target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%"class.eastl::bitvector" = type { %"class.eastl::vector", i64 }
%"class.eastl::vector" = type { %"struct.eastl::VectorBase" }
%"struct.eastl::VectorBase" = type { ptr, ptr, %"class.eastl::compressed_pair" }
%"class.eastl::compressed_pair" = type { %"class.eastl::compressed_pair_imp" }
%"class.eastl::compressed_pair_imp" = type { ptr }
%"class.eastl::bitvector_iterator" = type { %"class.eastl::bitvector_const_iterator" }
%"class.eastl::bitvector_const_iterator" = type { %"class.eastl::bitvector_reference" }
%"class.eastl::bitvector_reference" = type { ptr, i64 }
%"class.eastl::reverse_iterator" = type { %"class.eastl::bitvector_iterator" }
%"class.eastl::reverse_iterator.0" = type { %"class.eastl::bitvector_const_iterator" }
%"class.eastl::bitvector.1" = type { %"class.eastl::vector.2", i64 }
%"class.eastl::vector.2" = type { %"struct.eastl::VectorBase.3" }
%"struct.eastl::VectorBase.3" = type { ptr, ptr, %"class.eastl::compressed_pair.4" }
%"class.eastl::compressed_pair.4" = type { %"class.eastl::compressed_pair_imp.5" }
%"class.eastl::compressed_pair_imp.5" = type { ptr, %class.MallocAllocator }
%class.MallocAllocator = type { i32, i32, i64 }
%"class.eastl::bitvector.6" = type { %"class.eastl::vector.7", i64 }
%"class.eastl::vector.7" = type { %"struct.eastl::VectorBase.8" }
%"struct.eastl::VectorBase.8" = type { ptr, ptr, %"class.eastl::compressed_pair.9" }
%"class.eastl::compressed_pair.9" = type { %"class.eastl::compressed_pair_imp.10" }
%"class.eastl::compressed_pair_imp.10" = type { ptr }
%"class.eastl::bitvector_iterator.11" = type { %"class.eastl::bitvector_const_iterator.12" }
%"class.eastl::bitvector_const_iterator.12" = type { %"class.eastl::bitvector_reference.13" }
%"class.eastl::bitvector_reference.13" = type { ptr, i64 }
%"class.eastl::reverse_iterator.14" = type { %"class.eastl::bitvector_iterator.11" }
%"class.eastl::reverse_iterator.15" = type { %"class.eastl::bitvector_const_iterator.12" }
%"class.eastl::bitvector.16" = type { %"class.eastl::vector.17", i64 }
%"class.eastl::vector.17" = type { %"struct.eastl::VectorBase.18" }
%"struct.eastl::VectorBase.18" = type { ptr, ptr, %"class.eastl::compressed_pair.19" }
%"class.eastl::compressed_pair.19" = type { %"class.eastl::compressed_pair_imp.20" }
%"class.eastl::compressed_pair_imp.20" = type { ptr }
%"class.eastl::bitvector_iterator.21" = type { %"class.eastl::bitvector_const_iterator.22" }
%"class.eastl::bitvector_const_iterator.22" = type { %"class.eastl::bitvector_reference.23" }
%"class.eastl::bitvector_reference.23" = type { ptr, i64 }
%"class.eastl::reverse_iterator.24" = type { %"class.eastl::bitvector_iterator.21" }
%"class.eastl::reverse_iterator.25" = type { %"class.eastl::bitvector_const_iterator.22" }
%"class.eastl::bitvector.26" = type { %"class.eastl::vector.27", i64 }
%"class.eastl::vector.27" = type { %"struct.eastl::VectorBase.28" }
%"struct.eastl::VectorBase.28" = type { ptr, ptr, %"class.eastl::compressed_pair.29" }
%"class.eastl::compressed_pair.29" = type { %"class.eastl::compressed_pair_imp.30" }
%"class.eastl::compressed_pair_imp.30" = type { ptr }
%"class.eastl::bitvector_iterator.31" = type { %"class.eastl::bitvector_const_iterator.32" }
%"class.eastl::bitvector_const_iterator.32" = type { %"class.eastl::bitvector_reference.33" }
%"class.eastl::bitvector_reference.33" = type { ptr, i64 }
%"class.eastl::reverse_iterator.34" = type { %"class.eastl::bitvector_iterator.31" }
%"class.eastl::reverse_iterator.35" = type { %"class.eastl::bitvector_const_iterator.32" }
%"class.eastl::bitvector.36" = type { %"class.eastl::vector.37", i64 }
%"class.eastl::vector.37" = type { %"struct.eastl::VectorBase.38" }
%"struct.eastl::VectorBase.38" = type { ptr, ptr, %"class.eastl::compressed_pair.39" }
%"class.eastl::compressed_pair.39" = type { %"class.eastl::compressed_pair_imp.40" }
%"class.eastl::compressed_pair_imp.40" = type { ptr }
%"class.eastl::bitvector_iterator.41" = type { %"class.eastl::bitvector_const_iterator.42" }
%"class.eastl::bitvector_const_iterator.42" = type { %"class.eastl::bitvector_reference.43" }
%"class.eastl::bitvector_reference.43" = type { ptr, i64 }
%"class.eastl::reverse_iterator.44" = type { %"class.eastl::bitvector_iterator.41" }
%"class.eastl::reverse_iterator.45" = type { %"class.eastl::bitvector_const_iterator.42" }
%"class.eastl::allocator" = type { i8 }
%"class.eastl::basic_string" = type { %"class.eastl::compressed_pair.46" }
%"class.eastl::compressed_pair.46" = type { %"class.eastl::compressed_pair_imp.47" }
%"class.eastl::compressed_pair_imp.47" = type { %"struct.eastl::basic_string<char>::Layout" }
%"struct.eastl::basic_string<char>::Layout" = type { %union.anon }
%union.anon = type { %"struct.eastl::basic_string<char>::HeapLayout" }
%"struct.eastl::basic_string<char>::HeapLayout" = type { ptr, i64, i64 }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%"struct.eastl::basic_string<char>::SSOLayout" = type { [23 x i8], %"struct.eastl::basic_string<char>::SSOLayout::SSOSize" }
%"struct.eastl::basic_string<char>::SSOLayout::SSOSize" = type { i8 }
%"class.eastl::generic_iterator" = type { ptr }
%"class.eastl::move_iterator" = type { ptr }
%"class.eastl::generic_iterator.50" = type { ptr }
%"class.eastl::move_iterator.55" = type { ptr }
%"class.eastl::generic_iterator.58" = type { ptr }
%"class.eastl::move_iterator.63" = type { ptr }
%"class.eastl::generic_iterator.66" = type { ptr }
%"class.eastl::move_iterator.71" = type { ptr }
%"class.eastl::generic_iterator.74" = type { ptr }
%"class.eastl::move_iterator.79" = type { ptr }

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC5Ev = comdat any

$_ZN5eastl6vectorImNS_9allocatorEEC2Ev = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC5ERKS1_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEEC2ERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC5EmRKS1_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEEC2EmRKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC5EmbRKS1_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEEC2EmRKmRKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4swapERS4_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE4swapERS2_ = comdat any

$_ZN5eastl4swapImEEvRT_S2_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE5beginEv = comdat any

$_ZN5eastl18bitvector_iteratorImEC2EPmm = comdat any

$__clang_call_terminate = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv = comdat any

$_ZNK5eastl6vectorImNS_9allocatorEE5beginEv = comdat any

$_ZN5eastl24bitvector_const_iteratorImEC2EPKmm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6cbeginEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE3endEv = comdat any

$_ZNK5eastl18bitvector_iteratorImEmiEl = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv = comdat any

$_ZNK5eastl6vectorImNS_9allocatorEE3endEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorImEmiEl = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4cendEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6rbeginEv = comdat any

$_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_ = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6rbeginEv = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_ = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE7crbeginEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5crendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5emptyEv = comdat any

$_ZNK5eastl6vectorImNS_9allocatorEE5emptyEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv = comdat any

$_ZNK5eastl6vectorImNS_9allocatorEE4sizeEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8capacityEv = comdat any

$_ZNK5eastl6vectorImNS_9allocatorEE8capacityEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEmb = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE9push_backEb = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE6resizeEmRKm = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE6resizeEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE7reserveEm = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE7reserveEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE12set_capacityEm = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE12set_capacityEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE9push_backEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE9push_backEv = comdat any

$_ZN5eastl18bitvector_iteratorImEmmEv = comdat any

$_ZNK5eastl18bitvector_iteratorImEdeEv = comdat any

$_ZN5eastl19bitvector_referenceImEaSEb = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8pop_backEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE8pop_backEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5frontEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEEixEm = comdat any

$_ZN5eastl19bitvector_referenceImEC2EPmm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5frontEv = comdat any

$_ZNK5eastl6vectorImNS_9allocatorEEixEm = comdat any

$_ZNK5eastl19bitvector_referenceImEcvbEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4backEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4backEv = comdat any

$_ZN5eastl24bitvector_const_iteratorImEmmEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorImEdeEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4testEmb = comdat any

$_ZNK5eastl24bitvector_const_iteratorImEplEl = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3setEmb = comdat any

$_ZNK5eastl18bitvector_iteratorImEplEl = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE2atEm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE2atEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4dataEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE4dataEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4dataEv = comdat any

$_ZNK5eastl6vectorImNS_9allocatorEE4dataEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEb = comdat any

$_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv = comdat any

$_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE = comdat any

$_ZNK5eastl18bitvector_iteratorImEmiERKNS_24bitvector_const_iteratorImEE = comdat any

$_ZN5eastl18bitvector_iteratorImEaSEOS1_ = comdat any

$_ZN5eastl8MoveBitsImEEvNS_18bitvector_iteratorIT_EES3_S3_ = comdat any

$_ZN5eastl18bitvector_iteratorImEppEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEmb = comdat any

$_ZNK5eastl24bitvector_const_iteratorImEneERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEE = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEES6_ = comdat any

$_ZNK5eastl24bitvector_const_iteratorImEeqERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEE = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEppEv = comdat any

$_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEES8_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5clearEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE5clearEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE17reset_lose_memoryEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE17reset_lose_memoryEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv = comdat any

$_ZNK5eastl6vectorImNS_9allocatorEE8validateEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE17validate_iteratorENS_24bitvector_const_iteratorImEE = comdat any

$_ZNK5eastl24bitvector_const_iteratorImE8validateEPKmS3_m = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC5Ev = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorEC2Ev = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC5ERKS1_ = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorEC2ERKS1_ = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC5EmRKS1_ = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorEC2EmRKS1_ = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC5EmbRKS1_ = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorEC2EmRKmRKS1_ = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4swapERS4_ = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE4swapERS2_ = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE5beginEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv = comdat any

$_ZNK5eastl6vectorIm15MallocAllocatorE5beginEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6cbeginEv = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE3endEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv = comdat any

$_ZNK5eastl6vectorIm15MallocAllocatorE3endEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4cendEv = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6rbeginEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6rbeginEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE7crbeginEv = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5crendEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5emptyEv = comdat any

$_ZNK5eastl6vectorIm15MallocAllocatorE5emptyEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv = comdat any

$_ZNK5eastl6vectorIm15MallocAllocatorE4sizeEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8capacityEv = comdat any

$_ZNK5eastl6vectorIm15MallocAllocatorE8capacityEv = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEmb = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEm = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEb = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE6resizeEmRKm = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE6resizeEm = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE7reserveEm = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE7reserveEm = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE12set_capacityEm = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE12set_capacityEm = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEv = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE9push_backEv = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8pop_backEv = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE8pop_backEv = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5frontEv = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorEixEm = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5frontEv = comdat any

$_ZNK5eastl6vectorIm15MallocAllocatorEixEm = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4testEmb = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3setEmb = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE2atEm = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE2atEm = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4dataEv = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE4dataEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4dataEv = comdat any

$_ZNK5eastl6vectorIm15MallocAllocatorE4dataEv = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEb = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEmb = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEE = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEES6_ = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEE = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEES8_ = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5clearEv = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE5clearEv = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE17reset_lose_memoryEv = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE17reset_lose_memoryEv = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8validateEv = comdat any

$_ZNK5eastl6vectorIm15MallocAllocatorE8validateEv = comdat any

$_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE17validate_iteratorENS_24bitvector_const_iteratorImEE = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC5Ev = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEEC2Ev = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC5ERKS1_ = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEEC2ERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC5EmRKS1_ = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEEC2EmRKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC5EmbRKS1_ = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEEC2EmRKhRKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4swapERS4_ = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE4swapERS2_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE5beginEv = comdat any

$_ZN5eastl18bitvector_iteratorIhEC2EPhm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv = comdat any

$_ZNK5eastl6vectorIhNS_9allocatorEE5beginEv = comdat any

$_ZN5eastl24bitvector_const_iteratorIhEC2EPKhm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6cbeginEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE3endEv = comdat any

$_ZNK5eastl18bitvector_iteratorIhEmiEl = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv = comdat any

$_ZNK5eastl6vectorIhNS_9allocatorEE3endEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIhEmiEl = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4cendEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6rbeginEv = comdat any

$_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIhEEEC2ES2_ = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6rbeginEv = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEEC2ES2_ = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE7crbeginEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5crendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5emptyEv = comdat any

$_ZNK5eastl6vectorIhNS_9allocatorEE5emptyEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4sizeEv = comdat any

$_ZNK5eastl6vectorIhNS_9allocatorEE4sizeEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE8capacityEv = comdat any

$_ZNK5eastl6vectorIhNS_9allocatorEE8capacityEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6resizeEmb = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6resizeEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE9push_backEb = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE6resizeEmRKh = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE6resizeEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE7reserveEm = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE7reserveEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE12set_capacityEm = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE12set_capacityEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE9push_backEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE9push_backEv = comdat any

$_ZN5eastl18bitvector_iteratorIhEmmEv = comdat any

$_ZNK5eastl18bitvector_iteratorIhEdeEv = comdat any

$_ZN5eastl19bitvector_referenceIhEaSEb = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE8pop_backEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE8pop_backEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5frontEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEEixEm = comdat any

$_ZN5eastl19bitvector_referenceIhEC2EPhm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5frontEv = comdat any

$_ZNK5eastl6vectorIhNS_9allocatorEEixEm = comdat any

$_ZNK5eastl19bitvector_referenceIhEcvbEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4backEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4backEv = comdat any

$_ZN5eastl24bitvector_const_iteratorIhEmmEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIhEdeEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4testEmb = comdat any

$_ZNK5eastl24bitvector_const_iteratorIhEplEl = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3setEmb = comdat any

$_ZNK5eastl18bitvector_iteratorIhEplEl = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE2atEm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE2atEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEixEm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEixEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4dataEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE4dataEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4dataEv = comdat any

$_ZNK5eastl6vectorIhNS_9allocatorEE4dataEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6insertENS_24bitvector_const_iteratorIhEEb = comdat any

$_ZN5eastl24bitvector_const_iteratorIhE18get_reference_typeEv = comdat any

$_ZN5eastl18bitvector_iteratorIhEC2ERNS_19bitvector_referenceIhEE = comdat any

$_ZNK5eastl18bitvector_iteratorIhEmiERKNS_24bitvector_const_iteratorIhEE = comdat any

$_ZN5eastl18bitvector_iteratorIhEaSEOS1_ = comdat any

$_ZN5eastl8MoveBitsIhEEvNS_18bitvector_iteratorIT_EES3_S3_ = comdat any

$_ZN5eastl18bitvector_iteratorIhEppEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6insertENS_24bitvector_const_iteratorIhEEmb = comdat any

$_ZNK5eastl24bitvector_const_iteratorIhEneERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5eraseENS_24bitvector_const_iteratorIhEE = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5eraseENS_24bitvector_const_iteratorIhEES6_ = comdat any

$_ZNK5eastl24bitvector_const_iteratorIhEeqERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIhEEEE = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEEppEv = comdat any

$_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEE4baseEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIhEEEES8_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5clearEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE5clearEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE17reset_lose_memoryEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE17reset_lose_memoryEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE8validateEv = comdat any

$_ZNK5eastl6vectorIhNS_9allocatorEE8validateEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE17validate_iteratorENS_24bitvector_const_iteratorIhEE = comdat any

$_ZNK5eastl24bitvector_const_iteratorIhE8validateEPKhS3_m = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC5Ev = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEEC2Ev = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC5ERKS1_ = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEEC2ERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC5EmRKS1_ = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEEC2EmRKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC5EmbRKS1_ = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEEC2EmRKsRKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4swapERS4_ = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE4swapERS2_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE5beginEv = comdat any

$_ZN5eastl18bitvector_iteratorIsEC2EPsm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv = comdat any

$_ZNK5eastl6vectorIsNS_9allocatorEE5beginEv = comdat any

$_ZN5eastl24bitvector_const_iteratorIsEC2EPKsm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6cbeginEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE3endEv = comdat any

$_ZNK5eastl18bitvector_iteratorIsEmiEl = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv = comdat any

$_ZNK5eastl6vectorIsNS_9allocatorEE3endEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIsEmiEl = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4cendEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6rbeginEv = comdat any

$_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIsEEEC2ES2_ = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6rbeginEv = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEEC2ES2_ = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE7crbeginEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5crendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5emptyEv = comdat any

$_ZNK5eastl6vectorIsNS_9allocatorEE5emptyEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4sizeEv = comdat any

$_ZNK5eastl6vectorIsNS_9allocatorEE4sizeEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE8capacityEv = comdat any

$_ZNK5eastl6vectorIsNS_9allocatorEE8capacityEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6resizeEmb = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6resizeEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE9push_backEb = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE6resizeEmRKs = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE6resizeEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE7reserveEm = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE7reserveEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE12set_capacityEm = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE12set_capacityEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE9push_backEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE9push_backEv = comdat any

$_ZN5eastl18bitvector_iteratorIsEmmEv = comdat any

$_ZNK5eastl18bitvector_iteratorIsEdeEv = comdat any

$_ZN5eastl19bitvector_referenceIsEaSEb = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE8pop_backEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE8pop_backEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5frontEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEEixEm = comdat any

$_ZN5eastl19bitvector_referenceIsEC2EPsm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5frontEv = comdat any

$_ZNK5eastl6vectorIsNS_9allocatorEEixEm = comdat any

$_ZNK5eastl19bitvector_referenceIsEcvbEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4backEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4backEv = comdat any

$_ZN5eastl24bitvector_const_iteratorIsEmmEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIsEdeEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4testEmb = comdat any

$_ZNK5eastl24bitvector_const_iteratorIsEplEl = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3setEmb = comdat any

$_ZNK5eastl18bitvector_iteratorIsEplEl = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE2atEm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE2atEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEixEm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEixEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4dataEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE4dataEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4dataEv = comdat any

$_ZNK5eastl6vectorIsNS_9allocatorEE4dataEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6insertENS_24bitvector_const_iteratorIsEEb = comdat any

$_ZN5eastl24bitvector_const_iteratorIsE18get_reference_typeEv = comdat any

$_ZN5eastl18bitvector_iteratorIsEC2ERNS_19bitvector_referenceIsEE = comdat any

$_ZNK5eastl18bitvector_iteratorIsEmiERKNS_24bitvector_const_iteratorIsEE = comdat any

$_ZN5eastl18bitvector_iteratorIsEaSEOS1_ = comdat any

$_ZN5eastl8MoveBitsIsEEvNS_18bitvector_iteratorIT_EES3_S3_ = comdat any

$_ZN5eastl18bitvector_iteratorIsEppEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6insertENS_24bitvector_const_iteratorIsEEmb = comdat any

$_ZNK5eastl24bitvector_const_iteratorIsEneERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5eraseENS_24bitvector_const_iteratorIsEE = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5eraseENS_24bitvector_const_iteratorIsEES6_ = comdat any

$_ZNK5eastl24bitvector_const_iteratorIsEeqERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIsEEEE = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEEppEv = comdat any

$_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEE4baseEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIsEEEES8_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5clearEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE5clearEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE17reset_lose_memoryEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE17reset_lose_memoryEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE8validateEv = comdat any

$_ZNK5eastl6vectorIsNS_9allocatorEE8validateEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE17validate_iteratorENS_24bitvector_const_iteratorIsEE = comdat any

$_ZNK5eastl24bitvector_const_iteratorIsE8validateEPKsS3_m = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC5Ev = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEEC2Ev = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC5ERKS1_ = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEEC2ERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC5EmRKS1_ = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEEC2EmRKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC5EmbRKS1_ = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEEC2EmRKiRKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4swapERS4_ = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE4swapERS2_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE5beginEv = comdat any

$_ZN5eastl18bitvector_iteratorIiEC2EPim = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv = comdat any

$_ZNK5eastl6vectorIiNS_9allocatorEE5beginEv = comdat any

$_ZN5eastl24bitvector_const_iteratorIiEC2EPKim = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6cbeginEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE3endEv = comdat any

$_ZNK5eastl18bitvector_iteratorIiEmiEl = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv = comdat any

$_ZNK5eastl6vectorIiNS_9allocatorEE3endEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIiEmiEl = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4cendEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6rbeginEv = comdat any

$_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIiEEEC2ES2_ = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6rbeginEv = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEEC2ES2_ = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE7crbeginEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5crendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5emptyEv = comdat any

$_ZNK5eastl6vectorIiNS_9allocatorEE5emptyEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4sizeEv = comdat any

$_ZNK5eastl6vectorIiNS_9allocatorEE4sizeEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE8capacityEv = comdat any

$_ZNK5eastl6vectorIiNS_9allocatorEE8capacityEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6resizeEmb = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6resizeEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE9push_backEb = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE6resizeEmRKi = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE6resizeEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE7reserveEm = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE7reserveEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE12set_capacityEm = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE12set_capacityEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE9push_backEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE9push_backEv = comdat any

$_ZN5eastl18bitvector_iteratorIiEmmEv = comdat any

$_ZNK5eastl18bitvector_iteratorIiEdeEv = comdat any

$_ZN5eastl19bitvector_referenceIiEaSEb = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE8pop_backEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE8pop_backEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5frontEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEEixEm = comdat any

$_ZN5eastl19bitvector_referenceIiEC2EPim = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5frontEv = comdat any

$_ZNK5eastl6vectorIiNS_9allocatorEEixEm = comdat any

$_ZNK5eastl19bitvector_referenceIiEcvbEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4backEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4backEv = comdat any

$_ZN5eastl24bitvector_const_iteratorIiEmmEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIiEdeEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4testEmb = comdat any

$_ZNK5eastl24bitvector_const_iteratorIiEplEl = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3setEmb = comdat any

$_ZNK5eastl18bitvector_iteratorIiEplEl = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE2atEm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE2atEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEixEm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEixEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4dataEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE4dataEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4dataEv = comdat any

$_ZNK5eastl6vectorIiNS_9allocatorEE4dataEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6insertENS_24bitvector_const_iteratorIiEEb = comdat any

$_ZN5eastl24bitvector_const_iteratorIiE18get_reference_typeEv = comdat any

$_ZN5eastl18bitvector_iteratorIiEC2ERNS_19bitvector_referenceIiEE = comdat any

$_ZNK5eastl18bitvector_iteratorIiEmiERKNS_24bitvector_const_iteratorIiEE = comdat any

$_ZN5eastl18bitvector_iteratorIiEaSEOS1_ = comdat any

$_ZN5eastl8MoveBitsIiEEvNS_18bitvector_iteratorIT_EES3_S3_ = comdat any

$_ZN5eastl18bitvector_iteratorIiEppEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6insertENS_24bitvector_const_iteratorIiEEmb = comdat any

$_ZNK5eastl24bitvector_const_iteratorIiEneERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5eraseENS_24bitvector_const_iteratorIiEE = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5eraseENS_24bitvector_const_iteratorIiEES6_ = comdat any

$_ZNK5eastl24bitvector_const_iteratorIiEeqERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIiEEEE = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEEppEv = comdat any

$_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEE4baseEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIiEEEES8_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5clearEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE5clearEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE17reset_lose_memoryEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE17reset_lose_memoryEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE8validateEv = comdat any

$_ZNK5eastl6vectorIiNS_9allocatorEE8validateEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE17validate_iteratorENS_24bitvector_const_iteratorIiEE = comdat any

$_ZNK5eastl24bitvector_const_iteratorIiE8validateEPKiS3_m = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC5Ev = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEEC2Ev = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC5ERKS1_ = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEEC2ERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC5EmRKS1_ = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEEC2EmRKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC5EmbRKS1_ = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEEC2EmRKlRKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4swapERS4_ = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE4swapERS2_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE5beginEv = comdat any

$_ZN5eastl18bitvector_iteratorIlEC2EPlm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv = comdat any

$_ZNK5eastl6vectorIlNS_9allocatorEE5beginEv = comdat any

$_ZN5eastl24bitvector_const_iteratorIlEC2EPKlm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6cbeginEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE3endEv = comdat any

$_ZNK5eastl18bitvector_iteratorIlEmiEl = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv = comdat any

$_ZNK5eastl6vectorIlNS_9allocatorEE3endEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIlEmiEl = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4cendEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6rbeginEv = comdat any

$_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIlEEEC2ES2_ = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6rbeginEv = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEEC2ES2_ = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE7crbeginEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4rendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5crendEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5emptyEv = comdat any

$_ZNK5eastl6vectorIlNS_9allocatorEE5emptyEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4sizeEv = comdat any

$_ZNK5eastl6vectorIlNS_9allocatorEE4sizeEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE8capacityEv = comdat any

$_ZNK5eastl6vectorIlNS_9allocatorEE8capacityEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6resizeEmb = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6resizeEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE9push_backEb = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE6resizeEmRKl = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE6resizeEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE7reserveEm = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE7reserveEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE12set_capacityEm = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE12set_capacityEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE9push_backEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE9push_backEv = comdat any

$_ZN5eastl18bitvector_iteratorIlEmmEv = comdat any

$_ZNK5eastl18bitvector_iteratorIlEdeEv = comdat any

$_ZN5eastl19bitvector_referenceIlEaSEb = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE8pop_backEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE8pop_backEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5frontEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEEixEm = comdat any

$_ZN5eastl19bitvector_referenceIlEC2EPlm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5frontEv = comdat any

$_ZNK5eastl6vectorIlNS_9allocatorEEixEm = comdat any

$_ZNK5eastl19bitvector_referenceIlEcvbEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4backEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4backEv = comdat any

$_ZN5eastl24bitvector_const_iteratorIlEmmEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIlEdeEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4testEmb = comdat any

$_ZNK5eastl24bitvector_const_iteratorIlEplEl = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3setEmb = comdat any

$_ZNK5eastl18bitvector_iteratorIlEplEl = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE2atEm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE2atEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEixEm = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEixEm = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4dataEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE4dataEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4dataEv = comdat any

$_ZNK5eastl6vectorIlNS_9allocatorEE4dataEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6insertENS_24bitvector_const_iteratorIlEEb = comdat any

$_ZN5eastl24bitvector_const_iteratorIlE18get_reference_typeEv = comdat any

$_ZN5eastl18bitvector_iteratorIlEC2ERNS_19bitvector_referenceIlEE = comdat any

$_ZNK5eastl18bitvector_iteratorIlEmiERKNS_24bitvector_const_iteratorIlEE = comdat any

$_ZN5eastl18bitvector_iteratorIlEaSEOS1_ = comdat any

$_ZN5eastl8MoveBitsIlEEvNS_18bitvector_iteratorIT_EES3_S3_ = comdat any

$_ZN5eastl18bitvector_iteratorIlEppEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6insertENS_24bitvector_const_iteratorIlEEmb = comdat any

$_ZNK5eastl24bitvector_const_iteratorIlEneERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5eraseENS_24bitvector_const_iteratorIlEE = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5eraseENS_24bitvector_const_iteratorIlEES6_ = comdat any

$_ZNK5eastl24bitvector_const_iteratorIlEeqERKS1_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIlEEEE = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEEppEv = comdat any

$_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEE4baseEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIlEEEES8_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5clearEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE5clearEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE17reset_lose_memoryEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE17reset_lose_memoryEv = comdat any

$_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE13get_containerEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE8validateEv = comdat any

$_ZNK5eastl6vectorIlNS_9allocatorEE8validateEv = comdat any

$_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE17validate_iteratorENS_24bitvector_const_iteratorIlEE = comdat any

$_ZNK5eastl24bitvector_const_iteratorIlE8validateEPKlS3_m = comdat any

$_ZN5eastl9allocatorC2EPKc = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEEC2ENS2_11CtorSprintfEPKcz = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE4sizeEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEED2Ev = comdat any

$_ZN5eastl6vectorImNS_9allocatorEED2Ev = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev = comdat any

$_ZN15MallocAllocatorC2EPKc = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2ERKS4_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2IPbEET_S7_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2INS_18bitvector_iteratorImEEEET_S8_ = comdat any

$_ZN5eastleqINS_9allocatorEmNS_6vectorImS1_EEEEbRKNS_9bitvectorIT_T0_T1_EESA_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEaSERKS4_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6assignINS_18bitvector_iteratorImEEEEvT_S8_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6assignIPbEEvT_S7_ = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEED2Ev = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2EOS4_ = comdat any

$_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEaSEOS4_ = comdat any

$_ZN5eastl24bitvector_const_iteratorImEC2Ev = comdat any

$_ZN5eastl24bitvector_const_iteratorImEaSERKS1_ = comdat any

$_ZN5eastl24bitvector_const_iteratorImEppEv = comdat any

$_ZN5eastl24bitvector_const_iteratorImEpLEl = comdat any

$_ZN5eastl24bitvector_const_iteratorImEmIEl = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2Ev = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEaSERKS3_ = comdat any

$_ZN5eastlneINS_24bitvector_const_iteratorImEES2_EEbRKNS_16reverse_iteratorIT_EERKNS3_IT0_EE = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEmmEv = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEpLEl = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEmIEl = comdat any

$_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6assignIPbEEvT_S7_ = comdat any

$_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2INS_18bitvector_iteratorImEEEERKNS0_IT_EE = comdat any

$_ZN5eastl18bitvector_iteratorImEC2Ev = comdat any

$_ZN5eastl24bitvector_const_iteratorIhEaSERKS1_ = comdat any

$_ZN5eastl19bitvector_referenceIhE8CopyFromERKS1_ = comdat any

$_ZN5eastl24bitvector_const_iteratorIsEaSERKS1_ = comdat any

$_ZN5eastl19bitvector_referenceIsE8CopyFromERKS1_ = comdat any

$_ZN5eastl24bitvector_const_iteratorIiEaSERKS1_ = comdat any

$_ZN5eastl19bitvector_referenceIiE8CopyFromERKS1_ = comdat any

$_ZN5eastl24bitvector_const_iteratorIlEaSERKS1_ = comdat any

$_ZN5eastl19bitvector_referenceIlE8CopyFromERKS1_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEEC2ERKS2_ = comdat any

$_ZNK5eastl10VectorBaseImNS_9allocatorEE17internalAllocatorEv = comdat any

$_ZN5eastl10VectorBaseImNS_9allocatorEEC2EmRKS1_ = comdat any

$_ZN5eastl22uninitialized_copy_ptrIPmS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl10VectorBaseImNS_9allocatorEED2Ev = comdat any

$_ZNK5eastl15compressed_pairIPmNS_9allocatorEE6secondEv = comdat any

$_ZNK5eastl19compressed_pair_impIPmNS_9allocatorELi2EE6secondEv = comdat any

$_ZN5eastl15compressed_pairIPmNS_9allocatorEEC2ERKS2_ = comdat any

$_ZN5eastl10VectorBaseImNS_9allocatorEE10DoAllocateEm = comdat any

$_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv = comdat any

$_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EEC2ERKS2_ = comdat any

$_ZN5eastl9allocatorC2ERKS0_ = comdat any

$_ZN5eastl15allocate_memoryINS_9allocatorEEEPvRT_mmm = comdat any

$_ZN5eastl10VectorBaseImNS_9allocatorEE17internalAllocatorEv = comdat any

$_ZN5eastl9allocator8allocateEmi = comdat any

$_ZN5eastl9allocator8allocateEmmmi = comdat any

$_ZN5eastl15compressed_pairIPmNS_9allocatorEE6secondEv = comdat any

$_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EE6secondEv = comdat any

$_ZN5eastl15compressed_pairIPmNS_9allocatorEE5firstEv = comdat any

$_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EE5firstEv = comdat any

$_ZN5eastl18uninitialized_copyIPmS1_EET0_T_S3_S2_ = comdat any

$_ZN5eastl8Internal23uninitialized_copy_implILb1ELb1ELb1EE4implIPmS4_EET0_T_S6_S5_ = comdat any

$_ZN5eastl9addressofImEEPT_RS1_ = comdat any

$_ZN5eastl9allocator10deallocateEPvm = comdat any

$_ZN5eastl6vectorImNS_9allocatorEEaSERKS2_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE15DoClearCapacityEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE8DoAssignIPKmLb0EEEvT_S6_NS_17integral_constantIbLb0EEE = comdat any

$_ZN5eastl4moveIRNS_6vectorImNS_9allocatorEEEEEONS_16remove_referenceIT_E4typeEOS6_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEEC2EOS2_ = comdat any

$_ZN5eastl4moveIRNS_9allocatorEEEONS_16remove_referenceIT_E4typeEOS4_ = comdat any

$_ZN5eastl10VectorBaseImNS_9allocatorEEC2ERKS1_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE6DoSwapERS2_ = comdat any

$_ZN5eastl15compressed_pairIPmNS_9allocatorEEC2ES1_RKS2_ = comdat any

$_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EEC2ES1_RKS2_ = comdat any

$_ZN5eastl4swapIPmEEvRT_S3_ = comdat any

$_ZN5eastl4swapIPmNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_ = comdat any

$_ZN5eastl4moveIRPmEEONS_16remove_referenceIT_E4typeEOS4_ = comdat any

$_ZN5eastl15compressed_pairIPmNS_9allocatorEE4swapERS3_ = comdat any

$_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE = comdat any

$_ZN5eastl7cp_swapIPmEEvRT_S3_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE20DoAssignFromIteratorIPKmLb0EEEvT_S6_NS_26random_access_iterator_tagE = comdat any

$_ZN5eastl8distanceIPKmEENS_15iterator_traitsIT_E15difference_typeES4_S4_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE9DoReallocIPKmEEPmmT_S7_NS2_23should_move_or_copy_tagILb0EEE = comdat any

$_ZN5eastl8destructIPmEEvT_S2_ = comdat any

$_ZN5eastl10VectorBaseImNS_9allocatorEE6DoFreeEPmm = comdat any

$_ZN5eastl4copyIPKmPmEET0_T_S5_S4_ = comdat any

$_ZN5eastl22uninitialized_copy_ptrIPKmS2_PmEET1_T_T0_S4_ = comdat any

$_ZN5eastl13distance_implIPKmEENS_15iterator_traitsIT_E15difference_typeES4_S4_NS_26random_access_iterator_tagE = comdat any

$_ZN5eastl13destruct_implIPmEEvT_S2_NS_17integral_constantIbLb1EEE = comdat any

$_ZN5eastl23move_and_copy_unwrapperILb0EPKmPmEET1_T0_S5_S4_ = comdat any

$_ZN5eastl15unwrap_iteratorIPKmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS4_EE5valueEE13iterator_typeES4_ = comdat any

$_ZN5eastl21move_and_copy_chooserILb0EPKmPmEET1_T0_S5_S4_ = comdat any

$_ZN5eastl15unwrap_iteratorIPmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_ = comdat any

$_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyImEEPT_PKS4_S7_S5_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperIPmLb0EE13get_unwrappedES1_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperIPKmLb0EE13get_unwrappedES2_ = comdat any

$_ZN5eastl18uninitialized_copyIPKmPmEET0_T_S5_S4_ = comdat any

$_ZN5eastl8Internal23uninitialized_copy_implILb1ELb1ELb1EE4implIPKmPmEET0_T_S8_S7_ = comdat any

$_ZN5eastl9addressofIKmEEPT_RS2_ = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorED2Ev = comdat any

$_ZN5eastl10VectorBaseIm15MallocAllocatorED2Ev = comdat any

$_ZN5eastl10VectorBaseIm15MallocAllocatorE17internalAllocatorEv = comdat any

$_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv = comdat any

$_ZN5eastl15compressed_pairIPm15MallocAllocatorE6secondEv = comdat any

$_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE6secondEv = comdat any

$_ZN5eastl15compressed_pairIPm15MallocAllocatorE5firstEv = comdat any

$_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE5firstEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEEaSEOS2_ = comdat any

$_ZNK5eastl16reverse_iteratorINS_18bitvector_iteratorImEEE4baseEv = comdat any

$_ZN5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_EC2Ev = comdat any

$_ZN5eastl10CharStrlenIcEEmPKT_ = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE12AllocateSelfEm = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout7SetSizeEm = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE22append_sprintf_va_listEPKcP13__va_list_tag = comdat any

$_ZN5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EEC2Ev = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6LayoutC2Ev = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10ResetToSSOEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout11SSOBeginPtrEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10SetSSOSizeEm = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE10DoAllocateEm = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout15SetHeapBeginPtrEPc = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout15SetHeapCapacityEm = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout11SetHeapSizeEm = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE13get_allocatorEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE17internalAllocatorEv = comdat any

$_ZN5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_E6secondEv = comdat any

$_ZN5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EE6secondEv = comdat any

$_ZN5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_E5firstEv = comdat any

$_ZN5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EE5firstEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout20GetRemainingCapacityEv = comdat any

$_ZN5eastl9VsnprintfEPcmPKcP13__va_list_tag = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6resizeEm = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout8BeginPtrEv = comdat any

$_ZN5eastl7max_altImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_ = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout11GetHeapSizeEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout10GetSSOSizeEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout11CapacityPtrEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout15HeapCapacityPtrEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout14SSOCapacityPtrEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout15GetHeapCapacityEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout10HeapEndPtrEv = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout9SSOEndPtrEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10HeapEndPtrEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout9SSOEndPtrEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE5eraseEPKcS4_ = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6appendEmc = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE8capacityEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE7reserveEm = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE14GetNewCapacityEmm = comdat any

$_ZN5eastl28CharStringUninitializedFillNEPcmc = comdat any

$_ZNK5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv = comdat any

$_ZNK5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_E5firstEv = comdat any

$_ZNK5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EE5firstEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE12set_capacityEm = comdat any

$_ZN5eastl27CharStringUninitializedCopyIcEEPT_PKS1_S4_S2_ = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6DoFreeEPcm = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE14DeallocateSelfEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE12AllocateSelfEv = comdat any

$_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout12HeapBeginPtrEv = comdat any

$_ZN5eastl10VectorBaseImNS_9allocatorEEC2Ev = comdat any

$_ZN5eastl31uninitialized_value_construct_nIPmmEET_S2_T0_ = comdat any

$_ZN5eastl24uninitialized_fill_n_ptrImmEEvPT_T0_RKS1_ = comdat any

$_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPmvEEmmEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE = comdat any

$_ZN5eastl16generic_iteratorIPmvEC2ERKS1_ = comdat any

$_ZN5eastl6fill_nINS_16generic_iteratorIPmvEEmmEET_S4_T0_RKT1_ = comdat any

$_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPmvEEmmEET_S6_T0_RKT1_ = comdat any

$_ZNK5eastl16generic_iteratorIPmvEdeEv = comdat any

$_ZN5eastl16generic_iteratorIPmvEppEv = comdat any

$_ZN5eastl4moveIRmEEONS_16remove_referenceIT_E4typeEOS3_ = comdat any

$_ZN5eastl18bitvector_iteratorImEmIEl = comdat any

$_ZNK5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv = comdat any

$_ZNK5eastl15compressed_pairIPmNS_9allocatorEE5firstEv = comdat any

$_ZNK5eastl19compressed_pair_impIPmNS_9allocatorELi2EE5firstEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE17DoInsertValuesEndEmRKm = comdat any

$_ZN5eastl10VectorBaseImNS_9allocatorEE14GetNewCapacityEm = comdat any

$_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_ = comdat any

$_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl22uninitialized_move_ptrIPmS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPmvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE = comdat any

$_ZNK5eastl16generic_iteratorIPmvE4baseEv = comdat any

$_ZN5eastl4copyINS_16generic_iteratorIPmvEES3_EET0_T_S5_S4_ = comdat any

$_ZN5eastl23move_and_copy_unwrapperILb0EPmNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_ = comdat any

$_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPmvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_ = comdat any

$_ZN5eastl21move_and_copy_chooserILb0EPmS1_EET1_T0_S3_S2_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPmvEELb1EE13get_unwrappedES3_ = comdat any

$_ZNK5eastl16generic_iteratorIPmvE6unwrapEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE17DoInsertValuesEndEm = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE6DoGrowEm = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE13shrink_to_fitEv = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE9DoReallocIPmEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE = comdat any

$_ZN5eastl13move_iteratorIPmEC2ES1_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEEC2INS_13move_iteratorIPmEEEET_S7_RKS1_ = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE6DoInitINS_13move_iteratorIPmEEEEvT_S7_NS_17integral_constantIbLb0EEE = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPmEEEEvT_S7_NS_20forward_iterator_tagE = comdat any

$_ZN5eastl8distanceINS_13move_iteratorIPmEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_ = comdat any

$_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPmEES3_S2_EET1_T_T0_S4_ = comdat any

$_ZN5eastl13distance_implINS_13move_iteratorIPmEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE = comdat any

$_ZN5eastlmiIPmS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE = comdat any

$_ZNK5eastl13move_iteratorIPmE4baseEv = comdat any

$_ZN5eastl18uninitialized_copyINS_13move_iteratorIPmEES2_EET0_T_S5_S4_ = comdat any

$_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPmEES5_EET0_T_S8_S7_ = comdat any

$_ZN5eastlneIPmS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE = comdat any

$_ZNK5eastl13move_iteratorIPmEdeEv = comdat any

$_ZN5eastl13move_iteratorIPmEppEv = comdat any

$_ZN5eastleqIPmS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE = comdat any

$_ZN5eastl6vectorImNS_9allocatorEE16DoInsertValueEndIJmEEEvDpOT_ = comdat any

$_ZN5eastl7forwardImEEOT_RNS_16remove_referenceIS1_E4typeE = comdat any

$_ZN5eastl18bitvector_iteratorImEpLEl = comdat any

$_ZN5eastl24bitvector_const_iteratorImEC2ERKNS_19bitvector_referenceImEE = comdat any

$_ZNK5eastl24bitvector_const_iteratorImEmiERKS1_ = comdat any

$_ZN5eastl19bitvector_referenceImE8CopyFromERKS1_ = comdat any

$_ZNK5eastl24bitvector_const_iteratorImEleERKS1_ = comdat any

$_ZN5eastl19bitvector_referenceImEaSERKS1_ = comdat any

$_ZN5eastl10VectorBaseIm15MallocAllocatorEC2Ev = comdat any

$_ZN5eastl15compressed_pairIPm15MallocAllocatorEC2ES1_RKS2_ = comdat any

$_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EEC2ES1_RKS2_ = comdat any

$_ZN15MallocAllocatorC2ERKS_ = comdat any

$_ZN5eastl10VectorBaseIm15MallocAllocatorEC2ERKS1_ = comdat any

$_ZN5eastl10VectorBaseIm15MallocAllocatorEC2EmRKS1_ = comdat any

$_ZN5eastl15compressed_pairIPm15MallocAllocatorEC2ERKS2_ = comdat any

$_ZN5eastl10VectorBaseIm15MallocAllocatorE10DoAllocateEm = comdat any

$_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EEC2ERKS2_ = comdat any

$_ZN5eastl15allocate_memoryI15MallocAllocatorEEPvRT_mmm = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE6DoSwapERS2_ = comdat any

$_ZN5eastl4swapIPm15MallocAllocatorEEvRNS_15compressed_pairIT_T0_EES7_ = comdat any

$_ZN5eastl15compressed_pairIPm15MallocAllocatorE4swapERS3_ = comdat any

$_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE4swapERNS_15compressed_pairIS1_S2_EE = comdat any

$_ZN5eastl7cp_swapI15MallocAllocatorEEvRT_S3_ = comdat any

$_ZN15MallocAllocatoraSERKS_ = comdat any

$_ZNK5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv = comdat any

$_ZNK5eastl15compressed_pairIPm15MallocAllocatorE5firstEv = comdat any

$_ZNK5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE5firstEv = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE17DoInsertValuesEndEmRKm = comdat any

$_ZN5eastl10VectorBaseIm15MallocAllocatorE14GetNewCapacityEm = comdat any

$_ZN5eastl10VectorBaseIm15MallocAllocatorE6DoFreeEPmm = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE17DoInsertValuesEndEm = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE6DoGrowEm = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE13shrink_to_fitEv = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE9DoReallocIPmEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorEC2INS_13move_iteratorIPmEEEET_S7_RKS1_ = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE6DoInitINS_13move_iteratorIPmEEEEvT_S7_NS_17integral_constantIbLb0EEE = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE18DoInitFromIteratorINS_13move_iteratorIPmEEEEvT_S7_NS_20forward_iterator_tagE = comdat any

$_ZN5eastl6vectorIm15MallocAllocatorE16DoInsertValueEndIJmEEEvDpOT_ = comdat any

$_ZN5eastl10VectorBaseIhNS_9allocatorEEC2Ev = comdat any

$_ZN5eastl15compressed_pairIPhNS_9allocatorEEC2ES1_RKS2_ = comdat any

$_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EEC2ES1_RKS2_ = comdat any

$_ZN5eastl10VectorBaseIhNS_9allocatorEEC2ERKS1_ = comdat any

$_ZN5eastl10VectorBaseIhNS_9allocatorEEC2EmRKS1_ = comdat any

$_ZN5eastl31uninitialized_value_construct_nIPhmEET_S2_T0_ = comdat any

$_ZN5eastl10VectorBaseIhNS_9allocatorEED2Ev = comdat any

$_ZN5eastl15compressed_pairIPhNS_9allocatorEEC2ERKS2_ = comdat any

$_ZN5eastl10VectorBaseIhNS_9allocatorEE10DoAllocateEm = comdat any

$_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv = comdat any

$_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EEC2ERKS2_ = comdat any

$_ZN5eastl10VectorBaseIhNS_9allocatorEE17internalAllocatorEv = comdat any

$_ZN5eastl15compressed_pairIPhNS_9allocatorEE6secondEv = comdat any

$_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EE6secondEv = comdat any

$_ZN5eastl15compressed_pairIPhNS_9allocatorEE5firstEv = comdat any

$_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EE5firstEv = comdat any

$_ZN5eastl9addressofIhEEPT_RS1_ = comdat any

$_ZN5eastl24uninitialized_fill_n_ptrIhmEEvPT_T0_RKS1_ = comdat any

$_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPhvEEmhEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE = comdat any

$_ZN5eastl16generic_iteratorIPhvEC2ERKS1_ = comdat any

$_ZN5eastl6fill_nINS_16generic_iteratorIPhvEEmhEET_S4_T0_RKT1_ = comdat any

$_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPhvEEmhEET_S6_T0_RKT1_ = comdat any

$_ZNK5eastl16generic_iteratorIPhvEdeEv = comdat any

$_ZN5eastl16generic_iteratorIPhvEppEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE6DoSwapERS2_ = comdat any

$_ZN5eastl4swapIPhEEvRT_S3_ = comdat any

$_ZN5eastl4swapIPhNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_ = comdat any

$_ZN5eastl4moveIRPhEEONS_16remove_referenceIT_E4typeEOS4_ = comdat any

$_ZN5eastl15compressed_pairIPhNS_9allocatorEE4swapERS3_ = comdat any

$_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE = comdat any

$_ZN5eastl7cp_swapIPhEEvRT_S3_ = comdat any

$_ZN5eastl18bitvector_iteratorIhEmIEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIhEmIEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIhEpLEl = comdat any

$_ZNK5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv = comdat any

$_ZNK5eastl15compressed_pairIPhNS_9allocatorEE5firstEv = comdat any

$_ZNK5eastl19compressed_pair_impIPhNS_9allocatorELi2EE5firstEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE17DoInsertValuesEndEmRKh = comdat any

$_ZN5eastl8destructIPhEEvT_S2_ = comdat any

$_ZN5eastl10VectorBaseIhNS_9allocatorEE14GetNewCapacityEm = comdat any

$_ZN5eastl34uninitialized_move_ptr_if_noexceptIPhS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl10VectorBaseIhNS_9allocatorEE6DoFreeEPhm = comdat any

$_ZN5eastl22uninitialized_move_ptrIPhS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPhvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE = comdat any

$_ZNK5eastl16generic_iteratorIPhvE4baseEv = comdat any

$_ZN5eastl4copyINS_16generic_iteratorIPhvEES3_EET0_T_S5_S4_ = comdat any

$_ZN5eastl23move_and_copy_unwrapperILb0EPhNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_ = comdat any

$_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPhvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_ = comdat any

$_ZN5eastl21move_and_copy_chooserILb0EPhS1_EET1_T0_S3_S2_ = comdat any

$_ZN5eastl15unwrap_iteratorIPhEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_ = comdat any

$_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIhEEPT_PKS4_S7_S5_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperIPhLb0EE13get_unwrappedES1_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPhvEELb1EE13get_unwrappedES3_ = comdat any

$_ZNK5eastl16generic_iteratorIPhvE6unwrapEv = comdat any

$_ZN5eastl13destruct_implIPhEEvT_S2_NS_17integral_constantIbLb1EEE = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE17DoInsertValuesEndEm = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE6DoGrowEm = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE13shrink_to_fitEv = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE9DoReallocIPhEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE = comdat any

$_ZN5eastl13move_iteratorIPhEC2ES1_ = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEEC2INS_13move_iteratorIPhEEEET_S7_RKS1_ = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEED2Ev = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE6DoInitINS_13move_iteratorIPhEEEEvT_S7_NS_17integral_constantIbLb0EEE = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPhEEEEvT_S7_NS_20forward_iterator_tagE = comdat any

$_ZN5eastl8distanceINS_13move_iteratorIPhEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_ = comdat any

$_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPhEES3_S2_EET1_T_T0_S4_ = comdat any

$_ZN5eastl13distance_implINS_13move_iteratorIPhEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE = comdat any

$_ZN5eastlmiIPhS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE = comdat any

$_ZNK5eastl13move_iteratorIPhE4baseEv = comdat any

$_ZN5eastl18uninitialized_copyINS_13move_iteratorIPhEES2_EET0_T_S5_S4_ = comdat any

$_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPhEES5_EET0_T_S8_S7_ = comdat any

$_ZN5eastlneIPhS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE = comdat any

$_ZNK5eastl13move_iteratorIPhEdeEv = comdat any

$_ZN5eastl13move_iteratorIPhEppEv = comdat any

$_ZN5eastleqIPhS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE = comdat any

$_ZN5eastl6vectorIhNS_9allocatorEE16DoInsertValueEndIJhEEEvDpOT_ = comdat any

$_ZN5eastl7forwardIhEEOT_RNS_16remove_referenceIS1_E4typeE = comdat any

$_ZN5eastl18bitvector_iteratorIhEpLEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIhEC2ERKNS_19bitvector_referenceIhEE = comdat any

$_ZNK5eastl24bitvector_const_iteratorIhEmiERKS1_ = comdat any

$_ZN5eastl24bitvector_const_iteratorIhEppEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIhEleERKS1_ = comdat any

$_ZN5eastl19bitvector_referenceIhEaSERKS1_ = comdat any

$_ZN5eastl10VectorBaseIsNS_9allocatorEEC2Ev = comdat any

$_ZN5eastl15compressed_pairIPsNS_9allocatorEEC2ES1_RKS2_ = comdat any

$_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EEC2ES1_RKS2_ = comdat any

$_ZN5eastl10VectorBaseIsNS_9allocatorEEC2ERKS1_ = comdat any

$_ZN5eastl10VectorBaseIsNS_9allocatorEEC2EmRKS1_ = comdat any

$_ZN5eastl31uninitialized_value_construct_nIPsmEET_S2_T0_ = comdat any

$_ZN5eastl10VectorBaseIsNS_9allocatorEED2Ev = comdat any

$_ZN5eastl15compressed_pairIPsNS_9allocatorEEC2ERKS2_ = comdat any

$_ZN5eastl10VectorBaseIsNS_9allocatorEE10DoAllocateEm = comdat any

$_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv = comdat any

$_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EEC2ERKS2_ = comdat any

$_ZN5eastl10VectorBaseIsNS_9allocatorEE17internalAllocatorEv = comdat any

$_ZN5eastl15compressed_pairIPsNS_9allocatorEE6secondEv = comdat any

$_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EE6secondEv = comdat any

$_ZN5eastl15compressed_pairIPsNS_9allocatorEE5firstEv = comdat any

$_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EE5firstEv = comdat any

$_ZN5eastl9addressofIsEEPT_RS1_ = comdat any

$_ZN5eastl24uninitialized_fill_n_ptrIsmEEvPT_T0_RKS1_ = comdat any

$_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPsvEEmsEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE = comdat any

$_ZN5eastl16generic_iteratorIPsvEC2ERKS1_ = comdat any

$_ZN5eastl6fill_nINS_16generic_iteratorIPsvEEmsEET_S4_T0_RKT1_ = comdat any

$_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPsvEEmsEET_S6_T0_RKT1_ = comdat any

$_ZNK5eastl16generic_iteratorIPsvEdeEv = comdat any

$_ZN5eastl16generic_iteratorIPsvEppEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE6DoSwapERS2_ = comdat any

$_ZN5eastl4swapIPsEEvRT_S3_ = comdat any

$_ZN5eastl4swapIPsNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_ = comdat any

$_ZN5eastl4moveIRPsEEONS_16remove_referenceIT_E4typeEOS4_ = comdat any

$_ZN5eastl15compressed_pairIPsNS_9allocatorEE4swapERS3_ = comdat any

$_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE = comdat any

$_ZN5eastl7cp_swapIPsEEvRT_S3_ = comdat any

$_ZN5eastl18bitvector_iteratorIsEmIEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIsEmIEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIsEpLEl = comdat any

$_ZNK5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv = comdat any

$_ZNK5eastl15compressed_pairIPsNS_9allocatorEE5firstEv = comdat any

$_ZNK5eastl19compressed_pair_impIPsNS_9allocatorELi2EE5firstEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE17DoInsertValuesEndEmRKs = comdat any

$_ZN5eastl8destructIPsEEvT_S2_ = comdat any

$_ZN5eastl10VectorBaseIsNS_9allocatorEE14GetNewCapacityEm = comdat any

$_ZN5eastl34uninitialized_move_ptr_if_noexceptIPsS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl10VectorBaseIsNS_9allocatorEE6DoFreeEPsm = comdat any

$_ZN5eastl22uninitialized_move_ptrIPsS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPsvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE = comdat any

$_ZNK5eastl16generic_iteratorIPsvE4baseEv = comdat any

$_ZN5eastl4copyINS_16generic_iteratorIPsvEES3_EET0_T_S5_S4_ = comdat any

$_ZN5eastl23move_and_copy_unwrapperILb0EPsNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_ = comdat any

$_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPsvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_ = comdat any

$_ZN5eastl21move_and_copy_chooserILb0EPsS1_EET1_T0_S3_S2_ = comdat any

$_ZN5eastl15unwrap_iteratorIPsEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_ = comdat any

$_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIsEEPT_PKS4_S7_S5_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperIPsLb0EE13get_unwrappedES1_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPsvEELb1EE13get_unwrappedES3_ = comdat any

$_ZNK5eastl16generic_iteratorIPsvE6unwrapEv = comdat any

$_ZN5eastl13destruct_implIPsEEvT_S2_NS_17integral_constantIbLb1EEE = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE17DoInsertValuesEndEm = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE6DoGrowEm = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE13shrink_to_fitEv = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE9DoReallocIPsEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE = comdat any

$_ZN5eastl13move_iteratorIPsEC2ES1_ = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEEC2INS_13move_iteratorIPsEEEET_S7_RKS1_ = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEED2Ev = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE6DoInitINS_13move_iteratorIPsEEEEvT_S7_NS_17integral_constantIbLb0EEE = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPsEEEEvT_S7_NS_20forward_iterator_tagE = comdat any

$_ZN5eastl8distanceINS_13move_iteratorIPsEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_ = comdat any

$_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPsEES3_S2_EET1_T_T0_S4_ = comdat any

$_ZN5eastl13distance_implINS_13move_iteratorIPsEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE = comdat any

$_ZN5eastlmiIPsS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE = comdat any

$_ZNK5eastl13move_iteratorIPsE4baseEv = comdat any

$_ZN5eastl18uninitialized_copyINS_13move_iteratorIPsEES2_EET0_T_S5_S4_ = comdat any

$_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPsEES5_EET0_T_S8_S7_ = comdat any

$_ZN5eastlneIPsS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE = comdat any

$_ZNK5eastl13move_iteratorIPsEdeEv = comdat any

$_ZN5eastl13move_iteratorIPsEppEv = comdat any

$_ZN5eastleqIPsS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE = comdat any

$_ZN5eastl6vectorIsNS_9allocatorEE16DoInsertValueEndIJsEEEvDpOT_ = comdat any

$_ZN5eastl7forwardIsEEOT_RNS_16remove_referenceIS1_E4typeE = comdat any

$_ZN5eastl18bitvector_iteratorIsEpLEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIsEC2ERKNS_19bitvector_referenceIsEE = comdat any

$_ZNK5eastl24bitvector_const_iteratorIsEmiERKS1_ = comdat any

$_ZN5eastl24bitvector_const_iteratorIsEppEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIsEleERKS1_ = comdat any

$_ZN5eastl19bitvector_referenceIsEaSERKS1_ = comdat any

$_ZN5eastl10VectorBaseIiNS_9allocatorEEC2Ev = comdat any

$_ZN5eastl15compressed_pairIPiNS_9allocatorEEC2ES1_RKS2_ = comdat any

$_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EEC2ES1_RKS2_ = comdat any

$_ZN5eastl10VectorBaseIiNS_9allocatorEEC2ERKS1_ = comdat any

$_ZN5eastl10VectorBaseIiNS_9allocatorEEC2EmRKS1_ = comdat any

$_ZN5eastl31uninitialized_value_construct_nIPimEET_S2_T0_ = comdat any

$_ZN5eastl10VectorBaseIiNS_9allocatorEED2Ev = comdat any

$_ZN5eastl15compressed_pairIPiNS_9allocatorEEC2ERKS2_ = comdat any

$_ZN5eastl10VectorBaseIiNS_9allocatorEE10DoAllocateEm = comdat any

$_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv = comdat any

$_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EEC2ERKS2_ = comdat any

$_ZN5eastl10VectorBaseIiNS_9allocatorEE17internalAllocatorEv = comdat any

$_ZN5eastl15compressed_pairIPiNS_9allocatorEE6secondEv = comdat any

$_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EE6secondEv = comdat any

$_ZN5eastl15compressed_pairIPiNS_9allocatorEE5firstEv = comdat any

$_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EE5firstEv = comdat any

$_ZN5eastl9addressofIiEEPT_RS1_ = comdat any

$_ZN5eastl24uninitialized_fill_n_ptrIimEEvPT_T0_RKS1_ = comdat any

$_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPivEEmiEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE = comdat any

$_ZN5eastl16generic_iteratorIPivEC2ERKS1_ = comdat any

$_ZN5eastl6fill_nINS_16generic_iteratorIPivEEmiEET_S4_T0_RKT1_ = comdat any

$_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPivEEmiEET_S6_T0_RKT1_ = comdat any

$_ZNK5eastl16generic_iteratorIPivEdeEv = comdat any

$_ZN5eastl16generic_iteratorIPivEppEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE6DoSwapERS2_ = comdat any

$_ZN5eastl4swapIPiEEvRT_S3_ = comdat any

$_ZN5eastl4swapIPiNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_ = comdat any

$_ZN5eastl4moveIRPiEEONS_16remove_referenceIT_E4typeEOS4_ = comdat any

$_ZN5eastl15compressed_pairIPiNS_9allocatorEE4swapERS3_ = comdat any

$_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE = comdat any

$_ZN5eastl7cp_swapIPiEEvRT_S3_ = comdat any

$_ZN5eastl18bitvector_iteratorIiEmIEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIiEmIEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIiEpLEl = comdat any

$_ZNK5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv = comdat any

$_ZNK5eastl15compressed_pairIPiNS_9allocatorEE5firstEv = comdat any

$_ZNK5eastl19compressed_pair_impIPiNS_9allocatorELi2EE5firstEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE17DoInsertValuesEndEmRKi = comdat any

$_ZN5eastl8destructIPiEEvT_S2_ = comdat any

$_ZN5eastl10VectorBaseIiNS_9allocatorEE14GetNewCapacityEm = comdat any

$_ZN5eastl34uninitialized_move_ptr_if_noexceptIPiS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl10VectorBaseIiNS_9allocatorEE6DoFreeEPim = comdat any

$_ZN5eastl22uninitialized_move_ptrIPiS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPivEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE = comdat any

$_ZNK5eastl16generic_iteratorIPivE4baseEv = comdat any

$_ZN5eastl4copyINS_16generic_iteratorIPivEES3_EET0_T_S5_S4_ = comdat any

$_ZN5eastl23move_and_copy_unwrapperILb0EPiNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_ = comdat any

$_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPivEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_ = comdat any

$_ZN5eastl21move_and_copy_chooserILb0EPiS1_EET1_T0_S3_S2_ = comdat any

$_ZN5eastl15unwrap_iteratorIPiEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_ = comdat any

$_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIiEEPT_PKS4_S7_S5_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperIPiLb0EE13get_unwrappedES1_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPivEELb1EE13get_unwrappedES3_ = comdat any

$_ZNK5eastl16generic_iteratorIPivE6unwrapEv = comdat any

$_ZN5eastl13destruct_implIPiEEvT_S2_NS_17integral_constantIbLb1EEE = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE17DoInsertValuesEndEm = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE6DoGrowEm = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE13shrink_to_fitEv = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE9DoReallocIPiEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE = comdat any

$_ZN5eastl13move_iteratorIPiEC2ES1_ = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEEC2INS_13move_iteratorIPiEEEET_S7_RKS1_ = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEED2Ev = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE6DoInitINS_13move_iteratorIPiEEEEvT_S7_NS_17integral_constantIbLb0EEE = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPiEEEEvT_S7_NS_20forward_iterator_tagE = comdat any

$_ZN5eastl8distanceINS_13move_iteratorIPiEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_ = comdat any

$_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPiEES3_S2_EET1_T_T0_S4_ = comdat any

$_ZN5eastl13distance_implINS_13move_iteratorIPiEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE = comdat any

$_ZN5eastlmiIPiS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE = comdat any

$_ZNK5eastl13move_iteratorIPiE4baseEv = comdat any

$_ZN5eastl18uninitialized_copyINS_13move_iteratorIPiEES2_EET0_T_S5_S4_ = comdat any

$_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPiEES5_EET0_T_S8_S7_ = comdat any

$_ZN5eastlneIPiS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE = comdat any

$_ZNK5eastl13move_iteratorIPiEdeEv = comdat any

$_ZN5eastl13move_iteratorIPiEppEv = comdat any

$_ZN5eastleqIPiS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE = comdat any

$_ZN5eastl6vectorIiNS_9allocatorEE16DoInsertValueEndIJiEEEvDpOT_ = comdat any

$_ZN5eastl7forwardIiEEOT_RNS_16remove_referenceIS1_E4typeE = comdat any

$_ZN5eastl18bitvector_iteratorIiEpLEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIiEC2ERKNS_19bitvector_referenceIiEE = comdat any

$_ZNK5eastl24bitvector_const_iteratorIiEmiERKS1_ = comdat any

$_ZN5eastl24bitvector_const_iteratorIiEppEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIiEleERKS1_ = comdat any

$_ZN5eastl19bitvector_referenceIiEaSERKS1_ = comdat any

$_ZN5eastl10VectorBaseIlNS_9allocatorEEC2Ev = comdat any

$_ZN5eastl15compressed_pairIPlNS_9allocatorEEC2ES1_RKS2_ = comdat any

$_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EEC2ES1_RKS2_ = comdat any

$_ZN5eastl10VectorBaseIlNS_9allocatorEEC2ERKS1_ = comdat any

$_ZN5eastl10VectorBaseIlNS_9allocatorEEC2EmRKS1_ = comdat any

$_ZN5eastl31uninitialized_value_construct_nIPlmEET_S2_T0_ = comdat any

$_ZN5eastl10VectorBaseIlNS_9allocatorEED2Ev = comdat any

$_ZN5eastl15compressed_pairIPlNS_9allocatorEEC2ERKS2_ = comdat any

$_ZN5eastl10VectorBaseIlNS_9allocatorEE10DoAllocateEm = comdat any

$_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv = comdat any

$_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EEC2ERKS2_ = comdat any

$_ZN5eastl10VectorBaseIlNS_9allocatorEE17internalAllocatorEv = comdat any

$_ZN5eastl15compressed_pairIPlNS_9allocatorEE6secondEv = comdat any

$_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EE6secondEv = comdat any

$_ZN5eastl15compressed_pairIPlNS_9allocatorEE5firstEv = comdat any

$_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EE5firstEv = comdat any

$_ZN5eastl9addressofIlEEPT_RS1_ = comdat any

$_ZN5eastl24uninitialized_fill_n_ptrIlmEEvPT_T0_RKS1_ = comdat any

$_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPlvEEmlEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE = comdat any

$_ZN5eastl16generic_iteratorIPlvEC2ERKS1_ = comdat any

$_ZN5eastl6fill_nINS_16generic_iteratorIPlvEEmlEET_S4_T0_RKT1_ = comdat any

$_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPlvEEmlEET_S6_T0_RKT1_ = comdat any

$_ZNK5eastl16generic_iteratorIPlvEdeEv = comdat any

$_ZN5eastl16generic_iteratorIPlvEppEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE6DoSwapERS2_ = comdat any

$_ZN5eastl4swapIPlEEvRT_S3_ = comdat any

$_ZN5eastl4swapIPlNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_ = comdat any

$_ZN5eastl4moveIRPlEEONS_16remove_referenceIT_E4typeEOS4_ = comdat any

$_ZN5eastl15compressed_pairIPlNS_9allocatorEE4swapERS3_ = comdat any

$_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE = comdat any

$_ZN5eastl7cp_swapIPlEEvRT_S3_ = comdat any

$_ZN5eastl18bitvector_iteratorIlEmIEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIlEmIEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIlEpLEl = comdat any

$_ZNK5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv = comdat any

$_ZNK5eastl15compressed_pairIPlNS_9allocatorEE5firstEv = comdat any

$_ZNK5eastl19compressed_pair_impIPlNS_9allocatorELi2EE5firstEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE17DoInsertValuesEndEmRKl = comdat any

$_ZN5eastl8destructIPlEEvT_S2_ = comdat any

$_ZN5eastl10VectorBaseIlNS_9allocatorEE14GetNewCapacityEm = comdat any

$_ZN5eastl34uninitialized_move_ptr_if_noexceptIPlS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl10VectorBaseIlNS_9allocatorEE6DoFreeEPlm = comdat any

$_ZN5eastl22uninitialized_move_ptrIPlS1_S1_EET1_T_T0_S2_ = comdat any

$_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPlvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE = comdat any

$_ZNK5eastl16generic_iteratorIPlvE4baseEv = comdat any

$_ZN5eastl4copyINS_16generic_iteratorIPlvEES3_EET0_T_S5_S4_ = comdat any

$_ZN5eastl23move_and_copy_unwrapperILb0EPlNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_ = comdat any

$_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPlvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_ = comdat any

$_ZN5eastl21move_and_copy_chooserILb0EPlS1_EET1_T0_S3_S2_ = comdat any

$_ZN5eastl15unwrap_iteratorIPlEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_ = comdat any

$_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIlEEPT_PKS4_S7_S5_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperIPlLb0EE13get_unwrappedES1_ = comdat any

$_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPlvEELb1EE13get_unwrappedES3_ = comdat any

$_ZNK5eastl16generic_iteratorIPlvE6unwrapEv = comdat any

$_ZN5eastl13destruct_implIPlEEvT_S2_NS_17integral_constantIbLb1EEE = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE17DoInsertValuesEndEm = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE6DoGrowEm = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE13shrink_to_fitEv = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE9DoReallocIPlEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE = comdat any

$_ZN5eastl13move_iteratorIPlEC2ES1_ = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEEC2INS_13move_iteratorIPlEEEET_S7_RKS1_ = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEED2Ev = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE6DoInitINS_13move_iteratorIPlEEEEvT_S7_NS_17integral_constantIbLb0EEE = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPlEEEEvT_S7_NS_20forward_iterator_tagE = comdat any

$_ZN5eastl8distanceINS_13move_iteratorIPlEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_ = comdat any

$_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPlEES3_S2_EET1_T_T0_S4_ = comdat any

$_ZN5eastl13distance_implINS_13move_iteratorIPlEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE = comdat any

$_ZN5eastlmiIPlS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE = comdat any

$_ZNK5eastl13move_iteratorIPlE4baseEv = comdat any

$_ZN5eastl18uninitialized_copyINS_13move_iteratorIPlEES2_EET0_T_S5_S4_ = comdat any

$_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPlEES5_EET0_T_S8_S7_ = comdat any

$_ZN5eastlneIPlS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE = comdat any

$_ZNK5eastl13move_iteratorIPlEdeEv = comdat any

$_ZN5eastl13move_iteratorIPlEppEv = comdat any

$_ZN5eastleqIPlS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE = comdat any

$_ZN5eastl6vectorIlNS_9allocatorEE16DoInsertValueEndIJlEEEvDpOT_ = comdat any

$_ZN5eastl7forwardIlEEOT_RNS_16remove_referenceIS1_E4typeE = comdat any

$_ZN5eastl18bitvector_iteratorIlEpLEl = comdat any

$_ZN5eastl24bitvector_const_iteratorIlEC2ERKNS_19bitvector_referenceIlEE = comdat any

$_ZNK5eastl24bitvector_const_iteratorIlEmiERKS1_ = comdat any

$_ZN5eastl24bitvector_const_iteratorIlEppEv = comdat any

$_ZNK5eastl24bitvector_const_iteratorIlEleERKS1_ = comdat any

$_ZN5eastl19bitvector_referenceIlEaSERKS1_ = comdat any

$_ZN5eastl5equalINS_24bitvector_const_iteratorImEES2_EEbT_S3_T0_ = comdat any

@.str = private unnamed_addr constant [33 x i8] c"%p %p %p %p %p %p %p %p %p %p %p\00", align 1
@.str.1 = private unnamed_addr constant [119 x i8] c"generated/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/eastl/EASTL/test/source/TestBitVector.cpp\00", align 1
@.str.2 = private unnamed_addr constant [22 x i8] c"sAddresses.size() > 0\00", align 1
@.str.3 = private unnamed_addr constant [16 x i8] c"EASTL bitvector\00", align 1
@__const._Z13TestBitVectorv.boolArray = private unnamed_addr constant [3 x i8] c"\01\00\01", align 1
@.str.4 = private unnamed_addr constant [15 x i8] c"bv0.validate()\00", align 1
@.str.5 = private unnamed_addr constant [12 x i8] c"bv0.empty()\00", align 1
@.str.6 = private unnamed_addr constant [15 x i8] c"bv1.validate()\00", align 1
@.str.7 = private unnamed_addr constant [12 x i8] c"bv1.empty()\00", align 1
@.str.8 = private unnamed_addr constant [15 x i8] c"bv2.validate()\00", align 1
@.str.9 = private unnamed_addr constant [18 x i8] c"bv2.size() == 200\00", align 1
@.str.10 = private unnamed_addr constant [16 x i8] c"bv2[i] == false\00", align 1
@.str.11 = private unnamed_addr constant [15 x i8] c"bv3.validate()\00", align 1
@.str.12 = private unnamed_addr constant [18 x i8] c"bv3.size() == 300\00", align 1
@.str.13 = private unnamed_addr constant [15 x i8] c"bv3[i] == true\00", align 1
@.str.14 = private unnamed_addr constant [15 x i8] c"bv4.validate()\00", align 1
@.str.15 = private unnamed_addr constant [18 x i8] c"bv4.size() == 400\00", align 1
@.str.16 = private unnamed_addr constant [16 x i8] c"bv4[i] == false\00", align 1
@.str.17 = private unnamed_addr constant [15 x i8] c"bv5.validate()\00", align 1
@.str.18 = private unnamed_addr constant [11 x i8] c"bv5 == bv2\00", align 1
@.str.19 = private unnamed_addr constant [16 x i8] c"bv5[i] == false\00", align 1
@.str.20 = private unnamed_addr constant [15 x i8] c"bv6.validate()\00", align 1
@.str.21 = private unnamed_addr constant [38 x i8] c"bv6.size() == EAArrayCount(boolArray)\00", align 1
@.str.22 = private unnamed_addr constant [23 x i8] c"bv6[i] == boolArray[i]\00", align 1
@.str.23 = private unnamed_addr constant [15 x i8] c"bv7.validate()\00", align 1
@.str.24 = private unnamed_addr constant [25 x i8] c"bv7.size() == bv3.size()\00", align 1
@.str.25 = private unnamed_addr constant [17 x i8] c"bv7[j] == bv3[j]\00", align 1
@.str.26 = private unnamed_addr constant [11 x i8] c"bv7 == bv3\00", align 1
@.str.27 = private unnamed_addr constant [17 x i8] c"bv3[i] == bv7[i]\00", align 1
@.str.28 = private unnamed_addr constant [18 x i8] c"bv3.size() == 200\00", align 1
@.str.29 = private unnamed_addr constant [16 x i8] c"bv3[i] == false\00", align 1
@.str.30 = private unnamed_addr constant [18 x i8] c"bv2.size() == 300\00", align 1
@.str.31 = private unnamed_addr constant [15 x i8] c"bv2[i] == true\00", align 1
@.str.32 = private unnamed_addr constant [11 x i8] c"bv6 == bv7\00", align 1
@.str.33 = private unnamed_addr constant [11 x i8] c"bv0 == bv3\00", align 1
@.str.34 = private unnamed_addr constant [67 x i8] c"bv0 == bitvector<>(boolArray, boolArray + EAArrayCount(boolArray))\00", align 1
@.str.35 = private unnamed_addr constant [23 x i8] c"bv0.begin()==bv0.end()\00", align 1
@.str.36 = private unnamed_addr constant [36 x i8] c"bv3[i] == (i % kTestIncrement == 0)\00", align 1
@.str.37 = private unnamed_addr constant [36 x i8] c"bv4[i] == (i % kTestIncrement == 0)\00", align 1
@__const._Z13TestBitVectorv.boolArray.38 = private unnamed_addr constant [6 x i8] c"\01\00\01\01\00\01", align 1
@.str.39 = private unnamed_addr constant [22 x i8] c"value == boolArray[i]\00", align 1
@.str.40 = private unnamed_addr constant [16 x i8] c"bv0.size() == 0\00", align 1
@.str.41 = private unnamed_addr constant [20 x i8] c"bv0.capacity() == 0\00", align 1
@__const._Z13TestBitVectorv.boolArray.42 = private unnamed_addr constant [3 x i8] c"\00\01\01", align 1
@.str.43 = private unnamed_addr constant [13 x i8] c"!bv0.empty()\00", align 1
@.str.44 = private unnamed_addr constant [38 x i8] c"bv0.size() == EAArrayCount(boolArray)\00", align 1
@.str.45 = private unnamed_addr constant [84 x i8] c"(bv0.capacity() > 0) && (bv0.capacity() <= (8 * sizeof(bitvector<>::element_type)))\00", align 1
@.str.46 = private unnamed_addr constant [21 x i8] c"bv0.front() == false\00", align 1
@.str.47 = private unnamed_addr constant [19 x i8] c"bv0.back() == true\00", align 1
@.str.48 = private unnamed_addr constant [20 x i8] c"bv0.front() == true\00", align 1
@.str.49 = private unnamed_addr constant [50 x i8] c"(bv0.capacity() >= 17) && (bv0.capacity() <= 100)\00", align 1
@_ZN15MallocAllocator14mAllocCountAllE = external global i32, align 4
@.str.50 = private unnamed_addr constant [52 x i8] c"allocCountBefore == MallocAllocator::mAllocCountAll\00", align 1
@.str.51 = private unnamed_addr constant [29 x i8] c"bv0.capacity() >= bv0.size()\00", align 1
@.str.52 = private unnamed_addr constant [22 x i8] c"bv0.capacity() >= 800\00", align 1
@.str.53 = private unnamed_addr constant [26 x i8] c"bv0[bv0.size()-1] == true\00", align 1
@.str.54 = private unnamed_addr constant [27 x i8] c"bv0[bv0.size()-2] == false\00", align 1
@.str.55 = private unnamed_addr constant [26 x i8] c"bv0[bv0.size()-3] == true\00", align 1
@.str.56 = private unnamed_addr constant [29 x i8] c"bv0.at(bv0.size()-1) == true\00", align 1
@.str.57 = private unnamed_addr constant [30 x i8] c"bv0.at(bv0.size()-2) == false\00", align 1
@.str.58 = private unnamed_addr constant [29 x i8] c"bv0.at(bv0.size()-3) == true\00", align 1
@.str.59 = private unnamed_addr constant [27 x i8] c"bv0.test(0, false) == true\00", align 1
@.str.60 = private unnamed_addr constant [29 x i8] c"bv0.test(17, false) == false\00", align 1
@.str.61 = private unnamed_addr constant [27 x i8] c"bv0.test(17, true) == true\00", align 1
@.str.62 = private unnamed_addr constant [27 x i8] c"bv0.test(3, true) == false\00", align 1
@.str.63 = private unnamed_addr constant [29 x i8] c"bv0.test(100, false) == true\00", align 1
@.str.64 = private unnamed_addr constant [29 x i8] c"!bv0.get_container().empty()\00", align 1
@.str.65 = private unnamed_addr constant [38 x i8] c"bv0.validate_iterator(it) == isf_none\00", align 1
@.str.66 = private unnamed_addr constant [77 x i8] c"bv0.validate_iterator(it) == (isf_valid | isf_current | isf_can_dereference)\00", align 1
@.str.67 = private unnamed_addr constant [55 x i8] c"bv0.validate_iterator(it) == (isf_valid | isf_current)\00", align 1
@.str.68 = private unnamed_addr constant [16 x i8] c"bv0[5] == false\00", align 1
@.str.69 = private unnamed_addr constant [15 x i8] c"bv0[5] == true\00", align 1
@.str.70 = private unnamed_addr constant [40 x i8] c"(bv0[5] == false) && (bv0[11] == false)\00", align 1
@.str.71 = private unnamed_addr constant [20 x i8] c"bv0.back() == false\00", align 1
@.str.72 = private unnamed_addr constant [41 x i8] c"(bv0[10] == false) && (bv0[11] == false)\00", align 1
@.str.73 = private unnamed_addr constant [40 x i8] c"(bv0[10] == false) && (bv0[11] == true)\00", align 1
@.str.74 = private unnamed_addr constant [15 x i8] c"bv0[5] == bv06\00", align 1
@.str.75 = private unnamed_addr constant [42 x i8] c"(bv0.size() == 9) && (bv0.back() == true)\00", align 1
@.str.76 = private unnamed_addr constant [19 x i8] c"bv0.data() != NULL\00", align 1
@.str.77 = private unnamed_addr constant [19 x i8] c"bv0.data() == NULL\00", align 1
@_ZN15MallocAllocator16mpLastAllocationE = external global ptr, align 8
@.str.78 = private unnamed_addr constant [13 x i8] c"EASTL vector\00", align 1

@_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1Ev = weak_odr dso_local unnamed_addr alias void (ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2Ev
@_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1ERKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2ERKS1_
@_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1EmRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2EmRKS1_
@_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1EmbRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, i1, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2EmbRKS1_
@_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC1Ev = weak_odr dso_local unnamed_addr alias void (ptr), ptr @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC2Ev
@_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC1ERKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, ptr), ptr @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC2ERKS1_
@_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC1EmRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, ptr), ptr @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC2EmRKS1_
@_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC1EmbRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, i1, ptr), ptr @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC2EmbRKS1_
@_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC1Ev = weak_odr dso_local unnamed_addr alias void (ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC2Ev
@_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC1ERKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC2ERKS1_
@_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC1EmRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC2EmRKS1_
@_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC1EmbRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, i1, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC2EmbRKS1_
@_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC1Ev = weak_odr dso_local unnamed_addr alias void (ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC2Ev
@_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC1ERKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC2ERKS1_
@_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC1EmRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC2EmRKS1_
@_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC1EmbRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, i1, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC2EmbRKS1_
@_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC1Ev = weak_odr dso_local unnamed_addr alias void (ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC2Ev
@_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC1ERKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC2ERKS1_
@_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC1EmRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC2EmRKS1_
@_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC1EmbRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, i1, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC2EmbRKS1_
@_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC1Ev = weak_odr dso_local unnamed_addr alias void (ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC2Ev
@_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC1ERKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC2ERKS1_
@_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC1EmRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC2EmRKS1_
@_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC1EmbRKS1_ = weak_odr dso_local unnamed_addr alias void (ptr, i64, i1, ptr), ptr @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC2EmbRKS1_

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC5Ev) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #1 comdat($_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC5ERKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 1 dereferenceable(1) %0) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  invoke void @_ZN5eastl10VectorBaseImNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC5EmRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %div, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %2 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %2, 64
  %sub2 = sub i64 64, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %3 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %3, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %call = invoke noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPmmEET_S2_T0_(ptr noundef %2, i64 noundef %3)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin2, align 8
  %5 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %4, i64 %5
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %6 = landingpad { ptr, i32 }
          cleanup
  %7 = extractvalue { ptr, i32 } %6, 0
  store ptr %7, ptr %exn.slot, align 8
  %8 = extractvalue { ptr, i32 } %6, 1
  store i32 %8, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC5EmbRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %allocator.addr = alloca ptr, align 8
  %ref.tmp = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i64 -1, i64 0
  store i64 %cond, ptr %ref.tmp, align 8
  %2 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEEC2EmRKmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %div, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 1 dereferenceable(1) %2)
  %3 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %3, 64
  %sub2 = sub i64 64, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %4 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %4, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEEC2EmRKmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %4 = load ptr, ptr %value.addr, align 8
  invoke void @_ZN5eastl24uninitialized_fill_n_ptrImmEEvPT_T0_RKS1_(ptr noundef %2, i64 noundef %3, ptr noundef nonnull align 8 dereferenceable(8) %4)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin2, align 8
  %6 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %5, i64 %6
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %7 = landingpad { ptr, i32 }
          cleanup
  %8 = extractvalue { ptr, i32 } %7, 0
  store ptr %8, ptr %exn.slot, align 8
  %9 = extractvalue { ptr, i32 } %7, 1
  store i32 %9, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4swapERS4_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector", ptr %0, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 8 dereferenceable(24) %mContainer2)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %rhs.addr, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapImEEvRT_S2_(ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount, ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount3) #9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapImEEvRT_S2_(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %temp = alloca i64, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRmEEONS_16remove_referenceIT_E4typeEOS3_(ptr noundef nonnull align 8 dereferenceable(8) %0) #9
  %1 = load i64, ptr %call, align 8
  store i64 %1, ptr %temp, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRmEEONS_16remove_referenceIT_E4typeEOS3_(ptr noundef nonnull align 8 dereferenceable(8) %2) #9
  %3 = load i64, ptr %call1, align 8
  %4 = load ptr, ptr %a.addr, align 8
  store i64 %3, ptr %4, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRmEEONS_16remove_referenceIT_E4typeEOS3_(ptr noundef nonnull align 8 dereferenceable(8) %temp) #9
  %5 = load i64, ptr %call2, align 8
  %6 = load ptr, ptr %b.addr, align 8
  store i64 %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %0, i64 noundef %1)
  ret void
}

declare i32 @__gxx_personality_v0(...)

; Function Attrs: noreturn nounwind uwtable
define linkonce_odr hidden void @__clang_call_terminate(ptr noundef %0) #2 comdat {
  %2 = call ptr @__cxa_begin_catch(ptr %0) #9
  call void @_ZSt9terminatev() #10
  unreachable
}

declare ptr @__cxa_begin_catch(ptr)

declare void @_ZSt9terminatev()

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  call void @_ZN5eastl19bitvector_referenceImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6cbeginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive5, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive6, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4cendEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %i.coerce0, i64 %i.coerce1) unnamed_addr #1 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_iterator", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %i, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.0") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %i.coerce0, i64 %i.coerce1) unnamed_addr #1 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.0", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %i, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE7crbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.0") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator.0") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5crendEv(ptr noalias sret(%"class.eastl::reverse_iterator.0") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorImNS_9allocatorEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorImNS_9allocatorEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %cmp = icmp eq ptr %0, %1
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorImNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mul = mul i64 %call, 64
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %sub = sub i64 %mul, %0
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorImNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorImNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mul = mul i64 %call, 64
  ret i64 %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorImNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %0 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %s = alloca i64, align 8
  %newbits = alloca i64, align 8
  %element = alloca i64, align 8
  %words = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  store i64 %call, ptr %s, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %s, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, ptr %n.addr, align 8
  %4 = load i64, ptr %s, align 8
  %sub = sub i64 %3, %4
  store i64 %sub, ptr %newbits, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %5 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %6 = load i64, ptr %newbits, align 8
  %tobool2 = icmp ne i64 %6, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %tobool2, %land.rhs ]
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %8 = load i8, ptr %value.addr, align 1
  %tobool3 = trunc i8 %8 to i1
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this1, i1 noundef zeroext %tobool3)
  %9 = load i64, ptr %newbits, align 8
  %dec = add i64 %9, -1
  store i64 %dec, ptr %newbits, align 8
  br label %while.cond, !llvm.loop !5

while.end:                                        ; preds = %land.end
  %10 = load i64, ptr %newbits, align 8
  %tobool4 = icmp ne i64 %10, 0
  br i1 %tobool4, label %if.then5, label %if.end12

if.then5:                                         ; preds = %while.end
  store i64 0, ptr %element, align 8
  %11 = load i8, ptr %value.addr, align 1
  %tobool6 = trunc i8 %11 to i1
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.then5
  %12 = load i64, ptr %element, align 8
  %not = xor i64 %12, -1
  store i64 %not, ptr %element, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.then5
  %13 = load i64, ptr %n.addr, align 8
  %add = add i64 %13, 64
  %sub9 = sub i64 %add, 1
  %div = udiv i64 %sub9, 64
  store i64 %div, ptr %words, align 8
  %14 = load i64, ptr %words, align 8
  %mul = mul i64 %14, 64
  %15 = load i64, ptr %n.addr, align 8
  %sub10 = sub i64 %mul, %15
  store i64 %sub10, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %16 = load i64, ptr %words, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE6resizeEmRKm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %16, ptr noundef nonnull align 8 dereferenceable(8) %element)
  %17 = load i64, ptr %extra, align 8
  %mFreeBitCount11 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 %17, ptr %mFreeBitCount11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.end8, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  store i64 %div, ptr %wordCount, align 8
  %1 = load i64, ptr %wordCount, align 8
  %mul = mul i64 %1, 64
  %2 = load i64, ptr %n.addr, align 8
  %sub2 = sub i64 %mul, %2
  store i64 %sub2, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %3 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %3)
  %4 = load i64, ptr %extra, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 %4, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %0 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %0 to i1
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call, 1
  store i64 %4, ptr %3, align 8
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2)
  %call5 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call4)
  %5 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call5, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call5, 1
  store i64 %8, ptr %7, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE6resizeEmRKm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 8
  %sub = sub i64 %3, %sub.ptr.div7
  %6 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE17DoInsertValuesEndEmRKm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub, ptr noundef nonnull align 8 dereferenceable(8) %6)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin8, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %7, i64 %8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %9 = load ptr, ptr %mpEnd9, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %add.ptr, ptr noundef %9)
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %11 = load i64, ptr %n.addr, align 8
  %add.ptr11 = getelementptr inbounds i64, ptr %10, i64 %11
  %mpEnd12 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %add.ptr11, ptr %mpEnd12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 8
  %sub = sub i64 %3, %sub.ptr.div7
  call void @_ZN5eastl6vectorImNS_9allocatorEE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin8, align 8
  %7 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %6, i64 %7
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %8 = load ptr, ptr %mpEnd9, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %add.ptr, ptr noundef %8)
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %9 = load ptr, ptr %mpBegin10, align 8
  %10 = load i64, ptr %n.addr, align 8
  %add.ptr11 = getelementptr inbounds i64, ptr %9, i64 %10
  %mpEnd12 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %add.ptr11, ptr %mpEnd12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  store i64 %div, ptr %wordCount, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef -1)
  br label %if.end

if.else:                                          ; preds = %entry
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  call void @_ZN5eastl6vectorImNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer2, i64 noundef %div)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp2 = icmp ule i64 %1, %sub.ptr.div
  br i1 %cmp2, label %if.then, label %if.else14

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load i64, ptr %n.addr, align 8
  %cmp3 = icmp eq i64 %4, 0
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  call void @_ZN5eastl6vectorImNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %if.end13

if.else:                                          ; preds = %if.then
  %5 = load i64, ptr %n.addr, align 8
  %mpEnd5 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %6 = load ptr, ptr %mpEnd5, align 8
  %mpBegin6 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin6, align 8
  %sub.ptr.lhs.cast7 = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast8 = ptrtoint ptr %7 to i64
  %sub.ptr.sub9 = sub i64 %sub.ptr.lhs.cast7, %sub.ptr.rhs.cast8
  %sub.ptr.div10 = sdiv exact i64 %sub.ptr.sub9, 8
  %cmp11 = icmp ult i64 %5, %sub.ptr.div10
  br i1 %cmp11, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.else
  %8 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then12, %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then4
  call void @_ZN5eastl6vectorImNS_9allocatorEE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end37

if.else14:                                        ; preds = %lor.lhs.false
  %9 = load i64, ptr %n.addr, align 8
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin15, align 8
  %mpEnd16 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd16, align 8
  %call = call noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE9DoReallocIPmEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9, ptr noundef %10, ptr noundef %11)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %12 = load ptr, ptr %mpBegin17, align 8
  %mpEnd18 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %13 = load ptr, ptr %mpEnd18, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %12, ptr noundef %13)
  %mpBegin19 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %14 = load ptr, ptr %mpBegin19, align 8
  %call20 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %15 = load ptr, ptr %call20, align 8
  %mpBegin21 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %16 = load ptr, ptr %mpBegin21, align 8
  %sub.ptr.lhs.cast22 = ptrtoint ptr %15 to i64
  %sub.ptr.rhs.cast23 = ptrtoint ptr %16 to i64
  %sub.ptr.sub24 = sub i64 %sub.ptr.lhs.cast22, %sub.ptr.rhs.cast23
  %sub.ptr.div25 = sdiv exact i64 %sub.ptr.sub24, 8
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %14, i64 noundef %sub.ptr.div25)
  %mpEnd26 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %17 = load ptr, ptr %mpEnd26, align 8
  %mpBegin27 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin27, align 8
  %sub.ptr.lhs.cast28 = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast29 = ptrtoint ptr %18 to i64
  %sub.ptr.sub30 = sub i64 %sub.ptr.lhs.cast28, %sub.ptr.rhs.cast29
  %sub.ptr.div31 = sdiv exact i64 %sub.ptr.sub30, 8
  store i64 %sub.ptr.div31, ptr %nPrevSize, align 8
  %19 = load ptr, ptr %pNewData, align 8
  %mpBegin32 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  store ptr %19, ptr %mpBegin32, align 8
  %20 = load ptr, ptr %pNewData, align 8
  %21 = load i64, ptr %nPrevSize, align 8
  %add.ptr = getelementptr inbounds i64, ptr %20, i64 %21
  %mpEnd33 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd33, align 8
  %mpBegin34 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin34, align 8
  %23 = load i64, ptr %n.addr, align 8
  %add.ptr35 = getelementptr inbounds i64, ptr %22, i64 %23
  %call36 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr35, ptr %call36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.else14, %if.end13
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorImNS_9allocatorEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 64, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %mFreeBitCount3, align 8
  %dec = add i64 %1, -1
  store i64 %dec, ptr %mFreeBitCount3, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorImNS_9allocatorEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd2, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpEnd2, align 8
  store i64 0, ptr %2, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store i64 0, ptr %ref.tmp, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE16DoInsertValueEndIJmEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd3, align 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 -1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mReference, i64 16, i1 false)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %value) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %mask = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %shl = shl i64 1, %0
  store i64 %shl, ptr %mask, align 8
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %mask, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBitWord, align 8
  %4 = load i64, ptr %3, align 8
  %or = or i64 %4, %2
  store i64 %or, ptr %3, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load i64, ptr %mask, align 8
  %not = xor i64 %5, -1
  %mpBitWord2 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBitWord2, align 8
  %7 = load i64, ptr %6, align 8
  %and = and i64 %7, %not
  store i64 %and, ptr %6, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mFreeBitCount, align 8
  %cmp = icmp eq i64 %inc, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %0, i32 -1
  store ptr %incdec.ptr, ptr %mpEnd, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorImNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorImNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19bitvector_referenceImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %mpBitWord, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %i.addr, align 8
  store i64 %1, ptr %mnBitIndex, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl6vectorImNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
  %call2 = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl6vectorImNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load i64, ptr %0, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mnBitIndex, align 8
  %shl = shl i64 1, %2
  %and = and i64 %1, %shl
  %cmp = icmp ne i64 %and, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call3)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %8
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call2)
  ret i1 %call3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference2, i32 0, i32 0
  %1 = load ptr, ptr %mpBitWord, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %1, i32 -1
  store ptr %incdec.ptr, ptr %mpBitWord, align 8
  %mReference3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex4 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference3, i32 0, i32 1
  store i64 64, ptr %mnBitIndex4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference5, i32 0, i32 1
  %2 = load i64, ptr %mnBitIndex6, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %mnBitIndex6, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %mReference)
  ret i1 %call
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %defaultValue) #0 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %defaultValue.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %defaultValue to i8
  store i8 %frombool, ptr %defaultValue.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %cmp = icmp ult i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp2, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %5 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %5)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call4, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call4, 1
  store i64 %9, ptr %8, align 8
  %call6 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i1 %call6, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i8, ptr %defaultValue.addr, align 1
  %tobool = trunc i8 %10 to i1
  store i1 %tobool, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i1, ptr %retval, align 1
  ret i1 %11
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3setEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp4 = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %cmp = icmp uge i64 %0, %call
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 1
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %add)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call5 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp4, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %4 = extractvalue { ptr, i64 } %call5, 0
  store ptr %4, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %6 = extractvalue { ptr, i64 } %call5, 1
  store i64 %6, ptr %5, align 8
  %7 = load i64, ptr %n.addr, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4, i64 noundef %7)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp3, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive8, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call7, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call7, 1
  store i64 %11, ptr %10, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3)
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call10, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call10, 1
  store i64 %15, ptr %14, align 8
  %call11 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %n = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp5 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp14 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp20 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp21 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp23 = alloca %"class.eastl::bitvector_reference", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorImEmiERKNS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %n, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call7 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive8, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call7, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call7, 1
  store i64 %9, ptr %8, align 8
  %10 = load i64, ptr %n, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6, i64 noundef %10)
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp5, i32 0, i32 0
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive11, i32 0, i32 0
  %11 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 0
  %12 = extractvalue { ptr, i64 } %call10, 0
  store ptr %12, ptr %11, align 8
  %13 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 1
  %14 = extractvalue { ptr, i64 } %call10, 1
  store i64 %14, ptr %13, align 8
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp5)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call16 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp15, i32 0, i32 0
  %coerce.dive18 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive17, i32 0, i32 0
  %15 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 0
  %16 = extractvalue { ptr, i64 } %call16, 0
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 1
  %18 = extractvalue { ptr, i64 } %call16, 1
  store i64 %18, ptr %17, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp14, ptr align 8 %call19, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp21, ptr align 8 %retval, i64 16, i1 false)
  %call22 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp21)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp20, ptr align 8 %call22, i64 16, i1 false)
  %19 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %22 = load i64, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 1
  %26 = load i64, ptr %25, align 8
  %27 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 1
  %30 = load i64, ptr %29, align 8
  call void @_ZN5eastl8MoveBitsImEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %20, i64 %22, ptr %24, i64 %26, ptr %28, i64 %30)
  %31 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %31 to i1
  %call24 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %retval)
  %32 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 0
  %33 = extractvalue { ptr, i64 } %call24, 0
  store ptr %33, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 1
  %35 = extractvalue { ptr, i64 } %call24, 1
  store i64 %35, ptr %34, align 8
  %call25 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp23, i1 noundef zeroext %tobool)
  %coerce.dive26 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive27 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive26, i32 0, i32 0
  %36 = load { ptr, i64 }, ptr %coerce.dive27, align 8
  ret { ptr, i64 } %36
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  ret ptr %mReference
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %reference) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %reference.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorImEC2ERKNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl18bitvector_iteratorImEmiERKNS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef i64 @_ZNK5eastl24bitvector_const_iteratorImEmiERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %0) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %1 = load ptr, ptr %.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %1)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8MoveBitsImEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %start.coerce0, i64 %start.coerce1, ptr %end.coerce0, i64 %end.coerce1, ptr %dest.coerce0, i64 %dest.coerce1) #0 comdat {
entry:
  %start = alloca %"class.eastl::bitvector_iterator", align 8
  %end = alloca %"class.eastl::bitvector_iterator", align 8
  %dest = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp17 = alloca %"class.eastl::bitvector_reference", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %start, i32 0, i32 0
  store ptr %start.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %start, i32 0, i32 1
  store i64 %start.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %end, i32 0, i32 0
  store ptr %end.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %end, i32 0, i32 1
  store i64 %end.coerce1, ptr %3, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %dest, i32 0, i32 0
  store ptr %dest.coerce0, ptr %4, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %dest, i32 0, i32 1
  store i64 %dest.coerce1, ptr %5, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEleERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %dest, ptr noundef nonnull align 8 dereferenceable(16) %start)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %call1 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %start, ptr noundef nonnull align 8 dereferenceable(16) %end)
  br i1 %call1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call2 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %start)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call2, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call2, 1
  store i64 %9, ptr %8, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %10 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp3, i32 0, i32 0
  %11 = extractvalue { ptr, i64 } %call4, 0
  store ptr %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp3, i32 0, i32 1
  %13 = extractvalue { ptr, i64 } %call4, 1
  store i64 %13, ptr %12, align 8
  %call5 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %call7 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %start)
  br label %while.cond, !llvm.loop !7

while.end:                                        ; preds = %while.cond
  br label %if.end

if.else:                                          ; preds = %entry
  %call8 = call noundef i64 @_ZNK5eastl18bitvector_iteratorImEmiERKNS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(16) %end, ptr noundef nonnull align 8 dereferenceable(16) %start)
  %call9 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %dest, i64 noundef %call8)
  br label %while.cond10

while.cond10:                                     ; preds = %while.body12, %if.else
  %call11 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %start, ptr noundef nonnull align 8 dereferenceable(16) %end)
  br i1 %call11, label %while.body12, label %while.end20

while.body12:                                     ; preds = %while.cond10
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %end)
  %call16 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %end)
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp15, i32 0, i32 0
  %15 = extractvalue { ptr, i64 } %call16, 0
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp15, i32 0, i32 1
  %17 = extractvalue { ptr, i64 } %call16, 1
  store i64 %17, ptr %16, align 8
  %call18 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %18 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp17, i32 0, i32 0
  %19 = extractvalue { ptr, i64 } %call18, 0
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp17, i32 0, i32 1
  %21 = extractvalue { ptr, i64 } %call18, 1
  store i64 %21, ptr %20, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp17, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  br label %while.cond10, !llvm.loop !8

while.end20:                                      ; preds = %while.cond10
  br label %if.end

if.end:                                           ; preds = %while.end20, %while.end
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #3

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %position = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %iPosition = alloca %"class.eastl::bitvector_iterator", align 8
  %p = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp7 = alloca %"class.eastl::bitvector_iterator", align 8
  %insert_end = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp18 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp19 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp26 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp28 = alloca %"class.eastl::bitvector_reference", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorImEmiERKNS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %p, align 8
  %call5 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %6 = load i64, ptr %n.addr, align 8
  %add = add i64 %call5, %6
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %add)
  %call8 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp7, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive9, i32 0, i32 0
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 0
  %8 = extractvalue { ptr, i64 } %call8, 0
  store ptr %8, ptr %7, align 8
  %9 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 1
  %10 = extractvalue { ptr, i64 } %call8, 1
  store i64 %10, ptr %9, align 8
  %11 = load i64, ptr %p, align 8
  %call11 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp7, i64 noundef %11)
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive12, i32 0, i32 0
  %12 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call11, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call11, 1
  store i64 %15, ptr %14, align 8
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6)
  %16 = load i64, ptr %n.addr, align 8
  %call15 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, i64 noundef %16)
  %coerce.dive16 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %insert_end, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive16, i32 0, i32 0
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 0
  %18 = extractvalue { ptr, i64 } %call15, 0
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 1
  %20 = extractvalue { ptr, i64 } %call15, 1
  store i64 %20, ptr %19, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iPosition, i64 16, i1 false)
  %call20 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive21 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp19, i32 0, i32 0
  %coerce.dive22 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive21, i32 0, i32 0
  %21 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 0
  %22 = extractvalue { ptr, i64 } %call20, 0
  store ptr %22, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 1
  %24 = extractvalue { ptr, i64 } %call20, 1
  store i64 %24, ptr %23, align 8
  %25 = load i64, ptr %n.addr, align 8
  %call23 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp19, i64 noundef %25)
  %coerce.dive24 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp18, i32 0, i32 0
  %coerce.dive25 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive24, i32 0, i32 0
  %26 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 0
  %27 = extractvalue { ptr, i64 } %call23, 0
  store ptr %27, ptr %26, align 8
  %28 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 1
  %29 = extractvalue { ptr, i64 } %call23, 1
  store i64 %29, ptr %28, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp26, ptr align 8 %insert_end, i64 16, i1 false)
  %30 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %33 = load i64, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 0
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 1
  %37 = load i64, ptr %36, align 8
  %38 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 1
  %41 = load i64, ptr %40, align 8
  call void @_ZN5eastl8MoveBitsImEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %31, i64 %33, ptr %35, i64 %37, ptr %39, i64 %41)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call27 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %insert_end)
  br i1 %call27, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %42 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %42 to i1
  %call29 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  %43 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 0
  %44 = extractvalue { ptr, i64 } %call29, 0
  store ptr %44, ptr %43, align 8
  %45 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 1
  %46 = extractvalue { ptr, i64 } %call29, 1
  store i64 %46, ptr %45, align 8
  %call30 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp28, i1 noundef zeroext %tobool)
  %call31 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  br label %while.cond, !llvm.loop !9

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp6 = alloca %"class.eastl::bitvector_iterator", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %call2, i64 16, i1 false)
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp3, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call4, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call4, 1
  store i64 %5, ptr %4, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp6, ptr align 8 %retval, i64 16, i1 false)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  call void @_ZN5eastl8MoveBitsImEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %7, i64 %9, ptr %11, i64 %13, ptr %15, i64 %17)
  %call7 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %sub = sub i64 %call7, 1
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %sub)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive8, i32 0, i32 0
  %18 = load { ptr, i64 }, ptr %coerce.dive9, align 8
  ret { ptr, i64 } %18
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEES6_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %first.coerce0, i64 %first.coerce1, ptr %last.coerce0, i64 %last.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %first = alloca %"class.eastl::bitvector_const_iterator", align 8
  %last = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %iLast = alloca %"class.eastl::bitvector_iterator", align 8
  %eraseCount = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp5 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp8 = alloca %"class.eastl::bitvector_iterator", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 0
  store ptr %first.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 1
  store i64 %first.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 0
  store ptr %last.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 1
  store i64 %last.coerce1, ptr %3, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  call void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  call void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %call2)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %iLast)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorImEmiERKNS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %retval)
  store i64 %call4, ptr %eraseCount, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iLast, i64 16, i1 false)
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp5, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call6, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call6, 1
  store i64 %7, ptr %6, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp8, ptr align 8 %retval, i64 16, i1 false)
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 1
  %19 = load i64, ptr %18, align 8
  call void @_ZN5eastl8MoveBitsImEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %9, i64 %11, ptr %13, i64 %15, ptr %17, i64 %19)
  %call9 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %20 = load i64, ptr %eraseCount, align 8
  %sub = sub i64 %call9, %20
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %sub)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive10, i32 0, i32 0
  %21 = load { ptr, i64 }, ptr %coerce.dive11, align 8
  ret { ptr, i64 } %21
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %cmp = icmp eq ptr %0, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference4, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %4, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference5, i32 0, i32 1
  %5 = load i64, ptr %mnBitIndex6, align 8
  %cmp7 = icmp eq i64 %3, %5
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %6
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEE(ptr noalias sret(%"class.eastl::reverse_iterator") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %position) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %position.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %position, ptr %position.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  %call3 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %call)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call3, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call3, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %5, i64 %7)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive5, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call4, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call4, 1
  store i64 %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %13, i64 %15)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.0", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %mIterator)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.0", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mIterator, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEES8_(ptr noalias sret(%"class.eastl::reverse_iterator") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %first.indirect_addr = alloca ptr, align 8
  %last.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.indirect_addr, align 8
  store ptr %last, ptr %last.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp3, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEES6_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %9, i64 %11, ptr %13, i64 %15)
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive7, i32 0, i32 0
  %16 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 0
  %17 = extractvalue { ptr, i64 } %call6, 0
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 1
  %19 = extractvalue { ptr, i64 } %call6, 1
  store i64 %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %21, i64 %23)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd3, align 8
  ret void

terminate.lpad:                                   ; preds = %entry
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  call void @__clang_call_terminate(ptr %4) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr null, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorImNS_9allocatorEE8validateEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %conv = trunc i64 %0 to i32
  %cmp = icmp uge i32 %conv, 64
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %1 = load i1, ptr %retval, align 1
  ret i1 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorImNS_9allocatorEE8validateEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %call, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %cmp3 = icmp ult ptr %2, %3
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %4 = load i1, ptr %retval, align 1
  ret i1 %4
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef i32 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE17validate_iteratorENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %i.coerce0, i64 %i.coerce1) #0 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %call3 = call noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer2) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mFreeBitCount, align 8
  %call4 = call noundef i32 @_ZNK5eastl24bitvector_const_iteratorImE8validateEPKmS3_m(ptr noundef nonnull align 8 dereferenceable(16) %i, ptr noundef %call, ptr noundef %call3, i64 noundef %2)
  ret i32 %call4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK5eastl24bitvector_const_iteratorImE8validateEPKmS3_m(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %pStart, ptr noundef %pEnd, i64 noundef %nExtraBits) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %pStart.addr = alloca ptr, align 8
  %pEnd.addr = alloca ptr, align 8
  %nExtraBits.addr = alloca i64, align 8
  %pCurrent = alloca ptr, align 8
  %bit = alloca i64, align 8
  %lastbit = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %pStart, ptr %pStart.addr, align 8
  store ptr %pEnd, ptr %pEnd.addr, align 8
  store i64 %nExtraBits, ptr %nExtraBits.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  store ptr %0, ptr %pCurrent, align 8
  %1 = load ptr, ptr %pCurrent, align 8
  %2 = load ptr, ptr %pStart.addr, align 8
  %cmp = icmp uge ptr %1, %2
  br i1 %cmp, label %if.then, label %if.end27

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %nExtraBits.addr, align 8
  %cmp2 = icmp eq i64 %3, 0
  br i1 %cmp2, label %if.then3, label %if.else10

if.then3:                                         ; preds = %if.then
  %4 = load ptr, ptr %pCurrent, align 8
  %5 = load ptr, ptr %pEnd.addr, align 8
  %cmp4 = icmp eq ptr %4, %5
  br i1 %cmp4, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then3
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %mReference5)
  br i1 %call, label %if.then6, label %if.else

if.then6:                                         ; preds = %land.lhs.true
  store i32 3, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %if.then3
  %6 = load ptr, ptr %pCurrent, align 8
  %7 = load ptr, ptr %pEnd.addr, align 8
  %cmp7 = icmp ult ptr %6, %7
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else
  store i32 7, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end
  br label %if.end26

if.else10:                                        ; preds = %if.then
  %8 = load ptr, ptr %pCurrent, align 8
  %9 = load ptr, ptr %pEnd.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %9, i64 -1
  %cmp11 = icmp eq ptr %8, %add.ptr
  br i1 %cmp11, label %if.then12, label %if.else21

if.then12:                                        ; preds = %if.else10
  %mReference13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference13, i32 0, i32 1
  %10 = load i64, ptr %mnBitIndex, align 8
  store i64 %10, ptr %bit, align 8
  %11 = load i64, ptr %nExtraBits.addr, align 8
  %sub = sub i64 64, %11
  store i64 %sub, ptr %lastbit, align 8
  %12 = load i64, ptr %bit, align 8
  %13 = load i64, ptr %lastbit, align 8
  %cmp14 = icmp eq i64 %12, %13
  br i1 %cmp14, label %if.then15, label %if.else16

if.then15:                                        ; preds = %if.then12
  store i32 3, ptr %retval, align 4
  br label %return

if.else16:                                        ; preds = %if.then12
  %14 = load i64, ptr %bit, align 8
  %15 = load i64, ptr %lastbit, align 8
  %cmp17 = icmp ult i64 %14, %15
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else16
  store i32 7, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.else16
  br label %if.end20

if.end20:                                         ; preds = %if.end19
  br label %if.end25

if.else21:                                        ; preds = %if.else10
  %16 = load ptr, ptr %pCurrent, align 8
  %17 = load ptr, ptr %pEnd.addr, align 8
  %cmp22 = icmp ult ptr %16, %17
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.else21
  store i32 7, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.else21
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end20
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end9
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then23, %if.then18, %if.then15, %if.then8, %if.then6
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC2Ev(ptr noundef nonnull align 8 dereferenceable(48) %this) unnamed_addr #0 comdat($_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC5Ev) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIm15MallocAllocatorEC2Ev(ptr noundef nonnull align 8 dereferenceable(40) %mContainer)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorEC2Ev(ptr noundef nonnull align 8 dereferenceable(40) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorEC2Ev(ptr noundef nonnull align 8 dereferenceable(40) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(48) %this, ptr noundef nonnull align 8 dereferenceable(16) %allocator) unnamed_addr #1 comdat($_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC5ERKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(40) %mContainer, ptr noundef nonnull align 8 dereferenceable(16) %0) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(40) %this, ptr noundef nonnull align 8 dereferenceable(16) %allocator) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  invoke void @_ZN5eastl10VectorBaseIm15MallocAllocatorEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(40) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(16) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC5EmRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(40) %mContainer, i64 noundef %div, ptr noundef nonnull align 8 dereferenceable(16) %1)
  %2 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %2, 64
  %sub2 = sub i64 64, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %3 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %3, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(16) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %0, ptr noundef nonnull align 8 dereferenceable(16) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPmmEET_S2_T0_(ptr noundef %2, i64 noundef %3)
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin2, align 8
  %5 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %4, i64 %5
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC2EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n, i1 noundef zeroext %value, ptr noundef nonnull align 8 dereferenceable(16) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC5EmbRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %allocator.addr = alloca ptr, align 8
  %ref.tmp = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i64 -1, i64 0
  store i64 %cond, ptr %ref.tmp, align 8
  %2 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorEC2EmRKmRKS1_(ptr noundef nonnull align 8 dereferenceable(40) %mContainer, i64 noundef %div, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(16) %2)
  %3 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %3, 64
  %sub2 = sub i64 64, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %4 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %4, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorEC2EmRKmRKS1_(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value, ptr noundef nonnull align 8 dereferenceable(16) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %0, ptr noundef nonnull align 8 dereferenceable(16) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %4 = load ptr, ptr %value.addr, align 8
  invoke void @_ZN5eastl24uninitialized_fill_n_ptrImmEEvPT_T0_RKS1_(ptr noundef %2, i64 noundef %3, ptr noundef nonnull align 8 dereferenceable(8) %4)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin2, align 8
  %6 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %5, i64 %6
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %7 = landingpad { ptr, i32 }
          cleanup
  %8 = extractvalue { ptr, i32 } %7, 0
  store ptr %8, ptr %exn.slot, align 8
  %9 = extractvalue { ptr, i32 } %7, 1
  store i32 %9, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorED2Ev(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4swapERS4_(ptr noundef nonnull align 8 dereferenceable(48) %this, ptr noundef nonnull align 8 dereferenceable(48) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %0, i32 0, i32 0
  call void @_ZN5eastl6vectorIm15MallocAllocatorE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(40) %mContainer, ptr noundef nonnull align 8 dereferenceable(40) %mContainer2)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %rhs.addr, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapImEEvRT_S2_(ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount, ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount3) #9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(40) %this, ptr noundef nonnull align 8 dereferenceable(40) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(40) %this1, ptr noundef nonnull align 8 dereferenceable(40) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIm15MallocAllocatorE5beginEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIm15MallocAllocatorE5beginEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIm15MallocAllocatorE5beginEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIm15MallocAllocatorE5beginEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6cbeginEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIm15MallocAllocatorE5beginEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIm15MallocAllocatorE3endEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive5, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive6, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIm15MallocAllocatorE3endEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIm15MallocAllocatorE3endEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIm15MallocAllocatorE3endEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4cendEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIm15MallocAllocatorE3endEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.0") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE7crbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.0") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator.0") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5crendEv(ptr noalias sret(%"class.eastl::reverse_iterator.0") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorIm15MallocAllocatorE5emptyEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorIm15MallocAllocatorE5emptyEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %cmp = icmp eq ptr %0, %1
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorIm15MallocAllocatorE4sizeEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  %mul = mul i64 %call, 64
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %sub = sub i64 %mul, %0
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorIm15MallocAllocatorE4sizeEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorIm15MallocAllocatorE8capacityEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  %mul = mul i64 %call, 64
  ret i64 %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorIm15MallocAllocatorE8capacityEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %0 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %s = alloca i64, align 8
  %newbits = alloca i64, align 8
  %element = alloca i64, align 8
  %words = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  store i64 %call, ptr %s, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %s, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(48) %this1, i64 noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, ptr %n.addr, align 8
  %4 = load i64, ptr %s, align 8
  %sub = sub i64 %3, %4
  store i64 %sub, ptr %newbits, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %5 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %6 = load i64, ptr %newbits, align 8
  %tobool2 = icmp ne i64 %6, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %tobool2, %land.rhs ]
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %8 = load i8, ptr %value.addr, align 1
  %tobool3 = trunc i8 %8 to i1
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(48) %this1, i1 noundef zeroext %tobool3)
  %9 = load i64, ptr %newbits, align 8
  %dec = add i64 %9, -1
  store i64 %dec, ptr %newbits, align 8
  br label %while.cond, !llvm.loop !10

while.end:                                        ; preds = %land.end
  %10 = load i64, ptr %newbits, align 8
  %tobool4 = icmp ne i64 %10, 0
  br i1 %tobool4, label %if.then5, label %if.end12

if.then5:                                         ; preds = %while.end
  store i64 0, ptr %element, align 8
  %11 = load i8, ptr %value.addr, align 1
  %tobool6 = trunc i8 %11 to i1
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.then5
  %12 = load i64, ptr %element, align 8
  %not = xor i64 %12, -1
  store i64 %not, ptr %element, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.then5
  %13 = load i64, ptr %n.addr, align 8
  %add = add i64 %13, 64
  %sub9 = sub i64 %add, 1
  %div = udiv i64 %sub9, 64
  store i64 %div, ptr %words, align 8
  %14 = load i64, ptr %words, align 8
  %mul = mul i64 %14, 64
  %15 = load i64, ptr %n.addr, align 8
  %sub10 = sub i64 %mul, %15
  store i64 %sub10, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %16 = load i64, ptr %words, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorE6resizeEmRKm(ptr noundef nonnull align 8 dereferenceable(40) %mContainer, i64 noundef %16, ptr noundef nonnull align 8 dereferenceable(8) %element)
  %17 = load i64, ptr %extra, align 8
  %mFreeBitCount11 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 %17, ptr %mFreeBitCount11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.end8, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  store i64 %div, ptr %wordCount, align 8
  %1 = load i64, ptr %wordCount, align 8
  %mul = mul i64 %1, 64
  %2 = load i64, ptr %n.addr, align 8
  %sub2 = sub i64 %mul, %2
  store i64 %sub2, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %3 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorE6resizeEm(ptr noundef nonnull align 8 dereferenceable(40) %mContainer, i64 noundef %3)
  %4 = load i64, ptr %extra, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 %4, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(48) %this, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(48) %this1)
  %0 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %0 to i1
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call, 1
  store i64 %4, ptr %3, align 8
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2)
  %call5 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call4)
  %5 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call5, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call5, 1
  store i64 %8, ptr %7, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE6resizeEmRKm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 8
  %sub = sub i64 %3, %sub.ptr.div7
  %6 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorE17DoInsertValuesEndEmRKm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %sub, ptr noundef nonnull align 8 dereferenceable(8) %6)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin8, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %7, i64 %8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %9 = load ptr, ptr %mpEnd9, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %add.ptr, ptr noundef %9)
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %11 = load i64, ptr %n.addr, align 8
  %add.ptr11 = getelementptr inbounds i64, ptr %10, i64 %11
  %mpEnd12 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %add.ptr11, ptr %mpEnd12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE6resizeEm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 8
  %sub = sub i64 %3, %sub.ptr.div7
  call void @_ZN5eastl6vectorIm15MallocAllocatorE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %sub)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin8, align 8
  %7 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %6, i64 %7
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %8 = load ptr, ptr %mpEnd9, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %add.ptr, ptr noundef %8)
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %9 = load ptr, ptr %mpBegin10, align 8
  %10 = load i64, ptr %n.addr, align 8
  %add.ptr11 = getelementptr inbounds i64, ptr %9, i64 %10
  %mpEnd12 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %add.ptr11, ptr %mpEnd12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  store i64 %div, ptr %wordCount, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorE7reserveEm(ptr noundef nonnull align 8 dereferenceable(40) %mContainer, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE7reserveEm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIm15MallocAllocatorE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(40) %mContainer, i64 noundef -1)
  br label %if.end

if.else:                                          ; preds = %entry
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  call void @_ZN5eastl6vectorIm15MallocAllocatorE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(40) %mContainer2, i64 noundef %div)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp2 = icmp ule i64 %1, %sub.ptr.div
  br i1 %cmp2, label %if.then, label %if.else14

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load i64, ptr %n.addr, align 8
  %cmp3 = icmp eq i64 %4, 0
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  call void @_ZN5eastl6vectorIm15MallocAllocatorE5clearEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  br label %if.end13

if.else:                                          ; preds = %if.then
  %5 = load i64, ptr %n.addr, align 8
  %mpEnd5 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %6 = load ptr, ptr %mpEnd5, align 8
  %mpBegin6 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin6, align 8
  %sub.ptr.lhs.cast7 = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast8 = ptrtoint ptr %7 to i64
  %sub.ptr.sub9 = sub i64 %sub.ptr.lhs.cast7, %sub.ptr.rhs.cast8
  %sub.ptr.div10 = sdiv exact i64 %sub.ptr.sub9, 8
  %cmp11 = icmp ult i64 %5, %sub.ptr.div10
  br i1 %cmp11, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.else
  %8 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorE6resizeEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then12, %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then4
  call void @_ZN5eastl6vectorIm15MallocAllocatorE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(40) %this1)
  br label %if.end37

if.else14:                                        ; preds = %lor.lhs.false
  %9 = load i64, ptr %n.addr, align 8
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin15, align 8
  %mpEnd16 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd16, align 8
  %call = call noundef ptr @_ZN5eastl6vectorIm15MallocAllocatorE9DoReallocIPmEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %9, ptr noundef %10, ptr noundef %11)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %12 = load ptr, ptr %mpBegin17, align 8
  %mpEnd18 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %13 = load ptr, ptr %mpEnd18, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %12, ptr noundef %13)
  %mpBegin19 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %14 = load ptr, ptr %mpBegin19, align 8
  %call20 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %15 = load ptr, ptr %call20, align 8
  %mpBegin21 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %16 = load ptr, ptr %mpBegin21, align 8
  %sub.ptr.lhs.cast22 = ptrtoint ptr %15 to i64
  %sub.ptr.rhs.cast23 = ptrtoint ptr %16 to i64
  %sub.ptr.sub24 = sub i64 %sub.ptr.lhs.cast22, %sub.ptr.rhs.cast23
  %sub.ptr.div25 = sdiv exact i64 %sub.ptr.sub24, 8
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(40) %this1, ptr noundef %14, i64 noundef %sub.ptr.div25)
  %mpEnd26 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %17 = load ptr, ptr %mpEnd26, align 8
  %mpBegin27 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin27, align 8
  %sub.ptr.lhs.cast28 = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast29 = ptrtoint ptr %18 to i64
  %sub.ptr.sub30 = sub i64 %sub.ptr.lhs.cast28, %sub.ptr.rhs.cast29
  %sub.ptr.div31 = sdiv exact i64 %sub.ptr.sub30, 8
  store i64 %sub.ptr.div31, ptr %nPrevSize, align 8
  %19 = load ptr, ptr %pNewData, align 8
  %mpBegin32 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  store ptr %19, ptr %mpBegin32, align 8
  %20 = load ptr, ptr %pNewData, align 8
  %21 = load i64, ptr %nPrevSize, align 8
  %add.ptr = getelementptr inbounds i64, ptr %20, i64 %21
  %mpEnd33 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd33, align 8
  %mpBegin34 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin34, align 8
  %23 = load i64, ptr %n.addr, align 8
  %add.ptr35 = getelementptr inbounds i64, ptr %22, i64 %23
  %call36 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  store ptr %add.ptr35, ptr %call36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.else14, %if.end13
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorIm15MallocAllocatorE9push_backEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 64, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %mFreeBitCount3, align 8
  %dec = add i64 %1, -1
  store i64 %dec, ptr %mFreeBitCount3, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorIm15MallocAllocatorE9push_backEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd2, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpEnd2, align 8
  store i64 0, ptr %2, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store i64 0, ptr %ref.tmp, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorE16DoInsertValueEndIJmEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(40) %this1, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd3, align 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 -1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mFreeBitCount, align 8
  %cmp = icmp eq i64 %inc, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIm15MallocAllocatorE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %0, i32 -1
  store ptr %incdec.ptr, ptr %mpEnd, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorIm15MallocAllocatorEixEm(ptr noundef nonnull align 8 dereferenceable(40) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorIm15MallocAllocatorEixEm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl6vectorIm15MallocAllocatorEixEm(ptr noundef nonnull align 8 dereferenceable(40) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
  %call2 = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl6vectorIm15MallocAllocatorEixEm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call3)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %8
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call2)
  ret i1 %call3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n, i1 noundef zeroext %defaultValue) #0 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %defaultValue.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %defaultValue to i8
  store i8 %frombool, ptr %defaultValue.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %cmp = icmp ult i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp2, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %5 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %5)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call4, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call4, 1
  store i64 %9, ptr %8, align 8
  %call6 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i1 %call6, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i8, ptr %defaultValue.addr, align 1
  %tobool = trunc i8 %10 to i1
  store i1 %tobool, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i1, ptr %retval, align 1
  ret i1 %11
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3setEmb(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp4 = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %cmp = icmp uge i64 %0, %call
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 1
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(48) %this1, i64 noundef %add)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call5 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp4, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %4 = extractvalue { ptr, i64 } %call5, 0
  store ptr %4, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %6 = extractvalue { ptr, i64 } %call5, 1
  store i64 %6, ptr %5, align 8
  %7 = load i64, ptr %n.addr, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4, i64 noundef %7)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp3, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive8, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call7, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call7, 1
  store i64 %11, ptr %10, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3)
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call10, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call10, 1
  store i64 %15, ptr %14, align 8
  %call11 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIm15MallocAllocatorE4dataEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIm15MallocAllocatorE4dataEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIm15MallocAllocatorE4dataEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIm15MallocAllocatorE4dataEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEb(ptr noundef nonnull align 8 dereferenceable(48) %this, ptr %position.coerce0, i64 %position.coerce1, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %n = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp5 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp14 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp20 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp21 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp23 = alloca %"class.eastl::bitvector_reference", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorImEmiERKNS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %n, align 8
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(48) %this1)
  %call7 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive8, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call7, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call7, 1
  store i64 %9, ptr %8, align 8
  %10 = load i64, ptr %n, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6, i64 noundef %10)
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp5, i32 0, i32 0
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive11, i32 0, i32 0
  %11 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 0
  %12 = extractvalue { ptr, i64 } %call10, 0
  store ptr %12, ptr %11, align 8
  %13 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 1
  %14 = extractvalue { ptr, i64 } %call10, 1
  store i64 %14, ptr %13, align 8
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp5)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call16 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp15, i32 0, i32 0
  %coerce.dive18 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive17, i32 0, i32 0
  %15 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 0
  %16 = extractvalue { ptr, i64 } %call16, 0
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 1
  %18 = extractvalue { ptr, i64 } %call16, 1
  store i64 %18, ptr %17, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp14, ptr align 8 %call19, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp21, ptr align 8 %retval, i64 16, i1 false)
  %call22 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp21)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp20, ptr align 8 %call22, i64 16, i1 false)
  %19 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %22 = load i64, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 1
  %26 = load i64, ptr %25, align 8
  %27 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 1
  %30 = load i64, ptr %29, align 8
  call void @_ZN5eastl8MoveBitsImEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %20, i64 %22, ptr %24, i64 %26, ptr %28, i64 %30)
  %31 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %31 to i1
  %call24 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %retval)
  %32 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 0
  %33 = extractvalue { ptr, i64 } %call24, 0
  store ptr %33, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 1
  %35 = extractvalue { ptr, i64 } %call24, 1
  store i64 %35, ptr %34, align 8
  %call25 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp23, i1 noundef zeroext %tobool)
  %coerce.dive26 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive27 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive26, i32 0, i32 0
  %36 = load { ptr, i64 }, ptr %coerce.dive27, align 8
  ret { ptr, i64 } %36
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEmb(ptr noundef nonnull align 8 dereferenceable(48) %this, ptr %position.coerce0, i64 %position.coerce1, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %position = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %iPosition = alloca %"class.eastl::bitvector_iterator", align 8
  %p = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp7 = alloca %"class.eastl::bitvector_iterator", align 8
  %insert_end = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp18 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp19 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp26 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp28 = alloca %"class.eastl::bitvector_reference", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorImEmiERKNS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %p, align 8
  %call5 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %6 = load i64, ptr %n.addr, align 8
  %add = add i64 %call5, %6
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(48) %this1, i64 noundef %add)
  %call8 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp7, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive9, i32 0, i32 0
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 0
  %8 = extractvalue { ptr, i64 } %call8, 0
  store ptr %8, ptr %7, align 8
  %9 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 1
  %10 = extractvalue { ptr, i64 } %call8, 1
  store i64 %10, ptr %9, align 8
  %11 = load i64, ptr %p, align 8
  %call11 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp7, i64 noundef %11)
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive12, i32 0, i32 0
  %12 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call11, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call11, 1
  store i64 %15, ptr %14, align 8
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6)
  %16 = load i64, ptr %n.addr, align 8
  %call15 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, i64 noundef %16)
  %coerce.dive16 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %insert_end, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive16, i32 0, i32 0
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 0
  %18 = extractvalue { ptr, i64 } %call15, 0
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 1
  %20 = extractvalue { ptr, i64 } %call15, 1
  store i64 %20, ptr %19, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iPosition, i64 16, i1 false)
  %call20 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive21 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp19, i32 0, i32 0
  %coerce.dive22 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive21, i32 0, i32 0
  %21 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 0
  %22 = extractvalue { ptr, i64 } %call20, 0
  store ptr %22, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 1
  %24 = extractvalue { ptr, i64 } %call20, 1
  store i64 %24, ptr %23, align 8
  %25 = load i64, ptr %n.addr, align 8
  %call23 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp19, i64 noundef %25)
  %coerce.dive24 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp18, i32 0, i32 0
  %coerce.dive25 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive24, i32 0, i32 0
  %26 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 0
  %27 = extractvalue { ptr, i64 } %call23, 0
  store ptr %27, ptr %26, align 8
  %28 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 1
  %29 = extractvalue { ptr, i64 } %call23, 1
  store i64 %29, ptr %28, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp26, ptr align 8 %insert_end, i64 16, i1 false)
  %30 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %33 = load i64, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 0
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 1
  %37 = load i64, ptr %36, align 8
  %38 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 1
  %41 = load i64, ptr %40, align 8
  call void @_ZN5eastl8MoveBitsImEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %31, i64 %33, ptr %35, i64 %37, ptr %39, i64 %41)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call27 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %insert_end)
  br i1 %call27, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %42 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %42 to i1
  %call29 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  %43 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 0
  %44 = extractvalue { ptr, i64 } %call29, 0
  store ptr %44, ptr %43, align 8
  %45 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 1
  %46 = extractvalue { ptr, i64 } %call29, 1
  store i64 %46, ptr %45, align 8
  %call30 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp28, i1 noundef zeroext %tobool)
  %call31 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  br label %while.cond, !llvm.loop !11

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(48) %this, ptr %position.coerce0, i64 %position.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp6 = alloca %"class.eastl::bitvector_iterator", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %call2, i64 16, i1 false)
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp3, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call4, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call4, 1
  store i64 %5, ptr %4, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp6, ptr align 8 %retval, i64 16, i1 false)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  call void @_ZN5eastl8MoveBitsImEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %7, i64 %9, ptr %11, i64 %13, ptr %15, i64 %17)
  %call7 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %sub = sub i64 %call7, 1
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(48) %this1, i64 noundef %sub)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive8, i32 0, i32 0
  %18 = load { ptr, i64 }, ptr %coerce.dive9, align 8
  ret { ptr, i64 } %18
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEES6_(ptr noundef nonnull align 8 dereferenceable(48) %this, ptr %first.coerce0, i64 %first.coerce1, ptr %last.coerce0, i64 %last.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %first = alloca %"class.eastl::bitvector_const_iterator", align 8
  %last = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %iLast = alloca %"class.eastl::bitvector_iterator", align 8
  %eraseCount = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp5 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp8 = alloca %"class.eastl::bitvector_iterator", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 0
  store ptr %first.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 1
  store i64 %first.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 0
  store ptr %last.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 1
  store i64 %last.coerce1, ptr %3, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  call void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  call void @_ZN5eastl18bitvector_iteratorImEC2ERNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %call2)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %iLast)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorImEmiERKNS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %retval)
  store i64 %call4, ptr %eraseCount, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iLast, i64 16, i1 false)
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp5, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call6, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call6, 1
  store i64 %7, ptr %6, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp8, ptr align 8 %retval, i64 16, i1 false)
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 1
  %19 = load i64, ptr %18, align 8
  call void @_ZN5eastl8MoveBitsImEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %9, i64 %11, ptr %13, i64 %15, ptr %17, i64 %19)
  %call9 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %this1) #9
  %20 = load i64, ptr %eraseCount, align 8
  %sub = sub i64 %call9, %20
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(48) %this1, i64 noundef %sub)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive10, i32 0, i32 0
  %21 = load { ptr, i64 }, ptr %coerce.dive11, align 8
  ret { ptr, i64 } %21
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEE(ptr noalias sret(%"class.eastl::reverse_iterator") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(48) %this, ptr noundef %position) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %position.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %position, ptr %position.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  %call3 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %call)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call3, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call3, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(48) %this1, ptr %5, i64 %7)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive5, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call4, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call4, 1
  store i64 %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %13, i64 %15)
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEES8_(ptr noalias sret(%"class.eastl::reverse_iterator") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(48) %this, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %first.indirect_addr = alloca ptr, align 8
  %last.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.indirect_addr, align 8
  store ptr %last, ptr %last.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp3, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEES6_(ptr noundef nonnull align 8 dereferenceable(48) %this1, ptr %9, i64 %11, ptr %13, i64 %15)
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive7, i32 0, i32 0
  %16 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 0
  %17 = extractvalue { ptr, i64 } %call6, 0
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 1
  %19 = extractvalue { ptr, i64 } %call6, 1
  store i64 %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %21, i64 %23)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIm15MallocAllocatorE5clearEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE5clearEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd3, align 8
  ret void

terminate.lpad:                                   ; preds = %entry
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  call void @__clang_call_terminate(ptr %4) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIm15MallocAllocatorE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  store ptr null, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(40) ptr @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(40) ptr @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(48) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorIm15MallocAllocatorE8validateEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %conv = trunc i64 %0 to i32
  %cmp = icmp uge i32 %conv, 64
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %1 = load i1, ptr %retval, align 1
  ret i1 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorIm15MallocAllocatorE8validateEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %2 = load ptr, ptr %call, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %cmp3 = icmp ult ptr %2, %3
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %4 = load i1, ptr %retval, align 1
  ret i1 %4
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef i32 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE17validate_iteratorENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(48) %this, ptr %i.coerce0, i64 %i.coerce1) #0 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIm15MallocAllocatorE5beginEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  %call3 = call noundef ptr @_ZNK5eastl6vectorIm15MallocAllocatorE3endEv(ptr noundef nonnull align 8 dereferenceable(40) %mContainer2) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mFreeBitCount, align 8
  %call4 = call noundef i32 @_ZNK5eastl24bitvector_const_iteratorImE8validateEPKmS3_m(ptr noundef nonnull align 8 dereferenceable(16) %i, ptr noundef %call, ptr noundef %call3, i64 noundef %2)
  ret i32 %call4
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC5Ev) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIhNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #1 comdat($_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC5ERKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 1 dereferenceable(1) %0) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  invoke void @_ZN5eastl10VectorBaseIhNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC5EmRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 8
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %div, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %2 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %2, 8
  %sub2 = sub i64 8, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %3 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %3, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %call = invoke noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPhmEET_S2_T0_(ptr noundef %2, i64 noundef %3)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin2, align 8
  %5 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 %5
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %6 = landingpad { ptr, i32 }
          cleanup
  %7 = extractvalue { ptr, i32 } %6, 0
  store ptr %7, ptr %exn.slot, align 8
  %8 = extractvalue { ptr, i32 } %6, 1
  store i32 %8, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC2EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEC5EmbRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %allocator.addr = alloca ptr, align 8
  %ref.tmp = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 8
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 8
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i32 -1, i32 0
  %conv = trunc i32 %cond to i8
  store i8 %conv, ptr %ref.tmp, align 1
  %2 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEEC2EmRKhRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %div, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp, ptr noundef nonnull align 1 dereferenceable(1) %2)
  %3 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %3, 8
  %sub2 = sub i64 8, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %4 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %4, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEEC2EmRKhRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %value, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %4 = load ptr, ptr %value.addr, align 8
  invoke void @_ZN5eastl24uninitialized_fill_n_ptrIhmEEvPT_T0_RKS1_(ptr noundef %2, i64 noundef %3, ptr noundef nonnull align 1 dereferenceable(1) %4)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin2, align 8
  %6 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %5, i64 %6
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %7 = landingpad { ptr, i32 }
          cleanup
  %8 = extractvalue { ptr, i32 } %7, 0
  store ptr %8, ptr %exn.slot, align 8
  %9 = extractvalue { ptr, i32 } %7, 1
  store i32 %9, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4swapERS4_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %0, i32 0, i32 0
  call void @_ZN5eastl6vectorIhNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 8 dereferenceable(24) %mContainer2)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %rhs.addr, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapImEEvRT_S2_(ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount, ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount3) #9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.11", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIhNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorIhEC2EPhm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIhNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorIhEC2EPhm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorIhEC2EPKhm(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIhNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIhEC2EPKhm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIhNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorIhEC2EPKhm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  call void @_ZN5eastl19bitvector_referenceIhEC2EPhm(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6cbeginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIhNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIhEC2EPKhm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.11", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIhNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorIhEC2EPhm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %retval, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %retval, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive5, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive6, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIhNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.11", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIhNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIhEC2EPKhm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIhEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIhNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIhEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %retval, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4cendEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIhNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIhEC2EPKhm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIhEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.14") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIhEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIhEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %i.coerce0, i64 %i.coerce1) unnamed_addr #1 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_iterator.11", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.14", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %i, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.15") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %i.coerce0, i64 %i.coerce1) unnamed_addr #1 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.15", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %i, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE7crbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.15") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator.14") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIhEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator.15") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5crendEv(ptr noalias sret(%"class.eastl::reverse_iterator.15") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorIhNS_9allocatorEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorIhNS_9allocatorEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %cmp = icmp eq ptr %0, %1
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorIhNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mul = mul i64 %call, 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %sub = sub i64 %mul, %0
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorIhNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  ret i64 %sub.ptr.sub
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorIhNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mul = mul i64 %call, 8
  ret i64 %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorIhNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %0 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  ret i64 %sub.ptr.sub
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %s = alloca i64, align 8
  %newbits = alloca i64, align 8
  %element = alloca i8, align 1
  %words = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  store i64 %call, ptr %s, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %s, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, ptr %n.addr, align 8
  %4 = load i64, ptr %s, align 8
  %sub = sub i64 %3, %4
  store i64 %sub, ptr %newbits, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %5 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %6 = load i64, ptr %newbits, align 8
  %tobool2 = icmp ne i64 %6, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %tobool2, %land.rhs ]
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %8 = load i8, ptr %value.addr, align 1
  %tobool3 = trunc i8 %8 to i1
  call void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this1, i1 noundef zeroext %tobool3)
  %9 = load i64, ptr %newbits, align 8
  %dec = add i64 %9, -1
  store i64 %dec, ptr %newbits, align 8
  br label %while.cond, !llvm.loop !12

while.end:                                        ; preds = %land.end
  %10 = load i64, ptr %newbits, align 8
  %tobool4 = icmp ne i64 %10, 0
  br i1 %tobool4, label %if.then5, label %if.end13

if.then5:                                         ; preds = %while.end
  store i8 0, ptr %element, align 1
  %11 = load i8, ptr %value.addr, align 1
  %tobool6 = trunc i8 %11 to i1
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.then5
  %12 = load i8, ptr %element, align 1
  %conv = zext i8 %12 to i32
  %not = xor i32 %conv, -1
  %conv8 = trunc i32 %not to i8
  store i8 %conv8, ptr %element, align 1
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.then5
  %13 = load i64, ptr %n.addr, align 8
  %add = add i64 %13, 8
  %sub10 = sub i64 %add, 1
  %div = udiv i64 %sub10, 8
  store i64 %div, ptr %words, align 8
  %14 = load i64, ptr %words, align 8
  %mul = mul i64 %14, 8
  %15 = load i64, ptr %n.addr, align 8
  %sub11 = sub i64 %mul, %15
  store i64 %sub11, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %16 = load i64, ptr %words, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEE6resizeEmRKh(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %16, ptr noundef nonnull align 1 dereferenceable(1) %element)
  %17 = load i64, ptr %extra, align 8
  %mFreeBitCount12 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 %17, ptr %mFreeBitCount12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.end9, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 8
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 8
  store i64 %div, ptr %wordCount, align 8
  %1 = load i64, ptr %wordCount, align 8
  %mul = mul i64 %1, 8
  %2 = load i64, ptr %n.addr, align 8
  %sub2 = sub i64 %mul, %2
  store i64 %sub2, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %3 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %3)
  %4 = load i64, ptr %extra, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 %4, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference.13", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.11", align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %0 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %0 to i1
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call, 1
  store i64 %4, ptr %3, align 8
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2)
  %call5 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call4)
  %5 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call5, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call5, 1
  store i64 %8, ptr %7, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIhEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE6resizeEmRKh(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp ugt i64 %0, %sub.ptr.sub
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub = sub i64 %3, %sub.ptr.sub6
  %6 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEE17DoInsertValuesEndEmRKh(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub, ptr noundef nonnull align 1 dereferenceable(1) %6)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin7, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %7, i64 %8
  %mpEnd8 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %9 = load ptr, ptr %mpEnd8, align 8
  call void @_ZN5eastl8destructIPhEEvT_S2_(ptr noundef %add.ptr, ptr noundef %9)
  %mpBegin9 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin9, align 8
  %11 = load i64, ptr %n.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, ptr %10, i64 %11
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %add.ptr10, ptr %mpEnd11, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp ugt i64 %0, %sub.ptr.sub
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub = sub i64 %3, %sub.ptr.sub6
  call void @_ZN5eastl6vectorIhNS_9allocatorEE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin7, align 8
  %7 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %6, i64 %7
  %mpEnd8 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %8 = load ptr, ptr %mpEnd8, align 8
  call void @_ZN5eastl8destructIPhEEvT_S2_(ptr noundef %add.ptr, ptr noundef %8)
  %mpBegin9 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %9 = load ptr, ptr %mpBegin9, align 8
  %10 = load i64, ptr %n.addr, align 8
  %add.ptr10 = getelementptr inbounds i8, ptr %9, i64 %10
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %add.ptr10, ptr %mpEnd11, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 8
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 8
  store i64 %div, ptr %wordCount, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp ugt i64 %0, %sub.ptr.sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIhNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef -1)
  br label %if.end

if.else:                                          ; preds = %entry
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 8
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer2, i64 noundef %div)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp2 = icmp ule i64 %1, %sub.ptr.sub
  br i1 %cmp2, label %if.then, label %if.else13

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load i64, ptr %n.addr, align 8
  %cmp3 = icmp eq i64 %4, 0
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  call void @_ZN5eastl6vectorIhNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %if.end12

if.else:                                          ; preds = %if.then
  %5 = load i64, ptr %n.addr, align 8
  %mpEnd5 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %6 = load ptr, ptr %mpEnd5, align 8
  %mpBegin6 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin6, align 8
  %sub.ptr.lhs.cast7 = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast8 = ptrtoint ptr %7 to i64
  %sub.ptr.sub9 = sub i64 %sub.ptr.lhs.cast7, %sub.ptr.rhs.cast8
  %cmp10 = icmp ult i64 %5, %sub.ptr.sub9
  br i1 %cmp10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.else
  %8 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then11, %if.else
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then4
  call void @_ZN5eastl6vectorIhNS_9allocatorEE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end34

if.else13:                                        ; preds = %lor.lhs.false
  %9 = load i64, ptr %n.addr, align 8
  %mpBegin14 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin14, align 8
  %mpEnd15 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd15, align 8
  %call = call noundef ptr @_ZN5eastl6vectorIhNS_9allocatorEE9DoReallocIPhEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9, ptr noundef %10, ptr noundef %11)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %12 = load ptr, ptr %mpBegin16, align 8
  %mpEnd17 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %13 = load ptr, ptr %mpEnd17, align 8
  call void @_ZN5eastl8destructIPhEEvT_S2_(ptr noundef %12, ptr noundef %13)
  %mpBegin18 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %14 = load ptr, ptr %mpBegin18, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %15 = load ptr, ptr %call19, align 8
  %mpBegin20 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %16 = load ptr, ptr %mpBegin20, align 8
  %sub.ptr.lhs.cast21 = ptrtoint ptr %15 to i64
  %sub.ptr.rhs.cast22 = ptrtoint ptr %16 to i64
  %sub.ptr.sub23 = sub i64 %sub.ptr.lhs.cast21, %sub.ptr.rhs.cast22
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEE6DoFreeEPhm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %14, i64 noundef %sub.ptr.sub23)
  %mpEnd24 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %17 = load ptr, ptr %mpEnd24, align 8
  %mpBegin25 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin25, align 8
  %sub.ptr.lhs.cast26 = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast27 = ptrtoint ptr %18 to i64
  %sub.ptr.sub28 = sub i64 %sub.ptr.lhs.cast26, %sub.ptr.rhs.cast27
  store i64 %sub.ptr.sub28, ptr %nPrevSize, align 8
  %19 = load ptr, ptr %pNewData, align 8
  %mpBegin29 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  store ptr %19, ptr %mpBegin29, align 8
  %20 = load ptr, ptr %pNewData, align 8
  %21 = load i64, ptr %nPrevSize, align 8
  %add.ptr = getelementptr inbounds i8, ptr %20, i64 %21
  %mpEnd30 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd30, align 8
  %mpBegin31 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin31, align 8
  %23 = load i64, ptr %n.addr, align 8
  %add.ptr32 = getelementptr inbounds i8, ptr %22, i64 %23
  %call33 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr32, ptr %call33, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.else13, %if.end12
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl6vectorIhNS_9allocatorEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 8, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %mFreeBitCount3, align 8
  %dec = add i64 %1, -1
  store i64 %dec, ptr %mFreeBitCount3, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl6vectorIhNS_9allocatorEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd2, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpEnd2, align 8
  store i8 0, ptr %2, align 1
  br label %if.end

if.else:                                          ; preds = %entry
  store i8 0, ptr %ref.tmp, align 1
  call void @_ZN5eastl6vectorIhNS_9allocatorEE16DoInsertValueEndIJhEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd3, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 -1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.13", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mReference, i64 16, i1 false)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIhEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %value) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %mask = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %sh_prom = trunc i64 %0 to i32
  %shl = shl i32 1, %sh_prom
  %conv = trunc i32 %shl to i8
  store i8 %conv, ptr %mask, align 1
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i8, ptr %mask, align 1
  %conv2 = zext i8 %2 to i32
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBitWord, align 8
  %4 = load i8, ptr %3, align 1
  %conv3 = zext i8 %4 to i32
  %or = or i32 %conv3, %conv2
  %conv4 = trunc i32 %or to i8
  store i8 %conv4, ptr %3, align 1
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load i8, ptr %mask, align 1
  %conv5 = zext i8 %5 to i32
  %not = xor i32 %conv5, -1
  %mpBitWord6 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBitWord6, align 8
  %7 = load i8, ptr %6, align 1
  %conv7 = zext i8 %7 to i32
  %and = and i32 %conv7, %not
  %conv8 = trunc i32 %and to i8
  store i8 %conv8, ptr %6, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mFreeBitCount, align 8
  %cmp = icmp eq i64 %inc, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIhNS_9allocatorEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %0, i32 -1
  store ptr %incdec.ptr, ptr %mpEnd, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.13", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl6vectorIhNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceIhEC2EPhm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl6vectorIhNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19bitvector_referenceIhEC2EPhm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %mpBitWord, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %i.addr, align 8
  store i64 %1, ptr %mnBitIndex, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference.13", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl6vectorIhNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceIhEC2EPhm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
  %call2 = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIhEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl6vectorIhNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIhEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load i8, ptr %0, align 1
  %conv = zext i8 %1 to i32
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mnBitIndex, align 8
  %sh_prom = trunc i64 %2 to i32
  %shl = shl i32 1, %sh_prom
  %and = and i32 %conv, %shl
  %cmp = icmp ne i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.13", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call3)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %8
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %ref.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call2)
  ret i1 %call3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference2, i32 0, i32 0
  %1 = load ptr, ptr %mpBitWord, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %1, i32 -1
  store ptr %incdec.ptr, ptr %mpBitWord, align 8
  %mReference3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex4 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference3, i32 0, i32 1
  store i64 8, ptr %mnBitIndex4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference5, i32 0, i32 1
  %2 = load i64, ptr %mnBitIndex6, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %mnBitIndex6, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIhEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %mReference)
  ret i1 %call
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %defaultValue) #0 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %defaultValue.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %defaultValue to i8
  store i8 %frombool, ptr %defaultValue.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %cmp = icmp ult i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %ref.tmp2, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %5 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %5)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %ref.tmp, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call4, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call4, 1
  store i64 %9, ptr %8, align 8
  %call6 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i1 %call6, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i8, ptr %defaultValue.addr, align 1
  %tobool = trunc i8 %10 to i1
  store i1 %tobool, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i1, ptr %retval, align 1
  ret i1 %11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %retval, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3setEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference.13", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp4 = alloca %"class.eastl::bitvector_iterator.11", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %cmp = icmp uge i64 %0, %call
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 1
  call void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %add)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call5 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp4, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %4 = extractvalue { ptr, i64 } %call5, 0
  store ptr %4, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %6 = extractvalue { ptr, i64 } %call5, 1
  store i64 %6, ptr %5, align 8
  %7 = load i64, ptr %n.addr, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4, i64 noundef %7)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp3, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive8, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call7, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call7, 1
  store i64 %11, ptr %10, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3)
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call10, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call10, 1
  store i64 %15, ptr %14, align 8
  %call11 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIhEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.11", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.13", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.11", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.13", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.11", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIhNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIhNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIhNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIhNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6insertENS_24bitvector_const_iteratorIhEEb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.11", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %n = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp5 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp14 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp20 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp21 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp23 = alloca %"class.eastl::bitvector_reference.13", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIhEC2ERNS_19bitvector_referenceIhEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIhEmiERKNS_24bitvector_const_iteratorIhEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %n, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call7 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive8, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call7, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call7, 1
  store i64 %9, ptr %8, align 8
  %10 = load i64, ptr %n, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6, i64 noundef %10)
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp5, i32 0, i32 0
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive11, i32 0, i32 0
  %11 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 0
  %12 = extractvalue { ptr, i64 } %call10, 0
  store ptr %12, ptr %11, align 8
  %13 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 1
  %14 = extractvalue { ptr, i64 } %call10, 1
  store i64 %14, ptr %13, align 8
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp5)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call16 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp15, i32 0, i32 0
  %coerce.dive18 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive17, i32 0, i32 0
  %15 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 0
  %16 = extractvalue { ptr, i64 } %call16, 0
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 1
  %18 = extractvalue { ptr, i64 } %call16, 1
  store i64 %18, ptr %17, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp14, ptr align 8 %call19, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp21, ptr align 8 %retval, i64 16, i1 false)
  %call22 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp21)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp20, ptr align 8 %call22, i64 16, i1 false)
  %19 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %22 = load i64, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 1
  %26 = load i64, ptr %25, align 8
  %27 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 1
  %30 = load i64, ptr %29, align 8
  call void @_ZN5eastl8MoveBitsIhEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %20, i64 %22, ptr %24, i64 %26, ptr %28, i64 %30)
  %31 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %31 to i1
  %call24 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %retval)
  %32 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 0
  %33 = extractvalue { ptr, i64 } %call24, 0
  store ptr %33, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 1
  %35 = extractvalue { ptr, i64 } %call24, 1
  store i64 %35, ptr %34, align 8
  %call25 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIhEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp23, i1 noundef zeroext %tobool)
  %coerce.dive26 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %retval, i32 0, i32 0
  %coerce.dive27 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive26, i32 0, i32 0
  %36 = load { ptr, i64 }, ptr %coerce.dive27, align 8
  ret { ptr, i64 } %36
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  ret ptr %mReference
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorIhEC2ERNS_19bitvector_referenceIhEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %reference) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %reference.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorIhEC2ERKNS_19bitvector_referenceIhEE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl18bitvector_iteratorIhEmiERKNS_24bitvector_const_iteratorIhEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef i64 @_ZNK5eastl24bitvector_const_iteratorIhEmiERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %0) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %1 = load ptr, ptr %.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %1)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8MoveBitsIhEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %start.coerce0, i64 %start.coerce1, ptr %end.coerce0, i64 %end.coerce1, ptr %dest.coerce0, i64 %dest.coerce1) #0 comdat {
entry:
  %start = alloca %"class.eastl::bitvector_iterator.11", align 8
  %end = alloca %"class.eastl::bitvector_iterator.11", align 8
  %dest = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference.13", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_reference.13", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_reference.13", align 8
  %ref.tmp17 = alloca %"class.eastl::bitvector_reference.13", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %start, i32 0, i32 0
  store ptr %start.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %start, i32 0, i32 1
  store i64 %start.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %end, i32 0, i32 0
  store ptr %end.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %end, i32 0, i32 1
  store i64 %end.coerce1, ptr %3, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %dest, i32 0, i32 0
  store ptr %dest.coerce0, ptr %4, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %dest, i32 0, i32 1
  store i64 %dest.coerce1, ptr %5, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEleERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %dest, ptr noundef nonnull align 8 dereferenceable(16) %start)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %call1 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %start, ptr noundef nonnull align 8 dereferenceable(16) %end)
  br i1 %call1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call2 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %start)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call2, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call2, 1
  store i64 %9, ptr %8, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %10 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp3, i32 0, i32 0
  %11 = extractvalue { ptr, i64 } %call4, 0
  store ptr %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp3, i32 0, i32 1
  %13 = extractvalue { ptr, i64 } %call4, 1
  store i64 %13, ptr %12, align 8
  %call5 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIhEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEppEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %call7 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEppEv(ptr noundef nonnull align 8 dereferenceable(16) %start)
  br label %while.cond, !llvm.loop !13

while.end:                                        ; preds = %while.cond
  br label %if.end

if.else:                                          ; preds = %entry
  %call8 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIhEmiERKNS_24bitvector_const_iteratorIhEE(ptr noundef nonnull align 8 dereferenceable(16) %end, ptr noundef nonnull align 8 dereferenceable(16) %start)
  %call9 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %dest, i64 noundef %call8)
  br label %while.cond10

while.cond10:                                     ; preds = %while.body12, %if.else
  %call11 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %start, ptr noundef nonnull align 8 dereferenceable(16) %end)
  br i1 %call11, label %while.body12, label %while.end20

while.body12:                                     ; preds = %while.cond10
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %end)
  %call16 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %end)
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp15, i32 0, i32 0
  %15 = extractvalue { ptr, i64 } %call16, 0
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp15, i32 0, i32 1
  %17 = extractvalue { ptr, i64 } %call16, 1
  store i64 %17, ptr %16, align 8
  %call18 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %18 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp17, i32 0, i32 0
  %19 = extractvalue { ptr, i64 } %call18, 0
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp17, i32 0, i32 1
  %21 = extractvalue { ptr, i64 } %call18, 1
  store i64 %21, ptr %20, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIhEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp17, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  br label %while.cond10, !llvm.loop !14

while.end20:                                      ; preds = %while.cond10
  br label %if.end

if.end:                                           ; preds = %while.end20, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6insertENS_24bitvector_const_iteratorIhEEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %position = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %iPosition = alloca %"class.eastl::bitvector_iterator.11", align 8
  %p = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp7 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %insert_end = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp18 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp19 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp26 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp28 = alloca %"class.eastl::bitvector_reference.13", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIhEC2ERNS_19bitvector_referenceIhEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIhEmiERKNS_24bitvector_const_iteratorIhEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %p, align 8
  %call5 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %6 = load i64, ptr %n.addr, align 8
  %add = add i64 %call5, %6
  call void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %add)
  %call8 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp7, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive9, i32 0, i32 0
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 0
  %8 = extractvalue { ptr, i64 } %call8, 0
  store ptr %8, ptr %7, align 8
  %9 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 1
  %10 = extractvalue { ptr, i64 } %call8, 1
  store i64 %10, ptr %9, align 8
  %11 = load i64, ptr %p, align 8
  %call11 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp7, i64 noundef %11)
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive12, i32 0, i32 0
  %12 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call11, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call11, 1
  store i64 %15, ptr %14, align 8
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6)
  %16 = load i64, ptr %n.addr, align 8
  %call15 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEplEl(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, i64 noundef %16)
  %coerce.dive16 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %insert_end, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive16, i32 0, i32 0
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 0
  %18 = extractvalue { ptr, i64 } %call15, 0
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 1
  %20 = extractvalue { ptr, i64 } %call15, 1
  store i64 %20, ptr %19, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iPosition, i64 16, i1 false)
  %call20 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive21 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %ref.tmp19, i32 0, i32 0
  %coerce.dive22 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive21, i32 0, i32 0
  %21 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 0
  %22 = extractvalue { ptr, i64 } %call20, 0
  store ptr %22, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 1
  %24 = extractvalue { ptr, i64 } %call20, 1
  store i64 %24, ptr %23, align 8
  %25 = load i64, ptr %n.addr, align 8
  %call23 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp19, i64 noundef %25)
  %coerce.dive24 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %agg.tmp18, i32 0, i32 0
  %coerce.dive25 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive24, i32 0, i32 0
  %26 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 0
  %27 = extractvalue { ptr, i64 } %call23, 0
  store ptr %27, ptr %26, align 8
  %28 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 1
  %29 = extractvalue { ptr, i64 } %call23, 1
  store i64 %29, ptr %28, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp26, ptr align 8 %insert_end, i64 16, i1 false)
  %30 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %33 = load i64, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 0
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 1
  %37 = load i64, ptr %36, align 8
  %38 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 1
  %41 = load i64, ptr %40, align 8
  call void @_ZN5eastl8MoveBitsIhEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %31, i64 %33, ptr %35, i64 %37, ptr %39, i64 %41)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call27 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %insert_end)
  br i1 %call27, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %42 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %42 to i1
  %call29 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIhEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  %43 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 0
  %44 = extractvalue { ptr, i64 } %call29, 0
  store ptr %44, ptr %43, align 8
  %45 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 1
  %46 = extractvalue { ptr, i64 } %call29, 1
  store i64 %46, ptr %45, align 8
  %call30 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIhEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp28, i1 noundef zeroext %tobool)
  %call31 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEppEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  br label %while.cond, !llvm.loop !15

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5eraseENS_24bitvector_const_iteratorIhEE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.11", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp6 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIhEC2ERNS_19bitvector_referenceIhEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %call2, i64 16, i1 false)
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %agg.tmp3, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call4, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call4, 1
  store i64 %5, ptr %4, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp6, ptr align 8 %retval, i64 16, i1 false)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  call void @_ZN5eastl8MoveBitsIhEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %7, i64 %9, ptr %11, i64 %13, ptr %15, i64 %17)
  %call7 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %sub = sub i64 %call7, 1
  call void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %sub)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive8, i32 0, i32 0
  %18 = load { ptr, i64 }, ptr %coerce.dive9, align 8
  ret { ptr, i64 } %18
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5eraseENS_24bitvector_const_iteratorIhEES6_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %first.coerce0, i64 %first.coerce1, ptr %last.coerce0, i64 %last.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.11", align 8
  %first = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %last = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  %iLast = alloca %"class.eastl::bitvector_iterator.11", align 8
  %eraseCount = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp5 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp8 = alloca %"class.eastl::bitvector_iterator.11", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 0
  store ptr %first.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 1
  store i64 %first.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 0
  store ptr %last.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 1
  store i64 %last.coerce1, ptr %3, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  call void @_ZN5eastl18bitvector_iteratorIhEC2ERNS_19bitvector_referenceIhEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  call void @_ZN5eastl18bitvector_iteratorIhEC2ERNS_19bitvector_referenceIhEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %call2)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %iLast)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIhEmiERKNS_24bitvector_const_iteratorIhEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %retval)
  store i64 %call4, ptr %eraseCount, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iLast, i64 16, i1 false)
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %agg.tmp5, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call6, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call6, 1
  store i64 %7, ptr %6, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp8, ptr align 8 %retval, i64 16, i1 false)
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 1
  %19 = load i64, ptr %18, align 8
  call void @_ZN5eastl8MoveBitsIhEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %9, i64 %11, ptr %13, i64 %15, ptr %17, i64 %19)
  %call9 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %20 = load i64, ptr %eraseCount, align 8
  %sub = sub i64 %call9, %20
  call void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %sub)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %retval, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive10, i32 0, i32 0
  %21 = load { ptr, i64 }, ptr %coerce.dive11, align 8
  ret { ptr, i64 } %21
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %cmp = icmp eq ptr %0, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference4, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %4, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference5, i32 0, i32 1
  %5 = load i64, ptr %mnBitIndex6, align 8
  %cmp7 = icmp eq i64 %3, %5
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %6
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIhEEEE(ptr noalias sret(%"class.eastl::reverse_iterator.14") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %position) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %position.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %position, ptr %position.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  %call3 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %call)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call3, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call3, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5eraseENS_24bitvector_const_iteratorIhEE(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %5, i64 %7)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive5, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call4, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call4, 1
  store i64 %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIhEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %13, i64 %15)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.15", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %mIterator)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.15", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mIterator, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIhEEEES8_(ptr noalias sret(%"class.eastl::reverse_iterator.14") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %first.indirect_addr = alloca ptr, align 8
  %last.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.11", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.indirect_addr, align 8
  store ptr %last, ptr %last.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIhEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %agg.tmp3, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5eraseENS_24bitvector_const_iteratorIhEES6_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %9, i64 %11, ptr %13, i64 %15)
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_iterator.11", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %coerce.dive7, i32 0, i32 0
  %16 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 0
  %17 = extractvalue { ptr, i64 } %call6, 0
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 1
  %19 = extractvalue { ptr, i64 } %call6, 1
  store i64 %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIhEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %21, i64 %23)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIhNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPhEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd3, align 8
  ret void

terminate.lpad:                                   ; preds = %entry
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  call void @__clang_call_terminate(ptr %4) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIhNS_9allocatorEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr null, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorIhNS_9allocatorEE8validateEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %conv = trunc i64 %0 to i32
  %cmp = icmp uge i32 %conv, 8
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %1 = load i1, ptr %retval, align 1
  ret i1 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorIhNS_9allocatorEE8validateEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %call, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %cmp3 = icmp ult ptr %2, %3
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %4 = load i1, ptr %retval, align 1
  ret i1 %4
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef i32 @_ZNK5eastl9bitvectorINS_9allocatorEhNS_6vectorIhS1_EEE17validate_iteratorENS_24bitvector_const_iteratorIhEE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %i.coerce0, i64 %i.coerce1) #0 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator.12", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIhNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 0
  %call3 = call noundef ptr @_ZNK5eastl6vectorIhNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer2) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.6", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mFreeBitCount, align 8
  %call4 = call noundef i32 @_ZNK5eastl24bitvector_const_iteratorIhE8validateEPKhS3_m(ptr noundef nonnull align 8 dereferenceable(16) %i, ptr noundef %call, ptr noundef %call3, i64 noundef %2)
  ret i32 %call4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK5eastl24bitvector_const_iteratorIhE8validateEPKhS3_m(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %pStart, ptr noundef %pEnd, i64 noundef %nExtraBits) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %pStart.addr = alloca ptr, align 8
  %pEnd.addr = alloca ptr, align 8
  %nExtraBits.addr = alloca i64, align 8
  %pCurrent = alloca ptr, align 8
  %bit = alloca i64, align 8
  %lastbit = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %pStart, ptr %pStart.addr, align 8
  store ptr %pEnd, ptr %pEnd.addr, align 8
  store i64 %nExtraBits, ptr %nExtraBits.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  store ptr %0, ptr %pCurrent, align 8
  %1 = load ptr, ptr %pCurrent, align 8
  %2 = load ptr, ptr %pStart.addr, align 8
  %cmp = icmp uge ptr %1, %2
  br i1 %cmp, label %if.then, label %if.end27

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %nExtraBits.addr, align 8
  %cmp2 = icmp eq i64 %3, 0
  br i1 %cmp2, label %if.then3, label %if.else10

if.then3:                                         ; preds = %if.then
  %4 = load ptr, ptr %pCurrent, align 8
  %5 = load ptr, ptr %pEnd.addr, align 8
  %cmp4 = icmp eq ptr %4, %5
  br i1 %cmp4, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then3
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIhEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %mReference5)
  br i1 %call, label %if.then6, label %if.else

if.then6:                                         ; preds = %land.lhs.true
  store i32 3, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %if.then3
  %6 = load ptr, ptr %pCurrent, align 8
  %7 = load ptr, ptr %pEnd.addr, align 8
  %cmp7 = icmp ult ptr %6, %7
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else
  store i32 7, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end
  br label %if.end26

if.else10:                                        ; preds = %if.then
  %8 = load ptr, ptr %pCurrent, align 8
  %9 = load ptr, ptr %pEnd.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %9, i64 -1
  %cmp11 = icmp eq ptr %8, %add.ptr
  br i1 %cmp11, label %if.then12, label %if.else21

if.then12:                                        ; preds = %if.else10
  %mReference13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference13, i32 0, i32 1
  %10 = load i64, ptr %mnBitIndex, align 8
  store i64 %10, ptr %bit, align 8
  %11 = load i64, ptr %nExtraBits.addr, align 8
  %sub = sub i64 8, %11
  store i64 %sub, ptr %lastbit, align 8
  %12 = load i64, ptr %bit, align 8
  %13 = load i64, ptr %lastbit, align 8
  %cmp14 = icmp eq i64 %12, %13
  br i1 %cmp14, label %if.then15, label %if.else16

if.then15:                                        ; preds = %if.then12
  store i32 3, ptr %retval, align 4
  br label %return

if.else16:                                        ; preds = %if.then12
  %14 = load i64, ptr %bit, align 8
  %15 = load i64, ptr %lastbit, align 8
  %cmp17 = icmp ult i64 %14, %15
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else16
  store i32 7, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.else16
  br label %if.end20

if.end20:                                         ; preds = %if.end19
  br label %if.end25

if.else21:                                        ; preds = %if.else10
  %16 = load ptr, ptr %pCurrent, align 8
  %17 = load ptr, ptr %pEnd.addr, align 8
  %cmp22 = icmp ult ptr %16, %17
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.else21
  store i32 7, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.else21
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end20
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end9
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then23, %if.then18, %if.then15, %if.then8, %if.then6
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC5Ev) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIsNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #1 comdat($_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC5ERKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 1 dereferenceable(1) %0) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  invoke void @_ZN5eastl10VectorBaseIsNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC5EmRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 16
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 16
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %div, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %2 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %2, 16
  %sub2 = sub i64 16, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %3 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %3, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %call = invoke noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPsmEET_S2_T0_(ptr noundef %2, i64 noundef %3)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin2, align 8
  %5 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %4, i64 %5
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %6 = landingpad { ptr, i32 }
          cleanup
  %7 = extractvalue { ptr, i32 } %6, 0
  store ptr %7, ptr %exn.slot, align 8
  %8 = extractvalue { ptr, i32 } %6, 1
  store i32 %8, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC2EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEC5EmbRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %allocator.addr = alloca ptr, align 8
  %ref.tmp = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 16
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 16
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i32 -1, i32 0
  %conv = trunc i32 %cond to i16
  store i16 %conv, ptr %ref.tmp, align 2
  %2 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEEC2EmRKsRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %div, ptr noundef nonnull align 2 dereferenceable(2) %ref.tmp, ptr noundef nonnull align 1 dereferenceable(1) %2)
  %3 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %3, 16
  %sub2 = sub i64 16, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %4 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %4, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEEC2EmRKsRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 2 dereferenceable(2) %value, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %4 = load ptr, ptr %value.addr, align 8
  invoke void @_ZN5eastl24uninitialized_fill_n_ptrIsmEEvPT_T0_RKS1_(ptr noundef %2, i64 noundef %3, ptr noundef nonnull align 2 dereferenceable(2) %4)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin2, align 8
  %6 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %5, i64 %6
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %7 = landingpad { ptr, i32 }
          cleanup
  %8 = extractvalue { ptr, i32 } %7, 0
  store ptr %8, ptr %exn.slot, align 8
  %9 = extractvalue { ptr, i32 } %7, 1
  store i32 %9, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4swapERS4_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %0, i32 0, i32 0
  call void @_ZN5eastl6vectorIsNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 8 dereferenceable(24) %mContainer2)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %rhs.addr, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapImEEvRT_S2_(ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount, ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount3) #9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.21", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIsNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorIsEC2EPsm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIsNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorIsEC2EPsm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorIsEC2EPKsm(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIsNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIsEC2EPKsm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIsNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorIsEC2EPKsm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  call void @_ZN5eastl19bitvector_referenceIsEC2EPsm(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6cbeginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIsNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIsEC2EPKsm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.21", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIsNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorIsEC2EPsm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %retval, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %retval, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive5, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive6, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIsNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.21", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIsNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIsEC2EPKsm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIsEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIsNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIsEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %retval, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4cendEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIsNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIsEC2EPKsm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIsEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.24") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIsEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIsEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %i.coerce0, i64 %i.coerce1) unnamed_addr #1 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_iterator.21", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.24", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %i, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.25") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %i.coerce0, i64 %i.coerce1) unnamed_addr #1 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.25", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %i, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE7crbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.25") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator.24") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIsEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator.25") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5crendEv(ptr noalias sret(%"class.eastl::reverse_iterator.25") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorIsNS_9allocatorEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorIsNS_9allocatorEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %cmp = icmp eq ptr %0, %1
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorIsNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mul = mul i64 %call, 16
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %sub = sub i64 %mul, %0
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorIsNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorIsNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mul = mul i64 %call, 16
  ret i64 %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorIsNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %0 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %s = alloca i64, align 8
  %newbits = alloca i64, align 8
  %element = alloca i16, align 2
  %words = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  store i64 %call, ptr %s, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %s, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, ptr %n.addr, align 8
  %4 = load i64, ptr %s, align 8
  %sub = sub i64 %3, %4
  store i64 %sub, ptr %newbits, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %5 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %6 = load i64, ptr %newbits, align 8
  %tobool2 = icmp ne i64 %6, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %tobool2, %land.rhs ]
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %8 = load i8, ptr %value.addr, align 1
  %tobool3 = trunc i8 %8 to i1
  call void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this1, i1 noundef zeroext %tobool3)
  %9 = load i64, ptr %newbits, align 8
  %dec = add i64 %9, -1
  store i64 %dec, ptr %newbits, align 8
  br label %while.cond, !llvm.loop !16

while.end:                                        ; preds = %land.end
  %10 = load i64, ptr %newbits, align 8
  %tobool4 = icmp ne i64 %10, 0
  br i1 %tobool4, label %if.then5, label %if.end13

if.then5:                                         ; preds = %while.end
  store i16 0, ptr %element, align 2
  %11 = load i8, ptr %value.addr, align 1
  %tobool6 = trunc i8 %11 to i1
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.then5
  %12 = load i16, ptr %element, align 2
  %conv = sext i16 %12 to i32
  %not = xor i32 %conv, -1
  %conv8 = trunc i32 %not to i16
  store i16 %conv8, ptr %element, align 2
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %if.then5
  %13 = load i64, ptr %n.addr, align 8
  %add = add i64 %13, 16
  %sub10 = sub i64 %add, 1
  %div = udiv i64 %sub10, 16
  store i64 %div, ptr %words, align 8
  %14 = load i64, ptr %words, align 8
  %mul = mul i64 %14, 16
  %15 = load i64, ptr %n.addr, align 8
  %sub11 = sub i64 %mul, %15
  store i64 %sub11, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %16 = load i64, ptr %words, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEE6resizeEmRKs(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %16, ptr noundef nonnull align 2 dereferenceable(2) %element)
  %17 = load i64, ptr %extra, align 8
  %mFreeBitCount12 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 %17, ptr %mFreeBitCount12, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.end9, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 16
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 16
  store i64 %div, ptr %wordCount, align 8
  %1 = load i64, ptr %wordCount, align 8
  %mul = mul i64 %1, 16
  %2 = load i64, ptr %n.addr, align 8
  %sub2 = sub i64 %mul, %2
  store i64 %sub2, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %3 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %3)
  %4 = load i64, ptr %extra, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 %4, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference.23", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.21", align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %0 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %0 to i1
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call, 1
  store i64 %4, ptr %3, align 8
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2)
  %call5 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call4)
  %5 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call5, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call5, 1
  store i64 %8, ptr %7, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIsEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE6resizeEmRKs(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 2 dereferenceable(2) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 2
  %sub = sub i64 %3, %sub.ptr.div7
  %6 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEE17DoInsertValuesEndEmRKs(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub, ptr noundef nonnull align 2 dereferenceable(2) %6)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin8, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %7, i64 %8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %9 = load ptr, ptr %mpEnd9, align 8
  call void @_ZN5eastl8destructIPsEEvT_S2_(ptr noundef %add.ptr, ptr noundef %9)
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %11 = load i64, ptr %n.addr, align 8
  %add.ptr11 = getelementptr inbounds i16, ptr %10, i64 %11
  %mpEnd12 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %add.ptr11, ptr %mpEnd12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 2
  %sub = sub i64 %3, %sub.ptr.div7
  call void @_ZN5eastl6vectorIsNS_9allocatorEE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin8, align 8
  %7 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %6, i64 %7
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %8 = load ptr, ptr %mpEnd9, align 8
  call void @_ZN5eastl8destructIPsEEvT_S2_(ptr noundef %add.ptr, ptr noundef %8)
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %9 = load ptr, ptr %mpBegin10, align 8
  %10 = load i64, ptr %n.addr, align 8
  %add.ptr11 = getelementptr inbounds i16, ptr %9, i64 %10
  %mpEnd12 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %add.ptr11, ptr %mpEnd12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 16
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 16
  store i64 %div, ptr %wordCount, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIsNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef -1)
  br label %if.end

if.else:                                          ; preds = %entry
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 16
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 16
  call void @_ZN5eastl6vectorIsNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer2, i64 noundef %div)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  %cmp2 = icmp ule i64 %1, %sub.ptr.div
  br i1 %cmp2, label %if.then, label %if.else14

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load i64, ptr %n.addr, align 8
  %cmp3 = icmp eq i64 %4, 0
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  call void @_ZN5eastl6vectorIsNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %if.end13

if.else:                                          ; preds = %if.then
  %5 = load i64, ptr %n.addr, align 8
  %mpEnd5 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %6 = load ptr, ptr %mpEnd5, align 8
  %mpBegin6 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin6, align 8
  %sub.ptr.lhs.cast7 = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast8 = ptrtoint ptr %7 to i64
  %sub.ptr.sub9 = sub i64 %sub.ptr.lhs.cast7, %sub.ptr.rhs.cast8
  %sub.ptr.div10 = sdiv exact i64 %sub.ptr.sub9, 2
  %cmp11 = icmp ult i64 %5, %sub.ptr.div10
  br i1 %cmp11, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.else
  %8 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then12, %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then4
  call void @_ZN5eastl6vectorIsNS_9allocatorEE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end37

if.else14:                                        ; preds = %lor.lhs.false
  %9 = load i64, ptr %n.addr, align 8
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin15, align 8
  %mpEnd16 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd16, align 8
  %call = call noundef ptr @_ZN5eastl6vectorIsNS_9allocatorEE9DoReallocIPsEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9, ptr noundef %10, ptr noundef %11)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %12 = load ptr, ptr %mpBegin17, align 8
  %mpEnd18 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %13 = load ptr, ptr %mpEnd18, align 8
  call void @_ZN5eastl8destructIPsEEvT_S2_(ptr noundef %12, ptr noundef %13)
  %mpBegin19 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %14 = load ptr, ptr %mpBegin19, align 8
  %call20 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %15 = load ptr, ptr %call20, align 8
  %mpBegin21 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %16 = load ptr, ptr %mpBegin21, align 8
  %sub.ptr.lhs.cast22 = ptrtoint ptr %15 to i64
  %sub.ptr.rhs.cast23 = ptrtoint ptr %16 to i64
  %sub.ptr.sub24 = sub i64 %sub.ptr.lhs.cast22, %sub.ptr.rhs.cast23
  %sub.ptr.div25 = sdiv exact i64 %sub.ptr.sub24, 2
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEE6DoFreeEPsm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %14, i64 noundef %sub.ptr.div25)
  %mpEnd26 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %17 = load ptr, ptr %mpEnd26, align 8
  %mpBegin27 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin27, align 8
  %sub.ptr.lhs.cast28 = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast29 = ptrtoint ptr %18 to i64
  %sub.ptr.sub30 = sub i64 %sub.ptr.lhs.cast28, %sub.ptr.rhs.cast29
  %sub.ptr.div31 = sdiv exact i64 %sub.ptr.sub30, 2
  store i64 %sub.ptr.div31, ptr %nPrevSize, align 8
  %19 = load ptr, ptr %pNewData, align 8
  %mpBegin32 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  store ptr %19, ptr %mpBegin32, align 8
  %20 = load ptr, ptr %pNewData, align 8
  %21 = load i64, ptr %nPrevSize, align 8
  %add.ptr = getelementptr inbounds i16, ptr %20, i64 %21
  %mpEnd33 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd33, align 8
  %mpBegin34 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin34, align 8
  %23 = load i64, ptr %n.addr, align 8
  %add.ptr35 = getelementptr inbounds i16, ptr %22, i64 %23
  %call36 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr35, ptr %call36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.else14, %if.end13
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN5eastl6vectorIsNS_9allocatorEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 16, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %mFreeBitCount3, align 8
  %dec = add i64 %1, -1
  store i64 %dec, ptr %mFreeBitCount3, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 2 dereferenceable(2) ptr @_ZN5eastl6vectorIsNS_9allocatorEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd2, align 8
  %incdec.ptr = getelementptr inbounds i16, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpEnd2, align 8
  store i16 0, ptr %2, align 2
  br label %if.end

if.else:                                          ; preds = %entry
  store i16 0, ptr %ref.tmp, align 2
  call void @_ZN5eastl6vectorIsNS_9allocatorEE16DoInsertValueEndIJsEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 2 dereferenceable(2) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd3, align 8
  %add.ptr = getelementptr inbounds i16, ptr %3, i64 -1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.23", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mReference, i64 16, i1 false)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIsEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %value) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %mask = alloca i16, align 2
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %sh_prom = trunc i64 %0 to i32
  %shl = shl i32 1, %sh_prom
  %conv = trunc i32 %shl to i16
  store i16 %conv, ptr %mask, align 2
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i16, ptr %mask, align 2
  %conv2 = sext i16 %2 to i32
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBitWord, align 8
  %4 = load i16, ptr %3, align 2
  %conv3 = sext i16 %4 to i32
  %or = or i32 %conv3, %conv2
  %conv4 = trunc i32 %or to i16
  store i16 %conv4, ptr %3, align 2
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load i16, ptr %mask, align 2
  %conv5 = sext i16 %5 to i32
  %not = xor i32 %conv5, -1
  %mpBitWord6 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBitWord6, align 8
  %7 = load i16, ptr %6, align 2
  %conv7 = sext i16 %7 to i32
  %and = and i32 %conv7, %not
  %conv8 = trunc i32 %and to i16
  store i16 %conv8, ptr %6, align 2
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mFreeBitCount, align 8
  %cmp = icmp eq i64 %inc, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIsNS_9allocatorEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %incdec.ptr = getelementptr inbounds i16, ptr %0, i32 -1
  store ptr %incdec.ptr, ptr %mpEnd, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.23", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN5eastl6vectorIsNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceIsEC2EPsm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 2 dereferenceable(2) ptr @_ZN5eastl6vectorIsNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19bitvector_referenceIsEC2EPsm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %mpBitWord, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %i.addr, align 8
  store i64 %1, ptr %mnBitIndex, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference.23", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 2 dereferenceable(2) ptr @_ZNK5eastl6vectorIsNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceIsEC2EPsm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
  %call2 = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIsEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 2 dereferenceable(2) ptr @_ZNK5eastl6vectorIsNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIsEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load i16, ptr %0, align 2
  %conv = sext i16 %1 to i32
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mnBitIndex, align 8
  %sh_prom = trunc i64 %2 to i32
  %shl = shl i32 1, %sh_prom
  %and = and i32 %conv, %shl
  %cmp = icmp ne i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.23", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call3)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %8
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %ref.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call2)
  ret i1 %call3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference2, i32 0, i32 0
  %1 = load ptr, ptr %mpBitWord, align 8
  %incdec.ptr = getelementptr inbounds i16, ptr %1, i32 -1
  store ptr %incdec.ptr, ptr %mpBitWord, align 8
  %mReference3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex4 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference3, i32 0, i32 1
  store i64 16, ptr %mnBitIndex4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference5, i32 0, i32 1
  %2 = load i64, ptr %mnBitIndex6, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %mnBitIndex6, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIsEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %mReference)
  ret i1 %call
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %defaultValue) #0 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %defaultValue.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %defaultValue to i8
  store i8 %frombool, ptr %defaultValue.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %cmp = icmp ult i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %ref.tmp2, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %5 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %5)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %ref.tmp, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call4, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call4, 1
  store i64 %9, ptr %8, align 8
  %call6 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i1 %call6, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i8, ptr %defaultValue.addr, align 1
  %tobool = trunc i8 %10 to i1
  store i1 %tobool, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i1, ptr %retval, align 1
  ret i1 %11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %retval, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3setEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference.23", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp4 = alloca %"class.eastl::bitvector_iterator.21", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %cmp = icmp uge i64 %0, %call
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 1
  call void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %add)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call5 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp4, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %4 = extractvalue { ptr, i64 } %call5, 0
  store ptr %4, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %6 = extractvalue { ptr, i64 } %call5, 1
  store i64 %6, ptr %5, align 8
  %7 = load i64, ptr %n.addr, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4, i64 noundef %7)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp3, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive8, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call7, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call7, 1
  store i64 %11, ptr %10, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3)
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call10, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call10, 1
  store i64 %15, ptr %14, align 8
  %call11 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIsEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.21", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.23", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.21", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.23", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.21", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIsNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIsNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIsNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIsNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6insertENS_24bitvector_const_iteratorIsEEb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.21", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %n = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp5 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp14 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp20 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp21 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp23 = alloca %"class.eastl::bitvector_reference.23", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIsEC2ERNS_19bitvector_referenceIsEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIsEmiERKNS_24bitvector_const_iteratorIsEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %n, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call7 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive8, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call7, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call7, 1
  store i64 %9, ptr %8, align 8
  %10 = load i64, ptr %n, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6, i64 noundef %10)
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp5, i32 0, i32 0
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive11, i32 0, i32 0
  %11 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 0
  %12 = extractvalue { ptr, i64 } %call10, 0
  store ptr %12, ptr %11, align 8
  %13 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 1
  %14 = extractvalue { ptr, i64 } %call10, 1
  store i64 %14, ptr %13, align 8
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp5)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call16 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp15, i32 0, i32 0
  %coerce.dive18 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive17, i32 0, i32 0
  %15 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 0
  %16 = extractvalue { ptr, i64 } %call16, 0
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 1
  %18 = extractvalue { ptr, i64 } %call16, 1
  store i64 %18, ptr %17, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp14, ptr align 8 %call19, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp21, ptr align 8 %retval, i64 16, i1 false)
  %call22 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp21)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp20, ptr align 8 %call22, i64 16, i1 false)
  %19 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %22 = load i64, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 1
  %26 = load i64, ptr %25, align 8
  %27 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 1
  %30 = load i64, ptr %29, align 8
  call void @_ZN5eastl8MoveBitsIsEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %20, i64 %22, ptr %24, i64 %26, ptr %28, i64 %30)
  %31 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %31 to i1
  %call24 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %retval)
  %32 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 0
  %33 = extractvalue { ptr, i64 } %call24, 0
  store ptr %33, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 1
  %35 = extractvalue { ptr, i64 } %call24, 1
  store i64 %35, ptr %34, align 8
  %call25 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIsEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp23, i1 noundef zeroext %tobool)
  %coerce.dive26 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %retval, i32 0, i32 0
  %coerce.dive27 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive26, i32 0, i32 0
  %36 = load { ptr, i64 }, ptr %coerce.dive27, align 8
  ret { ptr, i64 } %36
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  ret ptr %mReference
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorIsEC2ERNS_19bitvector_referenceIsEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %reference) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %reference.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorIsEC2ERKNS_19bitvector_referenceIsEE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl18bitvector_iteratorIsEmiERKNS_24bitvector_const_iteratorIsEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef i64 @_ZNK5eastl24bitvector_const_iteratorIsEmiERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %0) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %1 = load ptr, ptr %.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %1)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8MoveBitsIsEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %start.coerce0, i64 %start.coerce1, ptr %end.coerce0, i64 %end.coerce1, ptr %dest.coerce0, i64 %dest.coerce1) #0 comdat {
entry:
  %start = alloca %"class.eastl::bitvector_iterator.21", align 8
  %end = alloca %"class.eastl::bitvector_iterator.21", align 8
  %dest = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference.23", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_reference.23", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_reference.23", align 8
  %ref.tmp17 = alloca %"class.eastl::bitvector_reference.23", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %start, i32 0, i32 0
  store ptr %start.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %start, i32 0, i32 1
  store i64 %start.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %end, i32 0, i32 0
  store ptr %end.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %end, i32 0, i32 1
  store i64 %end.coerce1, ptr %3, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %dest, i32 0, i32 0
  store ptr %dest.coerce0, ptr %4, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %dest, i32 0, i32 1
  store i64 %dest.coerce1, ptr %5, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEleERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %dest, ptr noundef nonnull align 8 dereferenceable(16) %start)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %call1 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %start, ptr noundef nonnull align 8 dereferenceable(16) %end)
  br i1 %call1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call2 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %start)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call2, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call2, 1
  store i64 %9, ptr %8, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %10 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp3, i32 0, i32 0
  %11 = extractvalue { ptr, i64 } %call4, 0
  store ptr %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp3, i32 0, i32 1
  %13 = extractvalue { ptr, i64 } %call4, 1
  store i64 %13, ptr %12, align 8
  %call5 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIsEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEppEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %call7 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEppEv(ptr noundef nonnull align 8 dereferenceable(16) %start)
  br label %while.cond, !llvm.loop !17

while.end:                                        ; preds = %while.cond
  br label %if.end

if.else:                                          ; preds = %entry
  %call8 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIsEmiERKNS_24bitvector_const_iteratorIsEE(ptr noundef nonnull align 8 dereferenceable(16) %end, ptr noundef nonnull align 8 dereferenceable(16) %start)
  %call9 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %dest, i64 noundef %call8)
  br label %while.cond10

while.cond10:                                     ; preds = %while.body12, %if.else
  %call11 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %start, ptr noundef nonnull align 8 dereferenceable(16) %end)
  br i1 %call11, label %while.body12, label %while.end20

while.body12:                                     ; preds = %while.cond10
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %end)
  %call16 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %end)
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp15, i32 0, i32 0
  %15 = extractvalue { ptr, i64 } %call16, 0
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp15, i32 0, i32 1
  %17 = extractvalue { ptr, i64 } %call16, 1
  store i64 %17, ptr %16, align 8
  %call18 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %18 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp17, i32 0, i32 0
  %19 = extractvalue { ptr, i64 } %call18, 0
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp17, i32 0, i32 1
  %21 = extractvalue { ptr, i64 } %call18, 1
  store i64 %21, ptr %20, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIsEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp17, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  br label %while.cond10, !llvm.loop !18

while.end20:                                      ; preds = %while.cond10
  br label %if.end

if.end:                                           ; preds = %while.end20, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6insertENS_24bitvector_const_iteratorIsEEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %position = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %iPosition = alloca %"class.eastl::bitvector_iterator.21", align 8
  %p = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp7 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %insert_end = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp18 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp19 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp26 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp28 = alloca %"class.eastl::bitvector_reference.23", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIsEC2ERNS_19bitvector_referenceIsEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIsEmiERKNS_24bitvector_const_iteratorIsEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %p, align 8
  %call5 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %6 = load i64, ptr %n.addr, align 8
  %add = add i64 %call5, %6
  call void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %add)
  %call8 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp7, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive9, i32 0, i32 0
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 0
  %8 = extractvalue { ptr, i64 } %call8, 0
  store ptr %8, ptr %7, align 8
  %9 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 1
  %10 = extractvalue { ptr, i64 } %call8, 1
  store i64 %10, ptr %9, align 8
  %11 = load i64, ptr %p, align 8
  %call11 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp7, i64 noundef %11)
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive12, i32 0, i32 0
  %12 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call11, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call11, 1
  store i64 %15, ptr %14, align 8
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6)
  %16 = load i64, ptr %n.addr, align 8
  %call15 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEplEl(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, i64 noundef %16)
  %coerce.dive16 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %insert_end, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive16, i32 0, i32 0
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 0
  %18 = extractvalue { ptr, i64 } %call15, 0
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 1
  %20 = extractvalue { ptr, i64 } %call15, 1
  store i64 %20, ptr %19, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iPosition, i64 16, i1 false)
  %call20 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive21 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %ref.tmp19, i32 0, i32 0
  %coerce.dive22 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive21, i32 0, i32 0
  %21 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 0
  %22 = extractvalue { ptr, i64 } %call20, 0
  store ptr %22, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 1
  %24 = extractvalue { ptr, i64 } %call20, 1
  store i64 %24, ptr %23, align 8
  %25 = load i64, ptr %n.addr, align 8
  %call23 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp19, i64 noundef %25)
  %coerce.dive24 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %agg.tmp18, i32 0, i32 0
  %coerce.dive25 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive24, i32 0, i32 0
  %26 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 0
  %27 = extractvalue { ptr, i64 } %call23, 0
  store ptr %27, ptr %26, align 8
  %28 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 1
  %29 = extractvalue { ptr, i64 } %call23, 1
  store i64 %29, ptr %28, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp26, ptr align 8 %insert_end, i64 16, i1 false)
  %30 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %33 = load i64, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 0
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 1
  %37 = load i64, ptr %36, align 8
  %38 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 1
  %41 = load i64, ptr %40, align 8
  call void @_ZN5eastl8MoveBitsIsEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %31, i64 %33, ptr %35, i64 %37, ptr %39, i64 %41)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call27 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %insert_end)
  br i1 %call27, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %42 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %42 to i1
  %call29 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIsEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  %43 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 0
  %44 = extractvalue { ptr, i64 } %call29, 0
  store ptr %44, ptr %43, align 8
  %45 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 1
  %46 = extractvalue { ptr, i64 } %call29, 1
  store i64 %46, ptr %45, align 8
  %call30 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIsEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp28, i1 noundef zeroext %tobool)
  %call31 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEppEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  br label %while.cond, !llvm.loop !19

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5eraseENS_24bitvector_const_iteratorIsEE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.21", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp6 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIsEC2ERNS_19bitvector_referenceIsEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %call2, i64 16, i1 false)
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %agg.tmp3, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call4, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call4, 1
  store i64 %5, ptr %4, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp6, ptr align 8 %retval, i64 16, i1 false)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  call void @_ZN5eastl8MoveBitsIsEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %7, i64 %9, ptr %11, i64 %13, ptr %15, i64 %17)
  %call7 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %sub = sub i64 %call7, 1
  call void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %sub)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive8, i32 0, i32 0
  %18 = load { ptr, i64 }, ptr %coerce.dive9, align 8
  ret { ptr, i64 } %18
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5eraseENS_24bitvector_const_iteratorIsEES6_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %first.coerce0, i64 %first.coerce1, ptr %last.coerce0, i64 %last.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.21", align 8
  %first = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %last = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  %iLast = alloca %"class.eastl::bitvector_iterator.21", align 8
  %eraseCount = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp5 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp8 = alloca %"class.eastl::bitvector_iterator.21", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 0
  store ptr %first.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 1
  store i64 %first.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 0
  store ptr %last.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 1
  store i64 %last.coerce1, ptr %3, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  call void @_ZN5eastl18bitvector_iteratorIsEC2ERNS_19bitvector_referenceIsEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  call void @_ZN5eastl18bitvector_iteratorIsEC2ERNS_19bitvector_referenceIsEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %call2)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %iLast)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIsEmiERKNS_24bitvector_const_iteratorIsEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %retval)
  store i64 %call4, ptr %eraseCount, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iLast, i64 16, i1 false)
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %agg.tmp5, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call6, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call6, 1
  store i64 %7, ptr %6, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp8, ptr align 8 %retval, i64 16, i1 false)
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 1
  %19 = load i64, ptr %18, align 8
  call void @_ZN5eastl8MoveBitsIsEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %9, i64 %11, ptr %13, i64 %15, ptr %17, i64 %19)
  %call9 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %20 = load i64, ptr %eraseCount, align 8
  %sub = sub i64 %call9, %20
  call void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %sub)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %retval, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive10, i32 0, i32 0
  %21 = load { ptr, i64 }, ptr %coerce.dive11, align 8
  ret { ptr, i64 } %21
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %cmp = icmp eq ptr %0, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference4, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %4, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference5, i32 0, i32 1
  %5 = load i64, ptr %mnBitIndex6, align 8
  %cmp7 = icmp eq i64 %3, %5
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %6
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIsEEEE(ptr noalias sret(%"class.eastl::reverse_iterator.24") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %position) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %position.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %position, ptr %position.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  %call3 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %call)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call3, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call3, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5eraseENS_24bitvector_const_iteratorIsEE(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %5, i64 %7)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive5, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call4, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call4, 1
  store i64 %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIsEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %13, i64 %15)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.25", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %mIterator)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.25", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mIterator, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIsEEEES8_(ptr noalias sret(%"class.eastl::reverse_iterator.24") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %first.indirect_addr = alloca ptr, align 8
  %last.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.21", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.indirect_addr, align 8
  store ptr %last, ptr %last.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIsEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %agg.tmp3, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5eraseENS_24bitvector_const_iteratorIsEES6_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %9, i64 %11, ptr %13, i64 %15)
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_iterator.21", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %coerce.dive7, i32 0, i32 0
  %16 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 0
  %17 = extractvalue { ptr, i64 } %call6, 0
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 1
  %19 = extractvalue { ptr, i64 } %call6, 1
  store i64 %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIsEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %21, i64 %23)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIsNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPsEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd3, align 8
  ret void

terminate.lpad:                                   ; preds = %entry
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  call void @__clang_call_terminate(ptr %4) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIsNS_9allocatorEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr null, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorIsNS_9allocatorEE8validateEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %conv = trunc i64 %0 to i32
  %cmp = icmp uge i32 %conv, 16
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %1 = load i1, ptr %retval, align 1
  ret i1 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorIsNS_9allocatorEE8validateEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %call, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %cmp3 = icmp ult ptr %2, %3
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %4 = load i1, ptr %retval, align 1
  ret i1 %4
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef i32 @_ZNK5eastl9bitvectorINS_9allocatorEsNS_6vectorIsS1_EEE17validate_iteratorENS_24bitvector_const_iteratorIsEE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %i.coerce0, i64 %i.coerce1) #0 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator.22", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIsNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 0
  %call3 = call noundef ptr @_ZNK5eastl6vectorIsNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer2) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.16", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mFreeBitCount, align 8
  %call4 = call noundef i32 @_ZNK5eastl24bitvector_const_iteratorIsE8validateEPKsS3_m(ptr noundef nonnull align 8 dereferenceable(16) %i, ptr noundef %call, ptr noundef %call3, i64 noundef %2)
  ret i32 %call4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK5eastl24bitvector_const_iteratorIsE8validateEPKsS3_m(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %pStart, ptr noundef %pEnd, i64 noundef %nExtraBits) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %pStart.addr = alloca ptr, align 8
  %pEnd.addr = alloca ptr, align 8
  %nExtraBits.addr = alloca i64, align 8
  %pCurrent = alloca ptr, align 8
  %bit = alloca i64, align 8
  %lastbit = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %pStart, ptr %pStart.addr, align 8
  store ptr %pEnd, ptr %pEnd.addr, align 8
  store i64 %nExtraBits, ptr %nExtraBits.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  store ptr %0, ptr %pCurrent, align 8
  %1 = load ptr, ptr %pCurrent, align 8
  %2 = load ptr, ptr %pStart.addr, align 8
  %cmp = icmp uge ptr %1, %2
  br i1 %cmp, label %if.then, label %if.end27

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %nExtraBits.addr, align 8
  %cmp2 = icmp eq i64 %3, 0
  br i1 %cmp2, label %if.then3, label %if.else10

if.then3:                                         ; preds = %if.then
  %4 = load ptr, ptr %pCurrent, align 8
  %5 = load ptr, ptr %pEnd.addr, align 8
  %cmp4 = icmp eq ptr %4, %5
  br i1 %cmp4, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then3
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIsEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %mReference5)
  br i1 %call, label %if.then6, label %if.else

if.then6:                                         ; preds = %land.lhs.true
  store i32 3, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %if.then3
  %6 = load ptr, ptr %pCurrent, align 8
  %7 = load ptr, ptr %pEnd.addr, align 8
  %cmp7 = icmp ult ptr %6, %7
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else
  store i32 7, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end
  br label %if.end26

if.else10:                                        ; preds = %if.then
  %8 = load ptr, ptr %pCurrent, align 8
  %9 = load ptr, ptr %pEnd.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %9, i64 -1
  %cmp11 = icmp eq ptr %8, %add.ptr
  br i1 %cmp11, label %if.then12, label %if.else21

if.then12:                                        ; preds = %if.else10
  %mReference13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference13, i32 0, i32 1
  %10 = load i64, ptr %mnBitIndex, align 8
  store i64 %10, ptr %bit, align 8
  %11 = load i64, ptr %nExtraBits.addr, align 8
  %sub = sub i64 16, %11
  store i64 %sub, ptr %lastbit, align 8
  %12 = load i64, ptr %bit, align 8
  %13 = load i64, ptr %lastbit, align 8
  %cmp14 = icmp eq i64 %12, %13
  br i1 %cmp14, label %if.then15, label %if.else16

if.then15:                                        ; preds = %if.then12
  store i32 3, ptr %retval, align 4
  br label %return

if.else16:                                        ; preds = %if.then12
  %14 = load i64, ptr %bit, align 8
  %15 = load i64, ptr %lastbit, align 8
  %cmp17 = icmp ult i64 %14, %15
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else16
  store i32 7, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.else16
  br label %if.end20

if.end20:                                         ; preds = %if.end19
  br label %if.end25

if.else21:                                        ; preds = %if.else10
  %16 = load ptr, ptr %pCurrent, align 8
  %17 = load ptr, ptr %pEnd.addr, align 8
  %cmp22 = icmp ult ptr %16, %17
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.else21
  store i32 7, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.else21
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end20
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end9
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then23, %if.then18, %if.then15, %if.then8, %if.then6
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC5Ev) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIiNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #1 comdat($_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC5ERKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 1 dereferenceable(1) %0) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  invoke void @_ZN5eastl10VectorBaseIiNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC5EmRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 32
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 32
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %div, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %2 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %2, 32
  %sub2 = sub i64 32, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %3 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %3, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %call = invoke noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPimEET_S2_T0_(ptr noundef %2, i64 noundef %3)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin2, align 8
  %5 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i32, ptr %4, i64 %5
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %6 = landingpad { ptr, i32 }
          cleanup
  %7 = extractvalue { ptr, i32 } %6, 0
  store ptr %7, ptr %exn.slot, align 8
  %8 = extractvalue { ptr, i32 } %6, 1
  store i32 %8, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC2EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEC5EmbRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %allocator.addr = alloca ptr, align 8
  %ref.tmp = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 32
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 32
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i32 -1, i32 0
  store i32 %cond, ptr %ref.tmp, align 4
  %2 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEEC2EmRKiRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %div, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp, ptr noundef nonnull align 1 dereferenceable(1) %2)
  %3 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %3, 32
  %sub2 = sub i64 32, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %4 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %4, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEEC2EmRKiRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 4 dereferenceable(4) %value, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %4 = load ptr, ptr %value.addr, align 8
  invoke void @_ZN5eastl24uninitialized_fill_n_ptrIimEEvPT_T0_RKS1_(ptr noundef %2, i64 noundef %3, ptr noundef nonnull align 4 dereferenceable(4) %4)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin2, align 8
  %6 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i32, ptr %5, i64 %6
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %7 = landingpad { ptr, i32 }
          cleanup
  %8 = extractvalue { ptr, i32 } %7, 0
  store ptr %8, ptr %exn.slot, align 8
  %9 = extractvalue { ptr, i32 } %7, 1
  store i32 %9, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4swapERS4_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %0, i32 0, i32 0
  call void @_ZN5eastl6vectorIiNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 8 dereferenceable(24) %mContainer2)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %rhs.addr, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapImEEvRT_S2_(ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount, ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount3) #9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.31", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIiNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorIiEC2EPim(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIiNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorIiEC2EPim(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorIiEC2EPKim(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIiNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIiEC2EPKim(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIiNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorIiEC2EPKim(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  call void @_ZN5eastl19bitvector_referenceIiEC2EPim(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6cbeginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIiNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIiEC2EPKim(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.31", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIiNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorIiEC2EPim(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %retval, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %retval, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive5, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive6, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIiNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.31", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIiNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIiEC2EPKim(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIiEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIiNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIiEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %retval, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4cendEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIiNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIiEC2EPKim(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIiEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.34") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIiEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIiEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %i.coerce0, i64 %i.coerce1) unnamed_addr #1 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_iterator.31", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.34", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %i, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.35") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %i.coerce0, i64 %i.coerce1) unnamed_addr #1 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.35", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %i, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE7crbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.35") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator.34") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIiEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator.35") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5crendEv(ptr noalias sret(%"class.eastl::reverse_iterator.35") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorIiNS_9allocatorEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorIiNS_9allocatorEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %cmp = icmp eq ptr %0, %1
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorIiNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mul = mul i64 %call, 32
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %sub = sub i64 %mul, %0
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorIiNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorIiNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mul = mul i64 %call, 32
  ret i64 %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorIiNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %0 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %s = alloca i64, align 8
  %newbits = alloca i64, align 8
  %element = alloca i32, align 4
  %words = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  store i64 %call, ptr %s, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %s, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, ptr %n.addr, align 8
  %4 = load i64, ptr %s, align 8
  %sub = sub i64 %3, %4
  store i64 %sub, ptr %newbits, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %5 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %6 = load i64, ptr %newbits, align 8
  %tobool2 = icmp ne i64 %6, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %tobool2, %land.rhs ]
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %8 = load i8, ptr %value.addr, align 1
  %tobool3 = trunc i8 %8 to i1
  call void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this1, i1 noundef zeroext %tobool3)
  %9 = load i64, ptr %newbits, align 8
  %dec = add i64 %9, -1
  store i64 %dec, ptr %newbits, align 8
  br label %while.cond, !llvm.loop !20

while.end:                                        ; preds = %land.end
  %10 = load i64, ptr %newbits, align 8
  %tobool4 = icmp ne i64 %10, 0
  br i1 %tobool4, label %if.then5, label %if.end12

if.then5:                                         ; preds = %while.end
  store i32 0, ptr %element, align 4
  %11 = load i8, ptr %value.addr, align 1
  %tobool6 = trunc i8 %11 to i1
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.then5
  %12 = load i32, ptr %element, align 4
  %not = xor i32 %12, -1
  store i32 %not, ptr %element, align 4
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.then5
  %13 = load i64, ptr %n.addr, align 8
  %add = add i64 %13, 32
  %sub9 = sub i64 %add, 1
  %div = udiv i64 %sub9, 32
  store i64 %div, ptr %words, align 8
  %14 = load i64, ptr %words, align 8
  %mul = mul i64 %14, 32
  %15 = load i64, ptr %n.addr, align 8
  %sub10 = sub i64 %mul, %15
  store i64 %sub10, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %16 = load i64, ptr %words, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEE6resizeEmRKi(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %16, ptr noundef nonnull align 4 dereferenceable(4) %element)
  %17 = load i64, ptr %extra, align 8
  %mFreeBitCount11 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 %17, ptr %mFreeBitCount11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.end8, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 32
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 32
  store i64 %div, ptr %wordCount, align 8
  %1 = load i64, ptr %wordCount, align 8
  %mul = mul i64 %1, 32
  %2 = load i64, ptr %n.addr, align 8
  %sub2 = sub i64 %mul, %2
  store i64 %sub2, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %3 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %3)
  %4 = load i64, ptr %extra, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 %4, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference.33", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.31", align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %0 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %0 to i1
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call, 1
  store i64 %4, ptr %3, align 8
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2)
  %call5 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call4)
  %5 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call5, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call5, 1
  store i64 %8, ptr %7, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIiEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE6resizeEmRKi(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 4 dereferenceable(4) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 4
  %sub = sub i64 %3, %sub.ptr.div7
  %6 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEE17DoInsertValuesEndEmRKi(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub, ptr noundef nonnull align 4 dereferenceable(4) %6)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin8, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i32, ptr %7, i64 %8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %9 = load ptr, ptr %mpEnd9, align 8
  call void @_ZN5eastl8destructIPiEEvT_S2_(ptr noundef %add.ptr, ptr noundef %9)
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %11 = load i64, ptr %n.addr, align 8
  %add.ptr11 = getelementptr inbounds i32, ptr %10, i64 %11
  %mpEnd12 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %add.ptr11, ptr %mpEnd12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 4
  %sub = sub i64 %3, %sub.ptr.div7
  call void @_ZN5eastl6vectorIiNS_9allocatorEE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin8, align 8
  %7 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i32, ptr %6, i64 %7
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %8 = load ptr, ptr %mpEnd9, align 8
  call void @_ZN5eastl8destructIPiEEvT_S2_(ptr noundef %add.ptr, ptr noundef %8)
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %9 = load ptr, ptr %mpBegin10, align 8
  %10 = load i64, ptr %n.addr, align 8
  %add.ptr11 = getelementptr inbounds i32, ptr %9, i64 %10
  %mpEnd12 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %add.ptr11, ptr %mpEnd12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 32
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 32
  store i64 %div, ptr %wordCount, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIiNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef -1)
  br label %if.end

if.else:                                          ; preds = %entry
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 32
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 32
  call void @_ZN5eastl6vectorIiNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer2, i64 noundef %div)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %cmp2 = icmp ule i64 %1, %sub.ptr.div
  br i1 %cmp2, label %if.then, label %if.else14

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load i64, ptr %n.addr, align 8
  %cmp3 = icmp eq i64 %4, 0
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  call void @_ZN5eastl6vectorIiNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %if.end13

if.else:                                          ; preds = %if.then
  %5 = load i64, ptr %n.addr, align 8
  %mpEnd5 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %6 = load ptr, ptr %mpEnd5, align 8
  %mpBegin6 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin6, align 8
  %sub.ptr.lhs.cast7 = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast8 = ptrtoint ptr %7 to i64
  %sub.ptr.sub9 = sub i64 %sub.ptr.lhs.cast7, %sub.ptr.rhs.cast8
  %sub.ptr.div10 = sdiv exact i64 %sub.ptr.sub9, 4
  %cmp11 = icmp ult i64 %5, %sub.ptr.div10
  br i1 %cmp11, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.else
  %8 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then12, %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then4
  call void @_ZN5eastl6vectorIiNS_9allocatorEE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end37

if.else14:                                        ; preds = %lor.lhs.false
  %9 = load i64, ptr %n.addr, align 8
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin15, align 8
  %mpEnd16 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd16, align 8
  %call = call noundef ptr @_ZN5eastl6vectorIiNS_9allocatorEE9DoReallocIPiEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9, ptr noundef %10, ptr noundef %11)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %12 = load ptr, ptr %mpBegin17, align 8
  %mpEnd18 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %13 = load ptr, ptr %mpEnd18, align 8
  call void @_ZN5eastl8destructIPiEEvT_S2_(ptr noundef %12, ptr noundef %13)
  %mpBegin19 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %14 = load ptr, ptr %mpBegin19, align 8
  %call20 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %15 = load ptr, ptr %call20, align 8
  %mpBegin21 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %16 = load ptr, ptr %mpBegin21, align 8
  %sub.ptr.lhs.cast22 = ptrtoint ptr %15 to i64
  %sub.ptr.rhs.cast23 = ptrtoint ptr %16 to i64
  %sub.ptr.sub24 = sub i64 %sub.ptr.lhs.cast22, %sub.ptr.rhs.cast23
  %sub.ptr.div25 = sdiv exact i64 %sub.ptr.sub24, 4
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEE6DoFreeEPim(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %14, i64 noundef %sub.ptr.div25)
  %mpEnd26 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %17 = load ptr, ptr %mpEnd26, align 8
  %mpBegin27 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin27, align 8
  %sub.ptr.lhs.cast28 = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast29 = ptrtoint ptr %18 to i64
  %sub.ptr.sub30 = sub i64 %sub.ptr.lhs.cast28, %sub.ptr.rhs.cast29
  %sub.ptr.div31 = sdiv exact i64 %sub.ptr.sub30, 4
  store i64 %sub.ptr.div31, ptr %nPrevSize, align 8
  %19 = load ptr, ptr %pNewData, align 8
  %mpBegin32 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  store ptr %19, ptr %mpBegin32, align 8
  %20 = load ptr, ptr %pNewData, align 8
  %21 = load i64, ptr %nPrevSize, align 8
  %add.ptr = getelementptr inbounds i32, ptr %20, i64 %21
  %mpEnd33 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd33, align 8
  %mpBegin34 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin34, align 8
  %23 = load i64, ptr %n.addr, align 8
  %add.ptr35 = getelementptr inbounds i32, ptr %22, i64 %23
  %call36 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr35, ptr %call36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.else14, %if.end13
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN5eastl6vectorIiNS_9allocatorEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 32, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %mFreeBitCount3, align 8
  %dec = add i64 %1, -1
  store i64 %dec, ptr %mFreeBitCount3, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZN5eastl6vectorIiNS_9allocatorEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd2, align 8
  %incdec.ptr = getelementptr inbounds i32, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpEnd2, align 8
  store i32 0, ptr %2, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 0, ptr %ref.tmp, align 4
  call void @_ZN5eastl6vectorIiNS_9allocatorEE16DoInsertValueEndIJiEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 4 dereferenceable(4) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd3, align 8
  %add.ptr = getelementptr inbounds i32, ptr %3, i64 -1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.33", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mReference, i64 16, i1 false)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIiEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %value) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %mask = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %sh_prom = trunc i64 %0 to i32
  %shl = shl i32 1, %sh_prom
  store i32 %shl, ptr %mask, align 4
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %mask, align 4
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBitWord, align 8
  %4 = load i32, ptr %3, align 4
  %or = or i32 %4, %2
  store i32 %or, ptr %3, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load i32, ptr %mask, align 4
  %not = xor i32 %5, -1
  %mpBitWord2 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBitWord2, align 8
  %7 = load i32, ptr %6, align 4
  %and = and i32 %7, %not
  store i32 %and, ptr %6, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mFreeBitCount, align 8
  %cmp = icmp eq i64 %inc, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIiNS_9allocatorEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %incdec.ptr = getelementptr inbounds i32, ptr %0, i32 -1
  store ptr %incdec.ptr, ptr %mpEnd, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.33", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN5eastl6vectorIiNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceIiEC2EPim(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZN5eastl6vectorIiNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i32, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19bitvector_referenceIiEC2EPim(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %mpBitWord, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %i.addr, align 8
  store i64 %1, ptr %mnBitIndex, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference.33", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK5eastl6vectorIiNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceIiEC2EPim(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
  %call2 = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIiEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK5eastl6vectorIiNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i32, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIiEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load i32, ptr %0, align 4
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mnBitIndex, align 8
  %sh_prom = trunc i64 %2 to i32
  %shl = shl i32 1, %sh_prom
  %and = and i32 %1, %shl
  %cmp = icmp ne i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.33", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call3)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %8
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %ref.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call2)
  ret i1 %call3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference2, i32 0, i32 0
  %1 = load ptr, ptr %mpBitWord, align 8
  %incdec.ptr = getelementptr inbounds i32, ptr %1, i32 -1
  store ptr %incdec.ptr, ptr %mpBitWord, align 8
  %mReference3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex4 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference3, i32 0, i32 1
  store i64 32, ptr %mnBitIndex4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference5, i32 0, i32 1
  %2 = load i64, ptr %mnBitIndex6, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %mnBitIndex6, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIiEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %mReference)
  ret i1 %call
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %defaultValue) #0 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %defaultValue.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %defaultValue to i8
  store i8 %frombool, ptr %defaultValue.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %cmp = icmp ult i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %ref.tmp2, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %5 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %5)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %ref.tmp, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call4, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call4, 1
  store i64 %9, ptr %8, align 8
  %call6 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i1 %call6, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i8, ptr %defaultValue.addr, align 1
  %tobool = trunc i8 %10 to i1
  store i1 %tobool, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i1, ptr %retval, align 1
  ret i1 %11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %retval, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3setEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference.33", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp4 = alloca %"class.eastl::bitvector_iterator.31", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %cmp = icmp uge i64 %0, %call
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 1
  call void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %add)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call5 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp4, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %4 = extractvalue { ptr, i64 } %call5, 0
  store ptr %4, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %6 = extractvalue { ptr, i64 } %call5, 1
  store i64 %6, ptr %5, align 8
  %7 = load i64, ptr %n.addr, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4, i64 noundef %7)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp3, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive8, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call7, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call7, 1
  store i64 %11, ptr %10, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3)
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call10, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call10, 1
  store i64 %15, ptr %14, align 8
  %call11 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIiEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.31", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.33", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.31", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.33", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.31", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIiNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIiNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIiNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIiNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6insertENS_24bitvector_const_iteratorIiEEb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.31", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %n = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp5 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp14 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp20 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp21 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp23 = alloca %"class.eastl::bitvector_reference.33", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIiEC2ERNS_19bitvector_referenceIiEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIiEmiERKNS_24bitvector_const_iteratorIiEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %n, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call7 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive8, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call7, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call7, 1
  store i64 %9, ptr %8, align 8
  %10 = load i64, ptr %n, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6, i64 noundef %10)
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp5, i32 0, i32 0
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive11, i32 0, i32 0
  %11 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 0
  %12 = extractvalue { ptr, i64 } %call10, 0
  store ptr %12, ptr %11, align 8
  %13 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 1
  %14 = extractvalue { ptr, i64 } %call10, 1
  store i64 %14, ptr %13, align 8
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp5)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call16 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp15, i32 0, i32 0
  %coerce.dive18 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive17, i32 0, i32 0
  %15 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 0
  %16 = extractvalue { ptr, i64 } %call16, 0
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 1
  %18 = extractvalue { ptr, i64 } %call16, 1
  store i64 %18, ptr %17, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp14, ptr align 8 %call19, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp21, ptr align 8 %retval, i64 16, i1 false)
  %call22 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp21)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp20, ptr align 8 %call22, i64 16, i1 false)
  %19 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %22 = load i64, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 1
  %26 = load i64, ptr %25, align 8
  %27 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 1
  %30 = load i64, ptr %29, align 8
  call void @_ZN5eastl8MoveBitsIiEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %20, i64 %22, ptr %24, i64 %26, ptr %28, i64 %30)
  %31 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %31 to i1
  %call24 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %retval)
  %32 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 0
  %33 = extractvalue { ptr, i64 } %call24, 0
  store ptr %33, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 1
  %35 = extractvalue { ptr, i64 } %call24, 1
  store i64 %35, ptr %34, align 8
  %call25 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIiEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp23, i1 noundef zeroext %tobool)
  %coerce.dive26 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %retval, i32 0, i32 0
  %coerce.dive27 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive26, i32 0, i32 0
  %36 = load { ptr, i64 }, ptr %coerce.dive27, align 8
  ret { ptr, i64 } %36
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  ret ptr %mReference
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorIiEC2ERNS_19bitvector_referenceIiEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %reference) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %reference.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorIiEC2ERKNS_19bitvector_referenceIiEE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl18bitvector_iteratorIiEmiERKNS_24bitvector_const_iteratorIiEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef i64 @_ZNK5eastl24bitvector_const_iteratorIiEmiERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %0) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %1 = load ptr, ptr %.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %1)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8MoveBitsIiEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %start.coerce0, i64 %start.coerce1, ptr %end.coerce0, i64 %end.coerce1, ptr %dest.coerce0, i64 %dest.coerce1) #0 comdat {
entry:
  %start = alloca %"class.eastl::bitvector_iterator.31", align 8
  %end = alloca %"class.eastl::bitvector_iterator.31", align 8
  %dest = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference.33", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_reference.33", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_reference.33", align 8
  %ref.tmp17 = alloca %"class.eastl::bitvector_reference.33", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %start, i32 0, i32 0
  store ptr %start.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %start, i32 0, i32 1
  store i64 %start.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %end, i32 0, i32 0
  store ptr %end.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %end, i32 0, i32 1
  store i64 %end.coerce1, ptr %3, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %dest, i32 0, i32 0
  store ptr %dest.coerce0, ptr %4, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %dest, i32 0, i32 1
  store i64 %dest.coerce1, ptr %5, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEleERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %dest, ptr noundef nonnull align 8 dereferenceable(16) %start)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %call1 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %start, ptr noundef nonnull align 8 dereferenceable(16) %end)
  br i1 %call1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call2 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %start)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call2, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call2, 1
  store i64 %9, ptr %8, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %10 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp3, i32 0, i32 0
  %11 = extractvalue { ptr, i64 } %call4, 0
  store ptr %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp3, i32 0, i32 1
  %13 = extractvalue { ptr, i64 } %call4, 1
  store i64 %13, ptr %12, align 8
  %call5 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIiEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEppEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %call7 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEppEv(ptr noundef nonnull align 8 dereferenceable(16) %start)
  br label %while.cond, !llvm.loop !21

while.end:                                        ; preds = %while.cond
  br label %if.end

if.else:                                          ; preds = %entry
  %call8 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIiEmiERKNS_24bitvector_const_iteratorIiEE(ptr noundef nonnull align 8 dereferenceable(16) %end, ptr noundef nonnull align 8 dereferenceable(16) %start)
  %call9 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %dest, i64 noundef %call8)
  br label %while.cond10

while.cond10:                                     ; preds = %while.body12, %if.else
  %call11 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %start, ptr noundef nonnull align 8 dereferenceable(16) %end)
  br i1 %call11, label %while.body12, label %while.end20

while.body12:                                     ; preds = %while.cond10
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %end)
  %call16 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %end)
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp15, i32 0, i32 0
  %15 = extractvalue { ptr, i64 } %call16, 0
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp15, i32 0, i32 1
  %17 = extractvalue { ptr, i64 } %call16, 1
  store i64 %17, ptr %16, align 8
  %call18 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %18 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp17, i32 0, i32 0
  %19 = extractvalue { ptr, i64 } %call18, 0
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp17, i32 0, i32 1
  %21 = extractvalue { ptr, i64 } %call18, 1
  store i64 %21, ptr %20, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIiEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp17, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  br label %while.cond10, !llvm.loop !22

while.end20:                                      ; preds = %while.cond10
  br label %if.end

if.end:                                           ; preds = %while.end20, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6insertENS_24bitvector_const_iteratorIiEEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %position = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %iPosition = alloca %"class.eastl::bitvector_iterator.31", align 8
  %p = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp7 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %insert_end = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp18 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp19 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp26 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp28 = alloca %"class.eastl::bitvector_reference.33", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIiEC2ERNS_19bitvector_referenceIiEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIiEmiERKNS_24bitvector_const_iteratorIiEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %p, align 8
  %call5 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %6 = load i64, ptr %n.addr, align 8
  %add = add i64 %call5, %6
  call void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %add)
  %call8 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp7, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive9, i32 0, i32 0
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 0
  %8 = extractvalue { ptr, i64 } %call8, 0
  store ptr %8, ptr %7, align 8
  %9 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 1
  %10 = extractvalue { ptr, i64 } %call8, 1
  store i64 %10, ptr %9, align 8
  %11 = load i64, ptr %p, align 8
  %call11 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp7, i64 noundef %11)
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive12, i32 0, i32 0
  %12 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call11, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call11, 1
  store i64 %15, ptr %14, align 8
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6)
  %16 = load i64, ptr %n.addr, align 8
  %call15 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEplEl(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, i64 noundef %16)
  %coerce.dive16 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %insert_end, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive16, i32 0, i32 0
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 0
  %18 = extractvalue { ptr, i64 } %call15, 0
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 1
  %20 = extractvalue { ptr, i64 } %call15, 1
  store i64 %20, ptr %19, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iPosition, i64 16, i1 false)
  %call20 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive21 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %ref.tmp19, i32 0, i32 0
  %coerce.dive22 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive21, i32 0, i32 0
  %21 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 0
  %22 = extractvalue { ptr, i64 } %call20, 0
  store ptr %22, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 1
  %24 = extractvalue { ptr, i64 } %call20, 1
  store i64 %24, ptr %23, align 8
  %25 = load i64, ptr %n.addr, align 8
  %call23 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp19, i64 noundef %25)
  %coerce.dive24 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %agg.tmp18, i32 0, i32 0
  %coerce.dive25 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive24, i32 0, i32 0
  %26 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 0
  %27 = extractvalue { ptr, i64 } %call23, 0
  store ptr %27, ptr %26, align 8
  %28 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 1
  %29 = extractvalue { ptr, i64 } %call23, 1
  store i64 %29, ptr %28, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp26, ptr align 8 %insert_end, i64 16, i1 false)
  %30 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %33 = load i64, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 0
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 1
  %37 = load i64, ptr %36, align 8
  %38 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 1
  %41 = load i64, ptr %40, align 8
  call void @_ZN5eastl8MoveBitsIiEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %31, i64 %33, ptr %35, i64 %37, ptr %39, i64 %41)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call27 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %insert_end)
  br i1 %call27, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %42 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %42 to i1
  %call29 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIiEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  %43 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 0
  %44 = extractvalue { ptr, i64 } %call29, 0
  store ptr %44, ptr %43, align 8
  %45 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 1
  %46 = extractvalue { ptr, i64 } %call29, 1
  store i64 %46, ptr %45, align 8
  %call30 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIiEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp28, i1 noundef zeroext %tobool)
  %call31 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEppEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  br label %while.cond, !llvm.loop !23

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5eraseENS_24bitvector_const_iteratorIiEE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.31", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp6 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIiEC2ERNS_19bitvector_referenceIiEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %call2, i64 16, i1 false)
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %agg.tmp3, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call4, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call4, 1
  store i64 %5, ptr %4, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp6, ptr align 8 %retval, i64 16, i1 false)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  call void @_ZN5eastl8MoveBitsIiEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %7, i64 %9, ptr %11, i64 %13, ptr %15, i64 %17)
  %call7 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %sub = sub i64 %call7, 1
  call void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %sub)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive8, i32 0, i32 0
  %18 = load { ptr, i64 }, ptr %coerce.dive9, align 8
  ret { ptr, i64 } %18
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5eraseENS_24bitvector_const_iteratorIiEES6_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %first.coerce0, i64 %first.coerce1, ptr %last.coerce0, i64 %last.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.31", align 8
  %first = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %last = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  %iLast = alloca %"class.eastl::bitvector_iterator.31", align 8
  %eraseCount = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp5 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp8 = alloca %"class.eastl::bitvector_iterator.31", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 0
  store ptr %first.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 1
  store i64 %first.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 0
  store ptr %last.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 1
  store i64 %last.coerce1, ptr %3, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  call void @_ZN5eastl18bitvector_iteratorIiEC2ERNS_19bitvector_referenceIiEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  call void @_ZN5eastl18bitvector_iteratorIiEC2ERNS_19bitvector_referenceIiEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %call2)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %iLast)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIiEmiERKNS_24bitvector_const_iteratorIiEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %retval)
  store i64 %call4, ptr %eraseCount, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iLast, i64 16, i1 false)
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %agg.tmp5, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call6, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call6, 1
  store i64 %7, ptr %6, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp8, ptr align 8 %retval, i64 16, i1 false)
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 1
  %19 = load i64, ptr %18, align 8
  call void @_ZN5eastl8MoveBitsIiEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %9, i64 %11, ptr %13, i64 %15, ptr %17, i64 %19)
  %call9 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %20 = load i64, ptr %eraseCount, align 8
  %sub = sub i64 %call9, %20
  call void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %sub)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %retval, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive10, i32 0, i32 0
  %21 = load { ptr, i64 }, ptr %coerce.dive11, align 8
  ret { ptr, i64 } %21
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %cmp = icmp eq ptr %0, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference4, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %4, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference5, i32 0, i32 1
  %5 = load i64, ptr %mnBitIndex6, align 8
  %cmp7 = icmp eq i64 %3, %5
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %6
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIiEEEE(ptr noalias sret(%"class.eastl::reverse_iterator.34") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %position) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %position.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %position, ptr %position.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  %call3 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %call)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call3, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call3, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5eraseENS_24bitvector_const_iteratorIiEE(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %5, i64 %7)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive5, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call4, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call4, 1
  store i64 %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIiEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %13, i64 %15)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.35", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %mIterator)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.35", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mIterator, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIiEEEES8_(ptr noalias sret(%"class.eastl::reverse_iterator.34") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %first.indirect_addr = alloca ptr, align 8
  %last.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.31", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.indirect_addr, align 8
  store ptr %last, ptr %last.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIiEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %agg.tmp3, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5eraseENS_24bitvector_const_iteratorIiEES6_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %9, i64 %11, ptr %13, i64 %15)
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_iterator.31", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %coerce.dive7, i32 0, i32 0
  %16 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 0
  %17 = extractvalue { ptr, i64 } %call6, 0
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 1
  %19 = extractvalue { ptr, i64 } %call6, 1
  store i64 %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIiEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %21, i64 %23)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIiNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPiEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd3, align 8
  ret void

terminate.lpad:                                   ; preds = %entry
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  call void @__clang_call_terminate(ptr %4) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIiNS_9allocatorEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr null, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorIiNS_9allocatorEE8validateEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %conv = trunc i64 %0 to i32
  %cmp = icmp uge i32 %conv, 32
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %1 = load i1, ptr %retval, align 1
  ret i1 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorIiNS_9allocatorEE8validateEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %call, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %cmp3 = icmp ult ptr %2, %3
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %4 = load i1, ptr %retval, align 1
  ret i1 %4
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef i32 @_ZNK5eastl9bitvectorINS_9allocatorEiNS_6vectorIiS1_EEE17validate_iteratorENS_24bitvector_const_iteratorIiEE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %i.coerce0, i64 %i.coerce1) #0 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator.32", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIiNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 0
  %call3 = call noundef ptr @_ZNK5eastl6vectorIiNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer2) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.26", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mFreeBitCount, align 8
  %call4 = call noundef i32 @_ZNK5eastl24bitvector_const_iteratorIiE8validateEPKiS3_m(ptr noundef nonnull align 8 dereferenceable(16) %i, ptr noundef %call, ptr noundef %call3, i64 noundef %2)
  ret i32 %call4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK5eastl24bitvector_const_iteratorIiE8validateEPKiS3_m(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %pStart, ptr noundef %pEnd, i64 noundef %nExtraBits) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %pStart.addr = alloca ptr, align 8
  %pEnd.addr = alloca ptr, align 8
  %nExtraBits.addr = alloca i64, align 8
  %pCurrent = alloca ptr, align 8
  %bit = alloca i64, align 8
  %lastbit = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %pStart, ptr %pStart.addr, align 8
  store ptr %pEnd, ptr %pEnd.addr, align 8
  store i64 %nExtraBits, ptr %nExtraBits.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  store ptr %0, ptr %pCurrent, align 8
  %1 = load ptr, ptr %pCurrent, align 8
  %2 = load ptr, ptr %pStart.addr, align 8
  %cmp = icmp uge ptr %1, %2
  br i1 %cmp, label %if.then, label %if.end27

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %nExtraBits.addr, align 8
  %cmp2 = icmp eq i64 %3, 0
  br i1 %cmp2, label %if.then3, label %if.else10

if.then3:                                         ; preds = %if.then
  %4 = load ptr, ptr %pCurrent, align 8
  %5 = load ptr, ptr %pEnd.addr, align 8
  %cmp4 = icmp eq ptr %4, %5
  br i1 %cmp4, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then3
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIiEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %mReference5)
  br i1 %call, label %if.then6, label %if.else

if.then6:                                         ; preds = %land.lhs.true
  store i32 3, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %if.then3
  %6 = load ptr, ptr %pCurrent, align 8
  %7 = load ptr, ptr %pEnd.addr, align 8
  %cmp7 = icmp ult ptr %6, %7
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else
  store i32 7, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end
  br label %if.end26

if.else10:                                        ; preds = %if.then
  %8 = load ptr, ptr %pCurrent, align 8
  %9 = load ptr, ptr %pEnd.addr, align 8
  %add.ptr = getelementptr inbounds i32, ptr %9, i64 -1
  %cmp11 = icmp eq ptr %8, %add.ptr
  br i1 %cmp11, label %if.then12, label %if.else21

if.then12:                                        ; preds = %if.else10
  %mReference13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference13, i32 0, i32 1
  %10 = load i64, ptr %mnBitIndex, align 8
  store i64 %10, ptr %bit, align 8
  %11 = load i64, ptr %nExtraBits.addr, align 8
  %sub = sub i64 32, %11
  store i64 %sub, ptr %lastbit, align 8
  %12 = load i64, ptr %bit, align 8
  %13 = load i64, ptr %lastbit, align 8
  %cmp14 = icmp eq i64 %12, %13
  br i1 %cmp14, label %if.then15, label %if.else16

if.then15:                                        ; preds = %if.then12
  store i32 3, ptr %retval, align 4
  br label %return

if.else16:                                        ; preds = %if.then12
  %14 = load i64, ptr %bit, align 8
  %15 = load i64, ptr %lastbit, align 8
  %cmp17 = icmp ult i64 %14, %15
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else16
  store i32 7, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.else16
  br label %if.end20

if.end20:                                         ; preds = %if.end19
  br label %if.end25

if.else21:                                        ; preds = %if.else10
  %16 = load ptr, ptr %pCurrent, align 8
  %17 = load ptr, ptr %pEnd.addr, align 8
  %cmp22 = icmp ult ptr %16, %17
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.else21
  store i32 7, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.else21
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end20
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end9
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then23, %if.then18, %if.then15, %if.then8, %if.then6
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC5Ev) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIlNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #1 comdat($_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC5ERKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 1 dereferenceable(1) %0) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  invoke void @_ZN5eastl10VectorBaseIlNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC5EmRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %div, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %2 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %2, 64
  %sub2 = sub i64 64, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %3 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %3, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %call = invoke noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPlmEET_S2_T0_(ptr noundef %2, i64 noundef %3)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin2, align 8
  %5 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %4, i64 %5
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %6 = landingpad { ptr, i32 }
          cleanup
  %7 = extractvalue { ptr, i32 } %6, 0
  store ptr %7, ptr %exn.slot, align 8
  %8 = extractvalue { ptr, i32 } %6, 1
  store i32 %8, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC2EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat($_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEC5EmbRKS1_) align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %allocator.addr = alloca ptr, align 8
  %ref.tmp = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  %cond = select i1 %tobool, i64 -1, i64 0
  store i64 %cond, ptr %ref.tmp, align 8
  %2 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEEC2EmRKlRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %div, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp, ptr noundef nonnull align 1 dereferenceable(1) %2)
  %3 = load i64, ptr %n.addr, align 8
  %rem = urem i64 %3, 64
  %sub2 = sub i64 64, %rem
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 %sub2, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %4 = load i64, ptr %mFreeBitCount3, align 8
  %cmp = icmp eq i64 %4, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mFreeBitCount4 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEEC2EmRKlRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %3 = load i64, ptr %n.addr, align 8
  %4 = load ptr, ptr %value.addr, align 8
  invoke void @_ZN5eastl24uninitialized_fill_n_ptrIlmEEvPT_T0_RKS1_(ptr noundef %2, i64 noundef %3, ptr noundef nonnull align 8 dereferenceable(8) %4)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin2, align 8
  %6 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %5, i64 %6
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd, align 8
  ret void

lpad:                                             ; preds = %entry
  %7 = landingpad { ptr, i32 }
          cleanup
  %8 = extractvalue { ptr, i32 } %7, 0
  store ptr %8, ptr %exn.slot, align 8
  %9 = extractvalue { ptr, i32 } %7, 1
  store i32 %9, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4swapERS4_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %0, i32 0, i32 0
  call void @_ZN5eastl6vectorIlNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 8 dereferenceable(24) %mContainer2)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %rhs.addr, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapImEEvRT_S2_(ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount, ptr noundef nonnull align 8 dereferenceable(8) %mFreeBitCount3) #9
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.41", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIlNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorIlEC2EPlm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIlNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorIlEC2EPlm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorIlEC2EPKlm(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIlNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIlEC2EPKlm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIlNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorIlEC2EPKlm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i64, ptr %i.addr, align 8
  call void @_ZN5eastl19bitvector_referenceIlEC2EPlm(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef %0, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6cbeginEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIlNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIlEC2EPKlm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0

terminate.lpad:                                   ; preds = %entry
  %1 = landingpad { ptr, i32 }
          catch ptr null
  %2 = extractvalue { ptr, i32 } %1, 0
  call void @__clang_call_terminate(ptr %2) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.41", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIlNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl18bitvector_iteratorIlEC2EPlm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %retval, i32 0, i32 0
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %retval, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive5, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive6, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIlNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.41", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIlNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIlEC2EPKlm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIlEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIlNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIlEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %retval, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4cendEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIlNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  invoke void @_ZN5eastl24bitvector_const_iteratorIlEC2EPKlm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %call3 = invoke { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIlEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i64 noundef %0)
          to label %invoke.cont2 unwind label %terminate.lpad

invoke.cont2:                                     ; preds = %invoke.cont
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %retval, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %retval, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %coerce.dive4, align 8
  ret { ptr, i64 } %5

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %6 = landingpad { ptr, i32 }
          catch ptr null
  %7 = extractvalue { ptr, i32 } %6, 0
  call void @__clang_call_terminate(ptr %7) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.44") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIlEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIlEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %i.coerce0, i64 %i.coerce1) unnamed_addr #1 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_iterator.41", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.44", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %i, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6rbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.45") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr %i.coerce0, i64 %i.coerce1) unnamed_addr #1 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.45", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %i, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE7crbeginEv(ptr noalias sret(%"class.eastl::reverse_iterator.45") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator.44") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIlEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4rendEv(ptr noalias sret(%"class.eastl::reverse_iterator.45") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5crendEv(ptr noalias sret(%"class.eastl::reverse_iterator.45") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %agg.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %5, i64 %7)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret void

terminate.lpad:                                   ; preds = %entry
  %8 = landingpad { ptr, i32 }
          catch ptr null
  %9 = extractvalue { ptr, i32 } %8, 0
  call void @__clang_call_terminate(ptr %9) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorIlNS_9allocatorEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret i1 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorIlNS_9allocatorEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %cmp = icmp eq ptr %0, %1
  ret i1 %cmp
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorIlNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mul = mul i64 %call, 64
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %sub = sub i64 %mul, %0
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorIlNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef i64 @_ZNK5eastl6vectorIlNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mul = mul i64 %call, 64
  ret i64 %mul
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl6vectorIlNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %0 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %s = alloca i64, align 8
  %newbits = alloca i64, align 8
  %element = alloca i64, align 8
  %words = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  store i64 %call, ptr %s, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %s, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, ptr %n.addr, align 8
  %4 = load i64, ptr %s, align 8
  %sub = sub i64 %3, %4
  store i64 %sub, ptr %newbits, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %5 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %6 = load i64, ptr %newbits, align 8
  %tobool2 = icmp ne i64 %6, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %tobool2, %land.rhs ]
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %8 = load i8, ptr %value.addr, align 1
  %tobool3 = trunc i8 %8 to i1
  call void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this1, i1 noundef zeroext %tobool3)
  %9 = load i64, ptr %newbits, align 8
  %dec = add i64 %9, -1
  store i64 %dec, ptr %newbits, align 8
  br label %while.cond, !llvm.loop !24

while.end:                                        ; preds = %land.end
  %10 = load i64, ptr %newbits, align 8
  %tobool4 = icmp ne i64 %10, 0
  br i1 %tobool4, label %if.then5, label %if.end12

if.then5:                                         ; preds = %while.end
  store i64 0, ptr %element, align 8
  %11 = load i8, ptr %value.addr, align 1
  %tobool6 = trunc i8 %11 to i1
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.then5
  %12 = load i64, ptr %element, align 8
  %not = xor i64 %12, -1
  store i64 %not, ptr %element, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.then5
  %13 = load i64, ptr %n.addr, align 8
  %add = add i64 %13, 64
  %sub9 = sub i64 %add, 1
  %div = udiv i64 %sub9, 64
  store i64 %div, ptr %words, align 8
  %14 = load i64, ptr %words, align 8
  %mul = mul i64 %14, 64
  %15 = load i64, ptr %n.addr, align 8
  %sub10 = sub i64 %mul, %15
  store i64 %sub10, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %16 = load i64, ptr %words, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEE6resizeEmRKl(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %16, ptr noundef nonnull align 8 dereferenceable(8) %element)
  %17 = load i64, ptr %extra, align 8
  %mFreeBitCount11 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 %17, ptr %mFreeBitCount11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.end8, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  %extra = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  store i64 %div, ptr %wordCount, align 8
  %1 = load i64, ptr %wordCount, align 8
  %mul = mul i64 %1, 64
  %2 = load i64, ptr %n.addr, align 8
  %sub2 = sub i64 %mul, %2
  store i64 %sub2, ptr %extra, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %3 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %3)
  %4 = load i64, ptr %extra, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 %4, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference.43", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.41", align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %0 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %0 to i1
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call, 1
  store i64 %4, ptr %3, align 8
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2)
  %call5 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call4)
  %5 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call5, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call5, 1
  store i64 %8, ptr %7, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIlEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE6resizeEmRKl(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 8
  %sub = sub i64 %3, %sub.ptr.div7
  %6 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEE17DoInsertValuesEndEmRKl(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub, ptr noundef nonnull align 8 dereferenceable(8) %6)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin8, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %7, i64 %8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %9 = load ptr, ptr %mpEnd9, align 8
  call void @_ZN5eastl8destructIPlEEvT_S2_(ptr noundef %add.ptr, ptr noundef %9)
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %11 = load i64, ptr %n.addr, align 8
  %add.ptr11 = getelementptr inbounds i64, ptr %10, i64 %11
  %mpEnd12 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %add.ptr11, ptr %mpEnd12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %4 = load ptr, ptr %mpEnd2, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %5 = load ptr, ptr %mpBegin3, align 8
  %sub.ptr.lhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast5 = ptrtoint ptr %5 to i64
  %sub.ptr.sub6 = sub i64 %sub.ptr.lhs.cast4, %sub.ptr.rhs.cast5
  %sub.ptr.div7 = sdiv exact i64 %sub.ptr.sub6, 8
  %sub = sub i64 %3, %sub.ptr.div7
  call void @_ZN5eastl6vectorIlNS_9allocatorEE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub)
  br label %if.end

if.else:                                          ; preds = %entry
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin8, align 8
  %7 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %6, i64 %7
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %8 = load ptr, ptr %mpEnd9, align 8
  call void @_ZN5eastl8destructIPlEEvT_S2_(ptr noundef %add.ptr, ptr noundef %8)
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %9 = load ptr, ptr %mpBegin10, align 8
  %10 = load i64, ptr %n.addr, align 8
  %add.ptr11 = getelementptr inbounds i64, ptr %9, i64 %10
  %mpEnd12 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %add.ptr11, ptr %mpEnd12, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %wordCount = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %add = add i64 %0, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  store i64 %div, ptr %wordCount, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %wordCount, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIlNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef -1)
  br label %if.end

if.else:                                          ; preds = %entry
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  call void @_ZN5eastl6vectorIlNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer2, i64 noundef %div)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp2 = icmp ule i64 %1, %sub.ptr.div
  br i1 %cmp2, label %if.then, label %if.else14

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load i64, ptr %n.addr, align 8
  %cmp3 = icmp eq i64 %4, 0
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then
  call void @_ZN5eastl6vectorIlNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %if.end13

if.else:                                          ; preds = %if.then
  %5 = load i64, ptr %n.addr, align 8
  %mpEnd5 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %6 = load ptr, ptr %mpEnd5, align 8
  %mpBegin6 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %7 = load ptr, ptr %mpBegin6, align 8
  %sub.ptr.lhs.cast7 = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast8 = ptrtoint ptr %7 to i64
  %sub.ptr.sub9 = sub i64 %sub.ptr.lhs.cast7, %sub.ptr.rhs.cast8
  %sub.ptr.div10 = sdiv exact i64 %sub.ptr.sub9, 8
  %cmp11 = icmp ult i64 %5, %sub.ptr.div10
  br i1 %cmp11, label %if.then12, label %if.end

if.then12:                                        ; preds = %if.else
  %8 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then12, %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then4
  call void @_ZN5eastl6vectorIlNS_9allocatorEE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end37

if.else14:                                        ; preds = %lor.lhs.false
  %9 = load i64, ptr %n.addr, align 8
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin15, align 8
  %mpEnd16 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd16, align 8
  %call = call noundef ptr @_ZN5eastl6vectorIlNS_9allocatorEE9DoReallocIPlEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9, ptr noundef %10, ptr noundef %11)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %12 = load ptr, ptr %mpBegin17, align 8
  %mpEnd18 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %13 = load ptr, ptr %mpEnd18, align 8
  call void @_ZN5eastl8destructIPlEEvT_S2_(ptr noundef %12, ptr noundef %13)
  %mpBegin19 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %14 = load ptr, ptr %mpBegin19, align 8
  %call20 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %15 = load ptr, ptr %call20, align 8
  %mpBegin21 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %16 = load ptr, ptr %mpBegin21, align 8
  %sub.ptr.lhs.cast22 = ptrtoint ptr %15 to i64
  %sub.ptr.rhs.cast23 = ptrtoint ptr %16 to i64
  %sub.ptr.sub24 = sub i64 %sub.ptr.lhs.cast22, %sub.ptr.rhs.cast23
  %sub.ptr.div25 = sdiv exact i64 %sub.ptr.sub24, 8
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEE6DoFreeEPlm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %14, i64 noundef %sub.ptr.div25)
  %mpEnd26 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %17 = load ptr, ptr %mpEnd26, align 8
  %mpBegin27 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin27, align 8
  %sub.ptr.lhs.cast28 = ptrtoint ptr %17 to i64
  %sub.ptr.rhs.cast29 = ptrtoint ptr %18 to i64
  %sub.ptr.sub30 = sub i64 %sub.ptr.lhs.cast28, %sub.ptr.rhs.cast29
  %sub.ptr.div31 = sdiv exact i64 %sub.ptr.sub30, 8
  store i64 %sub.ptr.div31, ptr %nPrevSize, align 8
  %19 = load ptr, ptr %pNewData, align 8
  %mpBegin32 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  store ptr %19, ptr %mpBegin32, align 8
  %20 = load ptr, ptr %pNewData, align 8
  %21 = load i64, ptr %nPrevSize, align 8
  %add.ptr = getelementptr inbounds i64, ptr %20, i64 %21
  %mpEnd33 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd33, align 8
  %mpBegin34 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin34, align 8
  %23 = load i64, ptr %n.addr, align 8
  %add.ptr35 = getelementptr inbounds i64, ptr %22, i64 %23
  %call36 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr35, ptr %call36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.else14, %if.end13
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorIlNS_9allocatorEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 64, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %mFreeBitCount3, align 8
  %dec = add i64 %1, -1
  store i64 %dec, ptr %mFreeBitCount3, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorIlNS_9allocatorEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd2, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpEnd2, align 8
  store i64 0, ptr %2, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store i64 0, ptr %ref.tmp, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEE16DoInsertValueEndIJlEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd3, align 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 -1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.43", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mReference, i64 16, i1 false)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIlEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %this, i1 noundef zeroext %value) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %mask = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %shl = shl i64 1, %0
  store i64 %shl, ptr %mask, align 8
  %1 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %mask, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBitWord, align 8
  %4 = load i64, ptr %3, align 8
  %or = or i64 %4, %2
  store i64 %or, ptr %3, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load i64, ptr %mask, align 8
  %not = xor i64 %5, -1
  %mpBitWord2 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBitWord2, align 8
  %7 = load i64, ptr %6, align 8
  %and = and i64 %7, %not
  store i64 %and, ptr %6, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mFreeBitCount, align 8
  %cmp = icmp eq i64 %inc, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIlNS_9allocatorEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount2 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE8pop_backEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %0, i32 -1
  store ptr %incdec.ptr, ptr %mpEnd, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.43", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorIlNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceIlEC2EPlm(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef %call, i64 noundef 0)
  %0 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl6vectorIlNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19bitvector_referenceIlEC2EPlm(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %p, i64 noundef %i) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %i.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %i, ptr %i.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %mpBitWord, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %this1, i32 0, i32 1
  %1 = load i64, ptr %i.addr, align 8
  store i64 %1, ptr %mnBitIndex, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference.43", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl6vectorIlNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, i64 noundef 0)
  call void @_ZN5eastl19bitvector_referenceIlEC2EPlm(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef %call, i64 noundef 0)
  %call2 = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIlEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl6vectorIlNS_9allocatorEEixEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %0, i64 %1
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIlEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load i64, ptr %0, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mnBitIndex, align 8
  %shl = shl i64 1, %2
  %and = and i64 %1, %shl
  %cmp = icmp ne i64 %and, 0
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.43", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call3)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %8
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %ref.tmp, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call2)
  ret i1 %call3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference2, i32 0, i32 0
  %1 = load ptr, ptr %mpBitWord, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %1, i32 -1
  store ptr %incdec.ptr, ptr %mpBitWord, align 8
  %mReference3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex4 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference3, i32 0, i32 1
  store i64 64, ptr %mnBitIndex4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference5, i32 0, i32 1
  %2 = load i64, ptr %mnBitIndex6, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %mnBitIndex6, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIlEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %mReference)
  ret i1 %call
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %defaultValue) #0 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %defaultValue.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %defaultValue to i8
  store i8 %frombool, ptr %defaultValue.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %cmp = icmp ult i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %ref.tmp2, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call3, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call3, 1
  store i64 %4, ptr %3, align 8
  %5 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %5)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %ref.tmp, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call4, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call4, 1
  store i64 %9, ptr %8, align 8
  %call6 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i1 %call6, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i8, ptr %defaultValue.addr, align 1
  %tobool = trunc i8 %10 to i1
  store i1 %tobool, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i1, ptr %retval, align 1
  ret i1 %11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %retval, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3setEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %ref.tmp = alloca %"class.eastl::bitvector_reference.43", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp4 = alloca %"class.eastl::bitvector_iterator.41", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %cmp = icmp uge i64 %0, %call
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 1
  call void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %add)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call5 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp4, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %4 = extractvalue { ptr, i64 } %call5, 0
  store ptr %4, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %6 = extractvalue { ptr, i64 } %call5, 1
  store i64 %6, ptr %5, align 8
  %7 = load i64, ptr %n.addr, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp4, i64 noundef %7)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp3, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive8, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call7, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call7, 1
  store i64 %11, ptr %10, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3)
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call10, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call10, 1
  store i64 %15, ptr %14, align 8
  %call11 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIlEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.41", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %this1, i64 16, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %retval, i64 noundef %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %1 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.43", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.41", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_reference.43", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_iterator.41", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp2, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive5, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call4, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call4, 1
  store i64 %8, ptr %7, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %9 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 0
  %10 = extractvalue { ptr, i64 } %call7, 0
  store ptr %10, ptr %9, align 8
  %11 = getelementptr inbounds { ptr, i64 }, ptr %retval, i32 0, i32 1
  %12 = extractvalue { ptr, i64 } %call7, 1
  store i64 %12, ptr %11, align 8
  %13 = load { ptr, i64 }, ptr %retval, align 8
  ret { ptr, i64 } %13
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %ref.tmp2 = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %ref.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %4 = load i64, ptr %n.addr, align 8
  %call3 = call { ptr, i64 } @_ZNK5eastl24bitvector_const_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp2, i64 noundef %4)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %ref.tmp, i32 0, i32 0
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 0
  %6 = extractvalue { ptr, i64 } %call3, 0
  store ptr %6, ptr %5, align 8
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive4, i32 0, i32 1
  %8 = extractvalue { ptr, i64 } %call3, 1
  store i64 %8, ptr %7, align 8
  %call5 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret i1 %call5
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZN5eastl6vectorIlNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIlNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef ptr @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIlNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl6vectorIlNS_9allocatorEE4dataEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6insertENS_24bitvector_const_iteratorIlEEb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.41", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  %value.addr = alloca i8, align 1
  %n = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp5 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp14 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp20 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp21 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp23 = alloca %"class.eastl::bitvector_reference.43", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIlEC2ERNS_19bitvector_referenceIlEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIlEmiERKNS_24bitvector_const_iteratorIlEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %n, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  %call7 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive8, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call7, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive9, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call7, 1
  store i64 %9, ptr %8, align 8
  %10 = load i64, ptr %n, align 8
  %call10 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6, i64 noundef %10)
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp5, i32 0, i32 0
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive11, i32 0, i32 0
  %11 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 0
  %12 = extractvalue { ptr, i64 } %call10, 0
  store ptr %12, ptr %11, align 8
  %13 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive12, i32 0, i32 1
  %14 = extractvalue { ptr, i64 } %call10, 1
  store i64 %14, ptr %13, align 8
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp5)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call16 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp15, i32 0, i32 0
  %coerce.dive18 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive17, i32 0, i32 0
  %15 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 0
  %16 = extractvalue { ptr, i64 } %call16, 0
  store ptr %16, ptr %15, align 8
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive18, i32 0, i32 1
  %18 = extractvalue { ptr, i64 } %call16, 1
  store i64 %18, ptr %17, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp14, ptr align 8 %call19, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp21, ptr align 8 %retval, i64 16, i1 false)
  %call22 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp21)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp20, ptr align 8 %call22, i64 16, i1 false)
  %19 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %22 = load i64, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp14, i32 0, i32 1
  %26 = load i64, ptr %25, align 8
  %27 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp20, i32 0, i32 1
  %30 = load i64, ptr %29, align 8
  call void @_ZN5eastl8MoveBitsIlEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %20, i64 %22, ptr %24, i64 %26, ptr %28, i64 %30)
  %31 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %31 to i1
  %call24 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %retval)
  %32 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 0
  %33 = extractvalue { ptr, i64 } %call24, 0
  store ptr %33, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp23, i32 0, i32 1
  %35 = extractvalue { ptr, i64 } %call24, 1
  store i64 %35, ptr %34, align 8
  %call25 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIlEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp23, i1 noundef zeroext %tobool)
  %coerce.dive26 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %retval, i32 0, i32 0
  %coerce.dive27 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive26, i32 0, i32 0
  %36 = load { ptr, i64 }, ptr %coerce.dive27, align 8
  ret { ptr, i64 } %36
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  ret ptr %mReference
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorIlEC2ERNS_19bitvector_referenceIlEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %reference) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %reference.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorIlEC2ERKNS_19bitvector_referenceIlEE(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl18bitvector_iteratorIlEmiERKNS_24bitvector_const_iteratorIlEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef i64 @_ZNK5eastl24bitvector_const_iteratorIlEmiERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %0) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %1 = load ptr, ptr %.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %1)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8MoveBitsIlEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %start.coerce0, i64 %start.coerce1, ptr %end.coerce0, i64 %end.coerce1, ptr %dest.coerce0, i64 %dest.coerce1) #0 comdat {
entry:
  %start = alloca %"class.eastl::bitvector_iterator.41", align 8
  %end = alloca %"class.eastl::bitvector_iterator.41", align 8
  %dest = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference.43", align 8
  %ref.tmp3 = alloca %"class.eastl::bitvector_reference.43", align 8
  %ref.tmp15 = alloca %"class.eastl::bitvector_reference.43", align 8
  %ref.tmp17 = alloca %"class.eastl::bitvector_reference.43", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %start, i32 0, i32 0
  store ptr %start.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %start, i32 0, i32 1
  store i64 %start.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %end, i32 0, i32 0
  store ptr %end.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %end, i32 0, i32 1
  store i64 %end.coerce1, ptr %3, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %dest, i32 0, i32 0
  store ptr %dest.coerce0, ptr %4, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %dest, i32 0, i32 1
  store i64 %dest.coerce1, ptr %5, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEleERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %dest, ptr noundef nonnull align 8 dereferenceable(16) %start)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %call1 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %start, ptr noundef nonnull align 8 dereferenceable(16) %end)
  br i1 %call1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call2 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %start)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call2, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call2, 1
  store i64 %9, ptr %8, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %10 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp3, i32 0, i32 0
  %11 = extractvalue { ptr, i64 } %call4, 0
  store ptr %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp3, i32 0, i32 1
  %13 = extractvalue { ptr, i64 } %call4, 1
  store i64 %13, ptr %12, align 8
  %call5 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIlEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp3, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  %call6 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEppEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %call7 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEppEv(ptr noundef nonnull align 8 dereferenceable(16) %start)
  br label %while.cond, !llvm.loop !25

while.end:                                        ; preds = %while.cond
  br label %if.end

if.else:                                          ; preds = %entry
  %call8 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIlEmiERKNS_24bitvector_const_iteratorIlEE(ptr noundef nonnull align 8 dereferenceable(16) %end, ptr noundef nonnull align 8 dereferenceable(16) %start)
  %call9 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %dest, i64 noundef %call8)
  br label %while.cond10

while.cond10:                                     ; preds = %while.body12, %if.else
  %call11 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %start, ptr noundef nonnull align 8 dereferenceable(16) %end)
  br i1 %call11, label %while.body12, label %while.end20

while.body12:                                     ; preds = %while.cond10
  %call13 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %end)
  %call16 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %end)
  %14 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp15, i32 0, i32 0
  %15 = extractvalue { ptr, i64 } %call16, 0
  store ptr %15, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp15, i32 0, i32 1
  %17 = extractvalue { ptr, i64 } %call16, 1
  store i64 %17, ptr %16, align 8
  %call18 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %dest)
  %18 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp17, i32 0, i32 0
  %19 = extractvalue { ptr, i64 } %call18, 0
  store ptr %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp17, i32 0, i32 1
  %21 = extractvalue { ptr, i64 } %call18, 1
  store i64 %21, ptr %20, align 8
  %call19 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIlEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp17, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp15)
  br label %while.cond10, !llvm.loop !26

while.end20:                                      ; preds = %while.cond10
  br label %if.end

if.end:                                           ; preds = %while.end20, %while.end
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6insertENS_24bitvector_const_iteratorIlEEmb(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1, i64 noundef %n, i1 noundef zeroext %value) #0 comdat align 2 {
entry:
  %position = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %iPosition = alloca %"class.eastl::bitvector_iterator.41", align 8
  %p = alloca i64, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp6 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp7 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %insert_end = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp18 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp19 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp26 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp28 = alloca %"class.eastl::bitvector_reference.43", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %frombool = zext i1 %value to i8
  store i8 %frombool, ptr %value.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIlEC2ERNS_19bitvector_referenceIlEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call2, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call2, 1
  store i64 %5, ptr %4, align 8
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIlEmiERKNS_24bitvector_const_iteratorIlEE(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  store i64 %call4, ptr %p, align 8
  %call5 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %6 = load i64, ptr %n.addr, align 8
  %add = add i64 %call5, %6
  call void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %add)
  %call8 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp7, i32 0, i32 0
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive9, i32 0, i32 0
  %7 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 0
  %8 = extractvalue { ptr, i64 } %call8, 0
  store ptr %8, ptr %7, align 8
  %9 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive10, i32 0, i32 1
  %10 = extractvalue { ptr, i64 } %call8, 1
  store i64 %10, ptr %9, align 8
  %11 = load i64, ptr %p, align 8
  %call11 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp7, i64 noundef %11)
  %coerce.dive12 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp6, i32 0, i32 0
  %coerce.dive13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive12, i32 0, i32 0
  %12 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call11, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive13, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call11, 1
  store i64 %15, ptr %14, align 8
  %call14 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp6)
  %16 = load i64, ptr %n.addr, align 8
  %call15 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEplEl(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, i64 noundef %16)
  %coerce.dive16 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %insert_end, i32 0, i32 0
  %coerce.dive17 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive16, i32 0, i32 0
  %17 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 0
  %18 = extractvalue { ptr, i64 } %call15, 0
  store ptr %18, ptr %17, align 8
  %19 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive17, i32 0, i32 1
  %20 = extractvalue { ptr, i64 } %call15, 1
  store i64 %20, ptr %19, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iPosition, i64 16, i1 false)
  %call20 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive21 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %ref.tmp19, i32 0, i32 0
  %coerce.dive22 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive21, i32 0, i32 0
  %21 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 0
  %22 = extractvalue { ptr, i64 } %call20, 0
  store ptr %22, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive22, i32 0, i32 1
  %24 = extractvalue { ptr, i64 } %call20, 1
  store i64 %24, ptr %23, align 8
  %25 = load i64, ptr %n.addr, align 8
  %call23 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEmiEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp19, i64 noundef %25)
  %coerce.dive24 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %agg.tmp18, i32 0, i32 0
  %coerce.dive25 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive24, i32 0, i32 0
  %26 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 0
  %27 = extractvalue { ptr, i64 } %call23, 0
  store ptr %27, ptr %26, align 8
  %28 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive25, i32 0, i32 1
  %29 = extractvalue { ptr, i64 } %call23, 1
  store i64 %29, ptr %28, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp26, ptr align 8 %insert_end, i64 16, i1 false)
  %30 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %33 = load i64, ptr %32, align 8
  %34 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 0
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp18, i32 0, i32 1
  %37 = load i64, ptr %36, align 8
  %38 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp26, i32 0, i32 1
  %41 = load i64, ptr %40, align 8
  call void @_ZN5eastl8MoveBitsIlEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %31, i64 %33, ptr %35, i64 %37, ptr %39, i64 %41)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call27 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %iPosition, ptr noundef nonnull align 8 dereferenceable(16) %insert_end)
  br i1 %call27, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %42 = load i8, ptr %value.addr, align 1
  %tobool = trunc i8 %42 to i1
  %call29 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorIlEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  %43 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 0
  %44 = extractvalue { ptr, i64 } %call29, 0
  store ptr %44, ptr %43, align 8
  %45 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp28, i32 0, i32 1
  %46 = extractvalue { ptr, i64 } %call29, 1
  store i64 %46, ptr %45, align 8
  %call30 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIlEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp28, i1 noundef zeroext %tobool)
  %call31 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEppEv(ptr noundef nonnull align 8 dereferenceable(16) %iPosition)
  br label %while.cond, !llvm.loop !27

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5eraseENS_24bitvector_const_iteratorIlEE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %position.coerce0, i64 %position.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.41", align 8
  %position = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp6 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 0
  store ptr %position.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %position, i32 0, i32 1
  store i64 %position.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  call void @_ZN5eastl18bitvector_iteratorIlEC2ERNS_19bitvector_referenceIlEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %ref.tmp, ptr align 8 %retval, i64 16, i1 false)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEppEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %call2, i64 16, i1 false)
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %agg.tmp3, i32 0, i32 0
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %3 = extractvalue { ptr, i64 } %call4, 0
  store ptr %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %5 = extractvalue { ptr, i64 } %call4, 1
  store i64 %5, ptr %4, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp6, ptr align 8 %retval, i64 16, i1 false)
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  call void @_ZN5eastl8MoveBitsIlEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %7, i64 %9, ptr %11, i64 %13, ptr %15, i64 %17)
  %call7 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %sub = sub i64 %call7, 1
  call void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %sub)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %retval, i32 0, i32 0
  %coerce.dive9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive8, i32 0, i32 0
  %18 = load { ptr, i64 }, ptr %coerce.dive9, align 8
  ret { ptr, i64 } %18
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5eraseENS_24bitvector_const_iteratorIlEES6_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %first.coerce0, i64 %first.coerce1, ptr %last.coerce0, i64 %last.coerce1) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator.41", align 8
  %first = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %last = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  %iLast = alloca %"class.eastl::bitvector_iterator.41", align 8
  %eraseCount = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp5 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp8 = alloca %"class.eastl::bitvector_iterator.41", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 0
  store ptr %first.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 1
  store i64 %first.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 0
  store ptr %last.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 1
  store i64 %last.coerce1, ptr %3, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  call void @_ZN5eastl18bitvector_iteratorIlEC2ERNS_19bitvector_referenceIlEE(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %call)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlE18get_reference_typeEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  call void @_ZN5eastl18bitvector_iteratorIlEC2ERNS_19bitvector_referenceIlEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %call2)
  %call3 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %retval, ptr noundef nonnull align 8 dereferenceable(16) %iLast)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call4 = call noundef i64 @_ZNK5eastl18bitvector_iteratorIlEmiERKNS_24bitvector_const_iteratorIlEE(ptr noundef nonnull align 8 dereferenceable(16) %iLast, ptr noundef nonnull align 8 dereferenceable(16) %retval)
  store i64 %call4, ptr %eraseCount, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iLast, i64 16, i1 false)
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %agg.tmp5, i32 0, i32 0
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call6, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive7, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call6, 1
  store i64 %7, ptr %6, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp8, ptr align 8 %retval, i64 16, i1 false)
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp5, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp8, i32 0, i32 1
  %19 = load i64, ptr %18, align 8
  call void @_ZN5eastl8MoveBitsIlEEvNS_18bitvector_iteratorIT_EES3_S3_(ptr %9, i64 %11, ptr %13, i64 %15, ptr %17, i64 %19)
  %call9 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %this1) #9
  %20 = load i64, ptr %eraseCount, align 8
  %sub = sub i64 %call9, %20
  call void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %this1, i64 noundef %sub)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %coerce.dive10 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %retval, i32 0, i32 0
  %coerce.dive11 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive10, i32 0, i32 0
  %21 = load { ptr, i64 }, ptr %coerce.dive11, align 8
  ret { ptr, i64 } %21
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %cmp = icmp eq ptr %0, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference4, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %4, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference5, i32 0, i32 1
  %5 = load i64, ptr %mnBitIndex6, align 8
  %cmp7 = icmp eq i64 %3, %5
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %6
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIlEEEE(ptr noalias sret(%"class.eastl::reverse_iterator.44") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %position) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %position.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %position, ptr %position.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %position)
  %call3 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %call)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call3, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call3, 1
  store i64 %3, ptr %2, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %call4 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5eraseENS_24bitvector_const_iteratorIlEE(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %5, i64 %7)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive5, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call4, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive6, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call4, 1
  store i64 %11, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIlEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %13, i64 %15)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.45", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %mIterator)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.45", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mIterator, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %retval, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorIlEEEES8_(ptr noalias sret(%"class.eastl::reverse_iterator.44") align 8 %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %result.ptr = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %first.indirect_addr = alloca ptr, align 8
  %last.indirect_addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator.41", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  store ptr %agg.result, ptr %result.ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.indirect_addr, align 8
  store ptr %last, ptr %last.indirect_addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %last)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %agg.tmp2, i32 0, i32 0
  %0 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %1 = extractvalue { ptr, i64 } %call, 0
  store ptr %1, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %3 = extractvalue { ptr, i64 } %call, 1
  store i64 %3, ptr %2, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorIlEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %agg.tmp3, i32 0, i32 0
  %4 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call4, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call4, 1
  store i64 %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %call6 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5eraseENS_24bitvector_const_iteratorIlEES6_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %9, i64 %11, ptr %13, i64 %15)
  %coerce.dive7 = getelementptr inbounds %"class.eastl::bitvector_iterator.41", ptr %agg.tmp, i32 0, i32 0
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %coerce.dive7, i32 0, i32 0
  %16 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 0
  %17 = extractvalue { ptr, i64 } %call6, 0
  store ptr %17, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 1
  %19 = extractvalue { ptr, i64 } %call6, 1
  store i64 %19, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  call void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorIlEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %agg.result, ptr %21, i64 %23)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIlNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPlEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd3, align 8
  ret void

terminate.lpad:                                   ; preds = %entry
  %3 = landingpad { ptr, i32 }
          catch ptr null
  %4 = extractvalue { ptr, i32 } %3, 0
  call void @__clang_call_terminate(ptr %4) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIlNS_9allocatorEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr null, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  ret ptr %mContainer
}

; Function Attrs: mustprogress nounwind uwtable
define weak_odr dso_local noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl6vectorIlNS_9allocatorEE8validateEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %0 = load i64, ptr %mFreeBitCount, align 8
  %conv = trunc i64 %0 to i32
  %cmp = icmp uge i32 %conv, 64
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %1 = load i1, ptr %retval, align 1
  ret i1 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl6vectorIlNS_9allocatorEE8validateEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %retval = alloca i1, align 1
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %cmp = icmp ult ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %call, align 8
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %cmp3 = icmp ult ptr %2, %3
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %4 = load i1, ptr %retval, align 1
  ret i1 %4
}

; Function Attrs: mustprogress uwtable
define weak_odr dso_local noundef i32 @_ZNK5eastl9bitvectorINS_9allocatorElNS_6vectorIlS1_EEE17validate_iteratorENS_24bitvector_const_iteratorIlEE(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %i.coerce0, i64 %i.coerce1) #0 comdat align 2 {
entry:
  %i = alloca %"class.eastl::bitvector_const_iterator.42", align 8
  %this.addr = alloca ptr, align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 0
  store ptr %i.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %i, i32 0, i32 1
  store i64 %i.coerce1, ptr %1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call = call noundef ptr @_ZNK5eastl6vectorIlNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 0
  %call3 = call noundef ptr @_ZNK5eastl6vectorIlNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %mContainer2) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector.36", ptr %this1, i32 0, i32 1
  %2 = load i64, ptr %mFreeBitCount, align 8
  %call4 = call noundef i32 @_ZNK5eastl24bitvector_const_iteratorIlE8validateEPKlS3_m(ptr noundef nonnull align 8 dereferenceable(16) %i, ptr noundef %call, ptr noundef %call3, i64 noundef %2)
  ret i32 %call4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i32 @_ZNK5eastl24bitvector_const_iteratorIlE8validateEPKlS3_m(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %pStart, ptr noundef %pEnd, i64 noundef %nExtraBits) #1 comdat align 2 {
entry:
  %retval = alloca i32, align 4
  %this.addr = alloca ptr, align 8
  %pStart.addr = alloca ptr, align 8
  %pEnd.addr = alloca ptr, align 8
  %nExtraBits.addr = alloca i64, align 8
  %pCurrent = alloca ptr, align 8
  %bit = alloca i64, align 8
  %lastbit = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %pStart, ptr %pStart.addr, align 8
  store ptr %pEnd, ptr %pEnd.addr, align 8
  store i64 %nExtraBits, ptr %nExtraBits.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  store ptr %0, ptr %pCurrent, align 8
  %1 = load ptr, ptr %pCurrent, align 8
  %2 = load ptr, ptr %pStart.addr, align 8
  %cmp = icmp uge ptr %1, %2
  br i1 %cmp, label %if.then, label %if.end27

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %nExtraBits.addr, align 8
  %cmp2 = icmp eq i64 %3, 0
  br i1 %cmp2, label %if.then3, label %if.else10

if.then3:                                         ; preds = %if.then
  %4 = load ptr, ptr %pCurrent, align 8
  %5 = load ptr, ptr %pEnd.addr, align 8
  %cmp4 = icmp eq ptr %4, %5
  br i1 %cmp4, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then3
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIlEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %mReference5)
  br i1 %call, label %if.then6, label %if.else

if.then6:                                         ; preds = %land.lhs.true
  store i32 3, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %if.then3
  %6 = load ptr, ptr %pCurrent, align 8
  %7 = load ptr, ptr %pEnd.addr, align 8
  %cmp7 = icmp ult ptr %6, %7
  br i1 %cmp7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else
  store i32 7, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end
  br label %if.end26

if.else10:                                        ; preds = %if.then
  %8 = load ptr, ptr %pCurrent, align 8
  %9 = load ptr, ptr %pEnd.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %9, i64 -1
  %cmp11 = icmp eq ptr %8, %add.ptr
  br i1 %cmp11, label %if.then12, label %if.else21

if.then12:                                        ; preds = %if.else10
  %mReference13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference13, i32 0, i32 1
  %10 = load i64, ptr %mnBitIndex, align 8
  store i64 %10, ptr %bit, align 8
  %11 = load i64, ptr %nExtraBits.addr, align 8
  %sub = sub i64 64, %11
  store i64 %sub, ptr %lastbit, align 8
  %12 = load i64, ptr %bit, align 8
  %13 = load i64, ptr %lastbit, align 8
  %cmp14 = icmp eq i64 %12, %13
  br i1 %cmp14, label %if.then15, label %if.else16

if.then15:                                        ; preds = %if.then12
  store i32 3, ptr %retval, align 4
  br label %return

if.else16:                                        ; preds = %if.then12
  %14 = load i64, ptr %bit, align 8
  %15 = load i64, ptr %lastbit, align 8
  %cmp17 = icmp ult i64 %14, %15
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.else16
  store i32 7, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.else16
  br label %if.end20

if.end20:                                         ; preds = %if.end19
  br label %if.end25

if.else21:                                        ; preds = %if.else10
  %16 = load ptr, ptr %pCurrent, align 8
  %17 = load ptr, ptr %pEnd.addr, align 8
  %cmp22 = icmp ult ptr %16, %17
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.else21
  store i32 7, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.else21
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end20
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end9
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then23, %if.then18, %if.then15, %if.then8, %if.then6
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: mustprogress uwtable
define dso_local noundef i32 @_Z13TestBitVectorv() #0 personality ptr @__gxx_personality_v0 {
entry:
  %nErrorCount = alloca i32, align 4
  %this_typeVariable = alloca %"class.eastl::bitvector", align 8
  %value_typeVariable = alloca i8, align 1
  %const_referenceVariable = alloca i8, align 1
  %iteratorVariable = alloca %"class.eastl::bitvector_iterator", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %const_iteratorVariable = alloca %"class.eastl::bitvector_const_iterator", align 8
  %reverse_iteratorVariable = alloca %"class.eastl::reverse_iterator", align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %const_reverse_iteratorVariable = alloca %"class.eastl::reverse_iterator.0", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %allocator_typeVariable = alloca %"class.eastl::allocator", align 1
  %element_typeVariable = alloca i64, align 8
  %container_typeVariable = alloca %"class.eastl::vector", align 8
  %size_typeVariable = alloca i64, align 8
  %sAddresses = alloca %"class.eastl::basic_string", align 8
  %mallocAllocator = alloca %class.MallocAllocator, align 8
  %bv0 = alloca %"class.eastl::bitvector", align 8
  %bv1 = alloca %"class.eastl::bitvector.1", align 8
  %bv2 = alloca %"class.eastl::bitvector", align 8
  %ref.tmp = alloca %"class.eastl::allocator", align 1
  %bv3 = alloca %"class.eastl::bitvector", align 8
  %ref.tmp19 = alloca %"class.eastl::allocator", align 1
  %bv4 = alloca %"class.eastl::bitvector.1", align 8
  %bv5 = alloca %"class.eastl::bitvector", align 8
  %boolArray = alloca [3 x i8], align 1
  %bv6 = alloca %"class.eastl::bitvector", align 8
  %bv7 = alloca %"class.eastl::bitvector", align 8
  %agg.tmp30 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp33 = alloca %"class.eastl::bitvector_iterator", align 8
  %i = alloca i64, align 8
  %ref.tmp61 = alloca %"class.eastl::bitvector_reference", align 8
  %i76 = alloca i64, align 8
  %ref.tmp81 = alloca %"class.eastl::bitvector_reference", align 8
  %i100 = alloca i64, align 8
  %ref.tmp105 = alloca %"class.eastl::bitvector_reference", align 8
  %i124 = alloca i64, align 8
  %i145 = alloca i64, align 8
  %ref.tmp150 = alloca %"class.eastl::bitvector_reference", align 8
  %j = alloca i64, align 8
  %ref.tmp175 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp181 = alloca %"class.eastl::bitvector_reference", align 8
  %i197 = alloca i64, align 8
  %ref.tmp204 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp210 = alloca %"class.eastl::bitvector_reference", align 8
  %i235 = alloca i64, align 8
  %ref.tmp244 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp250 = alloca %"class.eastl::bitvector_reference", align 8
  %i270 = alloca i64, align 8
  %ref.tmp275 = alloca %"class.eastl::bitvector_reference", align 8
  %i294 = alloca i64, align 8
  %ref.tmp299 = alloca %"class.eastl::bitvector_reference", align 8
  %agg.tmp320 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp324 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp337 = alloca %"class.eastl::bitvector", align 8
  %ref.tmp349 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp353 = alloca %"class.eastl::bitvector_iterator", align 8
  %kTestSize = alloca i64, align 8
  %kTestIncrement = alloca i64, align 8
  %bv1374 = alloca %"class.eastl::bitvector", align 8
  %ref.tmp375 = alloca %"class.eastl::allocator", align 1
  %bv2376 = alloca %"class.eastl::bitvector", align 8
  %ref.tmp377 = alloca %"class.eastl::allocator", align 1
  %i381 = alloca i64, align 8
  %ref.tmp385 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp391 = alloca %"class.eastl::bitvector_reference", align 8
  %bv3398 = alloca %"class.eastl::bitvector", align 8
  %bv4399 = alloca %"class.eastl::bitvector", align 8
  %ref.tmp400 = alloca %"class.eastl::allocator", align 1
  %i407 = alloca i64, align 8
  %ref.tmp411 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp422 = alloca %"class.eastl::bitvector_reference", align 8
  %boolArray441 = alloca [6 x i8], align 1
  %bv0442 = alloca %"class.eastl::bitvector", align 8
  %it = alloca %"class.eastl::bitvector_const_iterator", align 8
  %i448 = alloca i64, align 8
  %ref.tmp449 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp455 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %value = alloca i8, align 1
  %value481 = alloca i8, align 1
  %ref.tmp498 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp505 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %value511 = alloca i8, align 1
  %value533 = alloca i8, align 1
  %rit = alloca %"class.eastl::reverse_iterator.0", align 8
  %ref.tmp553 = alloca %"class.eastl::reverse_iterator.0", align 8
  %ref.tmp557 = alloca %"class.eastl::reverse_iterator.0", align 8
  %value561 = alloca i8, align 1
  %ref.tmp562 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %value591 = alloca i8, align 1
  %ref.tmp592 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp614 = alloca %"class.eastl::reverse_iterator.0", align 8
  %ref.tmp619 = alloca %"class.eastl::reverse_iterator.0", align 8
  %value623 = alloca i8, align 1
  %ref.tmp624 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %value653 = alloca i8, align 1
  %ref.tmp654 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %mallocAllocator677 = alloca %class.MallocAllocator, align 8
  %bv0678 = alloca %"class.eastl::bitvector.1", align 8
  %boolArray691 = alloca [3 x i8], align 1
  %ref.tmp711 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp720 = alloca %"class.eastl::bitvector_reference", align 8
  %agg.tmp729 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp730 = alloca %"class.eastl::bitvector_iterator", align 8
  %coerce = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp738 = alloca %"class.eastl::bitvector_reference", align 8
  %agg.tmp747 = alloca %"class.eastl::reverse_iterator.0", align 8
  %ref.tmp748 = alloca %"class.eastl::reverse_iterator", align 8
  %tmp = alloca %"class.eastl::reverse_iterator", align 8
  %ref.tmp751 = alloca %"class.eastl::bitvector_reference", align 8
  %allocCountBefore = alloca i32, align 4
  %ref.tmp799 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp806 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp817 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp828 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp839 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp850 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp861 = alloca %"class.eastl::bitvector_reference", align 8
  %it913 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp915 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp921 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp928 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp935 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %agg.tmp945 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %agg.tmp952 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp953 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp954 = alloca %"class.eastl::bitvector_iterator", align 8
  %coerce964 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp967 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp976 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp981 = alloca %"class.eastl::bitvector_reference", align 8
  %agg.tmp990 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp991 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp992 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp1001 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp1009 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp1019 = alloca %"class.eastl::bitvector_reference", align 8
  %agg.tmp1028 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp1029 = alloca %"class.eastl::bitvector_iterator", align 8
  %coerce1035 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp1038 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp1047 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp1055 = alloca %"class.eastl::bitvector_reference", align 8
  %agg.tmp1065 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp1066 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp1067 = alloca %"class.eastl::bitvector_iterator", align 8
  %coerce1077 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp1080 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp1088 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp1098 = alloca %"class.eastl::bitvector_reference", align 8
  %bv06 = alloca i8, align 1
  %ref.tmp1107 = alloca %"class.eastl::bitvector_reference", align 8
  %agg.tmp1113 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp1114 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp1115 = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp1123 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp1124 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp1125 = alloca %"class.eastl::bitvector_iterator", align 8
  %coerce1135 = alloca %"class.eastl::bitvector_iterator", align 8
  %ref.tmp1138 = alloca %"class.eastl::bitvector_reference", align 8
  %ref.tmp1150 = alloca %"class.eastl::bitvector_reference", align 8
  %agg.tmp1155 = alloca %"class.eastl::reverse_iterator.0", align 8
  %ref.tmp1156 = alloca %"class.eastl::reverse_iterator", align 8
  %tmp1158 = alloca %"class.eastl::reverse_iterator", align 8
  %ref.tmp1163 = alloca %"class.eastl::bitvector_reference", align 8
  %agg.tmp1173 = alloca %"class.eastl::reverse_iterator.0", align 8
  %ref.tmp1174 = alloca %"class.eastl::reverse_iterator", align 8
  %agg.tmp1176 = alloca %"class.eastl::reverse_iterator.0", align 8
  %ref.tmp1177 = alloca %"class.eastl::reverse_iterator", align 8
  %tmp1179 = alloca %"class.eastl::reverse_iterator", align 8
  %pSaved = alloca ptr, align 8
  store i32 0, ptr %nErrorCount, align 4
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1Ev(ptr noundef nonnull align 8 dereferenceable(32) %this_typeVariable)
  store i8 0, ptr %value_typeVariable, align 1
  store i8 0, ptr %const_referenceVariable, align 1
  invoke void @_ZN5eastl18bitvector_iteratorImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %iteratorVariable, ptr noundef null, i64 noundef 0)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  invoke void @_ZN5eastl24bitvector_const_iteratorImEC2EPKmm(ptr noundef nonnull align 8 dereferenceable(16) %const_iteratorVariable, ptr noundef null, i64 noundef 0)
          to label %invoke.cont1 unwind label %lpad

invoke.cont1:                                     ; preds = %invoke.cont
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %iteratorVariable, i64 16, i1 false)
  %0 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %0, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %3 = load i64, ptr %2, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_18bitvector_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %reverse_iteratorVariable, ptr %1, i64 %3)
          to label %invoke.cont2 unwind label %lpad

invoke.cont2:                                     ; preds = %invoke.cont1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %const_iteratorVariable, i64 16, i1 false)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2ES2_(ptr noundef nonnull align 8 dereferenceable(16) %const_reverse_iteratorVariable, ptr %5, i64 %7)
          to label %invoke.cont4 unwind label %lpad

invoke.cont4:                                     ; preds = %invoke.cont2
  invoke void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %allocator_typeVariable, ptr noundef null)
          to label %invoke.cont5 unwind label %lpad

invoke.cont5:                                     ; preds = %invoke.cont4
  store i64 0, ptr %element_typeVariable, align 8
  invoke void @_ZN5eastl6vectorImNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %container_typeVariable)
          to label %invoke.cont6 unwind label %lpad

invoke.cont6:                                     ; preds = %invoke.cont5
  store i64 0, ptr %size_typeVariable, align 8
  invoke void (ptr, ptr, ...) @_ZN5eastl12basic_stringIcNS_9allocatorEEC2ENS2_11CtorSprintfEPKcz(ptr noundef nonnull align 8 dereferenceable(24) %sAddresses, ptr noundef @.str, ptr noundef %this_typeVariable, ptr noundef %value_typeVariable, ptr noundef %const_referenceVariable, ptr noundef %iteratorVariable, ptr noundef %const_iteratorVariable, ptr noundef %reverse_iteratorVariable, ptr noundef %const_reverse_iteratorVariable, ptr noundef %allocator_typeVariable, ptr noundef %element_typeVariable, ptr noundef %container_typeVariable, ptr noundef %size_typeVariable)
          to label %invoke.cont9 unwind label %lpad8

invoke.cont9:                                     ; preds = %invoke.cont6
  %call = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %sAddresses) #9
  %cmp = icmp ugt i64 %call, 0
  %call12 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 67, ptr noundef @.str.2)
          to label %invoke.cont11 unwind label %lpad10

invoke.cont11:                                    ; preds = %invoke.cont9
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %sAddresses) #9
  call void @_ZN5eastl6vectorImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %container_typeVariable) #9
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this_typeVariable) #9
  call void @_ZN15MallocAllocatorC2EPKc(ptr noundef nonnull align 8 dereferenceable(16) %mallocAllocator, ptr noundef null)
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv0)
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(48) %bv1, ptr noundef nonnull align 8 dereferenceable(16) %mallocAllocator)
          to label %invoke.cont15 unwind label %lpad14

invoke.cont15:                                    ; preds = %invoke.cont11
  invoke void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp, ptr noundef @.str.3)
          to label %invoke.cont17 unwind label %lpad16

invoke.cont17:                                    ; preds = %invoke.cont15
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1EmRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %bv2, i64 noundef 200, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp)
          to label %invoke.cont18 unwind label %lpad16

invoke.cont18:                                    ; preds = %invoke.cont17
  invoke void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp19, ptr noundef @.str.3)
          to label %invoke.cont21 unwind label %lpad20

invoke.cont21:                                    ; preds = %invoke.cont18
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %bv3, i64 noundef 300, i1 noundef zeroext true, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp19)
          to label %invoke.cont22 unwind label %lpad20

invoke.cont22:                                    ; preds = %invoke.cont21
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC1EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(48) %bv4, i64 noundef 400, i1 noundef zeroext false, ptr noundef nonnull align 8 dereferenceable(16) %mallocAllocator)
          to label %invoke.cont24 unwind label %lpad23

invoke.cont24:                                    ; preds = %invoke.cont22
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2ERKS4_(ptr noundef nonnull align 8 dereferenceable(32) %bv5, ptr noundef nonnull align 8 dereferenceable(32) %bv2)
          to label %invoke.cont26 unwind label %lpad25

invoke.cont26:                                    ; preds = %invoke.cont24
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %boolArray, ptr align 1 @__const._Z13TestBitVectorv.boolArray, i64 3, i1 false)
  %arraydecay = getelementptr inbounds [3 x i8], ptr %boolArray, i64 0, i64 0
  %arraydecay27 = getelementptr inbounds [3 x i8], ptr %boolArray, i64 0, i64 0
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay27, i64 3
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2IPbEET_S7_(ptr noundef nonnull align 8 dereferenceable(32) %bv6, ptr noundef %arraydecay, ptr noundef %add.ptr)
          to label %invoke.cont29 unwind label %lpad28

invoke.cont29:                                    ; preds = %invoke.cont26
  %call31 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp30, i32 0, i32 0
  %coerce.dive32 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive32, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call31, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive32, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call31, 1
  store i64 %11, ptr %10, align 8
  %call34 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %coerce.dive35 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp33, i32 0, i32 0
  %coerce.dive36 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive35, i32 0, i32 0
  %12 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive36, i32 0, i32 0
  %13 = extractvalue { ptr, i64 } %call34, 0
  store ptr %13, ptr %12, align 8
  %14 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive36, i32 0, i32 1
  %15 = extractvalue { ptr, i64 } %call34, 1
  store i64 %15, ptr %14, align 8
  %16 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp30, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp30, i32 0, i32 1
  %19 = load i64, ptr %18, align 8
  %20 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp33, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp33, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2INS_18bitvector_iteratorImEEEET_S8_(ptr noundef nonnull align 8 dereferenceable(32) %bv7, ptr %17, i64 %19, ptr %21, i64 %23)
          to label %invoke.cont38 unwind label %lpad37

invoke.cont38:                                    ; preds = %invoke.cont29
  %call39 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0)
  %call42 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call39, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 93, ptr noundef @.str.4)
          to label %invoke.cont41 unwind label %lpad40

invoke.cont41:                                    ; preds = %invoke.cont38
  %call43 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0) #9
  %call45 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call43, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 94, ptr noundef @.str.5)
          to label %invoke.cont44 unwind label %lpad40

invoke.cont44:                                    ; preds = %invoke.cont41
  %call46 = call noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(48) %bv1)
  %call48 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call46, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 96, ptr noundef @.str.6)
          to label %invoke.cont47 unwind label %lpad40

invoke.cont47:                                    ; preds = %invoke.cont44
  %call49 = call noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(48) %bv1) #9
  %call51 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call49, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 97, ptr noundef @.str.7)
          to label %invoke.cont50 unwind label %lpad40

invoke.cont50:                                    ; preds = %invoke.cont47
  %call52 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %bv2)
  %call54 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call52, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 99, ptr noundef @.str.8)
          to label %invoke.cont53 unwind label %lpad40

invoke.cont53:                                    ; preds = %invoke.cont50
  %call55 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv2) #9
  %cmp56 = icmp eq i64 %call55, 200
  %call58 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp56, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 100, ptr noundef @.str.9)
          to label %invoke.cont57 unwind label %lpad40

invoke.cont57:                                    ; preds = %invoke.cont53
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %invoke.cont57
  %24 = load i64, ptr %i, align 8
  %call59 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv2) #9
  %cmp60 = icmp ult i64 %24, %call59
  br i1 %cmp60, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %25 = load i64, ptr %i, align 8
  %call63 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv2, i64 noundef %25)
          to label %invoke.cont62 unwind label %lpad40

invoke.cont62:                                    ; preds = %for.body
  %26 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp61, i32 0, i32 0
  %27 = extractvalue { ptr, i64 } %call63, 0
  store ptr %27, ptr %26, align 8
  %28 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp61, i32 0, i32 1
  %29 = extractvalue { ptr, i64 } %call63, 1
  store i64 %29, ptr %28, align 8
  %call65 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp61)
          to label %invoke.cont64 unwind label %lpad40

invoke.cont64:                                    ; preds = %invoke.cont62
  %conv = zext i1 %call65 to i32
  %cmp66 = icmp eq i32 %conv, 0
  %call68 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp66, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 102, ptr noundef @.str.10)
          to label %invoke.cont67 unwind label %lpad40

invoke.cont67:                                    ; preds = %invoke.cont64
  br label %for.inc

for.inc:                                          ; preds = %invoke.cont67
  %30 = load i64, ptr %i, align 8
  %inc = add i64 %30, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !28

lpad:                                             ; preds = %invoke.cont5, %invoke.cont4, %invoke.cont2, %invoke.cont1, %invoke.cont, %entry
  %31 = landingpad { ptr, i32 }
          cleanup
  %32 = extractvalue { ptr, i32 } %31, 0
  store ptr %32, ptr %exn.slot, align 8
  %33 = extractvalue { ptr, i32 } %31, 1
  store i32 %33, ptr %ehselector.slot, align 4
  br label %ehcleanup13

lpad8:                                            ; preds = %invoke.cont6
  %34 = landingpad { ptr, i32 }
          cleanup
  %35 = extractvalue { ptr, i32 } %34, 0
  store ptr %35, ptr %exn.slot, align 8
  %36 = extractvalue { ptr, i32 } %34, 1
  store i32 %36, ptr %ehselector.slot, align 4
  br label %ehcleanup

lpad10:                                           ; preds = %invoke.cont9
  %37 = landingpad { ptr, i32 }
          cleanup
  %38 = extractvalue { ptr, i32 } %37, 0
  store ptr %38, ptr %exn.slot, align 8
  %39 = extractvalue { ptr, i32 } %37, 1
  store i32 %39, ptr %ehselector.slot, align 4
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %sAddresses) #9
  br label %ehcleanup

ehcleanup:                                        ; preds = %lpad10, %lpad8
  call void @_ZN5eastl6vectorImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %container_typeVariable) #9
  br label %ehcleanup13

ehcleanup13:                                      ; preds = %ehcleanup, %lpad
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this_typeVariable) #9
  br label %eh.resume

lpad14:                                           ; preds = %invoke.cont11
  %40 = landingpad { ptr, i32 }
          cleanup
  %41 = extractvalue { ptr, i32 } %40, 0
  store ptr %41, ptr %exn.slot, align 8
  %42 = extractvalue { ptr, i32 } %40, 1
  store i32 %42, ptr %ehselector.slot, align 4
  br label %ehcleanup373

lpad16:                                           ; preds = %invoke.cont17, %invoke.cont15
  %43 = landingpad { ptr, i32 }
          cleanup
  %44 = extractvalue { ptr, i32 } %43, 0
  store ptr %44, ptr %exn.slot, align 8
  %45 = extractvalue { ptr, i32 } %43, 1
  store i32 %45, ptr %ehselector.slot, align 4
  br label %ehcleanup372

lpad20:                                           ; preds = %invoke.cont21, %invoke.cont18
  %46 = landingpad { ptr, i32 }
          cleanup
  %47 = extractvalue { ptr, i32 } %46, 0
  store ptr %47, ptr %exn.slot, align 8
  %48 = extractvalue { ptr, i32 } %46, 1
  store i32 %48, ptr %ehselector.slot, align 4
  br label %ehcleanup371

lpad23:                                           ; preds = %invoke.cont22
  %49 = landingpad { ptr, i32 }
          cleanup
  %50 = extractvalue { ptr, i32 } %49, 0
  store ptr %50, ptr %exn.slot, align 8
  %51 = extractvalue { ptr, i32 } %49, 1
  store i32 %51, ptr %ehselector.slot, align 4
  br label %ehcleanup370

lpad25:                                           ; preds = %invoke.cont24
  %52 = landingpad { ptr, i32 }
          cleanup
  %53 = extractvalue { ptr, i32 } %52, 0
  store ptr %53, ptr %exn.slot, align 8
  %54 = extractvalue { ptr, i32 } %52, 1
  store i32 %54, ptr %ehselector.slot, align 4
  br label %ehcleanup369

lpad28:                                           ; preds = %invoke.cont26
  %55 = landingpad { ptr, i32 }
          cleanup
  %56 = extractvalue { ptr, i32 } %55, 0
  store ptr %56, ptr %exn.slot, align 8
  %57 = extractvalue { ptr, i32 } %55, 1
  store i32 %57, ptr %ehselector.slot, align 4
  br label %ehcleanup368

lpad37:                                           ; preds = %invoke.cont29
  %58 = landingpad { ptr, i32 }
          cleanup
  %59 = extractvalue { ptr, i32 } %58, 0
  store ptr %59, ptr %exn.slot, align 8
  %60 = extractvalue { ptr, i32 } %58, 1
  store i32 %60, ptr %ehselector.slot, align 4
  br label %ehcleanup367

lpad40:                                           ; preds = %invoke.cont362, %invoke.cont361, %invoke.cont359, %invoke.cont357, %invoke.cont348, %invoke.cont345, %invoke.cont336, %invoke.cont331, %invoke.cont329, %invoke.cont328, %invoke.cont318, %invoke.cont316, %invoke.cont314, %invoke.cont311, %for.end310, %invoke.cont302, %invoke.cont300, %for.body298, %invoke.cont288, %for.end286, %invoke.cont278, %invoke.cont276, %for.body274, %invoke.cont264, %invoke.cont262, %for.end261, %invoke.cont253, %invoke.cont251, %invoke.cont247, %invoke.cont245, %for.body243, %invoke.cont228, %invoke.cont226, %invoke.cont224, %invoke.cont222, %for.end221, %invoke.cont213, %invoke.cont211, %invoke.cont207, %invoke.cont205, %for.body203, %invoke.cont193, %for.end192, %invoke.cont184, %invoke.cont182, %invoke.cont178, %invoke.cont176, %for.body174, %invoke.cont164, %for.end162, %invoke.cont153, %invoke.cont151, %for.body149, %invoke.cont139, %for.end137, %invoke.cont129, %for.body128, %invoke.cont120, %invoke.cont118, %for.end116, %invoke.cont108, %invoke.cont106, %for.body104, %invoke.cont94, %for.end92, %invoke.cont84, %invoke.cont82, %for.body80, %invoke.cont70, %for.end, %invoke.cont64, %invoke.cont62, %for.body, %invoke.cont53, %invoke.cont50, %invoke.cont47, %invoke.cont44, %invoke.cont41, %invoke.cont38
  %61 = landingpad { ptr, i32 }
          cleanup
  %62 = extractvalue { ptr, i32 } %61, 0
  store ptr %62, ptr %exn.slot, align 8
  %63 = extractvalue { ptr, i32 } %61, 1
  store i32 %63, ptr %ehselector.slot, align 4
  br label %ehcleanup366

for.end:                                          ; preds = %for.cond
  %call69 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3)
  %call71 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call69, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 104, ptr noundef @.str.11)
          to label %invoke.cont70 unwind label %lpad40

invoke.cont70:                                    ; preds = %for.end
  %call72 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %cmp73 = icmp eq i64 %call72, 300
  %call75 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp73, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 105, ptr noundef @.str.12)
          to label %invoke.cont74 unwind label %lpad40

invoke.cont74:                                    ; preds = %invoke.cont70
  store i64 0, ptr %i76, align 8
  br label %for.cond77

for.cond77:                                       ; preds = %for.inc90, %invoke.cont74
  %64 = load i64, ptr %i76, align 8
  %call78 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %cmp79 = icmp ult i64 %64, %call78
  br i1 %cmp79, label %for.body80, label %for.end92

for.body80:                                       ; preds = %for.cond77
  %65 = load i64, ptr %i76, align 8
  %call83 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv3, i64 noundef %65)
          to label %invoke.cont82 unwind label %lpad40

invoke.cont82:                                    ; preds = %for.body80
  %66 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp81, i32 0, i32 0
  %67 = extractvalue { ptr, i64 } %call83, 0
  store ptr %67, ptr %66, align 8
  %68 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp81, i32 0, i32 1
  %69 = extractvalue { ptr, i64 } %call83, 1
  store i64 %69, ptr %68, align 8
  %call85 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp81)
          to label %invoke.cont84 unwind label %lpad40

invoke.cont84:                                    ; preds = %invoke.cont82
  %conv86 = zext i1 %call85 to i32
  %cmp87 = icmp eq i32 %conv86, 1
  %call89 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp87, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 107, ptr noundef @.str.13)
          to label %invoke.cont88 unwind label %lpad40

invoke.cont88:                                    ; preds = %invoke.cont84
  br label %for.inc90

for.inc90:                                        ; preds = %invoke.cont88
  %70 = load i64, ptr %i76, align 8
  %inc91 = add i64 %70, 1
  store i64 %inc91, ptr %i76, align 8
  br label %for.cond77, !llvm.loop !29

for.end92:                                        ; preds = %for.cond77
  %call93 = call noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(48) %bv4)
  %call95 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call93, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 109, ptr noundef @.str.14)
          to label %invoke.cont94 unwind label %lpad40

invoke.cont94:                                    ; preds = %for.end92
  %call96 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv4) #9
  %cmp97 = icmp eq i64 %call96, 400
  %call99 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp97, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 110, ptr noundef @.str.15)
          to label %invoke.cont98 unwind label %lpad40

invoke.cont98:                                    ; preds = %invoke.cont94
  store i64 0, ptr %i100, align 8
  br label %for.cond101

for.cond101:                                      ; preds = %for.inc114, %invoke.cont98
  %71 = load i64, ptr %i100, align 8
  %call102 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv4) #9
  %cmp103 = icmp ult i64 %71, %call102
  br i1 %cmp103, label %for.body104, label %for.end116

for.body104:                                      ; preds = %for.cond101
  %72 = load i64, ptr %i100, align 8
  %call107 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv4, i64 noundef %72)
          to label %invoke.cont106 unwind label %lpad40

invoke.cont106:                                   ; preds = %for.body104
  %73 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp105, i32 0, i32 0
  %74 = extractvalue { ptr, i64 } %call107, 0
  store ptr %74, ptr %73, align 8
  %75 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp105, i32 0, i32 1
  %76 = extractvalue { ptr, i64 } %call107, 1
  store i64 %76, ptr %75, align 8
  %call109 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp105)
          to label %invoke.cont108 unwind label %lpad40

invoke.cont108:                                   ; preds = %invoke.cont106
  %conv110 = zext i1 %call109 to i32
  %cmp111 = icmp eq i32 %conv110, 0
  %call113 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp111, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 112, ptr noundef @.str.16)
          to label %invoke.cont112 unwind label %lpad40

invoke.cont112:                                   ; preds = %invoke.cont108
  br label %for.inc114

for.inc114:                                       ; preds = %invoke.cont112
  %77 = load i64, ptr %i100, align 8
  %inc115 = add i64 %77, 1
  store i64 %inc115, ptr %i100, align 8
  br label %for.cond101, !llvm.loop !30

for.end116:                                       ; preds = %for.cond101
  %call117 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %bv5)
  %call119 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call117, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 114, ptr noundef @.str.17)
          to label %invoke.cont118 unwind label %lpad40

invoke.cont118:                                   ; preds = %for.end116
  %call121 = invoke noundef zeroext i1 @_ZN5eastleqINS_9allocatorEmNS_6vectorImS1_EEEEbRKNS_9bitvectorIT_T0_T1_EESA_(ptr noundef nonnull align 8 dereferenceable(32) %bv5, ptr noundef nonnull align 8 dereferenceable(32) %bv2)
          to label %invoke.cont120 unwind label %lpad40

invoke.cont120:                                   ; preds = %invoke.cont118
  %call123 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call121, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 115, ptr noundef @.str.18)
          to label %invoke.cont122 unwind label %lpad40

invoke.cont122:                                   ; preds = %invoke.cont120
  store i64 0, ptr %i124, align 8
  br label %for.cond125

for.cond125:                                      ; preds = %for.inc135, %invoke.cont122
  %78 = load i64, ptr %i124, align 8
  %call126 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv5) #9
  %cmp127 = icmp ult i64 %78, %call126
  br i1 %cmp127, label %for.body128, label %for.end137

for.body128:                                      ; preds = %for.cond125
  %79 = load i64, ptr %i124, align 8
  %call130 = invoke noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv5, i64 noundef %79)
          to label %invoke.cont129 unwind label %lpad40

invoke.cont129:                                   ; preds = %for.body128
  %conv131 = zext i1 %call130 to i32
  %cmp132 = icmp eq i32 %conv131, 0
  %call134 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp132, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 117, ptr noundef @.str.19)
          to label %invoke.cont133 unwind label %lpad40

invoke.cont133:                                   ; preds = %invoke.cont129
  br label %for.inc135

for.inc135:                                       ; preds = %invoke.cont133
  %80 = load i64, ptr %i124, align 8
  %inc136 = add i64 %80, 1
  store i64 %inc136, ptr %i124, align 8
  br label %for.cond125, !llvm.loop !31

for.end137:                                       ; preds = %for.cond125
  %call138 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %bv6)
  %call140 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call138, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 119, ptr noundef @.str.20)
          to label %invoke.cont139 unwind label %lpad40

invoke.cont139:                                   ; preds = %for.end137
  %call141 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv6) #9
  %cmp142 = icmp eq i64 %call141, 3
  %call144 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp142, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 120, ptr noundef @.str.21)
          to label %invoke.cont143 unwind label %lpad40

invoke.cont143:                                   ; preds = %invoke.cont139
  store i64 0, ptr %i145, align 8
  br label %for.cond146

for.cond146:                                      ; preds = %for.inc160, %invoke.cont143
  %81 = load i64, ptr %i145, align 8
  %call147 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv6) #9
  %cmp148 = icmp ult i64 %81, %call147
  br i1 %cmp148, label %for.body149, label %for.end162

for.body149:                                      ; preds = %for.cond146
  %82 = load i64, ptr %i145, align 8
  %call152 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv6, i64 noundef %82)
          to label %invoke.cont151 unwind label %lpad40

invoke.cont151:                                   ; preds = %for.body149
  %83 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp150, i32 0, i32 0
  %84 = extractvalue { ptr, i64 } %call152, 0
  store ptr %84, ptr %83, align 8
  %85 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp150, i32 0, i32 1
  %86 = extractvalue { ptr, i64 } %call152, 1
  store i64 %86, ptr %85, align 8
  %call154 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp150)
          to label %invoke.cont153 unwind label %lpad40

invoke.cont153:                                   ; preds = %invoke.cont151
  %conv155 = zext i1 %call154 to i32
  %87 = load i64, ptr %i145, align 8
  %arrayidx = getelementptr inbounds [3 x i8], ptr %boolArray, i64 0, i64 %87
  %88 = load i8, ptr %arrayidx, align 1
  %tobool = trunc i8 %88 to i1
  %conv156 = zext i1 %tobool to i32
  %cmp157 = icmp eq i32 %conv155, %conv156
  %call159 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp157, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 122, ptr noundef @.str.22)
          to label %invoke.cont158 unwind label %lpad40

invoke.cont158:                                   ; preds = %invoke.cont153
  br label %for.inc160

for.inc160:                                       ; preds = %invoke.cont158
  %89 = load i64, ptr %i145, align 8
  %inc161 = add i64 %89, 1
  store i64 %inc161, ptr %i145, align 8
  br label %for.cond146, !llvm.loop !32

for.end162:                                       ; preds = %for.cond146
  %call163 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %bv7)
  %call165 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call163, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 124, ptr noundef @.str.23)
          to label %invoke.cont164 unwind label %lpad40

invoke.cont164:                                   ; preds = %for.end162
  %call166 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv7) #9
  %call167 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %cmp168 = icmp eq i64 %call166, %call167
  %call170 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp168, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 125, ptr noundef @.str.24)
          to label %invoke.cont169 unwind label %lpad40

invoke.cont169:                                   ; preds = %invoke.cont164
  store i64 0, ptr %j, align 8
  br label %for.cond171

for.cond171:                                      ; preds = %for.inc190, %invoke.cont169
  %90 = load i64, ptr %j, align 8
  %call172 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv7) #9
  %cmp173 = icmp ult i64 %90, %call172
  br i1 %cmp173, label %for.body174, label %for.end192

for.body174:                                      ; preds = %for.cond171
  %91 = load i64, ptr %j, align 8
  %call177 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv7, i64 noundef %91)
          to label %invoke.cont176 unwind label %lpad40

invoke.cont176:                                   ; preds = %for.body174
  %92 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp175, i32 0, i32 0
  %93 = extractvalue { ptr, i64 } %call177, 0
  store ptr %93, ptr %92, align 8
  %94 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp175, i32 0, i32 1
  %95 = extractvalue { ptr, i64 } %call177, 1
  store i64 %95, ptr %94, align 8
  %call179 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp175)
          to label %invoke.cont178 unwind label %lpad40

invoke.cont178:                                   ; preds = %invoke.cont176
  %conv180 = zext i1 %call179 to i32
  %96 = load i64, ptr %j, align 8
  %call183 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv3, i64 noundef %96)
          to label %invoke.cont182 unwind label %lpad40

invoke.cont182:                                   ; preds = %invoke.cont178
  %97 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp181, i32 0, i32 0
  %98 = extractvalue { ptr, i64 } %call183, 0
  store ptr %98, ptr %97, align 8
  %99 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp181, i32 0, i32 1
  %100 = extractvalue { ptr, i64 } %call183, 1
  store i64 %100, ptr %99, align 8
  %call185 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp181)
          to label %invoke.cont184 unwind label %lpad40

invoke.cont184:                                   ; preds = %invoke.cont182
  %conv186 = zext i1 %call185 to i32
  %cmp187 = icmp eq i32 %conv180, %conv186
  %call189 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp187, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 127, ptr noundef @.str.25)
          to label %invoke.cont188 unwind label %lpad40

invoke.cont188:                                   ; preds = %invoke.cont184
  br label %for.inc190

for.inc190:                                       ; preds = %invoke.cont188
  %101 = load i64, ptr %j, align 8
  %inc191 = add i64 %101, 1
  store i64 %inc191, ptr %j, align 8
  br label %for.cond171, !llvm.loop !33

for.end192:                                       ; preds = %for.cond171
  %call194 = invoke noundef zeroext i1 @_ZN5eastleqINS_9allocatorEmNS_6vectorImS1_EEEEbRKNS_9bitvectorIT_T0_T1_EESA_(ptr noundef nonnull align 8 dereferenceable(32) %bv7, ptr noundef nonnull align 8 dereferenceable(32) %bv3)
          to label %invoke.cont193 unwind label %lpad40

invoke.cont193:                                   ; preds = %for.end192
  %call196 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call194, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 128, ptr noundef @.str.26)
          to label %invoke.cont195 unwind label %lpad40

invoke.cont195:                                   ; preds = %invoke.cont193
  store i64 0, ptr %i197, align 8
  br label %for.cond198

for.cond198:                                      ; preds = %for.inc219, %invoke.cont195
  %102 = load i64, ptr %i197, align 8
  %call199 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %cmp200 = icmp ult i64 %102, %call199
  br i1 %cmp200, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond198
  %103 = load i64, ptr %i197, align 8
  %call201 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv7) #9
  %cmp202 = icmp ult i64 %103, %call201
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond198
  %104 = phi i1 [ false, %for.cond198 ], [ %cmp202, %land.rhs ]
  br i1 %104, label %for.body203, label %for.end221

for.body203:                                      ; preds = %land.end
  %105 = load i64, ptr %i197, align 8
  %call206 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv3, i64 noundef %105)
          to label %invoke.cont205 unwind label %lpad40

invoke.cont205:                                   ; preds = %for.body203
  %106 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp204, i32 0, i32 0
  %107 = extractvalue { ptr, i64 } %call206, 0
  store ptr %107, ptr %106, align 8
  %108 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp204, i32 0, i32 1
  %109 = extractvalue { ptr, i64 } %call206, 1
  store i64 %109, ptr %108, align 8
  %call208 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp204)
          to label %invoke.cont207 unwind label %lpad40

invoke.cont207:                                   ; preds = %invoke.cont205
  %conv209 = zext i1 %call208 to i32
  %110 = load i64, ptr %i197, align 8
  %call212 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv7, i64 noundef %110)
          to label %invoke.cont211 unwind label %lpad40

invoke.cont211:                                   ; preds = %invoke.cont207
  %111 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp210, i32 0, i32 0
  %112 = extractvalue { ptr, i64 } %call212, 0
  store ptr %112, ptr %111, align 8
  %113 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp210, i32 0, i32 1
  %114 = extractvalue { ptr, i64 } %call212, 1
  store i64 %114, ptr %113, align 8
  %call214 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp210)
          to label %invoke.cont213 unwind label %lpad40

invoke.cont213:                                   ; preds = %invoke.cont211
  %conv215 = zext i1 %call214 to i32
  %cmp216 = icmp eq i32 %conv209, %conv215
  %call218 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp216, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 130, ptr noundef @.str.27)
          to label %invoke.cont217 unwind label %lpad40

invoke.cont217:                                   ; preds = %invoke.cont213
  br label %for.inc219

for.inc219:                                       ; preds = %invoke.cont217
  %115 = load i64, ptr %i197, align 8
  %inc220 = add i64 %115, 1
  store i64 %inc220, ptr %i197, align 8
  br label %for.cond198, !llvm.loop !34

for.end221:                                       ; preds = %land.end
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4swapERS4_(ptr noundef nonnull align 8 dereferenceable(32) %bv7, ptr noundef nonnull align 8 dereferenceable(32) %bv7)
          to label %invoke.cont222 unwind label %lpad40

invoke.cont222:                                   ; preds = %for.end221
  %call223 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %bv7)
  %call225 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call223, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 137, ptr noundef @.str.23)
          to label %invoke.cont224 unwind label %lpad40

invoke.cont224:                                   ; preds = %invoke.cont222
  %call227 = invoke noundef zeroext i1 @_ZN5eastleqINS_9allocatorEmNS_6vectorImS1_EEEEbRKNS_9bitvectorIT_T0_T1_EESA_(ptr noundef nonnull align 8 dereferenceable(32) %bv7, ptr noundef nonnull align 8 dereferenceable(32) %bv3)
          to label %invoke.cont226 unwind label %lpad40

invoke.cont226:                                   ; preds = %invoke.cont224
  %call229 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call227, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 138, ptr noundef @.str.26)
          to label %invoke.cont228 unwind label %lpad40

invoke.cont228:                                   ; preds = %invoke.cont226
  %call230 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv7) #9
  %call231 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %cmp232 = icmp eq i64 %call230, %call231
  %call234 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp232, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 139, ptr noundef @.str.24)
          to label %invoke.cont233 unwind label %lpad40

invoke.cont233:                                   ; preds = %invoke.cont228
  store i64 0, ptr %i235, align 8
  br label %for.cond236

for.cond236:                                      ; preds = %for.inc259, %invoke.cont233
  %116 = load i64, ptr %i235, align 8
  %call237 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %cmp238 = icmp ult i64 %116, %call237
  br i1 %cmp238, label %land.rhs239, label %land.end242

land.rhs239:                                      ; preds = %for.cond236
  %117 = load i64, ptr %i235, align 8
  %call240 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv7) #9
  %cmp241 = icmp ult i64 %117, %call240
  br label %land.end242

land.end242:                                      ; preds = %land.rhs239, %for.cond236
  %118 = phi i1 [ false, %for.cond236 ], [ %cmp241, %land.rhs239 ]
  br i1 %118, label %for.body243, label %for.end261

for.body243:                                      ; preds = %land.end242
  %119 = load i64, ptr %i235, align 8
  %call246 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv3, i64 noundef %119)
          to label %invoke.cont245 unwind label %lpad40

invoke.cont245:                                   ; preds = %for.body243
  %120 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp244, i32 0, i32 0
  %121 = extractvalue { ptr, i64 } %call246, 0
  store ptr %121, ptr %120, align 8
  %122 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp244, i32 0, i32 1
  %123 = extractvalue { ptr, i64 } %call246, 1
  store i64 %123, ptr %122, align 8
  %call248 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp244)
          to label %invoke.cont247 unwind label %lpad40

invoke.cont247:                                   ; preds = %invoke.cont245
  %conv249 = zext i1 %call248 to i32
  %124 = load i64, ptr %i235, align 8
  %call252 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv7, i64 noundef %124)
          to label %invoke.cont251 unwind label %lpad40

invoke.cont251:                                   ; preds = %invoke.cont247
  %125 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp250, i32 0, i32 0
  %126 = extractvalue { ptr, i64 } %call252, 0
  store ptr %126, ptr %125, align 8
  %127 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp250, i32 0, i32 1
  %128 = extractvalue { ptr, i64 } %call252, 1
  store i64 %128, ptr %127, align 8
  %call254 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp250)
          to label %invoke.cont253 unwind label %lpad40

invoke.cont253:                                   ; preds = %invoke.cont251
  %conv255 = zext i1 %call254 to i32
  %cmp256 = icmp eq i32 %conv249, %conv255
  %call258 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp256, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 141, ptr noundef @.str.27)
          to label %invoke.cont257 unwind label %lpad40

invoke.cont257:                                   ; preds = %invoke.cont253
  br label %for.inc259

for.inc259:                                       ; preds = %invoke.cont257
  %129 = load i64, ptr %i235, align 8
  %inc260 = add i64 %129, 1
  store i64 %inc260, ptr %i235, align 8
  br label %for.cond236, !llvm.loop !35

for.end261:                                       ; preds = %land.end242
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4swapERS4_(ptr noundef nonnull align 8 dereferenceable(32) %bv3, ptr noundef nonnull align 8 dereferenceable(32) %bv2)
          to label %invoke.cont262 unwind label %lpad40

invoke.cont262:                                   ; preds = %for.end261
  %call263 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3)
  %call265 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call263, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 144, ptr noundef @.str.11)
          to label %invoke.cont264 unwind label %lpad40

invoke.cont264:                                   ; preds = %invoke.cont262
  %call266 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %cmp267 = icmp eq i64 %call266, 200
  %call269 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp267, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 145, ptr noundef @.str.28)
          to label %invoke.cont268 unwind label %lpad40

invoke.cont268:                                   ; preds = %invoke.cont264
  store i64 0, ptr %i270, align 8
  br label %for.cond271

for.cond271:                                      ; preds = %for.inc284, %invoke.cont268
  %130 = load i64, ptr %i270, align 8
  %call272 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %cmp273 = icmp ult i64 %130, %call272
  br i1 %cmp273, label %for.body274, label %for.end286

for.body274:                                      ; preds = %for.cond271
  %131 = load i64, ptr %i270, align 8
  %call277 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv3, i64 noundef %131)
          to label %invoke.cont276 unwind label %lpad40

invoke.cont276:                                   ; preds = %for.body274
  %132 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp275, i32 0, i32 0
  %133 = extractvalue { ptr, i64 } %call277, 0
  store ptr %133, ptr %132, align 8
  %134 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp275, i32 0, i32 1
  %135 = extractvalue { ptr, i64 } %call277, 1
  store i64 %135, ptr %134, align 8
  %call279 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp275)
          to label %invoke.cont278 unwind label %lpad40

invoke.cont278:                                   ; preds = %invoke.cont276
  %conv280 = zext i1 %call279 to i32
  %cmp281 = icmp eq i32 %conv280, 0
  %call283 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp281, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 147, ptr noundef @.str.29)
          to label %invoke.cont282 unwind label %lpad40

invoke.cont282:                                   ; preds = %invoke.cont278
  br label %for.inc284

for.inc284:                                       ; preds = %invoke.cont282
  %136 = load i64, ptr %i270, align 8
  %inc285 = add i64 %136, 1
  store i64 %inc285, ptr %i270, align 8
  br label %for.cond271, !llvm.loop !36

for.end286:                                       ; preds = %for.cond271
  %call287 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %bv2)
  %call289 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call287, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 149, ptr noundef @.str.8)
          to label %invoke.cont288 unwind label %lpad40

invoke.cont288:                                   ; preds = %for.end286
  %call290 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv2) #9
  %cmp291 = icmp eq i64 %call290, 300
  %call293 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp291, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 150, ptr noundef @.str.30)
          to label %invoke.cont292 unwind label %lpad40

invoke.cont292:                                   ; preds = %invoke.cont288
  store i64 0, ptr %i294, align 8
  br label %for.cond295

for.cond295:                                      ; preds = %for.inc308, %invoke.cont292
  %137 = load i64, ptr %i294, align 8
  %call296 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv2) #9
  %cmp297 = icmp ult i64 %137, %call296
  br i1 %cmp297, label %for.body298, label %for.end310

for.body298:                                      ; preds = %for.cond295
  %138 = load i64, ptr %i294, align 8
  %call301 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv2, i64 noundef %138)
          to label %invoke.cont300 unwind label %lpad40

invoke.cont300:                                   ; preds = %for.body298
  %139 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp299, i32 0, i32 0
  %140 = extractvalue { ptr, i64 } %call301, 0
  store ptr %140, ptr %139, align 8
  %141 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp299, i32 0, i32 1
  %142 = extractvalue { ptr, i64 } %call301, 1
  store i64 %142, ptr %141, align 8
  %call303 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp299)
          to label %invoke.cont302 unwind label %lpad40

invoke.cont302:                                   ; preds = %invoke.cont300
  %conv304 = zext i1 %call303 to i32
  %cmp305 = icmp eq i32 %conv304, 1
  %call307 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp305, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 152, ptr noundef @.str.31)
          to label %invoke.cont306 unwind label %lpad40

invoke.cont306:                                   ; preds = %invoke.cont302
  br label %for.inc308

for.inc308:                                       ; preds = %invoke.cont306
  %143 = load i64, ptr %i294, align 8
  %inc309 = add i64 %143, 1
  store i64 %inc309, ptr %i294, align 8
  br label %for.cond295, !llvm.loop !37

for.end310:                                       ; preds = %for.cond295
  %call312 = invoke noundef nonnull align 8 dereferenceable(32) ptr @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEaSERKS4_(ptr noundef nonnull align 8 dereferenceable(32) %bv6, ptr noundef nonnull align 8 dereferenceable(32) %bv7)
          to label %invoke.cont311 unwind label %lpad40

invoke.cont311:                                   ; preds = %for.end310
  %call313 = call noundef zeroext i1 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(32) %bv6)
  %call315 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call313, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 158, ptr noundef @.str.20)
          to label %invoke.cont314 unwind label %lpad40

invoke.cont314:                                   ; preds = %invoke.cont311
  %call317 = invoke noundef zeroext i1 @_ZN5eastleqINS_9allocatorEmNS_6vectorImS1_EEEEbRKNS_9bitvectorIT_T0_T1_EESA_(ptr noundef nonnull align 8 dereferenceable(32) %bv6, ptr noundef nonnull align 8 dereferenceable(32) %bv7)
          to label %invoke.cont316 unwind label %lpad40

invoke.cont316:                                   ; preds = %invoke.cont314
  %call319 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call317, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 159, ptr noundef @.str.32)
          to label %invoke.cont318 unwind label %lpad40

invoke.cont318:                                   ; preds = %invoke.cont316
  %call321 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %coerce.dive322 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp320, i32 0, i32 0
  %coerce.dive323 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive322, i32 0, i32 0
  %144 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive323, i32 0, i32 0
  %145 = extractvalue { ptr, i64 } %call321, 0
  store ptr %145, ptr %144, align 8
  %146 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive323, i32 0, i32 1
  %147 = extractvalue { ptr, i64 } %call321, 1
  store i64 %147, ptr %146, align 8
  %call325 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  %coerce.dive326 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %agg.tmp324, i32 0, i32 0
  %coerce.dive327 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive326, i32 0, i32 0
  %148 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive327, i32 0, i32 0
  %149 = extractvalue { ptr, i64 } %call325, 0
  store ptr %149, ptr %148, align 8
  %150 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive327, i32 0, i32 1
  %151 = extractvalue { ptr, i64 } %call325, 1
  store i64 %151, ptr %150, align 8
  %152 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp320, i32 0, i32 0
  %153 = load ptr, ptr %152, align 8
  %154 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp320, i32 0, i32 1
  %155 = load i64, ptr %154, align 8
  %156 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp324, i32 0, i32 0
  %157 = load ptr, ptr %156, align 8
  %158 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp324, i32 0, i32 1
  %159 = load i64, ptr %158, align 8
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6assignINS_18bitvector_iteratorImEEEEvT_S8_(ptr noundef nonnull align 8 dereferenceable(32) %bv0, ptr %153, i64 %155, ptr %157, i64 %159)
          to label %invoke.cont328 unwind label %lpad40

invoke.cont328:                                   ; preds = %invoke.cont318
  %call330 = invoke noundef zeroext i1 @_ZN5eastleqINS_9allocatorEmNS_6vectorImS1_EEEEbRKNS_9bitvectorIT_T0_T1_EESA_(ptr noundef nonnull align 8 dereferenceable(32) %bv0, ptr noundef nonnull align 8 dereferenceable(32) %bv3)
          to label %invoke.cont329 unwind label %lpad40

invoke.cont329:                                   ; preds = %invoke.cont328
  %call332 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call330, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 164, ptr noundef @.str.33)
          to label %invoke.cont331 unwind label %lpad40

invoke.cont331:                                   ; preds = %invoke.cont329
  %arraydecay333 = getelementptr inbounds [3 x i8], ptr %boolArray, i64 0, i64 0
  %arraydecay334 = getelementptr inbounds [3 x i8], ptr %boolArray, i64 0, i64 0
  %add.ptr335 = getelementptr inbounds i8, ptr %arraydecay334, i64 3
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6assignIPbEEvT_S7_(ptr noundef nonnull align 8 dereferenceable(32) %bv0, ptr noundef %arraydecay333, ptr noundef %add.ptr335)
          to label %invoke.cont336 unwind label %lpad40

invoke.cont336:                                   ; preds = %invoke.cont331
  %arraydecay338 = getelementptr inbounds [3 x i8], ptr %boolArray, i64 0, i64 0
  %arraydecay339 = getelementptr inbounds [3 x i8], ptr %boolArray, i64 0, i64 0
  %add.ptr340 = getelementptr inbounds i8, ptr %arraydecay339, i64 3
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2IPbEET_S7_(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp337, ptr noundef %arraydecay338, ptr noundef %add.ptr340)
          to label %invoke.cont341 unwind label %lpad40

invoke.cont341:                                   ; preds = %invoke.cont336
  %call344 = invoke noundef zeroext i1 @_ZN5eastleqINS_9allocatorEmNS_6vectorImS1_EEEEbRKNS_9bitvectorIT_T0_T1_EESA_(ptr noundef nonnull align 8 dereferenceable(32) %bv0, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp337)
          to label %invoke.cont343 unwind label %lpad342

invoke.cont343:                                   ; preds = %invoke.cont341
  %call346 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call344, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 167, ptr noundef @.str.34)
          to label %invoke.cont345 unwind label %lpad342

invoke.cont345:                                   ; preds = %invoke.cont343
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp337) #9
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %bv0, i64 noundef 0)
          to label %invoke.cont348 unwind label %lpad40

invoke.cont348:                                   ; preds = %invoke.cont345
  %call350 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0) #9
  %coerce.dive351 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp349, i32 0, i32 0
  %coerce.dive352 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive351, i32 0, i32 0
  %160 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive352, i32 0, i32 0
  %161 = extractvalue { ptr, i64 } %call350, 0
  store ptr %161, ptr %160, align 8
  %162 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive352, i32 0, i32 1
  %163 = extractvalue { ptr, i64 } %call350, 1
  store i64 %163, ptr %162, align 8
  %call354 = call { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0) #9
  %coerce.dive355 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp353, i32 0, i32 0
  %coerce.dive356 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive355, i32 0, i32 0
  %164 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive356, i32 0, i32 0
  %165 = extractvalue { ptr, i64 } %call354, 0
  store ptr %165, ptr %164, align 8
  %166 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive356, i32 0, i32 1
  %167 = extractvalue { ptr, i64 } %call354, 1
  store i64 %167, ptr %166, align 8
  %call358 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEeqERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp349, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp353)
          to label %invoke.cont357 unwind label %lpad40

invoke.cont357:                                   ; preds = %invoke.cont348
  %call360 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call358, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 170, ptr noundef @.str.35)
          to label %invoke.cont359 unwind label %lpad40

invoke.cont359:                                   ; preds = %invoke.cont357
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(32) %bv3, i64 noundef 0)
          to label %invoke.cont361 unwind label %lpad40

invoke.cont361:                                   ; preds = %invoke.cont359
  %call363 = invoke noundef zeroext i1 @_ZN5eastleqINS_9allocatorEmNS_6vectorImS1_EEEEbRKNS_9bitvectorIT_T0_T1_EESA_(ptr noundef nonnull align 8 dereferenceable(32) %bv0, ptr noundef nonnull align 8 dereferenceable(32) %bv3)
          to label %invoke.cont362 unwind label %lpad40

invoke.cont362:                                   ; preds = %invoke.cont361
  %call365 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call363, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 172, ptr noundef @.str.33)
          to label %invoke.cont364 unwind label %lpad40

invoke.cont364:                                   ; preds = %invoke.cont362
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv7) #9
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv6) #9
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv5) #9
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(48) %bv4) #9
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv2) #9
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(48) %bv1) #9
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv0) #9
  store i64 100, ptr %kTestSize, align 8
  store i64 5, ptr %kTestIncrement, align 8
  call void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp375, ptr noundef @.str.3)
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %bv1374, i64 noundef 100, i1 noundef zeroext false, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp375)
  invoke void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp377, ptr noundef @.str.3)
          to label %invoke.cont379 unwind label %lpad378

invoke.cont379:                                   ; preds = %invoke.cont364
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %bv2376, i64 noundef 100, i1 noundef zeroext false, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp377)
          to label %invoke.cont380 unwind label %lpad378

invoke.cont380:                                   ; preds = %invoke.cont379
  store i64 0, ptr %i381, align 8
  br label %for.cond382

for.cond382:                                      ; preds = %for.inc396, %invoke.cont380
  %168 = load i64, ptr %i381, align 8
  %cmp383 = icmp ult i64 %168, 100
  br i1 %cmp383, label %for.body384, label %for.end397

for.body384:                                      ; preds = %for.cond382
  %169 = load i64, ptr %i381, align 8
  %call388 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv1374, i64 noundef %169)
          to label %invoke.cont387 unwind label %lpad386

invoke.cont387:                                   ; preds = %for.body384
  %170 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp385, i32 0, i32 0
  %171 = extractvalue { ptr, i64 } %call388, 0
  store ptr %171, ptr %170, align 8
  %172 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp385, i32 0, i32 1
  %173 = extractvalue { ptr, i64 } %call388, 1
  store i64 %173, ptr %172, align 8
  %call390 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp385, i1 noundef zeroext true)
          to label %invoke.cont389 unwind label %lpad386

invoke.cont389:                                   ; preds = %invoke.cont387
  %174 = load i64, ptr %i381, align 8
  %call393 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv2376, i64 noundef %174)
          to label %invoke.cont392 unwind label %lpad386

invoke.cont392:                                   ; preds = %invoke.cont389
  %175 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp391, i32 0, i32 0
  %176 = extractvalue { ptr, i64 } %call393, 0
  store ptr %176, ptr %175, align 8
  %177 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp391, i32 0, i32 1
  %178 = extractvalue { ptr, i64 } %call393, 1
  store i64 %178, ptr %177, align 8
  %call395 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp391, i1 noundef zeroext true)
          to label %invoke.cont394 unwind label %lpad386

invoke.cont394:                                   ; preds = %invoke.cont392
  br label %for.inc396

for.inc396:                                       ; preds = %invoke.cont394
  %179 = load i64, ptr %i381, align 8
  %add = add i64 %179, 5
  store i64 %add, ptr %i381, align 8
  br label %for.cond382, !llvm.loop !38

lpad342:                                          ; preds = %invoke.cont343, %invoke.cont341
  %180 = landingpad { ptr, i32 }
          cleanup
  %181 = extractvalue { ptr, i32 } %180, 0
  store ptr %181, ptr %exn.slot, align 8
  %182 = extractvalue { ptr, i32 } %180, 1
  store i32 %182, ptr %ehselector.slot, align 4
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp337) #9
  br label %ehcleanup366

ehcleanup366:                                     ; preds = %lpad342, %lpad40
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv7) #9
  br label %ehcleanup367

ehcleanup367:                                     ; preds = %ehcleanup366, %lpad37
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv6) #9
  br label %ehcleanup368

ehcleanup368:                                     ; preds = %ehcleanup367, %lpad28
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv5) #9
  br label %ehcleanup369

ehcleanup369:                                     ; preds = %ehcleanup368, %lpad25
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(48) %bv4) #9
  br label %ehcleanup370

ehcleanup370:                                     ; preds = %ehcleanup369, %lpad23
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv3) #9
  br label %ehcleanup371

ehcleanup371:                                     ; preds = %ehcleanup370, %lpad20
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv2) #9
  br label %ehcleanup372

ehcleanup372:                                     ; preds = %ehcleanup371, %lpad16
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(48) %bv1) #9
  br label %ehcleanup373

ehcleanup373:                                     ; preds = %ehcleanup372, %lpad14
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv0) #9
  br label %eh.resume

lpad378:                                          ; preds = %invoke.cont379, %invoke.cont364
  %183 = landingpad { ptr, i32 }
          cleanup
  %184 = extractvalue { ptr, i32 } %183, 0
  store ptr %184, ptr %exn.slot, align 8
  %185 = extractvalue { ptr, i32 } %183, 1
  store i32 %185, ptr %ehselector.slot, align 4
  br label %ehcleanup440

lpad386:                                          ; preds = %invoke.cont392, %invoke.cont389, %invoke.cont387, %for.body384
  %186 = landingpad { ptr, i32 }
          cleanup
  %187 = extractvalue { ptr, i32 } %186, 0
  store ptr %187, ptr %exn.slot, align 8
  %188 = extractvalue { ptr, i32 } %186, 1
  store i32 %188, ptr %ehselector.slot, align 4
  br label %ehcleanup439

for.end397:                                       ; preds = %for.cond382
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2EOS4_(ptr noundef nonnull align 8 dereferenceable(32) %bv3398, ptr noundef nonnull align 8 dereferenceable(32) %bv1374) #9
  invoke void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp400, ptr noundef @.str.3)
          to label %invoke.cont402 unwind label %lpad401

invoke.cont402:                                   ; preds = %for.end397
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC1EmbRKS1_(ptr noundef nonnull align 8 dereferenceable(32) %bv4399, i64 noundef 50, i1 noundef zeroext true, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp400)
          to label %invoke.cont403 unwind label %lpad401

invoke.cont403:                                   ; preds = %invoke.cont402
  %call406 = invoke noundef nonnull align 8 dereferenceable(32) ptr @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEaSEOS4_(ptr noundef nonnull align 8 dereferenceable(32) %bv4399, ptr noundef nonnull align 8 dereferenceable(32) %bv2376)
          to label %invoke.cont405 unwind label %lpad404

invoke.cont405:                                   ; preds = %invoke.cont403
  store i64 0, ptr %i407, align 8
  br label %for.cond408

for.cond408:                                      ; preds = %for.inc434, %invoke.cont405
  %189 = load i64, ptr %i407, align 8
  %cmp409 = icmp ult i64 %189, 100
  br i1 %cmp409, label %for.body410, label %for.end436

for.body410:                                      ; preds = %for.cond408
  %190 = load i64, ptr %i407, align 8
  %call413 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv3398, i64 noundef %190)
          to label %invoke.cont412 unwind label %lpad404

invoke.cont412:                                   ; preds = %for.body410
  %191 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp411, i32 0, i32 0
  %192 = extractvalue { ptr, i64 } %call413, 0
  store ptr %192, ptr %191, align 8
  %193 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp411, i32 0, i32 1
  %194 = extractvalue { ptr, i64 } %call413, 1
  store i64 %194, ptr %193, align 8
  %call415 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp411)
          to label %invoke.cont414 unwind label %lpad404

invoke.cont414:                                   ; preds = %invoke.cont412
  %conv416 = zext i1 %call415 to i32
  %195 = load i64, ptr %i407, align 8
  %rem = urem i64 %195, 5
  %cmp417 = icmp eq i64 %rem, 0
  %conv418 = zext i1 %cmp417 to i32
  %cmp419 = icmp eq i32 %conv416, %conv418
  %call421 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp419, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 194, ptr noundef @.str.36)
          to label %invoke.cont420 unwind label %lpad404

invoke.cont420:                                   ; preds = %invoke.cont414
  %196 = load i64, ptr %i407, align 8
  %call424 = invoke { ptr, i64 } @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(32) %bv4399, i64 noundef %196)
          to label %invoke.cont423 unwind label %lpad404

invoke.cont423:                                   ; preds = %invoke.cont420
  %197 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp422, i32 0, i32 0
  %198 = extractvalue { ptr, i64 } %call424, 0
  store ptr %198, ptr %197, align 8
  %199 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp422, i32 0, i32 1
  %200 = extractvalue { ptr, i64 } %call424, 1
  store i64 %200, ptr %199, align 8
  %call426 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp422)
          to label %invoke.cont425 unwind label %lpad404

invoke.cont425:                                   ; preds = %invoke.cont423
  %conv427 = zext i1 %call426 to i32
  %201 = load i64, ptr %i407, align 8
  %rem428 = urem i64 %201, 5
  %cmp429 = icmp eq i64 %rem428, 0
  %conv430 = zext i1 %cmp429 to i32
  %cmp431 = icmp eq i32 %conv427, %conv430
  %call433 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp431, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 195, ptr noundef @.str.37)
          to label %invoke.cont432 unwind label %lpad404

invoke.cont432:                                   ; preds = %invoke.cont425
  br label %for.inc434

for.inc434:                                       ; preds = %invoke.cont432
  %202 = load i64, ptr %i407, align 8
  %inc435 = add i64 %202, 1
  store i64 %inc435, ptr %i407, align 8
  br label %for.cond408, !llvm.loop !39

lpad401:                                          ; preds = %invoke.cont402, %for.end397
  %203 = landingpad { ptr, i32 }
          cleanup
  %204 = extractvalue { ptr, i32 } %203, 0
  store ptr %204, ptr %exn.slot, align 8
  %205 = extractvalue { ptr, i32 } %203, 1
  store i32 %205, ptr %ehselector.slot, align 4
  br label %ehcleanup438

lpad404:                                          ; preds = %invoke.cont425, %invoke.cont423, %invoke.cont420, %invoke.cont414, %invoke.cont412, %for.body410, %invoke.cont403
  %206 = landingpad { ptr, i32 }
          cleanup
  %207 = extractvalue { ptr, i32 } %206, 0
  store ptr %207, ptr %exn.slot, align 8
  %208 = extractvalue { ptr, i32 } %206, 1
  store i32 %208, ptr %ehselector.slot, align 4
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv4399) #9
  br label %ehcleanup438

for.end436:                                       ; preds = %for.cond408
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv4399) #9
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv3398) #9
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv2376) #9
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv1374) #9
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %boolArray441, ptr align 1 @__const._Z13TestBitVectorv.boolArray.38, i64 6, i1 false)
  %arraydecay443 = getelementptr inbounds [6 x i8], ptr %boolArray441, i64 0, i64 0
  %arraydecay444 = getelementptr inbounds [6 x i8], ptr %boolArray441, i64 0, i64 0
  %add.ptr445 = getelementptr inbounds i8, ptr %arraydecay444, i64 6
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2IPbEET_S7_(ptr noundef nonnull align 8 dereferenceable(32) %bv0442, ptr noundef %arraydecay443, ptr noundef %add.ptr445)
  invoke void @_ZN5eastl24bitvector_const_iteratorImEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %it)
          to label %invoke.cont447 unwind label %lpad446

invoke.cont447:                                   ; preds = %for.end436
  %call450 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %coerce.dive451 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp449, i32 0, i32 0
  %209 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive451, i32 0, i32 0
  %210 = extractvalue { ptr, i64 } %call450, 0
  store ptr %210, ptr %209, align 8
  %211 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive451, i32 0, i32 1
  %212 = extractvalue { ptr, i64 } %call450, 1
  store i64 %212, ptr %211, align 8
  %call453 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %it, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp449)
          to label %invoke.cont452 unwind label %lpad446

invoke.cont452:                                   ; preds = %invoke.cont447
  store i64 0, ptr %i448, align 8
  br label %for.cond454

for.cond454:                                      ; preds = %invoke.cont472, %invoke.cont452
  %call456 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %coerce.dive457 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp455, i32 0, i32 0
  %213 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive457, i32 0, i32 0
  %214 = extractvalue { ptr, i64 } %call456, 0
  store ptr %214, ptr %213, align 8
  %215 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive457, i32 0, i32 1
  %216 = extractvalue { ptr, i64 } %call456, 1
  store i64 %216, ptr %215, align 8
  %call459 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %it, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp455)
          to label %invoke.cont458 unwind label %lpad446

invoke.cont458:                                   ; preds = %for.cond454
  br i1 %call459, label %for.body460, label %for.end475

for.body460:                                      ; preds = %invoke.cont458
  %call462 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %it)
          to label %invoke.cont461 unwind label %lpad446

invoke.cont461:                                   ; preds = %for.body460
  %frombool = zext i1 %call462 to i8
  store i8 %frombool, ptr %value, align 1
  %217 = load i8, ptr %value, align 1
  %tobool463 = trunc i8 %217 to i1
  %conv464 = zext i1 %tobool463 to i32
  %218 = load i64, ptr %i448, align 8
  %arrayidx465 = getelementptr inbounds [6 x i8], ptr %boolArray441, i64 0, i64 %218
  %219 = load i8, ptr %arrayidx465, align 1
  %tobool466 = trunc i8 %219 to i1
  %conv467 = zext i1 %tobool466 to i32
  %cmp468 = icmp eq i32 %conv464, %conv467
  %call470 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp468, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 213, ptr noundef @.str.39)
          to label %invoke.cont469 unwind label %lpad446

invoke.cont469:                                   ; preds = %invoke.cont461
  br label %for.inc471

for.inc471:                                       ; preds = %invoke.cont469
  %call473 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %it)
          to label %invoke.cont472 unwind label %lpad446

invoke.cont472:                                   ; preds = %for.inc471
  %220 = load i64, ptr %i448, align 8
  %inc474 = add i64 %220, 1
  store i64 %inc474, ptr %i448, align 8
  br label %for.cond454, !llvm.loop !40

ehcleanup438:                                     ; preds = %lpad404, %lpad401
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv3398) #9
  br label %ehcleanup439

ehcleanup439:                                     ; preds = %ehcleanup438, %lpad386
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv2376) #9
  br label %ehcleanup440

ehcleanup440:                                     ; preds = %ehcleanup439, %lpad378
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv1374) #9
  br label %eh.resume

lpad446:                                          ; preds = %for.inc671, %invoke.cont660, %invoke.cont658, %invoke.cont655, %for.body652, %for.end645, %for.inc641, %invoke.cont630, %invoke.cont628, %invoke.cont625, %for.body622, %for.cond618, %for.end613, %for.inc609, %invoke.cont598, %invoke.cont596, %invoke.cont593, %for.body590, %for.end583, %for.inc579, %invoke.cont568, %invoke.cont566, %invoke.cont563, %for.body560, %for.cond556, %invoke.cont550, %for.end549, %for.inc545, %invoke.cont534, %for.body532, %for.end527, %for.inc523, %invoke.cont512, %for.body510, %for.cond504, %for.end497, %for.inc493, %invoke.cont482, %for.body480, %for.end475, %for.inc471, %invoke.cont461, %for.body460, %for.cond454, %invoke.cont447, %for.end436
  %221 = landingpad { ptr, i32 }
          cleanup
  %222 = extractvalue { ptr, i32 } %221, 0
  store ptr %222, ptr %exn.slot, align 8
  %223 = extractvalue { ptr, i32 } %221, 1
  store i32 %223, ptr %ehselector.slot, align 4
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  br label %eh.resume

for.end475:                                       ; preds = %invoke.cont458
  %call477 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %it)
          to label %invoke.cont476 unwind label %lpad446

invoke.cont476:                                   ; preds = %for.end475
  %224 = load i64, ptr %i448, align 8
  %dec = add i64 %224, -1
  store i64 %dec, ptr %i448, align 8
  br label %for.cond478

for.cond478:                                      ; preds = %invoke.cont494, %invoke.cont476
  %225 = load i64, ptr %i448, align 8
  %cmp479 = icmp sge i64 %225, 0
  br i1 %cmp479, label %for.body480, label %for.end497

for.body480:                                      ; preds = %for.cond478
  %call483 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %it)
          to label %invoke.cont482 unwind label %lpad446

invoke.cont482:                                   ; preds = %for.body480
  %frombool484 = zext i1 %call483 to i8
  store i8 %frombool484, ptr %value481, align 1
  %226 = load i8, ptr %value481, align 1
  %tobool485 = trunc i8 %226 to i1
  %conv486 = zext i1 %tobool485 to i32
  %227 = load i64, ptr %i448, align 8
  %arrayidx487 = getelementptr inbounds [6 x i8], ptr %boolArray441, i64 0, i64 %227
  %228 = load i8, ptr %arrayidx487, align 1
  %tobool488 = trunc i8 %228 to i1
  %conv489 = zext i1 %tobool488 to i32
  %cmp490 = icmp eq i32 %conv486, %conv489
  %call492 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp490, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 219, ptr noundef @.str.39)
          to label %invoke.cont491 unwind label %lpad446

invoke.cont491:                                   ; preds = %invoke.cont482
  br label %for.inc493

for.inc493:                                       ; preds = %invoke.cont491
  %call495 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %it)
          to label %invoke.cont494 unwind label %lpad446

invoke.cont494:                                   ; preds = %for.inc493
  %229 = load i64, ptr %i448, align 8
  %dec496 = add i64 %229, -1
  store i64 %dec496, ptr %i448, align 8
  br label %for.cond478, !llvm.loop !41

for.end497:                                       ; preds = %for.cond478
  %call499 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %coerce.dive500 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp498, i32 0, i32 0
  %230 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive500, i32 0, i32 0
  %231 = extractvalue { ptr, i64 } %call499, 0
  store ptr %231, ptr %230, align 8
  %232 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive500, i32 0, i32 1
  %233 = extractvalue { ptr, i64 } %call499, 1
  store i64 %233, ptr %232, align 8
  %call502 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %it, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp498)
          to label %invoke.cont501 unwind label %lpad446

invoke.cont501:                                   ; preds = %for.end497
  %234 = load i64, ptr %i448, align 8
  %inc503 = add i64 %234, 1
  store i64 %inc503, ptr %i448, align 8
  br label %for.cond504

for.cond504:                                      ; preds = %invoke.cont524, %invoke.cont501
  %call506 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %coerce.dive507 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp505, i32 0, i32 0
  %235 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive507, i32 0, i32 0
  %236 = extractvalue { ptr, i64 } %call506, 0
  store ptr %236, ptr %235, align 8
  %237 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive507, i32 0, i32 1
  %238 = extractvalue { ptr, i64 } %call506, 1
  store i64 %238, ptr %237, align 8
  %call509 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %it, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp505)
          to label %invoke.cont508 unwind label %lpad446

invoke.cont508:                                   ; preds = %for.cond504
  br i1 %call509, label %for.body510, label %for.end527

for.body510:                                      ; preds = %invoke.cont508
  %call513 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %it)
          to label %invoke.cont512 unwind label %lpad446

invoke.cont512:                                   ; preds = %for.body510
  %frombool514 = zext i1 %call513 to i8
  store i8 %frombool514, ptr %value511, align 1
  %239 = load i8, ptr %value511, align 1
  %tobool515 = trunc i8 %239 to i1
  %conv516 = zext i1 %tobool515 to i32
  %240 = load i64, ptr %i448, align 8
  %arrayidx517 = getelementptr inbounds [6 x i8], ptr %boolArray441, i64 0, i64 %240
  %241 = load i8, ptr %arrayidx517, align 1
  %tobool518 = trunc i8 %241 to i1
  %conv519 = zext i1 %tobool518 to i32
  %cmp520 = icmp eq i32 %conv516, %conv519
  %call522 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp520, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 227, ptr noundef @.str.39)
          to label %invoke.cont521 unwind label %lpad446

invoke.cont521:                                   ; preds = %invoke.cont512
  br label %for.inc523

for.inc523:                                       ; preds = %invoke.cont521
  %call525 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %it, i64 noundef 2)
          to label %invoke.cont524 unwind label %lpad446

invoke.cont524:                                   ; preds = %for.inc523
  %242 = load i64, ptr %i448, align 8
  %add526 = add i64 %242, 2
  store i64 %add526, ptr %i448, align 8
  br label %for.cond504, !llvm.loop !42

for.end527:                                       ; preds = %invoke.cont508
  %call529 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %it, i64 noundef 2)
          to label %invoke.cont528 unwind label %lpad446

invoke.cont528:                                   ; preds = %for.end527
  %243 = load i64, ptr %i448, align 8
  %sub = sub i64 %243, 2
  store i64 %sub, ptr %i448, align 8
  br label %for.cond530

for.cond530:                                      ; preds = %invoke.cont546, %invoke.cont528
  %244 = load i64, ptr %i448, align 8
  %cmp531 = icmp sge i64 %244, 0
  br i1 %cmp531, label %for.body532, label %for.end549

for.body532:                                      ; preds = %for.cond530
  %call535 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %it)
          to label %invoke.cont534 unwind label %lpad446

invoke.cont534:                                   ; preds = %for.body532
  %frombool536 = zext i1 %call535 to i8
  store i8 %frombool536, ptr %value533, align 1
  %245 = load i8, ptr %value533, align 1
  %tobool537 = trunc i8 %245 to i1
  %conv538 = zext i1 %tobool537 to i32
  %246 = load i64, ptr %i448, align 8
  %arrayidx539 = getelementptr inbounds [6 x i8], ptr %boolArray441, i64 0, i64 %246
  %247 = load i8, ptr %arrayidx539, align 1
  %tobool540 = trunc i8 %247 to i1
  %conv541 = zext i1 %tobool540 to i32
  %cmp542 = icmp eq i32 %conv538, %conv541
  %call544 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp542, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 233, ptr noundef @.str.39)
          to label %invoke.cont543 unwind label %lpad446

invoke.cont543:                                   ; preds = %invoke.cont534
  br label %for.inc545

for.inc545:                                       ; preds = %invoke.cont543
  %call547 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %it, i64 noundef 2)
          to label %invoke.cont546 unwind label %lpad446

invoke.cont546:                                   ; preds = %for.inc545
  %248 = load i64, ptr %i448, align 8
  %sub548 = sub i64 %248, 2
  store i64 %sub548, ptr %i448, align 8
  br label %for.cond530, !llvm.loop !43

for.end549:                                       ; preds = %for.cond530
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %rit)
          to label %invoke.cont550 unwind label %lpad446

invoke.cont550:                                   ; preds = %for.end549
  %call551 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %sub552 = sub i64 %call551, 1
  store i64 %sub552, ptr %i448, align 8
  call void @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6rbeginEv(ptr sret(%"class.eastl::reverse_iterator.0") align 8 %ref.tmp553, ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %call555 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEaSERKS3_(ptr noundef nonnull align 8 dereferenceable(16) %rit, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp553)
          to label %invoke.cont554 unwind label %lpad446

invoke.cont554:                                   ; preds = %invoke.cont550
  br label %for.cond556

for.cond556:                                      ; preds = %invoke.cont580, %invoke.cont554
  call void @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4rendEv(ptr sret(%"class.eastl::reverse_iterator.0") align 8 %ref.tmp557, ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %call559 = invoke noundef zeroext i1 @_ZN5eastlneINS_24bitvector_const_iteratorImEES2_EEbRKNS_16reverse_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(16) %rit, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp557)
          to label %invoke.cont558 unwind label %lpad446

invoke.cont558:                                   ; preds = %for.cond556
  br i1 %call559, label %for.body560, label %for.end583

for.body560:                                      ; preds = %invoke.cont558
  %call564 = invoke { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %rit)
          to label %invoke.cont563 unwind label %lpad446

invoke.cont563:                                   ; preds = %for.body560
  %coerce.dive565 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp562, i32 0, i32 0
  %249 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive565, i32 0, i32 0
  %250 = extractvalue { ptr, i64 } %call564, 0
  store ptr %250, ptr %249, align 8
  %251 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive565, i32 0, i32 1
  %252 = extractvalue { ptr, i64 } %call564, 1
  store i64 %252, ptr %251, align 8
  %call567 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp562)
          to label %invoke.cont566 unwind label %lpad446

invoke.cont566:                                   ; preds = %invoke.cont563
  %call569 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call567)
          to label %invoke.cont568 unwind label %lpad446

invoke.cont568:                                   ; preds = %invoke.cont566
  %frombool570 = zext i1 %call569 to i8
  store i8 %frombool570, ptr %value561, align 1
  %253 = load i8, ptr %value561, align 1
  %tobool571 = trunc i8 %253 to i1
  %conv572 = zext i1 %tobool571 to i32
  %254 = load i64, ptr %i448, align 8
  %arrayidx573 = getelementptr inbounds [6 x i8], ptr %boolArray441, i64 0, i64 %254
  %255 = load i8, ptr %arrayidx573, align 1
  %tobool574 = trunc i8 %255 to i1
  %conv575 = zext i1 %tobool574 to i32
  %cmp576 = icmp eq i32 %conv572, %conv575
  %call578 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp576, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 249, ptr noundef @.str.39)
          to label %invoke.cont577 unwind label %lpad446

invoke.cont577:                                   ; preds = %invoke.cont568
  br label %for.inc579

for.inc579:                                       ; preds = %invoke.cont577
  %call581 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEppEv(ptr noundef nonnull align 8 dereferenceable(16) %rit)
          to label %invoke.cont580 unwind label %lpad446

invoke.cont580:                                   ; preds = %for.inc579
  %256 = load i64, ptr %i448, align 8
  %dec582 = add i64 %256, -1
  store i64 %dec582, ptr %i448, align 8
  br label %for.cond556, !llvm.loop !44

for.end583:                                       ; preds = %invoke.cont558
  %call585 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %rit)
          to label %invoke.cont584 unwind label %lpad446

invoke.cont584:                                   ; preds = %for.end583
  %257 = load i64, ptr %i448, align 8
  %inc586 = add i64 %257, 1
  store i64 %inc586, ptr %i448, align 8
  br label %for.cond587

for.cond587:                                      ; preds = %invoke.cont610, %invoke.cont584
  %258 = load i64, ptr %i448, align 8
  %call588 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %cmp589 = icmp ult i64 %258, %call588
  br i1 %cmp589, label %for.body590, label %for.end613

for.body590:                                      ; preds = %for.cond587
  %call594 = invoke { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %rit)
          to label %invoke.cont593 unwind label %lpad446

invoke.cont593:                                   ; preds = %for.body590
  %coerce.dive595 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp592, i32 0, i32 0
  %259 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive595, i32 0, i32 0
  %260 = extractvalue { ptr, i64 } %call594, 0
  store ptr %260, ptr %259, align 8
  %261 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive595, i32 0, i32 1
  %262 = extractvalue { ptr, i64 } %call594, 1
  store i64 %262, ptr %261, align 8
  %call597 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp592)
          to label %invoke.cont596 unwind label %lpad446

invoke.cont596:                                   ; preds = %invoke.cont593
  %call599 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call597)
          to label %invoke.cont598 unwind label %lpad446

invoke.cont598:                                   ; preds = %invoke.cont596
  %frombool600 = zext i1 %call599 to i8
  store i8 %frombool600, ptr %value591, align 1
  %263 = load i8, ptr %value591, align 1
  %tobool601 = trunc i8 %263 to i1
  %conv602 = zext i1 %tobool601 to i32
  %264 = load i64, ptr %i448, align 8
  %arrayidx603 = getelementptr inbounds [6 x i8], ptr %boolArray441, i64 0, i64 %264
  %265 = load i8, ptr %arrayidx603, align 1
  %tobool604 = trunc i8 %265 to i1
  %conv605 = zext i1 %tobool604 to i32
  %cmp606 = icmp eq i32 %conv602, %conv605
  %call608 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp606, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 256, ptr noundef @.str.39)
          to label %invoke.cont607 unwind label %lpad446

invoke.cont607:                                   ; preds = %invoke.cont598
  br label %for.inc609

for.inc609:                                       ; preds = %invoke.cont607
  %call611 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %rit)
          to label %invoke.cont610 unwind label %lpad446

invoke.cont610:                                   ; preds = %for.inc609
  %266 = load i64, ptr %i448, align 8
  %inc612 = add i64 %266, 1
  store i64 %inc612, ptr %i448, align 8
  br label %for.cond587, !llvm.loop !45

for.end613:                                       ; preds = %for.cond587
  call void @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6rbeginEv(ptr sret(%"class.eastl::reverse_iterator.0") align 8 %ref.tmp614, ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %call616 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEaSERKS3_(ptr noundef nonnull align 8 dereferenceable(16) %rit, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp614)
          to label %invoke.cont615 unwind label %lpad446

invoke.cont615:                                   ; preds = %for.end613
  %267 = load i64, ptr %i448, align 8
  %dec617 = add i64 %267, -1
  store i64 %dec617, ptr %i448, align 8
  br label %for.cond618

for.cond618:                                      ; preds = %invoke.cont642, %invoke.cont615
  call void @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4rendEv(ptr sret(%"class.eastl::reverse_iterator.0") align 8 %ref.tmp619, ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %call621 = invoke noundef zeroext i1 @_ZN5eastlneINS_24bitvector_const_iteratorImEES2_EEbRKNS_16reverse_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(16) %rit, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp619)
          to label %invoke.cont620 unwind label %lpad446

invoke.cont620:                                   ; preds = %for.cond618
  br i1 %call621, label %for.body622, label %for.end645

for.body622:                                      ; preds = %invoke.cont620
  %call626 = invoke { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %rit)
          to label %invoke.cont625 unwind label %lpad446

invoke.cont625:                                   ; preds = %for.body622
  %coerce.dive627 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp624, i32 0, i32 0
  %268 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive627, i32 0, i32 0
  %269 = extractvalue { ptr, i64 } %call626, 0
  store ptr %269, ptr %268, align 8
  %270 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive627, i32 0, i32 1
  %271 = extractvalue { ptr, i64 } %call626, 1
  store i64 %271, ptr %270, align 8
  %call629 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp624)
          to label %invoke.cont628 unwind label %lpad446

invoke.cont628:                                   ; preds = %invoke.cont625
  %call631 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call629)
          to label %invoke.cont630 unwind label %lpad446

invoke.cont630:                                   ; preds = %invoke.cont628
  %frombool632 = zext i1 %call631 to i8
  store i8 %frombool632, ptr %value623, align 1
  %272 = load i8, ptr %value623, align 1
  %tobool633 = trunc i8 %272 to i1
  %conv634 = zext i1 %tobool633 to i32
  %273 = load i64, ptr %i448, align 8
  %arrayidx635 = getelementptr inbounds [6 x i8], ptr %boolArray441, i64 0, i64 %273
  %274 = load i8, ptr %arrayidx635, align 1
  %tobool636 = trunc i8 %274 to i1
  %conv637 = zext i1 %tobool636 to i32
  %cmp638 = icmp eq i32 %conv634, %conv637
  %call640 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp638, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 265, ptr noundef @.str.39)
          to label %invoke.cont639 unwind label %lpad446

invoke.cont639:                                   ; preds = %invoke.cont630
  br label %for.inc641

for.inc641:                                       ; preds = %invoke.cont639
  %call643 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %rit, i64 noundef 2)
          to label %invoke.cont642 unwind label %lpad446

invoke.cont642:                                   ; preds = %for.inc641
  %275 = load i64, ptr %i448, align 8
  %sub644 = sub i64 %275, 2
  store i64 %sub644, ptr %i448, align 8
  br label %for.cond618, !llvm.loop !46

for.end645:                                       ; preds = %invoke.cont620
  %call647 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %rit, i64 noundef 2)
          to label %invoke.cont646 unwind label %lpad446

invoke.cont646:                                   ; preds = %for.end645
  %276 = load i64, ptr %i448, align 8
  %add648 = add i64 %276, 2
  store i64 %add648, ptr %i448, align 8
  br label %for.cond649

for.cond649:                                      ; preds = %invoke.cont672, %invoke.cont646
  %277 = load i64, ptr %i448, align 8
  %call650 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  %cmp651 = icmp ult i64 %277, %call650
  br i1 %cmp651, label %for.body652, label %for.end675

for.body652:                                      ; preds = %for.cond649
  %call656 = invoke { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %rit)
          to label %invoke.cont655 unwind label %lpad446

invoke.cont655:                                   ; preds = %for.body652
  %coerce.dive657 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp654, i32 0, i32 0
  %278 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive657, i32 0, i32 0
  %279 = extractvalue { ptr, i64 } %call656, 0
  store ptr %279, ptr %278, align 8
  %280 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive657, i32 0, i32 1
  %281 = extractvalue { ptr, i64 } %call656, 1
  store i64 %281, ptr %280, align 8
  %call659 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp654)
          to label %invoke.cont658 unwind label %lpad446

invoke.cont658:                                   ; preds = %invoke.cont655
  %call661 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %call659)
          to label %invoke.cont660 unwind label %lpad446

invoke.cont660:                                   ; preds = %invoke.cont658
  %frombool662 = zext i1 %call661 to i8
  store i8 %frombool662, ptr %value653, align 1
  %282 = load i8, ptr %value653, align 1
  %tobool663 = trunc i8 %282 to i1
  %conv664 = zext i1 %tobool663 to i32
  %283 = load i64, ptr %i448, align 8
  %arrayidx665 = getelementptr inbounds [6 x i8], ptr %boolArray441, i64 0, i64 %283
  %284 = load i8, ptr %arrayidx665, align 1
  %tobool666 = trunc i8 %284 to i1
  %conv667 = zext i1 %tobool666 to i32
  %cmp668 = icmp eq i32 %conv664, %conv667
  %call670 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp668, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 272, ptr noundef @.str.39)
          to label %invoke.cont669 unwind label %lpad446

invoke.cont669:                                   ; preds = %invoke.cont660
  br label %for.inc671

for.inc671:                                       ; preds = %invoke.cont669
  %call673 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %rit, i64 noundef 2)
          to label %invoke.cont672 unwind label %lpad446

invoke.cont672:                                   ; preds = %for.inc671
  %285 = load i64, ptr %i448, align 8
  %add674 = add i64 %285, 2
  store i64 %add674, ptr %i448, align 8
  br label %for.cond649, !llvm.loop !47

for.end675:                                       ; preds = %for.cond649
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %bv0442) #9
  call void @_ZN15MallocAllocatorC2EPKc(ptr noundef nonnull align 8 dereferenceable(16) %mallocAllocator677, ptr noundef null)
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEC1ERKS1_(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr noundef nonnull align 8 dereferenceable(16) %mallocAllocator677)
  %call679 = call noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %call682 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call679, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 295, ptr noundef @.str.5)
          to label %invoke.cont681 unwind label %lpad680

invoke.cont681:                                   ; preds = %for.end675
  %call683 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp684 = icmp eq i64 %call683, 0
  %call686 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp684, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 296, ptr noundef @.str.40)
          to label %invoke.cont685 unwind label %lpad680

invoke.cont685:                                   ; preds = %invoke.cont681
  %call687 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp688 = icmp eq i64 %call687, 0
  %call690 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp688, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 297, ptr noundef @.str.41)
          to label %invoke.cont689 unwind label %lpad680

invoke.cont689:                                   ; preds = %invoke.cont685
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %boolArray691, ptr align 1 @__const._Z13TestBitVectorv.boolArray.42, i64 3, i1 false)
  %arraydecay692 = getelementptr inbounds [3 x i8], ptr %boolArray691, i64 0, i64 0
  %arraydecay693 = getelementptr inbounds [3 x i8], ptr %boolArray691, i64 0, i64 0
  %add.ptr694 = getelementptr inbounds i8, ptr %arraydecay693, i64 3
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6assignIPbEEvT_S7_(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr noundef %arraydecay692, ptr noundef %add.ptr694)
          to label %invoke.cont695 unwind label %lpad680

invoke.cont695:                                   ; preds = %invoke.cont689
  %call696 = call noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %lnot = xor i1 %call696, true
  %call698 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %lnot, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 302, ptr noundef @.str.43)
          to label %invoke.cont697 unwind label %lpad680

invoke.cont697:                                   ; preds = %invoke.cont695
  %call699 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp700 = icmp eq i64 %call699, 3
  %call702 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp700, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 303, ptr noundef @.str.44)
          to label %invoke.cont701 unwind label %lpad680

invoke.cont701:                                   ; preds = %invoke.cont697
  %call703 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp704 = icmp ugt i64 %call703, 0
  br i1 %cmp704, label %land.rhs705, label %land.end708

land.rhs705:                                      ; preds = %invoke.cont701
  %call706 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp707 = icmp ule i64 %call706, 64
  br label %land.end708

land.end708:                                      ; preds = %land.rhs705, %invoke.cont701
  %286 = phi i1 [ false, %invoke.cont701 ], [ %cmp707, %land.rhs705 ]
  %call710 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %286, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 304, ptr noundef @.str.45)
          to label %invoke.cont709 unwind label %lpad680

invoke.cont709:                                   ; preds = %land.end708
  %call713 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
          to label %invoke.cont712 unwind label %lpad680

invoke.cont712:                                   ; preds = %invoke.cont709
  %287 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp711, i32 0, i32 0
  %288 = extractvalue { ptr, i64 } %call713, 0
  store ptr %288, ptr %287, align 8
  %289 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp711, i32 0, i32 1
  %290 = extractvalue { ptr, i64 } %call713, 1
  store i64 %290, ptr %289, align 8
  %call715 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp711)
          to label %invoke.cont714 unwind label %lpad680

invoke.cont714:                                   ; preds = %invoke.cont712
  %conv716 = zext i1 %call715 to i32
  %cmp717 = icmp eq i32 %conv716, 0
  %call719 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp717, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 312, ptr noundef @.str.46)
          to label %invoke.cont718 unwind label %lpad680

invoke.cont718:                                   ; preds = %invoke.cont714
  %call722 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
          to label %invoke.cont721 unwind label %lpad680

invoke.cont721:                                   ; preds = %invoke.cont718
  %291 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp720, i32 0, i32 0
  %292 = extractvalue { ptr, i64 } %call722, 0
  store ptr %292, ptr %291, align 8
  %293 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp720, i32 0, i32 1
  %294 = extractvalue { ptr, i64 } %call722, 1
  store i64 %294, ptr %293, align 8
  %call724 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp720)
          to label %invoke.cont723 unwind label %lpad680

invoke.cont723:                                   ; preds = %invoke.cont721
  %conv725 = zext i1 %call724 to i32
  %cmp726 = icmp eq i32 %conv725, 1
  %call728 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp726, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 313, ptr noundef @.str.47)
          to label %invoke.cont727 unwind label %lpad680

invoke.cont727:                                   ; preds = %invoke.cont723
  %call731 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %coerce.dive732 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp730, i32 0, i32 0
  %coerce.dive733 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive732, i32 0, i32 0
  %295 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive733, i32 0, i32 0
  %296 = extractvalue { ptr, i64 } %call731, 0
  store ptr %296, ptr %295, align 8
  %297 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive733, i32 0, i32 1
  %298 = extractvalue { ptr, i64 } %call731, 1
  store i64 %298, ptr %297, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp729, ptr align 8 %ref.tmp730, i64 16, i1 false)
  %299 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp729, i32 0, i32 0
  %300 = load ptr, ptr %299, align 8
  %301 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp729, i32 0, i32 1
  %302 = load i64, ptr %301, align 8
  %call735 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr %300, i64 %302)
          to label %invoke.cont734 unwind label %lpad680

invoke.cont734:                                   ; preds = %invoke.cont727
  %coerce.dive736 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %coerce, i32 0, i32 0
  %coerce.dive737 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive736, i32 0, i32 0
  %303 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive737, i32 0, i32 0
  %304 = extractvalue { ptr, i64 } %call735, 0
  store ptr %304, ptr %303, align 8
  %305 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive737, i32 0, i32 1
  %306 = extractvalue { ptr, i64 } %call735, 1
  store i64 %306, ptr %305, align 8
  %call740 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5frontEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
          to label %invoke.cont739 unwind label %lpad680

invoke.cont739:                                   ; preds = %invoke.cont734
  %307 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp738, i32 0, i32 0
  %308 = extractvalue { ptr, i64 } %call740, 0
  store ptr %308, ptr %307, align 8
  %309 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp738, i32 0, i32 1
  %310 = extractvalue { ptr, i64 } %call740, 1
  store i64 %310, ptr %309, align 8
  %call742 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp738)
          to label %invoke.cont741 unwind label %lpad680

invoke.cont741:                                   ; preds = %invoke.cont739
  %conv743 = zext i1 %call742 to i32
  %cmp744 = icmp eq i32 %conv743, 1
  %call746 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp744, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 315, ptr noundef @.str.48)
          to label %invoke.cont745 unwind label %lpad680

invoke.cont745:                                   ; preds = %invoke.cont741
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6rbeginEv(ptr sret(%"class.eastl::reverse_iterator") align 8 %ref.tmp748, ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2INS_18bitvector_iteratorImEEEERKNS0_IT_EE(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp747, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp748)
          to label %invoke.cont749 unwind label %lpad680

invoke.cont749:                                   ; preds = %invoke.cont745
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEE(ptr sret(%"class.eastl::reverse_iterator") align 8 %tmp, ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr noundef %agg.tmp747)
          to label %invoke.cont750 unwind label %lpad680

invoke.cont750:                                   ; preds = %invoke.cont749
  %call753 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
          to label %invoke.cont752 unwind label %lpad680

invoke.cont752:                                   ; preds = %invoke.cont750
  %311 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp751, i32 0, i32 0
  %312 = extractvalue { ptr, i64 } %call753, 0
  store ptr %312, ptr %311, align 8
  %313 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp751, i32 0, i32 1
  %314 = extractvalue { ptr, i64 } %call753, 1
  store i64 %314, ptr %313, align 8
  %call755 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp751)
          to label %invoke.cont754 unwind label %lpad680

invoke.cont754:                                   ; preds = %invoke.cont752
  %conv756 = zext i1 %call755 to i32
  %cmp757 = icmp eq i32 %conv756, 1
  %call759 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp757, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 317, ptr noundef @.str.47)
          to label %invoke.cont758 unwind label %lpad680

invoke.cont758:                                   ; preds = %invoke.cont754
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 17)
          to label %invoke.cont760 unwind label %lpad680

invoke.cont760:                                   ; preds = %invoke.cont758
  %call761 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp762 = icmp uge i64 %call761, 17
  br i1 %cmp762, label %land.rhs763, label %land.end766

land.rhs763:                                      ; preds = %invoke.cont760
  %call764 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp765 = icmp ule i64 %call764, 100
  br label %land.end766

land.end766:                                      ; preds = %land.rhs763, %invoke.cont760
  %315 = phi i1 [ false, %invoke.cont760 ], [ %cmp765, %land.rhs763 ]
  %call768 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %315, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 322, ptr noundef @.str.49)
          to label %invoke.cont767 unwind label %lpad680

invoke.cont767:                                   ; preds = %land.end766
  %316 = load i32, ptr @_ZN15MallocAllocator14mAllocCountAllE, align 4
  store i32 %316, ptr %allocCountBefore, align 4
  br label %while.cond

while.cond:                                       ; preds = %invoke.cont771, %invoke.cont767
  %call769 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp770 = icmp ult i64 %call769, 17
  br i1 %cmp770, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i1 noundef zeroext false)
          to label %invoke.cont771 unwind label %lpad680

invoke.cont771:                                   ; preds = %while.body
  br label %while.cond, !llvm.loop !48

lpad680:                                          ; preds = %invoke.cont1193, %invoke.cont1191, %invoke.cont1188, %invoke.cont1186, %invoke.cont1182, %invoke.cont1180, %invoke.cont1178, %invoke.cont1175, %invoke.cont1171, %land.end1170, %invoke.cont1164, %land.rhs1162, %invoke.cont1157, %invoke.cont1153, %invoke.cont1151, %invoke.cont1149, %invoke.cont1147, %invoke.cont1141, %invoke.cont1139, %invoke.cont1133, %invoke.cont1129, %invoke.cont1119, %invoke.cont1110, %invoke.cont1108, %invoke.cont1105, %invoke.cont1101, %invoke.cont1099, %invoke.cont1096, %land.end1095, %invoke.cont1089, %land.rhs1087, %invoke.cont1081, %invoke.cont1075, %invoke.cont1071, %invoke.cont1063, %land.end1062, %invoke.cont1056, %land.rhs1054, %invoke.cont1048, %invoke.cont1045, %invoke.cont1041, %invoke.cont1039, %invoke.cont1033, %invoke.cont1026, %invoke.cont1022, %invoke.cont1020, %invoke.cont1017, %land.end1016, %invoke.cont1010, %land.rhs1008, %invoke.cont1002, %invoke.cont1000, %invoke.cont996, %invoke.cont988, %invoke.cont984, %invoke.cont982, %invoke.cont979, %invoke.cont977, %invoke.cont974, %invoke.cont970, %invoke.cont968, %invoke.cont962, %invoke.cont958, %invoke.cont951, %invoke.cont949, %invoke.cont946, %for.end944, %for.inc941, %invoke.cont936, %for.body934, %for.cond927, %invoke.cont919, %invoke.cont916, %invoke.cont914, %invoke.cont911, %invoke.cont908, %invoke.cont903, %invoke.cont899, %invoke.cont898, %invoke.cont896, %invoke.cont892, %invoke.cont891, %invoke.cont889, %invoke.cont885, %invoke.cont883, %invoke.cont879, %invoke.cont877, %invoke.cont873, %invoke.cont872, %invoke.cont870, %invoke.cont866, %invoke.cont864, %invoke.cont859, %invoke.cont855, %invoke.cont853, %invoke.cont848, %invoke.cont844, %invoke.cont842, %invoke.cont837, %invoke.cont833, %invoke.cont831, %invoke.cont826, %invoke.cont822, %invoke.cont820, %invoke.cont815, %invoke.cont811, %invoke.cont809, %invoke.cont805, %invoke.cont804, %invoke.cont802, %invoke.cont800, %invoke.cont798, %invoke.cont796, %invoke.cont794, %invoke.cont792, %invoke.cont789, %invoke.cont787, %invoke.cont784, %invoke.cont781, %invoke.cont779, %invoke.cont775, %invoke.cont773, %while.end, %while.body, %land.end766, %invoke.cont758, %invoke.cont754, %invoke.cont752, %invoke.cont750, %invoke.cont749, %invoke.cont745, %invoke.cont741, %invoke.cont739, %invoke.cont734, %invoke.cont727, %invoke.cont723, %invoke.cont721, %invoke.cont718, %invoke.cont714, %invoke.cont712, %invoke.cont709, %land.end708, %invoke.cont697, %invoke.cont695, %invoke.cont689, %invoke.cont685, %invoke.cont681, %for.end675
  %317 = landingpad { ptr, i32 }
          cleanup
  %318 = extractvalue { ptr, i32 } %317, 0
  store ptr %318, ptr %exn.slot, align 8
  %319 = extractvalue { ptr, i32 } %317, 1
  store i32 %319, ptr %ehselector.slot, align 4
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  br label %eh.resume

while.end:                                        ; preds = %while.cond
  %320 = load i32, ptr %allocCountBefore, align 4
  %321 = load i32, ptr @_ZN15MallocAllocator14mAllocCountAllE, align 4
  %cmp772 = icmp eq i32 %320, %321
  %call774 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp772, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 327, ptr noundef @.str.50)
          to label %invoke.cont773 unwind label %lpad680

invoke.cont773:                                   ; preds = %while.end
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef -1)
          to label %invoke.cont775 unwind label %lpad680

invoke.cont775:                                   ; preds = %invoke.cont773
  %call776 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %call777 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp778 = icmp uge i64 %call776, %call777
  %call780 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp778, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 330, ptr noundef @.str.51)
          to label %invoke.cont779 unwind label %lpad680

invoke.cont779:                                   ; preds = %invoke.cont775
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 0)
          to label %invoke.cont781 unwind label %lpad680

invoke.cont781:                                   ; preds = %invoke.cont779
  %call782 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp783 = icmp eq i64 %call782, 0
  %call785 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp783, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 333, ptr noundef @.str.41)
          to label %invoke.cont784 unwind label %lpad680

invoke.cont784:                                   ; preds = %invoke.cont781
  %call786 = call noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %call788 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call786, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 334, ptr noundef @.str.5)
          to label %invoke.cont787 unwind label %lpad680

invoke.cont787:                                   ; preds = %invoke.cont784
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 800)
          to label %invoke.cont789 unwind label %lpad680

invoke.cont789:                                   ; preds = %invoke.cont787
  %call790 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp791 = icmp uge i64 %call790, 800
  %call793 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp791, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 342, ptr noundef @.str.52)
          to label %invoke.cont792 unwind label %lpad680

invoke.cont792:                                   ; preds = %invoke.cont789
  %322 = load i32, ptr @_ZN15MallocAllocator14mAllocCountAllE, align 4
  store i32 %322, ptr %allocCountBefore, align 4
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 800, i1 noundef zeroext true)
          to label %invoke.cont794 unwind label %lpad680

invoke.cont794:                                   ; preds = %invoke.cont792
  %323 = load i32, ptr %allocCountBefore, align 4
  %324 = load i32, ptr @_ZN15MallocAllocator14mAllocCountAllE, align 4
  %cmp795 = icmp eq i32 %323, %324
  %call797 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp795, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 345, ptr noundef @.str.50)
          to label %invoke.cont796 unwind label %lpad680

invoke.cont796:                                   ; preds = %invoke.cont794
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
          to label %invoke.cont798 unwind label %lpad680

invoke.cont798:                                   ; preds = %invoke.cont796
  %call801 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
          to label %invoke.cont800 unwind label %lpad680

invoke.cont800:                                   ; preds = %invoke.cont798
  %325 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp799, i32 0, i32 0
  %326 = extractvalue { ptr, i64 } %call801, 0
  store ptr %326, ptr %325, align 8
  %327 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp799, i32 0, i32 1
  %328 = extractvalue { ptr, i64 } %call801, 1
  store i64 %328, ptr %327, align 8
  %call803 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp799, i1 noundef zeroext true)
          to label %invoke.cont802 unwind label %lpad680

invoke.cont802:                                   ; preds = %invoke.cont800
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i1 noundef zeroext false)
          to label %invoke.cont804 unwind label %lpad680

invoke.cont804:                                   ; preds = %invoke.cont802
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i1 noundef zeroext true)
          to label %invoke.cont805 unwind label %lpad680

invoke.cont805:                                   ; preds = %invoke.cont804
  %call807 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %sub808 = sub i64 %call807, 1
  %call810 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef %sub808)
          to label %invoke.cont809 unwind label %lpad680

invoke.cont809:                                   ; preds = %invoke.cont805
  %329 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp806, i32 0, i32 0
  %330 = extractvalue { ptr, i64 } %call810, 0
  store ptr %330, ptr %329, align 8
  %331 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp806, i32 0, i32 1
  %332 = extractvalue { ptr, i64 } %call810, 1
  store i64 %332, ptr %331, align 8
  %call812 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp806)
          to label %invoke.cont811 unwind label %lpad680

invoke.cont811:                                   ; preds = %invoke.cont809
  %conv813 = zext i1 %call812 to i32
  %cmp814 = icmp eq i32 %conv813, 1
  %call816 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp814, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 359, ptr noundef @.str.53)
          to label %invoke.cont815 unwind label %lpad680

invoke.cont815:                                   ; preds = %invoke.cont811
  %call818 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %sub819 = sub i64 %call818, 2
  %call821 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef %sub819)
          to label %invoke.cont820 unwind label %lpad680

invoke.cont820:                                   ; preds = %invoke.cont815
  %333 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp817, i32 0, i32 0
  %334 = extractvalue { ptr, i64 } %call821, 0
  store ptr %334, ptr %333, align 8
  %335 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp817, i32 0, i32 1
  %336 = extractvalue { ptr, i64 } %call821, 1
  store i64 %336, ptr %335, align 8
  %call823 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp817)
          to label %invoke.cont822 unwind label %lpad680

invoke.cont822:                                   ; preds = %invoke.cont820
  %conv824 = zext i1 %call823 to i32
  %cmp825 = icmp eq i32 %conv824, 0
  %call827 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp825, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 360, ptr noundef @.str.54)
          to label %invoke.cont826 unwind label %lpad680

invoke.cont826:                                   ; preds = %invoke.cont822
  %call829 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %sub830 = sub i64 %call829, 3
  %call832 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef %sub830)
          to label %invoke.cont831 unwind label %lpad680

invoke.cont831:                                   ; preds = %invoke.cont826
  %337 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp828, i32 0, i32 0
  %338 = extractvalue { ptr, i64 } %call832, 0
  store ptr %338, ptr %337, align 8
  %339 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp828, i32 0, i32 1
  %340 = extractvalue { ptr, i64 } %call832, 1
  store i64 %340, ptr %339, align 8
  %call834 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp828)
          to label %invoke.cont833 unwind label %lpad680

invoke.cont833:                                   ; preds = %invoke.cont831
  %conv835 = zext i1 %call834 to i32
  %cmp836 = icmp eq i32 %conv835, 1
  %call838 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp836, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 361, ptr noundef @.str.55)
          to label %invoke.cont837 unwind label %lpad680

invoke.cont837:                                   ; preds = %invoke.cont833
  %call840 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %sub841 = sub i64 %call840, 1
  %call843 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef %sub841)
          to label %invoke.cont842 unwind label %lpad680

invoke.cont842:                                   ; preds = %invoke.cont837
  %341 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp839, i32 0, i32 0
  %342 = extractvalue { ptr, i64 } %call843, 0
  store ptr %342, ptr %341, align 8
  %343 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp839, i32 0, i32 1
  %344 = extractvalue { ptr, i64 } %call843, 1
  store i64 %344, ptr %343, align 8
  %call845 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp839)
          to label %invoke.cont844 unwind label %lpad680

invoke.cont844:                                   ; preds = %invoke.cont842
  %conv846 = zext i1 %call845 to i32
  %cmp847 = icmp eq i32 %conv846, 1
  %call849 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp847, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 367, ptr noundef @.str.56)
          to label %invoke.cont848 unwind label %lpad680

invoke.cont848:                                   ; preds = %invoke.cont844
  %call851 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %sub852 = sub i64 %call851, 2
  %call854 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef %sub852)
          to label %invoke.cont853 unwind label %lpad680

invoke.cont853:                                   ; preds = %invoke.cont848
  %345 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp850, i32 0, i32 0
  %346 = extractvalue { ptr, i64 } %call854, 0
  store ptr %346, ptr %345, align 8
  %347 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp850, i32 0, i32 1
  %348 = extractvalue { ptr, i64 } %call854, 1
  store i64 %348, ptr %347, align 8
  %call856 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp850)
          to label %invoke.cont855 unwind label %lpad680

invoke.cont855:                                   ; preds = %invoke.cont853
  %conv857 = zext i1 %call856 to i32
  %cmp858 = icmp eq i32 %conv857, 0
  %call860 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp858, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 368, ptr noundef @.str.57)
          to label %invoke.cont859 unwind label %lpad680

invoke.cont859:                                   ; preds = %invoke.cont855
  %call862 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %sub863 = sub i64 %call862, 3
  %call865 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE2atEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef %sub863)
          to label %invoke.cont864 unwind label %lpad680

invoke.cont864:                                   ; preds = %invoke.cont859
  %349 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp861, i32 0, i32 0
  %350 = extractvalue { ptr, i64 } %call865, 0
  store ptr %350, ptr %349, align 8
  %351 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp861, i32 0, i32 1
  %352 = extractvalue { ptr, i64 } %call865, 1
  store i64 %352, ptr %351, align 8
  %call867 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp861)
          to label %invoke.cont866 unwind label %lpad680

invoke.cont866:                                   ; preds = %invoke.cont864
  %conv868 = zext i1 %call867 to i32
  %cmp869 = icmp eq i32 %conv868, 1
  %call871 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp869, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 369, ptr noundef @.str.58)
          to label %invoke.cont870 unwind label %lpad680

invoke.cont870:                                   ; preds = %invoke.cont866
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 17, i1 noundef zeroext true)
          to label %invoke.cont872 unwind label %lpad680

invoke.cont872:                                   ; preds = %invoke.cont870
  %call874 = invoke noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 0, i1 noundef zeroext false)
          to label %invoke.cont873 unwind label %lpad680

invoke.cont873:                                   ; preds = %invoke.cont872
  %conv875 = zext i1 %call874 to i32
  %cmp876 = icmp eq i32 %conv875, 1
  %call878 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp876, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 378, ptr noundef @.str.59)
          to label %invoke.cont877 unwind label %lpad680

invoke.cont877:                                   ; preds = %invoke.cont873
  %call880 = invoke noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 17, i1 noundef zeroext false)
          to label %invoke.cont879 unwind label %lpad680

invoke.cont879:                                   ; preds = %invoke.cont877
  %conv881 = zext i1 %call880 to i32
  %cmp882 = icmp eq i32 %conv881, 0
  %call884 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp882, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 379, ptr noundef @.str.60)
          to label %invoke.cont883 unwind label %lpad680

invoke.cont883:                                   ; preds = %invoke.cont879
  %call886 = invoke noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 17, i1 noundef zeroext true)
          to label %invoke.cont885 unwind label %lpad680

invoke.cont885:                                   ; preds = %invoke.cont883
  %conv887 = zext i1 %call886 to i32
  %cmp888 = icmp eq i32 %conv887, 1
  %call890 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp888, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 380, ptr noundef @.str.61)
          to label %invoke.cont889 unwind label %lpad680

invoke.cont889:                                   ; preds = %invoke.cont885
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3setEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 3, i1 noundef zeroext false)
          to label %invoke.cont891 unwind label %lpad680

invoke.cont891:                                   ; preds = %invoke.cont889
  %call893 = invoke noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 3, i1 noundef zeroext true)
          to label %invoke.cont892 unwind label %lpad680

invoke.cont892:                                   ; preds = %invoke.cont891
  %conv894 = zext i1 %call893 to i32
  %cmp895 = icmp eq i32 %conv894, 0
  %call897 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp895, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 383, ptr noundef @.str.62)
          to label %invoke.cont896 unwind label %lpad680

invoke.cont896:                                   ; preds = %invoke.cont892
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3setEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 100, i1 noundef zeroext true)
          to label %invoke.cont898 unwind label %lpad680

invoke.cont898:                                   ; preds = %invoke.cont896
  %call900 = invoke noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4testEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 100, i1 noundef zeroext false)
          to label %invoke.cont899 unwind label %lpad680

invoke.cont899:                                   ; preds = %invoke.cont898
  %conv901 = zext i1 %call900 to i32
  %cmp902 = icmp eq i32 %conv901, 1
  %call904 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp902, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 386, ptr noundef @.str.63)
          to label %invoke.cont903 unwind label %lpad680

invoke.cont903:                                   ; preds = %invoke.cont899
  %call905 = call noundef nonnull align 8 dereferenceable(40) ptr @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE13get_containerEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
  %call906 = call noundef zeroext i1 @_ZNK5eastl6vectorIm15MallocAllocatorE5emptyEv(ptr noundef nonnull align 8 dereferenceable(40) %call905) #9
  %lnot907 = xor i1 %call906, true
  %call909 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %lnot907, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 392, ptr noundef @.str.64)
          to label %invoke.cont908 unwind label %lpad680

invoke.cont908:                                   ; preds = %invoke.cont903
  %call910 = call noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
  %call912 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call910, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 398, ptr noundef @.str.4)
          to label %invoke.cont911 unwind label %lpad680

invoke.cont911:                                   ; preds = %invoke.cont908
  invoke void @_ZN5eastl18bitvector_iteratorImEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %it913)
          to label %invoke.cont914 unwind label %lpad680

invoke.cont914:                                   ; preds = %invoke.cont911
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp915, ptr align 8 %it913, i64 16, i1 false)
  %353 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp915, i32 0, i32 0
  %354 = load ptr, ptr %353, align 8
  %355 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp915, i32 0, i32 1
  %356 = load i64, ptr %355, align 8
  %call917 = invoke noundef i32 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE17validate_iteratorENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr %354, i64 %356)
          to label %invoke.cont916 unwind label %lpad680

invoke.cont916:                                   ; preds = %invoke.cont914
  %cmp918 = icmp eq i32 %call917, 0
  %call920 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp918, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 400, ptr noundef @.str.65)
          to label %invoke.cont919 unwind label %lpad680

invoke.cont919:                                   ; preds = %invoke.cont916
  %call922 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %coerce.dive923 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp921, i32 0, i32 0
  %coerce.dive924 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive923, i32 0, i32 0
  %357 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive924, i32 0, i32 0
  %358 = extractvalue { ptr, i64 } %call922, 0
  store ptr %358, ptr %357, align 8
  %359 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive924, i32 0, i32 1
  %360 = extractvalue { ptr, i64 } %call922, 1
  store i64 %360, ptr %359, align 8
  %call926 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEaSEOS1_(ptr noundef nonnull align 8 dereferenceable(16) %it913, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp921)
          to label %invoke.cont925 unwind label %lpad680

invoke.cont925:                                   ; preds = %invoke.cont919
  br label %for.cond927

for.cond927:                                      ; preds = %invoke.cont942, %invoke.cont925
  %call929 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %coerce.dive930 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp928, i32 0, i32 0
  %coerce.dive931 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive930, i32 0, i32 0
  %361 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive931, i32 0, i32 0
  %362 = extractvalue { ptr, i64 } %call929, 0
  store ptr %362, ptr %361, align 8
  %363 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive931, i32 0, i32 1
  %364 = extractvalue { ptr, i64 } %call929, 1
  store i64 %364, ptr %363, align 8
  %call933 = invoke noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %it913, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp928)
          to label %invoke.cont932 unwind label %lpad680

invoke.cont932:                                   ; preds = %for.cond927
  br i1 %call933, label %for.body934, label %for.end944

for.body934:                                      ; preds = %invoke.cont932
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp935, ptr align 8 %it913, i64 16, i1 false)
  %365 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp935, i32 0, i32 0
  %366 = load ptr, ptr %365, align 8
  %367 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp935, i32 0, i32 1
  %368 = load i64, ptr %367, align 8
  %call937 = invoke noundef i32 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE17validate_iteratorENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr %366, i64 %368)
          to label %invoke.cont936 unwind label %lpad680

invoke.cont936:                                   ; preds = %for.body934
  %cmp938 = icmp eq i32 %call937, 7
  %call940 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp938, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 402, ptr noundef @.str.66)
          to label %invoke.cont939 unwind label %lpad680

invoke.cont939:                                   ; preds = %invoke.cont936
  br label %for.inc941

for.inc941:                                       ; preds = %invoke.cont939
  %call943 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %it913)
          to label %invoke.cont942 unwind label %lpad680

invoke.cont942:                                   ; preds = %for.inc941
  br label %for.cond927, !llvm.loop !49

for.end944:                                       ; preds = %invoke.cont932
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp945, ptr align 8 %it913, i64 16, i1 false)
  %369 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp945, i32 0, i32 0
  %370 = load ptr, ptr %369, align 8
  %371 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp945, i32 0, i32 1
  %372 = load i64, ptr %371, align 8
  %call947 = invoke noundef i32 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE17validate_iteratorENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr %370, i64 %372)
          to label %invoke.cont946 unwind label %lpad680

invoke.cont946:                                   ; preds = %for.end944
  %cmp948 = icmp eq i32 %call947, 3
  %call950 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp948, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 403, ptr noundef @.str.67)
          to label %invoke.cont949 unwind label %lpad680

invoke.cont949:                                   ; preds = %invoke.cont946
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 17, i1 noundef zeroext true)
          to label %invoke.cont951 unwind label %lpad680

invoke.cont951:                                   ; preds = %invoke.cont949
  %call955 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %coerce.dive956 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp954, i32 0, i32 0
  %coerce.dive957 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive956, i32 0, i32 0
  %373 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive957, i32 0, i32 0
  %374 = extractvalue { ptr, i64 } %call955, 0
  store ptr %374, ptr %373, align 8
  %375 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive957, i32 0, i32 1
  %376 = extractvalue { ptr, i64 } %call955, 1
  store i64 %376, ptr %375, align 8
  %call959 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp954, i64 noundef 5)
          to label %invoke.cont958 unwind label %lpad680

invoke.cont958:                                   ; preds = %invoke.cont951
  %coerce.dive960 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp953, i32 0, i32 0
  %coerce.dive961 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive960, i32 0, i32 0
  %377 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive961, i32 0, i32 0
  %378 = extractvalue { ptr, i64 } %call959, 0
  store ptr %378, ptr %377, align 8
  %379 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive961, i32 0, i32 1
  %380 = extractvalue { ptr, i64 } %call959, 1
  store i64 %380, ptr %379, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp952, ptr align 8 %ref.tmp953, i64 16, i1 false)
  %381 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp952, i32 0, i32 0
  %382 = load ptr, ptr %381, align 8
  %383 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp952, i32 0, i32 1
  %384 = load i64, ptr %383, align 8
  %call963 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr %382, i64 %384, i1 noundef zeroext false)
          to label %invoke.cont962 unwind label %lpad680

invoke.cont962:                                   ; preds = %invoke.cont958
  %coerce.dive965 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %coerce964, i32 0, i32 0
  %coerce.dive966 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive965, i32 0, i32 0
  %385 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive966, i32 0, i32 0
  %386 = extractvalue { ptr, i64 } %call963, 0
  store ptr %386, ptr %385, align 8
  %387 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive966, i32 0, i32 1
  %388 = extractvalue { ptr, i64 } %call963, 1
  store i64 %388, ptr %387, align 8
  %call969 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 5)
          to label %invoke.cont968 unwind label %lpad680

invoke.cont968:                                   ; preds = %invoke.cont962
  %389 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp967, i32 0, i32 0
  %390 = extractvalue { ptr, i64 } %call969, 0
  store ptr %390, ptr %389, align 8
  %391 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp967, i32 0, i32 1
  %392 = extractvalue { ptr, i64 } %call969, 1
  store i64 %392, ptr %391, align 8
  %call971 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp967)
          to label %invoke.cont970 unwind label %lpad680

invoke.cont970:                                   ; preds = %invoke.cont968
  %conv972 = zext i1 %call971 to i32
  %cmp973 = icmp eq i32 %conv972, 0
  %call975 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp973, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 413, ptr noundef @.str.68)
          to label %invoke.cont974 unwind label %lpad680

invoke.cont974:                                   ; preds = %invoke.cont970
  %call978 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 5)
          to label %invoke.cont977 unwind label %lpad680

invoke.cont977:                                   ; preds = %invoke.cont974
  %393 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp976, i32 0, i32 0
  %394 = extractvalue { ptr, i64 } %call978, 0
  store ptr %394, ptr %393, align 8
  %395 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp976, i32 0, i32 1
  %396 = extractvalue { ptr, i64 } %call978, 1
  store i64 %396, ptr %395, align 8
  %call980 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp976, i1 noundef zeroext true)
          to label %invoke.cont979 unwind label %lpad680

invoke.cont979:                                   ; preds = %invoke.cont977
  %call983 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 5)
          to label %invoke.cont982 unwind label %lpad680

invoke.cont982:                                   ; preds = %invoke.cont979
  %397 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp981, i32 0, i32 0
  %398 = extractvalue { ptr, i64 } %call983, 0
  store ptr %398, ptr %397, align 8
  %399 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp981, i32 0, i32 1
  %400 = extractvalue { ptr, i64 } %call983, 1
  store i64 %400, ptr %399, align 8
  %call985 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp981)
          to label %invoke.cont984 unwind label %lpad680

invoke.cont984:                                   ; preds = %invoke.cont982
  %conv986 = zext i1 %call985 to i32
  %cmp987 = icmp eq i32 %conv986, 1
  %call989 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp987, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 415, ptr noundef @.str.69)
          to label %invoke.cont988 unwind label %lpad680

invoke.cont988:                                   ; preds = %invoke.cont984
  %call993 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %coerce.dive994 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp992, i32 0, i32 0
  %coerce.dive995 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive994, i32 0, i32 0
  %401 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive995, i32 0, i32 0
  %402 = extractvalue { ptr, i64 } %call993, 0
  store ptr %402, ptr %401, align 8
  %403 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive995, i32 0, i32 1
  %404 = extractvalue { ptr, i64 } %call993, 1
  store i64 %404, ptr %403, align 8
  %call997 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp992, i64 noundef 5)
          to label %invoke.cont996 unwind label %lpad680

invoke.cont996:                                   ; preds = %invoke.cont988
  %coerce.dive998 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp991, i32 0, i32 0
  %coerce.dive999 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive998, i32 0, i32 0
  %405 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive999, i32 0, i32 0
  %406 = extractvalue { ptr, i64 } %call997, 0
  store ptr %406, ptr %405, align 8
  %407 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive999, i32 0, i32 1
  %408 = extractvalue { ptr, i64 } %call997, 1
  store i64 %408, ptr %407, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp990, ptr align 8 %ref.tmp991, i64 16, i1 false)
  %409 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp990, i32 0, i32 0
  %410 = load ptr, ptr %409, align 8
  %411 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp990, i32 0, i32 1
  %412 = load i64, ptr %411, align 8
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr %410, i64 %412, i64 noundef 7, i1 noundef zeroext false)
          to label %invoke.cont1000 unwind label %lpad680

invoke.cont1000:                                  ; preds = %invoke.cont996
  %call1003 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 5)
          to label %invoke.cont1002 unwind label %lpad680

invoke.cont1002:                                  ; preds = %invoke.cont1000
  %413 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1001, i32 0, i32 0
  %414 = extractvalue { ptr, i64 } %call1003, 0
  store ptr %414, ptr %413, align 8
  %415 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1001, i32 0, i32 1
  %416 = extractvalue { ptr, i64 } %call1003, 1
  store i64 %416, ptr %415, align 8
  %call1005 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1001)
          to label %invoke.cont1004 unwind label %lpad680

invoke.cont1004:                                  ; preds = %invoke.cont1002
  %conv1006 = zext i1 %call1005 to i32
  %cmp1007 = icmp eq i32 %conv1006, 0
  br i1 %cmp1007, label %land.rhs1008, label %land.end1016

land.rhs1008:                                     ; preds = %invoke.cont1004
  %call1011 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 11)
          to label %invoke.cont1010 unwind label %lpad680

invoke.cont1010:                                  ; preds = %land.rhs1008
  %417 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1009, i32 0, i32 0
  %418 = extractvalue { ptr, i64 } %call1011, 0
  store ptr %418, ptr %417, align 8
  %419 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1009, i32 0, i32 1
  %420 = extractvalue { ptr, i64 } %call1011, 1
  store i64 %420, ptr %419, align 8
  %call1013 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1009)
          to label %invoke.cont1012 unwind label %lpad680

invoke.cont1012:                                  ; preds = %invoke.cont1010
  %conv1014 = zext i1 %call1013 to i32
  %cmp1015 = icmp eq i32 %conv1014, 0
  br label %land.end1016

land.end1016:                                     ; preds = %invoke.cont1012, %invoke.cont1004
  %421 = phi i1 [ false, %invoke.cont1004 ], [ %cmp1015, %invoke.cont1012 ]
  %call1018 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %421, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 418, ptr noundef @.str.70)
          to label %invoke.cont1017 unwind label %lpad680

invoke.cont1017:                                  ; preds = %land.end1016
  %call1021 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
          to label %invoke.cont1020 unwind label %lpad680

invoke.cont1020:                                  ; preds = %invoke.cont1017
  %422 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1019, i32 0, i32 0
  %423 = extractvalue { ptr, i64 } %call1021, 0
  store ptr %423, ptr %422, align 8
  %424 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1019, i32 0, i32 1
  %425 = extractvalue { ptr, i64 } %call1021, 1
  store i64 %425, ptr %424, align 8
  %call1023 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1019)
          to label %invoke.cont1022 unwind label %lpad680

invoke.cont1022:                                  ; preds = %invoke.cont1020
  %conv1024 = zext i1 %call1023 to i32
  %cmp1025 = icmp eq i32 %conv1024, 1
  %call1027 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp1025, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 420, ptr noundef @.str.47)
          to label %invoke.cont1026 unwind label %lpad680

invoke.cont1026:                                  ; preds = %invoke.cont1022
  %call1030 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %coerce.dive1031 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp1029, i32 0, i32 0
  %coerce.dive1032 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive1031, i32 0, i32 0
  %426 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1032, i32 0, i32 0
  %427 = extractvalue { ptr, i64 } %call1030, 0
  store ptr %427, ptr %426, align 8
  %428 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1032, i32 0, i32 1
  %429 = extractvalue { ptr, i64 } %call1030, 1
  store i64 %429, ptr %428, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp1028, ptr align 8 %ref.tmp1029, i64 16, i1 false)
  %430 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp1028, i32 0, i32 0
  %431 = load ptr, ptr %430, align 8
  %432 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp1028, i32 0, i32 1
  %433 = load i64, ptr %432, align 8
  %call1034 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6insertENS_24bitvector_const_iteratorImEEb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr %431, i64 %433, i1 noundef zeroext false)
          to label %invoke.cont1033 unwind label %lpad680

invoke.cont1033:                                  ; preds = %invoke.cont1026
  %coerce.dive1036 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %coerce1035, i32 0, i32 0
  %coerce.dive1037 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive1036, i32 0, i32 0
  %434 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1037, i32 0, i32 0
  %435 = extractvalue { ptr, i64 } %call1034, 0
  store ptr %435, ptr %434, align 8
  %436 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1037, i32 0, i32 1
  %437 = extractvalue { ptr, i64 } %call1034, 1
  store i64 %437, ptr %436, align 8
  %call1040 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
          to label %invoke.cont1039 unwind label %lpad680

invoke.cont1039:                                  ; preds = %invoke.cont1033
  %438 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1038, i32 0, i32 0
  %439 = extractvalue { ptr, i64 } %call1040, 0
  store ptr %439, ptr %438, align 8
  %440 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1038, i32 0, i32 1
  %441 = extractvalue { ptr, i64 } %call1040, 1
  store i64 %441, ptr %440, align 8
  %call1042 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1038)
          to label %invoke.cont1041 unwind label %lpad680

invoke.cont1041:                                  ; preds = %invoke.cont1039
  %conv1043 = zext i1 %call1042 to i32
  %cmp1044 = icmp eq i32 %conv1043, 0
  %call1046 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp1044, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 422, ptr noundef @.str.71)
          to label %invoke.cont1045 unwind label %lpad680

invoke.cont1045:                                  ; preds = %invoke.cont1041
  %call1049 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 10)
          to label %invoke.cont1048 unwind label %lpad680

invoke.cont1048:                                  ; preds = %invoke.cont1045
  %442 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1047, i32 0, i32 0
  %443 = extractvalue { ptr, i64 } %call1049, 0
  store ptr %443, ptr %442, align 8
  %444 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1047, i32 0, i32 1
  %445 = extractvalue { ptr, i64 } %call1049, 1
  store i64 %445, ptr %444, align 8
  %call1051 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1047)
          to label %invoke.cont1050 unwind label %lpad680

invoke.cont1050:                                  ; preds = %invoke.cont1048
  %conv1052 = zext i1 %call1051 to i32
  %cmp1053 = icmp eq i32 %conv1052, 0
  br i1 %cmp1053, label %land.rhs1054, label %land.end1062

land.rhs1054:                                     ; preds = %invoke.cont1050
  %call1057 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 11)
          to label %invoke.cont1056 unwind label %lpad680

invoke.cont1056:                                  ; preds = %land.rhs1054
  %446 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1055, i32 0, i32 0
  %447 = extractvalue { ptr, i64 } %call1057, 0
  store ptr %447, ptr %446, align 8
  %448 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1055, i32 0, i32 1
  %449 = extractvalue { ptr, i64 } %call1057, 1
  store i64 %449, ptr %448, align 8
  %call1059 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1055)
          to label %invoke.cont1058 unwind label %lpad680

invoke.cont1058:                                  ; preds = %invoke.cont1056
  %conv1060 = zext i1 %call1059 to i32
  %cmp1061 = icmp eq i32 %conv1060, 0
  br label %land.end1062

land.end1062:                                     ; preds = %invoke.cont1058, %invoke.cont1050
  %450 = phi i1 [ false, %invoke.cont1050 ], [ %cmp1061, %invoke.cont1058 ]
  %call1064 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %450, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 428, ptr noundef @.str.72)
          to label %invoke.cont1063 unwind label %lpad680

invoke.cont1063:                                  ; preds = %land.end1062
  %call1068 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %coerce.dive1069 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp1067, i32 0, i32 0
  %coerce.dive1070 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive1069, i32 0, i32 0
  %451 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1070, i32 0, i32 0
  %452 = extractvalue { ptr, i64 } %call1068, 0
  store ptr %452, ptr %451, align 8
  %453 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1070, i32 0, i32 1
  %454 = extractvalue { ptr, i64 } %call1068, 1
  store i64 %454, ptr %453, align 8
  %call1072 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1067, i64 noundef 11)
          to label %invoke.cont1071 unwind label %lpad680

invoke.cont1071:                                  ; preds = %invoke.cont1063
  %coerce.dive1073 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp1066, i32 0, i32 0
  %coerce.dive1074 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive1073, i32 0, i32 0
  %455 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1074, i32 0, i32 0
  %456 = extractvalue { ptr, i64 } %call1072, 0
  store ptr %456, ptr %455, align 8
  %457 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1074, i32 0, i32 1
  %458 = extractvalue { ptr, i64 } %call1072, 1
  store i64 %458, ptr %457, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp1065, ptr align 8 %ref.tmp1066, i64 16, i1 false)
  %459 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp1065, i32 0, i32 0
  %460 = load ptr, ptr %459, align 8
  %461 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp1065, i32 0, i32 1
  %462 = load i64, ptr %461, align 8
  %call1076 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEE(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr %460, i64 %462)
          to label %invoke.cont1075 unwind label %lpad680

invoke.cont1075:                                  ; preds = %invoke.cont1071
  %coerce.dive1078 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %coerce1077, i32 0, i32 0
  %coerce.dive1079 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive1078, i32 0, i32 0
  %463 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1079, i32 0, i32 0
  %464 = extractvalue { ptr, i64 } %call1076, 0
  store ptr %464, ptr %463, align 8
  %465 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1079, i32 0, i32 1
  %466 = extractvalue { ptr, i64 } %call1076, 1
  store i64 %466, ptr %465, align 8
  %call1082 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 10)
          to label %invoke.cont1081 unwind label %lpad680

invoke.cont1081:                                  ; preds = %invoke.cont1075
  %467 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1080, i32 0, i32 0
  %468 = extractvalue { ptr, i64 } %call1082, 0
  store ptr %468, ptr %467, align 8
  %469 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1080, i32 0, i32 1
  %470 = extractvalue { ptr, i64 } %call1082, 1
  store i64 %470, ptr %469, align 8
  %call1084 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1080)
          to label %invoke.cont1083 unwind label %lpad680

invoke.cont1083:                                  ; preds = %invoke.cont1081
  %conv1085 = zext i1 %call1084 to i32
  %cmp1086 = icmp eq i32 %conv1085, 0
  br i1 %cmp1086, label %land.rhs1087, label %land.end1095

land.rhs1087:                                     ; preds = %invoke.cont1083
  %call1090 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 11)
          to label %invoke.cont1089 unwind label %lpad680

invoke.cont1089:                                  ; preds = %land.rhs1087
  %471 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1088, i32 0, i32 0
  %472 = extractvalue { ptr, i64 } %call1090, 0
  store ptr %472, ptr %471, align 8
  %473 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1088, i32 0, i32 1
  %474 = extractvalue { ptr, i64 } %call1090, 1
  store i64 %474, ptr %473, align 8
  %call1092 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1088)
          to label %invoke.cont1091 unwind label %lpad680

invoke.cont1091:                                  ; preds = %invoke.cont1089
  %conv1093 = zext i1 %call1092 to i32
  %cmp1094 = icmp eq i32 %conv1093, 1
  br label %land.end1095

land.end1095:                                     ; preds = %invoke.cont1091, %invoke.cont1083
  %475 = phi i1 [ false, %invoke.cont1083 ], [ %cmp1094, %invoke.cont1091 ]
  %call1097 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %475, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 430, ptr noundef @.str.73)
          to label %invoke.cont1096 unwind label %lpad680

invoke.cont1096:                                  ; preds = %land.end1095
  %call1100 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 5)
          to label %invoke.cont1099 unwind label %lpad680

invoke.cont1099:                                  ; preds = %invoke.cont1096
  %476 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1098, i32 0, i32 0
  %477 = extractvalue { ptr, i64 } %call1100, 0
  store ptr %477, ptr %476, align 8
  %478 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1098, i32 0, i32 1
  %479 = extractvalue { ptr, i64 } %call1100, 1
  store i64 %479, ptr %478, align 8
  %call1102 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1098)
          to label %invoke.cont1101 unwind label %lpad680

invoke.cont1101:                                  ; preds = %invoke.cont1099
  %conv1103 = zext i1 %call1102 to i32
  %cmp1104 = icmp eq i32 %conv1103, 0
  %call1106 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp1104, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 432, ptr noundef @.str.68)
          to label %invoke.cont1105 unwind label %lpad680

invoke.cont1105:                                  ; preds = %invoke.cont1101
  %call1109 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 6)
          to label %invoke.cont1108 unwind label %lpad680

invoke.cont1108:                                  ; preds = %invoke.cont1105
  %480 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1107, i32 0, i32 0
  %481 = extractvalue { ptr, i64 } %call1109, 0
  store ptr %481, ptr %480, align 8
  %482 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1107, i32 0, i32 1
  %483 = extractvalue { ptr, i64 } %call1109, 1
  store i64 %483, ptr %482, align 8
  %call1111 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1107)
          to label %invoke.cont1110 unwind label %lpad680

invoke.cont1110:                                  ; preds = %invoke.cont1108
  %frombool1112 = zext i1 %call1111 to i8
  store i8 %frombool1112, ptr %bv06, align 1
  %call1116 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %coerce.dive1117 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp1115, i32 0, i32 0
  %coerce.dive1118 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive1117, i32 0, i32 0
  %484 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1118, i32 0, i32 0
  %485 = extractvalue { ptr, i64 } %call1116, 0
  store ptr %485, ptr %484, align 8
  %486 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1118, i32 0, i32 1
  %487 = extractvalue { ptr, i64 } %call1116, 1
  store i64 %487, ptr %486, align 8
  %call1120 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1115, i64 noundef 5)
          to label %invoke.cont1119 unwind label %lpad680

invoke.cont1119:                                  ; preds = %invoke.cont1110
  %coerce.dive1121 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp1114, i32 0, i32 0
  %coerce.dive1122 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive1121, i32 0, i32 0
  %488 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1122, i32 0, i32 0
  %489 = extractvalue { ptr, i64 } %call1120, 0
  store ptr %489, ptr %488, align 8
  %490 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1122, i32 0, i32 1
  %491 = extractvalue { ptr, i64 } %call1120, 1
  store i64 %491, ptr %490, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp1113, ptr align 8 %ref.tmp1114, i64 16, i1 false)
  %call1126 = call { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %coerce.dive1127 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp1125, i32 0, i32 0
  %coerce.dive1128 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive1127, i32 0, i32 0
  %492 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1128, i32 0, i32 0
  %493 = extractvalue { ptr, i64 } %call1126, 0
  store ptr %493, ptr %492, align 8
  %494 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1128, i32 0, i32 1
  %495 = extractvalue { ptr, i64 } %call1126, 1
  store i64 %495, ptr %494, align 8
  %call1130 = invoke { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEplEl(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1125, i64 noundef 6)
          to label %invoke.cont1129 unwind label %lpad680

invoke.cont1129:                                  ; preds = %invoke.cont1119
  %coerce.dive1131 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp1124, i32 0, i32 0
  %coerce.dive1132 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive1131, i32 0, i32 0
  %496 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1132, i32 0, i32 0
  %497 = extractvalue { ptr, i64 } %call1130, 0
  store ptr %497, ptr %496, align 8
  %498 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1132, i32 0, i32 1
  %499 = extractvalue { ptr, i64 } %call1130, 1
  store i64 %499, ptr %498, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp1123, ptr align 8 %ref.tmp1124, i64 16, i1 false)
  %500 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp1113, i32 0, i32 0
  %501 = load ptr, ptr %500, align 8
  %502 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp1113, i32 0, i32 1
  %503 = load i64, ptr %502, align 8
  %504 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp1123, i32 0, i32 0
  %505 = load ptr, ptr %504, align 8
  %506 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp1123, i32 0, i32 1
  %507 = load i64, ptr %506, align 8
  %call1134 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_24bitvector_const_iteratorImEES6_(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr %501, i64 %503, ptr %505, i64 %507)
          to label %invoke.cont1133 unwind label %lpad680

invoke.cont1133:                                  ; preds = %invoke.cont1129
  %coerce.dive1136 = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %coerce1135, i32 0, i32 0
  %coerce.dive1137 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive1136, i32 0, i32 0
  %508 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1137, i32 0, i32 0
  %509 = extractvalue { ptr, i64 } %call1134, 0
  store ptr %509, ptr %508, align 8
  %510 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive1137, i32 0, i32 1
  %511 = extractvalue { ptr, i64 } %call1134, 1
  store i64 %511, ptr %510, align 8
  %call1140 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEEixEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 5)
          to label %invoke.cont1139 unwind label %lpad680

invoke.cont1139:                                  ; preds = %invoke.cont1133
  %512 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1138, i32 0, i32 0
  %513 = extractvalue { ptr, i64 } %call1140, 0
  store ptr %513, ptr %512, align 8
  %514 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1138, i32 0, i32 1
  %515 = extractvalue { ptr, i64 } %call1140, 1
  store i64 %515, ptr %514, align 8
  %call1142 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1138)
          to label %invoke.cont1141 unwind label %lpad680

invoke.cont1141:                                  ; preds = %invoke.cont1139
  %conv1143 = zext i1 %call1142 to i32
  %516 = load i8, ptr %bv06, align 1
  %tobool1144 = trunc i8 %516 to i1
  %conv1145 = zext i1 %tobool1144 to i32
  %cmp1146 = icmp eq i32 %conv1143, %conv1145
  %call1148 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp1146, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 435, ptr noundef @.str.74)
          to label %invoke.cont1147 unwind label %lpad680

invoke.cont1147:                                  ; preds = %invoke.cont1141
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 10, i1 noundef zeroext true)
          to label %invoke.cont1149 unwind label %lpad680

invoke.cont1149:                                  ; preds = %invoke.cont1147
  %call1152 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
          to label %invoke.cont1151 unwind label %lpad680

invoke.cont1151:                                  ; preds = %invoke.cont1149
  %517 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1150, i32 0, i32 0
  %518 = extractvalue { ptr, i64 } %call1152, 0
  store ptr %518, ptr %517, align 8
  %519 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1150, i32 0, i32 1
  %520 = extractvalue { ptr, i64 } %call1152, 1
  store i64 %520, ptr %519, align 8
  %call1154 = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1150, i1 noundef zeroext false)
          to label %invoke.cont1153 unwind label %lpad680

invoke.cont1153:                                  ; preds = %invoke.cont1151
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6rbeginEv(ptr sret(%"class.eastl::reverse_iterator") align 8 %ref.tmp1156, ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2INS_18bitvector_iteratorImEEEERKNS0_IT_EE(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp1155, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1156)
          to label %invoke.cont1157 unwind label %lpad680

invoke.cont1157:                                  ; preds = %invoke.cont1153
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEE(ptr sret(%"class.eastl::reverse_iterator") align 8 %tmp1158, ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr noundef %agg.tmp1155)
          to label %invoke.cont1159 unwind label %lpad680

invoke.cont1159:                                  ; preds = %invoke.cont1157
  %call1160 = call noundef i64 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp1161 = icmp eq i64 %call1160, 9
  br i1 %cmp1161, label %land.rhs1162, label %land.end1170

land.rhs1162:                                     ; preds = %invoke.cont1159
  %call1165 = invoke { ptr, i64 } @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4backEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
          to label %invoke.cont1164 unwind label %lpad680

invoke.cont1164:                                  ; preds = %land.rhs1162
  %521 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1163, i32 0, i32 0
  %522 = extractvalue { ptr, i64 } %call1165, 0
  store ptr %522, ptr %521, align 8
  %523 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp1163, i32 0, i32 1
  %524 = extractvalue { ptr, i64 } %call1165, 1
  store i64 %524, ptr %523, align 8
  %call1167 = invoke noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1163)
          to label %invoke.cont1166 unwind label %lpad680

invoke.cont1166:                                  ; preds = %invoke.cont1164
  %conv1168 = zext i1 %call1167 to i32
  %cmp1169 = icmp eq i32 %conv1168, 1
  br label %land.end1170

land.end1170:                                     ; preds = %invoke.cont1166, %invoke.cont1159
  %525 = phi i1 [ false, %invoke.cont1159 ], [ %cmp1169, %invoke.cont1166 ]
  %call1172 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %525, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 445, ptr noundef @.str.75)
          to label %invoke.cont1171 unwind label %lpad680

invoke.cont1171:                                  ; preds = %land.end1170
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6rbeginEv(ptr sret(%"class.eastl::reverse_iterator") align 8 %ref.tmp1174, ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2INS_18bitvector_iteratorImEEEERKNS0_IT_EE(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp1173, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1174)
          to label %invoke.cont1175 unwind label %lpad680

invoke.cont1175:                                  ; preds = %invoke.cont1171
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4rendEv(ptr sret(%"class.eastl::reverse_iterator") align 8 %ref.tmp1177, ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  invoke void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2INS_18bitvector_iteratorImEEEERKNS0_IT_EE(ptr noundef nonnull align 8 dereferenceable(16) %agg.tmp1176, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1177)
          to label %invoke.cont1178 unwind label %lpad680

invoke.cont1178:                                  ; preds = %invoke.cont1175
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5eraseENS_16reverse_iteratorINS_24bitvector_const_iteratorImEEEES8_(ptr sret(%"class.eastl::reverse_iterator") align 8 %tmp1179, ptr noundef nonnull align 8 dereferenceable(48) %bv0678, ptr noundef %agg.tmp1173, ptr noundef %agg.tmp1176)
          to label %invoke.cont1180 unwind label %lpad680

invoke.cont1180:                                  ; preds = %invoke.cont1178
  %call1181 = call noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5emptyEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %call1183 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call1181, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 448, ptr noundef @.str.5)
          to label %invoke.cont1182 unwind label %lpad680

invoke.cont1182:                                  ; preds = %invoke.cont1180
  %call1184 = call noundef ptr @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp1185 = icmp ne ptr %call1184, null
  %call1187 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp1185, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 463, ptr noundef @.str.76)
          to label %invoke.cont1186 unwind label %lpad680

invoke.cont1186:                                  ; preds = %invoke.cont1182
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 0)
          to label %invoke.cont1188 unwind label %lpad680

invoke.cont1188:                                  ; preds = %invoke.cont1186
  %call1189 = call noundef ptr @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE4dataEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %cmp1190 = icmp eq ptr %call1189, null
  %call1192 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %cmp1190, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 465, ptr noundef @.str.77)
          to label %invoke.cont1191 unwind label %lpad680

invoke.cont1191:                                  ; preds = %invoke.cont1188
  invoke void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6resizeEmb(ptr noundef nonnull align 8 dereferenceable(48) %bv0678, i64 noundef 100, i1 noundef zeroext true)
          to label %invoke.cont1193 unwind label %lpad680

invoke.cont1193:                                  ; preds = %invoke.cont1191
  %526 = load ptr, ptr @_ZN15MallocAllocator16mpLastAllocationE, align 8
  store ptr %526, ptr %pSaved, align 8
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE17reset_lose_memoryEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
  %call1194 = call noundef zeroext i1 @_ZNK5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE8validateEv(ptr noundef nonnull align 8 dereferenceable(48) %bv0678)
  %call1196 = invoke noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext %call1194, ptr noundef nonnull align 4 dereferenceable(4) %nErrorCount, ptr noundef @.str.1, i32 noundef 473, ptr noundef @.str.4)
          to label %invoke.cont1195 unwind label %lpad680

invoke.cont1195:                                  ; preds = %invoke.cont1193
  %527 = load ptr, ptr %pSaved, align 8
  call void @free(ptr noundef %527) #9
  store ptr null, ptr @_ZN15MallocAllocator16mpLastAllocationE, align 8
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(48) %bv0678) #9
  %528 = load i32, ptr %nErrorCount, align 4
  ret i32 %528

eh.resume:                                        ; preds = %lpad680, %lpad446, %ehcleanup440, %ehcleanup373, %ehcleanup13
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val1198 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val1198
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %0) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEEC2ENS2_11CtorSprintfEPKcz(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %pFormat, ...) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %pFormat.addr = alloca ptr, align 8
  %n = alloca i64, align 8
  %arguments = alloca [1 x %struct.__va_list_tag], align 16
  store ptr %this, ptr %this.addr, align 8
  store ptr %pFormat, ptr %pFormat.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mPair = getelementptr inbounds %"class.eastl::basic_string", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_EC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mPair)
  %0 = load ptr, ptr %pFormat.addr, align 8
  %call = call noundef i64 @_ZN5eastl10CharStrlenIcEEmPKT_(ptr noundef %0)
  store i64 %call, ptr %n, align 8
  %1 = load i64, ptr %n, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE12AllocateSelfEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %1)
  %call2 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout7SetSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %call2, i64 noundef 0) #9
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %arguments, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %2 = load ptr, ptr %pFormat.addr, align 8
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %arguments, i64 0, i64 0
  %call4 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE22append_sprintf_va_listEPKcP13__va_list_tag(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %2, ptr noundef %arraydecay3)
  %arraydecay5 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %arguments, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay5)
  ret void
}

declare noundef i32 @_ZN2EA8UnitTest12TestInternal17EATEST_VERIFY_IMPEbRiPKciS4_(i1 noundef zeroext, ptr noundef nonnull align 4 dereferenceable(4), ptr noundef, i32 noundef, ptr noundef) #4

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call2 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  ret i64 %call2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE14DeallocateSelfEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  ret void

terminate.lpad:                                   ; preds = %entry
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(32) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN15MallocAllocatorC2EPKc(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef %0) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mAllocCount = getelementptr inbounds %class.MallocAllocator, ptr %this1, i32 0, i32 0
  store i32 0, ptr %mAllocCount, align 8
  %mFreeCount = getelementptr inbounds %class.MallocAllocator, ptr %this1, i32 0, i32 1
  store i32 0, ptr %mFreeCount, align 4
  %mAllocVolume = getelementptr inbounds %class.MallocAllocator, ptr %this1, i32 0, i32 2
  store i64 0, ptr %mAllocVolume, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2ERKS4_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %0) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %.addr, align 8
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector", ptr %1, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 8 dereferenceable(24) %mContainer2)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %.addr, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mFreeBitCount3, align 8
  store i64 %3, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2IPbEET_S7_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %first, ptr noundef %last) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6assignIPbEEvT_S7_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  ret void

lpad:                                             ; preds = %entry
  %2 = landingpad { ptr, i32 }
          cleanup
  %3 = extractvalue { ptr, i32 } %2, 0
  store ptr %3, ptr %exn.slot, align 8
  %4 = extractvalue { ptr, i32 } %2, 1
  store i32 %4, ptr %ehselector.slot, align 4
  call void @_ZN5eastl6vectorImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val2 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2INS_18bitvector_iteratorImEEEET_S8_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %first.coerce0, i64 %first.coerce1, ptr %last.coerce0, i64 %last.coerce1) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %first = alloca %"class.eastl::bitvector_iterator", align 8
  %last = alloca %"class.eastl::bitvector_iterator", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::bitvector_iterator", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %0 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 0
  store ptr %first.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 1
  store i64 %first.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 0
  store ptr %last.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 1
  store i64 %last.coerce1, ptr %3, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mContainer)
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 0, ptr %mFreeBitCount, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 16, i1 false)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp2, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  invoke void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6assignINS_18bitvector_iteratorImEEEEvT_S8_(ptr noundef nonnull align 8 dereferenceable(32) %this1, ptr %5, i64 %7, ptr %9, i64 %11)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  ret void

lpad:                                             ; preds = %entry
  %12 = landingpad { ptr, i32 }
          cleanup
  %13 = extractvalue { ptr, i32 } %12, 0
  store ptr %13, ptr %exn.slot, align 8
  %14 = extractvalue { ptr, i32 } %12, 1
  store i32 %14, ptr %ehselector.slot, align 4
  call void @_ZN5eastl6vectorImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mContainer) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val3 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastleqINS_9allocatorEmNS_6vectorImS1_EEEEbRKNS_9bitvectorIT_T0_T1_EESA_(ptr noundef nonnull align 8 dereferenceable(32) %a, ptr noundef nonnull align 8 dereferenceable(32) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %agg.tmp6 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %0) #9
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef i64 @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(32) %1) #9
  %cmp = icmp eq i64 %call, %call1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load ptr, ptr %a.addr, align 8
  %call2 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %2) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp, i32 0, i32 0
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %4 = extractvalue { ptr, i64 } %call2, 0
  store ptr %4, ptr %3, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %6 = extractvalue { ptr, i64 } %call2, 1
  store i64 %6, ptr %5, align 8
  %7 = load ptr, ptr %a.addr, align 8
  %call4 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE3endEv(ptr noundef nonnull align 8 dereferenceable(32) %7) #9
  %coerce.dive5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp3, i32 0, i32 0
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 0
  %9 = extractvalue { ptr, i64 } %call4, 0
  store ptr %9, ptr %8, align 8
  %10 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive5, i32 0, i32 1
  %11 = extractvalue { ptr, i64 } %call4, 1
  store i64 %11, ptr %10, align 8
  %12 = load ptr, ptr %b.addr, align 8
  %call7 = call { ptr, i64 } @_ZNK5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5beginEv(ptr noundef nonnull align 8 dereferenceable(32) %12) #9
  %coerce.dive8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %agg.tmp6, i32 0, i32 0
  %13 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 0
  %14 = extractvalue { ptr, i64 } %call7, 0
  store ptr %14, ptr %13, align 8
  %15 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive8, i32 0, i32 1
  %16 = extractvalue { ptr, i64 } %call7, 1
  store i64 %16, ptr %15, align 8
  %17 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 0
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp, i32 0, i32 1
  %20 = load i64, ptr %19, align 8
  %21 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 0
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp3, i32 0, i32 1
  %24 = load i64, ptr %23, align 8
  %25 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr inbounds { ptr, i64 }, ptr %agg.tmp6, i32 0, i32 1
  %28 = load i64, ptr %27, align 8
  %call9 = call noundef zeroext i1 @_ZN5eastl5equalINS_24bitvector_const_iteratorImEES2_EEbT_S3_T0_(ptr %18, i64 %20, ptr %22, i64 %24, ptr %26, i64 %28)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %29 = phi i1 [ false, %entry ], [ %call9, %land.rhs ]
  ret i1 %29
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(32) ptr @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEaSERKS4_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %0) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %.addr, align 8
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector", ptr %1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl6vectorImNS_9allocatorEEaSERKS2_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 8 dereferenceable(24) %mContainer2)
  %2 = load ptr, ptr %.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 %3, ptr %mFreeBitCount3, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6assignINS_18bitvector_iteratorImEEEEvT_S8_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr %first.coerce0, i64 %first.coerce1, ptr %last.coerce0, i64 %last.coerce1) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::bitvector_iterator", align 8
  %last = alloca %"class.eastl::bitvector_iterator", align 8
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_reference", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 0
  store ptr %first.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %first, i32 0, i32 1
  store i64 %first.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 0
  store ptr %last.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %last, i32 0, i32 1
  store i64 %last.coerce1, ptr %3, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %first, ptr noundef nonnull align 8 dereferenceable(16) %last)
  br i1 %call, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call2 = call { ptr, i64 } @_ZNK5eastl18bitvector_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  %4 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 0
  %5 = extractvalue { ptr, i64 } %call2, 0
  store ptr %5, ptr %4, align 8
  %6 = getelementptr inbounds { ptr, i64 }, ptr %ref.tmp, i32 0, i32 1
  %7 = extractvalue { ptr, i64 } %call2, 1
  store i64 %7, ptr %6, align 8
  %call3 = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this1, i1 noundef zeroext %call3)
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %first)
  br label %while.cond, !llvm.loop !50

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE6assignIPbEEvT_S7_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(32) %this1)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %cmp = icmp ne ptr %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %first.addr, align 8
  %3 = load i8, ptr %2, align 1
  %tobool = trunc i8 %3 to i1
  call void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(32) %this1, i1 noundef zeroext %tobool)
  %4 = load ptr, ptr %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %4, i32 1
  store ptr %incdec.ptr, ptr %first.addr, align 8
  br label %while.cond, !llvm.loop !51

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEED2Ev(ptr noundef nonnull align 8 dereferenceable(48) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector.1", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl6vectorIm15MallocAllocatorED2Ev(ptr noundef nonnull align 8 dereferenceable(40) %mContainer) #9
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEC2EOS4_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %0) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %.addr, align 8
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector", ptr %1, i32 0, i32 0
  call void @_ZN5eastl6vectorImNS_9allocatorEEC2EOS2_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 8 dereferenceable(24) %mContainer2) #9
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %.addr, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mFreeBitCount3, align 8
  store i64 %3, ptr %mFreeBitCount, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(32) ptr @_ZN5eastl9bitvectorINS_9allocatorEmNS_6vectorImS1_EEEaSEOS4_(ptr noundef nonnull align 8 dereferenceable(32) %this, ptr noundef nonnull align 8 dereferenceable(32) %0) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mContainer = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %.addr, align 8
  %mContainer2 = getelementptr inbounds %"class.eastl::bitvector", ptr %1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl6vectorImNS_9allocatorEEaSEOS2_(ptr noundef nonnull align 8 dereferenceable(24) %mContainer, ptr noundef nonnull align 8 dereferenceable(24) %mContainer2)
  %2 = load ptr, ptr %.addr, align 8
  %mFreeBitCount = getelementptr inbounds %"class.eastl::bitvector", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mFreeBitCount, align 8
  %mFreeBitCount3 = getelementptr inbounds %"class.eastl::bitvector", ptr %this1, i32 0, i32 1
  store i64 %3, ptr %mFreeBitCount3, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorImEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl19bitvector_referenceImEC2EPmm(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef null, i64 noundef 0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %0, i32 0, i32 0
  call void @_ZN5eastl19bitvector_referenceImE8CopyFromERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef nonnull align 8 dereferenceable(16) %mReference2)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mnBitIndex, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex3 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference2, i32 0, i32 1
  %1 = load i64, ptr %mnBitIndex3, align 8
  %cmp = icmp eq i64 %1, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference4, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpBitWord, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference5, i32 0, i32 1
  store i64 0, ptr %mnBitIndex6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %backwards = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, %0
  store i64 %add, ptr %n.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %cmp = icmp sge i64 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %div = sdiv i64 %3, 64
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference2, i32 0, i32 0
  %4 = load ptr, ptr %mpBitWord, align 8
  %add.ptr = getelementptr inbounds i64, ptr %4, i64 %div
  store ptr %add.ptr, ptr %mpBitWord, align 8
  %5 = load i64, ptr %n.addr, align 8
  %rem = srem i64 %5, 64
  %mReference3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex4 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference3, i32 0, i32 1
  store i64 %rem, ptr %mnBitIndex4, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %6
  %add5 = add nsw i64 %sub, 64
  %sub6 = sub nsw i64 %add5, 1
  store i64 %sub6, ptr %backwards, align 8
  %7 = load i64, ptr %backwards, align 8
  %div7 = udiv i64 %7, 64
  %mReference8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mpBitWord9 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference8, i32 0, i32 0
  %8 = load ptr, ptr %mpBitWord9, align 8
  %idx.neg = sub i64 0, %div7
  %add.ptr10 = getelementptr inbounds i64, ptr %8, i64 %idx.neg
  store ptr %add.ptr10, ptr %mpBitWord9, align 8
  %9 = load i64, ptr %backwards, align 8
  %rem11 = urem i64 %9, 64
  %sub12 = sub i64 63, %rem11
  %mReference13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex14 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference13, i32 0, i32 1
  store i64 %sub12, ptr %mnBitIndex14, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %sub)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.0", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl24bitvector_const_iteratorImEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %mIterator)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEaSERKS3_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %0) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.0", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %.addr, align 8
  %mIterator2 = getelementptr inbounds %"class.eastl::reverse_iterator.0", ptr %1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %mIterator, ptr noundef nonnull align 8 dereferenceable(16) %mIterator2)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastlneINS_24bitvector_const_iteratorImEES2_EEbRKNS_16reverse_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(16) %a, ptr noundef nonnull align 8 dereferenceable(16) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_const_iterator", align 8
  %ref.tmp1 = alloca %"class.eastl::bitvector_const_iterator", align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call, 1
  store i64 %4, ptr %3, align 8
  %5 = load ptr, ptr %b.addr, align 8
  %call2 = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %5)
  %coerce.dive3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %ref.tmp1, i32 0, i32 0
  %6 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 0
  %7 = extractvalue { ptr, i64 } %call2, 0
  store ptr %7, ptr %6, align 8
  %8 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive3, i32 0, i32 1
  %9 = extractvalue { ptr, i64 } %call2, 1
  store i64 %9, ptr %8, align 8
  %call4 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp1)
  ret i1 %call4
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEmmEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.0", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %mIterator)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.0", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %mIterator, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.0", ptr %this1, i32 0, i32 0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %mIterator, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE6assignIPbEEvT_S7_(ptr noundef nonnull align 8 dereferenceable(48) %this, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE5clearEv(ptr noundef nonnull align 8 dereferenceable(48) %this1)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %cmp = icmp ne ptr %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %first.addr, align 8
  %3 = load i8, ptr %2, align 1
  %tobool = trunc i8 %3 to i1
  call void @_ZN5eastl9bitvectorI15MallocAllocatormNS_6vectorImS1_EEE9push_backEb(ptr noundef nonnull align 8 dereferenceable(48) %this1, i1 noundef zeroext %tobool)
  %4 = load ptr, ptr %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %4, i32 1
  store ptr %incdec.ptr, ptr %first.addr, align 8
  br label %while.cond, !llvm.loop !52

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl16reverse_iteratorINS_24bitvector_const_iteratorImEEEC2INS_18bitvector_iteratorImEEEERKNS0_IT_EE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %ri) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ri.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::bitvector_iterator", align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %ri, ptr %ri.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator.0", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %ri.addr, align 8
  %call = call { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_18bitvector_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %ref.tmp, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %1 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 0
  %2 = extractvalue { ptr, i64 } %call, 0
  store ptr %2, ptr %1, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %coerce.dive2, i32 0, i32 1
  %4 = extractvalue { ptr, i64 } %call, 1
  store i64 %4, ptr %3, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mIterator, ptr align 8 %ref.tmp, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl18bitvector_iteratorImEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl24bitvector_const_iteratorImEC2Ev(ptr noundef nonnull align 8 dereferenceable(16) %this1)
  ret void
}

; Function Attrs: nounwind
declare void @free(ptr noundef) #5

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %0, i32 0, i32 0
  call void @_ZN5eastl19bitvector_referenceIhE8CopyFromERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef nonnull align 8 dereferenceable(16) %mReference2)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19bitvector_referenceIhE8CopyFromERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %mpBitWord, align 8
  %mpBitWord2 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %this1, i32 0, i32 0
  store ptr %1, ptr %mpBitWord2, align 8
  %2 = load ptr, ptr %rhs.addr, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %mnBitIndex3 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %this1, i32 0, i32 1
  store i64 %3, ptr %mnBitIndex3, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %0, i32 0, i32 0
  call void @_ZN5eastl19bitvector_referenceIsE8CopyFromERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef nonnull align 8 dereferenceable(16) %mReference2)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19bitvector_referenceIsE8CopyFromERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %mpBitWord, align 8
  %mpBitWord2 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %this1, i32 0, i32 0
  store ptr %1, ptr %mpBitWord2, align 8
  %2 = load ptr, ptr %rhs.addr, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %mnBitIndex3 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %this1, i32 0, i32 1
  store i64 %3, ptr %mnBitIndex3, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %0, i32 0, i32 0
  call void @_ZN5eastl19bitvector_referenceIiE8CopyFromERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef nonnull align 8 dereferenceable(16) %mReference2)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19bitvector_referenceIiE8CopyFromERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %mpBitWord, align 8
  %mpBitWord2 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %this1, i32 0, i32 0
  store ptr %1, ptr %mpBitWord2, align 8
  %2 = load ptr, ptr %rhs.addr, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %mnBitIndex3 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %this1, i32 0, i32 1
  store i64 %3, ptr %mnBitIndex3, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %0, i32 0, i32 0
  call void @_ZN5eastl19bitvector_referenceIlE8CopyFromERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %mReference, ptr noundef nonnull align 8 dereferenceable(16) %mReference2)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19bitvector_referenceIlE8CopyFromERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %mpBitWord, align 8
  %mpBitWord2 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %this1, i32 0, i32 0
  store ptr %1, ptr %mpBitWord2, align 8
  %2 = load ptr, ptr %rhs.addr, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %mnBitIndex3 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %this1, i32 0, i32 1
  store i64 %3, ptr %mnBitIndex3, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %call = call noundef i64 @_ZNK5eastl6vectorImNS_9allocatorEE4sizeEv(ptr noundef nonnull align 8 dereferenceable(24) %0) #9
  %1 = load ptr, ptr %x.addr, align 8
  %call2 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl10VectorBaseImNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %1) #9
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %call, ptr noundef nonnull align 1 dereferenceable(1) %call2)
  %2 = load ptr, ptr %x.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin, align 8
  %4 = load ptr, ptr %x.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin3, align 8
  %call4 = invoke noundef ptr @_ZN5eastl22uninitialized_copy_ptrIPmS1_S1_EET1_T_T0_S2_(ptr noundef %3, ptr noundef %5, ptr noundef %6)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  %mpEnd5 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %call4, ptr %mpEnd5, align 8
  ret void

lpad:                                             ; preds = %entry
  %7 = landingpad { ptr, i32 }
          cleanup
  %8 = extractvalue { ptr, i32 } %7, 0
  store ptr %8, ptr %exn.slot, align 8
  %9 = extractvalue { ptr, i32 } %7, 1
  store i32 %9, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val6 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val6
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl10VectorBaseImNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl15compressed_pairIPmNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseImNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPmNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef nonnull align 1 dereferenceable(1) %0)
  %1 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  store ptr %call, ptr %mpBegin, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin3, align 8
  %4 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 %4
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_copy_ptrIPmS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %result.addr, align 8
  %call = call noundef ptr @_ZN5eastl18uninitialized_copyIPmS1_EET0_T_S3_S2_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %call3, align 8
  %mpBegin4 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin4, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %mul = mul i64 %sub.ptr.div, 8
  invoke void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %4 = landingpad { ptr, i32 }
          catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  call void @__clang_call_terminate(ptr %5) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl15compressed_pairIPmNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl19compressed_pair_impIPmNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl19compressed_pair_impIPmNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPmNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %tobool = icmp ne i64 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %1, 8
  %call3 = call noundef ptr @_ZN5eastl15allocate_memoryINS_9allocatorEEEPvRT_mmm(ptr noundef nonnull align 1 dereferenceable(1) %call, i64 noundef %mul, i64 noundef 8, i64 noundef 0)
  store ptr %call3, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPmNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef nonnull align 1 dereferenceable(1) %0) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %0, ptr %.addr, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15allocate_memoryINS_9allocatorEEEPvRT_mmm(ptr noundef nonnull align 1 dereferenceable(1) %a, i64 noundef %n, i64 noundef %alignment, i64 noundef %alignmentOffset) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %alignmentOffset.addr = alloca i64, align 8
  %result = alloca ptr, align 8
  %resultMinusOffset = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %alignmentOffset, ptr %alignmentOffset.addr, align 8
  %0 = load i64, ptr %alignment.addr, align 8
  %cmp = icmp ule i64 %0, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %a.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl9allocator8allocateEmi(ptr noundef nonnull align 1 dereferenceable(1) %1, i64 noundef %2, i32 noundef 0)
  store ptr %call, ptr %result, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %a.addr, align 8
  %4 = load i64, ptr %n.addr, align 8
  %5 = load i64, ptr %alignment.addr, align 8
  %6 = load i64, ptr %alignmentOffset.addr, align 8
  %call1 = call noundef ptr @_ZN5eastl9allocator8allocateEmmmi(ptr noundef nonnull align 1 dereferenceable(1) %3, i64 noundef %4, i64 noundef %5, i64 noundef %6, i32 noundef 0)
  store ptr %call1, ptr %result, align 8
  %7 = load ptr, ptr %result, align 8
  %8 = load i64, ptr %alignmentOffset.addr, align 8
  %idx.neg = sub i64 0, %8
  %add.ptr = getelementptr inbounds i8, ptr %7, i64 %idx.neg
  store ptr %add.ptr, ptr %resultMinusOffset, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %9 = load ptr, ptr %result, align 8
  ret ptr %9
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairIPmNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl9allocator8allocateEmi(ptr noundef nonnull align 1 dereferenceable(1) %this, i64 noundef %n, i32 noundef %flags) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i32, ptr %flags.addr, align 4
  %call = call noundef ptr @_ZnamPKcijS0_i(i64 noundef %0, ptr noundef null, i32 noundef %1, i32 noundef 0, ptr noundef null, i32 noundef 0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl9allocator8allocateEmmmi(ptr noundef nonnull align 1 dereferenceable(1) %this, i64 noundef %n, i64 noundef %alignment, i64 noundef %offset, i32 noundef %flags) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %alignment.addr, align 8
  %2 = load i64, ptr %offset.addr, align 8
  %3 = load i32, ptr %flags.addr, align 4
  %call = call noundef ptr @_ZnammmPKcijS0_i(i64 noundef %0, i64 noundef %1, i64 noundef %2, ptr noundef null, i32 noundef %3, i32 noundef 0, ptr noundef null, i32 noundef 0)
  ret ptr %call
}

declare noundef ptr @_ZnamPKcijS0_i(i64 noundef, ptr noundef, i32 noundef, i32 noundef, ptr noundef, i32 noundef) #4

declare noundef ptr @_ZnammmPKcijS0_i(i64 noundef, i64 noundef, i64 noundef, ptr noundef, i32 noundef, i32 noundef, ptr noundef, i32 noundef) #4

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairIPmNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPmNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl18uninitialized_copyIPmS1_EET0_T_S3_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %isTriviallyCopyable = alloca i8, align 1
  %isInputIteratorReferenceAddressable = alloca i8, align 1
  %areIteratorsContiguous = alloca i8, align 1
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %isTriviallyCopyable, align 1
  store i8 1, ptr %isInputIteratorReferenceAddressable, align 1
  store i8 1, ptr %areIteratorsContiguous, align 1
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %result.addr, align 8
  %call = call noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb1ELb1EE4implIPmS4_EET0_T_S6_S5_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb1ELb1EE4implIPmS4_EET0_T_S6_S5_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  %count = alloca i64, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %cmp = icmp eq ptr %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  br i1 %lnot1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %dest.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %last.addr, align 8
  %4 = load ptr, ptr %first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  store i64 %sub.ptr.div, ptr %count, align 8
  %5 = load ptr, ptr %dest.addr, align 8
  %call = call noundef ptr @_ZN5eastl9addressofImEEPT_RS1_(ptr noundef nonnull align 8 dereferenceable(8) %5) #9
  %6 = load ptr, ptr %first.addr, align 8
  %call2 = call noundef ptr @_ZN5eastl9addressofImEEPT_RS1_(ptr noundef nonnull align 8 dereferenceable(8) %6) #9
  %7 = load i64, ptr %count, align 8
  %mul = mul i64 8, %7
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %call, ptr align 8 %call2, i64 %mul, i1 false)
  %8 = load ptr, ptr %dest.addr, align 8
  %9 = load i64, ptr %count, align 8
  %add.ptr = getelementptr inbounds i64, ptr %8, i64 %9
  store ptr %add.ptr, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl9addressofImEEPT_RS1_(ptr noundef nonnull align 8 dereferenceable(8) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  ret ptr %0
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr nocapture writeonly, ptr nocapture readonly, i64, i1 immarg) #3

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %this, ptr noundef %p, i64 noundef %0) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %0, ptr %.addr, align 8
  %1 = load ptr, ptr %p.addr, align 8
  %isnull = icmp eq ptr %1, null
  br i1 %isnull, label %delete.end, label %delete.notnull

delete.notnull:                                   ; preds = %entry
  call void @_ZdaPv(ptr noundef %1) #11
  br label %delete.end

delete.end:                                       ; preds = %delete.notnull, %entry
  ret void
}

; Function Attrs: nobuiltin nounwind
declare void @_ZdaPv(ptr noundef) #6

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl6vectorImNS_9allocatorEEaSERKS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %bSlowerPathwayRequired = alloca i8, align 1
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %cmp = icmp ne ptr %this1, %0
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  store i8 0, ptr %bSlowerPathwayRequired, align 1
  %1 = load i8, ptr %bSlowerPathwayRequired, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  call void @_ZN5eastl6vectorImNS_9allocatorEE15DoClearCapacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %2 = load ptr, ptr %x.addr, align 8
  %call = call noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %2) #9
  %3 = load ptr, ptr %x.addr, align 8
  %call3 = call noundef ptr @_ZNK5eastl6vectorImNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %3) #9
  call void @_ZN5eastl6vectorImNS_9allocatorEE8DoAssignIPKmLb0EEEvT_S6_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %call, ptr noundef %call3)
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE15DoClearCapacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %temp = alloca %"class.eastl::vector", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE5clearEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl4moveIRNS_6vectorImNS_9allocatorEEEEEONS_16remove_referenceIT_E4typeEOS6_(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl6vectorImNS_9allocatorEEC2EOS2_(ptr noundef nonnull align 8 dereferenceable(24) %temp, ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  invoke void @_ZN5eastl6vectorImNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %temp)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl6vectorImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  ret void

lpad:                                             ; preds = %entry
  %0 = landingpad { ptr, i32 }
          cleanup
  %1 = extractvalue { ptr, i32 } %0, 0
  store ptr %1, ptr %exn.slot, align 8
  %2 = extractvalue { ptr, i32 } %0, 1
  store i32 %2, ptr %ehselector.slot, align 4
  call void @_ZN5eastl6vectorImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val2 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE8DoAssignIPKmLb0EEEvT_S6_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE20DoAssignFromIteratorIPKmLb0EEEvT_S6_NS_26random_access_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %0, ptr noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl4moveIRNS_6vectorImNS_9allocatorEEEEEONS_16remove_referenceIT_E4typeEOS6_(ptr noundef nonnull align 8 dereferenceable(24) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEEC2EOS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %0) #9
  %call2 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl4moveIRNS_9allocatorEEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 1 dereferenceable(1) %call) #9
  invoke void @_ZN5eastl10VectorBaseImNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 1 dereferenceable(1) %call2)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  %1 = load ptr, ptr %x.addr, align 8
  invoke void @_ZN5eastl6vectorImNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %1)
          to label %invoke.cont3 unwind label %terminate.lpad

invoke.cont3:                                     ; preds = %invoke.cont
  ret void

terminate.lpad:                                   ; preds = %invoke.cont, %entry
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl4moveIRNS_9allocatorEEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 1 dereferenceable(1) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseImNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPmNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %0, i32 0, i32 0
  call void @_ZN5eastl4swapIPmEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpBegin, ptr noundef nonnull align 8 dereferenceable(8) %mpBegin2) #9
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %x.addr, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapIPmEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpEnd, ptr noundef nonnull align 8 dereferenceable(8) %mpEnd3) #9
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 2
  %2 = load ptr, ptr %x.addr, align 8
  %mCapacityAllocator4 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %2, i32 0, i32 2
  call void @_ZN5eastl4swapIPmNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator4)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPmNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %x, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %x, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %x.addr, align 8
  store ptr %1, ptr %mFirst, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPmEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %temp = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPmEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %0) #9
  %1 = load ptr, ptr %call, align 8
  store ptr %1, ptr %temp, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPmEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %2) #9
  %3 = load ptr, ptr %call1, align 8
  %4 = load ptr, ptr %a.addr, align 8
  store ptr %3, ptr %4, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPmEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %temp) #9
  %5 = load ptr, ptr %call2, align 8
  %6 = load ptr, ptr %b.addr, align 8
  store ptr %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPmNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(8) %x, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat {
entry:
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl15compressed_pairIPmNS_9allocatorEE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPmEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPmNS_9allocatorEE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 8 dereferenceable(8) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPmNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %y.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPmNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  call void @_ZN5eastl7cp_swapIPmEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mFirst, ptr noundef nonnull align 8 dereferenceable(8) %call)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl7cp_swapIPmEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %t1, ptr noundef nonnull align 8 dereferenceable(8) %t2) #1 comdat {
entry:
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %tTemp = alloca ptr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  %0 = load ptr, ptr %t1.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %tTemp, align 8
  %2 = load ptr, ptr %t2.addr, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %t1.addr, align 8
  store ptr %3, ptr %4, align 8
  %5 = load ptr, ptr %tTemp, align 8
  %6 = load ptr, ptr %t2.addr, align 8
  store ptr %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE20DoAssignFromIteratorIPKmLb0EEEvT_S6_NS_26random_access_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %n = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  %position = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %call = call noundef i64 @_ZN5eastl8distanceIPKmEENS_15iterator_traitsIT_E15difference_typeES4_S4_(ptr noundef %0, ptr noundef %1)
  store i64 %call, ptr %n, align 8
  %2 = load i64, ptr %n, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %3 = load ptr, ptr %call2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %2, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load i64, ptr %n, align 8
  %6 = load ptr, ptr %first.addr, align 8
  %7 = load ptr, ptr %last.addr, align 8
  %call3 = call noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE9DoReallocIPKmEEPmmT_S7_NS2_23should_move_or_copy_tagILb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5, ptr noundef %6, ptr noundef %7)
  store ptr %call3, ptr %pNewData, align 8
  %mpBegin4 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %8 = load ptr, ptr %mpBegin4, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %9 = load ptr, ptr %mpEnd, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %8, ptr noundef %9)
  %mpBegin5 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin5, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %11 = load ptr, ptr %call6, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %12 = load ptr, ptr %mpBegin7, align 8
  %sub.ptr.lhs.cast8 = ptrtoint ptr %11 to i64
  %sub.ptr.rhs.cast9 = ptrtoint ptr %12 to i64
  %sub.ptr.sub10 = sub i64 %sub.ptr.lhs.cast8, %sub.ptr.rhs.cast9
  %sub.ptr.div11 = sdiv exact i64 %sub.ptr.sub10, 8
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %10, i64 noundef %sub.ptr.div11)
  %13 = load ptr, ptr %pNewData, align 8
  %mpBegin12 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  store ptr %13, ptr %mpBegin12, align 8
  %mpBegin13 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %14 = load ptr, ptr %mpBegin13, align 8
  %15 = load i64, ptr %n, align 8
  %add.ptr = getelementptr inbounds i64, ptr %14, i64 %15
  %mpEnd14 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %add.ptr, ptr %mpEnd14, align 8
  %mpEnd15 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %16 = load ptr, ptr %mpEnd15, align 8
  %call16 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %16, ptr %call16, align 8
  br label %if.end42

if.else:                                          ; preds = %entry
  %17 = load i64, ptr %n, align 8
  %mpEnd17 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %18 = load ptr, ptr %mpEnd17, align 8
  %mpBegin18 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %19 = load ptr, ptr %mpBegin18, align 8
  %sub.ptr.lhs.cast19 = ptrtoint ptr %18 to i64
  %sub.ptr.rhs.cast20 = ptrtoint ptr %19 to i64
  %sub.ptr.sub21 = sub i64 %sub.ptr.lhs.cast19, %sub.ptr.rhs.cast20
  %sub.ptr.div22 = sdiv exact i64 %sub.ptr.sub21, 8
  %cmp23 = icmp ule i64 %17, %sub.ptr.div22
  br i1 %cmp23, label %if.then24, label %if.else29

if.then24:                                        ; preds = %if.else
  %20 = load ptr, ptr %first.addr, align 8
  %21 = load ptr, ptr %last.addr, align 8
  %mpBegin25 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin25, align 8
  %call26 = call noundef ptr @_ZN5eastl4copyIPKmPmEET0_T_S5_S4_(ptr noundef %20, ptr noundef %21, ptr noundef %22)
  store ptr %call26, ptr %pNewEnd, align 8
  %23 = load ptr, ptr %pNewEnd, align 8
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %24 = load ptr, ptr %mpEnd27, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %23, ptr noundef %24)
  %25 = load ptr, ptr %pNewEnd, align 8
  %mpEnd28 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %25, ptr %mpEnd28, align 8
  br label %if.end

if.else29:                                        ; preds = %if.else
  %26 = load ptr, ptr %first.addr, align 8
  %mpEnd30 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %27 = load ptr, ptr %mpEnd30, align 8
  %mpBegin31 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %28 = load ptr, ptr %mpBegin31, align 8
  %sub.ptr.lhs.cast32 = ptrtoint ptr %27 to i64
  %sub.ptr.rhs.cast33 = ptrtoint ptr %28 to i64
  %sub.ptr.sub34 = sub i64 %sub.ptr.lhs.cast32, %sub.ptr.rhs.cast33
  %sub.ptr.div35 = sdiv exact i64 %sub.ptr.sub34, 8
  %add.ptr36 = getelementptr inbounds i64, ptr %26, i64 %sub.ptr.div35
  store ptr %add.ptr36, ptr %position, align 8
  %29 = load ptr, ptr %first.addr, align 8
  %30 = load ptr, ptr %position, align 8
  %mpBegin37 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %31 = load ptr, ptr %mpBegin37, align 8
  %call38 = call noundef ptr @_ZN5eastl4copyIPKmPmEET0_T_S5_S4_(ptr noundef %29, ptr noundef %30, ptr noundef %31)
  %32 = load ptr, ptr %position, align 8
  %33 = load ptr, ptr %last.addr, align 8
  %mpEnd39 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %34 = load ptr, ptr %mpEnd39, align 8
  %call40 = call noundef ptr @_ZN5eastl22uninitialized_copy_ptrIPKmS2_PmEET1_T_T0_S4_(ptr noundef %32, ptr noundef %33, ptr noundef %34)
  %mpEnd41 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %call40, ptr %mpEnd41, align 8
  br label %if.end

if.end:                                           ; preds = %if.else29, %if.then24
  br label %if.end42

if.end42:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl8distanceIPKmEENS_15iterator_traitsIT_E15difference_typeES4_S4_(ptr noundef %first, ptr noundef %last) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %call = call noundef i64 @_ZN5eastl13distance_implIPKmEENS_15iterator_traitsIT_E15difference_typeES4_S4_NS_26random_access_iterator_tagE(ptr noundef %0, ptr noundef %1)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE9DoReallocIPKmEEPmmT_S7_NS2_23should_move_or_copy_tagILb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %p, align 8
  %1 = load ptr, ptr %first.addr, align 8
  %2 = load ptr, ptr %last.addr, align 8
  %3 = load ptr, ptr %p, align 8
  %call2 = call noundef ptr @_ZN5eastl22uninitialized_copy_ptrIPKmS2_PmEET1_T_T0_S4_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %p, align 8
  ret ptr %4
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %first, ptr noundef %last) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  call void @_ZN5eastl13destruct_implIPmEEvT_S2_NS_17integral_constantIbLb1EEE(ptr noundef %0, ptr noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseImNS_9allocatorEE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %p, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %2, 8
  call void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl4copyIPKmPmEET0_T_S5_S4_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %isMove = alloca i8, align 1
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 0, ptr %isMove, align 1
  %0 = load ptr, ptr %first.addr, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorIPKmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS4_EE5valueEE13iterator_typeES4_(ptr noundef %0)
  %1 = load ptr, ptr %last.addr, align 8
  %call1 = call noundef ptr @_ZN5eastl15unwrap_iteratorIPKmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS4_EE5valueEE13iterator_typeES4_(ptr noundef %1)
  %2 = load ptr, ptr %result.addr, align 8
  %call2 = call noundef ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPKmPmEET1_T0_S5_S4_(ptr noundef %call, ptr noundef %call1, ptr noundef %2)
  ret ptr %call2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_copy_ptrIPKmS2_PmEET1_T_T0_S4_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %result.addr, align 8
  %call = call noundef ptr @_ZN5eastl18uninitialized_copyIPKmPmEET0_T_S5_S4_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl13distance_implIPKmEENS_15iterator_traitsIT_E15difference_typeES4_S4_NS_26random_access_iterator_tagE(ptr noundef %first, ptr noundef %last) #1 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %last.addr, align 8
  %1 = load ptr, ptr %first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl13destruct_implIPmEEvT_S2_NS_17integral_constantIbLb1EEE(ptr noundef %0, ptr noundef %1) #1 comdat {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPKmPmEET1_T0_S5_S4_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorIPKmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS4_EE5valueEE13iterator_typeES4_(ptr noundef %0)
  %1 = load ptr, ptr %last.addr, align 8
  %call1 = call noundef ptr @_ZN5eastl15unwrap_iteratorIPKmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS4_EE5valueEE13iterator_typeES4_(ptr noundef %1)
  %2 = load ptr, ptr %result.addr, align 8
  %call2 = call noundef ptr @_ZN5eastl15unwrap_iteratorIPmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %2)
  %call3 = call noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPKmPmEET1_T0_S5_S4_(ptr noundef %call, ptr noundef %call1, ptr noundef %call2)
  ret ptr %call3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorIPKmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS4_EE5valueEE13iterator_typeES4_(ptr noundef %it) #0 comdat {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPKmLb0EE13get_unwrappedES2_(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPKmPmEET1_T0_S5_S4_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %canBeMemmoved = alloca i8, align 1
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %canBeMemmoved, align 1
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %result.addr, align 8
  %call = call noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyImEEPT_PKS4_S7_S5_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorIPmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %it) #0 comdat {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPmLb0EE13get_unwrappedES1_(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyImEEPT_PKS4_S7_S5_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %cmp = icmp eq ptr %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  br i1 %lnot1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %result.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %result.addr, align 8
  %4 = load ptr, ptr %first.addr, align 8
  %5 = load ptr, ptr %last.addr, align 8
  %6 = ptrtoint ptr %5 to i64
  %7 = load ptr, ptr %first.addr, align 8
  %8 = ptrtoint ptr %7 to i64
  %sub = sub i64 %6, %8
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %3, ptr align 8 %4, i64 %sub, i1 false)
  %9 = load ptr, ptr %last.addr, align 8
  %10 = load ptr, ptr %first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %9 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 %sub.ptr.div
  store ptr %add.ptr, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPmLb0EE13get_unwrappedES1_(ptr noundef %it) #1 comdat align 2 {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPKmLb0EE13get_unwrappedES2_(ptr noundef %it) #1 comdat align 2 {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl18uninitialized_copyIPKmPmEET0_T_S5_S4_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %isTriviallyCopyable = alloca i8, align 1
  %isInputIteratorReferenceAddressable = alloca i8, align 1
  %areIteratorsContiguous = alloca i8, align 1
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %isTriviallyCopyable, align 1
  store i8 1, ptr %isInputIteratorReferenceAddressable, align 1
  store i8 1, ptr %areIteratorsContiguous, align 1
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %result.addr, align 8
  %call = call noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb1ELb1EE4implIPKmPmEET0_T_S8_S7_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb1ELb1EE4implIPKmPmEET0_T_S8_S7_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  %count = alloca i64, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %cmp = icmp eq ptr %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  br i1 %lnot1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %dest.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %last.addr, align 8
  %4 = load ptr, ptr %first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  store i64 %sub.ptr.div, ptr %count, align 8
  %5 = load ptr, ptr %dest.addr, align 8
  %call = call noundef ptr @_ZN5eastl9addressofImEEPT_RS1_(ptr noundef nonnull align 8 dereferenceable(8) %5) #9
  %6 = load ptr, ptr %first.addr, align 8
  %call2 = call noundef ptr @_ZN5eastl9addressofIKmEEPT_RS2_(ptr noundef nonnull align 8 dereferenceable(8) %6) #9
  %7 = load i64, ptr %count, align 8
  %mul = mul i64 8, %7
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %call, ptr align 8 %call2, i64 %mul, i1 false)
  %8 = load ptr, ptr %dest.addr, align 8
  %9 = load i64, ptr %count, align 8
  %add.ptr = getelementptr inbounds i64, ptr %8, i64 %9
  store ptr %add.ptr, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl9addressofIKmEEPT_RS2_(ptr noundef nonnull align 8 dereferenceable(8) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorED2Ev(ptr noundef nonnull align 8 dereferenceable(40) %this) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorED2Ev(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  ret void

terminate.lpad:                                   ; preds = %entry
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIm15MallocAllocatorED2Ev(ptr noundef nonnull align 8 dereferenceable(40) %this) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %2 = load ptr, ptr %call3, align 8
  %mpBegin4 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin4, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %mul = mul i64 %sub.ptr.div, 8
  invoke void @_ZN15MallocAllocator10deallocateEPvm(ptr noundef nonnull align 8 dereferenceable(16) %call, ptr noundef %1, i64 noundef %mul)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %if.then
  br label %if.end

if.end:                                           ; preds = %invoke.cont, %entry
  ret void

terminate.lpad:                                   ; preds = %if.then
  %4 = landingpad { ptr, i32 }
          catch ptr null
  %5 = extractvalue { ptr, i32 } %4, 0
  call void @__clang_call_terminate(ptr %5) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl15compressed_pairIPm15MallocAllocatorE6secondEv(ptr noundef nonnull align 8 dereferenceable(24) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

declare void @_ZN15MallocAllocator10deallocateEPvm(ptr noundef nonnull align 8 dereferenceable(16), ptr noundef, i64 noundef) #4

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPm15MallocAllocatorE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl15compressed_pairIPm15MallocAllocatorE6secondEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE6secondEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE6secondEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mSecond = getelementptr inbounds %"class.eastl::compressed_pair_imp.5", ptr %this1, i32 0, i32 1
  ret ptr %mSecond
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPm15MallocAllocatorE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.5", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl6vectorImNS_9allocatorEEaSEOS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %cmp = icmp ne ptr %this1, %0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @_ZN5eastl6vectorImNS_9allocatorEE15DoClearCapacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %1 = load ptr, ptr %x.addr, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE4swapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local { ptr, i64 } @_ZNK5eastl16reverse_iteratorINS_18bitvector_iteratorImEEE4baseEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::bitvector_iterator", align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::reverse_iterator", ptr %this1, i32 0, i32 0
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %mIterator, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %"class.eastl::bitvector_iterator", ptr %retval, i32 0, i32 0
  %coerce.dive2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %coerce.dive, i32 0, i32 0
  %0 = load { ptr, i64 }, ptr %coerce.dive2, align 8
  ret { ptr, i64 } %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_EC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl10CharStrlenIcEEmPKT_(ptr noundef %p) #1 comdat {
entry:
  %p.addr = alloca ptr, align 8
  %pCurrent = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %pCurrent, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load ptr, ptr %pCurrent, align 8
  %2 = load i8, ptr %1, align 1
  %tobool = icmp ne i8 %2, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %pCurrent, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %3, i32 1
  store ptr %incdec.ptr, ptr %pCurrent, align 8
  br label %while.cond, !llvm.loop !53

while.end:                                        ; preds = %while.cond
  %4 = load ptr, ptr %pCurrent, align 8
  %5 = load ptr, ptr %p.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %4 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  ret i64 %sub.ptr.sub
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE12AllocateSelfEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pBegin = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %0, 23
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, 1
  %call = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %add)
  store ptr %call, ptr %pBegin, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %pBegin, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout15SetHeapBeginPtrEPc(ptr noundef nonnull align 8 dereferenceable(24) %call2, ptr noundef %2) #9
  %call3 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %3 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout15SetHeapCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %call3, i64 noundef %3) #9
  %call4 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %4 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout11SetHeapSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %call4, i64 noundef %4) #9
  br label %if.end

if.else:                                          ; preds = %entry
  %call5 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %5 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10SetSSOSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %call5, i64 noundef %5) #9
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mPair = getelementptr inbounds %"class.eastl::basic_string", ptr %this1, i32 0, i32 0
  %call = invoke noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_E5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %mPair)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout7SetSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %size) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %0 = load i64, ptr %size.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout11SetHeapSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0) #9
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, ptr %size.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10SetSSOSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %1) #9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #7

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE22append_sprintf_va_listEPKcP13__va_list_tag(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %pFormat, ptr noundef %arguments) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %pFormat.addr = alloca ptr, align 8
  %arguments.addr = alloca ptr, align 8
  %nInitialSize = alloca i64, align 8
  %nInitialRemainingCapacity = alloca i64, align 8
  %nReturnValue = alloca i32, align 4
  %argumentsSaved = alloca [1 x %struct.__va_list_tag], align 16
  %n = alloca i64, align 8
  %nCapacity = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %pFormat, ptr %pFormat.addr, align 8
  store ptr %arguments, ptr %arguments.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call2 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  store i64 %call2, ptr %nInitialSize, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call4 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout20GetRemainingCapacityEv(ptr noundef nonnull align 8 dereferenceable(24) %call3) #9
  store i64 %call4, ptr %nInitialRemainingCapacity, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %argumentsSaved, i64 0, i64 0
  %0 = load ptr, ptr %arguments.addr, align 8
  call void @llvm.va_copy(ptr %arraydecay, ptr %0)
  %call5 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call6 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call5) #9
  %1 = load i64, ptr %nInitialRemainingCapacity, align 8
  %add = add i64 %1, 1
  %2 = load ptr, ptr %pFormat.addr, align 8
  %3 = load ptr, ptr %arguments.addr, align 8
  %call7 = call noundef i32 @_ZN5eastl9VsnprintfEPcmPKcP13__va_list_tag(ptr noundef %call6, i64 noundef %add, ptr noundef %2, ptr noundef %3)
  store i32 %call7, ptr %nReturnValue, align 4
  %4 = load i32, ptr %nReturnValue, align 4
  %5 = load i64, ptr %nInitialRemainingCapacity, align 8
  %add8 = add i64 %5, 1
  %conv = trunc i64 %add8 to i32
  %cmp = icmp sge i32 %4, %conv
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load ptr, ptr %arguments.addr, align 8
  call void @llvm.va_end(ptr %6)
  %7 = load ptr, ptr %arguments.addr, align 8
  %arraydecay9 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %argumentsSaved, i64 0, i64 0
  call void @llvm.va_copy(ptr %7, ptr %arraydecay9)
  %8 = load i64, ptr %nInitialSize, align 8
  %9 = load i32, ptr %nReturnValue, align 4
  %conv10 = sext i32 %9 to i64
  %add11 = add i64 %8, %conv10
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %add11)
  %call12 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call13 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout8BeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call12) #9
  %10 = load i64, ptr %nInitialSize, align 8
  %add.ptr = getelementptr inbounds i8, ptr %call13, i64 %10
  %11 = load i32, ptr %nReturnValue, align 4
  %add14 = add nsw i32 %11, 1
  %conv15 = sext i32 %add14 to i64
  %12 = load ptr, ptr %pFormat.addr, align 8
  %13 = load ptr, ptr %arguments.addr, align 8
  %call16 = call noundef i32 @_ZN5eastl9VsnprintfEPcmPKcP13__va_list_tag(ptr noundef %add.ptr, i64 noundef %conv15, ptr noundef %12, ptr noundef %13)
  store i32 %call16, ptr %nReturnValue, align 4
  br label %if.end38

if.else:                                          ; preds = %entry
  %14 = load i32, ptr %nReturnValue, align 4
  %cmp17 = icmp slt i32 %14, 0
  br i1 %cmp17, label %if.then18, label %if.end37

if.then18:                                        ; preds = %if.else
  %15 = load i64, ptr %nInitialSize, align 8
  %mul = mul i64 %15, 2
  %call19 = call noundef i64 @_ZN5eastl7max_altImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef 22, i64 noundef %mul)
  store i64 %call19, ptr %n, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then18
  %16 = load i32, ptr %nReturnValue, align 4
  %cmp20 = icmp slt i32 %16, 0
  br i1 %cmp20, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %17 = load i64, ptr %n, align 8
  %cmp21 = icmp ult i64 %17, 1000000
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %18 = phi i1 [ false, %for.cond ], [ %cmp21, %land.rhs ]
  br i1 %18, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %19 = load ptr, ptr %arguments.addr, align 8
  call void @llvm.va_end(ptr %19)
  %20 = load ptr, ptr %arguments.addr, align 8
  %arraydecay22 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %argumentsSaved, i64 0, i64 0
  call void @llvm.va_copy(ptr %20, ptr %arraydecay22)
  %21 = load i64, ptr %n, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %21)
  %22 = load i64, ptr %n, align 8
  %23 = load i64, ptr %nInitialSize, align 8
  %sub = sub i64 %22, %23
  store i64 %sub, ptr %nCapacity, align 8
  %call23 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call24 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout8BeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call23) #9
  %24 = load i64, ptr %nInitialSize, align 8
  %add.ptr25 = getelementptr inbounds i8, ptr %call24, i64 %24
  %25 = load i64, ptr %nCapacity, align 8
  %add26 = add i64 %25, 1
  %26 = load ptr, ptr %pFormat.addr, align 8
  %27 = load ptr, ptr %arguments.addr, align 8
  %call27 = call noundef i32 @_ZN5eastl9VsnprintfEPcmPKcP13__va_list_tag(ptr noundef %add.ptr25, i64 noundef %add26, ptr noundef %26, ptr noundef %27)
  store i32 %call27, ptr %nReturnValue, align 4
  %28 = load i32, ptr %nReturnValue, align 4
  %29 = load i64, ptr %nCapacity, align 8
  %conv28 = trunc i64 %29 to i32
  %cmp29 = icmp eq i32 %28, %conv28
  br i1 %cmp29, label %if.then30, label %if.end

if.then30:                                        ; preds = %for.body
  %30 = load i64, ptr %n, align 8
  %inc = add i64 %30, 1
  store i64 %inc, ptr %n, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %inc)
  %call31 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call32 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout8BeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call31) #9
  %31 = load i64, ptr %nInitialSize, align 8
  %add.ptr33 = getelementptr inbounds i8, ptr %call32, i64 %31
  %32 = load i64, ptr %nCapacity, align 8
  %add34 = add i64 %32, 2
  %33 = load ptr, ptr %pFormat.addr, align 8
  %34 = load ptr, ptr %arguments.addr, align 8
  %call35 = call noundef i32 @_ZN5eastl9VsnprintfEPcmPKcP13__va_list_tag(ptr noundef %add.ptr33, i64 noundef %add34, ptr noundef %33, ptr noundef %34)
  store i32 %call35, ptr %nReturnValue, align 4
  br label %if.end

if.end:                                           ; preds = %if.then30, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %35 = load i64, ptr %n, align 8
  %mul36 = mul i64 %35, 2
  store i64 %mul36, ptr %n, align 8
  br label %for.cond, !llvm.loop !54

for.end:                                          ; preds = %land.end
  br label %if.end37

if.end37:                                         ; preds = %for.end, %if.else
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.then
  %36 = load i32, ptr %nReturnValue, align 4
  %cmp39 = icmp sge i32 %36, 0
  br i1 %cmp39, label %if.then40, label %if.end44

if.then40:                                        ; preds = %if.end38
  %call41 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %37 = load i64, ptr %nInitialSize, align 8
  %38 = load i32, ptr %nReturnValue, align 4
  %conv42 = sext i32 %38 to i64
  %add43 = add i64 %37, %conv42
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout7SetSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %call41, i64 noundef %add43) #9
  br label %if.end44

if.end44:                                         ; preds = %if.then40, %if.end38
  %arraydecay45 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %argumentsSaved, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay45)
  ret ptr %this1
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #7

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef null)
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.47", ptr %this1, i32 0, i32 0
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6LayoutC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %mFirst)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE6LayoutC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10ResetToSSOEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10ResetToSSOEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout11SSOBeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store i8 0, ptr %call, align 1
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10SetSSOSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef 0) #9
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout11SSOBeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mData = getelementptr inbounds %"struct.eastl::basic_string<char>::SSOLayout", ptr %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [23 x i8], ptr %mData, i64 0, i64 0
  ret ptr %arraydecay
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10SetSSOSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %size) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %sub = sub i64 23, %0
  %conv = trunc i64 %sub to i8
  %1 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mRemainingSizeField = getelementptr inbounds %"struct.eastl::basic_string<char>::SSOLayout", ptr %1, i32 0, i32 1
  %mnRemainingSize = getelementptr inbounds %"struct.eastl::basic_string<char>::SSOLayout::SSOSize", ptr %mRemainingSizeField, i32 0, i32 0
  store i8 %conv, ptr %mnRemainingSize, align 1
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE13get_allocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %0 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %0, 1
  %call2 = call noundef ptr @_ZN5eastl9allocator8allocateEmi(ptr noundef nonnull align 1 dereferenceable(1) %call, i64 noundef %mul, i32 noundef 0)
  ret ptr %call2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout15SetHeapBeginPtrEPc(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %pBegin) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %pBegin.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %pBegin, ptr %pBegin.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %pBegin.addr, align 8
  %1 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mpBegin = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %1, i32 0, i32 0
  store ptr %0, ptr %mpBegin, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout15SetHeapCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %cap) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %cap.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %cap, ptr %cap.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %cap.addr, align 8
  %or = or i64 %0, -9223372036854775808
  %1 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mnCapacity = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %1, i32 0, i32 2
  store i64 %or, ptr %mnCapacity, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout11SetHeapSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %size) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %size.addr, align 8
  %1 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mnSize = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %1, i32 0, i32 1
  store i64 %0, ptr %mnSize, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE13get_allocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mPair = getelementptr inbounds %"class.eastl::basic_string", ptr %this1, i32 0, i32 0
  %call = invoke noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_E6secondEv(ptr noundef nonnull align 8 dereferenceable(24) %mPair)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_E6secondEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_E5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.47", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mRemainingSizeField = getelementptr inbounds %"struct.eastl::basic_string<char>::SSOLayout", ptr %0, i32 0, i32 1
  %mnRemainingSize = getelementptr inbounds %"struct.eastl::basic_string<char>::SSOLayout::SSOSize", ptr %mRemainingSizeField, i32 0, i32 0
  %1 = load i8, ptr %mnRemainingSize, align 1
  %conv = sext i8 %1 to i64
  %and = and i64 %conv, 128
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  ret i1 %lnot2
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call2 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout11GetHeapSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout10GetSSOSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ %call3, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout20GetRemainingCapacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout11CapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call2 = call noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %sub.ptr.lhs.cast = ptrtoint ptr %call to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %call2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  ret i64 %sub.ptr.sub
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_copy(ptr, ptr) #7

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i32 @_ZN5eastl9VsnprintfEPcmPKcP13__va_list_tag(ptr noalias noundef %pDestination, i64 noundef %n, ptr noalias noundef %pFormat, ptr noundef %arguments) #0 comdat {
entry:
  %pDestination.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pFormat.addr = alloca ptr, align 8
  %arguments.addr = alloca ptr, align 8
  store ptr %pDestination, ptr %pDestination.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %pFormat, ptr %pFormat.addr, align 8
  store ptr %arguments, ptr %arguments.addr, align 8
  %0 = load ptr, ptr %pDestination.addr, align 8
  %1 = load i64, ptr %n.addr, align 8
  %2 = load ptr, ptr %pFormat.addr, align 8
  %3 = load ptr, ptr %arguments.addr, align 8
  %call = call noundef i32 @_ZN2EA4StdC9VsnprintfEPcmPKcP13__va_list_tag(ptr noundef %0, i64 noundef %1, ptr noundef %2, ptr noundef %3)
  ret i32 %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call2 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10HeapEndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout9SSOEndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call2, %cond.true ], [ %call3, %cond.false ]
  ret ptr %cond
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE6resizeEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %s = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call2 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  store i64 %call2, ptr %s, align 8
  %0 = load i64, ptr %n.addr, align 8
  %1 = load i64, ptr %s, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call3 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call4 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout8BeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call3) #9
  %2 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %call4, i64 %2
  %call5 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call6 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call5) #9
  %call7 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE5eraseEPKcS4_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %add.ptr, ptr noundef %call6)
  br label %if.end11

if.else:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %4 = load i64, ptr %s, align 8
  %cmp8 = icmp ugt i64 %3, %4
  br i1 %cmp8, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.else
  %5 = load i64, ptr %n.addr, align 8
  %6 = load i64, ptr %s, align 8
  %sub = sub i64 %5, %6
  %call10 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6appendEmc(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %sub, i8 noundef signext 0)
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout8BeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call2 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout12HeapBeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout11SSOBeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call2, %cond.true ], [ %call3, %cond.false ]
  ret ptr %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl7max_altImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %a, i64 noundef %b) #1 comdat {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i64, ptr %b.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i64, ptr %a.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %2, %cond.true ], [ %3, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout11GetHeapSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mnSize = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %0, i32 0, i32 1
  %1 = load i64, ptr %mnSize, align 8
  ret i64 %1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout10GetSSOSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mRemainingSizeField = getelementptr inbounds %"struct.eastl::basic_string<char>::SSOLayout", ptr %0, i32 0, i32 1
  %mnRemainingSize = getelementptr inbounds %"struct.eastl::basic_string<char>::SSOLayout::SSOSize", ptr %mRemainingSizeField, i32 0, i32 0
  %1 = load i8, ptr %mnRemainingSize, align 1
  %conv = sext i8 %1 to i64
  %sub = sub i64 23, %conv
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout11CapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call2 = call noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout15HeapCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout14SSOCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call2, %cond.true ], [ %call3, %cond.false ]
  ret ptr %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call2 = call noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout10HeapEndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout9SSOEndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call2, %cond.true ], [ %call3, %cond.false ]
  ret ptr %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout15HeapCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mpBegin = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %call = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout15GetHeapCapacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %call
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout14SSOCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mData = getelementptr inbounds %"struct.eastl::basic_string<char>::SSOLayout", ptr %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [23 x i8], ptr %mData, i64 0, i64 0
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay, i64 23
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout15GetHeapCapacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mnCapacity = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %0, i32 0, i32 2
  %1 = load i64, ptr %mnCapacity, align 8
  %and = and i64 %1, 9223372036854775807
  ret i64 %and
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout10HeapEndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mpBegin = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %2 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mnSize = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mnSize, align 8
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %3
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout9SSOEndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mData = getelementptr inbounds %"struct.eastl::basic_string<char>::SSOLayout", ptr %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [23 x i8], ptr %mData, i64 0, i64 0
  %call = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout10GetSSOSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay, i64 %call
  ret ptr %add.ptr
}

declare noundef i32 @_ZN2EA4StdC9VsnprintfEPcmPKcP13__va_list_tag(ptr noundef, i64 noundef, ptr noundef, ptr noundef) #4

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10HeapEndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mpBegin = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %2 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mnSize = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mnSize, align 8
  %add.ptr = getelementptr inbounds i8, ptr %1, i64 %3
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout9SSOEndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mData = getelementptr inbounds %"struct.eastl::basic_string<char>::SSOLayout", ptr %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [23 x i8], ptr %mData, i64 0, i64 0
  %call = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout10GetSSOSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %add.ptr = getelementptr inbounds i8, ptr %arraydecay, i64 %call
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE5eraseEPKcS4_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %pBegin, ptr noundef %pEnd) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %pBegin.addr = alloca ptr, align 8
  %pEnd.addr = alloca ptr, align 8
  %n = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %pBegin, ptr %pBegin.addr, align 8
  store ptr %pEnd, ptr %pEnd.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %pBegin.addr, align 8
  %1 = load ptr, ptr %pEnd.addr, align 8
  %cmp = icmp ne ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %pBegin.addr, align 8
  %3 = load ptr, ptr %pEnd.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call2 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  %4 = load ptr, ptr %pEnd.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %call2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %add = add nsw i64 %sub.ptr.sub, 1
  %mul = mul i64 %add, 1
  call void @llvm.memmove.p0.p0.i64(ptr align 1 %2, ptr align 1 %3, i64 %mul, i1 false)
  %5 = load ptr, ptr %pEnd.addr, align 8
  %6 = load ptr, ptr %pBegin.addr, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %6 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  store i64 %sub.ptr.sub5, ptr %n, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call7 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call8 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %call7) #9
  %7 = load i64, ptr %n, align 8
  %sub = sub i64 %call8, %7
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout7SetSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %call6, i64 noundef %sub) #9
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load ptr, ptr %pBegin.addr, align 8
  ret ptr %8
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6appendEmc(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, i8 noundef signext %c) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %c.addr = alloca i8, align 1
  %nSize = alloca i64, align 8
  %nCapacity = alloca i64, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i8 %c, ptr %c.addr, align 1
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end13

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call2 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  store i64 %call2, ptr %nSize, align 8
  %call3 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store i64 %call3, ptr %nCapacity, align 8
  %1 = load i64, ptr %nSize, align 8
  %2 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, %2
  %3 = load i64, ptr %nCapacity, align 8
  %cmp4 = icmp ugt i64 %add, %3
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %4 = load i64, ptr %nCapacity, align 8
  %5 = load i64, ptr %nSize, align 8
  %6 = load i64, ptr %n.addr, align 8
  %add6 = add i64 %5, %6
  %7 = load i64, ptr %nCapacity, align 8
  %sub = sub i64 %add6, %7
  %call7 = call noundef i64 @_ZN5eastl12basic_stringIcNS_9allocatorEE14GetNewCapacityEmm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %4, i64 noundef %sub)
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %call7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  %call8 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call9 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call8) #9
  %8 = load i64, ptr %n.addr, align 8
  %9 = load i8, ptr %c.addr, align 1
  %call10 = call noundef ptr @_ZN5eastl28CharStringUninitializedFillNEPcmc(ptr noundef %call9, i64 noundef %8, i8 noundef signext %9)
  store ptr %call10, ptr %pNewEnd, align 8
  %10 = load ptr, ptr %pNewEnd, align 8
  store i8 0, ptr %10, align 1
  %call11 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %11 = load i64, ptr %nSize, align 8
  %12 = load i64, ptr %n.addr, align 8
  %add12 = add i64 %11, %12
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout7SetSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %call11, i64 noundef %add12) #9
  br label %if.end13

if.end13:                                         ; preds = %if.end, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %retval = alloca i64, align 8
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call2 = call noundef zeroext i1 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv(ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call4 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout15GetHeapCapacityEv(ptr noundef nonnull align 8 dereferenceable(24) %call3) #9
  store i64 %call4, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store i64 23, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %0 = load i64, ptr %retval, align 8
  ret i64 %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE7reserveEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call2 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  %call3 = call noundef i64 @_ZN5eastl7max_altImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %0, i64 noundef %call2)
  store i64 %call3, ptr %n.addr, align 8
  %1 = load i64, ptr %n.addr, align 8
  %call4 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %cmp = icmp ugt i64 %1, %call4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl12basic_stringIcNS_9allocatorEE14GetNewCapacityEmm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %currentCapacity, i64 noundef %minimumGrowSize) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %currentCapacity.addr = alloca i64, align 8
  %minimumGrowSize.addr = alloca i64, align 8
  %nNewCapacity = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %currentCapacity, ptr %currentCapacity.addr, align 8
  store i64 %minimumGrowSize, ptr %minimumGrowSize.addr, align 8
  %0 = load i64, ptr %currentCapacity.addr, align 8
  %1 = load i64, ptr %minimumGrowSize.addr, align 8
  %add = add i64 %0, %1
  %2 = load i64, ptr %currentCapacity.addr, align 8
  %mul = mul i64 %2, 2
  %call = call noundef i64 @_ZN5eastl7max_altImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %add, i64 noundef %mul)
  store i64 %call, ptr %nNewCapacity, align 8
  %3 = load i64, ptr %nNewCapacity, align 8
  ret i64 %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl28CharStringUninitializedFillNEPcmc(ptr noundef %pDestination, i64 noundef %n, i8 noundef signext %c) #1 comdat {
entry:
  %pDestination.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %c.addr = alloca i8, align 1
  store ptr %pDestination, ptr %pDestination.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i8 %c, ptr %c.addr, align 1
  %0 = load i64, ptr %n.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %pDestination.addr, align 8
  %2 = load i8, ptr %c.addr, align 1
  %conv = zext i8 %2 to i32
  %3 = trunc i32 %conv to i8
  %4 = load i64, ptr %n.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 1 %1, i8 %3, i64 %4, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load ptr, ptr %pDestination.addr, align 8
  %6 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %5, i64 %6
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mPair = getelementptr inbounds %"class.eastl::basic_string", ptr %this1, i32 0, i32 0
  %call = invoke noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_E5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %mPair)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl15compressed_pairINS_12basic_stringIcNS_9allocatorEE6LayoutES2_E5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(24) ptr @_ZNK5eastl19compressed_pair_impINS_12basic_stringIcNS_9allocatorEE6LayoutES2_Li2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.47", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE12set_capacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pOldBegin = alloca ptr, align 8
  %nOldCap = alloca i64, align 8
  %pNewBegin = alloca ptr, align 8
  %nSavedSize = alloca i64, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call2 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  store i64 %call2, ptr %n.addr, align 8
  br label %if.end10

if.else:                                          ; preds = %entry
  %1 = load i64, ptr %n.addr, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call4 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %call3) #9
  %cmp5 = icmp ult i64 %1, %call4
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.else
  %call7 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout7SetSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %call7, i64 noundef %2) #9
  %call8 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call9 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call8) #9
  store i8 0, ptr %call9, align 1
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.else
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  %3 = load i64, ptr %n.addr, align 8
  %call11 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %cmp12 = icmp ult i64 %3, %call11
  br i1 %cmp12, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end10
  %call13 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call14 = call noundef zeroext i1 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv(ptr noundef nonnull align 8 dereferenceable(24) %call13) #9
  br i1 %call14, label %if.then17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end10
  %4 = load i64, ptr %n.addr, align 8
  %call15 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE8capacityEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %cmp16 = icmp ugt i64 %4, %call15
  br i1 %cmp16, label %if.then17, label %if.end47

if.then17:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load i64, ptr %n.addr, align 8
  %tobool = icmp ne i64 %5, 0
  %lnot = xor i1 %tobool, true
  %lnot18 = xor i1 %lnot, true
  br i1 %lnot18, label %if.then19, label %if.else45

if.then19:                                        ; preds = %if.then17
  %6 = load i64, ptr %n.addr, align 8
  %cmp20 = icmp ule i64 %6, 23
  br i1 %cmp20, label %if.then21, label %if.end32

if.then21:                                        ; preds = %if.then19
  %call22 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call23 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout8BeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call22) #9
  store ptr %call23, ptr %pOldBegin, align 8
  %call24 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call25 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout15GetHeapCapacityEv(ptr noundef nonnull align 8 dereferenceable(24) %call24) #9
  store i64 %call25, ptr %nOldCap, align 8
  %7 = load ptr, ptr %pOldBegin, align 8
  %8 = load ptr, ptr %pOldBegin, align 8
  %9 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %8, i64 %9
  %call26 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call27 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout11SSOBeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call26) #9
  %call28 = call noundef ptr @_ZN5eastl27CharStringUninitializedCopyIcEEPT_PKS1_S4_S2_(ptr noundef %7, ptr noundef %add.ptr, ptr noundef %call27)
  %call29 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %10 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10SetSSOSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %call29, i64 noundef %10) #9
  %call30 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call31 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout9SSOEndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call30) #9
  store i8 0, ptr %call31, align 1
  %11 = load ptr, ptr %pOldBegin, align 8
  %12 = load i64, ptr %nOldCap, align 8
  %add = add i64 %12, 1
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6DoFreeEPcm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %11, i64 noundef %add)
  br label %if.end47

if.end32:                                         ; preds = %if.then19
  %13 = load i64, ptr %n.addr, align 8
  %add33 = add i64 %13, 1
  %call34 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %add33)
  store ptr %call34, ptr %pNewBegin, align 8
  %call35 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call36 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout7GetSizeEv(ptr noundef nonnull align 8 dereferenceable(24) %call35) #9
  store i64 %call36, ptr %nSavedSize, align 8
  %call37 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call38 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout8BeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call37) #9
  %call39 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call40 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout6EndPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call39) #9
  %14 = load ptr, ptr %pNewBegin, align 8
  %call41 = call noundef ptr @_ZN5eastl27CharStringUninitializedCopyIcEEPT_PKS1_S4_S2_(ptr noundef %call38, ptr noundef %call40, ptr noundef %14)
  store ptr %call41, ptr %pNewEnd, align 8
  %15 = load ptr, ptr %pNewEnd, align 8
  store i8 0, ptr %15, align 1
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE14DeallocateSelfEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  %call42 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %16 = load ptr, ptr %pNewBegin, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout15SetHeapBeginPtrEPc(ptr noundef nonnull align 8 dereferenceable(24) %call42, ptr noundef %16) #9
  %call43 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %17 = load i64, ptr %n.addr, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout15SetHeapCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %call43, i64 noundef %17) #9
  %call44 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %18 = load i64, ptr %nSavedSize, align 8
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout11SetHeapSizeEm(ptr noundef nonnull align 8 dereferenceable(24) %call44, i64 noundef %18) #9
  br label %if.end46

if.else45:                                        ; preds = %if.then17
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE14DeallocateSelfEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE12AllocateSelfEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  br label %if.end46

if.end46:                                         ; preds = %if.else45, %if.end32
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.then21, %lor.lhs.false
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl27CharStringUninitializedCopyIcEEPT_PKS1_S4_S2_(ptr noundef %pSource, ptr noundef %pSourceEnd, ptr noundef %pDestination) #1 comdat {
entry:
  %pSource.addr = alloca ptr, align 8
  %pSourceEnd.addr = alloca ptr, align 8
  %pDestination.addr = alloca ptr, align 8
  store ptr %pSource, ptr %pSource.addr, align 8
  store ptr %pSourceEnd, ptr %pSourceEnd.addr, align 8
  store ptr %pDestination, ptr %pDestination.addr, align 8
  %0 = load ptr, ptr %pDestination.addr, align 8
  %1 = load ptr, ptr %pSource.addr, align 8
  %2 = load ptr, ptr %pSourceEnd.addr, align 8
  %3 = load ptr, ptr %pSource.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %mul = mul i64 %sub.ptr.sub, 1
  call void @llvm.memmove.p0.p0.i64(ptr align 1 %0, ptr align 1 %1, i64 %mul, i1 false)
  %4 = load ptr, ptr %pDestination.addr, align 8
  %5 = load ptr, ptr %pSourceEnd.addr, align 8
  %6 = load ptr, ptr %pSource.addr, align 8
  %sub.ptr.lhs.cast1 = ptrtoint ptr %5 to i64
  %sub.ptr.rhs.cast2 = ptrtoint ptr %6 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.rhs.cast2
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 %sub.ptr.sub3
  ret ptr %add.ptr
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE6DoFreeEPcm(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %p, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE13get_allocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %2, 1
  call void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE14DeallocateSelfEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call2 = call noundef zeroext i1 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout6IsHeapEv(ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call4 = call noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout8BeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %call3) #9
  %call5 = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %call6 = call noundef i64 @_ZNK5eastl12basic_stringIcNS_9allocatorEE6Layout15GetHeapCapacityEv(ptr noundef nonnull align 8 dereferenceable(24) %call5) #9
  %add = add i64 %call6, 1
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6DoFreeEPcm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %call4, i64 noundef %add)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl12basic_stringIcNS_9allocatorEE12AllocateSelfEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(24) ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE14internalLayoutEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout10ResetToSSOEv(ptr noundef nonnull align 8 dereferenceable(24) %call) #9
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #8

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl12basic_stringIcNS_9allocatorEE6Layout12HeapBeginPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = getelementptr inbounds %"struct.eastl::basic_string<char>::Layout", ptr %this1, i32 0, i32 0
  %mpBegin = getelementptr inbounds %"struct.eastl::basic_string<char>::HeapLayout", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  ret ptr %1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseImNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::allocator", align 1
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 2
  call void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp, ptr noundef @.str.78)
  call void @_ZN5eastl15compressed_pairIPmNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPmmEET_S2_T0_(ptr noundef %first, i64 noundef %n) #1 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %currentDest = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  store ptr %0, ptr %currentDest, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %currentDest, align 8
  %call = call noundef ptr @_ZN5eastl9addressofImEEPT_RS1_(ptr noundef nonnull align 8 dereferenceable(8) %2) #9
  store i64 0, ptr %call, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i64, ptr %n.addr, align 8
  %dec = add i64 %3, -1
  store i64 %dec, ptr %n.addr, align 8
  %4 = load ptr, ptr %currentDest, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %4, i32 1
  store ptr %incdec.ptr, ptr %currentDest, align 8
  br label %for.cond, !llvm.loop !55

for.end:                                          ; preds = %for.cond
  %5 = load ptr, ptr %currentDest, align 8
  ret ptr %5
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24uninitialized_fill_n_ptrImmEEvPT_T0_RKS1_(ptr noundef %first, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator", align 8
  store ptr %first, ptr %first.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @_ZN5eastl16generic_iteratorIPmvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(8) %first.addr)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive, align 8
  call void @_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPmvEEmmEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE(ptr %2, i64 noundef %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPmvEEmmEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat {
entry:
  %first = alloca %"class.eastl::generic_iterator", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator", align 8
  %coerce = alloca %"class.eastl::generic_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive1, align 8
  %call = call ptr @_ZN5eastl6fill_nINS_16generic_iteratorIPmvEEmmEET_S4_T0_RKT1_(ptr %2, i64 noundef %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %coerce, i32 0, i32 0
  store ptr %call, ptr %coerce.dive2, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16generic_iteratorIPmvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %x) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %mIterator, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl6fill_nINS_16generic_iteratorIPmvEEmmEET_S4_T0_RKT1_(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator", align 8
  %first = alloca %"class.eastl::generic_iterator", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive1, align 8
  %call = call ptr @_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPmvEEmmEET_S6_T0_RKT1_(ptr %2, i64 noundef %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %retval, i32 0, i32 0
  store ptr %call, ptr %coerce.dive2, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive3, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPmvEEmmEET_S6_T0_RKT1_(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::generic_iterator", align 8
  %first = alloca %"class.eastl::generic_iterator", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %temp = alloca i64, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %1 = load i64, ptr %0, align 8
  store i64 %1, ptr %temp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %n.addr, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, ptr %temp, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPmvEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  store i64 %3, ptr %call, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl16generic_iteratorIPmvEppEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  br label %for.cond, !llvm.loop !56

for.end:                                          ; preds = %for.cond
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %first, i64 8, i1 false)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %retval, i32 0, i32 0
  %4 = load ptr, ptr %coerce.dive2, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPmvEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl16generic_iteratorIPmvEppEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %mIterator, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRmEEONS_16remove_referenceIT_E4typeEOS3_(ptr noundef nonnull align 8 dereferenceable(8) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %dist) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dist.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %dist, ptr %dist.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %dist.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPmNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPmNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPmNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPmNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE17DoInsertValuesEndEmRKm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 8
  store i64 %sub.ptr.div6, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call7 = call noundef i64 @_ZN5eastl10VectorBaseImNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5)
  store i64 %call7, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call8 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call8, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call9 = call noundef ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9)
  store ptr %call9, ptr %pNewData, align 8
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd11, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call12 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call12, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %15 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrImmEEvPT_T0_RKS1_(ptr noundef %13, i64 noundef %14, ptr noundef nonnull align 8 dereferenceable(8) %15)
  %16 = load i64, ptr %n.addr, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i64, ptr %17, i64 %16
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin13 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin13, align 8
  %mpEnd14 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %19 = load ptr, ptr %mpEnd14, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %18, ptr noundef %19)
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %20 = load ptr, ptr %mpBegin15, align 8
  %call16 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %21 = load ptr, ptr %call16, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin17, align 8
  %sub.ptr.lhs.cast18 = ptrtoint ptr %21 to i64
  %sub.ptr.rhs.cast19 = ptrtoint ptr %22 to i64
  %sub.ptr.sub20 = sub i64 %sub.ptr.lhs.cast18, %sub.ptr.rhs.cast19
  %sub.ptr.div21 = sdiv exact i64 %sub.ptr.sub20, 8
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %20, i64 noundef %sub.ptr.div21)
  %23 = load ptr, ptr %pNewData, align 8
  %mpBegin22 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  store ptr %23, ptr %mpBegin22, align 8
  %24 = load ptr, ptr %pNewEnd, align 8
  %mpEnd23 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %24, ptr %mpEnd23, align 8
  %25 = load ptr, ptr %pNewData, align 8
  %26 = load i64, ptr %nNewSize, align 8
  %add.ptr24 = getelementptr inbounds i64, ptr %25, i64 %26
  %call25 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr24, ptr %call25, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd26 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %27 = load ptr, ptr %mpEnd26, align 8
  %28 = load i64, ptr %n.addr, align 8
  %29 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrImmEEvPT_T0_RKS1_(ptr noundef %27, i64 noundef %28, ptr noundef nonnull align 8 dereferenceable(8) %29)
  %30 = load i64, ptr %n.addr, align 8
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %31 = load ptr, ptr %mpEnd27, align 8
  %add.ptr28 = getelementptr inbounds i64, ptr %31, i64 %30
  store ptr %add.ptr28, ptr %mpEnd27, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl10VectorBaseImNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %currentCapacity) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %currentCapacity.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %currentCapacity, ptr %currentCapacity.addr, align 8
  %0 = load i64, ptr %currentCapacity.addr, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %currentCapacity.addr, align 8
  %mul = mul i64 2, %1
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 1, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %a, i64 noundef %b) #1 comdat {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = load i64, ptr %b.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i64, ptr %b.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i64, ptr %a.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %2, %cond.true ], [ %3, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %dest.addr, align 8
  %call = call noundef ptr @_ZN5eastl22uninitialized_move_ptrIPmS1_S1_EET1_T_T0_S2_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_move_ptrIPmS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  %i = alloca %"class.eastl::generic_iterator", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator", align 8
  %agg.tmp1 = alloca %"class.eastl::generic_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::generic_iterator", align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  call void @_ZN5eastl16generic_iteratorIPmvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(8) %first.addr)
  call void @_ZN5eastl16generic_iteratorIPmvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp1, ptr noundef nonnull align 8 dereferenceable(8) %last.addr)
  call void @_ZN5eastl16generic_iteratorIPmvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(8) %dest.addr)
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp1, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive5, align 8
  %call = call ptr @_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPmvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE(ptr %0, ptr %1, ptr %2)
  %coerce.dive6 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %i, i32 0, i32 0
  store ptr %call, ptr %coerce.dive6, align 8
  %call7 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPmvE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %i)
  %3 = load ptr, ptr %call7, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPmvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE(ptr %first.coerce, ptr %last.coerce, ptr %dest.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator", align 8
  %first = alloca %"class.eastl::generic_iterator", align 8
  %last = alloca %"class.eastl::generic_iterator", align 8
  %dest = alloca %"class.eastl::generic_iterator", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::generic_iterator", align 8
  %agg.tmp4 = alloca %"class.eastl::generic_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %dest, i32 0, i32 0
  store ptr %dest.coerce, ptr %coerce.dive2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp4, ptr align 8 %dest, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  %coerce.dive7 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp4, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive7, align 8
  %call = call ptr @_ZN5eastl4copyINS_16generic_iteratorIPmvEES3_EET0_T_S5_S4_(ptr %0, ptr %1, ptr %2)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %retval, i32 0, i32 0
  store ptr %call, ptr %coerce.dive8, align 8
  %coerce.dive9 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive9, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPmvE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator", ptr %this1, i32 0, i32 0
  ret ptr %mIterator
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl4copyINS_16generic_iteratorIPmvEES3_EET0_T_S5_S4_(ptr %first.coerce, ptr %last.coerce, ptr %result.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator", align 8
  %first = alloca %"class.eastl::generic_iterator", align 8
  %last = alloca %"class.eastl::generic_iterator", align 8
  %result = alloca %"class.eastl::generic_iterator", align 8
  %isMove = alloca i8, align 1
  %agg.tmp = alloca %"class.eastl::generic_iterator", align 8
  %agg.tmp4 = alloca %"class.eastl::generic_iterator", align 8
  %agg.tmp7 = alloca %"class.eastl::generic_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %result, i32 0, i32 0
  store ptr %result.coerce, ptr %coerce.dive2, align 8
  store i8 0, ptr %isMove, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %coerce.dive3 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive3, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPmvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp4, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp4, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call6 = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPmvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp7, ptr align 8 %result, i64 8, i1 false)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp7, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive8, align 8
  %call9 = call ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPmNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_(ptr noundef %call, ptr noundef %call6, ptr %2)
  %coerce.dive10 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %retval, i32 0, i32 0
  store ptr %call9, ptr %coerce.dive10, align 8
  %coerce.dive11 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive11, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPmNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_(ptr noundef %first, ptr noundef %last, ptr %result.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator", align 8
  %result = alloca %"class.eastl::generic_iterator", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %ref.tmp = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator", ptr %result, i32 0, i32 0
  store ptr %result.coerce, ptr %coerce.dive, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorIPmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %0)
  %1 = load ptr, ptr %last.addr, align 8
  %call1 = call noundef ptr @_ZN5eastl15unwrap_iteratorIPmEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %result, i64 8, i1 false)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive2, align 8
  %call3 = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPmvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %2)
  %call4 = call noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPmS1_EET1_T0_S3_S2_(ptr noundef %call, ptr noundef %call1, ptr noundef %call3)
  store ptr %call4, ptr %ref.tmp, align 8
  call void @_ZN5eastl16generic_iteratorIPmvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %retval, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive5, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPmvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %it.coerce) #0 comdat {
entry:
  %it = alloca %"class.eastl::generic_iterator", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator", ptr %it, i32 0, i32 0
  store ptr %it.coerce, ptr %coerce.dive, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %it, i64 8, i1 false)
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive1, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPmvEELb1EE13get_unwrappedES3_(ptr %0)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPmS1_EET1_T0_S3_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #1 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %canBeMemmoved = alloca i8, align 1
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %canBeMemmoved, align 1
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %result.addr, align 8
  %call = call noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyImEEPT_PKS4_S7_S5_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPmvEELb1EE13get_unwrappedES3_(ptr %it.coerce) #0 comdat align 2 {
entry:
  %it = alloca %"class.eastl::generic_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator", ptr %it, i32 0, i32 0
  store ptr %it.coerce, ptr %coerce.dive, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPmvE6unwrapEv(ptr noundef nonnull align 8 dereferenceable(8) %it)
  %0 = load ptr, ptr %call, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPmvE6unwrapEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator", ptr %this1, i32 0, i32 0
  ret ptr %mIterator
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 8
  store i64 %sub.ptr.div6, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call7 = call noundef i64 @_ZN5eastl10VectorBaseImNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5)
  store i64 %call7, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call8 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call8, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call9 = call noundef ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9)
  store ptr %call9, ptr %pNewData, align 8
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd11, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call12 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call12, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %call13 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPmmEET_S2_T0_(ptr noundef %13, i64 noundef %14)
  %15 = load i64, ptr %n.addr, align 8
  %16 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i64, ptr %16, i64 %15
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin14 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %17 = load ptr, ptr %mpBegin14, align 8
  %mpEnd15 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %18 = load ptr, ptr %mpEnd15, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %17, ptr noundef %18)
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %19 = load ptr, ptr %mpBegin16, align 8
  %call17 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %20 = load ptr, ptr %call17, align 8
  %mpBegin18 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %21 = load ptr, ptr %mpBegin18, align 8
  %sub.ptr.lhs.cast19 = ptrtoint ptr %20 to i64
  %sub.ptr.rhs.cast20 = ptrtoint ptr %21 to i64
  %sub.ptr.sub21 = sub i64 %sub.ptr.lhs.cast19, %sub.ptr.rhs.cast20
  %sub.ptr.div22 = sdiv exact i64 %sub.ptr.sub21, 8
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %19, i64 noundef %sub.ptr.div22)
  %22 = load ptr, ptr %pNewData, align 8
  %mpBegin23 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  store ptr %22, ptr %mpBegin23, align 8
  %23 = load ptr, ptr %pNewEnd, align 8
  %mpEnd24 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %23, ptr %mpEnd24, align 8
  %24 = load ptr, ptr %pNewData, align 8
  %25 = load i64, ptr %nNewSize, align 8
  %add.ptr25 = getelementptr inbounds i64, ptr %24, i64 %25
  %call26 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr25, ptr %call26, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %26 = load ptr, ptr %mpEnd27, align 8
  %27 = load i64, ptr %n.addr, align 8
  %call28 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPmmEET_S2_T0_(ptr noundef %26, i64 noundef %27)
  %28 = load i64, ptr %n.addr, align 8
  %mpEnd29 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %29 = load ptr, ptr %mpEnd29, align 8
  %add.ptr30 = getelementptr inbounds i64, ptr %29, i64 %28
  store ptr %add.ptr30, ptr %mpEnd29, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %3 = load ptr, ptr %pNewData, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  store ptr %call2, ptr %pNewEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %4, ptr noundef %5)
  %mpBegin5 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin5, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %7 = load ptr, ptr %call6, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %8 = load ptr, ptr %mpBegin7, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %6, i64 noundef %sub.ptr.div)
  %9 = load ptr, ptr %pNewData, align 8
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  store ptr %9, ptr %mpBegin8, align 8
  %10 = load ptr, ptr %pNewEnd, align 8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %10, ptr %mpEnd9, align 8
  %11 = load ptr, ptr %pNewData, align 8
  %12 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %11, i64 %12
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call10, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %temp = alloca %"class.eastl::vector", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl13move_iteratorIPmEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef %call)
  %call3 = call noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl13move_iteratorIPmEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef %call3)
  %call4 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEEC2INS_13move_iteratorIPmEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(24) %temp, ptr %0, ptr %1, ptr noundef nonnull align 1 dereferenceable(1) %call4)
  invoke void @_ZN5eastl6vectorImNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %temp)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl6vectorImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  ret void

lpad:                                             ; preds = %entry
  %2 = landingpad { ptr, i32 }
          cleanup
  %3 = extractvalue { ptr, i32 } %2, 0
  store ptr %3, ptr %exn.slot, align 8
  %4 = extractvalue { ptr, i32 } %2, 1
  store i32 %4, ptr %ehselector.slot, align 4
  call void @_ZN5eastl6vectorImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val6 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorImNS_9allocatorEE9DoReallocIPmEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %p, align 8
  %1 = load ptr, ptr %first.addr, align 8
  %2 = load ptr, ptr %last.addr, align 8
  %3 = load ptr, ptr %p, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %p, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl13move_iteratorIPmEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %mi) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %mi.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %mi, ptr %mi.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mi.addr, align 8
  store ptr %0, ptr %mIterator, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEEC2INS_13move_iteratorIPmEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr noundef nonnull align 1 dereferenceable(1) %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp3, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive6, align 8
  invoke void @_ZN5eastl6vectorImNS_9allocatorEE6DoInitINS_13move_iteratorIPmEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr %1, ptr %2)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  ret void

lpad:                                             ; preds = %entry
  %3 = landingpad { ptr, i32 }
          cleanup
  %4 = extractvalue { ptr, i32 } %3, 0
  store ptr %4, ptr %exn.slot, align 8
  %5 = extractvalue { ptr, i32 } %3, 1
  store i32 %5, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val7 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE6DoInitINS_13move_iteratorIPmEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  call void @_ZN5eastl6vectorImNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPmEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr %0, ptr %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPmEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %this.addr = alloca ptr, align 8
  %n = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp10 = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp11 = alloca %"class.eastl::move_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPmEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %0, ptr %1)
  store i64 %call, ptr %n, align 8
  %2 = load i64, ptr %n, align 8
  %call6 = call noundef ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this2, i64 noundef %2)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this2, i32 0, i32 0
  store ptr %call6, ptr %mpBegin, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this2, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin7, align 8
  %4 = load i64, ptr %n, align 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 %4
  %call8 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  store ptr %add.ptr, ptr %call8, align 8
  %call9 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  %5 = load ptr, ptr %call9, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this2, i32 0, i32 1
  store ptr %5, ptr %mpEnd, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp10, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp11, ptr align 8 %last, i64 8, i1 false)
  %mpBegin12 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this2, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin12, align 8
  %coerce.dive13 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp10, i32 0, i32 0
  %7 = load ptr, ptr %coerce.dive13, align 8
  %coerce.dive14 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp11, i32 0, i32 0
  %8 = load ptr, ptr %coerce.dive14, align 8
  %call15 = call noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPmEES3_S2_EET1_T_T0_S4_(ptr %7, ptr %8, ptr noundef %6)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPmEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %first.coerce, ptr %last.coerce) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl13distance_implINS_13move_iteratorIPmEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE(ptr %0, ptr %1)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPmEES3_S2_EET1_T_T0_S4_(ptr %first.coerce, ptr %last.coerce, ptr noundef %result) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %result.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %result, ptr %result.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %0 = load ptr, ptr %result.addr, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive4, align 8
  %call = call noundef ptr @_ZN5eastl18uninitialized_copyINS_13move_iteratorIPmEES2_EET0_T_S5_S4_(ptr %1, ptr %2, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl13distance_implINS_13move_iteratorIPmEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE(ptr %first.coerce, ptr %last.coerce) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %call = call noundef i64 @_ZN5eastlmiIPmS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %last, ptr noundef nonnull align 8 dereferenceable(8) %first)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastlmiIPmS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef ptr @_ZNK5eastl13move_iteratorIPmE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef ptr @_ZNK5eastl13move_iteratorIPmE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %sub.ptr.lhs.cast = ptrtoint ptr %call to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %call1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl13move_iteratorIPmE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl18uninitialized_copyINS_13move_iteratorIPmEES2_EET0_T_S5_S4_(ptr %first.coerce, ptr %last.coerce, ptr noundef %result) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %result.addr = alloca ptr, align 8
  %isTriviallyCopyable = alloca i8, align 1
  %isInputIteratorReferenceAddressable = alloca i8, align 1
  %areIteratorsContiguous = alloca i8, align 1
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %isTriviallyCopyable, align 1
  store i8 0, ptr %isInputIteratorReferenceAddressable, align 1
  store i8 0, ptr %areIteratorsContiguous, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %0 = load ptr, ptr %result.addr, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive4, align 8
  %call = call noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPmEES5_EET0_T_S8_S7_(ptr %1, ptr %2, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPmEES5_EET0_T_S8_S7_(ptr %first.coerce, ptr %last.coerce, ptr noundef %dest) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %dest.addr = alloca ptr, align 8
  %currentDest = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %dest.addr, align 8
  store ptr %0, ptr %currentDest, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %call = call noundef zeroext i1 @_ZN5eastlneIPmS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %first, ptr noundef nonnull align 8 dereferenceable(8) %last)
  br i1 %call, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %currentDest, align 8
  %call2 = call noundef ptr @_ZN5eastl9addressofImEEPT_RS1_(ptr noundef nonnull align 8 dereferenceable(8) %1) #9
  %call3 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl13move_iteratorIPmEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  %2 = load i64, ptr %call3, align 8
  store i64 %2, ptr %call2, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl13move_iteratorIPmEppEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  %3 = load ptr, ptr %currentDest, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %3, i32 1
  store ptr %incdec.ptr, ptr %currentDest, align 8
  br label %for.cond, !llvm.loop !57

for.end:                                          ; preds = %for.cond
  %4 = load ptr, ptr %currentDest, align 8
  ret ptr %4
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastlneIPmS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %call = call noundef zeroext i1 @_ZN5eastleqIPmS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl13move_iteratorIPmEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl13move_iteratorIPmEppEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %mIterator, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastleqIPmS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef ptr @_ZNK5eastl13move_iteratorIPmE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef ptr @_ZNK5eastl13move_iteratorIPmE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %cmp = icmp eq ptr %call, %call1
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorImNS_9allocatorEE16DoInsertValueEndIJmEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(8) %args) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  store i64 %sub.ptr.div, ptr %nPrevSize, align 8
  %2 = load i64, ptr %nPrevSize, align 8
  %call = call noundef i64 @_ZN5eastl10VectorBaseImNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %2)
  store i64 %call, ptr %nNewSize, align 8
  %3 = load i64, ptr %nNewSize, align 8
  %call2 = call noundef ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %3)
  store ptr %call2, ptr %pNewData, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  %6 = load ptr, ptr %pNewData, align 8
  %call5 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %4, ptr noundef %5, ptr noundef %6)
  store ptr %call5, ptr %pNewEnd, align 8
  %7 = load ptr, ptr %pNewEnd, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl7forwardImEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 8 dereferenceable(8) %8) #9
  %9 = load i64, ptr %call6, align 8
  store i64 %9, ptr %7, align 8
  %10 = load ptr, ptr %pNewEnd, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %10, i32 1
  store ptr %incdec.ptr, ptr %pNewEnd, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %11 = load ptr, ptr %mpBegin7, align 8
  %mpEnd8 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  %12 = load ptr, ptr %mpEnd8, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %11, ptr noundef %12)
  %mpBegin9 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %13 = load ptr, ptr %mpBegin9, align 8
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %14 = load ptr, ptr %call10, align 8
  %mpBegin11 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  %15 = load ptr, ptr %mpBegin11, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %14 to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %15 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  %sub.ptr.div15 = sdiv exact i64 %sub.ptr.sub14, 8
  call void @_ZN5eastl10VectorBaseImNS_9allocatorEE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %13, i64 noundef %sub.ptr.div15)
  %16 = load ptr, ptr %pNewData, align 8
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 0
  store ptr %16, ptr %mpBegin16, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %mpEnd17 = getelementptr inbounds %"struct.eastl::VectorBase", ptr %this1, i32 0, i32 1
  store ptr %17, ptr %mpEnd17, align 8
  %18 = load ptr, ptr %pNewData, align 8
  %19 = load i64, ptr %nNewSize, align 8
  %add.ptr = getelementptr inbounds i64, ptr %18, i64 %19
  %call18 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseImNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call18, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl7forwardImEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 8 dereferenceable(8) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorImEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %dist) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dist.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %dist, ptr %dist.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %dist.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorImEC2ERKNS_19bitvector_referenceImEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %reference) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %reference.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mReference, ptr align 8 %0, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl24bitvector_const_iteratorImEmiERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %mul = mul nsw i64 %sub.ptr.div, 64
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference4, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %add = add i64 %mul, %3
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %4, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference5, i32 0, i32 1
  %5 = load i64, ptr %mnBitIndex6, align 8
  %sub = sub i64 %add, %5
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19bitvector_referenceImE8CopyFromERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %mpBitWord, align 8
  %mpBitWord2 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %this1, i32 0, i32 0
  store ptr %1, ptr %mpBitWord2, align 8
  %2 = load ptr, ptr %rhs.addr, align 8
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %2, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %mnBitIndex3 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %this1, i32 0, i32 1
  store i64 %3, ptr %mnBitIndex3, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEleERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %cmp = icmp ult ptr %0, %2
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mpBitWord5 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference4, i32 0, i32 0
  %3 = load ptr, ptr %mpBitWord5, align 8
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %4, i32 0, i32 0
  %mpBitWord7 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference6, i32 0, i32 0
  %5 = load ptr, ptr %mpBitWord7, align 8
  %cmp8 = icmp eq ptr %3, %5
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %mReference9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference9, i32 0, i32 1
  %6 = load i64, ptr %mnBitIndex, align 8
  %7 = load ptr, ptr %rhs.addr, align 8
  %mReference10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator", ptr %7, i32 0, i32 0
  %mnBitIndex11 = getelementptr inbounds %"class.eastl::bitvector_reference", ptr %mReference10, i32 0, i32 1
  %8 = load i64, ptr %mnBitIndex11, align 8
  %cmp12 = icmp ule i64 %6, %8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %9 = phi i1 [ false, %lor.rhs ], [ %cmp12, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %10 = phi i1 [ true, %entry ], [ %9, %land.end ]
  ret i1 %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceImEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceImEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %this1, i1 noundef zeroext %call)
  ret ptr %call2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIm15MallocAllocatorEC2Ev(ptr noundef nonnull align 8 dereferenceable(40) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %class.MallocAllocator, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 2
  call void @_ZN15MallocAllocatorC2EPKc(ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp, ptr noundef @.str.78)
  call void @_ZN5eastl15compressed_pairIPm15MallocAllocatorEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(24) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 8 dereferenceable(16) %ref.tmp)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPm15MallocAllocatorEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %x, ptr noundef nonnull align 8 dereferenceable(16) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %0, ptr noundef nonnull align 8 dereferenceable(16) %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %x, ptr noundef nonnull align 8 dereferenceable(16) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.5", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  store ptr %0, ptr %mFirst, align 8
  %mSecond = getelementptr inbounds %"class.eastl::compressed_pair_imp.5", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN15MallocAllocatorC2ERKS_(ptr noundef nonnull align 8 dereferenceable(16) %mSecond, ptr noundef nonnull align 8 dereferenceable(16) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN15MallocAllocatorC2ERKS_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %x) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mAllocCount = getelementptr inbounds %class.MallocAllocator, ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %mAllocCount2 = getelementptr inbounds %class.MallocAllocator, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %mAllocCount2, align 8
  store i32 %1, ptr %mAllocCount, align 8
  %mFreeCount = getelementptr inbounds %class.MallocAllocator, ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %x.addr, align 8
  %mFreeCount3 = getelementptr inbounds %class.MallocAllocator, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %mFreeCount3, align 4
  store i32 %3, ptr %mFreeCount, align 4
  %mAllocVolume = getelementptr inbounds %class.MallocAllocator, ptr %this1, i32 0, i32 2
  %4 = load ptr, ptr %x.addr, align 8
  %mAllocVolume4 = getelementptr inbounds %class.MallocAllocator, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %mAllocVolume4, align 8
  store i64 %5, ptr %mAllocVolume, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIm15MallocAllocatorEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(40) %this, ptr noundef nonnull align 8 dereferenceable(16) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPm15MallocAllocatorEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(24) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIm15MallocAllocatorEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(16) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPm15MallocAllocatorEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(24) %mCapacityAllocator, ptr noundef nonnull align 8 dereferenceable(16) %0)
  %1 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  store ptr %call, ptr %mpBegin, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin3, align 8
  %4 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 %4
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  store ptr %add.ptr, ptr %call4, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPm15MallocAllocatorEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(16) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %tobool = icmp ne i64 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %1 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %1, 8
  %call3 = call noundef ptr @_ZN5eastl15allocate_memoryI15MallocAllocatorEEPvRT_mmm(ptr noundef nonnull align 8 dereferenceable(16) %call, i64 noundef %mul, i64 noundef 8, i64 noundef 0)
  store ptr %call3, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(16) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mSecond = getelementptr inbounds %"class.eastl::compressed_pair_imp.5", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN15MallocAllocatorC2ERKS_(ptr noundef nonnull align 8 dereferenceable(16) %mSecond, ptr noundef nonnull align 8 dereferenceable(16) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15allocate_memoryI15MallocAllocatorEEPvRT_mmm(ptr noundef nonnull align 8 dereferenceable(16) %a, i64 noundef %n, i64 noundef %alignment, i64 noundef %alignmentOffset) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %alignment.addr = alloca i64, align 8
  %alignmentOffset.addr = alloca i64, align 8
  %result = alloca ptr, align 8
  %resultMinusOffset = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store i64 %alignment, ptr %alignment.addr, align 8
  store i64 %alignmentOffset, ptr %alignmentOffset.addr, align 8
  %0 = load i64, ptr %alignment.addr, align 8
  %cmp = icmp ule i64 %0, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %a.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN15MallocAllocator8allocateEmi(ptr noundef nonnull align 8 dereferenceable(16) %1, i64 noundef %2, i32 noundef 0)
  store ptr %call, ptr %result, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %a.addr, align 8
  %4 = load i64, ptr %n.addr, align 8
  %5 = load i64, ptr %alignment.addr, align 8
  %6 = load i64, ptr %alignmentOffset.addr, align 8
  %call1 = call noundef ptr @_ZN15MallocAllocator8allocateEmmmi(ptr noundef nonnull align 8 dereferenceable(16) %3, i64 noundef %4, i64 noundef %5, i64 noundef %6, i32 noundef 0)
  store ptr %call1, ptr %result, align 8
  %7 = load ptr, ptr %result, align 8
  %8 = load i64, ptr %alignmentOffset.addr, align 8
  %idx.neg = sub i64 0, %8
  %add.ptr = getelementptr inbounds i8, ptr %7, i64 %idx.neg
  store ptr %add.ptr, ptr %resultMinusOffset, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %9 = load ptr, ptr %result, align 8
  ret ptr %9
}

declare noundef ptr @_ZN15MallocAllocator8allocateEmi(ptr noundef nonnull align 8 dereferenceable(16), i64 noundef, i32 noundef) #4

declare noundef ptr @_ZN15MallocAllocator8allocateEmmmi(ptr noundef nonnull align 8 dereferenceable(16), i64 noundef, i64 noundef, i64 noundef, i32 noundef) #4

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(40) %this, ptr noundef nonnull align 8 dereferenceable(40) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %0, i32 0, i32 0
  call void @_ZN5eastl4swapIPmEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpBegin, ptr noundef nonnull align 8 dereferenceable(8) %mpBegin2) #9
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %x.addr, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapIPmEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpEnd, ptr noundef nonnull align 8 dereferenceable(8) %mpEnd3) #9
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 2
  %2 = load ptr, ptr %x.addr, align 8
  %mCapacityAllocator4 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %2, i32 0, i32 2
  call void @_ZN5eastl4swapIPm15MallocAllocatorEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(24) %mCapacityAllocator, ptr noundef nonnull align 8 dereferenceable(24) %mCapacityAllocator4)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPm15MallocAllocatorEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(24) %x, ptr noundef nonnull align 8 dereferenceable(24) %y) #0 comdat {
entry:
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl15compressed_pairIPm15MallocAllocatorE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(24) %0, ptr noundef nonnull align 8 dereferenceable(24) %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPm15MallocAllocatorE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.5", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %y.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPm15MallocAllocatorE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %0)
  call void @_ZN5eastl7cp_swapIPmEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mFirst, ptr noundef nonnull align 8 dereferenceable(8) %call)
  %mSecond = getelementptr inbounds %"class.eastl::compressed_pair_imp.5", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %y.addr, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl15compressed_pairIPm15MallocAllocatorE6secondEv(ptr noundef nonnull align 8 dereferenceable(24) %1)
  call void @_ZN5eastl7cp_swapI15MallocAllocatorEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(16) %mSecond, ptr noundef nonnull align 8 dereferenceable(16) %call2)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl7cp_swapI15MallocAllocatorEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(16) %t1, ptr noundef nonnull align 8 dereferenceable(16) %t2) #0 comdat {
entry:
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %tTemp = alloca %class.MallocAllocator, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  %0 = load ptr, ptr %t1.addr, align 8
  call void @_ZN15MallocAllocatorC2ERKS_(ptr noundef nonnull align 8 dereferenceable(16) %tTemp, ptr noundef nonnull align 8 dereferenceable(16) %0)
  %1 = load ptr, ptr %t2.addr, align 8
  %2 = load ptr, ptr %t1.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN15MallocAllocatoraSERKS_(ptr noundef nonnull align 8 dereferenceable(16) %2, ptr noundef nonnull align 8 dereferenceable(16) %1)
  %3 = load ptr, ptr %t2.addr, align 8
  %call1 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN15MallocAllocatoraSERKS_(ptr noundef nonnull align 8 dereferenceable(16) %3, ptr noundef nonnull align 8 dereferenceable(16) %tTemp)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN15MallocAllocatoraSERKS_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %x) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %mAllocCount = getelementptr inbounds %class.MallocAllocator, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %mAllocCount, align 8
  %mAllocCount2 = getelementptr inbounds %class.MallocAllocator, ptr %this1, i32 0, i32 0
  store i32 %1, ptr %mAllocCount2, align 8
  %2 = load ptr, ptr %x.addr, align 8
  %mFreeCount = getelementptr inbounds %class.MallocAllocator, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %mFreeCount, align 4
  %mFreeCount3 = getelementptr inbounds %class.MallocAllocator, ptr %this1, i32 0, i32 1
  store i32 %3, ptr %mFreeCount3, align 4
  %4 = load ptr, ptr %x.addr, align 8
  %mAllocVolume = getelementptr inbounds %class.MallocAllocator, ptr %4, i32 0, i32 2
  %5 = load i64, ptr %mAllocVolume, align 8
  %mAllocVolume4 = getelementptr inbounds %class.MallocAllocator, ptr %this1, i32 0, i32 2
  store i64 %5, ptr %mAllocVolume4, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPm15MallocAllocatorE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPm15MallocAllocatorE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPm15MallocAllocatorLi0EE5firstEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.5", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE17DoInsertValuesEndEmRKm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 8
  store i64 %sub.ptr.div6, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call7 = call noundef i64 @_ZN5eastl10VectorBaseIm15MallocAllocatorE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %5)
  store i64 %call7, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call8 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call8, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call9 = call noundef ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %9)
  store ptr %call9, ptr %pNewData, align 8
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd11, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call12 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call12, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %15 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrImmEEvPT_T0_RKS1_(ptr noundef %13, i64 noundef %14, ptr noundef nonnull align 8 dereferenceable(8) %15)
  %16 = load i64, ptr %n.addr, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i64, ptr %17, i64 %16
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin13 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin13, align 8
  %mpEnd14 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %19 = load ptr, ptr %mpEnd14, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %18, ptr noundef %19)
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %20 = load ptr, ptr %mpBegin15, align 8
  %call16 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %21 = load ptr, ptr %call16, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin17, align 8
  %sub.ptr.lhs.cast18 = ptrtoint ptr %21 to i64
  %sub.ptr.rhs.cast19 = ptrtoint ptr %22 to i64
  %sub.ptr.sub20 = sub i64 %sub.ptr.lhs.cast18, %sub.ptr.rhs.cast19
  %sub.ptr.div21 = sdiv exact i64 %sub.ptr.sub20, 8
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(40) %this1, ptr noundef %20, i64 noundef %sub.ptr.div21)
  %23 = load ptr, ptr %pNewData, align 8
  %mpBegin22 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  store ptr %23, ptr %mpBegin22, align 8
  %24 = load ptr, ptr %pNewEnd, align 8
  %mpEnd23 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %24, ptr %mpEnd23, align 8
  %25 = load ptr, ptr %pNewData, align 8
  %26 = load i64, ptr %nNewSize, align 8
  %add.ptr24 = getelementptr inbounds i64, ptr %25, i64 %26
  %call25 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  store ptr %add.ptr24, ptr %call25, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd26 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %27 = load ptr, ptr %mpEnd26, align 8
  %28 = load i64, ptr %n.addr, align 8
  %29 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrImmEEvPT_T0_RKS1_(ptr noundef %27, i64 noundef %28, ptr noundef nonnull align 8 dereferenceable(8) %29)
  %30 = load i64, ptr %n.addr, align 8
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %31 = load ptr, ptr %mpEnd27, align 8
  %add.ptr28 = getelementptr inbounds i64, ptr %31, i64 %30
  store ptr %add.ptr28, ptr %mpEnd27, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl10VectorBaseIm15MallocAllocatorE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %currentCapacity) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %currentCapacity.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %currentCapacity, ptr %currentCapacity.addr, align 8
  %0 = load i64, ptr %currentCapacity.addr, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %currentCapacity.addr, align 8
  %mul = mul i64 2, %1
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 1, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIm15MallocAllocatorE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(40) %this, ptr noundef %p, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %2, 8
  call void @_ZN15MallocAllocator10deallocateEPvm(ptr noundef nonnull align 8 dereferenceable(16) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 8
  store i64 %sub.ptr.div6, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call7 = call noundef i64 @_ZN5eastl10VectorBaseIm15MallocAllocatorE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %5)
  store i64 %call7, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call8 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call8, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call9 = call noundef ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %9)
  store ptr %call9, ptr %pNewData, align 8
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd11, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call12 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call12, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %call13 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPmmEET_S2_T0_(ptr noundef %13, i64 noundef %14)
  %15 = load i64, ptr %n.addr, align 8
  %16 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i64, ptr %16, i64 %15
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin14 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %17 = load ptr, ptr %mpBegin14, align 8
  %mpEnd15 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %18 = load ptr, ptr %mpEnd15, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %17, ptr noundef %18)
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %19 = load ptr, ptr %mpBegin16, align 8
  %call17 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %20 = load ptr, ptr %call17, align 8
  %mpBegin18 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %21 = load ptr, ptr %mpBegin18, align 8
  %sub.ptr.lhs.cast19 = ptrtoint ptr %20 to i64
  %sub.ptr.rhs.cast20 = ptrtoint ptr %21 to i64
  %sub.ptr.sub21 = sub i64 %sub.ptr.lhs.cast19, %sub.ptr.rhs.cast20
  %sub.ptr.div22 = sdiv exact i64 %sub.ptr.sub21, 8
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(40) %this1, ptr noundef %19, i64 noundef %sub.ptr.div22)
  %22 = load ptr, ptr %pNewData, align 8
  %mpBegin23 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  store ptr %22, ptr %mpBegin23, align 8
  %23 = load ptr, ptr %pNewEnd, align 8
  %mpEnd24 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %23, ptr %mpEnd24, align 8
  %24 = load ptr, ptr %pNewData, align 8
  %25 = load i64, ptr %nNewSize, align 8
  %add.ptr25 = getelementptr inbounds i64, ptr %24, i64 %25
  %call26 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  store ptr %add.ptr25, ptr %call26, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %26 = load ptr, ptr %mpEnd27, align 8
  %27 = load i64, ptr %n.addr, align 8
  %call28 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPmmEET_S2_T0_(ptr noundef %26, i64 noundef %27)
  %28 = load i64, ptr %n.addr, align 8
  %mpEnd29 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %29 = load ptr, ptr %mpEnd29, align 8
  %add.ptr30 = getelementptr inbounds i64, ptr %29, i64 %28
  store ptr %add.ptr30, ptr %mpEnd29, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %0)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %3 = load ptr, ptr %pNewData, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  store ptr %call2, ptr %pNewEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %4, ptr noundef %5)
  %mpBegin5 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin5, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %7 = load ptr, ptr %call6, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %8 = load ptr, ptr %mpBegin7, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(40) %this1, ptr noundef %6, i64 noundef %sub.ptr.div)
  %9 = load ptr, ptr %pNewData, align 8
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  store ptr %9, ptr %mpBegin8, align 8
  %10 = load ptr, ptr %pNewEnd, align 8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %10, ptr %mpEnd9, align 8
  %11 = load ptr, ptr %pNewData, align 8
  %12 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %11, i64 %12
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  store ptr %add.ptr, ptr %call10, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(40) %this) #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %temp = alloca %"class.eastl::vector.2", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN5eastl6vectorIm15MallocAllocatorE5beginEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  call void @_ZN5eastl13move_iteratorIPmEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef %call)
  %call3 = call noundef ptr @_ZN5eastl6vectorIm15MallocAllocatorE3endEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  call void @_ZN5eastl13move_iteratorIPmEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef %call3)
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorEC2INS_13move_iteratorIPmEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(40) %temp, ptr %0, ptr %1, ptr noundef nonnull align 8 dereferenceable(16) %call4)
  invoke void @_ZN5eastl6vectorIm15MallocAllocatorE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(40) %this1, ptr noundef nonnull align 8 dereferenceable(40) %temp)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl6vectorIm15MallocAllocatorED2Ev(ptr noundef nonnull align 8 dereferenceable(40) %temp) #9
  ret void

lpad:                                             ; preds = %entry
  %2 = landingpad { ptr, i32 }
          cleanup
  %3 = extractvalue { ptr, i32 } %2, 0
  store ptr %3, ptr %exn.slot, align 8
  %4 = extractvalue { ptr, i32 } %2, 1
  store i32 %4, ptr %ehselector.slot, align 4
  call void @_ZN5eastl6vectorIm15MallocAllocatorED2Ev(ptr noundef nonnull align 8 dereferenceable(40) %temp) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val6 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIm15MallocAllocatorE9DoReallocIPmEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(40) %this, i64 noundef %n, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %0)
  store ptr %call, ptr %p, align 8
  %1 = load ptr, ptr %first.addr, align 8
  %2 = load ptr, ptr %last.addr, align 8
  %3 = load ptr, ptr %p, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %p, align 8
  ret ptr %4
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorEC2INS_13move_iteratorIPmEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(40) %this, ptr %first.coerce, ptr %last.coerce, ptr noundef nonnull align 8 dereferenceable(16) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(40) %this2, ptr noundef nonnull align 8 dereferenceable(16) %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp3, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive6, align 8
  invoke void @_ZN5eastl6vectorIm15MallocAllocatorE6DoInitINS_13move_iteratorIPmEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(40) %this2, ptr %1, ptr %2)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  ret void

lpad:                                             ; preds = %entry
  %3 = landingpad { ptr, i32 }
          cleanup
  %4 = extractvalue { ptr, i32 } %3, 0
  store ptr %4, ptr %exn.slot, align 8
  %5 = extractvalue { ptr, i32 } %3, 1
  store i32 %5, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorED2Ev(ptr noundef nonnull align 8 dereferenceable(40) %this2) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val7 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val7
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE6DoInitINS_13move_iteratorIPmEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(40) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  call void @_ZN5eastl6vectorIm15MallocAllocatorE18DoInitFromIteratorINS_13move_iteratorIPmEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(40) %this2, ptr %0, ptr %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE18DoInitFromIteratorINS_13move_iteratorIPmEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(40) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator", align 8
  %last = alloca %"class.eastl::move_iterator", align 8
  %this.addr = alloca ptr, align 8
  %n = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp10 = alloca %"class.eastl::move_iterator", align 8
  %agg.tmp11 = alloca %"class.eastl::move_iterator", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPmEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %0, ptr %1)
  store i64 %call, ptr %n, align 8
  %2 = load i64, ptr %n, align 8
  %call6 = call noundef ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(40) %this2, i64 noundef %2)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this2, i32 0, i32 0
  store ptr %call6, ptr %mpBegin, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this2, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin7, align 8
  %4 = load i64, ptr %n, align 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 %4
  %call8 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this2) #9
  store ptr %add.ptr, ptr %call8, align 8
  %call9 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this2) #9
  %5 = load ptr, ptr %call9, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this2, i32 0, i32 1
  store ptr %5, ptr %mpEnd, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp10, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp11, ptr align 8 %last, i64 8, i1 false)
  %mpBegin12 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this2, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin12, align 8
  %coerce.dive13 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp10, i32 0, i32 0
  %7 = load ptr, ptr %coerce.dive13, align 8
  %coerce.dive14 = getelementptr inbounds %"class.eastl::move_iterator", ptr %agg.tmp11, i32 0, i32 0
  %8 = load ptr, ptr %coerce.dive14, align 8
  %call15 = call noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPmEES3_S2_EET1_T_T0_S4_(ptr %7, ptr %8, ptr noundef %6)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIm15MallocAllocatorE16DoInsertValueEndIJmEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(40) %this, ptr noundef nonnull align 8 dereferenceable(8) %args) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  store i64 %sub.ptr.div, ptr %nPrevSize, align 8
  %2 = load i64, ptr %nPrevSize, align 8
  %call = call noundef i64 @_ZN5eastl10VectorBaseIm15MallocAllocatorE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %2)
  store i64 %call, ptr %nNewSize, align 8
  %3 = load i64, ptr %nNewSize, align 8
  %call2 = call noundef ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(40) %this1, i64 noundef %3)
  store ptr %call2, ptr %pNewData, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  %6 = load ptr, ptr %pNewData, align 8
  %call5 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPmS1_S1_EET1_T_T0_S2_(ptr noundef %4, ptr noundef %5, ptr noundef %6)
  store ptr %call5, ptr %pNewEnd, align 8
  %7 = load ptr, ptr %pNewEnd, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl7forwardImEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 8 dereferenceable(8) %8) #9
  %9 = load i64, ptr %call6, align 8
  store i64 %9, ptr %7, align 8
  %10 = load ptr, ptr %pNewEnd, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %10, i32 1
  store ptr %incdec.ptr, ptr %pNewEnd, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %11 = load ptr, ptr %mpBegin7, align 8
  %mpEnd8 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  %12 = load ptr, ptr %mpEnd8, align 8
  call void @_ZN5eastl8destructIPmEEvT_S2_(ptr noundef %11, ptr noundef %12)
  %mpBegin9 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %13 = load ptr, ptr %mpBegin9, align 8
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  %14 = load ptr, ptr %call10, align 8
  %mpBegin11 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  %15 = load ptr, ptr %mpBegin11, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %14 to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %15 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  %sub.ptr.div15 = sdiv exact i64 %sub.ptr.sub14, 8
  call void @_ZN5eastl10VectorBaseIm15MallocAllocatorE6DoFreeEPmm(ptr noundef nonnull align 8 dereferenceable(40) %this1, ptr noundef %13, i64 noundef %sub.ptr.div15)
  %16 = load ptr, ptr %pNewData, align 8
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 0
  store ptr %16, ptr %mpBegin16, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %mpEnd17 = getelementptr inbounds %"struct.eastl::VectorBase.3", ptr %this1, i32 0, i32 1
  store ptr %17, ptr %mpEnd17, align 8
  %18 = load ptr, ptr %pNewData, align 8
  %19 = load i64, ptr %nNewSize, align 8
  %add.ptr = getelementptr inbounds i64, ptr %18, i64 %19
  %call18 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIm15MallocAllocatorE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(40) %this1) #9
  store ptr %add.ptr, ptr %call18, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIhNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::allocator", align 1
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 2
  call void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp, ptr noundef @.str.78)
  call void @_ZN5eastl15compressed_pairIPhNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPhNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %x, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %x, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.10", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %x.addr, align 8
  store ptr %1, ptr %mFirst, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIhNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPhNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIhNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPhNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef nonnull align 1 dereferenceable(1) %0)
  %1 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  store ptr %call, ptr %mpBegin, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin3, align 8
  %4 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 %4
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPhmEET_S2_T0_(ptr noundef %first, i64 noundef %n) #1 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %currentDest = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  store ptr %0, ptr %currentDest, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %currentDest, align 8
  %call = call noundef ptr @_ZN5eastl9addressofIhEEPT_RS1_(ptr noundef nonnull align 1 dereferenceable(1) %2) #9
  store i8 0, ptr %call, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i64, ptr %n.addr, align 8
  %dec = add i64 %3, -1
  store i64 %dec, ptr %n.addr, align 8
  %4 = load ptr, ptr %currentDest, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %4, i32 1
  store ptr %incdec.ptr, ptr %currentDest, align 8
  br label %for.cond, !llvm.loop !58

for.end:                                          ; preds = %for.cond
  %5 = load ptr, ptr %currentDest, align 8
  ret ptr %5
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIhNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %call3, align 8
  %mpBegin4 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin4, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %mul = mul i64 %sub.ptr.sub, 1
  call void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPhNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %tobool = icmp ne i64 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %1, 1
  %call3 = call noundef ptr @_ZN5eastl15allocate_memoryINS_9allocatorEEEPvRT_mmm(ptr noundef nonnull align 1 dereferenceable(1) %call, i64 noundef %mul, i64 noundef 1, i64 noundef 0)
  store ptr %call3, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPhNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairIPhNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairIPhNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPhNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.10", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl9addressofIhEEPT_RS1_(ptr noundef nonnull align 1 dereferenceable(1) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24uninitialized_fill_n_ptrIhmEEvPT_T0_RKS1_(ptr noundef %first, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %value) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.50", align 8
  store ptr %first, ptr %first.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @_ZN5eastl16generic_iteratorIPhvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(8) %first.addr)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive, align 8
  call void @_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPhvEEmhEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE(ptr %2, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPhvEEmhEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %value) #0 comdat {
entry:
  %first = alloca %"class.eastl::generic_iterator.50", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.50", align 8
  %coerce = alloca %"class.eastl::generic_iterator.50", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive1, align 8
  %call = call ptr @_ZN5eastl6fill_nINS_16generic_iteratorIPhvEEmhEET_S4_T0_RKT1_(ptr %2, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %coerce, i32 0, i32 0
  store ptr %call, ptr %coerce.dive2, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16generic_iteratorIPhvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %x) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %mIterator, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl6fill_nINS_16generic_iteratorIPhvEEmhEET_S4_T0_RKT1_(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %value) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.50", align 8
  %first = alloca %"class.eastl::generic_iterator.50", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.50", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive1, align 8
  %call = call ptr @_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPhvEEmhEET_S6_T0_RKT1_(ptr %2, i64 noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %retval, i32 0, i32 0
  store ptr %call, ptr %coerce.dive2, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive3, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPhvEEmhEET_S6_T0_RKT1_(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::generic_iterator.50", align 8
  %first = alloca %"class.eastl::generic_iterator.50", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %temp = alloca i8, align 1
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %1 = load i8, ptr %0, align 1
  store i8 %1, ptr %temp, align 1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %n.addr, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i8, ptr %temp, align 1
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl16generic_iteratorIPhvEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  store i8 %3, ptr %call, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl16generic_iteratorIPhvEppEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  br label %for.cond, !llvm.loop !59

for.end:                                          ; preds = %for.cond
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %first, i64 8, i1 false)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %retval, i32 0, i32 0
  %4 = load ptr, ptr %coerce.dive2, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl16generic_iteratorIPhvEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl16generic_iteratorIPhvEppEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %mIterator, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %0, i32 0, i32 0
  call void @_ZN5eastl4swapIPhEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpBegin, ptr noundef nonnull align 8 dereferenceable(8) %mpBegin2) #9
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %x.addr, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapIPhEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpEnd, ptr noundef nonnull align 8 dereferenceable(8) %mpEnd3) #9
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 2
  %2 = load ptr, ptr %x.addr, align 8
  %mCapacityAllocator4 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %2, i32 0, i32 2
  call void @_ZN5eastl4swapIPhNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator4)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPhEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %temp = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPhEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %0) #9
  %1 = load ptr, ptr %call, align 8
  store ptr %1, ptr %temp, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPhEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %2) #9
  %3 = load ptr, ptr %call1, align 8
  %4 = load ptr, ptr %a.addr, align 8
  store ptr %3, ptr %4, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPhEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %temp) #9
  %5 = load ptr, ptr %call2, align 8
  %6 = load ptr, ptr %b.addr, align 8
  store ptr %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPhNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(8) %x, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat {
entry:
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl15compressed_pairIPhNS_9allocatorEE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPhEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPhNS_9allocatorEE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 8 dereferenceable(8) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPhNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.10", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %y.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPhNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  call void @_ZN5eastl7cp_swapIPhEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mFirst, ptr noundef nonnull align 8 dereferenceable(8) %call)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl7cp_swapIPhEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %t1, ptr noundef nonnull align 8 dereferenceable(8) %t2) #1 comdat {
entry:
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %tTemp = alloca ptr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  %0 = load ptr, ptr %t1.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %tTemp, align 8
  %2 = load ptr, ptr %t2.addr, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %t1.addr, align 8
  store ptr %3, ptr %4, align 8
  %5 = load ptr, ptr %tTemp, align 8
  %6 = load ptr, ptr %t2.addr, align 8
  store ptr %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %dist) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dist.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %dist, ptr %dist.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %dist.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %sub)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %backwards = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, %0
  store i64 %add, ptr %n.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %cmp = icmp sge i64 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %div = sdiv i64 %3, 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference2, i32 0, i32 0
  %4 = load ptr, ptr %mpBitWord, align 8
  %add.ptr = getelementptr inbounds i8, ptr %4, i64 %div
  store ptr %add.ptr, ptr %mpBitWord, align 8
  %5 = load i64, ptr %n.addr, align 8
  %rem = srem i64 %5, 8
  %mReference3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex4 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference3, i32 0, i32 1
  store i64 %rem, ptr %mnBitIndex4, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %6
  %add5 = add nsw i64 %sub, 8
  %sub6 = sub nsw i64 %add5, 1
  store i64 %sub6, ptr %backwards, align 8
  %7 = load i64, ptr %backwards, align 8
  %div7 = udiv i64 %7, 8
  %mReference8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mpBitWord9 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference8, i32 0, i32 0
  %8 = load ptr, ptr %mpBitWord9, align 8
  %idx.neg = sub i64 0, %div7
  %add.ptr10 = getelementptr inbounds i8, ptr %8, i64 %idx.neg
  store ptr %add.ptr10, ptr %mpBitWord9, align 8
  %9 = load i64, ptr %backwards, align 8
  %rem11 = urem i64 %9, 8
  %sub12 = sub i64 7, %rem11
  %mReference13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex14 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference13, i32 0, i32 1
  store i64 %sub12, ptr %mnBitIndex14, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPhNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPhNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPhNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPhNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.10", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE17DoInsertValuesEndEmRKh(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp ugt i64 %0, %sub.ptr.sub
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  store i64 %sub.ptr.sub5, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call6 = call noundef i64 @_ZN5eastl10VectorBaseIhNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5)
  store i64 %call6, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call7 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call7, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call8 = call noundef ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9)
  store ptr %call8, ptr %pNewData, align 8
  %mpBegin9 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin9, align 8
  %mpEnd10 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd10, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call11 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPhS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call11, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %15 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrIhmEEvPT_T0_RKS1_(ptr noundef %13, i64 noundef %14, ptr noundef nonnull align 1 dereferenceable(1) %15)
  %16 = load i64, ptr %n.addr, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i8, ptr %17, i64 %16
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin12 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin12, align 8
  %mpEnd13 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %19 = load ptr, ptr %mpEnd13, align 8
  call void @_ZN5eastl8destructIPhEEvT_S2_(ptr noundef %18, ptr noundef %19)
  %mpBegin14 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %20 = load ptr, ptr %mpBegin14, align 8
  %call15 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %21 = load ptr, ptr %call15, align 8
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin16, align 8
  %sub.ptr.lhs.cast17 = ptrtoint ptr %21 to i64
  %sub.ptr.rhs.cast18 = ptrtoint ptr %22 to i64
  %sub.ptr.sub19 = sub i64 %sub.ptr.lhs.cast17, %sub.ptr.rhs.cast18
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEE6DoFreeEPhm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %20, i64 noundef %sub.ptr.sub19)
  %23 = load ptr, ptr %pNewData, align 8
  %mpBegin20 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  store ptr %23, ptr %mpBegin20, align 8
  %24 = load ptr, ptr %pNewEnd, align 8
  %mpEnd21 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %24, ptr %mpEnd21, align 8
  %25 = load ptr, ptr %pNewData, align 8
  %26 = load i64, ptr %nNewSize, align 8
  %add.ptr22 = getelementptr inbounds i8, ptr %25, i64 %26
  %call23 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr22, ptr %call23, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd24 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %27 = load ptr, ptr %mpEnd24, align 8
  %28 = load i64, ptr %n.addr, align 8
  %29 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrIhmEEvPT_T0_RKS1_(ptr noundef %27, i64 noundef %28, ptr noundef nonnull align 1 dereferenceable(1) %29)
  %30 = load i64, ptr %n.addr, align 8
  %mpEnd25 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %31 = load ptr, ptr %mpEnd25, align 8
  %add.ptr26 = getelementptr inbounds i8, ptr %31, i64 %30
  store ptr %add.ptr26, ptr %mpEnd25, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8destructIPhEEvT_S2_(ptr noundef %first, ptr noundef %last) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  call void @_ZN5eastl13destruct_implIPhEEvT_S2_NS_17integral_constantIbLb1EEE(ptr noundef %0, ptr noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl10VectorBaseIhNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %currentCapacity) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %currentCapacity.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %currentCapacity, ptr %currentCapacity.addr, align 8
  %0 = load i64, ptr %currentCapacity.addr, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %currentCapacity.addr, align 8
  %mul = mul i64 2, %1
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 1, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPhS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %dest.addr, align 8
  %call = call noundef ptr @_ZN5eastl22uninitialized_move_ptrIPhS1_S1_EET1_T_T0_S2_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIhNS_9allocatorEE6DoFreeEPhm(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %p, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %2, 1
  call void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_move_ptrIPhS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  %i = alloca %"class.eastl::generic_iterator.50", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.50", align 8
  %agg.tmp1 = alloca %"class.eastl::generic_iterator.50", align 8
  %agg.tmp2 = alloca %"class.eastl::generic_iterator.50", align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  call void @_ZN5eastl16generic_iteratorIPhvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(8) %first.addr)
  call void @_ZN5eastl16generic_iteratorIPhvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp1, ptr noundef nonnull align 8 dereferenceable(8) %last.addr)
  call void @_ZN5eastl16generic_iteratorIPhvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(8) %dest.addr)
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp1, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive5, align 8
  %call = call ptr @_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPhvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE(ptr %0, ptr %1, ptr %2)
  %coerce.dive6 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %i, i32 0, i32 0
  store ptr %call, ptr %coerce.dive6, align 8
  %call7 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPhvE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %i)
  %3 = load ptr, ptr %call7, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPhvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE(ptr %first.coerce, ptr %last.coerce, ptr %dest.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.50", align 8
  %first = alloca %"class.eastl::generic_iterator.50", align 8
  %last = alloca %"class.eastl::generic_iterator.50", align 8
  %dest = alloca %"class.eastl::generic_iterator.50", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.50", align 8
  %agg.tmp3 = alloca %"class.eastl::generic_iterator.50", align 8
  %agg.tmp4 = alloca %"class.eastl::generic_iterator.50", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %dest, i32 0, i32 0
  store ptr %dest.coerce, ptr %coerce.dive2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp4, ptr align 8 %dest, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  %coerce.dive7 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp4, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive7, align 8
  %call = call ptr @_ZN5eastl4copyINS_16generic_iteratorIPhvEES3_EET0_T_S5_S4_(ptr %0, ptr %1, ptr %2)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %retval, i32 0, i32 0
  store ptr %call, ptr %coerce.dive8, align 8
  %coerce.dive9 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive9, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPhvE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %this1, i32 0, i32 0
  ret ptr %mIterator
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl4copyINS_16generic_iteratorIPhvEES3_EET0_T_S5_S4_(ptr %first.coerce, ptr %last.coerce, ptr %result.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.50", align 8
  %first = alloca %"class.eastl::generic_iterator.50", align 8
  %last = alloca %"class.eastl::generic_iterator.50", align 8
  %result = alloca %"class.eastl::generic_iterator.50", align 8
  %isMove = alloca i8, align 1
  %agg.tmp = alloca %"class.eastl::generic_iterator.50", align 8
  %agg.tmp4 = alloca %"class.eastl::generic_iterator.50", align 8
  %agg.tmp7 = alloca %"class.eastl::generic_iterator.50", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %result, i32 0, i32 0
  store ptr %result.coerce, ptr %coerce.dive2, align 8
  store i8 0, ptr %isMove, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %coerce.dive3 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive3, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPhvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp4, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp4, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call6 = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPhvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp7, ptr align 8 %result, i64 8, i1 false)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp7, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive8, align 8
  %call9 = call ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPhNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_(ptr noundef %call, ptr noundef %call6, ptr %2)
  %coerce.dive10 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %retval, i32 0, i32 0
  store ptr %call9, ptr %coerce.dive10, align 8
  %coerce.dive11 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive11, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPhNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_(ptr noundef %first, ptr noundef %last, ptr %result.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.50", align 8
  %result = alloca %"class.eastl::generic_iterator.50", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %ref.tmp = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.50", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %result, i32 0, i32 0
  store ptr %result.coerce, ptr %coerce.dive, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorIPhEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %0)
  %1 = load ptr, ptr %last.addr, align 8
  %call1 = call noundef ptr @_ZN5eastl15unwrap_iteratorIPhEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %result, i64 8, i1 false)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive2, align 8
  %call3 = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPhvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %2)
  %call4 = call noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPhS1_EET1_T0_S3_S2_(ptr noundef %call, ptr noundef %call1, ptr noundef %call3)
  store ptr %call4, ptr %ref.tmp, align 8
  call void @_ZN5eastl16generic_iteratorIPhvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %retval, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive5, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPhvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %it.coerce) #0 comdat {
entry:
  %it = alloca %"class.eastl::generic_iterator.50", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.50", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %it, i32 0, i32 0
  store ptr %it.coerce, ptr %coerce.dive, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %it, i64 8, i1 false)
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive1, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPhvEELb1EE13get_unwrappedES3_(ptr %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPhS1_EET1_T0_S3_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %canBeMemmoved = alloca i8, align 1
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %canBeMemmoved, align 1
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %result.addr, align 8
  %call = call noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIhEEPT_PKS4_S7_S5_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorIPhEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %it) #0 comdat {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPhLb0EE13get_unwrappedES1_(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIhEEPT_PKS4_S7_S5_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %cmp = icmp eq ptr %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  br i1 %lnot1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %result.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %result.addr, align 8
  %4 = load ptr, ptr %first.addr, align 8
  %5 = load ptr, ptr %last.addr, align 8
  %6 = ptrtoint ptr %5 to i64
  %7 = load ptr, ptr %first.addr, align 8
  %8 = ptrtoint ptr %7 to i64
  %sub = sub i64 %6, %8
  call void @llvm.memmove.p0.p0.i64(ptr align 1 %3, ptr align 1 %4, i64 %sub, i1 false)
  %9 = load ptr, ptr %last.addr, align 8
  %10 = load ptr, ptr %first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %9 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 %sub.ptr.sub
  store ptr %add.ptr, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPhLb0EE13get_unwrappedES1_(ptr noundef %it) #1 comdat align 2 {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPhvEELb1EE13get_unwrappedES3_(ptr %it.coerce) #0 comdat align 2 {
entry:
  %it = alloca %"class.eastl::generic_iterator.50", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %it, i32 0, i32 0
  store ptr %it.coerce, ptr %coerce.dive, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPhvE6unwrapEv(ptr noundef nonnull align 8 dereferenceable(8) %it)
  %0 = load ptr, ptr %call, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPhvE6unwrapEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.50", ptr %this1, i32 0, i32 0
  ret ptr %mIterator
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl13destruct_implIPhEEvT_S2_NS_17integral_constantIbLb1EEE(ptr noundef %0, ptr noundef %1) #1 comdat {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp ugt i64 %0, %sub.ptr.sub
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  store i64 %sub.ptr.sub5, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call6 = call noundef i64 @_ZN5eastl10VectorBaseIhNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5)
  store i64 %call6, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call7 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call7, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call8 = call noundef ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9)
  store ptr %call8, ptr %pNewData, align 8
  %mpBegin9 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin9, align 8
  %mpEnd10 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd10, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call11 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPhS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call11, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %call12 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPhmEET_S2_T0_(ptr noundef %13, i64 noundef %14)
  %15 = load i64, ptr %n.addr, align 8
  %16 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i8, ptr %16, i64 %15
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin13 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %17 = load ptr, ptr %mpBegin13, align 8
  %mpEnd14 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %18 = load ptr, ptr %mpEnd14, align 8
  call void @_ZN5eastl8destructIPhEEvT_S2_(ptr noundef %17, ptr noundef %18)
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %19 = load ptr, ptr %mpBegin15, align 8
  %call16 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %20 = load ptr, ptr %call16, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %21 = load ptr, ptr %mpBegin17, align 8
  %sub.ptr.lhs.cast18 = ptrtoint ptr %20 to i64
  %sub.ptr.rhs.cast19 = ptrtoint ptr %21 to i64
  %sub.ptr.sub20 = sub i64 %sub.ptr.lhs.cast18, %sub.ptr.rhs.cast19
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEE6DoFreeEPhm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %19, i64 noundef %sub.ptr.sub20)
  %22 = load ptr, ptr %pNewData, align 8
  %mpBegin21 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  store ptr %22, ptr %mpBegin21, align 8
  %23 = load ptr, ptr %pNewEnd, align 8
  %mpEnd22 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %23, ptr %mpEnd22, align 8
  %24 = load ptr, ptr %pNewData, align 8
  %25 = load i64, ptr %nNewSize, align 8
  %add.ptr23 = getelementptr inbounds i8, ptr %24, i64 %25
  %call24 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr23, ptr %call24, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd25 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %26 = load ptr, ptr %mpEnd25, align 8
  %27 = load i64, ptr %n.addr, align 8
  %call26 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPhmEET_S2_T0_(ptr noundef %26, i64 noundef %27)
  %28 = load i64, ptr %n.addr, align 8
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %29 = load ptr, ptr %mpEnd27, align 8
  %add.ptr28 = getelementptr inbounds i8, ptr %29, i64 %28
  store ptr %add.ptr28, ptr %mpEnd27, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %3 = load ptr, ptr %pNewData, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPhS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  store ptr %call2, ptr %pNewEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  call void @_ZN5eastl8destructIPhEEvT_S2_(ptr noundef %4, ptr noundef %5)
  %mpBegin5 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin5, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %7 = load ptr, ptr %call6, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %8 = load ptr, ptr %mpBegin7, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEE6DoFreeEPhm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %6, i64 noundef %sub.ptr.sub)
  %9 = load ptr, ptr %pNewData, align 8
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  store ptr %9, ptr %mpBegin8, align 8
  %10 = load ptr, ptr %pNewEnd, align 8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %10, ptr %mpEnd9, align 8
  %11 = load ptr, ptr %pNewData, align 8
  %12 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %11, i64 %12
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call10, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %temp = alloca %"class.eastl::vector.7", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.55", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.55", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN5eastl6vectorIhNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl13move_iteratorIPhEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef %call)
  %call3 = call noundef ptr @_ZN5eastl6vectorIhNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl13move_iteratorIPhEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef %call3)
  %call4 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEEC2INS_13move_iteratorIPhEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(24) %temp, ptr %0, ptr %1, ptr noundef nonnull align 1 dereferenceable(1) %call4)
  invoke void @_ZN5eastl6vectorIhNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %temp)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl6vectorIhNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  ret void

lpad:                                             ; preds = %entry
  %2 = landingpad { ptr, i32 }
          cleanup
  %3 = extractvalue { ptr, i32 } %2, 0
  store ptr %3, ptr %exn.slot, align 8
  %4 = extractvalue { ptr, i32 } %2, 1
  store i32 %4, ptr %ehselector.slot, align 4
  call void @_ZN5eastl6vectorIhNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val6 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIhNS_9allocatorEE9DoReallocIPhEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %p, align 8
  %1 = load ptr, ptr %first.addr, align 8
  %2 = load ptr, ptr %last.addr, align 8
  %3 = load ptr, ptr %p, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPhS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %p, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl13move_iteratorIPhEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %mi) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %mi.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %mi, ptr %mi.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mi.addr, align 8
  store ptr %0, ptr %mIterator, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEEC2INS_13move_iteratorIPhEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %first = alloca %"class.eastl::move_iterator.55", align 8
  %last = alloca %"class.eastl::move_iterator.55", align 8
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.55", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.55", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr noundef nonnull align 1 dereferenceable(1) %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp3, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive6, align 8
  invoke void @_ZN5eastl6vectorIhNS_9allocatorEE6DoInitINS_13move_iteratorIPhEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr %1, ptr %2)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  ret void

lpad:                                             ; preds = %entry
  %3 = landingpad { ptr, i32 }
          cleanup
  %4 = extractvalue { ptr, i32 } %3, 0
  store ptr %4, ptr %exn.slot, align 8
  %5 = extractvalue { ptr, i32 } %3, 1
  store i32 %5, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val7 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPhEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  ret void

terminate.lpad:                                   ; preds = %entry
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE6DoInitINS_13move_iteratorIPhEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.55", align 8
  %last = alloca %"class.eastl::move_iterator.55", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.55", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.55", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  call void @_ZN5eastl6vectorIhNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPhEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr %0, ptr %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPhEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.55", align 8
  %last = alloca %"class.eastl::move_iterator.55", align 8
  %this.addr = alloca ptr, align 8
  %n = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.55", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.55", align 8
  %agg.tmp10 = alloca %"class.eastl::move_iterator.55", align 8
  %agg.tmp11 = alloca %"class.eastl::move_iterator.55", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPhEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %0, ptr %1)
  store i64 %call, ptr %n, align 8
  %2 = load i64, ptr %n, align 8
  %call6 = call noundef ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this2, i64 noundef %2)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this2, i32 0, i32 0
  store ptr %call6, ptr %mpBegin, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this2, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin7, align 8
  %4 = load i64, ptr %n, align 8
  %add.ptr = getelementptr inbounds i8, ptr %3, i64 %4
  %call8 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  store ptr %add.ptr, ptr %call8, align 8
  %call9 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  %5 = load ptr, ptr %call9, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this2, i32 0, i32 1
  store ptr %5, ptr %mpEnd, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp10, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp11, ptr align 8 %last, i64 8, i1 false)
  %mpBegin12 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this2, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin12, align 8
  %coerce.dive13 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp10, i32 0, i32 0
  %7 = load ptr, ptr %coerce.dive13, align 8
  %coerce.dive14 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp11, i32 0, i32 0
  %8 = load ptr, ptr %coerce.dive14, align 8
  %call15 = call noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPhEES3_S2_EET1_T_T0_S4_(ptr %7, ptr %8, ptr noundef %6)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPhEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %first.coerce, ptr %last.coerce) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.55", align 8
  %last = alloca %"class.eastl::move_iterator.55", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.55", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.55", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl13distance_implINS_13move_iteratorIPhEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE(ptr %0, ptr %1)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPhEES3_S2_EET1_T_T0_S4_(ptr %first.coerce, ptr %last.coerce, ptr noundef %result) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.55", align 8
  %last = alloca %"class.eastl::move_iterator.55", align 8
  %result.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.55", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.55", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %result, ptr %result.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %0 = load ptr, ptr %result.addr, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive4, align 8
  %call = call noundef ptr @_ZN5eastl18uninitialized_copyINS_13move_iteratorIPhEES2_EET0_T_S5_S4_(ptr %1, ptr %2, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl13distance_implINS_13move_iteratorIPhEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE(ptr %first.coerce, ptr %last.coerce) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.55", align 8
  %last = alloca %"class.eastl::move_iterator.55", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %call = call noundef i64 @_ZN5eastlmiIPhS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %last, ptr noundef nonnull align 8 dereferenceable(8) %first)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastlmiIPhS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef ptr @_ZNK5eastl13move_iteratorIPhE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef ptr @_ZNK5eastl13move_iteratorIPhE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %sub.ptr.lhs.cast = ptrtoint ptr %call to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %call1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  ret i64 %sub.ptr.sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl13move_iteratorIPhE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl18uninitialized_copyINS_13move_iteratorIPhEES2_EET0_T_S5_S4_(ptr %first.coerce, ptr %last.coerce, ptr noundef %result) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.55", align 8
  %last = alloca %"class.eastl::move_iterator.55", align 8
  %result.addr = alloca ptr, align 8
  %isTriviallyCopyable = alloca i8, align 1
  %isInputIteratorReferenceAddressable = alloca i8, align 1
  %areIteratorsContiguous = alloca i8, align 1
  %agg.tmp = alloca %"class.eastl::move_iterator.55", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.55", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %isTriviallyCopyable, align 1
  store i8 0, ptr %isInputIteratorReferenceAddressable, align 1
  store i8 0, ptr %areIteratorsContiguous, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %0 = load ptr, ptr %result.addr, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive4, align 8
  %call = call noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPhEES5_EET0_T_S8_S7_(ptr %1, ptr %2, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPhEES5_EET0_T_S8_S7_(ptr %first.coerce, ptr %last.coerce, ptr noundef %dest) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.55", align 8
  %last = alloca %"class.eastl::move_iterator.55", align 8
  %dest.addr = alloca ptr, align 8
  %currentDest = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %dest.addr, align 8
  store ptr %0, ptr %currentDest, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %call = call noundef zeroext i1 @_ZN5eastlneIPhS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %first, ptr noundef nonnull align 8 dereferenceable(8) %last)
  br i1 %call, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %currentDest, align 8
  %call2 = call noundef ptr @_ZN5eastl9addressofIhEEPT_RS1_(ptr noundef nonnull align 1 dereferenceable(1) %1) #9
  %call3 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl13move_iteratorIPhEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  %2 = load i8, ptr %call3, align 1
  store i8 %2, ptr %call2, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl13move_iteratorIPhEppEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  %3 = load ptr, ptr %currentDest, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %3, i32 1
  store ptr %incdec.ptr, ptr %currentDest, align 8
  br label %for.cond, !llvm.loop !60

for.end:                                          ; preds = %for.cond
  %4 = load ptr, ptr %currentDest, align 8
  ret ptr %4
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastlneIPhS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %call = call noundef zeroext i1 @_ZN5eastleqIPhS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZNK5eastl13move_iteratorIPhEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl13move_iteratorIPhEppEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.55", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %mIterator, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastleqIPhS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef ptr @_ZNK5eastl13move_iteratorIPhE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef ptr @_ZNK5eastl13move_iteratorIPhE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %cmp = icmp eq ptr %call, %call1
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIhNS_9allocatorEE16DoInsertValueEndIJhEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %args) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %nPrevSize, align 8
  %2 = load i64, ptr %nPrevSize, align 8
  %call = call noundef i64 @_ZN5eastl10VectorBaseIhNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %2)
  store i64 %call, ptr %nNewSize, align 8
  %3 = load i64, ptr %nNewSize, align 8
  %call2 = call noundef ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %3)
  store ptr %call2, ptr %pNewData, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  %6 = load ptr, ptr %pNewData, align 8
  %call5 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPhS1_S1_EET1_T_T0_S2_(ptr noundef %4, ptr noundef %5, ptr noundef %6)
  store ptr %call5, ptr %pNewEnd, align 8
  %7 = load ptr, ptr %pNewEnd, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %call6 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl7forwardIhEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 1 dereferenceable(1) %8) #9
  %9 = load i8, ptr %call6, align 1
  store i8 %9, ptr %7, align 1
  %10 = load ptr, ptr %pNewEnd, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %10, i32 1
  store ptr %incdec.ptr, ptr %pNewEnd, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %11 = load ptr, ptr %mpBegin7, align 8
  %mpEnd8 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  %12 = load ptr, ptr %mpEnd8, align 8
  call void @_ZN5eastl8destructIPhEEvT_S2_(ptr noundef %11, ptr noundef %12)
  %mpBegin9 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %13 = load ptr, ptr %mpBegin9, align 8
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %14 = load ptr, ptr %call10, align 8
  %mpBegin11 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  %15 = load ptr, ptr %mpBegin11, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %14 to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %15 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  call void @_ZN5eastl10VectorBaseIhNS_9allocatorEE6DoFreeEPhm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %13, i64 noundef %sub.ptr.sub14)
  %16 = load ptr, ptr %pNewData, align 8
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 0
  store ptr %16, ptr %mpBegin15, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %mpEnd16 = getelementptr inbounds %"struct.eastl::VectorBase.8", ptr %this1, i32 0, i32 1
  store ptr %17, ptr %mpEnd16, align 8
  %18 = load ptr, ptr %pNewData, align 8
  %19 = load i64, ptr %nNewSize, align 8
  %add.ptr = getelementptr inbounds i8, ptr %18, i64 %19
  %call17 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIhNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call17, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl7forwardIhEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 1 dereferenceable(1) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIhEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %dist) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dist.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %dist, ptr %dist.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %dist.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorIhEC2ERKNS_19bitvector_referenceIhEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %reference) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %reference.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mReference, ptr align 8 %0, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl24bitvector_const_iteratorIhEmiERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %mul = mul nsw i64 %sub.ptr.sub, 8
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference4, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %add = add i64 %mul, %3
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %4, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference5, i32 0, i32 1
  %5 = load i64, ptr %mnBitIndex6, align 8
  %sub = sub i64 %add, %5
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIhEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mnBitIndex, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex3 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference2, i32 0, i32 1
  %1 = load i64, ptr %mnBitIndex3, align 8
  %cmp = icmp eq i64 %1, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference4, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpBitWord, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference5, i32 0, i32 1
  store i64 0, ptr %mnBitIndex6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIhEleERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %cmp = icmp ult ptr %0, %2
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mpBitWord5 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference4, i32 0, i32 0
  %3 = load ptr, ptr %mpBitWord5, align 8
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %4, i32 0, i32 0
  %mpBitWord7 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference6, i32 0, i32 0
  %5 = load ptr, ptr %mpBitWord7, align 8
  %cmp8 = icmp eq ptr %3, %5
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %mReference9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference9, i32 0, i32 1
  %6 = load i64, ptr %mnBitIndex, align 8
  %7 = load ptr, ptr %rhs.addr, align 8
  %mReference10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.12", ptr %7, i32 0, i32 0
  %mnBitIndex11 = getelementptr inbounds %"class.eastl::bitvector_reference.13", ptr %mReference10, i32 0, i32 1
  %8 = load i64, ptr %mnBitIndex11, align 8
  %cmp12 = icmp ule i64 %6, %8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %9 = phi i1 [ false, %lor.rhs ], [ %cmp12, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %10 = phi i1 [ true, %entry ], [ %9, %land.end ]
  ret i1 %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIhEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIhEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIhEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %this1, i1 noundef zeroext %call)
  ret ptr %call2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIsNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::allocator", align 1
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 2
  call void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp, ptr noundef @.str.78)
  call void @_ZN5eastl15compressed_pairIPsNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPsNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %x, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %x, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.20", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %x.addr, align 8
  store ptr %1, ptr %mFirst, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIsNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPsNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIsNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPsNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef nonnull align 1 dereferenceable(1) %0)
  %1 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  store ptr %call, ptr %mpBegin, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin3, align 8
  %4 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %3, i64 %4
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPsmEET_S2_T0_(ptr noundef %first, i64 noundef %n) #1 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %currentDest = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  store ptr %0, ptr %currentDest, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %currentDest, align 8
  %call = call noundef ptr @_ZN5eastl9addressofIsEEPT_RS1_(ptr noundef nonnull align 2 dereferenceable(2) %2) #9
  store i16 0, ptr %call, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i64, ptr %n.addr, align 8
  %dec = add i64 %3, -1
  store i64 %dec, ptr %n.addr, align 8
  %4 = load ptr, ptr %currentDest, align 8
  %incdec.ptr = getelementptr inbounds i16, ptr %4, i32 1
  store ptr %incdec.ptr, ptr %currentDest, align 8
  br label %for.cond, !llvm.loop !61

for.end:                                          ; preds = %for.cond
  %5 = load ptr, ptr %currentDest, align 8
  ret ptr %5
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIsNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %call3, align 8
  %mpBegin4 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin4, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  %mul = mul i64 %sub.ptr.div, 2
  call void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPsNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %tobool = icmp ne i64 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %1, 2
  %call3 = call noundef ptr @_ZN5eastl15allocate_memoryINS_9allocatorEEEPvRT_mmm(ptr noundef nonnull align 1 dereferenceable(1) %call, i64 noundef %mul, i64 noundef 2, i64 noundef 0)
  store ptr %call3, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPsNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairIPsNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairIPsNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPsNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.20", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl9addressofIsEEPT_RS1_(ptr noundef nonnull align 2 dereferenceable(2) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24uninitialized_fill_n_ptrIsmEEvPT_T0_RKS1_(ptr noundef %first, i64 noundef %n, ptr noundef nonnull align 2 dereferenceable(2) %value) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.58", align 8
  store ptr %first, ptr %first.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @_ZN5eastl16generic_iteratorIPsvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(8) %first.addr)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive, align 8
  call void @_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPsvEEmsEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE(ptr %2, i64 noundef %0, ptr noundef nonnull align 2 dereferenceable(2) %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPsvEEmsEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 2 dereferenceable(2) %value) #0 comdat {
entry:
  %first = alloca %"class.eastl::generic_iterator.58", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.58", align 8
  %coerce = alloca %"class.eastl::generic_iterator.58", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive1, align 8
  %call = call ptr @_ZN5eastl6fill_nINS_16generic_iteratorIPsvEEmsEET_S4_T0_RKT1_(ptr %2, i64 noundef %0, ptr noundef nonnull align 2 dereferenceable(2) %1)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %coerce, i32 0, i32 0
  store ptr %call, ptr %coerce.dive2, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16generic_iteratorIPsvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %x) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %mIterator, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl6fill_nINS_16generic_iteratorIPsvEEmsEET_S4_T0_RKT1_(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 2 dereferenceable(2) %value) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.58", align 8
  %first = alloca %"class.eastl::generic_iterator.58", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.58", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive1, align 8
  %call = call ptr @_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPsvEEmsEET_S6_T0_RKT1_(ptr %2, i64 noundef %0, ptr noundef nonnull align 2 dereferenceable(2) %1)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %retval, i32 0, i32 0
  store ptr %call, ptr %coerce.dive2, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive3, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPsvEEmsEET_S6_T0_RKT1_(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 2 dereferenceable(2) %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::generic_iterator.58", align 8
  %first = alloca %"class.eastl::generic_iterator.58", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %temp = alloca i16, align 2
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %1 = load i16, ptr %0, align 2
  store i16 %1, ptr %temp, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %n.addr, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i16, ptr %temp, align 2
  %call = call noundef nonnull align 2 dereferenceable(2) ptr @_ZNK5eastl16generic_iteratorIPsvEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  store i16 %3, ptr %call, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl16generic_iteratorIPsvEppEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  br label %for.cond, !llvm.loop !62

for.end:                                          ; preds = %for.cond
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %first, i64 8, i1 false)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %retval, i32 0, i32 0
  %4 = load ptr, ptr %coerce.dive2, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 2 dereferenceable(2) ptr @_ZNK5eastl16generic_iteratorIPsvEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl16generic_iteratorIPsvEppEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  %incdec.ptr = getelementptr inbounds i16, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %mIterator, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %0, i32 0, i32 0
  call void @_ZN5eastl4swapIPsEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpBegin, ptr noundef nonnull align 8 dereferenceable(8) %mpBegin2) #9
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %x.addr, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapIPsEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpEnd, ptr noundef nonnull align 8 dereferenceable(8) %mpEnd3) #9
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 2
  %2 = load ptr, ptr %x.addr, align 8
  %mCapacityAllocator4 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %2, i32 0, i32 2
  call void @_ZN5eastl4swapIPsNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator4)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPsEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %temp = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPsEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %0) #9
  %1 = load ptr, ptr %call, align 8
  store ptr %1, ptr %temp, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPsEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %2) #9
  %3 = load ptr, ptr %call1, align 8
  %4 = load ptr, ptr %a.addr, align 8
  store ptr %3, ptr %4, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPsEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %temp) #9
  %5 = load ptr, ptr %call2, align 8
  %6 = load ptr, ptr %b.addr, align 8
  store ptr %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPsNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(8) %x, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat {
entry:
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl15compressed_pairIPsNS_9allocatorEE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPsEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPsNS_9allocatorEE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 8 dereferenceable(8) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPsNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.20", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %y.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPsNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  call void @_ZN5eastl7cp_swapIPsEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mFirst, ptr noundef nonnull align 8 dereferenceable(8) %call)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl7cp_swapIPsEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %t1, ptr noundef nonnull align 8 dereferenceable(8) %t2) #1 comdat {
entry:
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %tTemp = alloca ptr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  %0 = load ptr, ptr %t1.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %tTemp, align 8
  %2 = load ptr, ptr %t2.addr, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %t1.addr, align 8
  store ptr %3, ptr %4, align 8
  %5 = load ptr, ptr %tTemp, align 8
  %6 = load ptr, ptr %t2.addr, align 8
  store ptr %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %dist) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dist.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %dist, ptr %dist.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %dist.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %sub)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %backwards = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, %0
  store i64 %add, ptr %n.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %cmp = icmp sge i64 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %div = sdiv i64 %3, 16
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference2, i32 0, i32 0
  %4 = load ptr, ptr %mpBitWord, align 8
  %add.ptr = getelementptr inbounds i16, ptr %4, i64 %div
  store ptr %add.ptr, ptr %mpBitWord, align 8
  %5 = load i64, ptr %n.addr, align 8
  %rem = srem i64 %5, 16
  %mReference3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex4 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference3, i32 0, i32 1
  store i64 %rem, ptr %mnBitIndex4, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %6
  %add5 = add nsw i64 %sub, 16
  %sub6 = sub nsw i64 %add5, 1
  store i64 %sub6, ptr %backwards, align 8
  %7 = load i64, ptr %backwards, align 8
  %div7 = udiv i64 %7, 16
  %mReference8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mpBitWord9 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference8, i32 0, i32 0
  %8 = load ptr, ptr %mpBitWord9, align 8
  %idx.neg = sub i64 0, %div7
  %add.ptr10 = getelementptr inbounds i16, ptr %8, i64 %idx.neg
  store ptr %add.ptr10, ptr %mpBitWord9, align 8
  %9 = load i64, ptr %backwards, align 8
  %rem11 = urem i64 %9, 16
  %sub12 = sub i64 15, %rem11
  %mReference13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex14 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference13, i32 0, i32 1
  store i64 %sub12, ptr %mnBitIndex14, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPsNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPsNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPsNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPsNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.20", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE17DoInsertValuesEndEmRKs(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 2 dereferenceable(2) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 2
  store i64 %sub.ptr.div6, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call7 = call noundef i64 @_ZN5eastl10VectorBaseIsNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5)
  store i64 %call7, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call8 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call8, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call9 = call noundef ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9)
  store ptr %call9, ptr %pNewData, align 8
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd11, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call12 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPsS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call12, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %15 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrIsmEEvPT_T0_RKS1_(ptr noundef %13, i64 noundef %14, ptr noundef nonnull align 2 dereferenceable(2) %15)
  %16 = load i64, ptr %n.addr, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i16, ptr %17, i64 %16
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin13 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin13, align 8
  %mpEnd14 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %19 = load ptr, ptr %mpEnd14, align 8
  call void @_ZN5eastl8destructIPsEEvT_S2_(ptr noundef %18, ptr noundef %19)
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %20 = load ptr, ptr %mpBegin15, align 8
  %call16 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %21 = load ptr, ptr %call16, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin17, align 8
  %sub.ptr.lhs.cast18 = ptrtoint ptr %21 to i64
  %sub.ptr.rhs.cast19 = ptrtoint ptr %22 to i64
  %sub.ptr.sub20 = sub i64 %sub.ptr.lhs.cast18, %sub.ptr.rhs.cast19
  %sub.ptr.div21 = sdiv exact i64 %sub.ptr.sub20, 2
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEE6DoFreeEPsm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %20, i64 noundef %sub.ptr.div21)
  %23 = load ptr, ptr %pNewData, align 8
  %mpBegin22 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  store ptr %23, ptr %mpBegin22, align 8
  %24 = load ptr, ptr %pNewEnd, align 8
  %mpEnd23 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %24, ptr %mpEnd23, align 8
  %25 = load ptr, ptr %pNewData, align 8
  %26 = load i64, ptr %nNewSize, align 8
  %add.ptr24 = getelementptr inbounds i16, ptr %25, i64 %26
  %call25 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr24, ptr %call25, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd26 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %27 = load ptr, ptr %mpEnd26, align 8
  %28 = load i64, ptr %n.addr, align 8
  %29 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrIsmEEvPT_T0_RKS1_(ptr noundef %27, i64 noundef %28, ptr noundef nonnull align 2 dereferenceable(2) %29)
  %30 = load i64, ptr %n.addr, align 8
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %31 = load ptr, ptr %mpEnd27, align 8
  %add.ptr28 = getelementptr inbounds i16, ptr %31, i64 %30
  store ptr %add.ptr28, ptr %mpEnd27, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8destructIPsEEvT_S2_(ptr noundef %first, ptr noundef %last) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  call void @_ZN5eastl13destruct_implIPsEEvT_S2_NS_17integral_constantIbLb1EEE(ptr noundef %0, ptr noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl10VectorBaseIsNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %currentCapacity) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %currentCapacity.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %currentCapacity, ptr %currentCapacity.addr, align 8
  %0 = load i64, ptr %currentCapacity.addr, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %currentCapacity.addr, align 8
  %mul = mul i64 2, %1
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 1, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPsS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %dest.addr, align 8
  %call = call noundef ptr @_ZN5eastl22uninitialized_move_ptrIPsS1_S1_EET1_T_T0_S2_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIsNS_9allocatorEE6DoFreeEPsm(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %p, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %2, 2
  call void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_move_ptrIPsS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  %i = alloca %"class.eastl::generic_iterator.58", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.58", align 8
  %agg.tmp1 = alloca %"class.eastl::generic_iterator.58", align 8
  %agg.tmp2 = alloca %"class.eastl::generic_iterator.58", align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  call void @_ZN5eastl16generic_iteratorIPsvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(8) %first.addr)
  call void @_ZN5eastl16generic_iteratorIPsvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp1, ptr noundef nonnull align 8 dereferenceable(8) %last.addr)
  call void @_ZN5eastl16generic_iteratorIPsvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(8) %dest.addr)
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp1, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive5, align 8
  %call = call ptr @_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPsvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE(ptr %0, ptr %1, ptr %2)
  %coerce.dive6 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %i, i32 0, i32 0
  store ptr %call, ptr %coerce.dive6, align 8
  %call7 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPsvE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %i)
  %3 = load ptr, ptr %call7, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPsvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE(ptr %first.coerce, ptr %last.coerce, ptr %dest.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.58", align 8
  %first = alloca %"class.eastl::generic_iterator.58", align 8
  %last = alloca %"class.eastl::generic_iterator.58", align 8
  %dest = alloca %"class.eastl::generic_iterator.58", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.58", align 8
  %agg.tmp3 = alloca %"class.eastl::generic_iterator.58", align 8
  %agg.tmp4 = alloca %"class.eastl::generic_iterator.58", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %dest, i32 0, i32 0
  store ptr %dest.coerce, ptr %coerce.dive2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp4, ptr align 8 %dest, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  %coerce.dive7 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp4, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive7, align 8
  %call = call ptr @_ZN5eastl4copyINS_16generic_iteratorIPsvEES3_EET0_T_S5_S4_(ptr %0, ptr %1, ptr %2)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %retval, i32 0, i32 0
  store ptr %call, ptr %coerce.dive8, align 8
  %coerce.dive9 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive9, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPsvE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %this1, i32 0, i32 0
  ret ptr %mIterator
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl4copyINS_16generic_iteratorIPsvEES3_EET0_T_S5_S4_(ptr %first.coerce, ptr %last.coerce, ptr %result.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.58", align 8
  %first = alloca %"class.eastl::generic_iterator.58", align 8
  %last = alloca %"class.eastl::generic_iterator.58", align 8
  %result = alloca %"class.eastl::generic_iterator.58", align 8
  %isMove = alloca i8, align 1
  %agg.tmp = alloca %"class.eastl::generic_iterator.58", align 8
  %agg.tmp4 = alloca %"class.eastl::generic_iterator.58", align 8
  %agg.tmp7 = alloca %"class.eastl::generic_iterator.58", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %result, i32 0, i32 0
  store ptr %result.coerce, ptr %coerce.dive2, align 8
  store i8 0, ptr %isMove, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %coerce.dive3 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive3, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPsvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp4, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp4, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call6 = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPsvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp7, ptr align 8 %result, i64 8, i1 false)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp7, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive8, align 8
  %call9 = call ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPsNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_(ptr noundef %call, ptr noundef %call6, ptr %2)
  %coerce.dive10 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %retval, i32 0, i32 0
  store ptr %call9, ptr %coerce.dive10, align 8
  %coerce.dive11 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive11, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPsNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_(ptr noundef %first, ptr noundef %last, ptr %result.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.58", align 8
  %result = alloca %"class.eastl::generic_iterator.58", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %ref.tmp = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.58", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %result, i32 0, i32 0
  store ptr %result.coerce, ptr %coerce.dive, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorIPsEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %0)
  %1 = load ptr, ptr %last.addr, align 8
  %call1 = call noundef ptr @_ZN5eastl15unwrap_iteratorIPsEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %result, i64 8, i1 false)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive2, align 8
  %call3 = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPsvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %2)
  %call4 = call noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPsS1_EET1_T0_S3_S2_(ptr noundef %call, ptr noundef %call1, ptr noundef %call3)
  store ptr %call4, ptr %ref.tmp, align 8
  call void @_ZN5eastl16generic_iteratorIPsvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %retval, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive5, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPsvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %it.coerce) #0 comdat {
entry:
  %it = alloca %"class.eastl::generic_iterator.58", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.58", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %it, i32 0, i32 0
  store ptr %it.coerce, ptr %coerce.dive, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %it, i64 8, i1 false)
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive1, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPsvEELb1EE13get_unwrappedES3_(ptr %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPsS1_EET1_T0_S3_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %canBeMemmoved = alloca i8, align 1
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %canBeMemmoved, align 1
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %result.addr, align 8
  %call = call noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIsEEPT_PKS4_S7_S5_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorIPsEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %it) #0 comdat {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPsLb0EE13get_unwrappedES1_(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIsEEPT_PKS4_S7_S5_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %cmp = icmp eq ptr %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  br i1 %lnot1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %result.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %result.addr, align 8
  %4 = load ptr, ptr %first.addr, align 8
  %5 = load ptr, ptr %last.addr, align 8
  %6 = ptrtoint ptr %5 to i64
  %7 = load ptr, ptr %first.addr, align 8
  %8 = ptrtoint ptr %7 to i64
  %sub = sub i64 %6, %8
  call void @llvm.memmove.p0.p0.i64(ptr align 2 %3, ptr align 2 %4, i64 %sub, i1 false)
  %9 = load ptr, ptr %last.addr, align 8
  %10 = load ptr, ptr %first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %9 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  %add.ptr = getelementptr inbounds i16, ptr %3, i64 %sub.ptr.div
  store ptr %add.ptr, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPsLb0EE13get_unwrappedES1_(ptr noundef %it) #1 comdat align 2 {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPsvEELb1EE13get_unwrappedES3_(ptr %it.coerce) #0 comdat align 2 {
entry:
  %it = alloca %"class.eastl::generic_iterator.58", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %it, i32 0, i32 0
  store ptr %it.coerce, ptr %coerce.dive, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPsvE6unwrapEv(ptr noundef nonnull align 8 dereferenceable(8) %it)
  %0 = load ptr, ptr %call, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPsvE6unwrapEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.58", ptr %this1, i32 0, i32 0
  ret ptr %mIterator
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl13destruct_implIPsEEvT_S2_NS_17integral_constantIbLb1EEE(ptr noundef %0, ptr noundef %1) #1 comdat {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 2
  store i64 %sub.ptr.div6, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call7 = call noundef i64 @_ZN5eastl10VectorBaseIsNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5)
  store i64 %call7, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call8 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call8, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call9 = call noundef ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9)
  store ptr %call9, ptr %pNewData, align 8
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd11, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call12 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPsS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call12, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %call13 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPsmEET_S2_T0_(ptr noundef %13, i64 noundef %14)
  %15 = load i64, ptr %n.addr, align 8
  %16 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i16, ptr %16, i64 %15
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin14 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %17 = load ptr, ptr %mpBegin14, align 8
  %mpEnd15 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %18 = load ptr, ptr %mpEnd15, align 8
  call void @_ZN5eastl8destructIPsEEvT_S2_(ptr noundef %17, ptr noundef %18)
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %19 = load ptr, ptr %mpBegin16, align 8
  %call17 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %20 = load ptr, ptr %call17, align 8
  %mpBegin18 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %21 = load ptr, ptr %mpBegin18, align 8
  %sub.ptr.lhs.cast19 = ptrtoint ptr %20 to i64
  %sub.ptr.rhs.cast20 = ptrtoint ptr %21 to i64
  %sub.ptr.sub21 = sub i64 %sub.ptr.lhs.cast19, %sub.ptr.rhs.cast20
  %sub.ptr.div22 = sdiv exact i64 %sub.ptr.sub21, 2
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEE6DoFreeEPsm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %19, i64 noundef %sub.ptr.div22)
  %22 = load ptr, ptr %pNewData, align 8
  %mpBegin23 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  store ptr %22, ptr %mpBegin23, align 8
  %23 = load ptr, ptr %pNewEnd, align 8
  %mpEnd24 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %23, ptr %mpEnd24, align 8
  %24 = load ptr, ptr %pNewData, align 8
  %25 = load i64, ptr %nNewSize, align 8
  %add.ptr25 = getelementptr inbounds i16, ptr %24, i64 %25
  %call26 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr25, ptr %call26, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %26 = load ptr, ptr %mpEnd27, align 8
  %27 = load i64, ptr %n.addr, align 8
  %call28 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPsmEET_S2_T0_(ptr noundef %26, i64 noundef %27)
  %28 = load i64, ptr %n.addr, align 8
  %mpEnd29 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %29 = load ptr, ptr %mpEnd29, align 8
  %add.ptr30 = getelementptr inbounds i16, ptr %29, i64 %28
  store ptr %add.ptr30, ptr %mpEnd29, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %3 = load ptr, ptr %pNewData, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPsS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  store ptr %call2, ptr %pNewEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  call void @_ZN5eastl8destructIPsEEvT_S2_(ptr noundef %4, ptr noundef %5)
  %mpBegin5 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin5, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %7 = load ptr, ptr %call6, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %8 = load ptr, ptr %mpBegin7, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEE6DoFreeEPsm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %6, i64 noundef %sub.ptr.div)
  %9 = load ptr, ptr %pNewData, align 8
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  store ptr %9, ptr %mpBegin8, align 8
  %10 = load ptr, ptr %pNewEnd, align 8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %10, ptr %mpEnd9, align 8
  %11 = load ptr, ptr %pNewData, align 8
  %12 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i16, ptr %11, i64 %12
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call10, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %temp = alloca %"class.eastl::vector.17", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.63", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.63", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN5eastl6vectorIsNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl13move_iteratorIPsEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef %call)
  %call3 = call noundef ptr @_ZN5eastl6vectorIsNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl13move_iteratorIPsEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef %call3)
  %call4 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEEC2INS_13move_iteratorIPsEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(24) %temp, ptr %0, ptr %1, ptr noundef nonnull align 1 dereferenceable(1) %call4)
  invoke void @_ZN5eastl6vectorIsNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %temp)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl6vectorIsNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  ret void

lpad:                                             ; preds = %entry
  %2 = landingpad { ptr, i32 }
          cleanup
  %3 = extractvalue { ptr, i32 } %2, 0
  store ptr %3, ptr %exn.slot, align 8
  %4 = extractvalue { ptr, i32 } %2, 1
  store i32 %4, ptr %ehselector.slot, align 4
  call void @_ZN5eastl6vectorIsNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val6 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIsNS_9allocatorEE9DoReallocIPsEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %p, align 8
  %1 = load ptr, ptr %first.addr, align 8
  %2 = load ptr, ptr %last.addr, align 8
  %3 = load ptr, ptr %p, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPsS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %p, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl13move_iteratorIPsEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %mi) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %mi.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %mi, ptr %mi.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mi.addr, align 8
  store ptr %0, ptr %mIterator, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEEC2INS_13move_iteratorIPsEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %first = alloca %"class.eastl::move_iterator.63", align 8
  %last = alloca %"class.eastl::move_iterator.63", align 8
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.63", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.63", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr noundef nonnull align 1 dereferenceable(1) %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp3, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive6, align 8
  invoke void @_ZN5eastl6vectorIsNS_9allocatorEE6DoInitINS_13move_iteratorIPsEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr %1, ptr %2)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  ret void

lpad:                                             ; preds = %entry
  %3 = landingpad { ptr, i32 }
          cleanup
  %4 = extractvalue { ptr, i32 } %3, 0
  store ptr %4, ptr %exn.slot, align 8
  %5 = extractvalue { ptr, i32 } %3, 1
  store i32 %5, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val7 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPsEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  ret void

terminate.lpad:                                   ; preds = %entry
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE6DoInitINS_13move_iteratorIPsEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.63", align 8
  %last = alloca %"class.eastl::move_iterator.63", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.63", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.63", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  call void @_ZN5eastl6vectorIsNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPsEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr %0, ptr %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPsEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.63", align 8
  %last = alloca %"class.eastl::move_iterator.63", align 8
  %this.addr = alloca ptr, align 8
  %n = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.63", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.63", align 8
  %agg.tmp10 = alloca %"class.eastl::move_iterator.63", align 8
  %agg.tmp11 = alloca %"class.eastl::move_iterator.63", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPsEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %0, ptr %1)
  store i64 %call, ptr %n, align 8
  %2 = load i64, ptr %n, align 8
  %call6 = call noundef ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this2, i64 noundef %2)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this2, i32 0, i32 0
  store ptr %call6, ptr %mpBegin, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this2, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin7, align 8
  %4 = load i64, ptr %n, align 8
  %add.ptr = getelementptr inbounds i16, ptr %3, i64 %4
  %call8 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  store ptr %add.ptr, ptr %call8, align 8
  %call9 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  %5 = load ptr, ptr %call9, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this2, i32 0, i32 1
  store ptr %5, ptr %mpEnd, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp10, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp11, ptr align 8 %last, i64 8, i1 false)
  %mpBegin12 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this2, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin12, align 8
  %coerce.dive13 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp10, i32 0, i32 0
  %7 = load ptr, ptr %coerce.dive13, align 8
  %coerce.dive14 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp11, i32 0, i32 0
  %8 = load ptr, ptr %coerce.dive14, align 8
  %call15 = call noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPsEES3_S2_EET1_T_T0_S4_(ptr %7, ptr %8, ptr noundef %6)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPsEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %first.coerce, ptr %last.coerce) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.63", align 8
  %last = alloca %"class.eastl::move_iterator.63", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.63", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.63", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl13distance_implINS_13move_iteratorIPsEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE(ptr %0, ptr %1)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPsEES3_S2_EET1_T_T0_S4_(ptr %first.coerce, ptr %last.coerce, ptr noundef %result) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.63", align 8
  %last = alloca %"class.eastl::move_iterator.63", align 8
  %result.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.63", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.63", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %result, ptr %result.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %0 = load ptr, ptr %result.addr, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive4, align 8
  %call = call noundef ptr @_ZN5eastl18uninitialized_copyINS_13move_iteratorIPsEES2_EET0_T_S5_S4_(ptr %1, ptr %2, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl13distance_implINS_13move_iteratorIPsEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE(ptr %first.coerce, ptr %last.coerce) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.63", align 8
  %last = alloca %"class.eastl::move_iterator.63", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %call = call noundef i64 @_ZN5eastlmiIPsS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %last, ptr noundef nonnull align 8 dereferenceable(8) %first)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastlmiIPsS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef ptr @_ZNK5eastl13move_iteratorIPsE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef ptr @_ZNK5eastl13move_iteratorIPsE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %sub.ptr.lhs.cast = ptrtoint ptr %call to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %call1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl13move_iteratorIPsE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl18uninitialized_copyINS_13move_iteratorIPsEES2_EET0_T_S5_S4_(ptr %first.coerce, ptr %last.coerce, ptr noundef %result) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.63", align 8
  %last = alloca %"class.eastl::move_iterator.63", align 8
  %result.addr = alloca ptr, align 8
  %isTriviallyCopyable = alloca i8, align 1
  %isInputIteratorReferenceAddressable = alloca i8, align 1
  %areIteratorsContiguous = alloca i8, align 1
  %agg.tmp = alloca %"class.eastl::move_iterator.63", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.63", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %isTriviallyCopyable, align 1
  store i8 0, ptr %isInputIteratorReferenceAddressable, align 1
  store i8 0, ptr %areIteratorsContiguous, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %0 = load ptr, ptr %result.addr, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive4, align 8
  %call = call noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPsEES5_EET0_T_S8_S7_(ptr %1, ptr %2, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPsEES5_EET0_T_S8_S7_(ptr %first.coerce, ptr %last.coerce, ptr noundef %dest) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.63", align 8
  %last = alloca %"class.eastl::move_iterator.63", align 8
  %dest.addr = alloca ptr, align 8
  %currentDest = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %dest.addr, align 8
  store ptr %0, ptr %currentDest, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %call = call noundef zeroext i1 @_ZN5eastlneIPsS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %first, ptr noundef nonnull align 8 dereferenceable(8) %last)
  br i1 %call, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %currentDest, align 8
  %call2 = call noundef ptr @_ZN5eastl9addressofIsEEPT_RS1_(ptr noundef nonnull align 2 dereferenceable(2) %1) #9
  %call3 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZNK5eastl13move_iteratorIPsEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  %2 = load i16, ptr %call3, align 2
  store i16 %2, ptr %call2, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl13move_iteratorIPsEppEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  %3 = load ptr, ptr %currentDest, align 8
  %incdec.ptr = getelementptr inbounds i16, ptr %3, i32 1
  store ptr %incdec.ptr, ptr %currentDest, align 8
  br label %for.cond, !llvm.loop !63

for.end:                                          ; preds = %for.cond
  %4 = load ptr, ptr %currentDest, align 8
  ret ptr %4
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastlneIPsS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %call = call noundef zeroext i1 @_ZN5eastleqIPsS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 2 dereferenceable(2) ptr @_ZNK5eastl13move_iteratorIPsEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl13move_iteratorIPsEppEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.63", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  %incdec.ptr = getelementptr inbounds i16, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %mIterator, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastleqIPsS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef ptr @_ZNK5eastl13move_iteratorIPsE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef ptr @_ZNK5eastl13move_iteratorIPsE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %cmp = icmp eq ptr %call, %call1
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIsNS_9allocatorEE16DoInsertValueEndIJsEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 2 dereferenceable(2) %args) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  store i64 %sub.ptr.div, ptr %nPrevSize, align 8
  %2 = load i64, ptr %nPrevSize, align 8
  %call = call noundef i64 @_ZN5eastl10VectorBaseIsNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %2)
  store i64 %call, ptr %nNewSize, align 8
  %3 = load i64, ptr %nNewSize, align 8
  %call2 = call noundef ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %3)
  store ptr %call2, ptr %pNewData, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  %6 = load ptr, ptr %pNewData, align 8
  %call5 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPsS1_S1_EET1_T_T0_S2_(ptr noundef %4, ptr noundef %5, ptr noundef %6)
  store ptr %call5, ptr %pNewEnd, align 8
  %7 = load ptr, ptr %pNewEnd, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %call6 = call noundef nonnull align 2 dereferenceable(2) ptr @_ZN5eastl7forwardIsEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 2 dereferenceable(2) %8) #9
  %9 = load i16, ptr %call6, align 2
  store i16 %9, ptr %7, align 2
  %10 = load ptr, ptr %pNewEnd, align 8
  %incdec.ptr = getelementptr inbounds i16, ptr %10, i32 1
  store ptr %incdec.ptr, ptr %pNewEnd, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %11 = load ptr, ptr %mpBegin7, align 8
  %mpEnd8 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  %12 = load ptr, ptr %mpEnd8, align 8
  call void @_ZN5eastl8destructIPsEEvT_S2_(ptr noundef %11, ptr noundef %12)
  %mpBegin9 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %13 = load ptr, ptr %mpBegin9, align 8
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %14 = load ptr, ptr %call10, align 8
  %mpBegin11 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  %15 = load ptr, ptr %mpBegin11, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %14 to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %15 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  %sub.ptr.div15 = sdiv exact i64 %sub.ptr.sub14, 2
  call void @_ZN5eastl10VectorBaseIsNS_9allocatorEE6DoFreeEPsm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %13, i64 noundef %sub.ptr.div15)
  %16 = load ptr, ptr %pNewData, align 8
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 0
  store ptr %16, ptr %mpBegin16, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %mpEnd17 = getelementptr inbounds %"struct.eastl::VectorBase.18", ptr %this1, i32 0, i32 1
  store ptr %17, ptr %mpEnd17, align 8
  %18 = load ptr, ptr %pNewData, align 8
  %19 = load i64, ptr %nNewSize, align 8
  %add.ptr = getelementptr inbounds i16, ptr %18, i64 %19
  %call18 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIsNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call18, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 2 dereferenceable(2) ptr @_ZN5eastl7forwardIsEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 2 dereferenceable(2) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIsEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %dist) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dist.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %dist, ptr %dist.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %dist.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorIsEC2ERKNS_19bitvector_referenceIsEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %reference) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %reference.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mReference, ptr align 8 %0, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl24bitvector_const_iteratorIsEmiERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 2
  %mul = mul nsw i64 %sub.ptr.div, 16
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference4, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %add = add i64 %mul, %3
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %4, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference5, i32 0, i32 1
  %5 = load i64, ptr %mnBitIndex6, align 8
  %sub = sub i64 %add, %5
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIsEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mnBitIndex, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex3 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference2, i32 0, i32 1
  %1 = load i64, ptr %mnBitIndex3, align 8
  %cmp = icmp eq i64 %1, 16
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference4, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord, align 8
  %incdec.ptr = getelementptr inbounds i16, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpBitWord, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference5, i32 0, i32 1
  store i64 0, ptr %mnBitIndex6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIsEleERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %cmp = icmp ult ptr %0, %2
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mpBitWord5 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference4, i32 0, i32 0
  %3 = load ptr, ptr %mpBitWord5, align 8
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %4, i32 0, i32 0
  %mpBitWord7 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference6, i32 0, i32 0
  %5 = load ptr, ptr %mpBitWord7, align 8
  %cmp8 = icmp eq ptr %3, %5
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %mReference9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference9, i32 0, i32 1
  %6 = load i64, ptr %mnBitIndex, align 8
  %7 = load ptr, ptr %rhs.addr, align 8
  %mReference10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.22", ptr %7, i32 0, i32 0
  %mnBitIndex11 = getelementptr inbounds %"class.eastl::bitvector_reference.23", ptr %mReference10, i32 0, i32 1
  %8 = load i64, ptr %mnBitIndex11, align 8
  %cmp12 = icmp ule i64 %6, %8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %9 = phi i1 [ false, %lor.rhs ], [ %cmp12, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %10 = phi i1 [ true, %entry ], [ %9, %land.end ]
  ret i1 %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIsEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIsEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIsEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %this1, i1 noundef zeroext %call)
  ret ptr %call2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIiNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::allocator", align 1
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 2
  call void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp, ptr noundef @.str.78)
  call void @_ZN5eastl15compressed_pairIPiNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPiNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %x, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %x, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.30", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %x.addr, align 8
  store ptr %1, ptr %mFirst, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIiNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPiNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIiNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPiNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef nonnull align 1 dereferenceable(1) %0)
  %1 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  store ptr %call, ptr %mpBegin, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin3, align 8
  %4 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i32, ptr %3, i64 %4
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPimEET_S2_T0_(ptr noundef %first, i64 noundef %n) #1 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %currentDest = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  store ptr %0, ptr %currentDest, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %currentDest, align 8
  %call = call noundef ptr @_ZN5eastl9addressofIiEEPT_RS1_(ptr noundef nonnull align 4 dereferenceable(4) %2) #9
  store i32 0, ptr %call, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i64, ptr %n.addr, align 8
  %dec = add i64 %3, -1
  store i64 %dec, ptr %n.addr, align 8
  %4 = load ptr, ptr %currentDest, align 8
  %incdec.ptr = getelementptr inbounds i32, ptr %4, i32 1
  store ptr %incdec.ptr, ptr %currentDest, align 8
  br label %for.cond, !llvm.loop !64

for.end:                                          ; preds = %for.cond
  %5 = load ptr, ptr %currentDest, align 8
  ret ptr %5
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIiNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %call3, align 8
  %mpBegin4 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin4, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %mul = mul i64 %sub.ptr.div, 4
  call void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPiNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %tobool = icmp ne i64 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %1, 4
  %call3 = call noundef ptr @_ZN5eastl15allocate_memoryINS_9allocatorEEEPvRT_mmm(ptr noundef nonnull align 1 dereferenceable(1) %call, i64 noundef %mul, i64 noundef 4, i64 noundef 0)
  store ptr %call3, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPiNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairIPiNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairIPiNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPiNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.30", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl9addressofIiEEPT_RS1_(ptr noundef nonnull align 4 dereferenceable(4) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24uninitialized_fill_n_ptrIimEEvPT_T0_RKS1_(ptr noundef %first, i64 noundef %n, ptr noundef nonnull align 4 dereferenceable(4) %value) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.66", align 8
  store ptr %first, ptr %first.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @_ZN5eastl16generic_iteratorIPivEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(8) %first.addr)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive, align 8
  call void @_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPivEEmiEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE(ptr %2, i64 noundef %0, ptr noundef nonnull align 4 dereferenceable(4) %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPivEEmiEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 4 dereferenceable(4) %value) #0 comdat {
entry:
  %first = alloca %"class.eastl::generic_iterator.66", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.66", align 8
  %coerce = alloca %"class.eastl::generic_iterator.66", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive1, align 8
  %call = call ptr @_ZN5eastl6fill_nINS_16generic_iteratorIPivEEmiEET_S4_T0_RKT1_(ptr %2, i64 noundef %0, ptr noundef nonnull align 4 dereferenceable(4) %1)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %coerce, i32 0, i32 0
  store ptr %call, ptr %coerce.dive2, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16generic_iteratorIPivEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %x) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %mIterator, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl6fill_nINS_16generic_iteratorIPivEEmiEET_S4_T0_RKT1_(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 4 dereferenceable(4) %value) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.66", align 8
  %first = alloca %"class.eastl::generic_iterator.66", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.66", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive1, align 8
  %call = call ptr @_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPivEEmiEET_S6_T0_RKT1_(ptr %2, i64 noundef %0, ptr noundef nonnull align 4 dereferenceable(4) %1)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %retval, i32 0, i32 0
  store ptr %call, ptr %coerce.dive2, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive3, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPivEEmiEET_S6_T0_RKT1_(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 4 dereferenceable(4) %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::generic_iterator.66", align 8
  %first = alloca %"class.eastl::generic_iterator.66", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %temp = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %1 = load i32, ptr %0, align 4
  store i32 %1, ptr %temp, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %n.addr, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, ptr %temp, align 4
  %call = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK5eastl16generic_iteratorIPivEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  store i32 %3, ptr %call, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl16generic_iteratorIPivEppEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  br label %for.cond, !llvm.loop !65

for.end:                                          ; preds = %for.cond
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %first, i64 8, i1 false)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %retval, i32 0, i32 0
  %4 = load ptr, ptr %coerce.dive2, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK5eastl16generic_iteratorIPivEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl16generic_iteratorIPivEppEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  %incdec.ptr = getelementptr inbounds i32, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %mIterator, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %0, i32 0, i32 0
  call void @_ZN5eastl4swapIPiEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpBegin, ptr noundef nonnull align 8 dereferenceable(8) %mpBegin2) #9
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %x.addr, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapIPiEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpEnd, ptr noundef nonnull align 8 dereferenceable(8) %mpEnd3) #9
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 2
  %2 = load ptr, ptr %x.addr, align 8
  %mCapacityAllocator4 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %2, i32 0, i32 2
  call void @_ZN5eastl4swapIPiNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator4)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPiEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %temp = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPiEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %0) #9
  %1 = load ptr, ptr %call, align 8
  store ptr %1, ptr %temp, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPiEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %2) #9
  %3 = load ptr, ptr %call1, align 8
  %4 = load ptr, ptr %a.addr, align 8
  store ptr %3, ptr %4, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPiEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %temp) #9
  %5 = load ptr, ptr %call2, align 8
  %6 = load ptr, ptr %b.addr, align 8
  store ptr %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPiNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(8) %x, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat {
entry:
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl15compressed_pairIPiNS_9allocatorEE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPiEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPiNS_9allocatorEE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 8 dereferenceable(8) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPiNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.30", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %y.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPiNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  call void @_ZN5eastl7cp_swapIPiEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mFirst, ptr noundef nonnull align 8 dereferenceable(8) %call)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl7cp_swapIPiEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %t1, ptr noundef nonnull align 8 dereferenceable(8) %t2) #1 comdat {
entry:
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %tTemp = alloca ptr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  %0 = load ptr, ptr %t1.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %tTemp, align 8
  %2 = load ptr, ptr %t2.addr, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %t1.addr, align 8
  store ptr %3, ptr %4, align 8
  %5 = load ptr, ptr %tTemp, align 8
  %6 = load ptr, ptr %t2.addr, align 8
  store ptr %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %dist) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dist.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %dist, ptr %dist.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %dist.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %sub)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %backwards = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, %0
  store i64 %add, ptr %n.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %cmp = icmp sge i64 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %div = sdiv i64 %3, 32
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference2, i32 0, i32 0
  %4 = load ptr, ptr %mpBitWord, align 8
  %add.ptr = getelementptr inbounds i32, ptr %4, i64 %div
  store ptr %add.ptr, ptr %mpBitWord, align 8
  %5 = load i64, ptr %n.addr, align 8
  %rem = srem i64 %5, 32
  %mReference3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex4 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference3, i32 0, i32 1
  store i64 %rem, ptr %mnBitIndex4, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %6
  %add5 = add nsw i64 %sub, 32
  %sub6 = sub nsw i64 %add5, 1
  store i64 %sub6, ptr %backwards, align 8
  %7 = load i64, ptr %backwards, align 8
  %div7 = udiv i64 %7, 32
  %mReference8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mpBitWord9 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference8, i32 0, i32 0
  %8 = load ptr, ptr %mpBitWord9, align 8
  %idx.neg = sub i64 0, %div7
  %add.ptr10 = getelementptr inbounds i32, ptr %8, i64 %idx.neg
  store ptr %add.ptr10, ptr %mpBitWord9, align 8
  %9 = load i64, ptr %backwards, align 8
  %rem11 = urem i64 %9, 32
  %sub12 = sub i64 31, %rem11
  %mReference13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex14 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference13, i32 0, i32 1
  store i64 %sub12, ptr %mnBitIndex14, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPiNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPiNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPiNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPiNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.30", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE17DoInsertValuesEndEmRKi(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 4 dereferenceable(4) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 4
  store i64 %sub.ptr.div6, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call7 = call noundef i64 @_ZN5eastl10VectorBaseIiNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5)
  store i64 %call7, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call8 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call8, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call9 = call noundef ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9)
  store ptr %call9, ptr %pNewData, align 8
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd11, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call12 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPiS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call12, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %15 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrIimEEvPT_T0_RKS1_(ptr noundef %13, i64 noundef %14, ptr noundef nonnull align 4 dereferenceable(4) %15)
  %16 = load i64, ptr %n.addr, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i32, ptr %17, i64 %16
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin13 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin13, align 8
  %mpEnd14 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %19 = load ptr, ptr %mpEnd14, align 8
  call void @_ZN5eastl8destructIPiEEvT_S2_(ptr noundef %18, ptr noundef %19)
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %20 = load ptr, ptr %mpBegin15, align 8
  %call16 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %21 = load ptr, ptr %call16, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin17, align 8
  %sub.ptr.lhs.cast18 = ptrtoint ptr %21 to i64
  %sub.ptr.rhs.cast19 = ptrtoint ptr %22 to i64
  %sub.ptr.sub20 = sub i64 %sub.ptr.lhs.cast18, %sub.ptr.rhs.cast19
  %sub.ptr.div21 = sdiv exact i64 %sub.ptr.sub20, 4
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEE6DoFreeEPim(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %20, i64 noundef %sub.ptr.div21)
  %23 = load ptr, ptr %pNewData, align 8
  %mpBegin22 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  store ptr %23, ptr %mpBegin22, align 8
  %24 = load ptr, ptr %pNewEnd, align 8
  %mpEnd23 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %24, ptr %mpEnd23, align 8
  %25 = load ptr, ptr %pNewData, align 8
  %26 = load i64, ptr %nNewSize, align 8
  %add.ptr24 = getelementptr inbounds i32, ptr %25, i64 %26
  %call25 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr24, ptr %call25, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd26 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %27 = load ptr, ptr %mpEnd26, align 8
  %28 = load i64, ptr %n.addr, align 8
  %29 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrIimEEvPT_T0_RKS1_(ptr noundef %27, i64 noundef %28, ptr noundef nonnull align 4 dereferenceable(4) %29)
  %30 = load i64, ptr %n.addr, align 8
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %31 = load ptr, ptr %mpEnd27, align 8
  %add.ptr28 = getelementptr inbounds i32, ptr %31, i64 %30
  store ptr %add.ptr28, ptr %mpEnd27, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8destructIPiEEvT_S2_(ptr noundef %first, ptr noundef %last) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  call void @_ZN5eastl13destruct_implIPiEEvT_S2_NS_17integral_constantIbLb1EEE(ptr noundef %0, ptr noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl10VectorBaseIiNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %currentCapacity) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %currentCapacity.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %currentCapacity, ptr %currentCapacity.addr, align 8
  %0 = load i64, ptr %currentCapacity.addr, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %currentCapacity.addr, align 8
  %mul = mul i64 2, %1
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 1, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPiS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %dest.addr, align 8
  %call = call noundef ptr @_ZN5eastl22uninitialized_move_ptrIPiS1_S1_EET1_T_T0_S2_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIiNS_9allocatorEE6DoFreeEPim(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %p, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %2, 4
  call void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_move_ptrIPiS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  %i = alloca %"class.eastl::generic_iterator.66", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.66", align 8
  %agg.tmp1 = alloca %"class.eastl::generic_iterator.66", align 8
  %agg.tmp2 = alloca %"class.eastl::generic_iterator.66", align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  call void @_ZN5eastl16generic_iteratorIPivEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(8) %first.addr)
  call void @_ZN5eastl16generic_iteratorIPivEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp1, ptr noundef nonnull align 8 dereferenceable(8) %last.addr)
  call void @_ZN5eastl16generic_iteratorIPivEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(8) %dest.addr)
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp1, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive5, align 8
  %call = call ptr @_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPivEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE(ptr %0, ptr %1, ptr %2)
  %coerce.dive6 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %i, i32 0, i32 0
  store ptr %call, ptr %coerce.dive6, align 8
  %call7 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPivE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %i)
  %3 = load ptr, ptr %call7, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPivEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE(ptr %first.coerce, ptr %last.coerce, ptr %dest.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.66", align 8
  %first = alloca %"class.eastl::generic_iterator.66", align 8
  %last = alloca %"class.eastl::generic_iterator.66", align 8
  %dest = alloca %"class.eastl::generic_iterator.66", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.66", align 8
  %agg.tmp3 = alloca %"class.eastl::generic_iterator.66", align 8
  %agg.tmp4 = alloca %"class.eastl::generic_iterator.66", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %dest, i32 0, i32 0
  store ptr %dest.coerce, ptr %coerce.dive2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp4, ptr align 8 %dest, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  %coerce.dive7 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp4, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive7, align 8
  %call = call ptr @_ZN5eastl4copyINS_16generic_iteratorIPivEES3_EET0_T_S5_S4_(ptr %0, ptr %1, ptr %2)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %retval, i32 0, i32 0
  store ptr %call, ptr %coerce.dive8, align 8
  %coerce.dive9 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive9, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPivE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %this1, i32 0, i32 0
  ret ptr %mIterator
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl4copyINS_16generic_iteratorIPivEES3_EET0_T_S5_S4_(ptr %first.coerce, ptr %last.coerce, ptr %result.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.66", align 8
  %first = alloca %"class.eastl::generic_iterator.66", align 8
  %last = alloca %"class.eastl::generic_iterator.66", align 8
  %result = alloca %"class.eastl::generic_iterator.66", align 8
  %isMove = alloca i8, align 1
  %agg.tmp = alloca %"class.eastl::generic_iterator.66", align 8
  %agg.tmp4 = alloca %"class.eastl::generic_iterator.66", align 8
  %agg.tmp7 = alloca %"class.eastl::generic_iterator.66", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %result, i32 0, i32 0
  store ptr %result.coerce, ptr %coerce.dive2, align 8
  store i8 0, ptr %isMove, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %coerce.dive3 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive3, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPivEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp4, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp4, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call6 = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPivEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp7, ptr align 8 %result, i64 8, i1 false)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp7, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive8, align 8
  %call9 = call ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPiNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_(ptr noundef %call, ptr noundef %call6, ptr %2)
  %coerce.dive10 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %retval, i32 0, i32 0
  store ptr %call9, ptr %coerce.dive10, align 8
  %coerce.dive11 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive11, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPiNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_(ptr noundef %first, ptr noundef %last, ptr %result.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.66", align 8
  %result = alloca %"class.eastl::generic_iterator.66", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %ref.tmp = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.66", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %result, i32 0, i32 0
  store ptr %result.coerce, ptr %coerce.dive, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorIPiEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %0)
  %1 = load ptr, ptr %last.addr, align 8
  %call1 = call noundef ptr @_ZN5eastl15unwrap_iteratorIPiEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %result, i64 8, i1 false)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive2, align 8
  %call3 = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPivEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %2)
  %call4 = call noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPiS1_EET1_T0_S3_S2_(ptr noundef %call, ptr noundef %call1, ptr noundef %call3)
  store ptr %call4, ptr %ref.tmp, align 8
  call void @_ZN5eastl16generic_iteratorIPivEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %retval, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive5, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPivEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %it.coerce) #0 comdat {
entry:
  %it = alloca %"class.eastl::generic_iterator.66", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.66", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %it, i32 0, i32 0
  store ptr %it.coerce, ptr %coerce.dive, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %it, i64 8, i1 false)
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive1, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPivEELb1EE13get_unwrappedES3_(ptr %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPiS1_EET1_T0_S3_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %canBeMemmoved = alloca i8, align 1
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %canBeMemmoved, align 1
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %result.addr, align 8
  %call = call noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIiEEPT_PKS4_S7_S5_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorIPiEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %it) #0 comdat {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPiLb0EE13get_unwrappedES1_(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIiEEPT_PKS4_S7_S5_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %cmp = icmp eq ptr %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  br i1 %lnot1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %result.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %result.addr, align 8
  %4 = load ptr, ptr %first.addr, align 8
  %5 = load ptr, ptr %last.addr, align 8
  %6 = ptrtoint ptr %5 to i64
  %7 = load ptr, ptr %first.addr, align 8
  %8 = ptrtoint ptr %7 to i64
  %sub = sub i64 %6, %8
  call void @llvm.memmove.p0.p0.i64(ptr align 4 %3, ptr align 4 %4, i64 %sub, i1 false)
  %9 = load ptr, ptr %last.addr, align 8
  %10 = load ptr, ptr %first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %9 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %add.ptr = getelementptr inbounds i32, ptr %3, i64 %sub.ptr.div
  store ptr %add.ptr, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPiLb0EE13get_unwrappedES1_(ptr noundef %it) #1 comdat align 2 {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPivEELb1EE13get_unwrappedES3_(ptr %it.coerce) #0 comdat align 2 {
entry:
  %it = alloca %"class.eastl::generic_iterator.66", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %it, i32 0, i32 0
  store ptr %it.coerce, ptr %coerce.dive, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPivE6unwrapEv(ptr noundef nonnull align 8 dereferenceable(8) %it)
  %0 = load ptr, ptr %call, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPivE6unwrapEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.66", ptr %this1, i32 0, i32 0
  ret ptr %mIterator
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl13destruct_implIPiEEvT_S2_NS_17integral_constantIbLb1EEE(ptr noundef %0, ptr noundef %1) #1 comdat {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 4
  store i64 %sub.ptr.div6, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call7 = call noundef i64 @_ZN5eastl10VectorBaseIiNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5)
  store i64 %call7, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call8 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call8, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call9 = call noundef ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9)
  store ptr %call9, ptr %pNewData, align 8
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd11, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call12 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPiS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call12, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %call13 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPimEET_S2_T0_(ptr noundef %13, i64 noundef %14)
  %15 = load i64, ptr %n.addr, align 8
  %16 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i32, ptr %16, i64 %15
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin14 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %17 = load ptr, ptr %mpBegin14, align 8
  %mpEnd15 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %18 = load ptr, ptr %mpEnd15, align 8
  call void @_ZN5eastl8destructIPiEEvT_S2_(ptr noundef %17, ptr noundef %18)
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %19 = load ptr, ptr %mpBegin16, align 8
  %call17 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %20 = load ptr, ptr %call17, align 8
  %mpBegin18 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %21 = load ptr, ptr %mpBegin18, align 8
  %sub.ptr.lhs.cast19 = ptrtoint ptr %20 to i64
  %sub.ptr.rhs.cast20 = ptrtoint ptr %21 to i64
  %sub.ptr.sub21 = sub i64 %sub.ptr.lhs.cast19, %sub.ptr.rhs.cast20
  %sub.ptr.div22 = sdiv exact i64 %sub.ptr.sub21, 4
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEE6DoFreeEPim(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %19, i64 noundef %sub.ptr.div22)
  %22 = load ptr, ptr %pNewData, align 8
  %mpBegin23 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  store ptr %22, ptr %mpBegin23, align 8
  %23 = load ptr, ptr %pNewEnd, align 8
  %mpEnd24 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %23, ptr %mpEnd24, align 8
  %24 = load ptr, ptr %pNewData, align 8
  %25 = load i64, ptr %nNewSize, align 8
  %add.ptr25 = getelementptr inbounds i32, ptr %24, i64 %25
  %call26 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr25, ptr %call26, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %26 = load ptr, ptr %mpEnd27, align 8
  %27 = load i64, ptr %n.addr, align 8
  %call28 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPimEET_S2_T0_(ptr noundef %26, i64 noundef %27)
  %28 = load i64, ptr %n.addr, align 8
  %mpEnd29 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %29 = load ptr, ptr %mpEnd29, align 8
  %add.ptr30 = getelementptr inbounds i32, ptr %29, i64 %28
  store ptr %add.ptr30, ptr %mpEnd29, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %3 = load ptr, ptr %pNewData, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPiS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  store ptr %call2, ptr %pNewEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  call void @_ZN5eastl8destructIPiEEvT_S2_(ptr noundef %4, ptr noundef %5)
  %mpBegin5 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin5, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %7 = load ptr, ptr %call6, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %8 = load ptr, ptr %mpBegin7, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEE6DoFreeEPim(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %6, i64 noundef %sub.ptr.div)
  %9 = load ptr, ptr %pNewData, align 8
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  store ptr %9, ptr %mpBegin8, align 8
  %10 = load ptr, ptr %pNewEnd, align 8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %10, ptr %mpEnd9, align 8
  %11 = load ptr, ptr %pNewData, align 8
  %12 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i32, ptr %11, i64 %12
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call10, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %temp = alloca %"class.eastl::vector.27", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.71", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.71", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN5eastl6vectorIiNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl13move_iteratorIPiEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef %call)
  %call3 = call noundef ptr @_ZN5eastl6vectorIiNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl13move_iteratorIPiEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef %call3)
  %call4 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEEC2INS_13move_iteratorIPiEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(24) %temp, ptr %0, ptr %1, ptr noundef nonnull align 1 dereferenceable(1) %call4)
  invoke void @_ZN5eastl6vectorIiNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %temp)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl6vectorIiNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  ret void

lpad:                                             ; preds = %entry
  %2 = landingpad { ptr, i32 }
          cleanup
  %3 = extractvalue { ptr, i32 } %2, 0
  store ptr %3, ptr %exn.slot, align 8
  %4 = extractvalue { ptr, i32 } %2, 1
  store i32 %4, ptr %ehselector.slot, align 4
  call void @_ZN5eastl6vectorIiNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val6 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIiNS_9allocatorEE9DoReallocIPiEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %p, align 8
  %1 = load ptr, ptr %first.addr, align 8
  %2 = load ptr, ptr %last.addr, align 8
  %3 = load ptr, ptr %p, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPiS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %p, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl13move_iteratorIPiEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %mi) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %mi.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %mi, ptr %mi.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mi.addr, align 8
  store ptr %0, ptr %mIterator, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEEC2INS_13move_iteratorIPiEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %first = alloca %"class.eastl::move_iterator.71", align 8
  %last = alloca %"class.eastl::move_iterator.71", align 8
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.71", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.71", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr noundef nonnull align 1 dereferenceable(1) %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp3, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive6, align 8
  invoke void @_ZN5eastl6vectorIiNS_9allocatorEE6DoInitINS_13move_iteratorIPiEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr %1, ptr %2)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  ret void

lpad:                                             ; preds = %entry
  %3 = landingpad { ptr, i32 }
          cleanup
  %4 = extractvalue { ptr, i32 } %3, 0
  store ptr %4, ptr %exn.slot, align 8
  %5 = extractvalue { ptr, i32 } %3, 1
  store i32 %5, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val7 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPiEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  ret void

terminate.lpad:                                   ; preds = %entry
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE6DoInitINS_13move_iteratorIPiEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.71", align 8
  %last = alloca %"class.eastl::move_iterator.71", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.71", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.71", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  call void @_ZN5eastl6vectorIiNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPiEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr %0, ptr %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPiEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.71", align 8
  %last = alloca %"class.eastl::move_iterator.71", align 8
  %this.addr = alloca ptr, align 8
  %n = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.71", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.71", align 8
  %agg.tmp10 = alloca %"class.eastl::move_iterator.71", align 8
  %agg.tmp11 = alloca %"class.eastl::move_iterator.71", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPiEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %0, ptr %1)
  store i64 %call, ptr %n, align 8
  %2 = load i64, ptr %n, align 8
  %call6 = call noundef ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this2, i64 noundef %2)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this2, i32 0, i32 0
  store ptr %call6, ptr %mpBegin, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this2, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin7, align 8
  %4 = load i64, ptr %n, align 8
  %add.ptr = getelementptr inbounds i32, ptr %3, i64 %4
  %call8 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  store ptr %add.ptr, ptr %call8, align 8
  %call9 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  %5 = load ptr, ptr %call9, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this2, i32 0, i32 1
  store ptr %5, ptr %mpEnd, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp10, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp11, ptr align 8 %last, i64 8, i1 false)
  %mpBegin12 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this2, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin12, align 8
  %coerce.dive13 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp10, i32 0, i32 0
  %7 = load ptr, ptr %coerce.dive13, align 8
  %coerce.dive14 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp11, i32 0, i32 0
  %8 = load ptr, ptr %coerce.dive14, align 8
  %call15 = call noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPiEES3_S2_EET1_T_T0_S4_(ptr %7, ptr %8, ptr noundef %6)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPiEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %first.coerce, ptr %last.coerce) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.71", align 8
  %last = alloca %"class.eastl::move_iterator.71", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.71", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.71", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl13distance_implINS_13move_iteratorIPiEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE(ptr %0, ptr %1)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPiEES3_S2_EET1_T_T0_S4_(ptr %first.coerce, ptr %last.coerce, ptr noundef %result) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.71", align 8
  %last = alloca %"class.eastl::move_iterator.71", align 8
  %result.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.71", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.71", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %result, ptr %result.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %0 = load ptr, ptr %result.addr, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive4, align 8
  %call = call noundef ptr @_ZN5eastl18uninitialized_copyINS_13move_iteratorIPiEES2_EET0_T_S5_S4_(ptr %1, ptr %2, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl13distance_implINS_13move_iteratorIPiEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE(ptr %first.coerce, ptr %last.coerce) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.71", align 8
  %last = alloca %"class.eastl::move_iterator.71", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %call = call noundef i64 @_ZN5eastlmiIPiS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %last, ptr noundef nonnull align 8 dereferenceable(8) %first)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastlmiIPiS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef ptr @_ZNK5eastl13move_iteratorIPiE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef ptr @_ZNK5eastl13move_iteratorIPiE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %sub.ptr.lhs.cast = ptrtoint ptr %call to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %call1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl13move_iteratorIPiE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl18uninitialized_copyINS_13move_iteratorIPiEES2_EET0_T_S5_S4_(ptr %first.coerce, ptr %last.coerce, ptr noundef %result) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.71", align 8
  %last = alloca %"class.eastl::move_iterator.71", align 8
  %result.addr = alloca ptr, align 8
  %isTriviallyCopyable = alloca i8, align 1
  %isInputIteratorReferenceAddressable = alloca i8, align 1
  %areIteratorsContiguous = alloca i8, align 1
  %agg.tmp = alloca %"class.eastl::move_iterator.71", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.71", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %isTriviallyCopyable, align 1
  store i8 0, ptr %isInputIteratorReferenceAddressable, align 1
  store i8 0, ptr %areIteratorsContiguous, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %0 = load ptr, ptr %result.addr, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive4, align 8
  %call = call noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPiEES5_EET0_T_S8_S7_(ptr %1, ptr %2, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPiEES5_EET0_T_S8_S7_(ptr %first.coerce, ptr %last.coerce, ptr noundef %dest) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.71", align 8
  %last = alloca %"class.eastl::move_iterator.71", align 8
  %dest.addr = alloca ptr, align 8
  %currentDest = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %dest.addr, align 8
  store ptr %0, ptr %currentDest, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %call = call noundef zeroext i1 @_ZN5eastlneIPiS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %first, ptr noundef nonnull align 8 dereferenceable(8) %last)
  br i1 %call, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %currentDest, align 8
  %call2 = call noundef ptr @_ZN5eastl9addressofIiEEPT_RS1_(ptr noundef nonnull align 4 dereferenceable(4) %1) #9
  %call3 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZNK5eastl13move_iteratorIPiEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  %2 = load i32, ptr %call3, align 4
  store i32 %2, ptr %call2, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl13move_iteratorIPiEppEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  %3 = load ptr, ptr %currentDest, align 8
  %incdec.ptr = getelementptr inbounds i32, ptr %3, i32 1
  store ptr %incdec.ptr, ptr %currentDest, align 8
  br label %for.cond, !llvm.loop !66

for.end:                                          ; preds = %for.cond
  %4 = load ptr, ptr %currentDest, align 8
  ret ptr %4
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastlneIPiS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %call = call noundef zeroext i1 @_ZN5eastleqIPiS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZNK5eastl13move_iteratorIPiEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl13move_iteratorIPiEppEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.71", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  %incdec.ptr = getelementptr inbounds i32, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %mIterator, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastleqIPiS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef ptr @_ZNK5eastl13move_iteratorIPiE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef ptr @_ZNK5eastl13move_iteratorIPiE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %cmp = icmp eq ptr %call, %call1
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIiNS_9allocatorEE16DoInsertValueEndIJiEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 4 dereferenceable(4) %args) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  store i64 %sub.ptr.div, ptr %nPrevSize, align 8
  %2 = load i64, ptr %nPrevSize, align 8
  %call = call noundef i64 @_ZN5eastl10VectorBaseIiNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %2)
  store i64 %call, ptr %nNewSize, align 8
  %3 = load i64, ptr %nNewSize, align 8
  %call2 = call noundef ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %3)
  store ptr %call2, ptr %pNewData, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  %6 = load ptr, ptr %pNewData, align 8
  %call5 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPiS1_S1_EET1_T_T0_S2_(ptr noundef %4, ptr noundef %5, ptr noundef %6)
  store ptr %call5, ptr %pNewEnd, align 8
  %7 = load ptr, ptr %pNewEnd, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %call6 = call noundef nonnull align 4 dereferenceable(4) ptr @_ZN5eastl7forwardIiEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 4 dereferenceable(4) %8) #9
  %9 = load i32, ptr %call6, align 4
  store i32 %9, ptr %7, align 4
  %10 = load ptr, ptr %pNewEnd, align 8
  %incdec.ptr = getelementptr inbounds i32, ptr %10, i32 1
  store ptr %incdec.ptr, ptr %pNewEnd, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %11 = load ptr, ptr %mpBegin7, align 8
  %mpEnd8 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  %12 = load ptr, ptr %mpEnd8, align 8
  call void @_ZN5eastl8destructIPiEEvT_S2_(ptr noundef %11, ptr noundef %12)
  %mpBegin9 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %13 = load ptr, ptr %mpBegin9, align 8
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %14 = load ptr, ptr %call10, align 8
  %mpBegin11 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  %15 = load ptr, ptr %mpBegin11, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %14 to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %15 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  %sub.ptr.div15 = sdiv exact i64 %sub.ptr.sub14, 4
  call void @_ZN5eastl10VectorBaseIiNS_9allocatorEE6DoFreeEPim(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %13, i64 noundef %sub.ptr.div15)
  %16 = load ptr, ptr %pNewData, align 8
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 0
  store ptr %16, ptr %mpBegin16, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %mpEnd17 = getelementptr inbounds %"struct.eastl::VectorBase.28", ptr %this1, i32 0, i32 1
  store ptr %17, ptr %mpEnd17, align 8
  %18 = load ptr, ptr %pNewData, align 8
  %19 = load i64, ptr %nNewSize, align 8
  %add.ptr = getelementptr inbounds i32, ptr %18, i64 %19
  %call18 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIiNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call18, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 4 dereferenceable(4) ptr @_ZN5eastl7forwardIiEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 4 dereferenceable(4) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIiEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %dist) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dist.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %dist, ptr %dist.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %dist.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorIiEC2ERKNS_19bitvector_referenceIiEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %reference) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %reference.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mReference, ptr align 8 %0, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl24bitvector_const_iteratorIiEmiERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 4
  %mul = mul nsw i64 %sub.ptr.div, 32
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference4, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %add = add i64 %mul, %3
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %4, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference5, i32 0, i32 1
  %5 = load i64, ptr %mnBitIndex6, align 8
  %sub = sub i64 %add, %5
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIiEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mnBitIndex, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex3 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference2, i32 0, i32 1
  %1 = load i64, ptr %mnBitIndex3, align 8
  %cmp = icmp eq i64 %1, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference4, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord, align 8
  %incdec.ptr = getelementptr inbounds i32, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpBitWord, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference5, i32 0, i32 1
  store i64 0, ptr %mnBitIndex6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIiEleERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %cmp = icmp ult ptr %0, %2
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mpBitWord5 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference4, i32 0, i32 0
  %3 = load ptr, ptr %mpBitWord5, align 8
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %4, i32 0, i32 0
  %mpBitWord7 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference6, i32 0, i32 0
  %5 = load ptr, ptr %mpBitWord7, align 8
  %cmp8 = icmp eq ptr %3, %5
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %mReference9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference9, i32 0, i32 1
  %6 = load i64, ptr %mnBitIndex, align 8
  %7 = load ptr, ptr %rhs.addr, align 8
  %mReference10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.32", ptr %7, i32 0, i32 0
  %mnBitIndex11 = getelementptr inbounds %"class.eastl::bitvector_reference.33", ptr %mReference10, i32 0, i32 1
  %8 = load i64, ptr %mnBitIndex11, align 8
  %cmp12 = icmp ule i64 %6, %8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %9 = phi i1 [ false, %lor.rhs ], [ %cmp12, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %10 = phi i1 [ true, %entry ], [ %9, %land.end ]
  ret i1 %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIiEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIiEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIiEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %this1, i1 noundef zeroext %call)
  ret ptr %call2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIlNS_9allocatorEEC2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %ref.tmp = alloca %"class.eastl::allocator", align 1
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 2
  call void @_ZN5eastl9allocatorC2EPKc(ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp, ptr noundef @.str.78)
  call void @_ZN5eastl15compressed_pairIPlNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 1 dereferenceable(1) %ref.tmp)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPlNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %x, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef %0, ptr noundef nonnull align 1 dereferenceable(1) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %x, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.40", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %x.addr, align 8
  store ptr %1, ptr %mFirst, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIlNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  store ptr null, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr null, ptr %mpEnd, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPlNS_9allocatorEEC2ES1_RKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef null, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIlNS_9allocatorEEC2EmRKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %allocator.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 2
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl15compressed_pairIPlNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef nonnull align 1 dereferenceable(1) %0)
  %1 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %1)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  store ptr %call, ptr %mpBegin, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %2 = load ptr, ptr %mpBegin2, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %2, ptr %mpEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin3, align 8
  %4 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 %4
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call4, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPlmEET_S2_T0_(ptr noundef %first, i64 noundef %n) #1 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %currentDest = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  store ptr %0, ptr %currentDest, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %currentDest, align 8
  %call = call noundef ptr @_ZN5eastl9addressofIlEEPT_RS1_(ptr noundef nonnull align 8 dereferenceable(8) %2) #9
  store i64 0, ptr %call, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %3 = load i64, ptr %n.addr, align 8
  %dec = add i64 %3, -1
  store i64 %dec, ptr %n.addr, align 8
  %4 = load ptr, ptr %currentDest, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %4, i32 1
  store ptr %incdec.ptr, ptr %currentDest, align 8
  br label %for.cond, !llvm.loop !67

for.end:                                          ; preds = %for.cond
  %5 = load ptr, ptr %currentDest, align 8
  ret ptr %5
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIlNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin2, align 8
  %call3 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %2 = load ptr, ptr %call3, align 8
  %mpBegin4 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin4, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %mul = mul i64 %sub.ptr.div, 8
  call void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPlNS_9allocatorEEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %tobool = icmp ne i64 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  br i1 %lnot2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %1, 8
  %call3 = call noundef ptr @_ZN5eastl15allocate_memoryINS_9allocatorEEEPvRT_mmm(ptr noundef nonnull align 1 dereferenceable(1) %call, i64 noundef %mul, i64 noundef 8, i64 noundef 0)
  store ptr %call3, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPlNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EEC2ERKS2_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 1 dereferenceable(1) %y) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl9allocatorC2ERKS0_(ptr noundef nonnull align 1 dereferenceable(1) %this1, ptr noundef nonnull align 1 dereferenceable(1) %0)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairIPlNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl15compressed_pairIPlNS_9allocatorEE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EE6secondEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPlNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.40", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl9addressofIlEEPT_RS1_(ptr noundef nonnull align 8 dereferenceable(8) %value) #1 comdat {
entry:
  %value.addr = alloca ptr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl24uninitialized_fill_n_ptrIlmEEvPT_T0_RKS1_(ptr noundef %first, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.74", align 8
  store ptr %first, ptr %first.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @_ZN5eastl16generic_iteratorIPlvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(8) %first.addr)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive, align 8
  call void @_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPlvEEmlEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE(ptr %2, i64 noundef %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8Internal25uninitialized_fill_n_implINS_16generic_iteratorIPlvEEmlEEvT_T0_RKT1_NS_17integral_constantIbLb1EEE(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat {
entry:
  %first = alloca %"class.eastl::generic_iterator.74", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.74", align 8
  %coerce = alloca %"class.eastl::generic_iterator.74", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive1, align 8
  %call = call ptr @_ZN5eastl6fill_nINS_16generic_iteratorIPlvEEmlEET_S4_T0_RKT1_(ptr %2, i64 noundef %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %coerce, i32 0, i32 0
  store ptr %call, ptr %coerce.dive2, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl16generic_iteratorIPlvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %x) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %mIterator, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl6fill_nINS_16generic_iteratorIPlvEEmlEET_S4_T0_RKT1_(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.74", align 8
  %first = alloca %"class.eastl::generic_iterator.74", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.74", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %0 = load i64, ptr %n.addr, align 8
  %1 = load ptr, ptr %value.addr, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive1, align 8
  %call = call ptr @_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPlvEEmlEET_S6_T0_RKT1_(ptr %2, i64 noundef %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %retval, i32 0, i32 0
  store ptr %call, ptr %coerce.dive2, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive3, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl10fill_n_impILb1EE7do_fillINS_16generic_iteratorIPlvEEmlEET_S6_T0_RKT1_(ptr %first.coerce, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat align 2 {
entry:
  %retval = alloca %"class.eastl::generic_iterator.74", align 8
  %first = alloca %"class.eastl::generic_iterator.74", align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %temp = alloca i64, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %0 = load ptr, ptr %value.addr, align 8
  %1 = load i64, ptr %0, align 8
  store i64 %1, ptr %temp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %n.addr, align 8
  %dec = add i64 %2, -1
  store i64 %dec, ptr %n.addr, align 8
  %cmp = icmp ugt i64 %2, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, ptr %temp, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPlvEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  store i64 %3, ptr %call, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl16generic_iteratorIPlvEppEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  br label %for.cond, !llvm.loop !68

for.end:                                          ; preds = %for.cond
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %first, i64 8, i1 false)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %retval, i32 0, i32 0
  %4 = load ptr, ptr %coerce.dive2, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPlvEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl16generic_iteratorIPlvEppEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %mIterator, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(24) %x) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %x.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %x, ptr %x.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %x.addr, align 8
  %mpBegin2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %0, i32 0, i32 0
  call void @_ZN5eastl4swapIPlEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpBegin, ptr noundef nonnull align 8 dereferenceable(8) %mpBegin2) #9
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %x.addr, align 8
  %mpEnd3 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %1, i32 0, i32 1
  call void @_ZN5eastl4swapIPlEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mpEnd, ptr noundef nonnull align 8 dereferenceable(8) %mpEnd3) #9
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 2
  %2 = load ptr, ptr %x.addr, align 8
  %mCapacityAllocator4 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %2, i32 0, i32 2
  call void @_ZN5eastl4swapIPlNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator, ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator4)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPlEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %temp = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPlEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %0) #9
  %1 = load ptr, ptr %call, align 8
  store ptr %1, ptr %temp, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPlEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %2) #9
  %3 = load ptr, ptr %call1, align 8
  %4 = load ptr, ptr %a.addr, align 8
  store ptr %3, ptr %4, align 8
  %call2 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPlEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %temp) #9
  %5 = load ptr, ptr %call2, align 8
  %6 = load ptr, ptr %b.addr, align 8
  store ptr %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl4swapIPlNS_9allocatorEEEvRNS_15compressed_pairIT_T0_EES7_(ptr noundef nonnull align 8 dereferenceable(8) %x, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat {
entry:
  %x.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %1 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl15compressed_pairIPlNS_9allocatorEE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl4moveIRPlEEONS_16remove_referenceIT_E4typeEOS4_(ptr noundef nonnull align 8 dereferenceable(8) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl15compressed_pairIPlNS_9allocatorEE4swapERS3_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %y.addr, align 8
  call void @_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(8) %this1, ptr noundef nonnull align 8 dereferenceable(8) %0)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl19compressed_pair_impIPlNS_9allocatorELi2EE4swapERNS_15compressed_pairIS1_S2_EE(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef nonnull align 8 dereferenceable(8) %y) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %y.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %y, ptr %y.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.40", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %y.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl15compressed_pairIPlNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  call void @_ZN5eastl7cp_swapIPlEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %mFirst, ptr noundef nonnull align 8 dereferenceable(8) %call)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl7cp_swapIPlEEvRT_S3_(ptr noundef nonnull align 8 dereferenceable(8) %t1, ptr noundef nonnull align 8 dereferenceable(8) %t2) #1 comdat {
entry:
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %tTemp = alloca ptr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  %0 = load ptr, ptr %t1.addr, align 8
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %tTemp, align 8
  %2 = load ptr, ptr %t2.addr, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %t1.addr, align 8
  store ptr %3, ptr %4, align 8
  %5 = load ptr, ptr %tTemp, align 8
  %6 = load ptr, ptr %t2.addr, align 8
  store ptr %5, ptr %6, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %dist) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dist.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %dist, ptr %dist.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %dist.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEmIEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %0
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %sub)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %backwards = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %1 = load i64, ptr %n.addr, align 8
  %add = add i64 %1, %0
  store i64 %add, ptr %n.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %cmp = icmp sge i64 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, ptr %n.addr, align 8
  %div = sdiv i64 %3, 64
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference2, i32 0, i32 0
  %4 = load ptr, ptr %mpBitWord, align 8
  %add.ptr = getelementptr inbounds i64, ptr %4, i64 %div
  store ptr %add.ptr, ptr %mpBitWord, align 8
  %5 = load i64, ptr %n.addr, align 8
  %rem = srem i64 %5, 64
  %mReference3 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex4 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference3, i32 0, i32 1
  store i64 %rem, ptr %mnBitIndex4, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load i64, ptr %n.addr, align 8
  %sub = sub nsw i64 0, %6
  %add5 = add nsw i64 %sub, 64
  %sub6 = sub nsw i64 %add5, 1
  store i64 %sub6, ptr %backwards, align 8
  %7 = load i64, ptr %backwards, align 8
  %div7 = udiv i64 %7, 64
  %mReference8 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mpBitWord9 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference8, i32 0, i32 0
  %8 = load ptr, ptr %mpBitWord9, align 8
  %idx.neg = sub i64 0, %div7
  %add.ptr10 = getelementptr inbounds i64, ptr %8, i64 %idx.neg
  store ptr %add.ptr10, ptr %mpBitWord9, align 8
  %9 = load i64, ptr %backwards, align 8
  %rem11 = urem i64 %9, 64
  %sub12 = sub i64 63, %rem11
  %mReference13 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex14 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference13, i32 0, i32 1
  store i64 %sub12, ptr %mnBitIndex14, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mCapacityAllocator = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 2
  %call = invoke noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPlNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %mCapacityAllocator)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  ret ptr %call

terminate.lpad:                                   ; preds = %entry
  %0 = landingpad { ptr, i32 }
          catch ptr null
  %1 = extractvalue { ptr, i32 } %0, 0
  call void @__clang_call_terminate(ptr %1) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl15compressed_pairIPlNS_9allocatorEE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPlNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this1)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl19compressed_pair_impIPlNS_9allocatorELi2EE5firstEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mFirst = getelementptr inbounds %"class.eastl::compressed_pair_imp.40", ptr %this1, i32 0, i32 0
  ret ptr %mFirst
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE17DoInsertValuesEndEmRKl(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef nonnull align 8 dereferenceable(8) %value) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %value.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %value, ptr %value.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 8
  store i64 %sub.ptr.div6, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call7 = call noundef i64 @_ZN5eastl10VectorBaseIlNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5)
  store i64 %call7, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call8 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call8, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call9 = call noundef ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9)
  store ptr %call9, ptr %pNewData, align 8
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd11, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call12 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPlS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call12, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %15 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrIlmEEvPT_T0_RKS1_(ptr noundef %13, i64 noundef %14, ptr noundef nonnull align 8 dereferenceable(8) %15)
  %16 = load i64, ptr %n.addr, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i64, ptr %17, i64 %16
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin13 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %18 = load ptr, ptr %mpBegin13, align 8
  %mpEnd14 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %19 = load ptr, ptr %mpEnd14, align 8
  call void @_ZN5eastl8destructIPlEEvT_S2_(ptr noundef %18, ptr noundef %19)
  %mpBegin15 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %20 = load ptr, ptr %mpBegin15, align 8
  %call16 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %21 = load ptr, ptr %call16, align 8
  %mpBegin17 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %22 = load ptr, ptr %mpBegin17, align 8
  %sub.ptr.lhs.cast18 = ptrtoint ptr %21 to i64
  %sub.ptr.rhs.cast19 = ptrtoint ptr %22 to i64
  %sub.ptr.sub20 = sub i64 %sub.ptr.lhs.cast18, %sub.ptr.rhs.cast19
  %sub.ptr.div21 = sdiv exact i64 %sub.ptr.sub20, 8
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEE6DoFreeEPlm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %20, i64 noundef %sub.ptr.div21)
  %23 = load ptr, ptr %pNewData, align 8
  %mpBegin22 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  store ptr %23, ptr %mpBegin22, align 8
  %24 = load ptr, ptr %pNewEnd, align 8
  %mpEnd23 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %24, ptr %mpEnd23, align 8
  %25 = load ptr, ptr %pNewData, align 8
  %26 = load i64, ptr %nNewSize, align 8
  %add.ptr24 = getelementptr inbounds i64, ptr %25, i64 %26
  %call25 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr24, ptr %call25, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd26 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %27 = load ptr, ptr %mpEnd26, align 8
  %28 = load i64, ptr %n.addr, align 8
  %29 = load ptr, ptr %value.addr, align 8
  call void @_ZN5eastl24uninitialized_fill_n_ptrIlmEEvPT_T0_RKS1_(ptr noundef %27, i64 noundef %28, ptr noundef nonnull align 8 dereferenceable(8) %29)
  %30 = load i64, ptr %n.addr, align 8
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %31 = load ptr, ptr %mpEnd27, align 8
  %add.ptr28 = getelementptr inbounds i64, ptr %31, i64 %30
  store ptr %add.ptr28, ptr %mpEnd27, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl8destructIPlEEvT_S2_(ptr noundef %first, ptr noundef %last) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  call void @_ZN5eastl13destruct_implIPlEEvT_S2_NS_17integral_constantIbLb1EEE(ptr noundef %0, ptr noundef %1)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl10VectorBaseIlNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %currentCapacity) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %currentCapacity.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %currentCapacity, ptr %currentCapacity.addr, align 8
  %0 = load i64, ptr %currentCapacity.addr, align 8
  %cmp = icmp ugt i64 %0, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %currentCapacity.addr, align 8
  %mul = mul i64 2, %1
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ 1, %cond.false ]
  ret i64 %cond
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPlS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %dest.addr, align 8
  %call = call noundef ptr @_ZN5eastl22uninitialized_move_ptrIPlS1_S1_EET1_T_T0_S2_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl10VectorBaseIlNS_9allocatorEE6DoFreeEPlm(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef %p, i64 noundef %n) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %p.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %p, ptr %p.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %p.addr, align 8
  %2 = load i64, ptr %n.addr, align 8
  %mul = mul i64 %2, 8
  call void @_ZN5eastl9allocator10deallocateEPvm(ptr noundef nonnull align 1 dereferenceable(1) %call, ptr noundef %1, i64 noundef %mul)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_move_ptrIPlS1_S1_EET1_T_T0_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %dest) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  %i = alloca %"class.eastl::generic_iterator.74", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.74", align 8
  %agg.tmp1 = alloca %"class.eastl::generic_iterator.74", align 8
  %agg.tmp2 = alloca %"class.eastl::generic_iterator.74", align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  call void @_ZN5eastl16generic_iteratorIPlvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(8) %first.addr)
  call void @_ZN5eastl16generic_iteratorIPlvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp1, ptr noundef nonnull align 8 dereferenceable(8) %last.addr)
  call void @_ZN5eastl16generic_iteratorIPlvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(8) %dest.addr)
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp1, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive5, align 8
  %call = call ptr @_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPlvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE(ptr %0, ptr %1, ptr %2)
  %coerce.dive6 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %i, i32 0, i32 0
  store ptr %call, ptr %coerce.dive6, align 8
  %call7 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPlvE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %i)
  %3 = load ptr, ptr %call7, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl8Internal23uninitialized_move_implINS_16generic_iteratorIPlvEES4_EET0_T_S6_S5_NS_17integral_constantIbLb1EEE(ptr %first.coerce, ptr %last.coerce, ptr %dest.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.74", align 8
  %first = alloca %"class.eastl::generic_iterator.74", align 8
  %last = alloca %"class.eastl::generic_iterator.74", align 8
  %dest = alloca %"class.eastl::generic_iterator.74", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.74", align 8
  %agg.tmp3 = alloca %"class.eastl::generic_iterator.74", align 8
  %agg.tmp4 = alloca %"class.eastl::generic_iterator.74", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %dest, i32 0, i32 0
  store ptr %dest.coerce, ptr %coerce.dive2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp4, ptr align 8 %dest, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  %coerce.dive7 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp4, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive7, align 8
  %call = call ptr @_ZN5eastl4copyINS_16generic_iteratorIPlvEES3_EET0_T_S5_S4_(ptr %0, ptr %1, ptr %2)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %retval, i32 0, i32 0
  store ptr %call, ptr %coerce.dive8, align 8
  %coerce.dive9 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive9, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPlvE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %this1, i32 0, i32 0
  ret ptr %mIterator
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl4copyINS_16generic_iteratorIPlvEES3_EET0_T_S5_S4_(ptr %first.coerce, ptr %last.coerce, ptr %result.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.74", align 8
  %first = alloca %"class.eastl::generic_iterator.74", align 8
  %last = alloca %"class.eastl::generic_iterator.74", align 8
  %result = alloca %"class.eastl::generic_iterator.74", align 8
  %isMove = alloca i8, align 1
  %agg.tmp = alloca %"class.eastl::generic_iterator.74", align 8
  %agg.tmp4 = alloca %"class.eastl::generic_iterator.74", align 8
  %agg.tmp7 = alloca %"class.eastl::generic_iterator.74", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %result, i32 0, i32 0
  store ptr %result.coerce, ptr %coerce.dive2, align 8
  store i8 0, ptr %isMove, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  %coerce.dive3 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive3, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPlvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp4, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp4, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call6 = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPlvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp7, ptr align 8 %result, i64 8, i1 false)
  %coerce.dive8 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp7, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive8, align 8
  %call9 = call ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPlNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_(ptr noundef %call, ptr noundef %call6, ptr %2)
  %coerce.dive10 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %retval, i32 0, i32 0
  store ptr %call9, ptr %coerce.dive10, align 8
  %coerce.dive11 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive11, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local ptr @_ZN5eastl23move_and_copy_unwrapperILb0EPlNS_16generic_iteratorIS1_vEEEET1_T0_S5_S4_(ptr noundef %first, ptr noundef %last, ptr %result.coerce) #0 comdat {
entry:
  %retval = alloca %"class.eastl::generic_iterator.74", align 8
  %result = alloca %"class.eastl::generic_iterator.74", align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %ref.tmp = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.74", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %result, i32 0, i32 0
  store ptr %result.coerce, ptr %coerce.dive, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %call = call noundef ptr @_ZN5eastl15unwrap_iteratorIPlEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %0)
  %1 = load ptr, ptr %last.addr, align 8
  %call1 = call noundef ptr @_ZN5eastl15unwrap_iteratorIPlEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %1)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %result, i64 8, i1 false)
  %coerce.dive2 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive2, align 8
  %call3 = call noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPlvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %2)
  %call4 = call noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPlS1_EET1_T0_S3_S2_(ptr noundef %call, ptr noundef %call1, ptr noundef %call3)
  store ptr %call4, ptr %ref.tmp, align 8
  call void @_ZN5eastl16generic_iteratorIPlvEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(8) %retval, ptr noundef nonnull align 8 dereferenceable(8) %ref.tmp)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %retval, i32 0, i32 0
  %3 = load ptr, ptr %coerce.dive5, align 8
  ret ptr %3
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorINS_16generic_iteratorIPlvEEEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS5_EE5valueEE13iterator_typeES5_(ptr %it.coerce) #0 comdat {
entry:
  %it = alloca %"class.eastl::generic_iterator.74", align 8
  %agg.tmp = alloca %"class.eastl::generic_iterator.74", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %it, i32 0, i32 0
  store ptr %it.coerce, ptr %coerce.dive, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %it, i64 8, i1 false)
  %coerce.dive1 = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive1, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPlvEELb1EE13get_unwrappedES3_(ptr %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl21move_and_copy_chooserILb0EPlS1_EET1_T0_S3_S2_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #0 comdat {
entry:
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  %canBeMemmoved = alloca i8, align 1
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %canBeMemmoved, align 1
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %2 = load ptr, ptr %result.addr, align 8
  %call = call noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIlEEPT_PKS4_S7_S5_(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl15unwrap_iteratorIPlEENS_26is_iterator_wrapper_helperIT_Xsr5eastl19is_iterator_wrapperIS3_EE5valueEE13iterator_typeES3_(ptr noundef %it) #0 comdat {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  %call = call noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPlLb0EE13get_unwrappedES1_(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl20move_and_copy_helperINS_26random_access_iterator_tagELb0ELb1EE12move_or_copyIlEEPT_PKS4_S7_S5_(ptr noundef %first, ptr noundef %last, ptr noundef %result) #1 comdat align 2 {
entry:
  %retval = alloca ptr, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %result.addr = alloca ptr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  store ptr %result, ptr %result.addr, align 8
  %0 = load ptr, ptr %first.addr, align 8
  %1 = load ptr, ptr %last.addr, align 8
  %cmp = icmp eq ptr %0, %1
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  br i1 %lnot1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %result.addr, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %result.addr, align 8
  %4 = load ptr, ptr %first.addr, align 8
  %5 = load ptr, ptr %last.addr, align 8
  %6 = ptrtoint ptr %5 to i64
  %7 = load ptr, ptr %first.addr, align 8
  %8 = ptrtoint ptr %7 to i64
  %sub = sub i64 %6, %8
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %3, ptr align 8 %4, i64 %sub, i1 false)
  %9 = load ptr, ptr %last.addr, align 8
  %10 = load ptr, ptr %first.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %9 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 %sub.ptr.div
  store ptr %add.ptr, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperIPlLb0EE13get_unwrappedES1_(ptr noundef %it) #1 comdat align 2 {
entry:
  %it.addr = alloca ptr, align 8
  store ptr %it, ptr %it.addr, align 8
  %0 = load ptr, ptr %it.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl26is_iterator_wrapper_helperINS_16generic_iteratorIPlvEELb1EE13get_unwrappedES3_(ptr %it.coerce) #0 comdat align 2 {
entry:
  %it = alloca %"class.eastl::generic_iterator.74", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %it, i32 0, i32 0
  store ptr %it.coerce, ptr %coerce.dive, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPlvE6unwrapEv(ptr noundef nonnull align 8 dereferenceable(8) %it)
  %0 = load ptr, ptr %call, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl16generic_iteratorIPlvE6unwrapEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::generic_iterator.74", ptr %this1, i32 0, i32 0
  ret ptr %mIterator
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl13destruct_implIPlEEvT_S2_NS_17integral_constantIbLb1EEE(ptr noundef %0, ptr noundef %1) #1 comdat {
entry:
  %.addr = alloca ptr, align 8
  %.addr1 = alloca ptr, align 8
  store ptr %0, ptr %.addr, align 8
  store ptr %1, ptr %.addr1, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE17DoInsertValuesEndEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %nPrevSize = alloca i64, align 8
  %nGrowSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %1 = load ptr, ptr %call, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp ugt i64 %0, %sub.ptr.div
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %mpEnd2 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %3 = load ptr, ptr %mpEnd2, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast3 = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast4 = ptrtoint ptr %4 to i64
  %sub.ptr.sub5 = sub i64 %sub.ptr.lhs.cast3, %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 8
  store i64 %sub.ptr.div6, ptr %nPrevSize, align 8
  %5 = load i64, ptr %nPrevSize, align 8
  %call7 = call noundef i64 @_ZN5eastl10VectorBaseIlNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %5)
  store i64 %call7, ptr %nGrowSize, align 8
  %6 = load i64, ptr %nGrowSize, align 8
  %7 = load i64, ptr %nPrevSize, align 8
  %8 = load i64, ptr %n.addr, align 8
  %add = add i64 %7, %8
  %call8 = call noundef i64 @_ZN5eastl3maxImEENS_9enable_ifIXsr5eastl9is_scalarIT_EE5valueES2_E4typeES2_S2_(i64 noundef %6, i64 noundef %add)
  store i64 %call8, ptr %nNewSize, align 8
  %9 = load i64, ptr %nNewSize, align 8
  %call9 = call noundef ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %9)
  store ptr %call9, ptr %pNewData, align 8
  %mpBegin10 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %10 = load ptr, ptr %mpBegin10, align 8
  %mpEnd11 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %11 = load ptr, ptr %mpEnd11, align 8
  %12 = load ptr, ptr %pNewData, align 8
  %call12 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPlS1_S1_EET1_T_T0_S2_(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call12, ptr %pNewEnd, align 8
  %13 = load ptr, ptr %pNewEnd, align 8
  %14 = load i64, ptr %n.addr, align 8
  %call13 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPlmEET_S2_T0_(ptr noundef %13, i64 noundef %14)
  %15 = load i64, ptr %n.addr, align 8
  %16 = load ptr, ptr %pNewEnd, align 8
  %add.ptr = getelementptr inbounds i64, ptr %16, i64 %15
  store ptr %add.ptr, ptr %pNewEnd, align 8
  %mpBegin14 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %17 = load ptr, ptr %mpBegin14, align 8
  %mpEnd15 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %18 = load ptr, ptr %mpEnd15, align 8
  call void @_ZN5eastl8destructIPlEEvT_S2_(ptr noundef %17, ptr noundef %18)
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %19 = load ptr, ptr %mpBegin16, align 8
  %call17 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %20 = load ptr, ptr %call17, align 8
  %mpBegin18 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %21 = load ptr, ptr %mpBegin18, align 8
  %sub.ptr.lhs.cast19 = ptrtoint ptr %20 to i64
  %sub.ptr.rhs.cast20 = ptrtoint ptr %21 to i64
  %sub.ptr.sub21 = sub i64 %sub.ptr.lhs.cast19, %sub.ptr.rhs.cast20
  %sub.ptr.div22 = sdiv exact i64 %sub.ptr.sub21, 8
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEE6DoFreeEPlm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %19, i64 noundef %sub.ptr.div22)
  %22 = load ptr, ptr %pNewData, align 8
  %mpBegin23 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  store ptr %22, ptr %mpBegin23, align 8
  %23 = load ptr, ptr %pNewEnd, align 8
  %mpEnd24 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %23, ptr %mpEnd24, align 8
  %24 = load ptr, ptr %pNewData, align 8
  %25 = load i64, ptr %nNewSize, align 8
  %add.ptr25 = getelementptr inbounds i64, ptr %24, i64 %25
  %call26 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr25, ptr %call26, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %mpEnd27 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %26 = load ptr, ptr %mpEnd27, align 8
  %27 = load i64, ptr %n.addr, align 8
  %call28 = call noundef ptr @_ZN5eastl31uninitialized_value_construct_nIPlmEET_S2_T0_(ptr noundef %26, i64 noundef %27)
  %28 = load i64, ptr %n.addr, align 8
  %mpEnd29 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %29 = load ptr, ptr %mpEnd29, align 8
  %add.ptr30 = getelementptr inbounds i64, ptr %29, i64 %28
  store ptr %add.ptr30, ptr %mpEnd29, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE6DoGrowEm(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %pNewData, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %2 = load ptr, ptr %mpEnd, align 8
  %3 = load ptr, ptr %pNewData, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPlS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  store ptr %call2, ptr %pNewEnd, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  call void @_ZN5eastl8destructIPlEEvT_S2_(ptr noundef %4, ptr noundef %5)
  %mpBegin5 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin5, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %7 = load ptr, ptr %call6, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %8 = load ptr, ptr %mpBegin7, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEE6DoFreeEPlm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %6, i64 noundef %sub.ptr.div)
  %9 = load ptr, ptr %pNewData, align 8
  %mpBegin8 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  store ptr %9, ptr %mpBegin8, align 8
  %10 = load ptr, ptr %pNewEnd, align 8
  %mpEnd9 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %10, ptr %mpEnd9, align 8
  %11 = load ptr, ptr %pNewData, align 8
  %12 = load i64, ptr %n.addr, align 8
  %add.ptr = getelementptr inbounds i64, ptr %11, i64 %12
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call10, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE13shrink_to_fitEv(ptr noundef nonnull align 8 dereferenceable(24) %this) #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  %temp = alloca %"class.eastl::vector.37", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.79", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.79", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %call = call noundef ptr @_ZN5eastl6vectorIlNS_9allocatorEE5beginEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl13move_iteratorIPlEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp, ptr noundef %call)
  %call3 = call noundef ptr @_ZN5eastl6vectorIlNS_9allocatorEE3endEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  call void @_ZN5eastl13move_iteratorIPlEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %agg.tmp2, ptr noundef %call3)
  %call4 = call noundef nonnull align 1 dereferenceable(1) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE17internalAllocatorEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEEC2INS_13move_iteratorIPlEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(24) %temp, ptr %0, ptr %1, ptr noundef nonnull align 1 dereferenceable(1) %call4)
  invoke void @_ZN5eastl6vectorIlNS_9allocatorEE6DoSwapERS2_(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef nonnull align 8 dereferenceable(24) %temp)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl6vectorIlNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  ret void

lpad:                                             ; preds = %entry
  %2 = landingpad { ptr, i32 }
          cleanup
  %3 = extractvalue { ptr, i32 } %2, 0
  store ptr %3, ptr %exn.slot, align 8
  %4 = extractvalue { ptr, i32 } %2, 1
  store i32 %4, ptr %ehselector.slot, align 4
  call void @_ZN5eastl6vectorIlNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %temp) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val6 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val6
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl6vectorIlNS_9allocatorEE9DoReallocIPlEES4_mT_S5_NS2_23should_move_or_copy_tagILb1EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, i64 noundef %n, ptr noundef %first, ptr noundef %last) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %n.addr = alloca i64, align 8
  %first.addr = alloca ptr, align 8
  %last.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %first, ptr %first.addr, align 8
  store ptr %last, ptr %last.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %call = call noundef ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %0)
  store ptr %call, ptr %p, align 8
  %1 = load ptr, ptr %first.addr, align 8
  %2 = load ptr, ptr %last.addr, align 8
  %3 = load ptr, ptr %p, align 8
  %call2 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPlS1_S1_EET1_T_T0_S2_(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %p, align 8
  ret ptr %4
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl13move_iteratorIPlEC2ES1_(ptr noundef nonnull align 8 dereferenceable(8) %this, ptr noundef %mi) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %mi.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %mi, ptr %mi.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mi.addr, align 8
  store ptr %0, ptr %mIterator, align 8
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEEC2INS_13move_iteratorIPlEEEET_S7_RKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce, ptr noundef nonnull align 1 dereferenceable(1) %allocator) unnamed_addr #0 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %first = alloca %"class.eastl::move_iterator.79", align 8
  %last = alloca %"class.eastl::move_iterator.79", align 8
  %this.addr = alloca ptr, align 8
  %allocator.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.79", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.79", align 8
  %exn.slot = alloca ptr, align 8
  %ehselector.slot = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %allocator, ptr %allocator.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %allocator.addr, align 8
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEEC2ERKS1_(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr noundef nonnull align 1 dereferenceable(1) %0)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp3, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive6, align 8
  invoke void @_ZN5eastl6vectorIlNS_9allocatorEE6DoInitINS_13move_iteratorIPlEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr %1, ptr %2)
          to label %invoke.cont unwind label %lpad

invoke.cont:                                      ; preds = %entry
  ret void

lpad:                                             ; preds = %entry
  %3 = landingpad { ptr, i32 }
          cleanup
  %4 = extractvalue { ptr, i32 } %3, 0
  store ptr %4, ptr %exn.slot, align 8
  %5 = extractvalue { ptr, i32 } %3, 1
  store i32 %5, ptr %ehselector.slot, align 4
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  br label %eh.resume

eh.resume:                                        ; preds = %lpad
  %exn = load ptr, ptr %exn.slot, align 8
  %sel = load i32, ptr %ehselector.slot, align 4
  %lpad.val = insertvalue { ptr, i32 } poison, ptr %exn, 0
  %lpad.val7 = insertvalue { ptr, i32 } %lpad.val, i32 %sel, 1
  resume { ptr, i32 } %lpad.val7
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this) unnamed_addr #1 comdat align 2 personality ptr @__gxx_personality_v0 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mpBegin, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %1 = load ptr, ptr %mpEnd, align 8
  invoke void @_ZN5eastl8destructIPlEEvT_S2_(ptr noundef %0, ptr noundef %1)
          to label %invoke.cont unwind label %terminate.lpad

invoke.cont:                                      ; preds = %entry
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEED2Ev(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  ret void

terminate.lpad:                                   ; preds = %entry
  %2 = landingpad { ptr, i32 }
          catch ptr null
  %3 = extractvalue { ptr, i32 } %2, 0
  call void @__clang_call_terminate(ptr %3) #10
  unreachable
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE6DoInitINS_13move_iteratorIPlEEEEvT_S7_NS_17integral_constantIbLb0EEE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.79", align 8
  %last = alloca %"class.eastl::move_iterator.79", align 8
  %this.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.79", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.79", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive5, align 8
  %coerce.dive6 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive6, align 8
  call void @_ZN5eastl6vectorIlNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPlEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this2, ptr %0, ptr %1)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE18DoInitFromIteratorINS_13move_iteratorIPlEEEEvT_S7_NS_20forward_iterator_tagE(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr %first.coerce, ptr %last.coerce) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.79", align 8
  %last = alloca %"class.eastl::move_iterator.79", align 8
  %this.addr = alloca ptr, align 8
  %n = alloca i64, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.79", align 8
  %agg.tmp3 = alloca %"class.eastl::move_iterator.79", align 8
  %agg.tmp10 = alloca %"class.eastl::move_iterator.79", align 8
  %agg.tmp11 = alloca %"class.eastl::move_iterator.79", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %this, ptr %this.addr, align 8
  %this2 = load ptr, ptr %this.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp3, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp3, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPlEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %0, ptr %1)
  store i64 %call, ptr %n, align 8
  %2 = load i64, ptr %n, align 8
  %call6 = call noundef ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this2, i64 noundef %2)
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this2, i32 0, i32 0
  store ptr %call6, ptr %mpBegin, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this2, i32 0, i32 0
  %3 = load ptr, ptr %mpBegin7, align 8
  %4 = load i64, ptr %n, align 8
  %add.ptr = getelementptr inbounds i64, ptr %3, i64 %4
  %call8 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  store ptr %add.ptr, ptr %call8, align 8
  %call9 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this2) #9
  %5 = load ptr, ptr %call9, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this2, i32 0, i32 1
  store ptr %5, ptr %mpEnd, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp10, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp11, ptr align 8 %last, i64 8, i1 false)
  %mpBegin12 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this2, i32 0, i32 0
  %6 = load ptr, ptr %mpBegin12, align 8
  %coerce.dive13 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp10, i32 0, i32 0
  %7 = load ptr, ptr %coerce.dive13, align 8
  %coerce.dive14 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp11, i32 0, i32 0
  %8 = load ptr, ptr %coerce.dive14, align 8
  %call15 = call noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPlEES3_S2_EET1_T_T0_S4_(ptr %7, ptr %8, ptr noundef %6)
  ret void
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl8distanceINS_13move_iteratorIPlEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_(ptr %first.coerce, ptr %last.coerce) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.79", align 8
  %last = alloca %"class.eastl::move_iterator.79", align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.79", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.79", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp, i32 0, i32 0
  %0 = load ptr, ptr %coerce.dive4, align 8
  %coerce.dive5 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp2, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive5, align 8
  %call = call noundef i64 @_ZN5eastl13distance_implINS_13move_iteratorIPlEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE(ptr %0, ptr %1)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl22uninitialized_copy_ptrINS_13move_iteratorIPlEES3_S2_EET1_T_T0_S4_(ptr %first.coerce, ptr %last.coerce, ptr noundef %result) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.79", align 8
  %last = alloca %"class.eastl::move_iterator.79", align 8
  %result.addr = alloca ptr, align 8
  %agg.tmp = alloca %"class.eastl::move_iterator.79", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.79", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %result, ptr %result.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %0 = load ptr, ptr %result.addr, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive4, align 8
  %call = call noundef ptr @_ZN5eastl18uninitialized_copyINS_13move_iteratorIPlEES2_EET0_T_S5_S4_(ptr %1, ptr %2, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastl13distance_implINS_13move_iteratorIPlEEEENS_15iterator_traitsIT_E15difference_typeES5_S5_NS_26random_access_iterator_tagE(ptr %first.coerce, ptr %last.coerce) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.79", align 8
  %last = alloca %"class.eastl::move_iterator.79", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  %call = call noundef i64 @_ZN5eastlmiIPlS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %last, ptr noundef nonnull align 8 dereferenceable(8) %first)
  ret i64 %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef i64 @_ZN5eastlmiIPlS1_EEDTmicldtfp_4baseEcldtfp0_4baseEERKNS_13move_iteratorIT_EERKNS3_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef ptr @_ZNK5eastl13move_iteratorIPlE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef ptr @_ZNK5eastl13move_iteratorIPlE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %sub.ptr.lhs.cast = ptrtoint ptr %call to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %call1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  ret i64 %sub.ptr.div
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef ptr @_ZNK5eastl13move_iteratorIPlE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl18uninitialized_copyINS_13move_iteratorIPlEES2_EET0_T_S5_S4_(ptr %first.coerce, ptr %last.coerce, ptr noundef %result) #0 comdat {
entry:
  %first = alloca %"class.eastl::move_iterator.79", align 8
  %last = alloca %"class.eastl::move_iterator.79", align 8
  %result.addr = alloca ptr, align 8
  %isTriviallyCopyable = alloca i8, align 1
  %isInputIteratorReferenceAddressable = alloca i8, align 1
  %areIteratorsContiguous = alloca i8, align 1
  %agg.tmp = alloca %"class.eastl::move_iterator.79", align 8
  %agg.tmp2 = alloca %"class.eastl::move_iterator.79", align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %result, ptr %result.addr, align 8
  store i8 1, ptr %isTriviallyCopyable, align 1
  store i8 0, ptr %isInputIteratorReferenceAddressable, align 1
  store i8 0, ptr %areIteratorsContiguous, align 1
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp, ptr align 8 %first, i64 8, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %agg.tmp2, ptr align 8 %last, i64 8, i1 false)
  %0 = load ptr, ptr %result.addr, align 8
  %coerce.dive3 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp, i32 0, i32 0
  %1 = load ptr, ptr %coerce.dive3, align 8
  %coerce.dive4 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %agg.tmp2, i32 0, i32 0
  %2 = load ptr, ptr %coerce.dive4, align 8
  %call = call noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPlEES5_EET0_T_S8_S7_(ptr %1, ptr %2, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef ptr @_ZN5eastl8Internal23uninitialized_copy_implILb1ELb0ELb0EE4implINS_13move_iteratorIPlEES5_EET0_T_S8_S7_(ptr %first.coerce, ptr %last.coerce, ptr noundef %dest) #0 comdat align 2 {
entry:
  %first = alloca %"class.eastl::move_iterator.79", align 8
  %last = alloca %"class.eastl::move_iterator.79", align 8
  %dest.addr = alloca ptr, align 8
  %currentDest = alloca ptr, align 8
  %coerce.dive = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %first, i32 0, i32 0
  store ptr %first.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %last, i32 0, i32 0
  store ptr %last.coerce, ptr %coerce.dive1, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %dest.addr, align 8
  store ptr %0, ptr %currentDest, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %call = call noundef zeroext i1 @_ZN5eastlneIPlS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %first, ptr noundef nonnull align 8 dereferenceable(8) %last)
  br i1 %call, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %currentDest, align 8
  %call2 = call noundef ptr @_ZN5eastl9addressofIlEEPT_RS1_(ptr noundef nonnull align 8 dereferenceable(8) %1) #9
  %call3 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl13move_iteratorIPlEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  %2 = load i64, ptr %call3, align 8
  store i64 %2, ptr %call2, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %call4 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl13move_iteratorIPlEppEv(ptr noundef nonnull align 8 dereferenceable(8) %first)
  %3 = load ptr, ptr %currentDest, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %3, i32 1
  store ptr %incdec.ptr, ptr %currentDest, align 8
  br label %for.cond, !llvm.loop !69

for.end:                                          ; preds = %for.cond
  %4 = load ptr, ptr %currentDest, align 8
  ret ptr %4
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastlneIPlS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #0 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %call = call noundef zeroext i1 @_ZN5eastleqIPlS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %0, ptr noundef nonnull align 8 dereferenceable(8) %1)
  %lnot = xor i1 %call, true
  ret i1 %lnot
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZNK5eastl13move_iteratorIPlEdeEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl13move_iteratorIPlEppEv(ptr noundef nonnull align 8 dereferenceable(8) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mIterator = getelementptr inbounds %"class.eastl::move_iterator.79", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %mIterator, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %0, i32 1
  store ptr %incdec.ptr, ptr %mIterator, align 8
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastleqIPlS1_EEbRKNS_13move_iteratorIT_EERKNS2_IT0_EE(ptr noundef nonnull align 8 dereferenceable(8) %a, ptr noundef nonnull align 8 dereferenceable(8) %b) #1 comdat {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %call = call noundef ptr @_ZNK5eastl13move_iteratorIPlE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %0)
  %1 = load ptr, ptr %b.addr, align 8
  %call1 = call noundef ptr @_ZNK5eastl13move_iteratorIPlE4baseEv(ptr noundef nonnull align 8 dereferenceable(8) %1)
  %cmp = icmp eq ptr %call, %call1
  ret i1 %cmp
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local void @_ZN5eastl6vectorIlNS_9allocatorEE16DoInsertValueEndIJlEEEvDpOT_(ptr noundef nonnull align 8 dereferenceable(24) %this, ptr noundef nonnull align 8 dereferenceable(8) %args) #0 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %nPrevSize = alloca i64, align 8
  %nNewSize = alloca i64, align 8
  %pNewData = alloca ptr, align 8
  %pNewEnd = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mpEnd = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %0 = load ptr, ptr %mpEnd, align 8
  %mpBegin = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %1 = load ptr, ptr %mpBegin, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  store i64 %sub.ptr.div, ptr %nPrevSize, align 8
  %2 = load i64, ptr %nPrevSize, align 8
  %call = call noundef i64 @_ZN5eastl10VectorBaseIlNS_9allocatorEE14GetNewCapacityEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %2)
  store i64 %call, ptr %nNewSize, align 8
  %3 = load i64, ptr %nNewSize, align 8
  %call2 = call noundef ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE10DoAllocateEm(ptr noundef nonnull align 8 dereferenceable(24) %this1, i64 noundef %3)
  store ptr %call2, ptr %pNewData, align 8
  %mpBegin3 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %4 = load ptr, ptr %mpBegin3, align 8
  %mpEnd4 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %5 = load ptr, ptr %mpEnd4, align 8
  %6 = load ptr, ptr %pNewData, align 8
  %call5 = call noundef ptr @_ZN5eastl34uninitialized_move_ptr_if_noexceptIPlS1_S1_EET1_T_T0_S2_(ptr noundef %4, ptr noundef %5, ptr noundef %6)
  store ptr %call5, ptr %pNewEnd, align 8
  %7 = load ptr, ptr %pNewEnd, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %call6 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl7forwardIlEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 8 dereferenceable(8) %8) #9
  %9 = load i64, ptr %call6, align 8
  store i64 %9, ptr %7, align 8
  %10 = load ptr, ptr %pNewEnd, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %10, i32 1
  store ptr %incdec.ptr, ptr %pNewEnd, align 8
  %mpBegin7 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %11 = load ptr, ptr %mpBegin7, align 8
  %mpEnd8 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  %12 = load ptr, ptr %mpEnd8, align 8
  call void @_ZN5eastl8destructIPlEEvT_S2_(ptr noundef %11, ptr noundef %12)
  %mpBegin9 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %13 = load ptr, ptr %mpBegin9, align 8
  %call10 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  %14 = load ptr, ptr %call10, align 8
  %mpBegin11 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  %15 = load ptr, ptr %mpBegin11, align 8
  %sub.ptr.lhs.cast12 = ptrtoint ptr %14 to i64
  %sub.ptr.rhs.cast13 = ptrtoint ptr %15 to i64
  %sub.ptr.sub14 = sub i64 %sub.ptr.lhs.cast12, %sub.ptr.rhs.cast13
  %sub.ptr.div15 = sdiv exact i64 %sub.ptr.sub14, 8
  call void @_ZN5eastl10VectorBaseIlNS_9allocatorEE6DoFreeEPlm(ptr noundef nonnull align 8 dereferenceable(24) %this1, ptr noundef %13, i64 noundef %sub.ptr.div15)
  %16 = load ptr, ptr %pNewData, align 8
  %mpBegin16 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 0
  store ptr %16, ptr %mpBegin16, align 8
  %17 = load ptr, ptr %pNewEnd, align 8
  %mpEnd17 = getelementptr inbounds %"struct.eastl::VectorBase.38", ptr %this1, i32 0, i32 1
  store ptr %17, ptr %mpEnd17, align 8
  %18 = load ptr, ptr %pNewData, align 8
  %19 = load i64, ptr %nNewSize, align 8
  %add.ptr = getelementptr inbounds i64, ptr %18, i64 %19
  %call18 = call noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl10VectorBaseIlNS_9allocatorEE19internalCapacityPtrEv(ptr noundef nonnull align 8 dereferenceable(24) %this1) #9
  store ptr %add.ptr, ptr %call18, align 8
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(8) ptr @_ZN5eastl7forwardIlEEOT_RNS_16remove_referenceIS1_E4typeE(ptr noundef nonnull align 8 dereferenceable(8) %x) #1 comdat {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl18bitvector_iteratorIlEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this, i64 noundef %dist) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %dist.addr = alloca i64, align 8
  store ptr %this, ptr %this.addr, align 8
  store i64 %dist, ptr %dist.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load i64, ptr %dist.addr, align 8
  %call = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEpLEl(ptr noundef nonnull align 8 dereferenceable(16) %this1, i64 noundef %0)
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local void @_ZN5eastl24bitvector_const_iteratorIlEC2ERKNS_19bitvector_referenceIlEE(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %reference) unnamed_addr #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %0 = load ptr, ptr %reference.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %mReference, ptr align 8 %0, i64 16, i1 false)
  ret void
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef i64 @_ZNK5eastl24bitvector_const_iteratorIlEmiERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %mul = mul nsw i64 %sub.ptr.div, 64
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference4, i32 0, i32 1
  %3 = load i64, ptr %mnBitIndex, align 8
  %add = add i64 %mul, %3
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %4, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference5, i32 0, i32 1
  %5 = load i64, ptr %mnBitIndex6, align 8
  %sub = sub i64 %add, %5
  ret i64 %sub
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorIlEppEv(ptr noundef nonnull align 8 dereferenceable(16) %this) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference, i32 0, i32 1
  %0 = load i64, ptr %mnBitIndex, align 8
  %inc = add i64 %0, 1
  store i64 %inc, ptr %mnBitIndex, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex3 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference2, i32 0, i32 1
  %1 = load i64, ptr %mnBitIndex3, align 8
  %cmp = icmp eq i64 %1, 64
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference4, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord, align 8
  %incdec.ptr = getelementptr inbounds i64, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %mpBitWord, align 8
  %mReference5 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex6 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference5, i32 0, i32 1
  store i64 0, ptr %mnBitIndex6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret ptr %this1
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorIlEleERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %mReference = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mpBitWord = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference, i32 0, i32 0
  %0 = load ptr, ptr %mpBitWord, align 8
  %1 = load ptr, ptr %rhs.addr, align 8
  %mReference2 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %1, i32 0, i32 0
  %mpBitWord3 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference2, i32 0, i32 0
  %2 = load ptr, ptr %mpBitWord3, align 8
  %cmp = icmp ult ptr %0, %2
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %mReference4 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mpBitWord5 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference4, i32 0, i32 0
  %3 = load ptr, ptr %mpBitWord5, align 8
  %4 = load ptr, ptr %rhs.addr, align 8
  %mReference6 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %4, i32 0, i32 0
  %mpBitWord7 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference6, i32 0, i32 0
  %5 = load ptr, ptr %mpBitWord7, align 8
  %cmp8 = icmp eq ptr %3, %5
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %mReference9 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %this1, i32 0, i32 0
  %mnBitIndex = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference9, i32 0, i32 1
  %6 = load i64, ptr %mnBitIndex, align 8
  %7 = load ptr, ptr %rhs.addr, align 8
  %mReference10 = getelementptr inbounds %"class.eastl::bitvector_const_iterator.42", ptr %7, i32 0, i32 0
  %mnBitIndex11 = getelementptr inbounds %"class.eastl::bitvector_reference.43", ptr %mReference10, i32 0, i32 1
  %8 = load i64, ptr %mnBitIndex11, align 8
  %cmp12 = icmp ule i64 %6, %8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %9 = phi i1 [ false, %lor.rhs ], [ %cmp12, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %10 = phi i1 [ true, %entry ], [ %9, %land.end ]
  ret i1 %10
}

; Function Attrs: mustprogress nounwind uwtable
define linkonce_odr dso_local noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIlEaSERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %this, ptr noundef nonnull align 8 dereferenceable(16) %rhs) #1 comdat align 2 {
entry:
  %this.addr = alloca ptr, align 8
  %rhs.addr = alloca ptr, align 8
  store ptr %this, ptr %this.addr, align 8
  store ptr %rhs, ptr %rhs.addr, align 8
  %this1 = load ptr, ptr %this.addr, align 8
  %0 = load ptr, ptr %rhs.addr, align 8
  %call = call noundef zeroext i1 @_ZNK5eastl19bitvector_referenceIlEcvbEv(ptr noundef nonnull align 8 dereferenceable(16) %0)
  %call2 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl19bitvector_referenceIlEaSEb(ptr noundef nonnull align 8 dereferenceable(16) %this1, i1 noundef zeroext %call)
  ret ptr %call2
}

; Function Attrs: mustprogress uwtable
define linkonce_odr dso_local noundef zeroext i1 @_ZN5eastl5equalINS_24bitvector_const_iteratorImEES2_EEbT_S3_T0_(ptr %first1.coerce0, i64 %first1.coerce1, ptr %last1.coerce0, i64 %last1.coerce1, ptr %first2.coerce0, i64 %first2.coerce1) #0 comdat {
entry:
  %retval = alloca i1, align 1
  %first1 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %last1 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %first2 = alloca %"class.eastl::bitvector_const_iterator", align 8
  %0 = getelementptr inbounds { ptr, i64 }, ptr %first1, i32 0, i32 0
  store ptr %first1.coerce0, ptr %0, align 8
  %1 = getelementptr inbounds { ptr, i64 }, ptr %first1, i32 0, i32 1
  store i64 %first1.coerce1, ptr %1, align 8
  %2 = getelementptr inbounds { ptr, i64 }, ptr %last1, i32 0, i32 0
  store ptr %last1.coerce0, ptr %2, align 8
  %3 = getelementptr inbounds { ptr, i64 }, ptr %last1, i32 0, i32 1
  store i64 %last1.coerce1, ptr %3, align 8
  %4 = getelementptr inbounds { ptr, i64 }, ptr %first2, i32 0, i32 0
  store ptr %first2.coerce0, ptr %4, align 8
  %5 = getelementptr inbounds { ptr, i64 }, ptr %first2, i32 0, i32 1
  store i64 %first2.coerce1, ptr %5, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %call = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEneERKS1_(ptr noundef nonnull align 8 dereferenceable(16) %first1, ptr noundef nonnull align 8 dereferenceable(16) %last1)
  br i1 %call, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call1 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %first1)
  %conv = zext i1 %call1 to i32
  %call2 = call noundef zeroext i1 @_ZNK5eastl24bitvector_const_iteratorImEdeEv(ptr noundef nonnull align 8 dereferenceable(16) %first2)
  %conv3 = zext i1 %call2 to i32
  %cmp = icmp eq i32 %conv, %conv3
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %call4 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %first1)
  %call5 = call noundef nonnull align 8 dereferenceable(16) ptr @_ZN5eastl24bitvector_const_iteratorImEppEv(ptr noundef nonnull align 8 dereferenceable(16) %first2)
  br label %for.cond, !llvm.loop !70

for.end:                                          ; preds = %for.cond
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then
  %6 = load i1, ptr %retval, align 1
  ret i1 %6
}

attributes #0 = { mustprogress uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { mustprogress nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { noreturn nounwind uwtable "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nobuiltin nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { nocallback nofree nosync nounwind willreturn }
attributes #8 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #9 = { nounwind }
attributes #10 = { noreturn nounwind }
attributes #11 = { builtin nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
