target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ssl3_enc_method = type { ptr, ptr, ptr, ptr, ptr, i64, ptr, i64, ptr, ptr, i32, ptr, ptr, ptr }
%struct.anon.7 = type { i8, i8, i32 }
%struct.ssl_connection_st = type { %struct.ssl_st, i32, ptr, ptr, ptr, i32, ptr, i32, i32, i32, i32, %struct.OSSL_TIME, %struct.OSSL_TIME, %struct.ossl_statem_st, i32, ptr, ptr, i64, i64, i64, %struct.anon, ptr, ptr, ptr, i32, ptr, %struct.ssl_dane_st, ptr, ptr, ptr, ptr, i32, [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], ptr, [64 x i8], i64, i32, i64, [32 x i8], ptr, ptr, ptr, i64, ptr, [32 x i8], i64, i32, ptr, ptr, i32, i32, ptr, ptr, ptr, ptr, ptr, i64, ptr, ptr, i64, i32, i32, i32, i64, i32, i32, i64, i64, i64, %struct.anon.1, ptr, i32, ptr, ptr, ptr, i32, ptr, ptr, ptr, i32, i32, i32, i32, ptr, i64, i32, ptr, %struct.srp_ctx_st, ptr, %struct.record_layer_st, ptr, ptr, ptr, ptr, i64, i32, i32, i32, i64, i64, i64, ptr, ptr, ptr, ptr, ptr, i64, ptr, i64, ptr, i64 }
%struct.ssl_st = type { i32, ptr, ptr, ptr, %struct.CRYPTO_REF_COUNT, ptr, %struct.crypto_ex_data_st }
%struct.CRYPTO_REF_COUNT = type { i32 }
%struct.crypto_ex_data_st = type { ptr, ptr }
%struct.OSSL_TIME = type { i64 }
%struct.ossl_statem_st = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, ptr, ptr, ptr, i8 }
%struct.anon = type { i64, [32 x i8], [32 x i8], ptr, ptr, i32, i32, i32, i32, [2 x i8], i32, i32, i32, i32, %struct.anon.0, [64 x i8], i64, [64 x i8], i64, i32, i32, ptr, i64, ptr, i64, i32, i8, i8, i16, ptr }
%struct.anon.0 = type { [128 x i8], i64, [128 x i8], i64, i64, i32, ptr, ptr, i32, ptr, i64, ptr, i64, ptr, ptr, ptr, i32, i64, ptr, i32, ptr, i64, ptr, i64, ptr, i64, ptr, ptr, ptr, ptr, i64, i64, ptr, ptr, i32, i32, i32, i32 }
%struct.ssl_dane_st = type { ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i64 }
%struct.anon.1 = type { [29 x i8], ptr, ptr, ptr, i32, ptr, i16, i32, %struct.anon.2, i32, i32, i64, ptr, i64, ptr, i64, ptr, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, i64, i32, i32, i32, i32, ptr, i64, i32, i8, i32, [4 x i32], i32, i8, i8, i8, i8 }
%struct.anon.2 = type { ptr, ptr, ptr, i64 }
%struct.srp_ctx_st = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i64 }
%struct.record_layer_st = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, i32, i64, [4 x i8], i64, i64, i8, i64, ptr, i32, ptr, ptr, ptr, i64, i64, i64, [32 x %struct.tls_record_st] }
%struct.tls_record_st = type { ptr, i32, i8, ptr, ptr, i64, i64, i16, [8 x i8] }
%struct.ssl_method_st = type { i32, i32, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.quic_conn_st = type { %struct.ssl_st, ptr, ptr, ptr, ptr, ptr, ptr, %union.bio_addr_st, %struct.quic_thread_assist_st, ptr, ptr, i64, i16, i32, i32, i64, i32, i64, i32 }
%union.bio_addr_st = type { %struct.sockaddr_in6, [84 x i8] }
%struct.sockaddr_in6 = type { i16, i16, i32, %struct.in6_addr, i32 }
%struct.in6_addr = type { %union.anon }
%union.anon = type { [4 x i32] }
%struct.quic_thread_assist_st = type { ptr, ptr, ptr, i32, i32, ptr, ptr }
%struct.ssl_ctx_st = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, ptr, i32, %struct.OSSL_TIME, ptr, ptr, ptr, %struct.anon.3, %struct.CRYPTO_REF_COUNT, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %struct.crypto_ex_data_st, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, i32, i32, i32, i64, ptr, ptr, i32, ptr, ptr, i32, i64, [32 x i8], ptr, ptr, ptr, i32, ptr, ptr, ptr, i64, i64, i64, i64, ptr, ptr, ptr, %struct.anon.4, ptr, ptr, ptr, ptr, %struct.srp_ctx_st, %struct.dane_ctx_st, ptr, ptr, ptr, ptr, i32, i32, ptr, ptr, i64, ptr, ptr, ptr, i64, ptr, ptr, i32, ptr, ptr, ptr, [14 x i32], [24 x ptr], [14 x ptr], [14 x i64], i64, ptr, ptr, ptr, i64, i64, ptr, i64, i64, i32, i32, i32, i32, ptr, i64, ptr, i64 }
%struct.anon.3 = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.anon.4 = type { ptr, ptr, [16 x i8], ptr, ptr, ptr, ptr, ptr, i32, i8, i64, ptr, i64, ptr, ptr, i64, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, [32 x i8] }
%struct.dane_ctx_st = type { ptr, ptr, i8, i64 }
%struct.ssl_session_st = type { i32, i64, [64 x i8], [512 x i8], i64, [32 x i8], i64, [32 x i8], ptr, ptr, i32, ptr, ptr, ptr, i64, %struct.CRYPTO_REF_COUNT, %struct.OSSL_TIME, %struct.OSSL_TIME, %struct.OSSL_TIME, i32, ptr, i64, i32, %struct.crypto_ex_data_st, ptr, ptr, %struct.anon.5, ptr, ptr, i64, i32, ptr }
%struct.anon.5 = type { ptr, ptr, i64, i64, i32, i32, ptr, i64, i8 }
%struct.danetls_record_st = type { i8, i8, i8, ptr, i64, ptr }
%struct.tls_group_info_st = type { ptr, ptr, ptr, i32, i16, i32, i32, i32, i32, i8 }
%struct.tls_sigalg_info_st = type { ptr, i16, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i32, i32, i32 }
%struct.CLIENTHELLO_MSG = type { i32, i32, [32 x i8], i64, [32 x i8], i64, [255 x i8], %struct.PACKET, i64, [255 x i8], %struct.PACKET, i64, ptr }
%struct.PACKET = type { ptr, i64 }
%struct.ossl_record_method_st = type { ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.ossl_param_st = type { ptr, i32, ptr, i64, i64 }
%struct.dtls_record_layer_st = type { i16, i16, %struct.record_pqueue_st }
%struct.record_pqueue_st = type { i16, ptr }
%struct.pitem_st = type { [8 x i8], ptr, ptr }
%struct.cert_st = type { ptr, ptr, ptr, i32, i32, ptr, i64, ptr, i64, ptr, i64, ptr, i64, ptr, ptr, ptr, ptr, %struct.custom_ext_methods, ptr, i32, ptr, ptr, %struct.CRYPTO_REF_COUNT }
%struct.custom_ext_methods = type { ptr, i64 }
%struct.cert_pkey_st = type { ptr, ptr, ptr, ptr, i64 }
%struct.ssl_async_args = type { ptr, ptr, i64, i32, %union.anon.6 }
%union.anon.6 = type { ptr }
%struct.ssl_cipher_st = type { i32, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ssl_ctx_ext_secure_st = type { [32 x i8], [32 x i8] }
%struct.raw_extension_st = type { %struct.PACKET, i32, i32, i32, i64 }
%struct.timeval = type { i64, i64 }

@ssl3_undef_enc_method = global %struct.ssl3_enc_method { ptr @ssl_undefined_function_8, ptr @ssl_undefined_function_3, ptr @ssl_undefined_function_4, ptr @ssl_undefined_function_5, ptr null, i64 0, ptr null, i64 0, ptr @ssl_undefined_function_6, ptr @ssl_undefined_function_7, i32 0, ptr null, ptr null, ptr null }, align 8
@.str = private unnamed_addr constant [25 x i8] c"../openssl/ssl/ssl_lib.c\00", align 1
@__func__.SSL_clear = private unnamed_addr constant [10 x i8] c"SSL_clear\00", align 1
@__func__.ossl_ssl_connection_reset = private unnamed_addr constant [26 x i8] c"ossl_ssl_connection_reset\00", align 1
@__func__.SSL_CTX_set_ssl_version = private unnamed_addr constant [24 x i8] c"SSL_CTX_set_ssl_version\00", align 1
@__func__.SSL_new = private unnamed_addr constant [8 x i8] c"SSL_new\00", align 1
@__func__.ossl_ssl_connection_new_int = private unnamed_addr constant [28 x i8] c"ossl_ssl_connection_new_int\00", align 1
@__func__.SSL_CTX_set_session_id_context = private unnamed_addr constant [31 x i8] c"SSL_CTX_set_session_id_context\00", align 1
@__func__.SSL_set_session_id_context = private unnamed_addr constant [27 x i8] c"SSL_set_session_id_context\00", align 1
@__func__.SSL_dane_enable = private unnamed_addr constant [16 x i8] c"SSL_dane_enable\00", align 1
@__func__.SSL_set_fd = private unnamed_addr constant [11 x i8] c"SSL_set_fd\00", align 1
@__func__.SSL_set_wfd = private unnamed_addr constant [12 x i8] c"SSL_set_wfd\00", align 1
@__func__.SSL_set_rfd = private unnamed_addr constant [12 x i8] c"SSL_set_rfd\00", align 1
@.str.1 = private unnamed_addr constant [11 x i8] c"read_ahead\00", align 1
@__func__.SSL_CTX_check_private_key = private unnamed_addr constant [26 x i8] c"SSL_CTX_check_private_key\00", align 1
@__func__.SSL_check_private_key = private unnamed_addr constant [22 x i8] c"SSL_check_private_key\00", align 1
@__func__.ssl_read_internal = private unnamed_addr constant [18 x i8] c"ssl_read_internal\00", align 1
@__func__.SSL_read = private unnamed_addr constant [9 x i8] c"SSL_read\00", align 1
@__func__.SSL_read_early_data = private unnamed_addr constant [20 x i8] c"SSL_read_early_data\00", align 1
@__func__.SSL_peek = private unnamed_addr constant [9 x i8] c"SSL_peek\00", align 1
@__func__.ssl_write_internal = private unnamed_addr constant [19 x i8] c"ssl_write_internal\00", align 1
@__func__.SSL_sendfile = private unnamed_addr constant [13 x i8] c"SSL_sendfile\00", align 1
@__func__.SSL_write = private unnamed_addr constant [10 x i8] c"SSL_write\00", align 1
@__func__.SSL_write_early_data = private unnamed_addr constant [21 x i8] c"SSL_write_early_data\00", align 1
@__func__.SSL_shutdown = private unnamed_addr constant [13 x i8] c"SSL_shutdown\00", align 1
@__func__.SSL_key_update = private unnamed_addr constant [15 x i8] c"SSL_key_update\00", align 1
@.str.2 = private unnamed_addr constant [5 x i8] c"mode\00", align 1
@__func__.SSL_CTX_set_cipher_list = private unnamed_addr constant [24 x i8] c"SSL_CTX_set_cipher_list\00", align 1
@__func__.SSL_set_cipher_list = private unnamed_addr constant [20 x i8] c"SSL_set_cipher_list\00", align 1
@__func__.SSL_CTX_new_ex = private unnamed_addr constant [15 x i8] c"SSL_CTX_new_ex\00", align 1
@__func__.ssl_check_srvr_ecc_cert_and_alg = private unnamed_addr constant [32 x i8] c"ssl_check_srvr_ecc_cert_and_alg\00", align 1
@__func__.SSL_do_handshake = private unnamed_addr constant [17 x i8] c"SSL_do_handshake\00", align 1
@__func__.ssl_undefined_function = private unnamed_addr constant [23 x i8] c"ssl_undefined_function\00", align 1
@__func__.ssl_undefined_void_function = private unnamed_addr constant [28 x i8] c"ssl_undefined_void_function\00", align 1
@__func__.ssl_bad_method = private unnamed_addr constant [15 x i8] c"ssl_bad_method\00", align 1
@.str.3 = private unnamed_addr constant [8 x i8] c"TLSv1.3\00", align 1
@.str.4 = private unnamed_addr constant [8 x i8] c"TLSv1.2\00", align 1
@.str.5 = private unnamed_addr constant [8 x i8] c"TLSv1.1\00", align 1
@.str.6 = private unnamed_addr constant [6 x i8] c"TLSv1\00", align 1
@.str.7 = private unnamed_addr constant [6 x i8] c"SSLv3\00", align 1
@.str.8 = private unnamed_addr constant [9 x i8] c"DTLSv0.9\00", align 1
@.str.9 = private unnamed_addr constant [7 x i8] c"DTLSv1\00", align 1
@.str.10 = private unnamed_addr constant [9 x i8] c"DTLSv1.2\00", align 1
@.str.11 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.12 = private unnamed_addr constant [7 x i8] c"QUICv1\00", align 1
@__func__.ssl_init_wbio_buffer = private unnamed_addr constant [21 x i8] c"ssl_init_wbio_buffer\00", align 1
@__func__.SSL_CTX_use_psk_identity_hint = private unnamed_addr constant [30 x i8] c"SSL_CTX_use_psk_identity_hint\00", align 1
@__func__.SSL_use_psk_identity_hint = private unnamed_addr constant [26 x i8] c"SSL_use_psk_identity_hint\00", align 1
@__func__.ssl_handshake_hash = private unnamed_addr constant [19 x i8] c"ssl_handshake_hash\00", align 1
@.str.13 = private unnamed_addr constant [8 x i8] c"options\00", align 1
@__func__.SSL_set_ct_validation_callback = private unnamed_addr constant [31 x i8] c"SSL_set_ct_validation_callback\00", align 1
@__func__.SSL_CTX_set_ct_validation_callback = private unnamed_addr constant [35 x i8] c"SSL_CTX_set_ct_validation_callback\00", align 1
@__func__.ssl_validate_ct = private unnamed_addr constant [16 x i8] c"ssl_validate_ct\00", align 1
@__func__.SSL_CTX_enable_ct = private unnamed_addr constant [18 x i8] c"SSL_CTX_enable_ct\00", align 1
@__func__.SSL_enable_ct = private unnamed_addr constant [14 x i8] c"SSL_enable_ct\00", align 1
@__func__.ssl_log_rsa_client_key_exchange = private unnamed_addr constant [32 x i8] c"ssl_log_rsa_client_key_exchange\00", align 1
@.str.14 = private unnamed_addr constant [4 x i8] c"RSA\00", align 1
@__func__.ssl_cache_cipherlist = private unnamed_addr constant [21 x i8] c"ssl_cache_cipherlist\00", align 1
@__func__.ossl_bytes_to_cipher_list = private unnamed_addr constant [26 x i8] c"ossl_bytes_to_cipher_list\00", align 1
@__func__.SSL_verify_client_post_handshake = private unnamed_addr constant [33 x i8] c"SSL_verify_client_post_handshake\00", align 1
@__func__.SSL_set0_tmp_dh_pkey = private unnamed_addr constant [21 x i8] c"SSL_set0_tmp_dh_pkey\00", align 1
@__func__.SSL_CTX_set0_tmp_dh_pkey = private unnamed_addr constant [25 x i8] c"SSL_CTX_set0_tmp_dh_pkey\00", align 1
@dane_mds = internal constant [3 x %struct.anon.7] [%struct.anon.7 zeroinitializer, %struct.anon.7 { i8 1, i8 1, i32 672 }, %struct.anon.7 { i8 2, i8 2, i32 674 }], align 16
@__func__.dane_tlsa_add = private unnamed_addr constant [14 x i8] c"dane_tlsa_add\00", align 1
@__func__.dane_mtype_set = private unnamed_addr constant [15 x i8] c"dane_mtype_set\00", align 1
@__func__.ssl_start_async_job = private unnamed_addr constant [20 x i8] c"ssl_start_async_job\00", align 1
@__func__.ssl_peek_internal = private unnamed_addr constant [18 x i8] c"ssl_peek_internal\00", align 1
@__func__.can_renegotiate = private unnamed_addr constant [16 x i8] c"can_renegotiate\00", align 1
@__func__.ssl_dane_dup = private unnamed_addr constant [13 x i8] c"ssl_dane_dup\00", align 1
@__func__.ct_move_scts = private unnamed_addr constant [13 x i8] c"ct_move_scts\00", align 1
@__func__.ct_strict = private unnamed_addr constant [10 x i8] c"ct_strict\00", align 1
@.str.15 = private unnamed_addr constant [5 x i8] c"%02x\00", align 1
@.str.16 = private unnamed_addr constant [37 x i8] c"../openssl/include/internal/packet.h\00", align 1

; Function Attrs: nounwind uwtable
define internal i32 @ssl_undefined_function_8(ptr noundef %sc) #0 {
entry:
  %sc.addr = alloca ptr, align 8
  store ptr %sc, ptr %sc.addr, align 8
  %0 = load ptr, ptr %sc.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 0
  %call = call i32 @ssl_undefined_function(ptr noundef %ssl)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @ssl_undefined_function_3(ptr noundef %sc, ptr noundef %r, ptr noundef %s, i64 noundef %t, ptr noundef %u) #0 {
entry:
  %sc.addr = alloca ptr, align 8
  %r.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %t.addr = alloca i64, align 8
  %u.addr = alloca ptr, align 8
  store ptr %sc, ptr %sc.addr, align 8
  store ptr %r, ptr %r.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %t, ptr %t.addr, align 8
  store ptr %u, ptr %u.addr, align 8
  %0 = load ptr, ptr %sc.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 0
  %call = call i32 @ssl_undefined_function(ptr noundef %ssl)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @ssl_undefined_function_4(ptr noundef %sc, i32 noundef %r) #0 {
entry:
  %sc.addr = alloca ptr, align 8
  %r.addr = alloca i32, align 4
  store ptr %sc, ptr %sc.addr, align 8
  store i32 %r, ptr %r.addr, align 4
  %0 = load ptr, ptr %sc.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 0
  %call = call i32 @ssl_undefined_function(ptr noundef %ssl)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @ssl_undefined_function_5(ptr noundef %sc, ptr noundef %r, i64 noundef %s, ptr noundef %t) #0 {
entry:
  %sc.addr = alloca ptr, align 8
  %r.addr = alloca ptr, align 8
  %s.addr = alloca i64, align 8
  %t.addr = alloca ptr, align 8
  store ptr %sc, ptr %sc.addr, align 8
  store ptr %r, ptr %r.addr, align 8
  store i64 %s, ptr %s.addr, align 8
  store ptr %t, ptr %t.addr, align 8
  %0 = load ptr, ptr %sc.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 0
  %call = call i32 @ssl_undefined_function(ptr noundef %ssl)
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind uwtable
define internal i32 @ssl_undefined_function_6(i32 noundef %r) #0 {
entry:
  %r.addr = alloca i32, align 4
  store i32 %r, ptr %r.addr, align 4
  %call = call i32 @ssl_undefined_function(ptr noundef null)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @ssl_undefined_function_7(ptr noundef %sc, ptr noundef %r, i64 noundef %s, ptr noundef %t, i64 noundef %u, ptr noundef %v, i64 noundef %w, i32 noundef %x) #0 {
entry:
  %sc.addr = alloca ptr, align 8
  %r.addr = alloca ptr, align 8
  %s.addr = alloca i64, align 8
  %t.addr = alloca ptr, align 8
  %u.addr = alloca i64, align 8
  %v.addr = alloca ptr, align 8
  %w.addr = alloca i64, align 8
  %x.addr = alloca i32, align 4
  store ptr %sc, ptr %sc.addr, align 8
  store ptr %r, ptr %r.addr, align 8
  store i64 %s, ptr %s.addr, align 8
  store ptr %t, ptr %t.addr, align 8
  store i64 %u, ptr %u.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  store i64 %w, ptr %w.addr, align 8
  store i32 %x, ptr %x.addr, align 4
  %0 = load ptr, ptr %sc.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 0
  %call = call i32 @ssl_undefined_function(ptr noundef %ssl)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @SSL_clear(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %method, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 590, ptr noundef @__func__.SSL_clear)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 188, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %method1 = getelementptr inbounds %struct.ssl_st, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %method1, align 8
  %ssl_reset = getelementptr inbounds %struct.ssl_method_st, ptr %3, i32 0, i32 5
  %4 = load ptr, ptr %ssl_reset, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 %4(ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare void @ERR_new() #1

declare void @ERR_set_debug(ptr noundef, i32 noundef, ptr noundef) #1

declare void @ERR_set_error(i32 noundef, i32 noundef, ptr noundef, ...) #1

; Function Attrs: nounwind uwtable
define i32 @ossl_ssl_connection_reset(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %call = call i32 @ssl_clear_bad_session(ptr noundef %9)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end
  %10 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 50
  %11 = load ptr, ptr %session, align 8
  call void @SSL_SESSION_free(ptr noundef %11)
  %12 = load ptr, ptr %sc, align 8
  %session14 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 50
  store ptr null, ptr %session14, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end
  %13 = load ptr, ptr %sc, align 8
  %psksession = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 51
  %14 = load ptr, ptr %psksession, align 8
  call void @SSL_SESSION_free(ptr noundef %14)
  %15 = load ptr, ptr %sc, align 8
  %psksession16 = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 51
  store ptr null, ptr %psksession16, align 8
  %16 = load ptr, ptr %sc, align 8
  %psksession_id = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 52
  %17 = load ptr, ptr %psksession_id, align 8
  call void @CRYPTO_free(ptr noundef %17, ptr noundef @.str, i32 noundef 610)
  %18 = load ptr, ptr %sc, align 8
  %psksession_id17 = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 52
  store ptr null, ptr %psksession_id17, align 8
  %19 = load ptr, ptr %sc, align 8
  %psksession_id_len = getelementptr inbounds %struct.ssl_connection_st, ptr %19, i32 0, i32 53
  store i64 0, ptr %psksession_id_len, align 8
  %20 = load ptr, ptr %sc, align 8
  %hello_retry_request = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 47
  store i32 0, ptr %hello_retry_request, align 8
  %21 = load ptr, ptr %sc, align 8
  %sent_tickets = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 110
  store i64 0, ptr %sent_tickets, align 8
  %22 = load ptr, ptr %sc, align 8
  %error = getelementptr inbounds %struct.ssl_connection_st, ptr %22, i32 0, i32 60
  store i32 0, ptr %error, align 8
  %23 = load ptr, ptr %sc, align 8
  %hit = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 24
  store i32 0, ptr %hit, align 8
  %24 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %24, i32 0, i32 10
  store i32 0, ptr %shutdown, align 4
  %25 = load ptr, ptr %sc, align 8
  %renegotiate = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 90
  %26 = load i32, ptr %renegotiate, align 8
  %tobool18 = icmp ne i32 %26, 0
  br i1 %tobool18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end15
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 621, ptr noundef @__func__.ossl_ssl_connection_reset)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786691, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.end15
  %27 = load ptr, ptr %sc, align 8
  call void @ossl_statem_clear(ptr noundef %27)
  %28 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %28, i32 0, i32 3
  %29 = load ptr, ptr %method, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %29, i32 0, i32 0
  %30 = load i32, ptr %version, align 8
  %31 = load ptr, ptr %sc, align 8
  %version21 = getelementptr inbounds %struct.ssl_connection_st, ptr %31, i32 0, i32 1
  store i32 %30, ptr %version21, align 8
  %32 = load ptr, ptr %sc, align 8
  %version22 = getelementptr inbounds %struct.ssl_connection_st, ptr %32, i32 0, i32 1
  %33 = load i32, ptr %version22, align 8
  %34 = load ptr, ptr %sc, align 8
  %client_version = getelementptr inbounds %struct.ssl_connection_st, ptr %34, i32 0, i32 76
  store i32 %33, ptr %client_version, align 4
  %35 = load ptr, ptr %sc, align 8
  %rwstate = getelementptr inbounds %struct.ssl_connection_st, ptr %35, i32 0, i32 5
  store i32 1, ptr %rwstate, align 8
  %36 = load ptr, ptr %sc, align 8
  %init_buf = getelementptr inbounds %struct.ssl_connection_st, ptr %36, i32 0, i32 15
  %37 = load ptr, ptr %init_buf, align 8
  call void @BUF_MEM_free(ptr noundef %37)
  %38 = load ptr, ptr %sc, align 8
  %init_buf23 = getelementptr inbounds %struct.ssl_connection_st, ptr %38, i32 0, i32 15
  store ptr null, ptr %init_buf23, align 8
  %39 = load ptr, ptr %sc, align 8
  %first_packet = getelementptr inbounds %struct.ssl_connection_st, ptr %39, i32 0, i32 75
  store i32 0, ptr %first_packet, align 8
  %40 = load ptr, ptr %sc, align 8
  %key_update = getelementptr inbounds %struct.ssl_connection_st, ptr %40, i32 0, i32 91
  store i32 -1, ptr %key_update, align 4
  %41 = load ptr, ptr %sc, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %41, i32 0, i32 80
  %compress_certificate_from_peer = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 37
  %arraydecay = getelementptr inbounds [4 x i32], ptr %compress_certificate_from_peer, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 4 %arraydecay, i8 0, i64 16, i1 false)
  %42 = load ptr, ptr %sc, align 8
  %ext24 = getelementptr inbounds %struct.ssl_connection_st, ptr %42, i32 0, i32 80
  %compress_certificate_sent = getelementptr inbounds %struct.anon.1, ptr %ext24, i32 0, i32 38
  store i32 0, ptr %compress_certificate_sent, align 4
  %43 = load ptr, ptr %sc, align 8
  %pha_dgst = getelementptr inbounds %struct.ssl_connection_st, ptr %43, i32 0, i32 97
  %44 = load ptr, ptr %pha_dgst, align 8
  call void @EVP_MD_CTX_free(ptr noundef %44)
  %45 = load ptr, ptr %sc, align 8
  %pha_dgst25 = getelementptr inbounds %struct.ssl_connection_st, ptr %45, i32 0, i32 97
  store ptr null, ptr %pha_dgst25, align 8
  %46 = load ptr, ptr %sc, align 8
  %dane = getelementptr inbounds %struct.ssl_connection_st, ptr %46, i32 0, i32 26
  %mdpth = getelementptr inbounds %struct.ssl_dane_st, ptr %dane, i32 0, i32 6
  store i32 -1, ptr %mdpth, align 4
  %47 = load ptr, ptr %sc, align 8
  %dane26 = getelementptr inbounds %struct.ssl_connection_st, ptr %47, i32 0, i32 26
  %pdpth = getelementptr inbounds %struct.ssl_dane_st, ptr %dane26, i32 0, i32 7
  store i32 -1, ptr %pdpth, align 8
  %48 = load ptr, ptr %sc, align 8
  %dane27 = getelementptr inbounds %struct.ssl_connection_st, ptr %48, i32 0, i32 26
  %mcert = getelementptr inbounds %struct.ssl_dane_st, ptr %dane27, i32 0, i32 4
  %49 = load ptr, ptr %mcert, align 8
  call void @X509_free(ptr noundef %49)
  %50 = load ptr, ptr %sc, align 8
  %dane28 = getelementptr inbounds %struct.ssl_connection_st, ptr %50, i32 0, i32 26
  %mcert29 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane28, i32 0, i32 4
  store ptr null, ptr %mcert29, align 8
  %51 = load ptr, ptr %sc, align 8
  %dane30 = getelementptr inbounds %struct.ssl_connection_st, ptr %51, i32 0, i32 26
  %mtlsa = getelementptr inbounds %struct.ssl_dane_st, ptr %dane30, i32 0, i32 3
  store ptr null, ptr %mtlsa, align 8
  %52 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %52, i32 0, i32 25
  %53 = load ptr, ptr %param, align 8
  call void @X509_VERIFY_PARAM_move_peername(ptr noundef %53, ptr noundef null)
  %54 = load ptr, ptr %sc, align 8
  %shared_sigalgs = getelementptr inbounds %struct.ssl_connection_st, ptr %54, i32 0, i32 116
  %55 = load ptr, ptr %shared_sigalgs, align 8
  call void @CRYPTO_free(ptr noundef %55, ptr noundef @.str, i32 noundef 654)
  %56 = load ptr, ptr %sc, align 8
  %shared_sigalgs31 = getelementptr inbounds %struct.ssl_connection_st, ptr %56, i32 0, i32 116
  store ptr null, ptr %shared_sigalgs31, align 8
  %57 = load ptr, ptr %sc, align 8
  %shared_sigalgslen = getelementptr inbounds %struct.ssl_connection_st, ptr %57, i32 0, i32 117
  store i64 0, ptr %shared_sigalgslen, align 8
  %58 = load ptr, ptr %s.addr, align 8
  %method32 = getelementptr inbounds %struct.ssl_st, ptr %58, i32 0, i32 3
  %59 = load ptr, ptr %method32, align 8
  %60 = load ptr, ptr %s.addr, align 8
  %defltmeth = getelementptr inbounds %struct.ssl_st, ptr %60, i32 0, i32 2
  %61 = load ptr, ptr %defltmeth, align 8
  %cmp33 = icmp ne ptr %59, %61
  br i1 %cmp33, label %if.then34, label %if.else

if.then34:                                        ; preds = %if.end20
  %62 = load ptr, ptr %s.addr, align 8
  %method35 = getelementptr inbounds %struct.ssl_st, ptr %62, i32 0, i32 3
  %63 = load ptr, ptr %method35, align 8
  %ssl_deinit = getelementptr inbounds %struct.ssl_method_st, ptr %63, i32 0, i32 8
  %64 = load ptr, ptr %ssl_deinit, align 8
  %65 = load ptr, ptr %s.addr, align 8
  call void %64(ptr noundef %65)
  %66 = load ptr, ptr %s.addr, align 8
  %defltmeth36 = getelementptr inbounds %struct.ssl_st, ptr %66, i32 0, i32 2
  %67 = load ptr, ptr %defltmeth36, align 8
  %68 = load ptr, ptr %s.addr, align 8
  %method37 = getelementptr inbounds %struct.ssl_st, ptr %68, i32 0, i32 3
  store ptr %67, ptr %method37, align 8
  %69 = load ptr, ptr %s.addr, align 8
  %method38 = getelementptr inbounds %struct.ssl_st, ptr %69, i32 0, i32 3
  %70 = load ptr, ptr %method38, align 8
  %ssl_init = getelementptr inbounds %struct.ssl_method_st, ptr %70, i32 0, i32 6
  %71 = load ptr, ptr %ssl_init, align 8
  %72 = load ptr, ptr %s.addr, align 8
  %call39 = call i32 %71(ptr noundef %72)
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %if.then34
  store i32 0, ptr %retval, align 4
  br label %return

if.end42:                                         ; preds = %if.then34
  br label %if.end48

if.else:                                          ; preds = %if.end20
  %73 = load ptr, ptr %s.addr, align 8
  %method43 = getelementptr inbounds %struct.ssl_st, ptr %73, i32 0, i32 3
  %74 = load ptr, ptr %method43, align 8
  %ssl_clear = getelementptr inbounds %struct.ssl_method_st, ptr %74, i32 0, i32 7
  %75 = load ptr, ptr %ssl_clear, align 8
  %76 = load ptr, ptr %s.addr, align 8
  %call44 = call i32 %75(ptr noundef %76)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.end47, label %if.then46

if.then46:                                        ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

if.end47:                                         ; preds = %if.else
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.end42
  %77 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %77, i32 0, i32 100
  call void @RECORD_LAYER_clear(ptr noundef %rlayer)
  %78 = load ptr, ptr %sc, align 8
  %rlayer49 = getelementptr inbounds %struct.ssl_connection_st, ptr %78, i32 0, i32 100
  %rrlnext = getelementptr inbounds %struct.record_layer_st, ptr %rlayer49, i32 0, i32 7
  %79 = load ptr, ptr %rrlnext, align 8
  %call50 = call i32 @BIO_free(ptr noundef %79)
  %80 = load ptr, ptr %sc, align 8
  %rlayer51 = getelementptr inbounds %struct.ssl_connection_st, ptr %80, i32 0, i32 100
  %rrlnext52 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer51, i32 0, i32 7
  store ptr null, ptr %rrlnext52, align 8
  %81 = load ptr, ptr %sc, align 8
  %call53 = call i32 @clear_record_layer(ptr noundef %81)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %if.end56, label %if.then55

if.then55:                                        ; preds = %if.end48
  store i32 0, ptr %retval, align 4
  br label %return

if.end56:                                         ; preds = %if.end48
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end56, %if.then55, %if.then46, %if.then41, %if.then19, %if.then
  %82 = load i32, ptr %retval, align 4
  ret i32 %82
}

declare i32 @ssl_clear_bad_session(ptr noundef) #1

declare void @SSL_SESSION_free(ptr noundef) #1

declare void @CRYPTO_free(ptr noundef, ptr noundef, i32 noundef) #1

declare void @ossl_statem_clear(ptr noundef) #1

declare void @BUF_MEM_free(ptr noundef) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #2

declare void @EVP_MD_CTX_free(ptr noundef) #1

declare void @X509_free(ptr noundef) #1

declare void @X509_VERIFY_PARAM_move_peername(ptr noundef, ptr noundef) #1

declare void @RECORD_LAYER_clear(ptr noundef) #1

declare i32 @BIO_free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @clear_record_layer(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %1, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %2 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %2, i32 0, i32 28
  %3 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %3, i32 0, i32 10
  %4 = load i32, ptr %enc_flags, align 8
  %and = and i32 %4, 8
  %tobool = icmp ne i32 %and, 0
  %cond = select i1 %tobool, i32 131071, i32 65536
  %call = call i32 @ssl_set_new_record_layer(ptr noundef %0, i32 noundef %cond, i32 noundef 0, i32 noundef 0, ptr noundef null, i64 noundef 0, ptr noundef null, i64 noundef 0, ptr noundef null, i64 noundef 0, ptr noundef null, i64 noundef 0, ptr noundef null, i64 noundef 0, i32 noundef 0, ptr noundef null, ptr noundef null, ptr noundef null)
  store i32 %call, ptr %ret, align 4
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %ssl1 = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 0
  %method2 = getelementptr inbounds %struct.ssl_st, ptr %ssl1, i32 0, i32 3
  %7 = load ptr, ptr %method2, align 8
  %ssl3_enc3 = getelementptr inbounds %struct.ssl_method_st, ptr %7, i32 0, i32 28
  %8 = load ptr, ptr %ssl3_enc3, align 8
  %enc_flags4 = getelementptr inbounds %struct.ssl3_enc_method, ptr %8, i32 0, i32 10
  %9 = load i32, ptr %enc_flags4, align 8
  %and5 = and i32 %9, 8
  %tobool6 = icmp ne i32 %and5, 0
  %cond7 = select i1 %tobool6, i32 131071, i32 65536
  %call8 = call i32 @ssl_set_new_record_layer(ptr noundef %5, i32 noundef %cond7, i32 noundef 1, i32 noundef 0, ptr noundef null, i64 noundef 0, ptr noundef null, i64 noundef 0, ptr noundef null, i64 noundef 0, ptr noundef null, i64 noundef 0, ptr noundef null, i64 noundef 0, i32 noundef 0, ptr noundef null, ptr noundef null, ptr noundef null)
  %10 = load i32, ptr %ret, align 4
  %and9 = and i32 %10, %call8
  store i32 %and9, ptr %ret, align 4
  %11 = load i32, ptr %ret, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_ssl_version(ptr noundef %ctx, ptr noundef %meth) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %meth.addr = alloca ptr, align 8
  %sk = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %meth, ptr %meth.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %method = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %method, align 8
  %call = call ptr @OSSL_QUIC_client_method()
  %cmp = icmp eq ptr %1, %call
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %method1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %method1, align 8
  %call2 = call ptr @OSSL_QUIC_client_thread_method()
  %cmp3 = icmp eq ptr %3, %call2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 689, ptr noundef @__func__.SSL_CTX_set_ssl_version)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 266, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %meth.addr, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %method4 = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 1
  store ptr %4, ptr %method4, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %call5 = call ptr @OSSL_default_ciphersuites()
  %call6 = call i32 @SSL_CTX_set_ciphersuites(ptr noundef %6, ptr noundef %call5)
  %tobool = icmp ne i32 %call6, 0
  br i1 %tobool, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 696, ptr noundef @__func__.SSL_CTX_set_ssl_version)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 230, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %7 = load ptr, ptr %ctx.addr, align 8
  %8 = load ptr, ptr %ctx.addr, align 8
  %tls13_ciphersuites = getelementptr inbounds %struct.ssl_ctx_st, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %tls13_ciphersuites, align 8
  %10 = load ptr, ptr %ctx.addr, align 8
  %cipher_list = getelementptr inbounds %struct.ssl_ctx_st, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %ctx.addr, align 8
  %cipher_list_by_id = getelementptr inbounds %struct.ssl_ctx_st, ptr %11, i32 0, i32 3
  %call9 = call ptr @OSSL_default_cipher_list()
  %12 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %12, i32 0, i32 39
  %13 = load ptr, ptr %cert, align 8
  %call10 = call ptr @ssl_create_cipher_list(ptr noundef %7, ptr noundef %9, ptr noundef %cipher_list, ptr noundef %cipher_list_by_id, ptr noundef %call9, ptr noundef %13)
  store ptr %call10, ptr %sk, align 8
  %14 = load ptr, ptr %sk, align 8
  %cmp11 = icmp eq ptr %14, null
  br i1 %cmp11, label %if.then16, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %if.end8
  %15 = load ptr, ptr %sk, align 8
  %call13 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %15)
  %call14 = call i32 @OPENSSL_sk_num(ptr noundef %call13)
  %cmp15 = icmp sle i32 %call14, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false12, %if.end8
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 705, ptr noundef @__func__.SSL_CTX_set_ssl_version)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 230, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %lor.lhs.false12
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end17, %if.then16, %if.then7, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

declare ptr @OSSL_QUIC_client_method() #1

declare ptr @OSSL_QUIC_client_thread_method() #1

declare i32 @SSL_CTX_set_ciphersuites(ptr noundef, ptr noundef) #1

declare ptr @OSSL_default_ciphersuites() #1

declare ptr @ssl_create_cipher_list(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @OSSL_default_cipher_list() #1

declare i32 @OPENSSL_sk_num(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define ptr @SSL_new(ptr noundef %ctx) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 715, ptr noundef @__func__.SSL_new)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 195, ptr noundef null)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %method = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %method, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 719, ptr noundef @__func__.SSL_new)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 228, ptr noundef null)
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr %ctx.addr, align 8
  %method4 = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %method4, align 8
  %ssl_new = getelementptr inbounds %struct.ssl_method_st, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %ssl_new, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %call = call ptr %5(ptr noundef %6)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

; Function Attrs: nounwind uwtable
define i32 @ossl_ssl_init(ptr noundef %ssl, ptr noundef %ctx, ptr noundef %method, i32 noundef %type) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %method.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %method, ptr %method.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %1 = load ptr, ptr %ssl.addr, align 8
  %type1 = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  store i32 %0, ptr %type1, align 8
  %call = call ptr @CRYPTO_THREAD_lock_new()
  %2 = load ptr, ptr %ssl.addr, align 8
  %lock = getelementptr inbounds %struct.ssl_st, ptr %2, i32 0, i32 5
  store ptr %call, ptr %lock, align 8
  %3 = load ptr, ptr %ssl.addr, align 8
  %lock2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 5
  %4 = load ptr, ptr %lock2, align 8
  %cmp = icmp eq ptr %4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %ssl.addr, align 8
  %references = getelementptr inbounds %struct.ssl_st, ptr %5, i32 0, i32 4
  %call3 = call i32 @CRYPTO_NEW_REF(ptr noundef %references, i32 noundef 1)
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.end6, label %if.then4

if.then4:                                         ; preds = %if.end
  %6 = load ptr, ptr %ssl.addr, align 8
  %lock5 = getelementptr inbounds %struct.ssl_st, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %lock5, align 8
  call void @CRYPTO_THREAD_lock_free(ptr noundef %7)
  store i32 0, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %8 = load ptr, ptr %ssl.addr, align 8
  %9 = load ptr, ptr %ssl.addr, align 8
  %ex_data = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 6
  %call7 = call i32 @CRYPTO_new_ex_data(i32 noundef 0, ptr noundef %8, ptr noundef %ex_data)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end13, label %if.then9

if.then9:                                         ; preds = %if.end6
  %10 = load ptr, ptr %ssl.addr, align 8
  %lock10 = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 5
  %11 = load ptr, ptr %lock10, align 8
  call void @CRYPTO_THREAD_lock_free(ptr noundef %11)
  %12 = load ptr, ptr %ssl.addr, align 8
  %references11 = getelementptr inbounds %struct.ssl_st, ptr %12, i32 0, i32 4
  call void @CRYPTO_FREE_REF(ptr noundef %references11)
  %13 = load ptr, ptr %ssl.addr, align 8
  %lock12 = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 5
  store ptr null, ptr %lock12, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end6
  %14 = load ptr, ptr %ctx.addr, align 8
  %call14 = call i32 @SSL_CTX_up_ref(ptr noundef %14)
  %15 = load ptr, ptr %ctx.addr, align 8
  %16 = load ptr, ptr %ssl.addr, align 8
  %ctx15 = getelementptr inbounds %struct.ssl_st, ptr %16, i32 0, i32 1
  store ptr %15, ptr %ctx15, align 8
  %17 = load ptr, ptr %method.addr, align 8
  %18 = load ptr, ptr %ssl.addr, align 8
  %method16 = getelementptr inbounds %struct.ssl_st, ptr %18, i32 0, i32 3
  store ptr %17, ptr %method16, align 8
  %19 = load ptr, ptr %ssl.addr, align 8
  %defltmeth = getelementptr inbounds %struct.ssl_st, ptr %19, i32 0, i32 2
  store ptr %17, ptr %defltmeth, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then9, %if.then4, %if.then
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

declare ptr @CRYPTO_THREAD_lock_new() #1

; Function Attrs: nounwind uwtable
define internal i32 @CRYPTO_NEW_REF(ptr noundef %refcnt, i32 noundef %n) #0 {
entry:
  %refcnt.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %refcnt, ptr %refcnt.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %1 = load ptr, ptr %refcnt.addr, align 8
  %val = getelementptr inbounds %struct.CRYPTO_REF_COUNT, ptr %1, i32 0, i32 0
  store atomic i32 %0, ptr %val seq_cst, align 4
  ret i32 1
}

declare void @CRYPTO_THREAD_lock_free(ptr noundef) #1

declare i32 @CRYPTO_new_ex_data(i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @CRYPTO_FREE_REF(ptr noundef %refcnt) #0 {
entry:
  %refcnt.addr = alloca ptr, align 8
  store ptr %refcnt, ptr %refcnt.addr, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_up_ref(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %references = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 16
  %call = call i32 @CRYPTO_UP_REF(ptr noundef %references, ptr noundef %i)
  %cmp = icmp sle i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %i, align 4
  %cmp1 = icmp sgt i32 %1, 1
  %cond = select i1 %cmp1, i32 1, i32 0
  store i32 %cond, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define ptr @ossl_ssl_connection_new_int(ptr noundef %ctx, ptr noundef %method) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %method.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %ssl = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %method, ptr %method.addr, align 8
  %call = call noalias ptr @CRYPTO_zalloc(i64 noundef 5400, ptr noundef @.str, i32 noundef 758)
  store ptr %call, ptr %s, align 8
  %0 = load ptr, ptr %s, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %s, align 8
  %ssl1 = getelementptr inbounds %struct.ssl_connection_st, ptr %1, i32 0, i32 0
  store ptr %ssl1, ptr %ssl, align 8
  %2 = load ptr, ptr %ssl, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load ptr, ptr %method.addr, align 8
  %call2 = call i32 @ossl_ssl_init(ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef 0)
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %s, align 8
  call void @CRYPTO_free(ptr noundef %5, ptr noundef @.str, i32 noundef 764)
  store ptr null, ptr %s, align 8
  store ptr null, ptr %ssl, align 8
  br label %sslerr

if.end4:                                          ; preds = %if.end
  %6 = load ptr, ptr %s, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 100
  %7 = load ptr, ptr %s, align 8
  call void @RECORD_LAYER_init(ptr noundef %rlayer, ptr noundef %7)
  %8 = load ptr, ptr %ctx.addr, align 8
  %options = getelementptr inbounds %struct.ssl_ctx_st, ptr %8, i32 0, i32 34
  %9 = load i64, ptr %options, align 8
  %10 = load ptr, ptr %s, align 8
  %options5 = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 70
  store i64 %9, ptr %options5, align 8
  %11 = load ptr, ptr %ctx.addr, align 8
  %dane = getelementptr inbounds %struct.ssl_ctx_st, ptr %11, i32 0, i32 67
  %flags = getelementptr inbounds %struct.dane_ctx_st, ptr %dane, i32 0, i32 3
  %12 = load i64, ptr %flags, align 8
  %13 = load ptr, ptr %s, align 8
  %dane6 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 26
  %flags7 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane6, i32 0, i32 8
  store i64 %12, ptr %flags7, align 8
  %14 = load ptr, ptr %method.addr, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 0
  %15 = load i32, ptr %version, align 8
  %16 = load ptr, ptr %ctx.addr, align 8
  %method8 = getelementptr inbounds %struct.ssl_ctx_st, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %method8, align 8
  %version9 = getelementptr inbounds %struct.ssl_method_st, ptr %17, i32 0, i32 0
  %18 = load i32, ptr %version9, align 8
  %cmp10 = icmp eq i32 %15, %18
  br i1 %cmp10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %if.end4
  %19 = load ptr, ptr %ctx.addr, align 8
  %min_proto_version = getelementptr inbounds %struct.ssl_ctx_st, ptr %19, i32 0, i32 36
  %20 = load i32, ptr %min_proto_version, align 4
  %21 = load ptr, ptr %s, align 8
  %min_proto_version12 = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 72
  store i32 %20, ptr %min_proto_version12, align 4
  %22 = load ptr, ptr %ctx.addr, align 8
  %max_proto_version = getelementptr inbounds %struct.ssl_ctx_st, ptr %22, i32 0, i32 37
  %23 = load i32, ptr %max_proto_version, align 8
  %24 = load ptr, ptr %s, align 8
  %max_proto_version13 = getelementptr inbounds %struct.ssl_connection_st, ptr %24, i32 0, i32 73
  store i32 %23, ptr %max_proto_version13, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then11, %if.end4
  %25 = load ptr, ptr %ctx.addr, align 8
  %mode = getelementptr inbounds %struct.ssl_ctx_st, ptr %25, i32 0, i32 35
  %26 = load i32, ptr %mode, align 8
  %27 = load ptr, ptr %s, align 8
  %mode15 = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 71
  store i32 %26, ptr %mode15, align 8
  %28 = load ptr, ptr %ctx.addr, align 8
  %max_cert_list = getelementptr inbounds %struct.ssl_ctx_st, ptr %28, i32 0, i32 38
  %29 = load i64, ptr %max_cert_list, align 8
  %30 = load ptr, ptr %s, align 8
  %max_cert_list16 = getelementptr inbounds %struct.ssl_connection_st, ptr %30, i32 0, i32 74
  store i64 %29, ptr %max_cert_list16, align 8
  %31 = load ptr, ptr %ctx.addr, align 8
  %max_early_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %31, i32 0, i32 72
  %32 = load i32, ptr %max_early_data, align 8
  %33 = load ptr, ptr %s, align 8
  %max_early_data17 = getelementptr inbounds %struct.ssl_connection_st, ptr %33, i32 0, i32 106
  store i32 %32, ptr %max_early_data17, align 8
  %34 = load ptr, ptr %ctx.addr, align 8
  %recv_max_early_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %34, i32 0, i32 73
  %35 = load i32, ptr %recv_max_early_data, align 4
  %36 = load ptr, ptr %s, align 8
  %recv_max_early_data18 = getelementptr inbounds %struct.ssl_connection_st, ptr %36, i32 0, i32 107
  store i32 %35, ptr %recv_max_early_data18, align 4
  %37 = load ptr, ptr %ctx.addr, align 8
  %num_tickets = getelementptr inbounds %struct.ssl_ctx_st, ptr %37, i32 0, i32 80
  %38 = load i64, ptr %num_tickets, align 8
  %39 = load ptr, ptr %s, align 8
  %num_tickets19 = getelementptr inbounds %struct.ssl_connection_st, ptr %39, i32 0, i32 109
  store i64 %38, ptr %num_tickets19, align 8
  %40 = load ptr, ptr %ctx.addr, align 8
  %pha_enabled = getelementptr inbounds %struct.ssl_ctx_st, ptr %40, i32 0, i32 83
  %41 = load i32, ptr %pha_enabled, align 8
  %42 = load ptr, ptr %s, align 8
  %pha_enabled20 = getelementptr inbounds %struct.ssl_connection_st, ptr %42, i32 0, i32 93
  store i32 %41, ptr %pha_enabled20, align 4
  %43 = load ptr, ptr %ctx.addr, align 8
  %tls13_ciphersuites = getelementptr inbounds %struct.ssl_ctx_st, ptr %43, i32 0, i32 4
  %44 = load ptr, ptr %tls13_ciphersuites, align 8
  %call21 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %44)
  %call22 = call ptr @OPENSSL_sk_dup(ptr noundef %call21)
  %45 = load ptr, ptr %s, align 8
  %tls13_ciphersuites23 = getelementptr inbounds %struct.ssl_connection_st, ptr %45, i32 0, i32 30
  store ptr %call22, ptr %tls13_ciphersuites23, align 8
  %46 = load ptr, ptr %s, align 8
  %tls13_ciphersuites24 = getelementptr inbounds %struct.ssl_connection_st, ptr %46, i32 0, i32 30
  %47 = load ptr, ptr %tls13_ciphersuites24, align 8
  %cmp25 = icmp eq ptr %47, null
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end14
  br label %cerr

if.end27:                                         ; preds = %if.end14
  %48 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %48, i32 0, i32 39
  %49 = load ptr, ptr %cert, align 8
  %call28 = call ptr @ssl_cert_dup(ptr noundef %49)
  %50 = load ptr, ptr %s, align 8
  %cert29 = getelementptr inbounds %struct.ssl_connection_st, ptr %50, i32 0, i32 44
  store ptr %call28, ptr %cert29, align 8
  %51 = load ptr, ptr %s, align 8
  %cert30 = getelementptr inbounds %struct.ssl_connection_st, ptr %51, i32 0, i32 44
  %52 = load ptr, ptr %cert30, align 8
  %cmp31 = icmp eq ptr %52, null
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %if.end27
  br label %sslerr

if.end33:                                         ; preds = %if.end27
  %53 = load ptr, ptr %ctx.addr, align 8
  %read_ahead = getelementptr inbounds %struct.ssl_ctx_st, ptr %53, i32 0, i32 41
  %54 = load i32, ptr %read_ahead, align 8
  %55 = load ptr, ptr %s, align 8
  %rlayer34 = getelementptr inbounds %struct.ssl_connection_st, ptr %55, i32 0, i32 100
  %read_ahead35 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer34, i32 0, i32 9
  store i32 %54, ptr %read_ahead35, align 8
  %56 = load ptr, ptr %ctx.addr, align 8
  %msg_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %56, i32 0, i32 42
  %57 = load ptr, ptr %msg_callback, align 8
  %58 = load ptr, ptr %s, align 8
  %msg_callback36 = getelementptr inbounds %struct.ssl_connection_st, ptr %58, i32 0, i32 22
  store ptr %57, ptr %msg_callback36, align 8
  %59 = load ptr, ptr %ctx.addr, align 8
  %msg_callback_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %59, i32 0, i32 43
  %60 = load ptr, ptr %msg_callback_arg, align 8
  %61 = load ptr, ptr %s, align 8
  %msg_callback_arg37 = getelementptr inbounds %struct.ssl_connection_st, ptr %61, i32 0, i32 23
  store ptr %60, ptr %msg_callback_arg37, align 8
  %62 = load ptr, ptr %ctx.addr, align 8
  %verify_mode = getelementptr inbounds %struct.ssl_ctx_st, ptr %62, i32 0, i32 44
  %63 = load i32, ptr %verify_mode, align 8
  %64 = load ptr, ptr %s, align 8
  %verify_mode38 = getelementptr inbounds %struct.ssl_connection_st, ptr %64, i32 0, i32 57
  store i32 %63, ptr %verify_mode38, align 8
  %65 = load ptr, ptr %ctx.addr, align 8
  %not_resumable_session_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %65, i32 0, i32 69
  %66 = load ptr, ptr %not_resumable_session_cb, align 8
  %67 = load ptr, ptr %s, align 8
  %not_resumable_session_cb39 = getelementptr inbounds %struct.ssl_connection_st, ptr %67, i32 0, i32 99
  store ptr %66, ptr %not_resumable_session_cb39, align 8
  %68 = load ptr, ptr %ctx.addr, align 8
  %record_padding_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %68, i32 0, i32 74
  %69 = load ptr, ptr %record_padding_cb, align 8
  %70 = load ptr, ptr %s, align 8
  %rlayer40 = getelementptr inbounds %struct.ssl_connection_st, ptr %70, i32 0, i32 100
  %record_padding_cb41 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer40, i32 0, i32 19
  store ptr %69, ptr %record_padding_cb41, align 8
  %71 = load ptr, ptr %ctx.addr, align 8
  %record_padding_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %71, i32 0, i32 75
  %72 = load ptr, ptr %record_padding_arg, align 8
  %73 = load ptr, ptr %s, align 8
  %rlayer42 = getelementptr inbounds %struct.ssl_connection_st, ptr %73, i32 0, i32 100
  %record_padding_arg43 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer42, i32 0, i32 20
  store ptr %72, ptr %record_padding_arg43, align 8
  %74 = load ptr, ptr %ctx.addr, align 8
  %block_padding = getelementptr inbounds %struct.ssl_ctx_st, ptr %74, i32 0, i32 76
  %75 = load i64, ptr %block_padding, align 8
  %76 = load ptr, ptr %s, align 8
  %rlayer44 = getelementptr inbounds %struct.ssl_connection_st, ptr %76, i32 0, i32 100
  %block_padding45 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer44, i32 0, i32 21
  store i64 %75, ptr %block_padding45, align 8
  %77 = load ptr, ptr %ctx.addr, align 8
  %sid_ctx_length = getelementptr inbounds %struct.ssl_ctx_st, ptr %77, i32 0, i32 45
  %78 = load i64, ptr %sid_ctx_length, align 8
  %79 = load ptr, ptr %s, align 8
  %sid_ctx_length46 = getelementptr inbounds %struct.ssl_connection_st, ptr %79, i32 0, i32 48
  store i64 %78, ptr %sid_ctx_length46, align 8
  %80 = load ptr, ptr %s, align 8
  %sid_ctx_length47 = getelementptr inbounds %struct.ssl_connection_st, ptr %80, i32 0, i32 48
  %81 = load i64, ptr %sid_ctx_length47, align 8
  %cmp48 = icmp ule i64 %81, 32
  %conv = zext i1 %cmp48 to i32
  %cmp49 = icmp ne i32 %conv, 0
  %lnot = xor i1 %cmp49, true
  %lnot51 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot51 to i32
  %conv52 = sext i32 %lnot.ext to i64
  %tobool53 = icmp ne i64 %conv52, 0
  br i1 %tobool53, label %if.end55, label %if.then54

if.then54:                                        ; preds = %if.end33
  br label %err

if.end55:                                         ; preds = %if.end33
  %82 = load ptr, ptr %s, align 8
  %sid_ctx = getelementptr inbounds %struct.ssl_connection_st, ptr %82, i32 0, i32 49
  %83 = load ptr, ptr %ctx.addr, align 8
  %sid_ctx56 = getelementptr inbounds %struct.ssl_ctx_st, ptr %83, i32 0, i32 46
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %sid_ctx, ptr align 8 %sid_ctx56, i64 32, i1 false)
  %84 = load ptr, ptr %ctx.addr, align 8
  %default_verify_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %84, i32 0, i32 47
  %85 = load ptr, ptr %default_verify_callback, align 8
  %86 = load ptr, ptr %s, align 8
  %verify_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %86, i32 0, i32 58
  store ptr %85, ptr %verify_callback, align 8
  %87 = load ptr, ptr %ctx.addr, align 8
  %generate_session_id = getelementptr inbounds %struct.ssl_ctx_st, ptr %87, i32 0, i32 48
  %88 = load ptr, ptr %generate_session_id, align 8
  %89 = load ptr, ptr %s, align 8
  %generate_session_id57 = getelementptr inbounds %struct.ssl_connection_st, ptr %89, i32 0, i32 54
  store ptr %88, ptr %generate_session_id57, align 8
  %call58 = call ptr @X509_VERIFY_PARAM_new()
  %90 = load ptr, ptr %s, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %90, i32 0, i32 25
  store ptr %call58, ptr %param, align 8
  %91 = load ptr, ptr %s, align 8
  %param59 = getelementptr inbounds %struct.ssl_connection_st, ptr %91, i32 0, i32 25
  %92 = load ptr, ptr %param59, align 8
  %cmp60 = icmp eq ptr %92, null
  br i1 %cmp60, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end55
  br label %asn1err

if.end63:                                         ; preds = %if.end55
  %93 = load ptr, ptr %s, align 8
  %param64 = getelementptr inbounds %struct.ssl_connection_st, ptr %93, i32 0, i32 25
  %94 = load ptr, ptr %param64, align 8
  %95 = load ptr, ptr %ctx.addr, align 8
  %param65 = getelementptr inbounds %struct.ssl_ctx_st, ptr %95, i32 0, i32 49
  %96 = load ptr, ptr %param65, align 8
  %call66 = call i32 @X509_VERIFY_PARAM_inherit(ptr noundef %94, ptr noundef %96)
  %97 = load ptr, ptr %ctx.addr, align 8
  %method67 = getelementptr inbounds %struct.ssl_ctx_st, ptr %97, i32 0, i32 1
  %98 = load ptr, ptr %method67, align 8
  %call68 = call ptr @OSSL_QUIC_client_method()
  %cmp69 = icmp eq ptr %98, %call68
  br i1 %cmp69, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end63
  %99 = load ptr, ptr %ctx.addr, align 8
  %method71 = getelementptr inbounds %struct.ssl_ctx_st, ptr %99, i32 0, i32 1
  %100 = load ptr, ptr %method71, align 8
  %call72 = call ptr @OSSL_QUIC_client_thread_method()
  %cmp73 = icmp eq ptr %100, %call72
  br i1 %cmp73, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %if.end63
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %101 = load ptr, ptr %ctx.addr, align 8
  %quiet_shutdown = getelementptr inbounds %struct.ssl_ctx_st, ptr %101, i32 0, i32 50
  %102 = load i32, ptr %quiet_shutdown, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %102, %cond.false ]
  %103 = load ptr, ptr %s, align 8
  %quiet_shutdown75 = getelementptr inbounds %struct.ssl_connection_st, ptr %103, i32 0, i32 9
  store i32 %cond, ptr %quiet_shutdown75, align 8
  %104 = load ptr, ptr %ctx.addr, align 8
  %method76 = getelementptr inbounds %struct.ssl_ctx_st, ptr %104, i32 0, i32 1
  %105 = load ptr, ptr %method76, align 8
  %call77 = call ptr @OSSL_QUIC_client_method()
  %cmp78 = icmp eq ptr %105, %call77
  br i1 %cmp78, label %if.end88, label %lor.lhs.false80

lor.lhs.false80:                                  ; preds = %cond.end
  %106 = load ptr, ptr %ctx.addr, align 8
  %method81 = getelementptr inbounds %struct.ssl_ctx_st, ptr %106, i32 0, i32 1
  %107 = load ptr, ptr %method81, align 8
  %call82 = call ptr @OSSL_QUIC_client_thread_method()
  %cmp83 = icmp eq ptr %107, %call82
  br i1 %cmp83, label %if.end88, label %if.then85

if.then85:                                        ; preds = %lor.lhs.false80
  %108 = load ptr, ptr %ctx.addr, align 8
  %ext = getelementptr inbounds %struct.ssl_ctx_st, ptr %108, i32 0, i32 61
  %max_fragment_len_mode = getelementptr inbounds %struct.anon.4, ptr %ext, i32 0, i32 9
  %109 = load i8, ptr %max_fragment_len_mode, align 4
  %110 = load ptr, ptr %s, align 8
  %ext86 = getelementptr inbounds %struct.ssl_connection_st, ptr %110, i32 0, i32 80
  %max_fragment_len_mode87 = getelementptr inbounds %struct.anon.1, ptr %ext86, i32 0, i32 35
  store i8 %109, ptr %max_fragment_len_mode87, align 4
  br label %if.end88

if.end88:                                         ; preds = %if.then85, %lor.lhs.false80, %cond.end
  %111 = load ptr, ptr %ctx.addr, align 8
  %max_send_fragment = getelementptr inbounds %struct.ssl_ctx_st, ptr %111, i32 0, i32 55
  %112 = load i64, ptr %max_send_fragment, align 8
  %113 = load ptr, ptr %s, align 8
  %max_send_fragment89 = getelementptr inbounds %struct.ssl_connection_st, ptr %113, i32 0, i32 78
  store i64 %112, ptr %max_send_fragment89, align 8
  %114 = load ptr, ptr %ctx.addr, align 8
  %split_send_fragment = getelementptr inbounds %struct.ssl_ctx_st, ptr %114, i32 0, i32 54
  %115 = load i64, ptr %split_send_fragment, align 8
  %116 = load ptr, ptr %s, align 8
  %split_send_fragment90 = getelementptr inbounds %struct.ssl_connection_st, ptr %116, i32 0, i32 77
  store i64 %115, ptr %split_send_fragment90, align 8
  %117 = load ptr, ptr %ctx.addr, align 8
  %max_pipelines = getelementptr inbounds %struct.ssl_ctx_st, ptr %117, i32 0, i32 56
  %118 = load i64, ptr %max_pipelines, align 8
  %119 = load ptr, ptr %s, align 8
  %max_pipelines91 = getelementptr inbounds %struct.ssl_connection_st, ptr %119, i32 0, i32 79
  store i64 %118, ptr %max_pipelines91, align 8
  %120 = load ptr, ptr %ctx.addr, align 8
  %default_read_buf_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %120, i32 0, i32 57
  %121 = load i64, ptr %default_read_buf_len, align 8
  %122 = load ptr, ptr %s, align 8
  %rlayer92 = getelementptr inbounds %struct.ssl_connection_st, ptr %122, i32 0, i32 100
  %default_read_buf_len93 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer92, i32 0, i32 8
  store i64 %121, ptr %default_read_buf_len93, align 8
  %123 = load ptr, ptr %s, align 8
  %ext94 = getelementptr inbounds %struct.ssl_connection_st, ptr %123, i32 0, i32 80
  %debug_cb = getelementptr inbounds %struct.anon.1, ptr %ext94, i32 0, i32 1
  store ptr null, ptr %debug_cb, align 8
  %124 = load ptr, ptr %s, align 8
  %ext95 = getelementptr inbounds %struct.ssl_connection_st, ptr %124, i32 0, i32 80
  %debug_arg = getelementptr inbounds %struct.anon.1, ptr %ext95, i32 0, i32 2
  store ptr null, ptr %debug_arg, align 8
  %125 = load ptr, ptr %s, align 8
  %ext96 = getelementptr inbounds %struct.ssl_connection_st, ptr %125, i32 0, i32 80
  %ticket_expected = getelementptr inbounds %struct.anon.1, ptr %ext96, i32 0, i32 9
  store i32 0, ptr %ticket_expected, align 8
  %126 = load ptr, ptr %ctx.addr, align 8
  %ext97 = getelementptr inbounds %struct.ssl_ctx_st, ptr %126, i32 0, i32 61
  %status_type = getelementptr inbounds %struct.anon.4, ptr %ext97, i32 0, i32 8
  %127 = load i32, ptr %status_type, align 8
  %128 = load ptr, ptr %s, align 8
  %ext98 = getelementptr inbounds %struct.ssl_connection_st, ptr %128, i32 0, i32 80
  %status_type99 = getelementptr inbounds %struct.anon.1, ptr %ext98, i32 0, i32 4
  store i32 %127, ptr %status_type99, align 8
  %129 = load ptr, ptr %s, align 8
  %ext100 = getelementptr inbounds %struct.ssl_connection_st, ptr %129, i32 0, i32 80
  %status_expected = getelementptr inbounds %struct.anon.1, ptr %ext100, i32 0, i32 7
  store i32 0, ptr %status_expected, align 4
  %130 = load ptr, ptr %s, align 8
  %ext101 = getelementptr inbounds %struct.ssl_connection_st, ptr %130, i32 0, i32 80
  %ocsp = getelementptr inbounds %struct.anon.1, ptr %ext101, i32 0, i32 8
  %ids = getelementptr inbounds %struct.anon.2, ptr %ocsp, i32 0, i32 0
  store ptr null, ptr %ids, align 8
  %131 = load ptr, ptr %s, align 8
  %ext102 = getelementptr inbounds %struct.ssl_connection_st, ptr %131, i32 0, i32 80
  %ocsp103 = getelementptr inbounds %struct.anon.1, ptr %ext102, i32 0, i32 8
  %exts = getelementptr inbounds %struct.anon.2, ptr %ocsp103, i32 0, i32 1
  store ptr null, ptr %exts, align 8
  %132 = load ptr, ptr %s, align 8
  %ext104 = getelementptr inbounds %struct.ssl_connection_st, ptr %132, i32 0, i32 80
  %ocsp105 = getelementptr inbounds %struct.anon.1, ptr %ext104, i32 0, i32 8
  %resp = getelementptr inbounds %struct.anon.2, ptr %ocsp105, i32 0, i32 2
  store ptr null, ptr %resp, align 8
  %133 = load ptr, ptr %s, align 8
  %ext106 = getelementptr inbounds %struct.ssl_connection_st, ptr %133, i32 0, i32 80
  %ocsp107 = getelementptr inbounds %struct.anon.1, ptr %ext106, i32 0, i32 8
  %resp_len = getelementptr inbounds %struct.anon.2, ptr %ocsp107, i32 0, i32 3
  store i64 0, ptr %resp_len, align 8
  %134 = load ptr, ptr %ctx.addr, align 8
  %call108 = call i32 @SSL_CTX_up_ref(ptr noundef %134)
  %135 = load ptr, ptr %ctx.addr, align 8
  %136 = load ptr, ptr %s, align 8
  %session_ctx = getelementptr inbounds %struct.ssl_connection_st, ptr %136, i32 0, i32 87
  store ptr %135, ptr %session_ctx, align 8
  %137 = load ptr, ptr %ctx.addr, align 8
  %ext109 = getelementptr inbounds %struct.ssl_ctx_st, ptr %137, i32 0, i32 61
  %ecpointformats = getelementptr inbounds %struct.anon.4, ptr %ext109, i32 0, i32 11
  %138 = load ptr, ptr %ecpointformats, align 8
  %tobool110 = icmp ne ptr %138, null
  br i1 %tobool110, label %if.then111, label %if.end129

if.then111:                                       ; preds = %if.end88
  %139 = load ptr, ptr %ctx.addr, align 8
  %ext112 = getelementptr inbounds %struct.ssl_ctx_st, ptr %139, i32 0, i32 61
  %ecpointformats113 = getelementptr inbounds %struct.anon.4, ptr %ext112, i32 0, i32 11
  %140 = load ptr, ptr %ecpointformats113, align 8
  %141 = load ptr, ptr %ctx.addr, align 8
  %ext114 = getelementptr inbounds %struct.ssl_ctx_st, ptr %141, i32 0, i32 61
  %ecpointformats_len = getelementptr inbounds %struct.anon.4, ptr %ext114, i32 0, i32 10
  %142 = load i64, ptr %ecpointformats_len, align 8
  %call115 = call noalias ptr @CRYPTO_memdup(ptr noundef %140, i64 noundef %142, ptr noundef @.str, i32 noundef 849)
  %143 = load ptr, ptr %s, align 8
  %ext116 = getelementptr inbounds %struct.ssl_connection_st, ptr %143, i32 0, i32 80
  %ecpointformats117 = getelementptr inbounds %struct.anon.1, ptr %ext116, i32 0, i32 12
  store ptr %call115, ptr %ecpointformats117, align 8
  %144 = load ptr, ptr %s, align 8
  %ext118 = getelementptr inbounds %struct.ssl_connection_st, ptr %144, i32 0, i32 80
  %ecpointformats119 = getelementptr inbounds %struct.anon.1, ptr %ext118, i32 0, i32 12
  %145 = load ptr, ptr %ecpointformats119, align 8
  %tobool120 = icmp ne ptr %145, null
  br i1 %tobool120, label %if.end124, label %if.then121

if.then121:                                       ; preds = %if.then111
  %146 = load ptr, ptr %s, align 8
  %ext122 = getelementptr inbounds %struct.ssl_connection_st, ptr %146, i32 0, i32 80
  %ecpointformats_len123 = getelementptr inbounds %struct.anon.1, ptr %ext122, i32 0, i32 11
  store i64 0, ptr %ecpointformats_len123, align 8
  br label %err

if.end124:                                        ; preds = %if.then111
  %147 = load ptr, ptr %ctx.addr, align 8
  %ext125 = getelementptr inbounds %struct.ssl_ctx_st, ptr %147, i32 0, i32 61
  %ecpointformats_len126 = getelementptr inbounds %struct.anon.4, ptr %ext125, i32 0, i32 10
  %148 = load i64, ptr %ecpointformats_len126, align 8
  %149 = load ptr, ptr %s, align 8
  %ext127 = getelementptr inbounds %struct.ssl_connection_st, ptr %149, i32 0, i32 80
  %ecpointformats_len128 = getelementptr inbounds %struct.anon.1, ptr %ext127, i32 0, i32 11
  store i64 %148, ptr %ecpointformats_len128, align 8
  br label %if.end129

if.end129:                                        ; preds = %if.end124, %if.end88
  %150 = load ptr, ptr %ctx.addr, align 8
  %ext130 = getelementptr inbounds %struct.ssl_ctx_st, ptr %150, i32 0, i32 61
  %supportedgroups = getelementptr inbounds %struct.anon.4, ptr %ext130, i32 0, i32 13
  %151 = load ptr, ptr %supportedgroups, align 8
  %tobool131 = icmp ne ptr %151, null
  br i1 %tobool131, label %if.then132, label %if.end150

if.then132:                                       ; preds = %if.end129
  %152 = load ptr, ptr %ctx.addr, align 8
  %ext133 = getelementptr inbounds %struct.ssl_ctx_st, ptr %152, i32 0, i32 61
  %supportedgroups134 = getelementptr inbounds %struct.anon.4, ptr %ext133, i32 0, i32 13
  %153 = load ptr, ptr %supportedgroups134, align 8
  %154 = load ptr, ptr %ctx.addr, align 8
  %ext135 = getelementptr inbounds %struct.ssl_ctx_st, ptr %154, i32 0, i32 61
  %supportedgroups_len = getelementptr inbounds %struct.anon.4, ptr %ext135, i32 0, i32 12
  %155 = load i64, ptr %supportedgroups_len, align 8
  %mul = mul i64 %155, 2
  %call136 = call noalias ptr @CRYPTO_memdup(ptr noundef %153, i64 noundef %mul, ptr noundef @.str, i32 noundef 861)
  %156 = load ptr, ptr %s, align 8
  %ext137 = getelementptr inbounds %struct.ssl_connection_st, ptr %156, i32 0, i32 80
  %supportedgroups138 = getelementptr inbounds %struct.anon.1, ptr %ext137, i32 0, i32 16
  store ptr %call136, ptr %supportedgroups138, align 8
  %157 = load ptr, ptr %s, align 8
  %ext139 = getelementptr inbounds %struct.ssl_connection_st, ptr %157, i32 0, i32 80
  %supportedgroups140 = getelementptr inbounds %struct.anon.1, ptr %ext139, i32 0, i32 16
  %158 = load ptr, ptr %supportedgroups140, align 8
  %tobool141 = icmp ne ptr %158, null
  br i1 %tobool141, label %if.end145, label %if.then142

if.then142:                                       ; preds = %if.then132
  %159 = load ptr, ptr %s, align 8
  %ext143 = getelementptr inbounds %struct.ssl_connection_st, ptr %159, i32 0, i32 80
  %supportedgroups_len144 = getelementptr inbounds %struct.anon.1, ptr %ext143, i32 0, i32 15
  store i64 0, ptr %supportedgroups_len144, align 8
  br label %err

if.end145:                                        ; preds = %if.then132
  %160 = load ptr, ptr %ctx.addr, align 8
  %ext146 = getelementptr inbounds %struct.ssl_ctx_st, ptr %160, i32 0, i32 61
  %supportedgroups_len147 = getelementptr inbounds %struct.anon.4, ptr %ext146, i32 0, i32 12
  %161 = load i64, ptr %supportedgroups_len147, align 8
  %162 = load ptr, ptr %s, align 8
  %ext148 = getelementptr inbounds %struct.ssl_connection_st, ptr %162, i32 0, i32 80
  %supportedgroups_len149 = getelementptr inbounds %struct.anon.1, ptr %ext148, i32 0, i32 15
  store i64 %161, ptr %supportedgroups_len149, align 8
  br label %if.end150

if.end150:                                        ; preds = %if.end145, %if.end129
  %163 = load ptr, ptr %s, align 8
  %ext151 = getelementptr inbounds %struct.ssl_connection_st, ptr %163, i32 0, i32 80
  %npn = getelementptr inbounds %struct.anon.1, ptr %ext151, i32 0, i32 26
  store ptr null, ptr %npn, align 8
  %164 = load ptr, ptr %ctx.addr, align 8
  %ext152 = getelementptr inbounds %struct.ssl_ctx_st, ptr %164, i32 0, i32 61
  %alpn = getelementptr inbounds %struct.anon.4, ptr %ext152, i32 0, i32 18
  %165 = load ptr, ptr %alpn, align 8
  %cmp153 = icmp ne ptr %165, null
  br i1 %cmp153, label %if.then155, label %if.end178

if.then155:                                       ; preds = %if.end150
  %166 = load ptr, ptr %ctx.addr, align 8
  %ext156 = getelementptr inbounds %struct.ssl_ctx_st, ptr %166, i32 0, i32 61
  %alpn_len = getelementptr inbounds %struct.anon.4, ptr %ext156, i32 0, i32 19
  %167 = load i64, ptr %alpn_len, align 8
  %call157 = call noalias ptr @CRYPTO_malloc(i64 noundef %167, ptr noundef @.str, i32 noundef 874)
  %168 = load ptr, ptr %s, align 8
  %ext158 = getelementptr inbounds %struct.ssl_connection_st, ptr %168, i32 0, i32 80
  %alpn159 = getelementptr inbounds %struct.anon.1, ptr %ext158, i32 0, i32 24
  store ptr %call157, ptr %alpn159, align 8
  %169 = load ptr, ptr %s, align 8
  %ext160 = getelementptr inbounds %struct.ssl_connection_st, ptr %169, i32 0, i32 80
  %alpn161 = getelementptr inbounds %struct.anon.1, ptr %ext160, i32 0, i32 24
  %170 = load ptr, ptr %alpn161, align 8
  %cmp162 = icmp eq ptr %170, null
  br i1 %cmp162, label %if.then164, label %if.end167

if.then164:                                       ; preds = %if.then155
  %171 = load ptr, ptr %s, align 8
  %ext165 = getelementptr inbounds %struct.ssl_connection_st, ptr %171, i32 0, i32 80
  %alpn_len166 = getelementptr inbounds %struct.anon.1, ptr %ext165, i32 0, i32 25
  store i64 0, ptr %alpn_len166, align 8
  br label %err

if.end167:                                        ; preds = %if.then155
  %172 = load ptr, ptr %s, align 8
  %ext168 = getelementptr inbounds %struct.ssl_connection_st, ptr %172, i32 0, i32 80
  %alpn169 = getelementptr inbounds %struct.anon.1, ptr %ext168, i32 0, i32 24
  %173 = load ptr, ptr %alpn169, align 8
  %174 = load ptr, ptr %ctx.addr, align 8
  %ext170 = getelementptr inbounds %struct.ssl_ctx_st, ptr %174, i32 0, i32 61
  %alpn171 = getelementptr inbounds %struct.anon.4, ptr %ext170, i32 0, i32 18
  %175 = load ptr, ptr %alpn171, align 8
  %176 = load ptr, ptr %ctx.addr, align 8
  %ext172 = getelementptr inbounds %struct.ssl_ctx_st, ptr %176, i32 0, i32 61
  %alpn_len173 = getelementptr inbounds %struct.anon.4, ptr %ext172, i32 0, i32 19
  %177 = load i64, ptr %alpn_len173, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %173, ptr align 1 %175, i64 %177, i1 false)
  %178 = load ptr, ptr %ctx.addr, align 8
  %ext174 = getelementptr inbounds %struct.ssl_ctx_st, ptr %178, i32 0, i32 61
  %alpn_len175 = getelementptr inbounds %struct.anon.4, ptr %ext174, i32 0, i32 19
  %179 = load i64, ptr %alpn_len175, align 8
  %180 = load ptr, ptr %s, align 8
  %ext176 = getelementptr inbounds %struct.ssl_connection_st, ptr %180, i32 0, i32 80
  %alpn_len177 = getelementptr inbounds %struct.anon.1, ptr %ext176, i32 0, i32 25
  store i64 %179, ptr %alpn_len177, align 8
  br label %if.end178

if.end178:                                        ; preds = %if.end167, %if.end150
  %181 = load ptr, ptr %s, align 8
  %verified_chain = getelementptr inbounds %struct.ssl_connection_st, ptr %181, i32 0, i32 66
  store ptr null, ptr %verified_chain, align 8
  %182 = load ptr, ptr %s, align 8
  %verify_result = getelementptr inbounds %struct.ssl_connection_st, ptr %182, i32 0, i32 67
  store i64 0, ptr %verify_result, align 8
  %183 = load ptr, ptr %ctx.addr, align 8
  %default_passwd_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %183, i32 0, i32 19
  %184 = load ptr, ptr %default_passwd_callback, align 8
  %185 = load ptr, ptr %s, align 8
  %default_passwd_callback179 = getelementptr inbounds %struct.ssl_connection_st, ptr %185, i32 0, i32 101
  store ptr %184, ptr %default_passwd_callback179, align 8
  %186 = load ptr, ptr %ctx.addr, align 8
  %default_passwd_callback_userdata = getelementptr inbounds %struct.ssl_ctx_st, ptr %186, i32 0, i32 20
  %187 = load ptr, ptr %default_passwd_callback_userdata, align 8
  %188 = load ptr, ptr %s, align 8
  %default_passwd_callback_userdata180 = getelementptr inbounds %struct.ssl_connection_st, ptr %188, i32 0, i32 102
  store ptr %187, ptr %default_passwd_callback_userdata180, align 8
  %189 = load ptr, ptr %s, align 8
  %key_update = getelementptr inbounds %struct.ssl_connection_st, ptr %189, i32 0, i32 91
  store i32 -1, ptr %key_update, align 4
  %190 = load ptr, ptr %ctx.addr, align 8
  %method181 = getelementptr inbounds %struct.ssl_ctx_st, ptr %190, i32 0, i32 1
  %191 = load ptr, ptr %method181, align 8
  %call182 = call ptr @OSSL_QUIC_client_method()
  %cmp183 = icmp eq ptr %191, %call182
  br i1 %cmp183, label %if.end193, label %lor.lhs.false185

lor.lhs.false185:                                 ; preds = %if.end178
  %192 = load ptr, ptr %ctx.addr, align 8
  %method186 = getelementptr inbounds %struct.ssl_ctx_st, ptr %192, i32 0, i32 1
  %193 = load ptr, ptr %method186, align 8
  %call187 = call ptr @OSSL_QUIC_client_thread_method()
  %cmp188 = icmp eq ptr %193, %call187
  br i1 %cmp188, label %if.end193, label %if.then190

if.then190:                                       ; preds = %lor.lhs.false185
  %194 = load ptr, ptr %ctx.addr, align 8
  %allow_early_data_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %194, i32 0, i32 81
  %195 = load ptr, ptr %allow_early_data_cb, align 8
  %196 = load ptr, ptr %s, align 8
  %allow_early_data_cb191 = getelementptr inbounds %struct.ssl_connection_st, ptr %196, i32 0, i32 112
  store ptr %195, ptr %allow_early_data_cb191, align 8
  %197 = load ptr, ptr %ctx.addr, align 8
  %allow_early_data_cb_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %197, i32 0, i32 82
  %198 = load ptr, ptr %allow_early_data_cb_data, align 8
  %199 = load ptr, ptr %s, align 8
  %allow_early_data_cb_data192 = getelementptr inbounds %struct.ssl_connection_st, ptr %199, i32 0, i32 113
  store ptr %198, ptr %allow_early_data_cb_data192, align 8
  br label %if.end193

if.end193:                                        ; preds = %if.then190, %lor.lhs.false185, %if.end178
  %200 = load ptr, ptr %method.addr, align 8
  %ssl_init = getelementptr inbounds %struct.ssl_method_st, ptr %200, i32 0, i32 6
  %201 = load ptr, ptr %ssl_init, align 8
  %202 = load ptr, ptr %ssl, align 8
  %call194 = call i32 %201(ptr noundef %202)
  %tobool195 = icmp ne i32 %call194, 0
  br i1 %tobool195, label %if.end197, label %if.then196

if.then196:                                       ; preds = %if.end193
  br label %sslerr

if.end197:                                        ; preds = %if.end193
  %203 = load ptr, ptr %method.addr, align 8
  %ssl_accept = getelementptr inbounds %struct.ssl_method_st, ptr %203, i32 0, i32 9
  %204 = load ptr, ptr %ssl_accept, align 8
  %cmp198 = icmp eq ptr %204, @ssl_undefined_function
  %cond200 = select i1 %cmp198, i32 0, i32 1
  %205 = load ptr, ptr %s, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %205, i32 0, i32 7
  store i32 %cond200, ptr %server, align 8
  %206 = load ptr, ptr %method.addr, align 8
  %ssl_reset = getelementptr inbounds %struct.ssl_method_st, ptr %206, i32 0, i32 5
  %207 = load ptr, ptr %ssl_reset, align 8
  %208 = load ptr, ptr %ssl, align 8
  %call201 = call i32 %207(ptr noundef %208)
  %tobool202 = icmp ne i32 %call201, 0
  br i1 %tobool202, label %if.end204, label %if.then203

if.then203:                                       ; preds = %if.end197
  br label %sslerr

if.end204:                                        ; preds = %if.end197
  %209 = load ptr, ptr %ctx.addr, align 8
  %psk_client_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %209, i32 0, i32 62
  %210 = load ptr, ptr %psk_client_callback, align 8
  %211 = load ptr, ptr %s, align 8
  %psk_client_callback205 = getelementptr inbounds %struct.ssl_connection_st, ptr %211, i32 0, i32 62
  store ptr %210, ptr %psk_client_callback205, align 8
  %212 = load ptr, ptr %ctx.addr, align 8
  %psk_server_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %212, i32 0, i32 63
  %213 = load ptr, ptr %psk_server_callback, align 8
  %214 = load ptr, ptr %s, align 8
  %psk_server_callback206 = getelementptr inbounds %struct.ssl_connection_st, ptr %214, i32 0, i32 63
  store ptr %213, ptr %psk_server_callback206, align 8
  %215 = load ptr, ptr %ctx.addr, align 8
  %psk_find_session_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %215, i32 0, i32 64
  %216 = load ptr, ptr %psk_find_session_cb, align 8
  %217 = load ptr, ptr %s, align 8
  %psk_find_session_cb207 = getelementptr inbounds %struct.ssl_connection_st, ptr %217, i32 0, i32 64
  store ptr %216, ptr %psk_find_session_cb207, align 8
  %218 = load ptr, ptr %ctx.addr, align 8
  %psk_use_session_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %218, i32 0, i32 65
  %219 = load ptr, ptr %psk_use_session_cb, align 8
  %220 = load ptr, ptr %s, align 8
  %psk_use_session_cb208 = getelementptr inbounds %struct.ssl_connection_st, ptr %220, i32 0, i32 65
  store ptr %219, ptr %psk_use_session_cb208, align 8
  %221 = load ptr, ptr %ctx.addr, align 8
  %async_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %221, i32 0, i32 84
  %222 = load ptr, ptr %async_cb, align 8
  %223 = load ptr, ptr %s, align 8
  %async_cb209 = getelementptr inbounds %struct.ssl_connection_st, ptr %223, i32 0, i32 114
  store ptr %222, ptr %async_cb209, align 8
  %224 = load ptr, ptr %ctx.addr, align 8
  %async_cb_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %224, i32 0, i32 85
  %225 = load ptr, ptr %async_cb_arg, align 8
  %226 = load ptr, ptr %s, align 8
  %async_cb_arg210 = getelementptr inbounds %struct.ssl_connection_st, ptr %226, i32 0, i32 115
  store ptr %225, ptr %async_cb_arg210, align 8
  %227 = load ptr, ptr %s, align 8
  %job = getelementptr inbounds %struct.ssl_connection_st, ptr %227, i32 0, i32 103
  store ptr null, ptr %job, align 8
  %228 = load ptr, ptr %ctx.addr, align 8
  %client_cert_type = getelementptr inbounds %struct.ssl_ctx_st, ptr %228, i32 0, i32 104
  %229 = load ptr, ptr %client_cert_type, align 8
  %cmp211 = icmp ne ptr %229, null
  br i1 %cmp211, label %if.then213, label %if.end224

if.then213:                                       ; preds = %if.end204
  %230 = load ptr, ptr %ctx.addr, align 8
  %client_cert_type214 = getelementptr inbounds %struct.ssl_ctx_st, ptr %230, i32 0, i32 104
  %231 = load ptr, ptr %client_cert_type214, align 8
  %232 = load ptr, ptr %ctx.addr, align 8
  %client_cert_type_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %232, i32 0, i32 105
  %233 = load i64, ptr %client_cert_type_len, align 8
  %call215 = call noalias ptr @CRYPTO_memdup(ptr noundef %231, i64 noundef %233, ptr noundef @.str, i32 noundef 921)
  %234 = load ptr, ptr %s, align 8
  %client_cert_type216 = getelementptr inbounds %struct.ssl_connection_st, ptr %234, i32 0, i32 118
  store ptr %call215, ptr %client_cert_type216, align 8
  %235 = load ptr, ptr %s, align 8
  %client_cert_type217 = getelementptr inbounds %struct.ssl_connection_st, ptr %235, i32 0, i32 118
  %236 = load ptr, ptr %client_cert_type217, align 8
  %cmp218 = icmp eq ptr %236, null
  br i1 %cmp218, label %if.then220, label %if.end221

if.then220:                                       ; preds = %if.then213
  br label %sslerr

if.end221:                                        ; preds = %if.then213
  %237 = load ptr, ptr %ctx.addr, align 8
  %client_cert_type_len222 = getelementptr inbounds %struct.ssl_ctx_st, ptr %237, i32 0, i32 105
  %238 = load i64, ptr %client_cert_type_len222, align 8
  %239 = load ptr, ptr %s, align 8
  %client_cert_type_len223 = getelementptr inbounds %struct.ssl_connection_st, ptr %239, i32 0, i32 119
  store i64 %238, ptr %client_cert_type_len223, align 8
  br label %if.end224

if.end224:                                        ; preds = %if.end221, %if.end204
  %240 = load ptr, ptr %ctx.addr, align 8
  %server_cert_type = getelementptr inbounds %struct.ssl_ctx_st, ptr %240, i32 0, i32 106
  %241 = load ptr, ptr %server_cert_type, align 8
  %cmp225 = icmp ne ptr %241, null
  br i1 %cmp225, label %if.then227, label %if.end238

if.then227:                                       ; preds = %if.end224
  %242 = load ptr, ptr %ctx.addr, align 8
  %server_cert_type228 = getelementptr inbounds %struct.ssl_ctx_st, ptr %242, i32 0, i32 106
  %243 = load ptr, ptr %server_cert_type228, align 8
  %244 = load ptr, ptr %ctx.addr, align 8
  %server_cert_type_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %244, i32 0, i32 107
  %245 = load i64, ptr %server_cert_type_len, align 8
  %call229 = call noalias ptr @CRYPTO_memdup(ptr noundef %243, i64 noundef %245, ptr noundef @.str, i32 noundef 928)
  %246 = load ptr, ptr %s, align 8
  %server_cert_type230 = getelementptr inbounds %struct.ssl_connection_st, ptr %246, i32 0, i32 120
  store ptr %call229, ptr %server_cert_type230, align 8
  %247 = load ptr, ptr %s, align 8
  %server_cert_type231 = getelementptr inbounds %struct.ssl_connection_st, ptr %247, i32 0, i32 120
  %248 = load ptr, ptr %server_cert_type231, align 8
  %cmp232 = icmp eq ptr %248, null
  br i1 %cmp232, label %if.then234, label %if.end235

if.then234:                                       ; preds = %if.then227
  br label %sslerr

if.end235:                                        ; preds = %if.then227
  %249 = load ptr, ptr %ctx.addr, align 8
  %server_cert_type_len236 = getelementptr inbounds %struct.ssl_ctx_st, ptr %249, i32 0, i32 107
  %250 = load i64, ptr %server_cert_type_len236, align 8
  %251 = load ptr, ptr %s, align 8
  %server_cert_type_len237 = getelementptr inbounds %struct.ssl_connection_st, ptr %251, i32 0, i32 121
  store i64 %250, ptr %server_cert_type_len237, align 8
  br label %if.end238

if.end238:                                        ; preds = %if.end235, %if.end224
  %252 = load ptr, ptr %ssl, align 8
  %253 = load ptr, ptr %ctx.addr, align 8
  %ct_validation_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %253, i32 0, i32 52
  %254 = load ptr, ptr %ct_validation_callback, align 8
  %255 = load ptr, ptr %ctx.addr, align 8
  %ct_validation_callback_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %255, i32 0, i32 53
  %256 = load ptr, ptr %ct_validation_callback_arg, align 8
  %call239 = call i32 @SSL_set_ct_validation_callback(ptr noundef %252, ptr noundef %254, ptr noundef %256)
  %tobool240 = icmp ne i32 %call239, 0
  br i1 %tobool240, label %if.end242, label %if.then241

if.then241:                                       ; preds = %if.end238
  br label %sslerr

if.end242:                                        ; preds = %if.end238
  %257 = load ptr, ptr %ctx.addr, align 8
  %sigalg_list_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %257, i32 0, i32 98
  %258 = load i64, ptr %sigalg_list_len, align 8
  %add = add i64 9, %258
  %259 = load ptr, ptr %s, align 8
  %ssl_pkey_num = getelementptr inbounds %struct.ssl_connection_st, ptr %259, i32 0, i32 19
  store i64 %add, ptr %ssl_pkey_num, align 8
  %260 = load ptr, ptr %ssl, align 8
  store ptr %260, ptr %retval, align 8
  br label %return

cerr:                                             ; preds = %if.then26
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 943, ptr noundef @__func__.ossl_ssl_connection_new_int)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  br label %err

asn1err:                                          ; preds = %if.then62
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 946, ptr noundef @__func__.ossl_ssl_connection_new_int)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524301, ptr noundef null)
  br label %err

sslerr:                                           ; preds = %if.then241, %if.then234, %if.then220, %if.then203, %if.then196, %if.then32, %if.then3
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 949, ptr noundef @__func__.ossl_ssl_connection_new_int)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524308, ptr noundef null)
  br label %err

err:                                              ; preds = %sslerr, %asn1err, %cerr, %if.then164, %if.then142, %if.then121, %if.then54
  %261 = load ptr, ptr %ssl, align 8
  call void @SSL_free(ptr noundef %261)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %err, %if.end242, %if.then
  %262 = load ptr, ptr %retval, align 8
  ret ptr %262
}

declare noalias ptr @CRYPTO_zalloc(i64 noundef, ptr noundef, i32 noundef) #1

declare void @RECORD_LAYER_init(ptr noundef, ptr noundef) #1

declare ptr @OPENSSL_sk_dup(ptr noundef) #1

declare ptr @ssl_cert_dup(ptr noundef) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #3

declare ptr @X509_VERIFY_PARAM_new() #1

declare i32 @X509_VERIFY_PARAM_inherit(ptr noundef, ptr noundef) #1

declare noalias ptr @CRYPTO_memdup(ptr noundef, i64 noundef, ptr noundef, i32 noundef) #1

declare noalias ptr @CRYPTO_malloc(i64 noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @ssl_undefined_function(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 4792, ptr noundef @__func__.ssl_undefined_function)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786689, ptr noundef null)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_ct_validation_callback(ptr noundef %s, ptr noundef %callback, ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %callback.addr, align 8
  %cmp13 = icmp ne ptr %9, null
  br i1 %cmp13, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.end
  %10 = load ptr, ptr %s.addr, align 8
  %ctx = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %ctx, align 8
  %call = call i32 @SSL_CTX_has_client_custom_ext(ptr noundef %11, i32 noundef 18)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6262, ptr noundef @__func__.SSL_set_ct_validation_callback)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 206, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %land.lhs.true, %if.end
  %12 = load ptr, ptr %callback.addr, align 8
  %cmp16 = icmp ne ptr %12, null
  br i1 %cmp16, label %if.then17, label %if.end22

if.then17:                                        ; preds = %if.end15
  %13 = load ptr, ptr %s.addr, align 8
  %call18 = call i64 @SSL_ctrl(ptr noundef %13, i32 noundef 65, i64 noundef 1, ptr noundef null)
  %tobool19 = icmp ne i64 %call18, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.then17
  store i32 0, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.then17
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end15
  %14 = load ptr, ptr %callback.addr, align 8
  %15 = load ptr, ptr %sc, align 8
  %ct_validation_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 83
  store ptr %14, ptr %ct_validation_callback, align 8
  %16 = load ptr, ptr %arg.addr, align 8
  %17 = load ptr, ptr %sc, align 8
  %ct_validation_callback_arg = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 84
  store ptr %16, ptr %ct_validation_callback_arg, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end22, %if.then20, %if.then14, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define void @SSL_free(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %references = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 4
  %call = call i32 @CRYPTO_DOWN_REF(ptr noundef %references, ptr noundef %i)
  %2 = load i32, ptr %i, align 4
  %cmp1 = icmp sgt i32 %2, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %ex_data = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 6
  call void @CRYPTO_free_ex_data(i32 noundef 0, ptr noundef %3, ptr noundef %ex_data)
  %5 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %5, i32 0, i32 3
  %6 = load ptr, ptr %method, align 8
  %cmp4 = icmp ne ptr %6, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  %7 = load ptr, ptr %s.addr, align 8
  %method6 = getelementptr inbounds %struct.ssl_st, ptr %7, i32 0, i32 3
  %8 = load ptr, ptr %method6, align 8
  %ssl_free = getelementptr inbounds %struct.ssl_method_st, ptr %8, i32 0, i32 4
  %9 = load ptr, ptr %ssl_free, align 8
  %10 = load ptr, ptr %s.addr, align 8
  call void %9(ptr noundef %10)
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  %11 = load ptr, ptr %s.addr, align 8
  %ctx = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %ctx, align 8
  call void @SSL_CTX_free(ptr noundef %12)
  %13 = load ptr, ptr %s.addr, align 8
  %lock = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %lock, align 8
  call void @CRYPTO_THREAD_lock_free(ptr noundef %14)
  %15 = load ptr, ptr %s.addr, align 8
  %references8 = getelementptr inbounds %struct.ssl_st, ptr %15, i32 0, i32 4
  call void @CRYPTO_FREE_REF(ptr noundef %references8)
  %16 = load ptr, ptr %s.addr, align 8
  call void @CRYPTO_free(ptr noundef %16, ptr noundef @.str, i32 noundef 1423)
  br label %return

return:                                           ; preds = %if.end7, %if.then2, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @ossl_ssl_connection_new(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %method = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %method, align 8
  %call = call ptr @ossl_ssl_connection_new_int(ptr noundef %0, ptr noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define i32 @SSL_is_dtls(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %type12 = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type12, align 8
  %cmp13 = icmp eq i32 %9, 1
  br i1 %cmp13, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %10 = load ptr, ptr %s.addr, align 8
  %type14 = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %type14, align 8
  %cmp15 = icmp eq i32 %11, 2
  br i1 %cmp15, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %12 = load ptr, ptr %sc, align 8
  %cmp16 = icmp eq ptr %12, null
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end
  %13 = load ptr, ptr %sc, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %14 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 28
  %15 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %15, i32 0, i32 10
  %16 = load i32, ptr %enc_flags, align 8
  %and = and i32 %16, 8
  %tobool = icmp ne i32 %and, 0
  %cond19 = select i1 %tobool, i32 1, i32 0
  store i32 %cond19, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then17, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @SSL_is_tls(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %type12 = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type12, align 8
  %cmp13 = icmp eq i32 %9, 1
  br i1 %cmp13, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %10 = load ptr, ptr %s.addr, align 8
  %type14 = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %type14, align 8
  %cmp15 = icmp eq i32 %11, 2
  br i1 %cmp15, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %12 = load ptr, ptr %sc, align 8
  %cmp16 = icmp eq ptr %12, null
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end
  %13 = load ptr, ptr %sc, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %14 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 28
  %15 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %15, i32 0, i32 10
  %16 = load i32, ptr %enc_flags, align 8
  %and = and i32 %16, 8
  %tobool = icmp ne i32 %and, 0
  %cond19 = select i1 %tobool, i32 0, i32 1
  store i32 %cond19, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then17, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @SSL_is_quic(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %type1 = getelementptr inbounds %struct.ssl_st, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %type1, align 8
  %cmp2 = icmp eq i32 %3, 2
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define i32 @SSL_up_ref(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %references = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 4
  %call = call i32 @CRYPTO_UP_REF(ptr noundef %references, ptr noundef %i)
  %cmp = icmp sle i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %i, align 4
  %cmp1 = icmp sgt i32 %1, 1
  %cond = select i1 %cmp1, i32 1, i32 0
  store i32 %cond, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @CRYPTO_UP_REF(ptr noundef %refcnt, ptr noundef %ret) #0 {
entry:
  %refcnt.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  %.atomictmp = alloca i32, align 4
  %atomic-temp = alloca i32, align 4
  store ptr %refcnt, ptr %refcnt.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  %0 = load ptr, ptr %refcnt.addr, align 8
  %val = getelementptr inbounds %struct.CRYPTO_REF_COUNT, ptr %0, i32 0, i32 0
  store i32 1, ptr %.atomictmp, align 4
  %1 = load i32, ptr %.atomictmp, align 4
  %2 = atomicrmw add ptr %val, i32 %1 monotonic, align 4
  store i32 %2, ptr %atomic-temp, align 4
  %3 = load i32, ptr %atomic-temp, align 4
  %add = add nsw i32 %3, 1
  %4 = load ptr, ptr %ret.addr, align 8
  store i32 %add, ptr %4, align 4
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_session_id_context(ptr noundef %ctx, ptr noundef %sid_ctx, i32 noundef %sid_ctx_len) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %sid_ctx.addr = alloca ptr, align 8
  %sid_ctx_len.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %sid_ctx, ptr %sid_ctx.addr, align 8
  store i32 %sid_ctx_len, ptr %sid_ctx_len.addr, align 4
  %0 = load i32, ptr %sid_ctx_len.addr, align 4
  %cmp = icmp ugt i32 %0, 32
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1015, ptr noundef @__func__.SSL_CTX_set_session_id_context)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 273, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %sid_ctx_len.addr, align 4
  %conv = zext i32 %1 to i64
  %2 = load ptr, ptr %ctx.addr, align 8
  %sid_ctx_length = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 45
  store i64 %conv, ptr %sid_ctx_length, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %sid_ctx1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 46
  %arraydecay = getelementptr inbounds [32 x i8], ptr %sid_ctx1, i64 0, i64 0
  %4 = load ptr, ptr %sid_ctx.addr, align 8
  %5 = load i32, ptr %sid_ctx_len.addr, align 4
  %conv2 = zext i32 %5 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %4, i64 %conv2, i1 false)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_session_id_context(ptr noundef %ssl, ptr noundef %sid_ctx, i32 noundef %sid_ctx_len) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %sid_ctx.addr = alloca ptr, align 8
  %sid_ctx_len.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %sid_ctx, ptr %sid_ctx.addr, align 8
  store i32 %sid_ctx_len, ptr %sid_ctx_len.addr, align 4
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load i32, ptr %sid_ctx_len.addr, align 4
  %cmp13 = icmp ugt i32 %9, 32
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1033, ptr noundef @__func__.SSL_set_session_id_context)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 273, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end
  %10 = load i32, ptr %sid_ctx_len.addr, align 4
  %conv = zext i32 %10 to i64
  %11 = load ptr, ptr %sc, align 8
  %sid_ctx_length = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 48
  store i64 %conv, ptr %sid_ctx_length, align 8
  %12 = load ptr, ptr %sc, align 8
  %sid_ctx16 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 49
  %arraydecay = getelementptr inbounds [32 x i8], ptr %sid_ctx16, i64 0, i64 0
  %13 = load ptr, ptr %sid_ctx.addr, align 8
  %14 = load i32, ptr %sid_ctx_len.addr, align 4
  %conv17 = zext i32 %14 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %13, i64 %conv17, i1 false)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then14, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_generate_session_id(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %lock = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 70
  %1 = load ptr, ptr %lock, align 8
  %call = call i32 @CRYPTO_THREAD_write_lock(ptr noundef %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %cb.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %generate_session_id = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 48
  store ptr %2, ptr %generate_session_id, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %lock1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %4, i32 0, i32 70
  %5 = load ptr, ptr %lock1, align 8
  %call2 = call i32 @CRYPTO_THREAD_unlock(ptr noundef %5)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare i32 @CRYPTO_THREAD_write_lock(ptr noundef) #1

declare i32 @CRYPTO_THREAD_unlock(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set_generate_session_id(ptr noundef %ssl, ptr noundef %cb) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %ssl.addr, align 8
  %lock = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 5
  %10 = load ptr, ptr %lock, align 8
  %call = call i32 @CRYPTO_THREAD_write_lock(ptr noundef %10)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %11 = load ptr, ptr %cb.addr, align 8
  %12 = load ptr, ptr %sc, align 8
  %generate_session_id = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 54
  store ptr %11, ptr %generate_session_id, align 8
  %13 = load ptr, ptr %ssl.addr, align 8
  %lock13 = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %lock13, align 8
  %call14 = call i32 @CRYPTO_THREAD_unlock(ptr noundef %14)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define i32 @SSL_has_matching_session_id(ptr noundef %ssl, ptr noundef %id, i32 noundef %id_len) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %id.addr = alloca ptr, align 8
  %id_len.addr = alloca i32, align 4
  %r = alloca %struct.ssl_session_st, align 8
  %p = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %id, ptr %id.addr, align 8
  store i32 %id_len, ptr %id_len.addr, align 4
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %9 = load i32, ptr %id_len.addr, align 4
  %conv = zext i32 %9 to i64
  %cmp13 = icmp ugt i64 %conv, 32
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %10 = load ptr, ptr %sc, align 8
  %version = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 1
  %11 = load i32, ptr %version, align 8
  %ssl_version = getelementptr inbounds %struct.ssl_session_st, ptr %r, i32 0, i32 0
  store i32 %11, ptr %ssl_version, align 8
  %12 = load i32, ptr %id_len.addr, align 4
  %conv15 = zext i32 %12 to i64
  %session_id_length = getelementptr inbounds %struct.ssl_session_st, ptr %r, i32 0, i32 4
  store i64 %conv15, ptr %session_id_length, align 8
  %session_id = getelementptr inbounds %struct.ssl_session_st, ptr %r, i32 0, i32 5
  %arraydecay = getelementptr inbounds [32 x i8], ptr %session_id, i64 0, i64 0
  %13 = load ptr, ptr %id.addr, align 8
  %14 = load i32, ptr %id_len.addr, align 4
  %conv16 = zext i32 %14 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %13, i64 %conv16, i1 false)
  %15 = load ptr, ptr %sc, align 8
  %session_ctx = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 87
  %16 = load ptr, ptr %session_ctx, align 8
  %lock = getelementptr inbounds %struct.ssl_ctx_st, ptr %16, i32 0, i32 70
  %17 = load ptr, ptr %lock, align 8
  %call = call i32 @CRYPTO_THREAD_read_lock(ptr noundef %17)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end
  %18 = load ptr, ptr %sc, align 8
  %session_ctx19 = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 87
  %19 = load ptr, ptr %session_ctx19, align 8
  %sessions = getelementptr inbounds %struct.ssl_ctx_st, ptr %19, i32 0, i32 6
  %20 = load ptr, ptr %sessions, align 8
  %call20 = call ptr @lh_SSL_SESSION_retrieve(ptr noundef %20, ptr noundef %r)
  store ptr %call20, ptr %p, align 8
  %21 = load ptr, ptr %sc, align 8
  %session_ctx21 = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 87
  %22 = load ptr, ptr %session_ctx21, align 8
  %lock22 = getelementptr inbounds %struct.ssl_ctx_st, ptr %22, i32 0, i32 70
  %23 = load ptr, ptr %lock22, align 8
  %call23 = call i32 @CRYPTO_THREAD_unlock(ptr noundef %23)
  %24 = load ptr, ptr %p, align 8
  %cmp24 = icmp ne ptr %24, null
  %conv25 = zext i1 %cmp24 to i32
  store i32 %conv25, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then17, %if.then
  %25 = load i32, ptr %retval, align 4
  ret i32 %25
}

declare i32 @CRYPTO_THREAD_read_lock(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @lh_SSL_SESSION_retrieve(ptr noundef %lh, ptr noundef %d) #0 {
entry:
  %lh.addr = alloca ptr, align 8
  %d.addr = alloca ptr, align 8
  store ptr %lh, ptr %lh.addr, align 8
  store ptr %d, ptr %d.addr, align 8
  %0 = load ptr, ptr %lh.addr, align 8
  %1 = load ptr, ptr %d.addr, align 8
  %call = call ptr @OPENSSL_LH_retrieve(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_purpose(ptr noundef %s, i32 noundef %purpose) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %purpose.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %purpose, ptr %purpose.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %param = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 49
  %1 = load ptr, ptr %param, align 8
  %2 = load i32, ptr %purpose.addr, align 4
  %call = call i32 @X509_VERIFY_PARAM_set_purpose(ptr noundef %1, i32 noundef %2)
  ret i32 %call
}

declare i32 @X509_VERIFY_PARAM_set_purpose(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set_purpose(ptr noundef %s, i32 noundef %purpose) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %purpose.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %purpose, ptr %purpose.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 25
  %10 = load ptr, ptr %param, align 8
  %11 = load i32, ptr %purpose.addr, align 4
  %call = call i32 @X509_VERIFY_PARAM_set_purpose(ptr noundef %10, i32 noundef %11)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_trust(ptr noundef %s, i32 noundef %trust) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %trust.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %trust, ptr %trust.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %param = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 49
  %1 = load ptr, ptr %param, align 8
  %2 = load i32, ptr %trust.addr, align 4
  %call = call i32 @X509_VERIFY_PARAM_set_trust(ptr noundef %1, i32 noundef %2)
  ret i32 %call
}

declare i32 @X509_VERIFY_PARAM_set_trust(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set_trust(ptr noundef %s, i32 noundef %trust) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %trust.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %trust, ptr %trust.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 25
  %10 = load ptr, ptr %param, align 8
  %11 = load i32, ptr %trust.addr, align 4
  %call = call i32 @X509_VERIFY_PARAM_set_trust(ptr noundef %10, i32 noundef %11)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set1_host(ptr noundef %s, ptr noundef %hostname) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %hostname.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %hostname, ptr %hostname.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %hostname.addr, align 8
  %cmp13 = icmp ne ptr %9, null
  br i1 %cmp13, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.end
  %10 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 25
  %11 = load ptr, ptr %param, align 8
  %12 = load ptr, ptr %hostname.addr, align 8
  %call = call i32 @X509_VERIFY_PARAM_set1_ip_asc(ptr noundef %11, ptr noundef %12)
  %cmp14 = icmp eq i32 %call, 1
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %if.end
  %13 = load ptr, ptr %sc, align 8
  %param17 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 25
  %14 = load ptr, ptr %param17, align 8
  %15 = load ptr, ptr %hostname.addr, align 8
  %call18 = call i32 @X509_VERIFY_PARAM_set1_host(ptr noundef %14, ptr noundef %15, i64 noundef 0)
  store i32 %call18, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end16, %if.then15, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

declare i32 @X509_VERIFY_PARAM_set1_ip_asc(ptr noundef, ptr noundef) #1

declare i32 @X509_VERIFY_PARAM_set1_host(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_add1_host(ptr noundef %s, ptr noundef %hostname) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %hostname.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  %ip = alloca ptr, align 8
  %old_ip = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %hostname, ptr %hostname.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %hostname.addr, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.then13, label %if.end23

if.then13:                                        ; preds = %if.end
  %10 = load ptr, ptr %hostname.addr, align 8
  %call = call ptr @a2i_IPADDRESS(ptr noundef %10)
  store ptr %call, ptr %ip, align 8
  %11 = load ptr, ptr %ip, align 8
  %tobool14 = icmp ne ptr %11, null
  br i1 %tobool14, label %if.then15, label %if.end22

if.then15:                                        ; preds = %if.then13
  %12 = load ptr, ptr %ip, align 8
  call void @ASN1_OCTET_STRING_free(ptr noundef %12)
  %13 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 25
  %14 = load ptr, ptr %param, align 8
  %call16 = call ptr @X509_VERIFY_PARAM_get1_ip_asc(ptr noundef %14)
  store ptr %call16, ptr %old_ip, align 8
  %15 = load ptr, ptr %old_ip, align 8
  %tobool17 = icmp ne ptr %15, null
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then15
  %16 = load ptr, ptr %old_ip, align 8
  call void @CRYPTO_free(ptr noundef %16, ptr noundef @.str, i32 noundef 1157)
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.then15
  %17 = load ptr, ptr %sc, align 8
  %param20 = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 25
  %18 = load ptr, ptr %param20, align 8
  %19 = load ptr, ptr %hostname.addr, align 8
  %call21 = call i32 @X509_VERIFY_PARAM_set1_ip_asc(ptr noundef %18, ptr noundef %19)
  store i32 %call21, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.then13
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end
  %20 = load ptr, ptr %sc, align 8
  %param24 = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 25
  %21 = load ptr, ptr %param24, align 8
  %22 = load ptr, ptr %hostname.addr, align 8
  %call25 = call i32 @X509_VERIFY_PARAM_add1_host(ptr noundef %21, ptr noundef %22, i64 noundef 0)
  store i32 %call25, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end23, %if.end19, %if.then18, %if.then
  %23 = load i32, ptr %retval, align 4
  ret i32 %23
}

declare ptr @a2i_IPADDRESS(ptr noundef) #1

declare void @ASN1_OCTET_STRING_free(ptr noundef) #1

declare ptr @X509_VERIFY_PARAM_get1_ip_asc(ptr noundef) #1

declare i32 @X509_VERIFY_PARAM_add1_host(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define void @SSL_set_hostflags(ptr noundef %s, i32 noundef %flags) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 25
  %10 = load ptr, ptr %param, align 8
  %11 = load i32, ptr %flags.addr, align 4
  call void @X509_VERIFY_PARAM_set_hostflags(ptr noundef %10, i32 noundef %11)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare void @X509_VERIFY_PARAM_set_hostflags(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_get0_peername(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 25
  %10 = load ptr, ptr %param, align 8
  %call = call ptr @X509_VERIFY_PARAM_get0_peername(ptr noundef %10)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

declare ptr @X509_VERIFY_PARAM_get0_peername(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_dane_enable(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %dane = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 67
  %call = call i32 @dane_ctx_enable(ptr noundef %dane)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @dane_ctx_enable(ptr noundef %dctx) #0 {
entry:
  %retval = alloca i32, align 4
  %dctx.addr = alloca ptr, align 8
  %mdevp = alloca ptr, align 8
  %mdord = alloca ptr, align 8
  %mdmax = alloca i8, align 1
  %n = alloca i32, align 4
  %i = alloca i64, align 8
  %md = alloca ptr, align 8
  store ptr %dctx, ptr %dctx.addr, align 8
  store i8 2, ptr %mdmax, align 1
  %0 = load i8, ptr %mdmax, align 1
  %conv = zext i8 %0 to i32
  %add = add nsw i32 %conv, 1
  store i32 %add, ptr %n, align 4
  %1 = load ptr, ptr %dctx.addr, align 8
  %mdevp1 = getelementptr inbounds %struct.dane_ctx_st, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %mdevp1, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %n, align 4
  %conv3 = sext i32 %3 to i64
  %mul = mul i64 %conv3, 8
  %call = call noalias ptr @CRYPTO_zalloc(i64 noundef %mul, ptr noundef @.str, i32 noundef 117)
  store ptr %call, ptr %mdevp, align 8
  %4 = load i32, ptr %n, align 4
  %conv4 = sext i32 %4 to i64
  %mul5 = mul i64 %conv4, 1
  %call6 = call noalias ptr @CRYPTO_zalloc(i64 noundef %mul5, ptr noundef @.str, i32 noundef 118)
  store ptr %call6, ptr %mdord, align 8
  %5 = load ptr, ptr %mdord, align 8
  %cmp7 = icmp eq ptr %5, null
  br i1 %cmp7, label %if.then11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %6 = load ptr, ptr %mdevp, align 8
  %cmp9 = icmp eq ptr %6, null
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %lor.lhs.false, %if.end
  %7 = load ptr, ptr %mdord, align 8
  call void @CRYPTO_free(ptr noundef %7, ptr noundef @.str, i32 noundef 121)
  %8 = load ptr, ptr %mdevp, align 8
  call void @CRYPTO_free(ptr noundef %8, ptr noundef @.str, i32 noundef 122)
  store i32 0, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %lor.lhs.false
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end12
  %9 = load i64, ptr %i, align 8
  %cmp13 = icmp ult i64 %9, 3
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds [3 x %struct.anon.7], ptr @dane_mds, i64 0, i64 %10
  %nid = getelementptr inbounds %struct.anon.7, ptr %arrayidx, i32 0, i32 2
  %11 = load i32, ptr %nid, align 4
  %cmp15 = icmp eq i32 %11, 0
  br i1 %cmp15, label %if.then24, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %for.body
  %12 = load i64, ptr %i, align 8
  %arrayidx18 = getelementptr inbounds [3 x %struct.anon.7], ptr @dane_mds, i64 0, i64 %12
  %nid19 = getelementptr inbounds %struct.anon.7, ptr %arrayidx18, i32 0, i32 2
  %13 = load i32, ptr %nid19, align 4
  %call20 = call ptr @OBJ_nid2sn(i32 noundef %13)
  %call21 = call ptr @EVP_get_digestbyname(ptr noundef %call20)
  store ptr %call21, ptr %md, align 8
  %cmp22 = icmp eq ptr %call21, null
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %lor.lhs.false17, %for.body
  br label %for.inc

if.end25:                                         ; preds = %lor.lhs.false17
  %14 = load ptr, ptr %md, align 8
  %15 = load ptr, ptr %mdevp, align 8
  %16 = load i64, ptr %i, align 8
  %arrayidx26 = getelementptr inbounds [3 x %struct.anon.7], ptr @dane_mds, i64 0, i64 %16
  %mtype = getelementptr inbounds %struct.anon.7, ptr %arrayidx26, i32 0, i32 0
  %17 = load i8, ptr %mtype, align 8
  %idxprom = zext i8 %17 to i64
  %arrayidx27 = getelementptr inbounds ptr, ptr %15, i64 %idxprom
  store ptr %14, ptr %arrayidx27, align 8
  %18 = load i64, ptr %i, align 8
  %arrayidx28 = getelementptr inbounds [3 x %struct.anon.7], ptr @dane_mds, i64 0, i64 %18
  %ord = getelementptr inbounds %struct.anon.7, ptr %arrayidx28, i32 0, i32 1
  %19 = load i8, ptr %ord, align 1
  %20 = load ptr, ptr %mdord, align 8
  %21 = load i64, ptr %i, align 8
  %arrayidx29 = getelementptr inbounds [3 x %struct.anon.7], ptr @dane_mds, i64 0, i64 %21
  %mtype30 = getelementptr inbounds %struct.anon.7, ptr %arrayidx29, i32 0, i32 0
  %22 = load i8, ptr %mtype30, align 8
  %idxprom31 = zext i8 %22 to i64
  %arrayidx32 = getelementptr inbounds i8, ptr %20, i64 %idxprom31
  store i8 %19, ptr %arrayidx32, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end25, %if.then24
  %23 = load i64, ptr %i, align 8
  %inc = add i64 %23, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !4

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %mdevp, align 8
  %25 = load ptr, ptr %dctx.addr, align 8
  %mdevp33 = getelementptr inbounds %struct.dane_ctx_st, ptr %25, i32 0, i32 0
  store ptr %24, ptr %mdevp33, align 8
  %26 = load ptr, ptr %mdord, align 8
  %27 = load ptr, ptr %dctx.addr, align 8
  %mdord34 = getelementptr inbounds %struct.dane_ctx_st, ptr %27, i32 0, i32 1
  store ptr %26, ptr %mdord34, align 8
  %28 = load i8, ptr %mdmax, align 1
  %29 = load ptr, ptr %dctx.addr, align 8
  %mdmax35 = getelementptr inbounds %struct.dane_ctx_st, ptr %29, i32 0, i32 2
  store i8 %28, ptr %mdmax35, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then11, %if.then
  %30 = load i32, ptr %retval, align 4
  ret i32 %30
}

; Function Attrs: nounwind uwtable
define i64 @SSL_CTX_dane_set_flags(ptr noundef %ctx, i64 noundef %flags) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  %orig = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %dane = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 67
  %flags1 = getelementptr inbounds %struct.dane_ctx_st, ptr %dane, i32 0, i32 3
  %1 = load i64, ptr %flags1, align 8
  store i64 %1, ptr %orig, align 8
  %2 = load i64, ptr %flags.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %dane2 = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 67
  %flags3 = getelementptr inbounds %struct.dane_ctx_st, ptr %dane2, i32 0, i32 3
  %4 = load i64, ptr %flags3, align 8
  %or = or i64 %4, %2
  store i64 %or, ptr %flags3, align 8
  %5 = load i64, ptr %orig, align 8
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define i64 @SSL_CTX_dane_clear_flags(ptr noundef %ctx, i64 noundef %flags) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  %orig = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %dane = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 67
  %flags1 = getelementptr inbounds %struct.dane_ctx_st, ptr %dane, i32 0, i32 3
  %1 = load i64, ptr %flags1, align 8
  store i64 %1, ptr %orig, align 8
  %2 = load i64, ptr %flags.addr, align 8
  %not = xor i64 %2, -1
  %3 = load ptr, ptr %ctx.addr, align 8
  %dane2 = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 67
  %flags3 = getelementptr inbounds %struct.dane_ctx_st, ptr %dane2, i32 0, i32 3
  %4 = load i64, ptr %flags3, align 8
  %and = and i64 %4, %not
  store i64 %and, ptr %flags3, align 8
  %5 = load i64, ptr %orig, align 8
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define i32 @SSL_dane_enable(ptr noundef %s, ptr noundef %basedomain) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %basedomain.addr = alloca ptr, align 8
  %dane = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %basedomain, ptr %basedomain.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %dane13 = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 26
  store ptr %dane13, ptr %dane, align 8
  %10 = load ptr, ptr %s.addr, align 8
  %ctx = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 1
  %11 = load ptr, ptr %ctx, align 8
  %dane14 = getelementptr inbounds %struct.ssl_ctx_st, ptr %11, i32 0, i32 67
  %mdmax = getelementptr inbounds %struct.dane_ctx_st, ptr %dane14, i32 0, i32 2
  %12 = load i8, ptr %mdmax, align 8
  %conv = zext i8 %12 to i32
  %cmp15 = icmp eq i32 %conv, 0
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1220, ptr noundef @__func__.SSL_dane_enable)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 167, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end
  %13 = load ptr, ptr %dane, align 8
  %trecs = getelementptr inbounds %struct.ssl_dane_st, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %trecs, align 8
  %cmp19 = icmp ne ptr %14, null
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1224, ptr noundef @__func__.SSL_dane_enable)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 172, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end18
  %15 = load ptr, ptr %sc, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 80
  %hostname = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 3
  %16 = load ptr, ptr %hostname, align 8
  %cmp23 = icmp eq ptr %16, null
  br i1 %cmp23, label %if.then25, label %if.end28

if.then25:                                        ; preds = %if.end22
  %17 = load ptr, ptr %s.addr, align 8
  %18 = load ptr, ptr %basedomain.addr, align 8
  %call = call i64 @SSL_ctrl(ptr noundef %17, i32 noundef 55, i64 noundef 0, ptr noundef %18)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.then25
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1235, ptr noundef @__func__.SSL_dane_enable)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 204, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.then25
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end22
  %19 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %19, i32 0, i32 25
  %20 = load ptr, ptr %param, align 8
  %21 = load ptr, ptr %basedomain.addr, align 8
  %call29 = call i32 @X509_VERIFY_PARAM_set1_host(ptr noundef %20, ptr noundef %21, i64 noundef 0)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.end28
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1242, ptr noundef @__func__.SSL_dane_enable)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 204, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.end28
  %22 = load ptr, ptr %dane, align 8
  %mdpth = getelementptr inbounds %struct.ssl_dane_st, ptr %22, i32 0, i32 6
  store i32 -1, ptr %mdpth, align 4
  %23 = load ptr, ptr %dane, align 8
  %pdpth = getelementptr inbounds %struct.ssl_dane_st, ptr %23, i32 0, i32 7
  store i32 -1, ptr %pdpth, align 8
  %24 = load ptr, ptr %s.addr, align 8
  %ctx33 = getelementptr inbounds %struct.ssl_st, ptr %24, i32 0, i32 1
  %25 = load ptr, ptr %ctx33, align 8
  %dane34 = getelementptr inbounds %struct.ssl_ctx_st, ptr %25, i32 0, i32 67
  %26 = load ptr, ptr %dane, align 8
  %dctx = getelementptr inbounds %struct.ssl_dane_st, ptr %26, i32 0, i32 0
  store ptr %dane34, ptr %dctx, align 8
  %call35 = call ptr @sk_danetls_record_new_null()
  %27 = load ptr, ptr %dane, align 8
  %trecs36 = getelementptr inbounds %struct.ssl_dane_st, ptr %27, i32 0, i32 1
  store ptr %call35, ptr %trecs36, align 8
  %28 = load ptr, ptr %dane, align 8
  %trecs37 = getelementptr inbounds %struct.ssl_dane_st, ptr %28, i32 0, i32 1
  %29 = load ptr, ptr %trecs37, align 8
  %cmp38 = icmp eq ptr %29, null
  br i1 %cmp38, label %if.then40, label %if.end41

if.then40:                                        ; preds = %if.end32
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1252, ptr noundef @__func__.SSL_dane_enable)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end32
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end41, %if.then40, %if.then31, %if.then26, %if.then21, %if.then17, %if.then
  %30 = load i32, ptr %retval, align 4
  ret i32 %30
}

; Function Attrs: nounwind uwtable
define i64 @SSL_ctrl(ptr noundef %s, i32 noundef %cmd, i64 noundef %larg, ptr noundef %parg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cmd.addr = alloca i32, align 4
  %larg.addr = alloca i64, align 8
  %parg.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %larg, ptr %larg.addr, align 8
  store ptr %parg, ptr %parg.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %cmd.addr, align 4
  %2 = load i64, ptr %larg.addr, align 8
  %3 = load ptr, ptr %parg.addr, align 8
  %call = call i64 @ossl_ctrl_internal(ptr noundef %0, i32 noundef %1, i64 noundef %2, ptr noundef %3, i32 noundef 0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal ptr @sk_danetls_record_new_null() #0 {
entry:
  %call = call ptr @OPENSSL_sk_new_null()
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define i64 @SSL_dane_set_flags(ptr noundef %ssl, i64 noundef %flags) #0 {
entry:
  %retval = alloca i64, align 8
  %ssl.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  %orig = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %dane = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 26
  %flags13 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane, i32 0, i32 8
  %10 = load i64, ptr %flags13, align 8
  store i64 %10, ptr %orig, align 8
  %11 = load i64, ptr %flags.addr, align 8
  %12 = load ptr, ptr %sc, align 8
  %dane14 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 26
  %flags15 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane14, i32 0, i32 8
  %13 = load i64, ptr %flags15, align 8
  %or = or i64 %13, %11
  store i64 %or, ptr %flags15, align 8
  %14 = load i64, ptr %orig, align 8
  store i64 %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define i64 @SSL_dane_clear_flags(ptr noundef %ssl, i64 noundef %flags) #0 {
entry:
  %retval = alloca i64, align 8
  %ssl.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  %orig = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %dane = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 26
  %flags13 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane, i32 0, i32 8
  %10 = load i64, ptr %flags13, align 8
  store i64 %10, ptr %orig, align 8
  %11 = load i64, ptr %flags.addr, align 8
  %not = xor i64 %11, -1
  %12 = load ptr, ptr %sc, align 8
  %dane14 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 26
  %flags15 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane14, i32 0, i32 8
  %13 = load i64, ptr %flags15, align 8
  %and = and i64 %13, %not
  store i64 %and, ptr %flags15, align 8
  %14 = load i64, ptr %orig, align 8
  store i64 %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get0_dane_authority(ptr noundef %s, ptr noundef %mcert, ptr noundef %mspki) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %mcert.addr = alloca ptr, align 8
  %mspki.addr = alloca ptr, align 8
  %dane = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %mcert, ptr %mcert.addr, align 8
  store ptr %mspki, ptr %mspki.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %dane13 = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 26
  store ptr %dane13, ptr %dane, align 8
  %10 = load ptr, ptr %dane, align 8
  %cmp14 = icmp ne ptr %10, null
  br i1 %cmp14, label %land.lhs.true, label %if.then17

land.lhs.true:                                    ; preds = %if.end
  %11 = load ptr, ptr %dane, align 8
  %trecs = getelementptr inbounds %struct.ssl_dane_st, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %trecs, align 8
  %call = call i32 @sk_danetls_record_num(ptr noundef %12)
  %cmp15 = icmp sgt i32 %call, 0
  br i1 %cmp15, label %lor.lhs.false, label %if.then17

lor.lhs.false:                                    ; preds = %land.lhs.true
  %13 = load ptr, ptr %sc, align 8
  %verify_result = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 67
  %14 = load i64, ptr %verify_result, align 8
  %cmp16 = icmp ne i64 %14, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %lor.lhs.false, %land.lhs.true, %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %lor.lhs.false
  %15 = load ptr, ptr %dane, align 8
  %mtlsa = getelementptr inbounds %struct.ssl_dane_st, ptr %15, i32 0, i32 3
  %16 = load ptr, ptr %mtlsa, align 8
  %tobool = icmp ne ptr %16, null
  br i1 %tobool, label %if.then19, label %if.end34

if.then19:                                        ; preds = %if.end18
  %17 = load ptr, ptr %mcert.addr, align 8
  %tobool20 = icmp ne ptr %17, null
  br i1 %tobool20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %if.then19
  %18 = load ptr, ptr %dane, align 8
  %mcert22 = getelementptr inbounds %struct.ssl_dane_st, ptr %18, i32 0, i32 4
  %19 = load ptr, ptr %mcert22, align 8
  %20 = load ptr, ptr %mcert.addr, align 8
  store ptr %19, ptr %20, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.then21, %if.then19
  %21 = load ptr, ptr %mspki.addr, align 8
  %tobool24 = icmp ne ptr %21, null
  br i1 %tobool24, label %if.then25, label %if.end33

if.then25:                                        ; preds = %if.end23
  %22 = load ptr, ptr %dane, align 8
  %mcert26 = getelementptr inbounds %struct.ssl_dane_st, ptr %22, i32 0, i32 4
  %23 = load ptr, ptr %mcert26, align 8
  %cmp27 = icmp eq ptr %23, null
  br i1 %cmp27, label %cond.true28, label %cond.false30

cond.true28:                                      ; preds = %if.then25
  %24 = load ptr, ptr %dane, align 8
  %mtlsa29 = getelementptr inbounds %struct.ssl_dane_st, ptr %24, i32 0, i32 3
  %25 = load ptr, ptr %mtlsa29, align 8
  %spki = getelementptr inbounds %struct.danetls_record_st, ptr %25, i32 0, i32 5
  %26 = load ptr, ptr %spki, align 8
  br label %cond.end31

cond.false30:                                     ; preds = %if.then25
  br label %cond.end31

cond.end31:                                       ; preds = %cond.false30, %cond.true28
  %cond32 = phi ptr [ %26, %cond.true28 ], [ null, %cond.false30 ]
  %27 = load ptr, ptr %mspki.addr, align 8
  store ptr %cond32, ptr %27, align 8
  br label %if.end33

if.end33:                                         ; preds = %cond.end31, %if.end23
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.end18
  %28 = load ptr, ptr %dane, align 8
  %mdpth = getelementptr inbounds %struct.ssl_dane_st, ptr %28, i32 0, i32 6
  %29 = load i32, ptr %mdpth, align 4
  store i32 %29, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end34, %if.then17, %if.then
  %30 = load i32, ptr %retval, align 4
  ret i32 %30
}

; Function Attrs: nounwind uwtable
define internal i32 @sk_danetls_record_num(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  %call = call i32 @OPENSSL_sk_num(ptr noundef %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get0_dane_tlsa(ptr noundef %s, ptr noundef %usage, ptr noundef %selector, ptr noundef %mtype, ptr noundef %data, ptr noundef %dlen) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %usage.addr = alloca ptr, align 8
  %selector.addr = alloca ptr, align 8
  %mtype.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %dlen.addr = alloca ptr, align 8
  %dane = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %usage, ptr %usage.addr, align 8
  store ptr %selector, ptr %selector.addr, align 8
  store ptr %mtype, ptr %mtype.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %dlen, ptr %dlen.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %dane13 = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 26
  store ptr %dane13, ptr %dane, align 8
  %10 = load ptr, ptr %dane, align 8
  %cmp14 = icmp ne ptr %10, null
  br i1 %cmp14, label %land.lhs.true, label %if.then17

land.lhs.true:                                    ; preds = %if.end
  %11 = load ptr, ptr %dane, align 8
  %trecs = getelementptr inbounds %struct.ssl_dane_st, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %trecs, align 8
  %call = call i32 @sk_danetls_record_num(ptr noundef %12)
  %cmp15 = icmp sgt i32 %call, 0
  br i1 %cmp15, label %lor.lhs.false, label %if.then17

lor.lhs.false:                                    ; preds = %land.lhs.true
  %13 = load ptr, ptr %sc, align 8
  %verify_result = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 67
  %14 = load i64, ptr %verify_result, align 8
  %cmp16 = icmp ne i64 %14, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %lor.lhs.false, %land.lhs.true, %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %lor.lhs.false
  %15 = load ptr, ptr %dane, align 8
  %mtlsa = getelementptr inbounds %struct.ssl_dane_st, ptr %15, i32 0, i32 3
  %16 = load ptr, ptr %mtlsa, align 8
  %tobool = icmp ne ptr %16, null
  br i1 %tobool, label %if.then19, label %if.end45

if.then19:                                        ; preds = %if.end18
  %17 = load ptr, ptr %usage.addr, align 8
  %tobool20 = icmp ne ptr %17, null
  br i1 %tobool20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.then19
  %18 = load ptr, ptr %dane, align 8
  %mtlsa22 = getelementptr inbounds %struct.ssl_dane_st, ptr %18, i32 0, i32 3
  %19 = load ptr, ptr %mtlsa22, align 8
  %usage23 = getelementptr inbounds %struct.danetls_record_st, ptr %19, i32 0, i32 0
  %20 = load i8, ptr %usage23, align 8
  %21 = load ptr, ptr %usage.addr, align 8
  store i8 %20, ptr %21, align 1
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.then19
  %22 = load ptr, ptr %selector.addr, align 8
  %tobool25 = icmp ne ptr %22, null
  br i1 %tobool25, label %if.then26, label %if.end29

if.then26:                                        ; preds = %if.end24
  %23 = load ptr, ptr %dane, align 8
  %mtlsa27 = getelementptr inbounds %struct.ssl_dane_st, ptr %23, i32 0, i32 3
  %24 = load ptr, ptr %mtlsa27, align 8
  %selector28 = getelementptr inbounds %struct.danetls_record_st, ptr %24, i32 0, i32 1
  %25 = load i8, ptr %selector28, align 1
  %26 = load ptr, ptr %selector.addr, align 8
  store i8 %25, ptr %26, align 1
  br label %if.end29

if.end29:                                         ; preds = %if.then26, %if.end24
  %27 = load ptr, ptr %mtype.addr, align 8
  %tobool30 = icmp ne ptr %27, null
  br i1 %tobool30, label %if.then31, label %if.end34

if.then31:                                        ; preds = %if.end29
  %28 = load ptr, ptr %dane, align 8
  %mtlsa32 = getelementptr inbounds %struct.ssl_dane_st, ptr %28, i32 0, i32 3
  %29 = load ptr, ptr %mtlsa32, align 8
  %mtype33 = getelementptr inbounds %struct.danetls_record_st, ptr %29, i32 0, i32 2
  %30 = load i8, ptr %mtype33, align 2
  %31 = load ptr, ptr %mtype.addr, align 8
  store i8 %30, ptr %31, align 1
  br label %if.end34

if.end34:                                         ; preds = %if.then31, %if.end29
  %32 = load ptr, ptr %data.addr, align 8
  %tobool35 = icmp ne ptr %32, null
  br i1 %tobool35, label %if.then36, label %if.end39

if.then36:                                        ; preds = %if.end34
  %33 = load ptr, ptr %dane, align 8
  %mtlsa37 = getelementptr inbounds %struct.ssl_dane_st, ptr %33, i32 0, i32 3
  %34 = load ptr, ptr %mtlsa37, align 8
  %data38 = getelementptr inbounds %struct.danetls_record_st, ptr %34, i32 0, i32 3
  %35 = load ptr, ptr %data38, align 8
  %36 = load ptr, ptr %data.addr, align 8
  store ptr %35, ptr %36, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.then36, %if.end34
  %37 = load ptr, ptr %dlen.addr, align 8
  %tobool40 = icmp ne ptr %37, null
  br i1 %tobool40, label %if.then41, label %if.end44

if.then41:                                        ; preds = %if.end39
  %38 = load ptr, ptr %dane, align 8
  %mtlsa42 = getelementptr inbounds %struct.ssl_dane_st, ptr %38, i32 0, i32 3
  %39 = load ptr, ptr %mtlsa42, align 8
  %dlen43 = getelementptr inbounds %struct.danetls_record_st, ptr %39, i32 0, i32 4
  %40 = load i64, ptr %dlen43, align 8
  %41 = load ptr, ptr %dlen.addr, align 8
  store i64 %40, ptr %41, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.then41, %if.end39
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.end18
  %42 = load ptr, ptr %dane, align 8
  %mdpth = getelementptr inbounds %struct.ssl_dane_st, ptr %42, i32 0, i32 6
  %43 = load i32, ptr %mdpth, align 4
  store i32 %43, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end45, %if.then17, %if.then
  %44 = load i32, ptr %retval, align 4
  ret i32 %44
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get0_dane(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %dane = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 26
  store ptr %dane, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define i32 @SSL_dane_tlsa_add(ptr noundef %s, i8 noundef zeroext %usage, i8 noundef zeroext %selector, i8 noundef zeroext %mtype, ptr noundef %data, i64 noundef %dlen) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %usage.addr = alloca i8, align 1
  %selector.addr = alloca i8, align 1
  %mtype.addr = alloca i8, align 1
  %data.addr = alloca ptr, align 8
  %dlen.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i8 %usage, ptr %usage.addr, align 1
  store i8 %selector, ptr %selector.addr, align 1
  store i8 %mtype, ptr %mtype.addr, align 1
  store ptr %data, ptr %data.addr, align 8
  store i64 %dlen, ptr %dlen.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %dane = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 26
  %10 = load i8, ptr %usage.addr, align 1
  %11 = load i8, ptr %selector.addr, align 1
  %12 = load i8, ptr %mtype.addr, align 1
  %13 = load ptr, ptr %data.addr, align 8
  %14 = load i64, ptr %dlen.addr, align 8
  %call = call i32 @dane_tlsa_add(ptr noundef %dane, i8 noundef zeroext %10, i8 noundef zeroext %11, i8 noundef zeroext %12, ptr noundef %13, i64 noundef %14)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal i32 @dane_tlsa_add(ptr noundef %dane, i8 noundef zeroext %usage, i8 noundef zeroext %selector, i8 noundef zeroext %mtype, ptr noundef %data, i64 noundef %dlen) #0 {
entry:
  %retval = alloca i32, align 4
  %dane.addr = alloca ptr, align 8
  %usage.addr = alloca i8, align 1
  %selector.addr = alloca i8, align 1
  %mtype.addr = alloca i8, align 1
  %data.addr = alloca ptr, align 8
  %dlen.addr = alloca i64, align 8
  %t = alloca ptr, align 8
  %md = alloca ptr, align 8
  %ilen = alloca i32, align 4
  %i = alloca i32, align 4
  %num = alloca i32, align 4
  %p = alloca ptr, align 8
  %cert = alloca ptr, align 8
  %pkey = alloca ptr, align 8
  %rec = alloca ptr, align 8
  store ptr %dane, ptr %dane.addr, align 8
  store i8 %usage, ptr %usage.addr, align 1
  store i8 %selector, ptr %selector.addr, align 1
  store i8 %mtype, ptr %mtype.addr, align 1
  store ptr %data, ptr %data.addr, align 8
  store i64 %dlen, ptr %dlen.addr, align 8
  store ptr null, ptr %md, align 8
  %0 = load i64, ptr %dlen.addr, align 8
  %conv = trunc i64 %0 to i32
  store i32 %conv, ptr %ilen, align 4
  %1 = load ptr, ptr %dane.addr, align 8
  %trecs = getelementptr inbounds %struct.ssl_dane_st, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %trecs, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 270, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 175, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, ptr %ilen, align 4
  %cmp2 = icmp slt i32 %3, 0
  br i1 %cmp2, label %if.then7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %4 = load i64, ptr %dlen.addr, align 8
  %5 = load i32, ptr %ilen, align 4
  %conv4 = sext i32 %5 to i64
  %cmp5 = icmp ne i64 %4, %conv4
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %lor.lhs.false, %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 275, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 189, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %lor.lhs.false
  %6 = load i8, ptr %usage.addr, align 1
  %conv9 = zext i8 %6 to i32
  %cmp10 = icmp sgt i32 %conv9, 3
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end8
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 280, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 184, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end8
  %7 = load i8, ptr %selector.addr, align 1
  %conv14 = zext i8 %7 to i32
  %cmp15 = icmp sgt i32 %conv14, 1
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end13
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 285, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 202, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end13
  %8 = load i8, ptr %mtype.addr, align 1
  %conv19 = zext i8 %8 to i32
  %cmp20 = icmp ne i32 %conv19, 0
  br i1 %cmp20, label %if.then22, label %if.end27

if.then22:                                        ; preds = %if.end18
  %9 = load ptr, ptr %dane.addr, align 8
  %10 = load i8, ptr %mtype.addr, align 1
  %call = call ptr @tlsa_md_get(ptr noundef %9, i8 noundef zeroext %10)
  store ptr %call, ptr %md, align 8
  %11 = load ptr, ptr %md, align 8
  %cmp23 = icmp eq ptr %11, null
  br i1 %cmp23, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.then22
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 292, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 200, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.then22
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %if.end18
  %12 = load ptr, ptr %md, align 8
  %cmp28 = icmp ne ptr %12, null
  br i1 %cmp28, label %land.lhs.true, label %if.end35

land.lhs.true:                                    ; preds = %if.end27
  %13 = load i64, ptr %dlen.addr, align 8
  %14 = load ptr, ptr %md, align 8
  %call30 = call i32 @EVP_MD_get_size(ptr noundef %14)
  %conv31 = sext i32 %call30 to i64
  %cmp32 = icmp ne i64 %13, %conv31
  br i1 %cmp32, label %if.then34, label %if.end35

if.then34:                                        ; preds = %land.lhs.true
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 298, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 192, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end35:                                         ; preds = %land.lhs.true, %if.end27
  %15 = load ptr, ptr %data.addr, align 8
  %tobool = icmp ne ptr %15, null
  br i1 %tobool, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.end35
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 302, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 203, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end35
  %call38 = call noalias ptr @CRYPTO_zalloc(i64 noundef 32, ptr noundef @.str, i32 noundef 306)
  store ptr %call38, ptr %t, align 8
  %cmp39 = icmp eq ptr %call38, null
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end37
  store i32 -1, ptr %retval, align 4
  br label %return

if.end42:                                         ; preds = %if.end37
  %16 = load i8, ptr %usage.addr, align 1
  %17 = load ptr, ptr %t, align 8
  %usage43 = getelementptr inbounds %struct.danetls_record_st, ptr %17, i32 0, i32 0
  store i8 %16, ptr %usage43, align 8
  %18 = load i8, ptr %selector.addr, align 1
  %19 = load ptr, ptr %t, align 8
  %selector44 = getelementptr inbounds %struct.danetls_record_st, ptr %19, i32 0, i32 1
  store i8 %18, ptr %selector44, align 1
  %20 = load i8, ptr %mtype.addr, align 1
  %21 = load ptr, ptr %t, align 8
  %mtype45 = getelementptr inbounds %struct.danetls_record_st, ptr %21, i32 0, i32 2
  store i8 %20, ptr %mtype45, align 2
  %22 = load i64, ptr %dlen.addr, align 8
  %call46 = call noalias ptr @CRYPTO_malloc(i64 noundef %22, ptr noundef @.str, i32 noundef 312)
  %23 = load ptr, ptr %t, align 8
  %data47 = getelementptr inbounds %struct.danetls_record_st, ptr %23, i32 0, i32 3
  store ptr %call46, ptr %data47, align 8
  %24 = load ptr, ptr %t, align 8
  %data48 = getelementptr inbounds %struct.danetls_record_st, ptr %24, i32 0, i32 3
  %25 = load ptr, ptr %data48, align 8
  %cmp49 = icmp eq ptr %25, null
  br i1 %cmp49, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.end42
  %26 = load ptr, ptr %t, align 8
  call void @tlsa_free(ptr noundef %26)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end52:                                         ; preds = %if.end42
  %27 = load ptr, ptr %t, align 8
  %data53 = getelementptr inbounds %struct.danetls_record_st, ptr %27, i32 0, i32 3
  %28 = load ptr, ptr %data53, align 8
  %29 = load ptr, ptr %data.addr, align 8
  %30 = load i64, ptr %dlen.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %28, ptr align 1 %29, i64 %30, i1 false)
  %31 = load i64, ptr %dlen.addr, align 8
  %32 = load ptr, ptr %t, align 8
  %dlen54 = getelementptr inbounds %struct.danetls_record_st, ptr %32, i32 0, i32 4
  store i64 %31, ptr %dlen54, align 8
  %33 = load i8, ptr %mtype.addr, align 1
  %conv55 = zext i8 %33 to i32
  %cmp56 = icmp eq i32 %conv55, 0
  br i1 %cmp56, label %if.then58, label %if.end116

if.then58:                                        ; preds = %if.end52
  %34 = load ptr, ptr %data.addr, align 8
  store ptr %34, ptr %p, align 8
  store ptr null, ptr %cert, align 8
  store ptr null, ptr %pkey, align 8
  %35 = load i8, ptr %selector.addr, align 1
  %conv59 = zext i8 %35 to i32
  switch i32 %conv59, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb96
  ]

sw.bb:                                            ; preds = %if.then58
  %36 = load i32, ptr %ilen, align 4
  %conv60 = sext i32 %36 to i64
  %call61 = call ptr @d2i_X509(ptr noundef %cert, ptr noundef %p, i64 noundef %conv60)
  %tobool62 = icmp ne ptr %call61, null
  br i1 %tobool62, label %lor.lhs.false63, label %if.then69

lor.lhs.false63:                                  ; preds = %sw.bb
  %37 = load ptr, ptr %p, align 8
  %38 = load ptr, ptr %data.addr, align 8
  %cmp64 = icmp ult ptr %37, %38
  br i1 %cmp64, label %if.then69, label %lor.lhs.false66

lor.lhs.false66:                                  ; preds = %lor.lhs.false63
  %39 = load i64, ptr %dlen.addr, align 8
  %40 = load ptr, ptr %p, align 8
  %41 = load ptr, ptr %data.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %40 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %41 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp67 = icmp ne i64 %39, %sub.ptr.sub
  br i1 %cmp67, label %if.then69, label %if.end70

if.then69:                                        ; preds = %lor.lhs.false66, %lor.lhs.false63, %sw.bb
  %42 = load ptr, ptr %cert, align 8
  call void @X509_free(ptr noundef %42)
  %43 = load ptr, ptr %t, align 8
  call void @tlsa_free(ptr noundef %43)
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 332, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 180, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end70:                                         ; preds = %lor.lhs.false66
  %44 = load ptr, ptr %cert, align 8
  %call71 = call ptr @X509_get0_pubkey(ptr noundef %44)
  %cmp72 = icmp eq ptr %call71, null
  br i1 %cmp72, label %if.then74, label %if.end75

if.then74:                                        ; preds = %if.end70
  %45 = load ptr, ptr %cert, align 8
  call void @X509_free(ptr noundef %45)
  %46 = load ptr, ptr %t, align 8
  call void @tlsa_free(ptr noundef %46)
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 338, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 180, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end75:                                         ; preds = %if.end70
  %47 = load i8, ptr %usage.addr, align 1
  %conv76 = zext i8 %47 to i32
  %shl = shl i32 1, %conv76
  %and = and i32 %shl, 5
  %cmp77 = icmp eq i32 %and, 0
  br i1 %cmp77, label %if.then79, label %if.end80

if.then79:                                        ; preds = %if.end75
  %48 = load ptr, ptr %cert, align 8
  call void @X509_free(ptr noundef %48)
  br label %sw.epilog

if.end80:                                         ; preds = %if.end75
  %49 = load ptr, ptr %dane.addr, align 8
  %certs = getelementptr inbounds %struct.ssl_dane_st, ptr %49, i32 0, i32 2
  %50 = load ptr, ptr %certs, align 8
  %cmp81 = icmp eq ptr %50, null
  br i1 %cmp81, label %land.lhs.true83, label %lor.lhs.false88

land.lhs.true83:                                  ; preds = %if.end80
  %call84 = call ptr @OPENSSL_sk_new_null()
  %51 = load ptr, ptr %dane.addr, align 8
  %certs85 = getelementptr inbounds %struct.ssl_dane_st, ptr %51, i32 0, i32 2
  store ptr %call84, ptr %certs85, align 8
  %cmp86 = icmp eq ptr %call84, null
  br i1 %cmp86, label %if.then94, label %lor.lhs.false88

lor.lhs.false88:                                  ; preds = %land.lhs.true83, %if.end80
  %52 = load ptr, ptr %dane.addr, align 8
  %certs89 = getelementptr inbounds %struct.ssl_dane_st, ptr %52, i32 0, i32 2
  %53 = load ptr, ptr %certs89, align 8
  %call90 = call ptr @ossl_check_X509_sk_type(ptr noundef %53)
  %54 = load ptr, ptr %cert, align 8
  %call91 = call ptr @ossl_check_X509_type(ptr noundef %54)
  %call92 = call i32 @OPENSSL_sk_push(ptr noundef %call90, ptr noundef %call91)
  %tobool93 = icmp ne i32 %call92, 0
  br i1 %tobool93, label %if.end95, label %if.then94

if.then94:                                        ; preds = %lor.lhs.false88, %land.lhs.true83
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 369, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  %55 = load ptr, ptr %cert, align 8
  call void @X509_free(ptr noundef %55)
  %56 = load ptr, ptr %t, align 8
  call void @tlsa_free(ptr noundef %56)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end95:                                         ; preds = %lor.lhs.false88
  br label %sw.epilog

sw.bb96:                                          ; preds = %if.then58
  %57 = load i32, ptr %ilen, align 4
  %conv97 = sext i32 %57 to i64
  %call98 = call ptr @d2i_PUBKEY(ptr noundef %pkey, ptr noundef %p, i64 noundef %conv97)
  %tobool99 = icmp ne ptr %call98, null
  br i1 %tobool99, label %lor.lhs.false100, label %if.then109

lor.lhs.false100:                                 ; preds = %sw.bb96
  %58 = load ptr, ptr %p, align 8
  %59 = load ptr, ptr %data.addr, align 8
  %cmp101 = icmp ult ptr %58, %59
  br i1 %cmp101, label %if.then109, label %lor.lhs.false103

lor.lhs.false103:                                 ; preds = %lor.lhs.false100
  %60 = load i64, ptr %dlen.addr, align 8
  %61 = load ptr, ptr %p, align 8
  %62 = load ptr, ptr %data.addr, align 8
  %sub.ptr.lhs.cast104 = ptrtoint ptr %61 to i64
  %sub.ptr.rhs.cast105 = ptrtoint ptr %62 to i64
  %sub.ptr.sub106 = sub i64 %sub.ptr.lhs.cast104, %sub.ptr.rhs.cast105
  %cmp107 = icmp ne i64 %60, %sub.ptr.sub106
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %lor.lhs.false103, %lor.lhs.false100, %sw.bb96
  %63 = load ptr, ptr %pkey, align 8
  call void @EVP_PKEY_free(ptr noundef %63)
  %64 = load ptr, ptr %t, align 8
  call void @tlsa_free(ptr noundef %64)
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 381, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 201, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end110:                                        ; preds = %lor.lhs.false103
  %65 = load i8, ptr %usage.addr, align 1
  %conv111 = zext i8 %65 to i32
  %cmp112 = icmp eq i32 %conv111, 2
  br i1 %cmp112, label %if.then114, label %if.else

if.then114:                                       ; preds = %if.end110
  %66 = load ptr, ptr %pkey, align 8
  %67 = load ptr, ptr %t, align 8
  %spki = getelementptr inbounds %struct.danetls_record_st, ptr %67, i32 0, i32 5
  store ptr %66, ptr %spki, align 8
  br label %if.end115

if.else:                                          ; preds = %if.end110
  %68 = load ptr, ptr %pkey, align 8
  call void @EVP_PKEY_free(ptr noundef %68)
  br label %if.end115

if.end115:                                        ; preds = %if.else, %if.then114
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end115, %if.end95, %if.then79, %if.then58
  br label %if.end116

if.end116:                                        ; preds = %sw.epilog, %if.end52
  %69 = load ptr, ptr %dane.addr, align 8
  %trecs117 = getelementptr inbounds %struct.ssl_dane_st, ptr %69, i32 0, i32 1
  %70 = load ptr, ptr %trecs117, align 8
  %call118 = call i32 @sk_danetls_record_num(ptr noundef %70)
  store i32 %call118, ptr %num, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end116
  %71 = load i32, ptr %i, align 4
  %72 = load i32, ptr %num, align 4
  %cmp119 = icmp slt i32 %71, %72
  br i1 %cmp119, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %73 = load ptr, ptr %dane.addr, align 8
  %trecs121 = getelementptr inbounds %struct.ssl_dane_st, ptr %73, i32 0, i32 1
  %74 = load ptr, ptr %trecs121, align 8
  %75 = load i32, ptr %i, align 4
  %call122 = call ptr @sk_danetls_record_value(ptr noundef %74, i32 noundef %75)
  store ptr %call122, ptr %rec, align 8
  %76 = load ptr, ptr %rec, align 8
  %usage123 = getelementptr inbounds %struct.danetls_record_st, ptr %76, i32 0, i32 0
  %77 = load i8, ptr %usage123, align 8
  %conv124 = zext i8 %77 to i32
  %78 = load i8, ptr %usage.addr, align 1
  %conv125 = zext i8 %78 to i32
  %cmp126 = icmp sgt i32 %conv124, %conv125
  br i1 %cmp126, label %if.then128, label %if.end129

if.then128:                                       ; preds = %for.body
  br label %for.inc

if.end129:                                        ; preds = %for.body
  %79 = load ptr, ptr %rec, align 8
  %usage130 = getelementptr inbounds %struct.danetls_record_st, ptr %79, i32 0, i32 0
  %80 = load i8, ptr %usage130, align 8
  %conv131 = zext i8 %80 to i32
  %81 = load i8, ptr %usage.addr, align 1
  %conv132 = zext i8 %81 to i32
  %cmp133 = icmp slt i32 %conv131, %conv132
  br i1 %cmp133, label %if.then135, label %if.end136

if.then135:                                       ; preds = %if.end129
  br label %for.end

if.end136:                                        ; preds = %if.end129
  %82 = load ptr, ptr %rec, align 8
  %selector137 = getelementptr inbounds %struct.danetls_record_st, ptr %82, i32 0, i32 1
  %83 = load i8, ptr %selector137, align 1
  %conv138 = zext i8 %83 to i32
  %84 = load i8, ptr %selector.addr, align 1
  %conv139 = zext i8 %84 to i32
  %cmp140 = icmp sgt i32 %conv138, %conv139
  br i1 %cmp140, label %if.then142, label %if.end143

if.then142:                                       ; preds = %if.end136
  br label %for.inc

if.end143:                                        ; preds = %if.end136
  %85 = load ptr, ptr %rec, align 8
  %selector144 = getelementptr inbounds %struct.danetls_record_st, ptr %85, i32 0, i32 1
  %86 = load i8, ptr %selector144, align 1
  %conv145 = zext i8 %86 to i32
  %87 = load i8, ptr %selector.addr, align 1
  %conv146 = zext i8 %87 to i32
  %cmp147 = icmp slt i32 %conv145, %conv146
  br i1 %cmp147, label %if.then149, label %if.end150

if.then149:                                       ; preds = %if.end143
  br label %for.end

if.end150:                                        ; preds = %if.end143
  %88 = load ptr, ptr %dane.addr, align 8
  %dctx = getelementptr inbounds %struct.ssl_dane_st, ptr %88, i32 0, i32 0
  %89 = load ptr, ptr %dctx, align 8
  %mdord = getelementptr inbounds %struct.dane_ctx_st, ptr %89, i32 0, i32 1
  %90 = load ptr, ptr %mdord, align 8
  %91 = load ptr, ptr %rec, align 8
  %mtype151 = getelementptr inbounds %struct.danetls_record_st, ptr %91, i32 0, i32 2
  %92 = load i8, ptr %mtype151, align 2
  %idxprom = zext i8 %92 to i64
  %arrayidx = getelementptr inbounds i8, ptr %90, i64 %idxprom
  %93 = load i8, ptr %arrayidx, align 1
  %conv152 = zext i8 %93 to i32
  %94 = load ptr, ptr %dane.addr, align 8
  %dctx153 = getelementptr inbounds %struct.ssl_dane_st, ptr %94, i32 0, i32 0
  %95 = load ptr, ptr %dctx153, align 8
  %mdord154 = getelementptr inbounds %struct.dane_ctx_st, ptr %95, i32 0, i32 1
  %96 = load ptr, ptr %mdord154, align 8
  %97 = load i8, ptr %mtype.addr, align 1
  %idxprom155 = zext i8 %97 to i64
  %arrayidx156 = getelementptr inbounds i8, ptr %96, i64 %idxprom155
  %98 = load i8, ptr %arrayidx156, align 1
  %conv157 = zext i8 %98 to i32
  %cmp158 = icmp sgt i32 %conv152, %conv157
  br i1 %cmp158, label %if.then160, label %if.end161

if.then160:                                       ; preds = %if.end150
  br label %for.inc

if.end161:                                        ; preds = %if.end150
  br label %for.end

for.inc:                                          ; preds = %if.then160, %if.then142, %if.then128
  %99 = load i32, ptr %i, align 4
  %inc = add nsw i32 %99, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !6

for.end:                                          ; preds = %if.end161, %if.then149, %if.then135, %for.cond
  %100 = load ptr, ptr %dane.addr, align 8
  %trecs162 = getelementptr inbounds %struct.ssl_dane_st, ptr %100, i32 0, i32 1
  %101 = load ptr, ptr %trecs162, align 8
  %102 = load ptr, ptr %t, align 8
  %103 = load i32, ptr %i, align 4
  %call163 = call i32 @sk_danetls_record_insert(ptr noundef %101, ptr noundef %102, i32 noundef %103)
  %tobool164 = icmp ne i32 %call163, 0
  br i1 %tobool164, label %if.end166, label %if.then165

if.then165:                                       ; preds = %for.end
  %104 = load ptr, ptr %t, align 8
  call void @tlsa_free(ptr noundef %104)
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 431, ptr noundef @__func__.dane_tlsa_add)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end166:                                        ; preds = %for.end
  %105 = load i8, ptr %usage.addr, align 1
  %conv167 = zext i8 %105 to i32
  %shl168 = shl i32 1, %conv167
  %106 = load ptr, ptr %dane.addr, align 8
  %umask = getelementptr inbounds %struct.ssl_dane_st, ptr %106, i32 0, i32 5
  %107 = load i32, ptr %umask, align 8
  %or = or i32 %107, %shl168
  store i32 %or, ptr %umask, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end166, %if.then165, %if.then109, %if.then94, %if.then74, %if.then69, %if.then51, %if.then41, %if.then36, %if.then34, %if.then25, %if.then17, %if.then12, %if.then7, %if.then
  %108 = load i32, ptr %retval, align 4
  ret i32 %108
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_dane_mtype_set(ptr noundef %ctx, ptr noundef %md, i8 noundef zeroext %mtype, i8 noundef zeroext %ord) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %md.addr = alloca ptr, align 8
  %mtype.addr = alloca i8, align 1
  %ord.addr = alloca i8, align 1
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %md, ptr %md.addr, align 8
  store i8 %mtype, ptr %mtype.addr, align 1
  store i8 %ord, ptr %ord.addr, align 1
  %0 = load ptr, ptr %ctx.addr, align 8
  %dane = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 67
  %1 = load ptr, ptr %md.addr, align 8
  %2 = load i8, ptr %mtype.addr, align 1
  %3 = load i8, ptr %ord.addr, align 1
  %call = call i32 @dane_mtype_set(ptr noundef %dane, ptr noundef %1, i8 noundef zeroext %2, i8 noundef zeroext %3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @dane_mtype_set(ptr noundef %dctx, ptr noundef %md, i8 noundef zeroext %mtype, i8 noundef zeroext %ord) #0 {
entry:
  %retval = alloca i32, align 4
  %dctx.addr = alloca ptr, align 8
  %md.addr = alloca ptr, align 8
  %mtype.addr = alloca i8, align 1
  %ord.addr = alloca i8, align 1
  %i = alloca i32, align 4
  %mdevp = alloca ptr, align 8
  %mdord = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %dctx, ptr %dctx.addr, align 8
  store ptr %md, ptr %md.addr, align 8
  store i8 %mtype, ptr %mtype.addr, align 1
  store i8 %ord, ptr %ord.addr, align 1
  %0 = load i8, ptr %mtype.addr, align 1
  %conv = zext i8 %0 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %md.addr, align 8
  %cmp2 = icmp ne ptr %1, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 216, ptr noundef @__func__.dane_mtype_set)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 173, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load i8, ptr %mtype.addr, align 1
  %conv4 = zext i8 %2 to i32
  %3 = load ptr, ptr %dctx.addr, align 8
  %mdmax = getelementptr inbounds %struct.dane_ctx_st, ptr %3, i32 0, i32 2
  %4 = load i8, ptr %mdmax, align 8
  %conv5 = zext i8 %4 to i32
  %cmp6 = icmp sgt i32 %conv4, %conv5
  br i1 %cmp6, label %if.then8, label %if.end35

if.then8:                                         ; preds = %if.end
  %5 = load i8, ptr %mtype.addr, align 1
  %conv9 = zext i8 %5 to i32
  %add = add nsw i32 %conv9, 1
  store i32 %add, ptr %n, align 4
  %6 = load ptr, ptr %dctx.addr, align 8
  %mdevp10 = getelementptr inbounds %struct.dane_ctx_st, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %mdevp10, align 8
  %8 = load i32, ptr %n, align 4
  %conv11 = sext i32 %8 to i64
  %mul = mul i64 %conv11, 8
  %call = call ptr @CRYPTO_realloc(ptr noundef %7, i64 noundef %mul, ptr noundef @.str, i32 noundef 225)
  store ptr %call, ptr %mdevp, align 8
  %9 = load ptr, ptr %mdevp, align 8
  %cmp12 = icmp eq ptr %9, null
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.then8
  store i32 -1, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.then8
  %10 = load ptr, ptr %mdevp, align 8
  %11 = load ptr, ptr %dctx.addr, align 8
  %mdevp16 = getelementptr inbounds %struct.dane_ctx_st, ptr %11, i32 0, i32 0
  store ptr %10, ptr %mdevp16, align 8
  %12 = load ptr, ptr %dctx.addr, align 8
  %mdord17 = getelementptr inbounds %struct.dane_ctx_st, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %mdord17, align 8
  %14 = load i32, ptr %n, align 4
  %conv18 = sext i32 %14 to i64
  %mul19 = mul i64 %conv18, 1
  %call20 = call ptr @CRYPTO_realloc(ptr noundef %13, i64 noundef %mul19, ptr noundef @.str, i32 noundef 230)
  store ptr %call20, ptr %mdord, align 8
  %15 = load ptr, ptr %mdord, align 8
  %cmp21 = icmp eq ptr %15, null
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end15
  store i32 -1, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end15
  %16 = load ptr, ptr %mdord, align 8
  %17 = load ptr, ptr %dctx.addr, align 8
  %mdord25 = getelementptr inbounds %struct.dane_ctx_st, ptr %17, i32 0, i32 1
  store ptr %16, ptr %mdord25, align 8
  %18 = load ptr, ptr %dctx.addr, align 8
  %mdmax26 = getelementptr inbounds %struct.dane_ctx_st, ptr %18, i32 0, i32 2
  %19 = load i8, ptr %mdmax26, align 8
  %conv27 = zext i8 %19 to i32
  %add28 = add nsw i32 %conv27, 1
  store i32 %add28, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end24
  %20 = load i32, ptr %i, align 4
  %21 = load i8, ptr %mtype.addr, align 1
  %conv29 = zext i8 %21 to i32
  %cmp30 = icmp slt i32 %20, %conv29
  br i1 %cmp30, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %22 = load ptr, ptr %mdevp, align 8
  %23 = load i32, ptr %i, align 4
  %idxprom = sext i32 %23 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %22, i64 %idxprom
  store ptr null, ptr %arrayidx, align 8
  %24 = load ptr, ptr %mdord, align 8
  %25 = load i32, ptr %i, align 4
  %idxprom32 = sext i32 %25 to i64
  %arrayidx33 = getelementptr inbounds i8, ptr %24, i64 %idxprom32
  store i8 0, ptr %arrayidx33, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %26 = load i32, ptr %i, align 4
  %inc = add nsw i32 %26, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !7

for.end:                                          ; preds = %for.cond
  %27 = load i8, ptr %mtype.addr, align 1
  %28 = load ptr, ptr %dctx.addr, align 8
  %mdmax34 = getelementptr inbounds %struct.dane_ctx_st, ptr %28, i32 0, i32 2
  store i8 %27, ptr %mdmax34, align 8
  br label %if.end35

if.end35:                                         ; preds = %for.end, %if.end
  %29 = load ptr, ptr %md.addr, align 8
  %30 = load ptr, ptr %dctx.addr, align 8
  %mdevp36 = getelementptr inbounds %struct.dane_ctx_st, ptr %30, i32 0, i32 0
  %31 = load ptr, ptr %mdevp36, align 8
  %32 = load i8, ptr %mtype.addr, align 1
  %idxprom37 = zext i8 %32 to i64
  %arrayidx38 = getelementptr inbounds ptr, ptr %31, i64 %idxprom37
  store ptr %29, ptr %arrayidx38, align 8
  %33 = load ptr, ptr %md.addr, align 8
  %cmp39 = icmp eq ptr %33, null
  br i1 %cmp39, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end35
  br label %cond.end

cond.false:                                       ; preds = %if.end35
  %34 = load i8, ptr %ord.addr, align 1
  %conv41 = zext i8 %34 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %conv41, %cond.false ]
  %conv42 = trunc i32 %cond to i8
  %35 = load ptr, ptr %dctx.addr, align 8
  %mdord43 = getelementptr inbounds %struct.dane_ctx_st, ptr %35, i32 0, i32 1
  %36 = load ptr, ptr %mdord43, align 8
  %37 = load i8, ptr %mtype.addr, align 1
  %idxprom44 = zext i8 %37 to i64
  %arrayidx45 = getelementptr inbounds i8, ptr %36, i64 %idxprom44
  store i8 %conv42, ptr %arrayidx45, align 1
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then23, %if.then14, %if.then
  %38 = load i32, ptr %retval, align 4
  ret i32 %38
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set1_param(ptr noundef %ctx, ptr noundef %vpm) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %vpm.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %vpm, ptr %vpm.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %param = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 49
  %1 = load ptr, ptr %param, align 8
  %2 = load ptr, ptr %vpm.addr, align 8
  %call = call i32 @X509_VERIFY_PARAM_set1(ptr noundef %1, ptr noundef %2)
  ret i32 %call
}

declare i32 @X509_VERIFY_PARAM_set1(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set1_param(ptr noundef %ssl, ptr noundef %vpm) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %vpm.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %vpm, ptr %vpm.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 25
  %10 = load ptr, ptr %param, align 8
  %11 = load ptr, ptr %vpm.addr, align 8
  %call = call i32 @X509_VERIFY_PARAM_set1(ptr noundef %10, ptr noundef %11)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get0_param(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %param = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 49
  %1 = load ptr, ptr %param, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get0_param(ptr noundef %ssl) #0 {
entry:
  %retval = alloca ptr, align 8
  %ssl.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 25
  %10 = load ptr, ptr %param, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define void @SSL_certs_clear(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 44
  %10 = load ptr, ptr %cert, align 8
  call void @ssl_cert_clear_certs(ptr noundef %10)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare void @ssl_cert_clear_certs(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @CRYPTO_DOWN_REF(ptr noundef %refcnt, ptr noundef %ret) #0 {
entry:
  %refcnt.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  %.atomictmp = alloca i32, align 4
  %atomic-temp = alloca i32, align 4
  store ptr %refcnt, ptr %refcnt.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  %0 = load ptr, ptr %refcnt.addr, align 8
  %val = getelementptr inbounds %struct.CRYPTO_REF_COUNT, ptr %0, i32 0, i32 0
  store i32 1, ptr %.atomictmp, align 4
  %1 = load i32, ptr %.atomictmp, align 4
  %2 = atomicrmw sub ptr %val, i32 %1 monotonic, align 4
  store i32 %2, ptr %atomic-temp, align 4
  %3 = load i32, ptr %atomic-temp, align 4
  %sub = sub nsw i32 %3, 1
  %4 = load ptr, ptr %ret.addr, align 8
  store i32 %sub, ptr %4, align 4
  %5 = load ptr, ptr %ret.addr, align 8
  %6 = load i32, ptr %5, align 4
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  fence acquire
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 1
}

declare void @CRYPTO_free_ex_data(i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define void @SSL_CTX_free(ptr noundef %a) #0 {
entry:
  %a.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %j = alloca i64, align 8
  store ptr %a, ptr %a.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %a.addr, align 8
  %references = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 16
  %call = call i32 @CRYPTO_DOWN_REF(ptr noundef %references, ptr noundef %i)
  %2 = load i32, ptr %i, align 4
  %cmp1 = icmp sgt i32 %2, 0
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  br label %return

if.end3:                                          ; preds = %if.end
  %3 = load ptr, ptr %a.addr, align 8
  %param = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 49
  %4 = load ptr, ptr %param, align 8
  call void @X509_VERIFY_PARAM_free(ptr noundef %4)
  %5 = load ptr, ptr %a.addr, align 8
  %dane = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 67
  call void @dane_ctx_final(ptr noundef %dane)
  %6 = load ptr, ptr %a.addr, align 8
  %sessions = getelementptr inbounds %struct.ssl_ctx_st, ptr %6, i32 0, i32 6
  %7 = load ptr, ptr %sessions, align 8
  %cmp4 = icmp ne ptr %7, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  %8 = load ptr, ptr %a.addr, align 8
  call void @SSL_CTX_flush_sessions(ptr noundef %8, i64 noundef 0)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end3
  %9 = load ptr, ptr %a.addr, align 8
  %10 = load ptr, ptr %a.addr, align 8
  %ex_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %10, i32 0, i32 26
  call void @CRYPTO_free_ex_data(i32 noundef 1, ptr noundef %9, ptr noundef %ex_data)
  %11 = load ptr, ptr %a.addr, align 8
  %sessions7 = getelementptr inbounds %struct.ssl_ctx_st, ptr %11, i32 0, i32 6
  %12 = load ptr, ptr %sessions7, align 8
  call void @lh_SSL_SESSION_free(ptr noundef %12)
  %13 = load ptr, ptr %a.addr, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %13, i32 0, i32 5
  %14 = load ptr, ptr %cert_store, align 8
  call void @X509_STORE_free(ptr noundef %14)
  %15 = load ptr, ptr %a.addr, align 8
  %ctlog_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %15, i32 0, i32 51
  %16 = load ptr, ptr %ctlog_store, align 8
  call void @CTLOG_STORE_free(ptr noundef %16)
  %17 = load ptr, ptr %a.addr, align 8
  %cipher_list = getelementptr inbounds %struct.ssl_ctx_st, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %cipher_list, align 8
  %call8 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %18)
  call void @OPENSSL_sk_free(ptr noundef %call8)
  %19 = load ptr, ptr %a.addr, align 8
  %cipher_list_by_id = getelementptr inbounds %struct.ssl_ctx_st, ptr %19, i32 0, i32 3
  %20 = load ptr, ptr %cipher_list_by_id, align 8
  %call9 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %20)
  call void @OPENSSL_sk_free(ptr noundef %call9)
  %21 = load ptr, ptr %a.addr, align 8
  %tls13_ciphersuites = getelementptr inbounds %struct.ssl_ctx_st, ptr %21, i32 0, i32 4
  %22 = load ptr, ptr %tls13_ciphersuites, align 8
  %call10 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %22)
  call void @OPENSSL_sk_free(ptr noundef %call10)
  %23 = load ptr, ptr %a.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %23, i32 0, i32 39
  %24 = load ptr, ptr %cert, align 8
  call void @ssl_cert_free(ptr noundef %24)
  %25 = load ptr, ptr %a.addr, align 8
  %ca_names = getelementptr inbounds %struct.ssl_ctx_st, ptr %25, i32 0, i32 32
  %26 = load ptr, ptr %ca_names, align 8
  %call11 = call ptr @ossl_check_X509_NAME_sk_type(ptr noundef %26)
  %call12 = call ptr @ossl_check_X509_NAME_freefunc_type(ptr noundef @X509_NAME_free)
  call void @OPENSSL_sk_pop_free(ptr noundef %call11, ptr noundef %call12)
  %27 = load ptr, ptr %a.addr, align 8
  %client_ca_names = getelementptr inbounds %struct.ssl_ctx_st, ptr %27, i32 0, i32 33
  %28 = load ptr, ptr %client_ca_names, align 8
  %call13 = call ptr @ossl_check_X509_NAME_sk_type(ptr noundef %28)
  %call14 = call ptr @ossl_check_X509_NAME_freefunc_type(ptr noundef @X509_NAME_free)
  call void @OPENSSL_sk_pop_free(ptr noundef %call13, ptr noundef %call14)
  %29 = load ptr, ptr %a.addr, align 8
  %extra_certs = getelementptr inbounds %struct.ssl_ctx_st, ptr %29, i32 0, i32 29
  %30 = load ptr, ptr %extra_certs, align 8
  call void @OSSL_STACK_OF_X509_free(ptr noundef %30)
  %31 = load ptr, ptr %a.addr, align 8
  %comp_methods = getelementptr inbounds %struct.ssl_ctx_st, ptr %31, i32 0, i32 30
  store ptr null, ptr %comp_methods, align 8
  %32 = load ptr, ptr %a.addr, align 8
  %srtp_profiles = getelementptr inbounds %struct.ssl_ctx_st, ptr %32, i32 0, i32 68
  %33 = load ptr, ptr %srtp_profiles, align 8
  %call15 = call ptr @ossl_check_SRTP_PROTECTION_PROFILE_sk_type(ptr noundef %33)
  call void @OPENSSL_sk_free(ptr noundef %call15)
  %34 = load ptr, ptr %a.addr, align 8
  %call16 = call i32 @ssl_ctx_srp_ctx_free_intern(ptr noundef %34)
  %35 = load ptr, ptr %a.addr, align 8
  %client_cert_engine = getelementptr inbounds %struct.ssl_ctx_st, ptr %35, i32 0, i32 58
  %36 = load ptr, ptr %client_cert_engine, align 8
  call void @tls_engine_finish(ptr noundef %36)
  %37 = load ptr, ptr %a.addr, align 8
  %ext = getelementptr inbounds %struct.ssl_ctx_st, ptr %37, i32 0, i32 61
  %ecpointformats = getelementptr inbounds %struct.anon.4, ptr %ext, i32 0, i32 11
  %38 = load ptr, ptr %ecpointformats, align 8
  call void @CRYPTO_free(ptr noundef %38, ptr noundef @.str, i32 noundef 4188)
  %39 = load ptr, ptr %a.addr, align 8
  %ext17 = getelementptr inbounds %struct.ssl_ctx_st, ptr %39, i32 0, i32 61
  %supportedgroups = getelementptr inbounds %struct.anon.4, ptr %ext17, i32 0, i32 13
  %40 = load ptr, ptr %supportedgroups, align 8
  call void @CRYPTO_free(ptr noundef %40, ptr noundef @.str, i32 noundef 4189)
  %41 = load ptr, ptr %a.addr, align 8
  %ext18 = getelementptr inbounds %struct.ssl_ctx_st, ptr %41, i32 0, i32 61
  %supported_groups_default = getelementptr inbounds %struct.anon.4, ptr %ext18, i32 0, i32 14
  %42 = load ptr, ptr %supported_groups_default, align 8
  call void @CRYPTO_free(ptr noundef %42, ptr noundef @.str, i32 noundef 4190)
  %43 = load ptr, ptr %a.addr, align 8
  %ext19 = getelementptr inbounds %struct.ssl_ctx_st, ptr %43, i32 0, i32 61
  %alpn = getelementptr inbounds %struct.anon.4, ptr %ext19, i32 0, i32 18
  %44 = load ptr, ptr %alpn, align 8
  call void @CRYPTO_free(ptr noundef %44, ptr noundef @.str, i32 noundef 4191)
  %45 = load ptr, ptr %a.addr, align 8
  %ext20 = getelementptr inbounds %struct.ssl_ctx_st, ptr %45, i32 0, i32 61
  %secure = getelementptr inbounds %struct.anon.4, ptr %ext20, i32 0, i32 3
  %46 = load ptr, ptr %secure, align 8
  call void @CRYPTO_secure_free(ptr noundef %46, ptr noundef @.str, i32 noundef 4192)
  %47 = load ptr, ptr %a.addr, align 8
  %md5 = getelementptr inbounds %struct.ssl_ctx_st, ptr %47, i32 0, i32 27
  %48 = load ptr, ptr %md5, align 8
  call void @ssl_evp_md_free(ptr noundef %48)
  %49 = load ptr, ptr %a.addr, align 8
  %sha1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %49, i32 0, i32 28
  %50 = load ptr, ptr %sha1, align 8
  call void @ssl_evp_md_free(ptr noundef %50)
  store i64 0, ptr %j, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %51 = load i64, ptr %j, align 8
  %cmp21 = icmp ult i64 %51, 24
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %52 = load ptr, ptr %a.addr, align 8
  %ssl_cipher_methods = getelementptr inbounds %struct.ssl_ctx_st, ptr %52, i32 0, i32 88
  %53 = load i64, ptr %j, align 8
  %arrayidx = getelementptr inbounds [24 x ptr], ptr %ssl_cipher_methods, i64 0, i64 %53
  %54 = load ptr, ptr %arrayidx, align 8
  call void @ssl_evp_cipher_free(ptr noundef %54)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %55 = load i64, ptr %j, align 8
  %inc = add i64 %55, 1
  store i64 %inc, ptr %j, align 8
  br label %for.cond, !llvm.loop !8

for.end:                                          ; preds = %for.cond
  store i64 0, ptr %j, align 8
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc26, %for.end
  %56 = load i64, ptr %j, align 8
  %cmp23 = icmp ult i64 %56, 14
  br i1 %cmp23, label %for.body24, label %for.end28

for.body24:                                       ; preds = %for.cond22
  %57 = load ptr, ptr %a.addr, align 8
  %ssl_digest_methods = getelementptr inbounds %struct.ssl_ctx_st, ptr %57, i32 0, i32 89
  %58 = load i64, ptr %j, align 8
  %arrayidx25 = getelementptr inbounds [14 x ptr], ptr %ssl_digest_methods, i64 0, i64 %58
  %59 = load ptr, ptr %arrayidx25, align 8
  call void @ssl_evp_md_free(ptr noundef %59)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body24
  %60 = load i64, ptr %j, align 8
  %inc27 = add i64 %60, 1
  store i64 %inc27, ptr %j, align 8
  br label %for.cond22, !llvm.loop !9

for.end28:                                        ; preds = %for.cond22
  store i64 0, ptr %j, align 8
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc37, %for.end28
  %61 = load i64, ptr %j, align 8
  %62 = load ptr, ptr %a.addr, align 8
  %group_list_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %62, i32 0, i32 95
  %63 = load i64, ptr %group_list_len, align 8
  %cmp30 = icmp ult i64 %61, %63
  br i1 %cmp30, label %for.body31, label %for.end39

for.body31:                                       ; preds = %for.cond29
  %64 = load ptr, ptr %a.addr, align 8
  %group_list = getelementptr inbounds %struct.ssl_ctx_st, ptr %64, i32 0, i32 94
  %65 = load ptr, ptr %group_list, align 8
  %66 = load i64, ptr %j, align 8
  %arrayidx32 = getelementptr inbounds %struct.tls_group_info_st, ptr %65, i64 %66
  %tlsname = getelementptr inbounds %struct.tls_group_info_st, ptr %arrayidx32, i32 0, i32 0
  %67 = load ptr, ptr %tlsname, align 8
  call void @CRYPTO_free(ptr noundef %67, ptr noundef @.str, i32 noundef 4202)
  %68 = load ptr, ptr %a.addr, align 8
  %group_list33 = getelementptr inbounds %struct.ssl_ctx_st, ptr %68, i32 0, i32 94
  %69 = load ptr, ptr %group_list33, align 8
  %70 = load i64, ptr %j, align 8
  %arrayidx34 = getelementptr inbounds %struct.tls_group_info_st, ptr %69, i64 %70
  %realname = getelementptr inbounds %struct.tls_group_info_st, ptr %arrayidx34, i32 0, i32 1
  %71 = load ptr, ptr %realname, align 8
  call void @CRYPTO_free(ptr noundef %71, ptr noundef @.str, i32 noundef 4203)
  %72 = load ptr, ptr %a.addr, align 8
  %group_list35 = getelementptr inbounds %struct.ssl_ctx_st, ptr %72, i32 0, i32 94
  %73 = load ptr, ptr %group_list35, align 8
  %74 = load i64, ptr %j, align 8
  %arrayidx36 = getelementptr inbounds %struct.tls_group_info_st, ptr %73, i64 %74
  %algorithm = getelementptr inbounds %struct.tls_group_info_st, ptr %arrayidx36, i32 0, i32 2
  %75 = load ptr, ptr %algorithm, align 8
  call void @CRYPTO_free(ptr noundef %75, ptr noundef @.str, i32 noundef 4204)
  br label %for.inc37

for.inc37:                                        ; preds = %for.body31
  %76 = load i64, ptr %j, align 8
  %inc38 = add i64 %76, 1
  store i64 %inc38, ptr %j, align 8
  br label %for.cond29, !llvm.loop !10

for.end39:                                        ; preds = %for.cond29
  %77 = load ptr, ptr %a.addr, align 8
  %group_list40 = getelementptr inbounds %struct.ssl_ctx_st, ptr %77, i32 0, i32 94
  %78 = load ptr, ptr %group_list40, align 8
  call void @CRYPTO_free(ptr noundef %78, ptr noundef @.str, i32 noundef 4206)
  store i64 0, ptr %j, align 8
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc61, %for.end39
  %79 = load i64, ptr %j, align 8
  %80 = load ptr, ptr %a.addr, align 8
  %sigalg_list_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %80, i32 0, i32 98
  %81 = load i64, ptr %sigalg_list_len, align 8
  %cmp42 = icmp ult i64 %79, %81
  br i1 %cmp42, label %for.body43, label %for.end63

for.body43:                                       ; preds = %for.cond41
  %82 = load ptr, ptr %a.addr, align 8
  %sigalg_list = getelementptr inbounds %struct.ssl_ctx_st, ptr %82, i32 0, i32 97
  %83 = load ptr, ptr %sigalg_list, align 8
  %84 = load i64, ptr %j, align 8
  %arrayidx44 = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %83, i64 %84
  %name = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %arrayidx44, i32 0, i32 0
  %85 = load ptr, ptr %name, align 8
  call void @CRYPTO_free(ptr noundef %85, ptr noundef @.str, i32 noundef 4208)
  %86 = load ptr, ptr %a.addr, align 8
  %sigalg_list45 = getelementptr inbounds %struct.ssl_ctx_st, ptr %86, i32 0, i32 97
  %87 = load ptr, ptr %sigalg_list45, align 8
  %88 = load i64, ptr %j, align 8
  %arrayidx46 = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %87, i64 %88
  %sigalg_name = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %arrayidx46, i32 0, i32 2
  %89 = load ptr, ptr %sigalg_name, align 8
  call void @CRYPTO_free(ptr noundef %89, ptr noundef @.str, i32 noundef 4209)
  %90 = load ptr, ptr %a.addr, align 8
  %sigalg_list47 = getelementptr inbounds %struct.ssl_ctx_st, ptr %90, i32 0, i32 97
  %91 = load ptr, ptr %sigalg_list47, align 8
  %92 = load i64, ptr %j, align 8
  %arrayidx48 = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %91, i64 %92
  %sigalg_oid = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %arrayidx48, i32 0, i32 3
  %93 = load ptr, ptr %sigalg_oid, align 8
  call void @CRYPTO_free(ptr noundef %93, ptr noundef @.str, i32 noundef 4210)
  %94 = load ptr, ptr %a.addr, align 8
  %sigalg_list49 = getelementptr inbounds %struct.ssl_ctx_st, ptr %94, i32 0, i32 97
  %95 = load ptr, ptr %sigalg_list49, align 8
  %96 = load i64, ptr %j, align 8
  %arrayidx50 = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %95, i64 %96
  %sig_name = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %arrayidx50, i32 0, i32 4
  %97 = load ptr, ptr %sig_name, align 8
  call void @CRYPTO_free(ptr noundef %97, ptr noundef @.str, i32 noundef 4211)
  %98 = load ptr, ptr %a.addr, align 8
  %sigalg_list51 = getelementptr inbounds %struct.ssl_ctx_st, ptr %98, i32 0, i32 97
  %99 = load ptr, ptr %sigalg_list51, align 8
  %100 = load i64, ptr %j, align 8
  %arrayidx52 = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %99, i64 %100
  %sig_oid = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %arrayidx52, i32 0, i32 5
  %101 = load ptr, ptr %sig_oid, align 8
  call void @CRYPTO_free(ptr noundef %101, ptr noundef @.str, i32 noundef 4212)
  %102 = load ptr, ptr %a.addr, align 8
  %sigalg_list53 = getelementptr inbounds %struct.ssl_ctx_st, ptr %102, i32 0, i32 97
  %103 = load ptr, ptr %sigalg_list53, align 8
  %104 = load i64, ptr %j, align 8
  %arrayidx54 = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %103, i64 %104
  %hash_name = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %arrayidx54, i32 0, i32 6
  %105 = load ptr, ptr %hash_name, align 8
  call void @CRYPTO_free(ptr noundef %105, ptr noundef @.str, i32 noundef 4213)
  %106 = load ptr, ptr %a.addr, align 8
  %sigalg_list55 = getelementptr inbounds %struct.ssl_ctx_st, ptr %106, i32 0, i32 97
  %107 = load ptr, ptr %sigalg_list55, align 8
  %108 = load i64, ptr %j, align 8
  %arrayidx56 = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %107, i64 %108
  %hash_oid = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %arrayidx56, i32 0, i32 7
  %109 = load ptr, ptr %hash_oid, align 8
  call void @CRYPTO_free(ptr noundef %109, ptr noundef @.str, i32 noundef 4214)
  %110 = load ptr, ptr %a.addr, align 8
  %sigalg_list57 = getelementptr inbounds %struct.ssl_ctx_st, ptr %110, i32 0, i32 97
  %111 = load ptr, ptr %sigalg_list57, align 8
  %112 = load i64, ptr %j, align 8
  %arrayidx58 = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %111, i64 %112
  %keytype = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %arrayidx58, i32 0, i32 8
  %113 = load ptr, ptr %keytype, align 8
  call void @CRYPTO_free(ptr noundef %113, ptr noundef @.str, i32 noundef 4215)
  %114 = load ptr, ptr %a.addr, align 8
  %sigalg_list59 = getelementptr inbounds %struct.ssl_ctx_st, ptr %114, i32 0, i32 97
  %115 = load ptr, ptr %sigalg_list59, align 8
  %116 = load i64, ptr %j, align 8
  %arrayidx60 = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %115, i64 %116
  %keytype_oid = getelementptr inbounds %struct.tls_sigalg_info_st, ptr %arrayidx60, i32 0, i32 9
  %117 = load ptr, ptr %keytype_oid, align 8
  call void @CRYPTO_free(ptr noundef %117, ptr noundef @.str, i32 noundef 4216)
  br label %for.inc61

for.inc61:                                        ; preds = %for.body43
  %118 = load i64, ptr %j, align 8
  %inc62 = add i64 %118, 1
  store i64 %inc62, ptr %j, align 8
  br label %for.cond41, !llvm.loop !11

for.end63:                                        ; preds = %for.cond41
  %119 = load ptr, ptr %a.addr, align 8
  %sigalg_list64 = getelementptr inbounds %struct.ssl_ctx_st, ptr %119, i32 0, i32 97
  %120 = load ptr, ptr %sigalg_list64, align 8
  call void @CRYPTO_free(ptr noundef %120, ptr noundef @.str, i32 noundef 4218)
  %121 = load ptr, ptr %a.addr, align 8
  %ssl_cert_info = getelementptr inbounds %struct.ssl_ctx_st, ptr %121, i32 0, i32 40
  %122 = load ptr, ptr %ssl_cert_info, align 8
  call void @CRYPTO_free(ptr noundef %122, ptr noundef @.str, i32 noundef 4219)
  %123 = load ptr, ptr %a.addr, align 8
  %sigalg_lookup_cache = getelementptr inbounds %struct.ssl_ctx_st, ptr %123, i32 0, i32 92
  %124 = load ptr, ptr %sigalg_lookup_cache, align 8
  call void @CRYPTO_free(ptr noundef %124, ptr noundef @.str, i32 noundef 4221)
  %125 = load ptr, ptr %a.addr, align 8
  %tls12_sigalgs = getelementptr inbounds %struct.ssl_ctx_st, ptr %125, i32 0, i32 93
  %126 = load ptr, ptr %tls12_sigalgs, align 8
  call void @CRYPTO_free(ptr noundef %126, ptr noundef @.str, i32 noundef 4222)
  %127 = load ptr, ptr %a.addr, align 8
  %client_cert_type = getelementptr inbounds %struct.ssl_ctx_st, ptr %127, i32 0, i32 104
  %128 = load ptr, ptr %client_cert_type, align 8
  call void @CRYPTO_free(ptr noundef %128, ptr noundef @.str, i32 noundef 4224)
  %129 = load ptr, ptr %a.addr, align 8
  %server_cert_type = getelementptr inbounds %struct.ssl_ctx_st, ptr %129, i32 0, i32 106
  %130 = load ptr, ptr %server_cert_type, align 8
  call void @CRYPTO_free(ptr noundef %130, ptr noundef @.str, i32 noundef 4225)
  %131 = load ptr, ptr %a.addr, align 8
  %lock = getelementptr inbounds %struct.ssl_ctx_st, ptr %131, i32 0, i32 70
  %132 = load ptr, ptr %lock, align 8
  call void @CRYPTO_THREAD_lock_free(ptr noundef %132)
  %133 = load ptr, ptr %a.addr, align 8
  %references65 = getelementptr inbounds %struct.ssl_ctx_st, ptr %133, i32 0, i32 16
  call void @CRYPTO_FREE_REF(ptr noundef %references65)
  %134 = load ptr, ptr %a.addr, align 8
  %propq = getelementptr inbounds %struct.ssl_ctx_st, ptr %134, i32 0, i32 86
  %135 = load ptr, ptr %propq, align 8
  call void @CRYPTO_free(ptr noundef %135, ptr noundef @.str, i32 noundef 4233)
  %136 = load ptr, ptr %a.addr, align 8
  call void @CRYPTO_free(ptr noundef %136, ptr noundef @.str, i32 noundef 4235)
  br label %return

return:                                           ; preds = %for.end63, %if.then2, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @ossl_ssl_connection_free(ptr noundef %ssl) #0 {
entry:
  %ssl.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %s, align 8
  %4 = load ptr, ptr %s, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %s, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 25
  %6 = load ptr, ptr %param, align 8
  call void @X509_VERIFY_PARAM_free(ptr noundef %6)
  %7 = load ptr, ptr %s, align 8
  %dane = getelementptr inbounds %struct.ssl_connection_st, ptr %7, i32 0, i32 26
  call void @dane_final(ptr noundef %dane)
  %8 = load ptr, ptr %s, align 8
  %call = call i32 @ssl_free_wbio_buffer(ptr noundef %8)
  %9 = load ptr, ptr %s, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 100
  call void @RECORD_LAYER_clear(ptr noundef %rlayer)
  %10 = load ptr, ptr %s, align 8
  %init_buf = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 15
  %11 = load ptr, ptr %init_buf, align 8
  call void @BUF_MEM_free(ptr noundef %11)
  %12 = load ptr, ptr %s, align 8
  %cipher_list = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 28
  %13 = load ptr, ptr %cipher_list, align 8
  %call7 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %13)
  call void @OPENSSL_sk_free(ptr noundef %call7)
  %14 = load ptr, ptr %s, align 8
  %cipher_list_by_id = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 29
  %15 = load ptr, ptr %cipher_list_by_id, align 8
  %call8 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %15)
  call void @OPENSSL_sk_free(ptr noundef %call8)
  %16 = load ptr, ptr %s, align 8
  %tls13_ciphersuites = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 30
  %17 = load ptr, ptr %tls13_ciphersuites, align 8
  %call9 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %17)
  call void @OPENSSL_sk_free(ptr noundef %call9)
  %18 = load ptr, ptr %s, align 8
  %peer_ciphers = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 27
  %19 = load ptr, ptr %peer_ciphers, align 8
  %call10 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %19)
  call void @OPENSSL_sk_free(ptr noundef %call10)
  %20 = load ptr, ptr %s, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 50
  %21 = load ptr, ptr %session, align 8
  %cmp11 = icmp ne ptr %21, null
  br i1 %cmp11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end
  %22 = load ptr, ptr %s, align 8
  %call13 = call i32 @ssl_clear_bad_session(ptr noundef %22)
  %23 = load ptr, ptr %s, align 8
  %session14 = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 50
  %24 = load ptr, ptr %session14, align 8
  call void @SSL_SESSION_free(ptr noundef %24)
  br label %if.end15

if.end15:                                         ; preds = %if.then12, %if.end
  %25 = load ptr, ptr %s, align 8
  %psksession = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 51
  %26 = load ptr, ptr %psksession, align 8
  call void @SSL_SESSION_free(ptr noundef %26)
  %27 = load ptr, ptr %s, align 8
  %psksession_id = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 52
  %28 = load ptr, ptr %psksession_id, align 8
  call void @CRYPTO_free(ptr noundef %28, ptr noundef @.str, i32 noundef 1456)
  %29 = load ptr, ptr %s, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %29, i32 0, i32 44
  %30 = load ptr, ptr %cert, align 8
  call void @ssl_cert_free(ptr noundef %30)
  %31 = load ptr, ptr %s, align 8
  %shared_sigalgs = getelementptr inbounds %struct.ssl_connection_st, ptr %31, i32 0, i32 116
  %32 = load ptr, ptr %shared_sigalgs, align 8
  call void @CRYPTO_free(ptr noundef %32, ptr noundef @.str, i32 noundef 1459)
  %33 = load ptr, ptr %s, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %33, i32 0, i32 80
  %hostname = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 3
  %34 = load ptr, ptr %hostname, align 8
  call void @CRYPTO_free(ptr noundef %34, ptr noundef @.str, i32 noundef 1462)
  %35 = load ptr, ptr %s, align 8
  %session_ctx = getelementptr inbounds %struct.ssl_connection_st, ptr %35, i32 0, i32 87
  %36 = load ptr, ptr %session_ctx, align 8
  call void @SSL_CTX_free(ptr noundef %36)
  %37 = load ptr, ptr %s, align 8
  %ext16 = getelementptr inbounds %struct.ssl_connection_st, ptr %37, i32 0, i32 80
  %ecpointformats = getelementptr inbounds %struct.anon.1, ptr %ext16, i32 0, i32 12
  %38 = load ptr, ptr %ecpointformats, align 8
  call void @CRYPTO_free(ptr noundef %38, ptr noundef @.str, i32 noundef 1464)
  %39 = load ptr, ptr %s, align 8
  %ext17 = getelementptr inbounds %struct.ssl_connection_st, ptr %39, i32 0, i32 80
  %peer_ecpointformats = getelementptr inbounds %struct.anon.1, ptr %ext17, i32 0, i32 14
  %40 = load ptr, ptr %peer_ecpointformats, align 8
  call void @CRYPTO_free(ptr noundef %40, ptr noundef @.str, i32 noundef 1465)
  %41 = load ptr, ptr %s, align 8
  %ext18 = getelementptr inbounds %struct.ssl_connection_st, ptr %41, i32 0, i32 80
  %supportedgroups = getelementptr inbounds %struct.anon.1, ptr %ext18, i32 0, i32 16
  %42 = load ptr, ptr %supportedgroups, align 8
  call void @CRYPTO_free(ptr noundef %42, ptr noundef @.str, i32 noundef 1466)
  %43 = load ptr, ptr %s, align 8
  %ext19 = getelementptr inbounds %struct.ssl_connection_st, ptr %43, i32 0, i32 80
  %peer_supportedgroups = getelementptr inbounds %struct.anon.1, ptr %ext19, i32 0, i32 18
  %44 = load ptr, ptr %peer_supportedgroups, align 8
  call void @CRYPTO_free(ptr noundef %44, ptr noundef @.str, i32 noundef 1467)
  %45 = load ptr, ptr %s, align 8
  %ext20 = getelementptr inbounds %struct.ssl_connection_st, ptr %45, i32 0, i32 80
  %ocsp = getelementptr inbounds %struct.anon.1, ptr %ext20, i32 0, i32 8
  %exts = getelementptr inbounds %struct.anon.2, ptr %ocsp, i32 0, i32 1
  %46 = load ptr, ptr %exts, align 8
  %call21 = call ptr @ossl_check_X509_EXTENSION_sk_type(ptr noundef %46)
  %call22 = call ptr @ossl_check_X509_EXTENSION_freefunc_type(ptr noundef @X509_EXTENSION_free)
  call void @OPENSSL_sk_pop_free(ptr noundef %call21, ptr noundef %call22)
  %47 = load ptr, ptr %s, align 8
  %ext23 = getelementptr inbounds %struct.ssl_connection_st, ptr %47, i32 0, i32 80
  %ocsp24 = getelementptr inbounds %struct.anon.1, ptr %ext23, i32 0, i32 8
  %ids = getelementptr inbounds %struct.anon.2, ptr %ocsp24, i32 0, i32 0
  %48 = load ptr, ptr %ids, align 8
  %call25 = call ptr @ossl_check_OCSP_RESPID_sk_type(ptr noundef %48)
  %call26 = call ptr @ossl_check_OCSP_RESPID_freefunc_type(ptr noundef @OCSP_RESPID_free)
  call void @OPENSSL_sk_pop_free(ptr noundef %call25, ptr noundef %call26)
  %49 = load ptr, ptr %s, align 8
  %scts = getelementptr inbounds %struct.ssl_connection_st, ptr %49, i32 0, i32 85
  %50 = load ptr, ptr %scts, align 8
  call void @SCT_LIST_free(ptr noundef %50)
  %51 = load ptr, ptr %s, align 8
  %ext27 = getelementptr inbounds %struct.ssl_connection_st, ptr %51, i32 0, i32 80
  %scts28 = getelementptr inbounds %struct.anon.1, ptr %ext27, i32 0, i32 5
  %52 = load ptr, ptr %scts28, align 8
  call void @CRYPTO_free(ptr noundef %52, ptr noundef @.str, i32 noundef 1474)
  %53 = load ptr, ptr %s, align 8
  %ext29 = getelementptr inbounds %struct.ssl_connection_st, ptr %53, i32 0, i32 80
  %ocsp30 = getelementptr inbounds %struct.anon.1, ptr %ext29, i32 0, i32 8
  %resp = getelementptr inbounds %struct.anon.2, ptr %ocsp30, i32 0, i32 2
  %54 = load ptr, ptr %resp, align 8
  call void @CRYPTO_free(ptr noundef %54, ptr noundef @.str, i32 noundef 1476)
  %55 = load ptr, ptr %s, align 8
  %ext31 = getelementptr inbounds %struct.ssl_connection_st, ptr %55, i32 0, i32 80
  %alpn = getelementptr inbounds %struct.anon.1, ptr %ext31, i32 0, i32 24
  %56 = load ptr, ptr %alpn, align 8
  call void @CRYPTO_free(ptr noundef %56, ptr noundef @.str, i32 noundef 1477)
  %57 = load ptr, ptr %s, align 8
  %ext32 = getelementptr inbounds %struct.ssl_connection_st, ptr %57, i32 0, i32 80
  %tls13_cookie = getelementptr inbounds %struct.anon.1, ptr %ext32, i32 0, i32 32
  %58 = load ptr, ptr %tls13_cookie, align 8
  call void @CRYPTO_free(ptr noundef %58, ptr noundef @.str, i32 noundef 1478)
  %59 = load ptr, ptr %s, align 8
  %clienthello = getelementptr inbounds %struct.ssl_connection_st, ptr %59, i32 0, i32 81
  %60 = load ptr, ptr %clienthello, align 8
  %cmp33 = icmp ne ptr %60, null
  br i1 %cmp33, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end15
  %61 = load ptr, ptr %s, align 8
  %clienthello35 = getelementptr inbounds %struct.ssl_connection_st, ptr %61, i32 0, i32 81
  %62 = load ptr, ptr %clienthello35, align 8
  %pre_proc_exts = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %62, i32 0, i32 12
  %63 = load ptr, ptr %pre_proc_exts, align 8
  call void @CRYPTO_free(ptr noundef %63, ptr noundef @.str, i32 noundef 1480)
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end15
  %64 = load ptr, ptr %s, align 8
  %clienthello37 = getelementptr inbounds %struct.ssl_connection_st, ptr %64, i32 0, i32 81
  %65 = load ptr, ptr %clienthello37, align 8
  call void @CRYPTO_free(ptr noundef %65, ptr noundef @.str, i32 noundef 1481)
  %66 = load ptr, ptr %s, align 8
  %pha_context = getelementptr inbounds %struct.ssl_connection_st, ptr %66, i32 0, i32 94
  %67 = load ptr, ptr %pha_context, align 8
  call void @CRYPTO_free(ptr noundef %67, ptr noundef @.str, i32 noundef 1482)
  %68 = load ptr, ptr %s, align 8
  %pha_dgst = getelementptr inbounds %struct.ssl_connection_st, ptr %68, i32 0, i32 97
  %69 = load ptr, ptr %pha_dgst, align 8
  call void @EVP_MD_CTX_free(ptr noundef %69)
  %70 = load ptr, ptr %s, align 8
  %ca_names = getelementptr inbounds %struct.ssl_connection_st, ptr %70, i32 0, i32 68
  %71 = load ptr, ptr %ca_names, align 8
  %call38 = call ptr @ossl_check_X509_NAME_sk_type(ptr noundef %71)
  %call39 = call ptr @ossl_check_X509_NAME_freefunc_type(ptr noundef @X509_NAME_free)
  call void @OPENSSL_sk_pop_free(ptr noundef %call38, ptr noundef %call39)
  %72 = load ptr, ptr %s, align 8
  %client_ca_names = getelementptr inbounds %struct.ssl_connection_st, ptr %72, i32 0, i32 69
  %73 = load ptr, ptr %client_ca_names, align 8
  %call40 = call ptr @ossl_check_X509_NAME_sk_type(ptr noundef %73)
  %call41 = call ptr @ossl_check_X509_NAME_freefunc_type(ptr noundef @X509_NAME_free)
  call void @OPENSSL_sk_pop_free(ptr noundef %call40, ptr noundef %call41)
  %74 = load ptr, ptr %s, align 8
  %client_cert_type = getelementptr inbounds %struct.ssl_connection_st, ptr %74, i32 0, i32 118
  %75 = load ptr, ptr %client_cert_type, align 8
  call void @CRYPTO_free(ptr noundef %75, ptr noundef @.str, i32 noundef 1488)
  %76 = load ptr, ptr %s, align 8
  %server_cert_type = getelementptr inbounds %struct.ssl_connection_st, ptr %76, i32 0, i32 120
  %77 = load ptr, ptr %server_cert_type, align 8
  call void @CRYPTO_free(ptr noundef %77, ptr noundef @.str, i32 noundef 1489)
  %78 = load ptr, ptr %s, align 8
  %verified_chain = getelementptr inbounds %struct.ssl_connection_st, ptr %78, i32 0, i32 66
  %79 = load ptr, ptr %verified_chain, align 8
  call void @OSSL_STACK_OF_X509_free(ptr noundef %79)
  %80 = load ptr, ptr %ssl.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %80, i32 0, i32 3
  %81 = load ptr, ptr %method, align 8
  %cmp42 = icmp ne ptr %81, null
  br i1 %cmp42, label %if.then43, label %if.end45

if.then43:                                        ; preds = %if.end36
  %82 = load ptr, ptr %ssl.addr, align 8
  %method44 = getelementptr inbounds %struct.ssl_st, ptr %82, i32 0, i32 3
  %83 = load ptr, ptr %method44, align 8
  %ssl_deinit = getelementptr inbounds %struct.ssl_method_st, ptr %83, i32 0, i32 8
  %84 = load ptr, ptr %ssl_deinit, align 8
  %85 = load ptr, ptr %ssl.addr, align 8
  call void %84(ptr noundef %85)
  br label %if.end45

if.end45:                                         ; preds = %if.then43, %if.end36
  %86 = load ptr, ptr %s, align 8
  %waitctx = getelementptr inbounds %struct.ssl_connection_st, ptr %86, i32 0, i32 104
  %87 = load ptr, ptr %waitctx, align 8
  call void @ASYNC_WAIT_CTX_free(ptr noundef %87)
  %88 = load ptr, ptr %s, align 8
  %ext46 = getelementptr inbounds %struct.ssl_connection_st, ptr %88, i32 0, i32 80
  %npn = getelementptr inbounds %struct.anon.1, ptr %ext46, i32 0, i32 26
  %89 = load ptr, ptr %npn, align 8
  call void @CRYPTO_free(ptr noundef %89, ptr noundef @.str, i32 noundef 1499)
  %90 = load ptr, ptr %s, align 8
  %srtp_profiles = getelementptr inbounds %struct.ssl_connection_st, ptr %90, i32 0, i32 88
  %91 = load ptr, ptr %srtp_profiles, align 8
  %call47 = call ptr @ossl_check_SRTP_PROTECTION_PROFILE_sk_type(ptr noundef %91)
  call void @OPENSSL_sk_free(ptr noundef %call47)
  %92 = load ptr, ptr %s, align 8
  %wbio = getelementptr inbounds %struct.ssl_connection_st, ptr %92, i32 0, i32 3
  %93 = load ptr, ptr %wbio, align 8
  call void @BIO_free_all(ptr noundef %93)
  %94 = load ptr, ptr %s, align 8
  %wbio48 = getelementptr inbounds %struct.ssl_connection_st, ptr %94, i32 0, i32 3
  store ptr null, ptr %wbio48, align 8
  %95 = load ptr, ptr %s, align 8
  %rbio = getelementptr inbounds %struct.ssl_connection_st, ptr %95, i32 0, i32 2
  %96 = load ptr, ptr %rbio, align 8
  call void @BIO_free_all(ptr noundef %96)
  %97 = load ptr, ptr %s, align 8
  %rbio49 = getelementptr inbounds %struct.ssl_connection_st, ptr %97, i32 0, i32 2
  store ptr null, ptr %rbio49, align 8
  %98 = load ptr, ptr %s, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %98, i32 0, i32 20
  %tmp = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 14
  %valid_flags = getelementptr inbounds %struct.anon.0, ptr %tmp, i32 0, i32 33
  %99 = load ptr, ptr %valid_flags, align 8
  call void @CRYPTO_free(ptr noundef %99, ptr noundef @.str, i32 noundef 1516)
  br label %return

return:                                           ; preds = %if.end45, %if.then
  ret void
}

declare void @X509_VERIFY_PARAM_free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal void @dane_final(ptr noundef %dane) #0 {
entry:
  %dane.addr = alloca ptr, align 8
  store ptr %dane, ptr %dane.addr, align 8
  %0 = load ptr, ptr %dane.addr, align 8
  %trecs = getelementptr inbounds %struct.ssl_dane_st, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %trecs, align 8
  call void @sk_danetls_record_pop_free(ptr noundef %1, ptr noundef @tlsa_free)
  %2 = load ptr, ptr %dane.addr, align 8
  %trecs1 = getelementptr inbounds %struct.ssl_dane_st, ptr %2, i32 0, i32 1
  store ptr null, ptr %trecs1, align 8
  %3 = load ptr, ptr %dane.addr, align 8
  %certs = getelementptr inbounds %struct.ssl_dane_st, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %certs, align 8
  call void @OSSL_STACK_OF_X509_free(ptr noundef %4)
  %5 = load ptr, ptr %dane.addr, align 8
  %certs2 = getelementptr inbounds %struct.ssl_dane_st, ptr %5, i32 0, i32 2
  store ptr null, ptr %certs2, align 8
  %6 = load ptr, ptr %dane.addr, align 8
  %mcert = getelementptr inbounds %struct.ssl_dane_st, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %mcert, align 8
  call void @X509_free(ptr noundef %7)
  %8 = load ptr, ptr %dane.addr, align 8
  %mcert3 = getelementptr inbounds %struct.ssl_dane_st, ptr %8, i32 0, i32 4
  store ptr null, ptr %mcert3, align 8
  %9 = load ptr, ptr %dane.addr, align 8
  %mtlsa = getelementptr inbounds %struct.ssl_dane_st, ptr %9, i32 0, i32 3
  store ptr null, ptr %mtlsa, align 8
  %10 = load ptr, ptr %dane.addr, align 8
  %mdpth = getelementptr inbounds %struct.ssl_dane_st, ptr %10, i32 0, i32 6
  store i32 -1, ptr %mdpth, align 4
  %11 = load ptr, ptr %dane.addr, align 8
  %pdpth = getelementptr inbounds %struct.ssl_dane_st, ptr %11, i32 0, i32 7
  store i32 -1, ptr %pdpth, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @ssl_free_wbio_buffer(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %bbio = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %bbio, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %wbio = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %wbio, align 8
  %call = call ptr @BIO_pop(ptr noundef %3)
  %4 = load ptr, ptr %s.addr, align 8
  %wbio1 = getelementptr inbounds %struct.ssl_connection_st, ptr %4, i32 0, i32 3
  store ptr %call, ptr %wbio1, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 100
  %wrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 4
  %6 = load ptr, ptr %wrlmethod, align 8
  %set1_bio = getelementptr inbounds %struct.ossl_record_method_st, ptr %6, i32 0, i32 11
  %7 = load ptr, ptr %set1_bio, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %rlayer2 = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 100
  %wrl = getelementptr inbounds %struct.record_layer_st, ptr %rlayer2, i32 0, i32 6
  %9 = load ptr, ptr %wrl, align 8
  %10 = load ptr, ptr %s.addr, align 8
  %wbio3 = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %wbio3, align 8
  %call4 = call i32 %7(ptr noundef %9, ptr noundef %11)
  %12 = load ptr, ptr %s.addr, align 8
  %bbio5 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 4
  %13 = load ptr, ptr %bbio5, align 8
  %call6 = call i32 @BIO_free(ptr noundef %13)
  %14 = load ptr, ptr %s.addr, align 8
  %bbio7 = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 4
  store ptr null, ptr %bbio7, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

declare void @OPENSSL_sk_free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

declare void @ssl_cert_free(ptr noundef) #1

declare void @OPENSSL_sk_pop_free(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_X509_EXTENSION_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_X509_EXTENSION_freefunc_type(ptr noundef %fr) #0 {
entry:
  %fr.addr = alloca ptr, align 8
  store ptr %fr, ptr %fr.addr, align 8
  %0 = load ptr, ptr %fr.addr, align 8
  ret ptr %0
}

declare void @X509_EXTENSION_free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_OCSP_RESPID_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_OCSP_RESPID_freefunc_type(ptr noundef %fr) #0 {
entry:
  %fr.addr = alloca ptr, align 8
  store ptr %fr, ptr %fr.addr, align 8
  %0 = load ptr, ptr %fr.addr, align 8
  ret ptr %0
}

declare void @OCSP_RESPID_free(ptr noundef) #1

declare void @SCT_LIST_free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_X509_NAME_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_X509_NAME_freefunc_type(ptr noundef %fr) #0 {
entry:
  %fr.addr = alloca ptr, align 8
  store ptr %fr, ptr %fr.addr, align 8
  %0 = load ptr, ptr %fr.addr, align 8
  ret ptr %0
}

declare void @X509_NAME_free(ptr noundef) #1

declare void @OSSL_STACK_OF_X509_free(ptr noundef) #1

declare void @ASYNC_WAIT_CTX_free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_SRTP_PROTECTION_PROFILE_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

declare void @BIO_free_all(ptr noundef) #1

; Function Attrs: nounwind uwtable
define void @SSL_set0_rbio(ptr noundef %s, ptr noundef %rbio) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %rbio.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %rbio, ptr %rbio.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load ptr, ptr %rbio.addr, align 8
  call void @ossl_quic_conn_set0_net_rbio(ptr noundef %13, ptr noundef %14)
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %15 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %15, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  br label %return

if.end19:                                         ; preds = %if.end
  %16 = load ptr, ptr %sc, align 8
  %rbio20 = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %rbio20, align 8
  call void @BIO_free_all(ptr noundef %17)
  %18 = load ptr, ptr %rbio.addr, align 8
  %19 = load ptr, ptr %sc, align 8
  %rbio21 = getelementptr inbounds %struct.ssl_connection_st, ptr %19, i32 0, i32 2
  store ptr %18, ptr %rbio21, align 8
  %20 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 100
  %rrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 3
  %21 = load ptr, ptr %rrlmethod, align 8
  %set1_bio = getelementptr inbounds %struct.ossl_record_method_st, ptr %21, i32 0, i32 11
  %22 = load ptr, ptr %set1_bio, align 8
  %23 = load ptr, ptr %sc, align 8
  %rlayer22 = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 100
  %rrl = getelementptr inbounds %struct.record_layer_st, ptr %rlayer22, i32 0, i32 5
  %24 = load ptr, ptr %rrl, align 8
  %25 = load ptr, ptr %sc, align 8
  %rbio23 = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 2
  %26 = load ptr, ptr %rbio23, align 8
  %call = call i32 %22(ptr noundef %24, ptr noundef %26)
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then
  ret void
}

declare void @ossl_quic_conn_set0_net_rbio(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define void @SSL_set0_wbio(ptr noundef %s, ptr noundef %wbio) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %wbio.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %wbio, ptr %wbio.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load ptr, ptr %wbio.addr, align 8
  call void @ossl_quic_conn_set0_net_wbio(ptr noundef %13, ptr noundef %14)
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %15 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %15, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  br label %return

if.end19:                                         ; preds = %if.end
  %16 = load ptr, ptr %sc, align 8
  %bbio = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 4
  %17 = load ptr, ptr %bbio, align 8
  %cmp20 = icmp ne ptr %17, null
  br i1 %cmp20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end19
  %18 = load ptr, ptr %sc, align 8
  %wbio22 = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 3
  %19 = load ptr, ptr %wbio22, align 8
  %call = call ptr @BIO_pop(ptr noundef %19)
  %20 = load ptr, ptr %sc, align 8
  %wbio23 = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 3
  store ptr %call, ptr %wbio23, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then21, %if.end19
  %21 = load ptr, ptr %sc, align 8
  %wbio25 = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 3
  %22 = load ptr, ptr %wbio25, align 8
  call void @BIO_free_all(ptr noundef %22)
  %23 = load ptr, ptr %wbio.addr, align 8
  %24 = load ptr, ptr %sc, align 8
  %wbio26 = getelementptr inbounds %struct.ssl_connection_st, ptr %24, i32 0, i32 3
  store ptr %23, ptr %wbio26, align 8
  %25 = load ptr, ptr %sc, align 8
  %bbio27 = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 4
  %26 = load ptr, ptr %bbio27, align 8
  %cmp28 = icmp ne ptr %26, null
  br i1 %cmp28, label %if.then29, label %if.end34

if.then29:                                        ; preds = %if.end24
  %27 = load ptr, ptr %sc, align 8
  %bbio30 = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 4
  %28 = load ptr, ptr %bbio30, align 8
  %29 = load ptr, ptr %sc, align 8
  %wbio31 = getelementptr inbounds %struct.ssl_connection_st, ptr %29, i32 0, i32 3
  %30 = load ptr, ptr %wbio31, align 8
  %call32 = call ptr @BIO_push(ptr noundef %28, ptr noundef %30)
  %31 = load ptr, ptr %sc, align 8
  %wbio33 = getelementptr inbounds %struct.ssl_connection_st, ptr %31, i32 0, i32 3
  store ptr %call32, ptr %wbio33, align 8
  br label %if.end34

if.end34:                                         ; preds = %if.then29, %if.end24
  %32 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %32, i32 0, i32 100
  %wrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 4
  %33 = load ptr, ptr %wrlmethod, align 8
  %set1_bio = getelementptr inbounds %struct.ossl_record_method_st, ptr %33, i32 0, i32 11
  %34 = load ptr, ptr %set1_bio, align 8
  %35 = load ptr, ptr %sc, align 8
  %rlayer35 = getelementptr inbounds %struct.ssl_connection_st, ptr %35, i32 0, i32 100
  %wrl = getelementptr inbounds %struct.record_layer_st, ptr %rlayer35, i32 0, i32 6
  %36 = load ptr, ptr %wrl, align 8
  %37 = load ptr, ptr %sc, align 8
  %wbio36 = getelementptr inbounds %struct.ssl_connection_st, ptr %37, i32 0, i32 3
  %38 = load ptr, ptr %wbio36, align 8
  %call37 = call i32 %34(ptr noundef %36, ptr noundef %38)
  br label %return

return:                                           ; preds = %if.end34, %if.then18, %if.then
  ret void
}

declare void @ossl_quic_conn_set0_net_wbio(ptr noundef, ptr noundef) #1

declare ptr @BIO_pop(ptr noundef) #1

declare ptr @BIO_push(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define void @SSL_set_bio(ptr noundef %s, ptr noundef %rbio, ptr noundef %wbio) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %rbio.addr = alloca ptr, align 8
  %wbio.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %rbio, ptr %rbio.addr, align 8
  store ptr %wbio, ptr %wbio.addr, align 8
  %0 = load ptr, ptr %rbio.addr, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get_rbio(ptr noundef %1)
  %cmp = icmp eq ptr %0, %call
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %wbio.addr, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %call1 = call ptr @SSL_get_wbio(ptr noundef %3)
  %cmp2 = icmp eq ptr %2, %call1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %4 = load ptr, ptr %rbio.addr, align 8
  %cmp3 = icmp ne ptr %4, null
  br i1 %cmp3, label %land.lhs.true4, label %if.end8

land.lhs.true4:                                   ; preds = %if.end
  %5 = load ptr, ptr %rbio.addr, align 8
  %6 = load ptr, ptr %wbio.addr, align 8
  %cmp5 = icmp eq ptr %5, %6
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %land.lhs.true4
  %7 = load ptr, ptr %rbio.addr, align 8
  %call7 = call i32 @BIO_up_ref(ptr noundef %7)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %land.lhs.true4, %if.end
  %8 = load ptr, ptr %rbio.addr, align 8
  %9 = load ptr, ptr %s.addr, align 8
  %call9 = call ptr @SSL_get_rbio(ptr noundef %9)
  %cmp10 = icmp eq ptr %8, %call9
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load ptr, ptr %wbio.addr, align 8
  call void @SSL_set0_wbio(ptr noundef %10, ptr noundef %11)
  br label %return

if.end12:                                         ; preds = %if.end8
  %12 = load ptr, ptr %wbio.addr, align 8
  %13 = load ptr, ptr %s.addr, align 8
  %call13 = call ptr @SSL_get_wbio(ptr noundef %13)
  %cmp14 = icmp eq ptr %12, %call13
  br i1 %cmp14, label %land.lhs.true15, label %if.end20

land.lhs.true15:                                  ; preds = %if.end12
  %14 = load ptr, ptr %s.addr, align 8
  %call16 = call ptr @SSL_get_rbio(ptr noundef %14)
  %15 = load ptr, ptr %s.addr, align 8
  %call17 = call ptr @SSL_get_wbio(ptr noundef %15)
  %cmp18 = icmp ne ptr %call16, %call17
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %land.lhs.true15
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load ptr, ptr %rbio.addr, align 8
  call void @SSL_set0_rbio(ptr noundef %16, ptr noundef %17)
  br label %return

if.end20:                                         ; preds = %land.lhs.true15, %if.end12
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load ptr, ptr %rbio.addr, align 8
  call void @SSL_set0_rbio(ptr noundef %18, ptr noundef %19)
  %20 = load ptr, ptr %s.addr, align 8
  %21 = load ptr, ptr %wbio.addr, align 8
  call void @SSL_set0_wbio(ptr noundef %20, ptr noundef %21)
  br label %return

return:                                           ; preds = %if.end20, %if.then19, %if.then11, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_rbio(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %call = call ptr @ossl_quic_conn_get_net_rbio(ptr noundef %13)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %14 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %14, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.end
  %15 = load ptr, ptr %sc, align 8
  %rbio = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 2
  %16 = load ptr, ptr %rbio, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_wbio(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %call = call ptr @ossl_quic_conn_get_net_wbio(ptr noundef %13)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %14 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %14, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.end
  %15 = load ptr, ptr %sc, align 8
  %bbio = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 4
  %16 = load ptr, ptr %bbio, align 8
  %cmp20 = icmp ne ptr %16, null
  br i1 %cmp20, label %if.then21, label %if.end24

if.then21:                                        ; preds = %if.end19
  %17 = load ptr, ptr %sc, align 8
  %bbio22 = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 4
  %18 = load ptr, ptr %bbio22, align 8
  %call23 = call ptr @BIO_next(ptr noundef %18)
  store ptr %call23, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %if.end19
  %19 = load ptr, ptr %sc, align 8
  %wbio = getelementptr inbounds %struct.ssl_connection_st, ptr %19, i32 0, i32 3
  %20 = load ptr, ptr %wbio, align 8
  store ptr %20, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end24, %if.then21, %if.then18, %if.then
  %21 = load ptr, ptr %retval, align 8
  ret ptr %21
}

declare i32 @BIO_up_ref(ptr noundef) #1

declare ptr @ossl_quic_conn_get_net_rbio(ptr noundef) #1

declare ptr @ossl_quic_conn_get_net_wbio(ptr noundef) #1

declare ptr @BIO_next(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_fd(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call i32 @SSL_get_rfd(ptr noundef %0)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_rfd(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %b = alloca ptr, align 8
  %r = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 -1, ptr %ret, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get_rbio(ptr noundef %0)
  store ptr %call, ptr %b, align 8
  %1 = load ptr, ptr %b, align 8
  %call1 = call ptr @BIO_find_type(ptr noundef %1, i32 noundef 256)
  store ptr %call1, ptr %r, align 8
  %2 = load ptr, ptr %r, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %r, align 8
  %call2 = call i64 @BIO_ctrl(ptr noundef %3, i32 noundef 105, i64 noundef 0, ptr noundef %ret)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i32, ptr %ret, align 4
  ret i32 %4
}

declare ptr @BIO_find_type(ptr noundef, i32 noundef) #1

declare i64 @BIO_ctrl(ptr noundef, i32 noundef, i64 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_wfd(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %b = alloca ptr, align 8
  %r = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 -1, ptr %ret, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get_wbio(ptr noundef %0)
  store ptr %call, ptr %b, align 8
  %1 = load ptr, ptr %b, align 8
  %call1 = call ptr @BIO_find_type(ptr noundef %1, i32 noundef 256)
  store ptr %call1, ptr %r, align 8
  %2 = load ptr, ptr %r, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %r, align 8
  %call2 = call i64 @BIO_ctrl(ptr noundef %3, i32 noundef 105, i64 noundef 0, ptr noundef %ret)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i32, ptr %ret, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_fd(ptr noundef %s, i32 noundef %fd) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %ret = alloca i32, align 4
  %bio = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i32 0, ptr %ret, align 4
  store ptr null, ptr %bio, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  %cmp = icmp eq i32 %1, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1691, ptr noundef @__func__.SSL_set_fd)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 356, ptr noundef null)
  br label %err

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %call = call ptr @fd_method(ptr noundef %2)
  %call1 = call ptr @BIO_new(ptr noundef %call)
  store ptr %call1, ptr %bio, align 8
  %3 = load ptr, ptr %bio, align 8
  %cmp2 = icmp eq ptr %3, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1698, ptr noundef @__func__.SSL_set_fd)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524295, ptr noundef null)
  br label %err

if.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %bio, align 8
  %5 = load i32, ptr %fd.addr, align 4
  %call5 = call i64 @BIO_int_ctrl(ptr noundef %4, i32 noundef 104, i64 noundef 0, i32 noundef %5)
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load ptr, ptr %bio, align 8
  %8 = load ptr, ptr %bio, align 8
  call void @SSL_set_bio(ptr noundef %6, ptr noundef %7, ptr noundef %8)
  store i32 1, ptr %ret, align 4
  br label %err

err:                                              ; preds = %if.end4, %if.then3, %if.then
  %9 = load i32, ptr %ret, align 4
  ret i32 %9
}

declare ptr @BIO_new(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @fd_method(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %call = call ptr @BIO_s_datagram()
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %call4 = call ptr @BIO_s_socket()
  store ptr %call4, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load ptr, ptr %retval, align 8
  ret ptr %5
}

declare i64 @BIO_int_ctrl(ptr noundef, i32 noundef, i64 noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set_wfd(ptr noundef %s, i32 noundef %fd) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %rbio = alloca ptr, align 8
  %desired_type = alloca i32, align 4
  %bio = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get_rbio(ptr noundef %0)
  store ptr %call, ptr %rbio, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %3, 1
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %4 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %5, 2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %6 = phi i1 [ true, %land.rhs ], [ %cmp3, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %7 = phi i1 [ false, %entry ], [ %6, %lor.end ]
  %cond = select i1 %7, i32 1301, i32 1285
  store i32 %cond, ptr %desired_type, align 4
  %8 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %9, 2
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1723, ptr noundef @__func__.SSL_set_wfd)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 356, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.end
  %10 = load ptr, ptr %rbio, align 8
  %cmp6 = icmp eq ptr %10, null
  br i1 %cmp6, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %11 = load ptr, ptr %rbio, align 8
  %call7 = call i32 @BIO_method_type(ptr noundef %11)
  %12 = load i32, ptr %desired_type, align 4
  %cmp8 = icmp ne i32 %call7, %12
  br i1 %cmp8, label %if.then13, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %13 = load ptr, ptr %rbio, align 8
  %call10 = call i64 @BIO_ctrl(ptr noundef %13, i32 noundef 105, i64 noundef 0, ptr noundef null)
  %conv = trunc i64 %call10 to i32
  %14 = load i32, ptr %fd.addr, align 4
  %cmp11 = icmp ne i32 %conv, %14
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %lor.lhs.false9, %lor.lhs.false, %if.end
  %15 = load ptr, ptr %s.addr, align 8
  %call14 = call ptr @fd_method(ptr noundef %15)
  %call15 = call ptr @BIO_new(ptr noundef %call14)
  store ptr %call15, ptr %bio, align 8
  %16 = load ptr, ptr %bio, align 8
  %cmp16 = icmp eq ptr %16, null
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then13
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1732, ptr noundef @__func__.SSL_set_wfd)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524295, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.then13
  %17 = load ptr, ptr %bio, align 8
  %18 = load i32, ptr %fd.addr, align 4
  %call20 = call i64 @BIO_int_ctrl(ptr noundef %17, i32 noundef 104, i64 noundef 0, i32 noundef %18)
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load ptr, ptr %bio, align 8
  call void @SSL_set0_wbio(ptr noundef %19, ptr noundef %20)
  br label %if.end22

if.else:                                          ; preds = %lor.lhs.false9
  %21 = load ptr, ptr %rbio, align 8
  %call21 = call i32 @BIO_up_ref(ptr noundef %21)
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load ptr, ptr %rbio, align 8
  call void @SSL_set0_wbio(ptr noundef %22, ptr noundef %23)
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.end19
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end22, %if.then18, %if.then
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

declare i32 @BIO_method_type(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set_rfd(ptr noundef %s, i32 noundef %fd) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %wbio = alloca ptr, align 8
  %desired_type = alloca i32, align 4
  %bio = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get_wbio(ptr noundef %0)
  store ptr %call, ptr %wbio, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %3, 1
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %4 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %5, 2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %6 = phi i1 [ true, %land.rhs ], [ %cmp3, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %entry
  %7 = phi i1 [ false, %entry ], [ %6, %lor.end ]
  %cond = select i1 %7, i32 1301, i32 1285
  store i32 %cond, ptr %desired_type, align 4
  %8 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %9, 2
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1759, ptr noundef @__func__.SSL_set_rfd)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 356, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.end
  %10 = load ptr, ptr %wbio, align 8
  %cmp6 = icmp eq ptr %10, null
  br i1 %cmp6, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %11 = load ptr, ptr %wbio, align 8
  %call7 = call i32 @BIO_method_type(ptr noundef %11)
  %12 = load i32, ptr %desired_type, align 4
  %cmp8 = icmp ne i32 %call7, %12
  br i1 %cmp8, label %if.then13, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %13 = load ptr, ptr %wbio, align 8
  %call10 = call i64 @BIO_ctrl(ptr noundef %13, i32 noundef 105, i64 noundef 0, ptr noundef null)
  %conv = trunc i64 %call10 to i32
  %14 = load i32, ptr %fd.addr, align 4
  %cmp11 = icmp ne i32 %conv, %14
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %lor.lhs.false9, %lor.lhs.false, %if.end
  %15 = load ptr, ptr %s.addr, align 8
  %call14 = call ptr @fd_method(ptr noundef %15)
  %call15 = call ptr @BIO_new(ptr noundef %call14)
  store ptr %call15, ptr %bio, align 8
  %16 = load ptr, ptr %bio, align 8
  %cmp16 = icmp eq ptr %16, null
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then13
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 1768, ptr noundef @__func__.SSL_set_rfd)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524295, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.then13
  %17 = load ptr, ptr %bio, align 8
  %18 = load i32, ptr %fd.addr, align 4
  %call20 = call i64 @BIO_int_ctrl(ptr noundef %17, i32 noundef 104, i64 noundef 0, i32 noundef %18)
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load ptr, ptr %bio, align 8
  call void @SSL_set0_rbio(ptr noundef %19, ptr noundef %20)
  br label %if.end22

if.else:                                          ; preds = %lor.lhs.false9
  %21 = load ptr, ptr %wbio, align 8
  %call21 = call i32 @BIO_up_ref(ptr noundef %21)
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load ptr, ptr %wbio, align 8
  call void @SSL_set0_rbio(ptr noundef %22, ptr noundef %23)
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.end19
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end22, %if.then18, %if.then
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define i64 @SSL_get_finished(ptr noundef %s, ptr noundef %buf, i64 noundef %count) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %ret = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 0, ptr %ret, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 20
  %tmp = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 14
  %finish_md_len = getelementptr inbounds %struct.anon.0, ptr %tmp, i32 0, i32 1
  %10 = load i64, ptr %finish_md_len, align 8
  store i64 %10, ptr %ret, align 8
  %11 = load i64, ptr %count.addr, align 8
  %12 = load i64, ptr %ret, align 8
  %cmp13 = icmp ugt i64 %11, %12
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  %13 = load i64, ptr %ret, align 8
  store i64 %13, ptr %count.addr, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end
  %14 = load ptr, ptr %buf.addr, align 8
  %15 = load ptr, ptr %sc, align 8
  %s316 = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 20
  %tmp17 = getelementptr inbounds %struct.anon, ptr %s316, i32 0, i32 14
  %finish_md = getelementptr inbounds %struct.anon.0, ptr %tmp17, i32 0, i32 0
  %arraydecay = getelementptr inbounds [128 x i8], ptr %finish_md, i64 0, i64 0
  %16 = load i64, ptr %count.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %14, ptr align 8 %arraydecay, i64 %16, i1 false)
  %17 = load i64, ptr %ret, align 8
  store i64 %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.then
  %18 = load i64, ptr %retval, align 8
  ret i64 %18
}

; Function Attrs: nounwind uwtable
define i64 @SSL_get_peer_finished(ptr noundef %s, ptr noundef %buf, i64 noundef %count) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %count.addr = alloca i64, align 8
  %ret = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %count, ptr %count.addr, align 8
  store i64 0, ptr %ret, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 20
  %tmp = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 14
  %peer_finish_md_len = getelementptr inbounds %struct.anon.0, ptr %tmp, i32 0, i32 3
  %10 = load i64, ptr %peer_finish_md_len, align 8
  store i64 %10, ptr %ret, align 8
  %11 = load i64, ptr %count.addr, align 8
  %12 = load i64, ptr %ret, align 8
  %cmp13 = icmp ugt i64 %11, %12
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  %13 = load i64, ptr %ret, align 8
  store i64 %13, ptr %count.addr, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end
  %14 = load ptr, ptr %buf.addr, align 8
  %15 = load ptr, ptr %sc, align 8
  %s316 = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 20
  %tmp17 = getelementptr inbounds %struct.anon, ptr %s316, i32 0, i32 14
  %peer_finish_md = getelementptr inbounds %struct.anon.0, ptr %tmp17, i32 0, i32 2
  %arraydecay = getelementptr inbounds [128 x i8], ptr %peer_finish_md, i64 0, i64 0
  %16 = load i64, ptr %count.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %14, ptr align 8 %arraydecay, i64 %16, i1 false)
  %17 = load i64, ptr %ret, align 8
  store i64 %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end15, %if.then
  %18 = load i64, ptr %retval, align 8
  ret i64 %18
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_verify_mode(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %verify_mode = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 57
  %10 = load i32, ptr %verify_mode, align 8
  store i32 %10, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_verify_depth(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 25
  %10 = load ptr, ptr %param, align 8
  %call = call i32 @X509_VERIFY_PARAM_get_depth(ptr noundef %10)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

declare i32 @X509_VERIFY_PARAM_get_depth(ptr noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_get_verify_callback(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %verify_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 58
  %10 = load ptr, ptr %verify_callback, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_get_verify_mode(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %verify_mode = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 44
  %1 = load i32, ptr %verify_mode, align 8
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_get_verify_depth(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %param = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 49
  %1 = load ptr, ptr %param, align 8
  %call = call i32 @X509_VERIFY_PARAM_get_depth(ptr noundef %1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get_verify_callback(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %default_verify_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 47
  %1 = load ptr, ptr %default_verify_callback, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define void @SSL_set_verify(ptr noundef %s, i32 noundef %mode, ptr noundef %callback) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %callback.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store ptr %callback, ptr %callback.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %if.end15

if.end:                                           ; preds = %cond.end10
  %9 = load i32, ptr %mode.addr, align 4
  %10 = load ptr, ptr %sc, align 8
  %verify_mode = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 57
  store i32 %9, ptr %verify_mode, align 8
  %11 = load ptr, ptr %callback.addr, align 8
  %cmp13 = icmp ne ptr %11, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  %12 = load ptr, ptr %callback.addr, align 8
  %13 = load ptr, ptr %sc, align 8
  %verify_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 58
  store ptr %12, ptr %verify_callback, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_set_verify_depth(ptr noundef %s, i32 noundef %depth) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %depth.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %depth, ptr %depth.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 25
  %10 = load ptr, ptr %param, align 8
  %11 = load i32, ptr %depth.addr, align 4
  call void @X509_VERIFY_PARAM_set_depth(ptr noundef %10, i32 noundef %11)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare void @X509_VERIFY_PARAM_set_depth(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define void @SSL_set_read_ahead(ptr noundef %s, i32 noundef %yes) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %yes.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  %options = alloca [2 x %struct.ossl_param_st], align 16
  %opts = alloca ptr, align 8
  %tmp = alloca %struct.ossl_param_st, align 8
  %tmp9 = alloca %struct.ossl_param_st, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %yes, ptr %yes.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.ossl_param_st], ptr %options, i64 0, i64 0
  store ptr %arraydecay, ptr %opts, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load i32, ptr %yes.addr, align 4
  %6 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 100
  %read_ahead = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 9
  store i32 %5, ptr %read_ahead, align 8
  %7 = load ptr, ptr %opts, align 8
  %incdec.ptr = getelementptr inbounds %struct.ossl_param_st, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %opts, align 8
  %8 = load ptr, ptr %sc, align 8
  %rlayer7 = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 100
  %read_ahead8 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer7, i32 0, i32 9
  call void @OSSL_PARAM_construct_int(ptr sret(%struct.ossl_param_st) align 8 %tmp, ptr noundef @.str.1, ptr noundef %read_ahead8)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %7, ptr align 8 %tmp, i64 40, i1 false)
  %9 = load ptr, ptr %opts, align 8
  call void @OSSL_PARAM_construct_end(ptr sret(%struct.ossl_param_st) align 8 %tmp9)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %9, ptr align 8 %tmp9, i64 40, i1 false)
  %10 = load ptr, ptr %sc, align 8
  %rlayer10 = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 100
  %rrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %rlayer10, i32 0, i32 3
  %11 = load ptr, ptr %rrlmethod, align 8
  %set_options = getelementptr inbounds %struct.ossl_record_method_st, ptr %11, i32 0, i32 18
  %12 = load ptr, ptr %set_options, align 8
  %13 = load ptr, ptr %sc, align 8
  %rlayer11 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 100
  %rrl = getelementptr inbounds %struct.record_layer_st, ptr %rlayer11, i32 0, i32 5
  %14 = load ptr, ptr %rrl, align 8
  %arraydecay12 = getelementptr inbounds [2 x %struct.ossl_param_st], ptr %options, i64 0, i64 0
  %call = call i32 %12(ptr noundef %14, ptr noundef %arraydecay12)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare void @OSSL_PARAM_construct_int(ptr sret(%struct.ossl_param_st) align 8, ptr noundef, ptr noundef) #1

declare void @OSSL_PARAM_construct_end(ptr sret(%struct.ossl_param_st) align 8) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_read_ahead(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 100
  %read_ahead = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 9
  %6 = load i32, ptr %read_ahead, align 8
  store i32 %6, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define i32 @SSL_pending(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %pending = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %method, align 8
  %ssl_pending = getelementptr inbounds %struct.ssl_method_st, ptr %1, i32 0, i32 24
  %2 = load ptr, ptr %ssl_pending, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %call = call i64 %2(ptr noundef %3)
  store i64 %call, ptr %pending, align 8
  %4 = load i64, ptr %pending, align 8
  %cmp = icmp ult i64 %4, 2147483647
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i64, ptr %pending, align 8
  %conv = trunc i64 %5 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ 2147483647, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind uwtable
define i32 @SSL_has_pending(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  %rdata = alloca ptr, align 8
  %item = alloca ptr, align 8
  %iter = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_has_pending(ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %6 = load ptr, ptr %s.addr, align 8
  %cmp4 = icmp eq ptr %6, null
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end15

cond.false:                                       ; preds = %if.end
  %7 = load ptr, ptr %s.addr, align 8
  %type5 = getelementptr inbounds %struct.ssl_st, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %type5, align 8
  %cmp6 = icmp eq i32 %8, 0
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.false
  %9 = load ptr, ptr %s.addr, align 8
  br label %cond.end13

cond.false8:                                      ; preds = %cond.false
  %10 = load ptr, ptr %s.addr, align 8
  %type9 = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %type9, align 8
  %cmp10 = icmp eq i32 %11, 1
  br i1 %cmp10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false8
  %12 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false12:                                     ; preds = %cond.false8
  br label %cond.end

cond.end:                                         ; preds = %cond.false12, %cond.true11
  %cond = phi ptr [ %13, %cond.true11 ], [ null, %cond.false12 ]
  br label %cond.end13

cond.end13:                                       ; preds = %cond.end, %cond.true7
  %cond14 = phi ptr [ %9, %cond.true7 ], [ %cond, %cond.end ]
  br label %cond.end15

cond.end15:                                       ; preds = %cond.end13, %cond.true
  %cond16 = phi ptr [ null, %cond.true ], [ %cond14, %cond.end13 ]
  store ptr %cond16, ptr %sc, align 8
  %14 = load ptr, ptr %sc, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %15 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %15, i32 0, i32 28
  %16 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %16, i32 0, i32 10
  %17 = load i32, ptr %enc_flags, align 8
  %and = and i32 %17, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then17, label %if.end24

if.then17:                                        ; preds = %cond.end15
  %18 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 100
  %d = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 18
  %19 = load ptr, ptr %d, align 8
  %buffered_app_data = getelementptr inbounds %struct.dtls_record_layer_st, ptr %19, i32 0, i32 2
  %q = getelementptr inbounds %struct.record_pqueue_st, ptr %buffered_app_data, i32 0, i32 1
  %20 = load ptr, ptr %q, align 8
  %call18 = call ptr @pqueue_iterator(ptr noundef %20)
  store ptr %call18, ptr %iter, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end23, %if.then17
  %call19 = call ptr @pqueue_next(ptr noundef %iter)
  store ptr %call19, ptr %item, align 8
  %cmp20 = icmp ne ptr %call19, null
  br i1 %cmp20, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load ptr, ptr %item, align 8
  %data = getelementptr inbounds %struct.pitem_st, ptr %21, i32 0, i32 1
  %22 = load ptr, ptr %data, align 8
  store ptr %22, ptr %rdata, align 8
  %23 = load ptr, ptr %rdata, align 8
  %length = getelementptr inbounds %struct.tls_record_st, ptr %23, i32 0, i32 5
  %24 = load i64, ptr %length, align 8
  %cmp21 = icmp ugt i64 %24, 0
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %while.body
  store i32 1, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %while.body
  br label %while.cond, !llvm.loop !12

while.end:                                        ; preds = %while.cond
  br label %if.end24

if.end24:                                         ; preds = %while.end, %cond.end15
  %25 = load ptr, ptr %sc, align 8
  %rlayer25 = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 100
  %call26 = call i32 @RECORD_LAYER_processed_read_pending(ptr noundef %rlayer25)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end24
  store i32 1, ptr %retval, align 4
  br label %return

if.end29:                                         ; preds = %if.end24
  %26 = load ptr, ptr %sc, align 8
  %rlayer30 = getelementptr inbounds %struct.ssl_connection_st, ptr %26, i32 0, i32 100
  %call31 = call i32 @RECORD_LAYER_read_pending(ptr noundef %rlayer30)
  store i32 %call31, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end29, %if.then28, %if.then22, %if.then
  %27 = load i32, ptr %retval, align 4
  ret i32 %27
}

declare i32 @ossl_quic_has_pending(ptr noundef) #1

declare ptr @pqueue_iterator(ptr noundef) #1

declare ptr @pqueue_next(ptr noundef) #1

declare i32 @RECORD_LAYER_processed_read_pending(ptr noundef) #1

declare i32 @RECORD_LAYER_read_pending(ptr noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_get1_peer_certificate(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %r = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get0_peer_certificate(ptr noundef %0)
  store ptr %call, ptr %r, align 8
  %1 = load ptr, ptr %r, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %r, align 8
  %call1 = call i32 @X509_up_ref(ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load ptr, ptr %r, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get0_peer_certificate(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 50
  %10 = load ptr, ptr %session, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %session15 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 50
  %12 = load ptr, ptr %session15, align 8
  %peer = getelementptr inbounds %struct.ssl_session_st, ptr %12, i32 0, i32 12
  %13 = load ptr, ptr %peer, align 8
  store ptr %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then14, %if.then
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

declare i32 @X509_up_ref(ptr noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_get_peer_cert_chain(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %r = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 50
  %10 = load ptr, ptr %session, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  store ptr null, ptr %r, align 8
  br label %if.end16

if.else:                                          ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %session15 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 50
  %12 = load ptr, ptr %session15, align 8
  %peer_chain = getelementptr inbounds %struct.ssl_session_st, ptr %12, i32 0, i32 13
  %13 = load ptr, ptr %peer_chain, align 8
  store ptr %13, ptr %r, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then14
  %14 = load ptr, ptr %r, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end16, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind uwtable
define i32 @SSL_copy_session_id(ptr noundef %t, ptr noundef %f) #0 {
entry:
  %retval = alloca i32, align 4
  %t.addr = alloca ptr, align 8
  %f.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %tsc = alloca ptr, align 8
  %fsc = alloca ptr, align 8
  store ptr %t, ptr %t.addr, align 8
  store ptr %f, ptr %f.addr, align 8
  %0 = load ptr, ptr %t.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %t.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %t.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %tsc, align 8
  %4 = load ptr, ptr %f.addr, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.end4
  br label %cond.end15

cond.false8:                                      ; preds = %cond.end4
  %5 = load ptr, ptr %f.addr, align 8
  %type9 = getelementptr inbounds %struct.ssl_st, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %type9, align 8
  %cmp10 = icmp eq i32 %6, 0
  br i1 %cmp10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false8
  %7 = load ptr, ptr %f.addr, align 8
  br label %cond.end13

cond.false12:                                     ; preds = %cond.false8
  br label %cond.end13

cond.end13:                                       ; preds = %cond.false12, %cond.true11
  %cond14 = phi ptr [ %7, %cond.true11 ], [ null, %cond.false12 ]
  br label %cond.end15

cond.end15:                                       ; preds = %cond.end13, %cond.true7
  %cond16 = phi ptr [ null, %cond.true7 ], [ %cond14, %cond.end13 ]
  store ptr %cond16, ptr %fsc, align 8
  %8 = load ptr, ptr %tsc, align 8
  %cmp17 = icmp eq ptr %8, null
  br i1 %cmp17, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end15
  %9 = load ptr, ptr %fsc, align 8
  %cmp18 = icmp eq ptr %9, null
  br i1 %cmp18, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end15
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %10 = load ptr, ptr %t.addr, align 8
  %11 = load ptr, ptr %f.addr, align 8
  %call = call ptr @SSL_get_session(ptr noundef %11)
  %call19 = call i32 @SSL_set_session(ptr noundef %10, ptr noundef %call)
  %tobool = icmp ne i32 %call19, 0
  br i1 %tobool, label %if.end21, label %if.then20

if.then20:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end
  %12 = load ptr, ptr %t.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %12, i32 0, i32 3
  %13 = load ptr, ptr %method, align 8
  %14 = load ptr, ptr %f.addr, align 8
  %method22 = getelementptr inbounds %struct.ssl_st, ptr %14, i32 0, i32 3
  %15 = load ptr, ptr %method22, align 8
  %cmp23 = icmp ne ptr %13, %15
  br i1 %cmp23, label %if.then24, label %if.end33

if.then24:                                        ; preds = %if.end21
  %16 = load ptr, ptr %t.addr, align 8
  %method25 = getelementptr inbounds %struct.ssl_st, ptr %16, i32 0, i32 3
  %17 = load ptr, ptr %method25, align 8
  %ssl_deinit = getelementptr inbounds %struct.ssl_method_st, ptr %17, i32 0, i32 8
  %18 = load ptr, ptr %ssl_deinit, align 8
  %19 = load ptr, ptr %t.addr, align 8
  call void %18(ptr noundef %19)
  %20 = load ptr, ptr %f.addr, align 8
  %method26 = getelementptr inbounds %struct.ssl_st, ptr %20, i32 0, i32 3
  %21 = load ptr, ptr %method26, align 8
  %22 = load ptr, ptr %t.addr, align 8
  %method27 = getelementptr inbounds %struct.ssl_st, ptr %22, i32 0, i32 3
  store ptr %21, ptr %method27, align 8
  %23 = load ptr, ptr %t.addr, align 8
  %method28 = getelementptr inbounds %struct.ssl_st, ptr %23, i32 0, i32 3
  %24 = load ptr, ptr %method28, align 8
  %ssl_init = getelementptr inbounds %struct.ssl_method_st, ptr %24, i32 0, i32 6
  %25 = load ptr, ptr %ssl_init, align 8
  %26 = load ptr, ptr %t.addr, align 8
  %call29 = call i32 %25(ptr noundef %26)
  %cmp30 = icmp eq i32 %call29, 0
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.then24
  store i32 0, ptr %retval, align 4
  br label %return

if.end32:                                         ; preds = %if.then24
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.end21
  %27 = load ptr, ptr %fsc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 44
  %28 = load ptr, ptr %cert, align 8
  %references = getelementptr inbounds %struct.cert_st, ptr %28, i32 0, i32 22
  %call34 = call i32 @CRYPTO_UP_REF(ptr noundef %references, ptr noundef %i)
  %29 = load ptr, ptr %tsc, align 8
  %cert35 = getelementptr inbounds %struct.ssl_connection_st, ptr %29, i32 0, i32 44
  %30 = load ptr, ptr %cert35, align 8
  call void @ssl_cert_free(ptr noundef %30)
  %31 = load ptr, ptr %fsc, align 8
  %cert36 = getelementptr inbounds %struct.ssl_connection_st, ptr %31, i32 0, i32 44
  %32 = load ptr, ptr %cert36, align 8
  %33 = load ptr, ptr %tsc, align 8
  %cert37 = getelementptr inbounds %struct.ssl_connection_st, ptr %33, i32 0, i32 44
  store ptr %32, ptr %cert37, align 8
  %34 = load ptr, ptr %t.addr, align 8
  %35 = load ptr, ptr %fsc, align 8
  %sid_ctx = getelementptr inbounds %struct.ssl_connection_st, ptr %35, i32 0, i32 49
  %arraydecay = getelementptr inbounds [32 x i8], ptr %sid_ctx, i64 0, i64 0
  %36 = load ptr, ptr %fsc, align 8
  %sid_ctx_length = getelementptr inbounds %struct.ssl_connection_st, ptr %36, i32 0, i32 48
  %37 = load i64, ptr %sid_ctx_length, align 8
  %conv = trunc i64 %37 to i32
  %call38 = call i32 @SSL_set_session_id_context(ptr noundef %34, ptr noundef %arraydecay, i32 noundef %conv)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.end33
  store i32 0, ptr %retval, align 4
  br label %return

if.end41:                                         ; preds = %if.end33
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end41, %if.then40, %if.then31, %if.then20, %if.then
  %38 = load i32, ptr %retval, align 4
  ret i32 %38
}

declare i32 @SSL_set_session(ptr noundef, ptr noundef) #1

declare ptr @SSL_get_session(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_check_private_key(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %cert, align 8
  %key = getelementptr inbounds %struct.cert_st, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %key, align 8
  %x509 = getelementptr inbounds %struct.cert_pkey_st, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %x509, align 8
  %cmp1 = icmp eq ptr %4, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2050, ptr noundef @__func__.SSL_CTX_check_private_key)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 177, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %5 = load ptr, ptr %ctx.addr, align 8
  %cert2 = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 39
  %6 = load ptr, ptr %cert2, align 8
  %key3 = getelementptr inbounds %struct.cert_st, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %key3, align 8
  %privatekey = getelementptr inbounds %struct.cert_pkey_st, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %privatekey, align 8
  %cmp4 = icmp eq ptr %8, null
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2054, ptr noundef @__func__.SSL_CTX_check_private_key)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 190, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %9 = load ptr, ptr %ctx.addr, align 8
  %cert7 = getelementptr inbounds %struct.ssl_ctx_st, ptr %9, i32 0, i32 39
  %10 = load ptr, ptr %cert7, align 8
  %key8 = getelementptr inbounds %struct.cert_st, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %key8, align 8
  %x5099 = getelementptr inbounds %struct.cert_pkey_st, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %x5099, align 8
  %13 = load ptr, ptr %ctx.addr, align 8
  %cert10 = getelementptr inbounds %struct.ssl_ctx_st, ptr %13, i32 0, i32 39
  %14 = load ptr, ptr %cert10, align 8
  %key11 = getelementptr inbounds %struct.cert_st, ptr %14, i32 0, i32 0
  %15 = load ptr, ptr %key11, align 8
  %privatekey12 = getelementptr inbounds %struct.cert_pkey_st, ptr %15, i32 0, i32 1
  %16 = load ptr, ptr %privatekey12, align 8
  %call = call i32 @X509_check_private_key(ptr noundef %12, ptr noundef %16)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

declare i32 @X509_check_private_key(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_check_private_key(ptr noundef %ssl) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %cmp12 = icmp eq ptr %cond11, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2067, ptr noundef @__func__.SSL_check_private_key)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786690, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %8 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 44
  %9 = load ptr, ptr %cert, align 8
  %key = getelementptr inbounds %struct.cert_st, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %key, align 8
  %x509 = getelementptr inbounds %struct.cert_pkey_st, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %x509, align 8
  %cmp13 = icmp eq ptr %11, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2071, ptr noundef @__func__.SSL_check_private_key)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 177, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end
  %12 = load ptr, ptr %sc, align 8
  %cert16 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 44
  %13 = load ptr, ptr %cert16, align 8
  %key17 = getelementptr inbounds %struct.cert_st, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %key17, align 8
  %privatekey = getelementptr inbounds %struct.cert_pkey_st, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %privatekey, align 8
  %cmp18 = icmp eq ptr %15, null
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %if.end15
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2075, ptr noundef @__func__.SSL_check_private_key)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 190, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end20:                                         ; preds = %if.end15
  %16 = load ptr, ptr %sc, align 8
  %cert21 = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 44
  %17 = load ptr, ptr %cert21, align 8
  %key22 = getelementptr inbounds %struct.cert_st, ptr %17, i32 0, i32 0
  %18 = load ptr, ptr %key22, align 8
  %x50923 = getelementptr inbounds %struct.cert_pkey_st, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %x50923, align 8
  %20 = load ptr, ptr %sc, align 8
  %cert24 = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 44
  %21 = load ptr, ptr %cert24, align 8
  %key25 = getelementptr inbounds %struct.cert_st, ptr %21, i32 0, i32 0
  %22 = load ptr, ptr %key25, align 8
  %privatekey26 = getelementptr inbounds %struct.cert_pkey_st, ptr %22, i32 0, i32 1
  %23 = load ptr, ptr %privatekey26, align 8
  %call = call i32 @X509_check_private_key(ptr noundef %19, ptr noundef %23)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end20, %if.then19, %if.then14, %if.then
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define i32 @SSL_waiting_for_async(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %job = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 103
  %10 = load ptr, ptr %job, align 8
  %tobool = icmp ne ptr %10, null
  br i1 %tobool, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then13, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_all_async_fds(ptr noundef %s, ptr noundef %fds, ptr noundef %numfds) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %fds.addr = alloca ptr, align 8
  %numfds.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %fds, ptr %fds.addr, align 8
  store ptr %numfds, ptr %numfds.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %waitctx = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 104
  %10 = load ptr, ptr %waitctx, align 8
  store ptr %10, ptr %ctx, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end
  %11 = load ptr, ptr %ctx, align 8
  %12 = load ptr, ptr %fds.addr, align 8
  %13 = load ptr, ptr %numfds.addr, align 8
  %call = call i32 @ASYNC_WAIT_CTX_get_all_fds(ptr noundef %11, ptr noundef %12, ptr noundef %13)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then14, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

declare i32 @ASYNC_WAIT_CTX_get_all_fds(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_changed_async_fds(ptr noundef %s, ptr noundef %addfd, ptr noundef %numaddfds, ptr noundef %delfd, ptr noundef %numdelfds) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %addfd.addr = alloca ptr, align 8
  %numaddfds.addr = alloca ptr, align 8
  %delfd.addr = alloca ptr, align 8
  %numdelfds.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %addfd, ptr %addfd.addr, align 8
  store ptr %numaddfds, ptr %numaddfds.addr, align 8
  store ptr %delfd, ptr %delfd.addr, align 8
  store ptr %numdelfds, ptr %numdelfds.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %waitctx = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 104
  %10 = load ptr, ptr %waitctx, align 8
  store ptr %10, ptr %ctx, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end
  %11 = load ptr, ptr %ctx, align 8
  %12 = load ptr, ptr %addfd.addr, align 8
  %13 = load ptr, ptr %numaddfds.addr, align 8
  %14 = load ptr, ptr %delfd.addr, align 8
  %15 = load ptr, ptr %numdelfds.addr, align 8
  %call = call i32 @ASYNC_WAIT_CTX_get_changed_fds(ptr noundef %11, ptr noundef %12, ptr noundef %13, ptr noundef %14, ptr noundef %15)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then14, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

declare i32 @ASYNC_WAIT_CTX_get_changed_fds(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_async_callback(ptr noundef %ctx, ptr noundef %callback) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  %0 = load ptr, ptr %callback.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %async_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 84
  store ptr %0, ptr %async_cb, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_async_callback_arg(ptr noundef %ctx, ptr noundef %arg) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %async_cb_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 85
  store ptr %0, ptr %async_cb_arg, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_async_callback(ptr noundef %s, ptr noundef %callback) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %callback.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %async_cb = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 114
  store ptr %9, ptr %async_cb, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_async_callback_arg(ptr noundef %s, ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %arg.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %async_cb_arg = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 115
  store ptr %9, ptr %async_cb_arg, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_async_status(ptr noundef %s, ptr noundef %status) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %status.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %status, ptr %status.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %waitctx = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 104
  %10 = load ptr, ptr %waitctx, align 8
  store ptr %10, ptr %ctx, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end
  %11 = load ptr, ptr %ctx, align 8
  %call = call i32 @ASYNC_WAIT_CTX_get_status(ptr noundef %11)
  %12 = load ptr, ptr %status.addr, align 8
  store i32 %call, ptr %12, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then14, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

declare i32 @ASYNC_WAIT_CTX_get_status(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_accept(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 3
  %14 = load ptr, ptr %method, align 8
  %ssl_accept = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 9
  %15 = load ptr, ptr %ssl_accept, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %call = call i32 %15(ptr noundef %16)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %17 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %17, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %18 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 6
  %19 = load ptr, ptr %handshake_func, align 8
  %cmp20 = icmp eq ptr %19, null
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end19
  %20 = load ptr, ptr %s.addr, align 8
  call void @SSL_set_accept_state(ptr noundef %20)
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.end19
  %21 = load ptr, ptr %s.addr, align 8
  %call23 = call i32 @SSL_do_handshake(ptr noundef %21)
  store i32 %call23, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end22, %if.then18, %if.then
  %22 = load i32, ptr %retval, align 4
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define void @SSL_set_accept_state(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %cmp6 = icmp ne ptr %4, null
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end4
  %5 = load ptr, ptr %s.addr, align 8
  %type7 = getelementptr inbounds %struct.ssl_st, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %type7, align 8
  %cmp8 = icmp eq i32 %6, 1
  br i1 %cmp8, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %7 = load ptr, ptr %s.addr, align 8
  %type9 = getelementptr inbounds %struct.ssl_st, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %type9, align 8
  %cmp10 = icmp eq i32 %8, 2
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %9 = load ptr, ptr %s.addr, align 8
  call void @ossl_quic_set_accept_state(ptr noundef %9)
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end4
  %10 = load ptr, ptr %sc, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 7
  store i32 1, ptr %server, align 8
  %11 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 10
  store i32 0, ptr %shutdown, align 4
  %12 = load ptr, ptr %sc, align 8
  call void @ossl_statem_clear(ptr noundef %12)
  %13 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 3
  %14 = load ptr, ptr %method, align 8
  %ssl_accept = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 9
  %15 = load ptr, ptr %ssl_accept, align 8
  %16 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 6
  store ptr %15, ptr %handshake_func, align 8
  %17 = load ptr, ptr %sc, align 8
  %call = call i32 @clear_record_layer(ptr noundef %17)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_do_handshake(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %sc = alloca ptr, align 8
  %args = alloca %struct.ssl_async_args, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 1, ptr %ret, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_do_handshake(ptr noundef %13)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %14 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 6
  %15 = load ptr, ptr %handshake_func, align 8
  %cmp17 = icmp eq ptr %15, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 4729, ptr noundef @__func__.SSL_do_handshake)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 144, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %16 = load ptr, ptr %sc, align 8
  call void @ossl_statem_check_finish_init(ptr noundef %16, i32 noundef -1)
  %17 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %17, i32 0, i32 3
  %18 = load ptr, ptr %method, align 8
  %ssl_renegotiate_check = getelementptr inbounds %struct.ssl_method_st, ptr %18, i32 0, i32 16
  %19 = load ptr, ptr %ssl_renegotiate_check, align 8
  %20 = load ptr, ptr %s.addr, align 8
  %call20 = call i32 %19(ptr noundef %20, i32 noundef 0)
  %21 = load ptr, ptr %s.addr, align 8
  %call21 = call i32 @SSL_in_init(ptr noundef %21)
  %tobool = icmp ne i32 %call21, 0
  br i1 %tobool, label %if.then25, label %lor.lhs.false22

lor.lhs.false22:                                  ; preds = %if.end19
  %22 = load ptr, ptr %s.addr, align 8
  %call23 = call i32 @SSL_in_before(ptr noundef %22)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.then25, label %if.end36

if.then25:                                        ; preds = %lor.lhs.false22, %if.end19
  %23 = load ptr, ptr %sc, align 8
  %mode = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 71
  %24 = load i32, ptr %mode, align 8
  %and = and i32 %24, 256
  %tobool26 = icmp ne i32 %and, 0
  br i1 %tobool26, label %land.lhs.true27, label %if.else

land.lhs.true27:                                  ; preds = %if.then25
  %call28 = call ptr @ASYNC_get_current_job()
  %cmp29 = icmp eq ptr %call28, null
  br i1 %cmp29, label %if.then30, label %if.else

if.then30:                                        ; preds = %land.lhs.true27
  call void @llvm.memset.p0.i64(ptr align 8 %args, i8 0, i64 40, i1 false)
  %25 = load ptr, ptr %s.addr, align 8
  %s31 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 0
  store ptr %25, ptr %s31, align 8
  %26 = load ptr, ptr %s.addr, align 8
  %call32 = call i32 @ssl_start_async_job(ptr noundef %26, ptr noundef %args, ptr noundef @ssl_do_handshake_intern)
  store i32 %call32, ptr %ret, align 4
  br label %if.end35

if.else:                                          ; preds = %land.lhs.true27, %if.then25
  %27 = load ptr, ptr %sc, align 8
  %handshake_func33 = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 6
  %28 = load ptr, ptr %handshake_func33, align 8
  %29 = load ptr, ptr %s.addr, align 8
  %call34 = call i32 %28(ptr noundef %29)
  store i32 %call34, ptr %ret, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.else, %if.then30
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %lor.lhs.false22
  %30 = load i32, ptr %ret, align 4
  store i32 %30, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end36, %if.then18, %if.then
  %31 = load i32, ptr %retval, align 4
  ret i32 %31
}

; Function Attrs: nounwind uwtable
define i32 @SSL_connect(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 3
  %14 = load ptr, ptr %method, align 8
  %ssl_connect = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 10
  %15 = load ptr, ptr %ssl_connect, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %call = call i32 %15(ptr noundef %16)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %17 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %17, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %18 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 6
  %19 = load ptr, ptr %handshake_func, align 8
  %cmp20 = icmp eq ptr %19, null
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end19
  %20 = load ptr, ptr %s.addr, align 8
  call void @SSL_set_connect_state(ptr noundef %20)
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.end19
  %21 = load ptr, ptr %s.addr, align 8
  %call23 = call i32 @SSL_do_handshake(ptr noundef %21)
  store i32 %call23, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end22, %if.then18, %if.then
  %22 = load i32, ptr %retval, align 4
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define void @SSL_set_connect_state(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %cmp6 = icmp ne ptr %4, null
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end4
  %5 = load ptr, ptr %s.addr, align 8
  %type7 = getelementptr inbounds %struct.ssl_st, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %type7, align 8
  %cmp8 = icmp eq i32 %6, 1
  br i1 %cmp8, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %7 = load ptr, ptr %s.addr, align 8
  %type9 = getelementptr inbounds %struct.ssl_st, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %type9, align 8
  %cmp10 = icmp eq i32 %8, 2
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %9 = load ptr, ptr %s.addr, align 8
  call void @ossl_quic_set_connect_state(ptr noundef %9)
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end4
  %10 = load ptr, ptr %sc, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 7
  store i32 0, ptr %server, align 8
  %11 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 10
  store i32 0, ptr %shutdown, align 4
  %12 = load ptr, ptr %sc, align 8
  call void @ossl_statem_clear(ptr noundef %12)
  %13 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 3
  %14 = load ptr, ptr %method, align 8
  %ssl_connect = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 10
  %15 = load ptr, ptr %ssl_connect, align 8
  %16 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 6
  store ptr %15, ptr %handshake_func, align 8
  %17 = load ptr, ptr %sc, align 8
  %call = call i32 @clear_record_layer(ptr noundef %17)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @SSL_get_default_timeout(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %agg.tmp = alloca %struct.OSSL_TIME, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %method, align 8
  %get_timeout = getelementptr inbounds %struct.ssl_method_st, ptr %1, i32 0, i32 27
  %2 = load ptr, ptr %get_timeout, align 8
  %call = call i64 %2()
  %coerce.dive = getelementptr inbounds %struct.OSSL_TIME, ptr %agg.tmp, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %struct.OSSL_TIME, ptr %agg.tmp, i32 0, i32 0
  %3 = load i64, ptr %coerce.dive1, align 8
  %call2 = call i64 @ossl_time2ticks(i64 %3)
  %div = udiv i64 %call2, 1000000000
  ret i64 %div
}

; Function Attrs: nounwind uwtable
define internal i64 @ossl_time2ticks(i64 %t.coerce) #0 {
entry:
  %t = alloca %struct.OSSL_TIME, align 8
  %coerce.dive = getelementptr inbounds %struct.OSSL_TIME, ptr %t, i32 0, i32 0
  store i64 %t.coerce, ptr %coerce.dive, align 8
  %t1 = getelementptr inbounds %struct.OSSL_TIME, ptr %t, i32 0, i32 0
  %0 = load i64, ptr %t1, align 8
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define i32 @ssl_read_internal(ptr noundef %s, ptr noundef %buf, i64 noundef %num, ptr noundef %readbytes) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i64, align 8
  %readbytes.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  %args = alloca %struct.ssl_async_args, align 8
  %ret = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %num, ptr %num.addr, align 8
  store ptr %readbytes, ptr %readbytes.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 3
  %14 = load ptr, ptr %method, align 8
  %ssl_read = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 11
  %15 = load ptr, ptr %ssl_read, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load ptr, ptr %buf.addr, align 8
  %18 = load i64, ptr %num.addr, align 8
  %19 = load ptr, ptr %readbytes.addr, align 8
  %call = call i32 %15(ptr noundef %16, ptr noundef %17, i64 noundef %18, ptr noundef %19)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %20 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %20, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %21 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 6
  %22 = load ptr, ptr %handshake_func, align 8
  %cmp20 = icmp eq ptr %22, null
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end19
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2309, ptr noundef @__func__.ssl_read_internal)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 276, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end19
  %23 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 10
  %24 = load i32, ptr %shutdown, align 4
  %and = and i32 %24, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end22
  %25 = load ptr, ptr %sc, align 8
  %rwstate = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 5
  store i32 1, ptr %rwstate, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end22
  %26 = load ptr, ptr %sc, align 8
  %early_data_state = getelementptr inbounds %struct.ssl_connection_st, ptr %26, i32 0, i32 14
  %27 = load i32, ptr %early_data_state, align 8
  %cmp25 = icmp eq i32 %27, 1
  br i1 %cmp25, label %if.then29, label %lor.lhs.false26

lor.lhs.false26:                                  ; preds = %if.end24
  %28 = load ptr, ptr %sc, align 8
  %early_data_state27 = getelementptr inbounds %struct.ssl_connection_st, ptr %28, i32 0, i32 14
  %29 = load i32, ptr %early_data_state27, align 8
  %cmp28 = icmp eq i32 %29, 8
  br i1 %cmp28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %lor.lhs.false26, %if.end24
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2320, ptr noundef @__func__.ssl_read_internal)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786689, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end30:                                         ; preds = %lor.lhs.false26
  %30 = load ptr, ptr %sc, align 8
  call void @ossl_statem_check_finish_init(ptr noundef %30, i32 noundef 0)
  %31 = load ptr, ptr %sc, align 8
  %mode = getelementptr inbounds %struct.ssl_connection_st, ptr %31, i32 0, i32 71
  %32 = load i32, ptr %mode, align 8
  %and31 = and i32 %32, 256
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %land.lhs.true33, label %if.else

land.lhs.true33:                                  ; preds = %if.end30
  %call34 = call ptr @ASYNC_get_current_job()
  %cmp35 = icmp eq ptr %call34, null
  br i1 %cmp35, label %if.then36, label %if.else

if.then36:                                        ; preds = %land.lhs.true33
  %33 = load ptr, ptr %s.addr, align 8
  %s37 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 0
  store ptr %33, ptr %s37, align 8
  %34 = load ptr, ptr %buf.addr, align 8
  %buf38 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 1
  store ptr %34, ptr %buf38, align 8
  %35 = load i64, ptr %num.addr, align 8
  %num39 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 2
  store i64 %35, ptr %num39, align 8
  %type40 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 3
  store i32 0, ptr %type40, align 8
  %36 = load ptr, ptr %s.addr, align 8
  %method41 = getelementptr inbounds %struct.ssl_st, ptr %36, i32 0, i32 3
  %37 = load ptr, ptr %method41, align 8
  %ssl_read42 = getelementptr inbounds %struct.ssl_method_st, ptr %37, i32 0, i32 11
  %38 = load ptr, ptr %ssl_read42, align 8
  %f = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 4
  store ptr %38, ptr %f, align 8
  %39 = load ptr, ptr %s.addr, align 8
  %call43 = call i32 @ssl_start_async_job(ptr noundef %39, ptr noundef %args, ptr noundef @ssl_io_intern)
  store i32 %call43, ptr %ret, align 4
  %40 = load ptr, ptr %sc, align 8
  %asyncrw = getelementptr inbounds %struct.ssl_connection_st, ptr %40, i32 0, i32 105
  %41 = load i64, ptr %asyncrw, align 8
  %42 = load ptr, ptr %readbytes.addr, align 8
  store i64 %41, ptr %42, align 8
  %43 = load i32, ptr %ret, align 4
  store i32 %43, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true33, %if.end30
  %44 = load ptr, ptr %s.addr, align 8
  %method44 = getelementptr inbounds %struct.ssl_st, ptr %44, i32 0, i32 3
  %45 = load ptr, ptr %method44, align 8
  %ssl_read45 = getelementptr inbounds %struct.ssl_method_st, ptr %45, i32 0, i32 11
  %46 = load ptr, ptr %ssl_read45, align 8
  %47 = load ptr, ptr %s.addr, align 8
  %48 = load ptr, ptr %buf.addr, align 8
  %49 = load i64, ptr %num.addr, align 8
  %50 = load ptr, ptr %readbytes.addr, align 8
  %call46 = call i32 %46(ptr noundef %47, ptr noundef %48, i64 noundef %49, ptr noundef %50)
  store i32 %call46, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then36, %if.then29, %if.then23, %if.then21, %if.then18, %if.then
  %51 = load i32, ptr %retval, align 4
  ret i32 %51
}

declare void @ossl_statem_check_finish_init(ptr noundef, i32 noundef) #1

declare ptr @ASYNC_get_current_job() #1

; Function Attrs: nounwind uwtable
define internal i32 @ssl_start_async_job(ptr noundef %s, ptr noundef %args, ptr noundef %func) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %func.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store ptr %func, ptr %func.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %waitctx = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 104
  %10 = load ptr, ptr %waitctx, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.end25

if.then14:                                        ; preds = %if.end
  %call = call ptr @ASYNC_WAIT_CTX_new()
  %11 = load ptr, ptr %sc, align 8
  %waitctx15 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 104
  store ptr %call, ptr %waitctx15, align 8
  %12 = load ptr, ptr %sc, align 8
  %waitctx16 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 104
  %13 = load ptr, ptr %waitctx16, align 8
  %cmp17 = icmp eq ptr %13, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.then14
  store i32 -1, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.then14
  %14 = load ptr, ptr %sc, align 8
  %async_cb = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 114
  %15 = load ptr, ptr %async_cb, align 8
  %cmp20 = icmp ne ptr %15, null
  br i1 %cmp20, label %land.lhs.true, label %if.end24

land.lhs.true:                                    ; preds = %if.end19
  %16 = load ptr, ptr %sc, align 8
  %waitctx21 = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 104
  %17 = load ptr, ptr %waitctx21, align 8
  %18 = load ptr, ptr %s.addr, align 8
  %call22 = call i32 @ASYNC_WAIT_CTX_set_callback(ptr noundef %17, ptr noundef @ssl_async_wait_ctx_cb, ptr noundef %18)
  %tobool = icmp ne i32 %call22, 0
  br i1 %tobool, label %if.end24, label %if.then23

if.then23:                                        ; preds = %land.lhs.true
  store i32 -1, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %land.lhs.true, %if.end19
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end
  %19 = load ptr, ptr %sc, align 8
  %rwstate = getelementptr inbounds %struct.ssl_connection_st, ptr %19, i32 0, i32 5
  store i32 1, ptr %rwstate, align 8
  %20 = load ptr, ptr %sc, align 8
  %job = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 103
  %21 = load ptr, ptr %sc, align 8
  %waitctx26 = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 104
  %22 = load ptr, ptr %waitctx26, align 8
  %23 = load ptr, ptr %func.addr, align 8
  %24 = load ptr, ptr %args.addr, align 8
  %call27 = call i32 @ASYNC_start_job(ptr noundef %job, ptr noundef %22, ptr noundef %ret, ptr noundef %23, ptr noundef %24, i64 noundef 40)
  switch i32 %call27, label %sw.default [
    i32 0, label %sw.bb
    i32 2, label %sw.bb29
    i32 1, label %sw.bb31
    i32 3, label %sw.bb33
  ]

sw.bb:                                            ; preds = %if.end25
  %25 = load ptr, ptr %sc, align 8
  %rwstate28 = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 5
  store i32 1, ptr %rwstate28, align 8
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2251, ptr noundef @__func__.ssl_start_async_job)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 405, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

sw.bb29:                                          ; preds = %if.end25
  %26 = load ptr, ptr %sc, align 8
  %rwstate30 = getelementptr inbounds %struct.ssl_connection_st, ptr %26, i32 0, i32 5
  store i32 5, ptr %rwstate30, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

sw.bb31:                                          ; preds = %if.end25
  %27 = load ptr, ptr %sc, align 8
  %rwstate32 = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 5
  store i32 6, ptr %rwstate32, align 8
  store i32 -1, ptr %retval, align 4
  br label %return

sw.bb33:                                          ; preds = %if.end25
  %28 = load ptr, ptr %sc, align 8
  %job34 = getelementptr inbounds %struct.ssl_connection_st, ptr %28, i32 0, i32 103
  store ptr null, ptr %job34, align 8
  %29 = load i32, ptr %ret, align 4
  store i32 %29, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end25
  %30 = load ptr, ptr %sc, align 8
  %rwstate35 = getelementptr inbounds %struct.ssl_connection_st, ptr %30, i32 0, i32 5
  store i32 1, ptr %rwstate35, align 8
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2264, ptr noundef @__func__.ssl_start_async_job)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786691, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %sw.bb33, %sw.bb31, %sw.bb29, %sw.bb, %if.then23, %if.then18, %if.then
  %31 = load i32, ptr %retval, align 4
  ret i32 %31
}

; Function Attrs: nounwind uwtable
define internal i32 @ssl_io_intern(ptr noundef %vargs) #0 {
entry:
  %retval = alloca i32, align 4
  %vargs.addr = alloca ptr, align 8
  %args = alloca ptr, align 8
  %s = alloca ptr, align 8
  %buf = alloca ptr, align 8
  %num = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %vargs, ptr %vargs.addr, align 8
  %0 = load ptr, ptr %vargs.addr, align 8
  store ptr %0, ptr %args, align 8
  %1 = load ptr, ptr %args, align 8
  %s1 = getelementptr inbounds %struct.ssl_async_args, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %s1, align 8
  store ptr %2, ptr %s, align 8
  %3 = load ptr, ptr %args, align 8
  %buf2 = getelementptr inbounds %struct.ssl_async_args, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %buf2, align 8
  store ptr %4, ptr %buf, align 8
  %5 = load ptr, ptr %args, align 8
  %num3 = getelementptr inbounds %struct.ssl_async_args, ptr %5, i32 0, i32 2
  %6 = load i64, ptr %num3, align 8
  store i64 %6, ptr %num, align 8
  %7 = load ptr, ptr %s, align 8
  %cmp = icmp eq ptr %7, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end13

cond.false:                                       ; preds = %entry
  %8 = load ptr, ptr %s, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type, align 8
  %cmp4 = icmp eq i32 %9, 0
  br i1 %cmp4, label %cond.true5, label %cond.false6

cond.true5:                                       ; preds = %cond.false
  %10 = load ptr, ptr %s, align 8
  br label %cond.end11

cond.false6:                                      ; preds = %cond.false
  %11 = load ptr, ptr %s, align 8
  %type7 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type7, align 8
  %cmp8 = icmp eq i32 %12, 1
  br i1 %cmp8, label %cond.true9, label %cond.false10

cond.true9:                                       ; preds = %cond.false6
  %13 = load ptr, ptr %s, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false10:                                     ; preds = %cond.false6
  br label %cond.end

cond.end:                                         ; preds = %cond.false10, %cond.true9
  %cond = phi ptr [ %14, %cond.true9 ], [ null, %cond.false10 ]
  br label %cond.end11

cond.end11:                                       ; preds = %cond.end, %cond.true5
  %cond12 = phi ptr [ %10, %cond.true5 ], [ %cond, %cond.end ]
  br label %cond.end13

cond.end13:                                       ; preds = %cond.end11, %cond.true
  %cond14 = phi ptr [ null, %cond.true ], [ %cond12, %cond.end11 ]
  store ptr %cond14, ptr %sc, align 8
  %cmp15 = icmp eq ptr %cond14, null
  br i1 %cmp15, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end13
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end13
  %15 = load ptr, ptr %args, align 8
  %type16 = getelementptr inbounds %struct.ssl_async_args, ptr %15, i32 0, i32 3
  %16 = load i32, ptr %type16, align 8
  switch i32 %16, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb17
    i32 2, label %sw.bb21
  ]

sw.bb:                                            ; preds = %if.end
  %17 = load ptr, ptr %args, align 8
  %f = getelementptr inbounds %struct.ssl_async_args, ptr %17, i32 0, i32 4
  %18 = load ptr, ptr %f, align 8
  %19 = load ptr, ptr %s, align 8
  %20 = load ptr, ptr %buf, align 8
  %21 = load i64, ptr %num, align 8
  %22 = load ptr, ptr %sc, align 8
  %asyncrw = getelementptr inbounds %struct.ssl_connection_st, ptr %22, i32 0, i32 105
  %call = call i32 %18(ptr noundef %19, ptr noundef %20, i64 noundef %21, ptr noundef %asyncrw)
  store i32 %call, ptr %retval, align 4
  br label %return

sw.bb17:                                          ; preds = %if.end
  %23 = load ptr, ptr %args, align 8
  %f18 = getelementptr inbounds %struct.ssl_async_args, ptr %23, i32 0, i32 4
  %24 = load ptr, ptr %f18, align 8
  %25 = load ptr, ptr %s, align 8
  %26 = load ptr, ptr %buf, align 8
  %27 = load i64, ptr %num, align 8
  %28 = load ptr, ptr %sc, align 8
  %asyncrw19 = getelementptr inbounds %struct.ssl_connection_st, ptr %28, i32 0, i32 105
  %call20 = call i32 %24(ptr noundef %25, ptr noundef %26, i64 noundef %27, ptr noundef %asyncrw19)
  store i32 %call20, ptr %retval, align 4
  br label %return

sw.bb21:                                          ; preds = %if.end
  %29 = load ptr, ptr %args, align 8
  %f22 = getelementptr inbounds %struct.ssl_async_args, ptr %29, i32 0, i32 4
  %30 = load ptr, ptr %f22, align 8
  %31 = load ptr, ptr %s, align 8
  %call23 = call i32 %30(ptr noundef %31)
  store i32 %call23, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb21, %sw.bb17, %sw.bb, %if.then
  %32 = load i32, ptr %retval, align 4
  ret i32 %32
}

; Function Attrs: nounwind uwtable
define i32 @SSL_read(ptr noundef %s, ptr noundef %buf, i32 noundef %num) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i32, align 4
  %ret = alloca i32, align 4
  %readbytes = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i32 %num, ptr %num.addr, align 4
  %0 = load i32, ptr %num.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2353, ptr noundef @__func__.SSL_read)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 271, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i32, ptr %num.addr, align 4
  %conv = sext i32 %3 to i64
  %call = call i32 @ssl_read_internal(ptr noundef %1, ptr noundef %2, i64 noundef %conv, ptr noundef %readbytes)
  store i32 %call, ptr %ret, align 4
  %4 = load i32, ptr %ret, align 4
  %cmp1 = icmp sgt i32 %4, 0
  br i1 %cmp1, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %5 = load i64, ptr %readbytes, align 8
  %conv4 = trunc i64 %5 to i32
  store i32 %conv4, ptr %ret, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %6 = load i32, ptr %ret, align 4
  store i32 %6, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define i32 @SSL_read_ex(ptr noundef %s, ptr noundef %buf, i64 noundef %num, ptr noundef %readbytes) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i64, align 8
  %readbytes.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %num, ptr %num.addr, align 8
  store ptr %readbytes, ptr %readbytes.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %buf.addr, align 8
  %2 = load i64, ptr %num.addr, align 8
  %3 = load ptr, ptr %readbytes.addr, align 8
  %call = call i32 @ssl_read_internal(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3)
  store i32 %call, ptr %ret, align 4
  %4 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %ret, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %ret, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define i32 @SSL_read_early_data(ptr noundef %s, ptr noundef %buf, i64 noundef %num, ptr noundef %readbytes) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i64, align 8
  %readbytes.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %num, ptr %num.addr, align 8
  store ptr %readbytes, ptr %readbytes.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 7
  %6 = load i32, ptr %server, align 8
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %cond.end4
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2385, ptr noundef @__func__.SSL_read_early_data)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786689, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %7 = load ptr, ptr %sc, align 8
  %early_data_state = getelementptr inbounds %struct.ssl_connection_st, ptr %7, i32 0, i32 14
  %8 = load i32, ptr %early_data_state, align 8
  switch i32 %8, label %sw.default [
    i32 0, label %sw.bb
    i32 8, label %sw.bb10
    i32 10, label %sw.bb17
  ]

sw.bb:                                            ; preds = %if.end
  %9 = load ptr, ptr %s.addr, align 8
  %call = call i32 @SSL_in_before(ptr noundef %9)
  %tobool7 = icmp ne i32 %call, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %sw.bb
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2392, ptr noundef @__func__.SSL_read_early_data)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786689, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %sw.bb
  br label %sw.bb10

sw.bb10:                                          ; preds = %if.end9, %if.end
  %10 = load ptr, ptr %sc, align 8
  %early_data_state11 = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 14
  store i32 9, ptr %early_data_state11, align 8
  %11 = load ptr, ptr %s.addr, align 8
  %call12 = call i32 @SSL_accept(ptr noundef %11)
  store i32 %call12, ptr %ret, align 4
  %12 = load i32, ptr %ret, align 4
  %cmp13 = icmp sle i32 %12, 0
  br i1 %cmp13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %sw.bb10
  %13 = load ptr, ptr %sc, align 8
  %early_data_state15 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 14
  store i32 8, ptr %early_data_state15, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %sw.bb10
  br label %sw.bb17

sw.bb17:                                          ; preds = %if.end16, %if.end
  %14 = load ptr, ptr %sc, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 80
  %early_data = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 30
  %15 = load i32, ptr %early_data, align 8
  %cmp18 = icmp eq i32 %15, 2
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %sw.bb17
  %16 = load ptr, ptr %sc, align 8
  %early_data_state20 = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 14
  store i32 11, ptr %early_data_state20, align 8
  %17 = load ptr, ptr %s.addr, align 8
  %18 = load ptr, ptr %buf.addr, align 8
  %19 = load i64, ptr %num.addr, align 8
  %20 = load ptr, ptr %readbytes.addr, align 8
  %call21 = call i32 @SSL_read_ex(ptr noundef %17, ptr noundef %18, i64 noundef %19, ptr noundef %20)
  store i32 %call21, ptr %ret, align 4
  %21 = load i32, ptr %ret, align 4
  %cmp22 = icmp sgt i32 %21, 0
  br i1 %cmp22, label %if.then27, label %lor.lhs.false23

lor.lhs.false23:                                  ; preds = %if.then19
  %22 = load i32, ptr %ret, align 4
  %cmp24 = icmp sle i32 %22, 0
  br i1 %cmp24, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %lor.lhs.false23
  %23 = load ptr, ptr %sc, align 8
  %early_data_state25 = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 14
  %24 = load i32, ptr %early_data_state25, align 8
  %cmp26 = icmp ne i32 %24, 12
  br i1 %cmp26, label %if.then27, label %if.end31

if.then27:                                        ; preds = %land.lhs.true, %if.then19
  %25 = load ptr, ptr %sc, align 8
  %early_data_state28 = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 14
  store i32 10, ptr %early_data_state28, align 8
  %26 = load i32, ptr %ret, align 4
  %cmp29 = icmp sgt i32 %26, 0
  %cond30 = select i1 %cmp29, i32 1, i32 0
  store i32 %cond30, ptr %retval, align 4
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %lor.lhs.false23
  br label %if.end33

if.else:                                          ; preds = %sw.bb17
  %27 = load ptr, ptr %sc, align 8
  %early_data_state32 = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 14
  store i32 12, ptr %early_data_state32, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.else, %if.end31
  %28 = load ptr, ptr %readbytes.addr, align 8
  store i64 0, ptr %28, align 8
  store i32 2, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2429, ptr noundef @__func__.SSL_read_early_data)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786689, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %if.end33, %if.then27, %if.then14, %if.then8, %if.then
  %29 = load i32, ptr %retval, align 4
  ret i32 %29
}

declare i32 @SSL_in_before(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_early_data_status(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 80
  %early_data = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 30
  %6 = load i32, ptr %early_data, align 8
  store i32 %6, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define i32 @SSL_peek(ptr noundef %s, ptr noundef %buf, i32 noundef %num) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i32, align 4
  %ret = alloca i32, align 4
  %readbytes = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i32 %num, ptr %num.addr, align 4
  %0 = load i32, ptr %num.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2489, ptr noundef @__func__.SSL_peek)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 271, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i32, ptr %num.addr, align 4
  %conv = sext i32 %3 to i64
  %call = call i32 @ssl_peek_internal(ptr noundef %1, ptr noundef %2, i64 noundef %conv, ptr noundef %readbytes)
  store i32 %call, ptr %ret, align 4
  %4 = load i32, ptr %ret, align 4
  %cmp1 = icmp sgt i32 %4, 0
  br i1 %cmp1, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %5 = load i64, ptr %readbytes, align 8
  %conv4 = trunc i64 %5 to i32
  store i32 %conv4, ptr %ret, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %6 = load i32, ptr %ret, align 4
  store i32 %6, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @ssl_peek_internal(ptr noundef %s, ptr noundef %buf, i64 noundef %num, ptr noundef %readbytes) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i64, align 8
  %readbytes.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  %args = alloca %struct.ssl_async_args, align 8
  %ret = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %num, ptr %num.addr, align 8
  store ptr %readbytes, ptr %readbytes.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 3
  %14 = load ptr, ptr %method, align 8
  %ssl_peek = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 12
  %15 = load ptr, ptr %ssl_peek, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load ptr, ptr %buf.addr, align 8
  %18 = load i64, ptr %num.addr, align 8
  %19 = load ptr, ptr %readbytes.addr, align 8
  %call = call i32 %15(ptr noundef %16, ptr noundef %17, i64 noundef %18, ptr noundef %19)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %20 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %20, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %21 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 6
  %22 = load ptr, ptr %handshake_func, align 8
  %cmp20 = icmp eq ptr %22, null
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end19
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2458, ptr noundef @__func__.ssl_peek_internal)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 276, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end19
  %23 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 10
  %24 = load i32, ptr %shutdown, align 4
  %and = and i32 %24, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end22
  store i32 0, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end22
  %25 = load ptr, ptr %sc, align 8
  %mode = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 71
  %26 = load i32, ptr %mode, align 8
  %and25 = and i32 %26, 256
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %land.lhs.true27, label %if.else

land.lhs.true27:                                  ; preds = %if.end24
  %call28 = call ptr @ASYNC_get_current_job()
  %cmp29 = icmp eq ptr %call28, null
  br i1 %cmp29, label %if.then30, label %if.else

if.then30:                                        ; preds = %land.lhs.true27
  %27 = load ptr, ptr %s.addr, align 8
  %s31 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 0
  store ptr %27, ptr %s31, align 8
  %28 = load ptr, ptr %buf.addr, align 8
  %buf32 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 1
  store ptr %28, ptr %buf32, align 8
  %29 = load i64, ptr %num.addr, align 8
  %num33 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 2
  store i64 %29, ptr %num33, align 8
  %type34 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 3
  store i32 0, ptr %type34, align 8
  %30 = load ptr, ptr %s.addr, align 8
  %method35 = getelementptr inbounds %struct.ssl_st, ptr %30, i32 0, i32 3
  %31 = load ptr, ptr %method35, align 8
  %ssl_peek36 = getelementptr inbounds %struct.ssl_method_st, ptr %31, i32 0, i32 12
  %32 = load ptr, ptr %ssl_peek36, align 8
  %f = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 4
  store ptr %32, ptr %f, align 8
  %33 = load ptr, ptr %s.addr, align 8
  %call37 = call i32 @ssl_start_async_job(ptr noundef %33, ptr noundef %args, ptr noundef @ssl_io_intern)
  store i32 %call37, ptr %ret, align 4
  %34 = load ptr, ptr %sc, align 8
  %asyncrw = getelementptr inbounds %struct.ssl_connection_st, ptr %34, i32 0, i32 105
  %35 = load i64, ptr %asyncrw, align 8
  %36 = load ptr, ptr %readbytes.addr, align 8
  store i64 %35, ptr %36, align 8
  %37 = load i32, ptr %ret, align 4
  store i32 %37, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true27, %if.end24
  %38 = load ptr, ptr %s.addr, align 8
  %method38 = getelementptr inbounds %struct.ssl_st, ptr %38, i32 0, i32 3
  %39 = load ptr, ptr %method38, align 8
  %ssl_peek39 = getelementptr inbounds %struct.ssl_method_st, ptr %39, i32 0, i32 12
  %40 = load ptr, ptr %ssl_peek39, align 8
  %41 = load ptr, ptr %s.addr, align 8
  %42 = load ptr, ptr %buf.addr, align 8
  %43 = load i64, ptr %num.addr, align 8
  %44 = load ptr, ptr %readbytes.addr, align 8
  %call40 = call i32 %40(ptr noundef %41, ptr noundef %42, i64 noundef %43, ptr noundef %44)
  store i32 %call40, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then30, %if.then23, %if.then21, %if.then18, %if.then
  %45 = load i32, ptr %retval, align 4
  ret i32 %45
}

; Function Attrs: nounwind uwtable
define i32 @SSL_peek_ex(ptr noundef %s, ptr noundef %buf, i64 noundef %num, ptr noundef %readbytes) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i64, align 8
  %readbytes.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %num, ptr %num.addr, align 8
  store ptr %readbytes, ptr %readbytes.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %buf.addr, align 8
  %2 = load i64, ptr %num.addr, align 8
  %3 = load ptr, ptr %readbytes.addr, align 8
  %call = call i32 @ssl_peek_internal(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3)
  store i32 %call, ptr %ret, align 4
  %4 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %ret, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %ret, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define i32 @ssl_write_internal(ptr noundef %s, ptr noundef %buf, i64 noundef %num, ptr noundef %written) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i64, align 8
  %written.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  %ret = alloca i32, align 4
  %args = alloca %struct.ssl_async_args, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %num, ptr %num.addr, align 8
  store ptr %written, ptr %written.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 3
  %14 = load ptr, ptr %method, align 8
  %ssl_write = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 13
  %15 = load ptr, ptr %ssl_write, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load ptr, ptr %buf.addr, align 8
  %18 = load i64, ptr %num.addr, align 8
  %19 = load ptr, ptr %written.addr, align 8
  %call = call i32 %15(ptr noundef %16, ptr noundef %17, i64 noundef %18, ptr noundef %19)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %20 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %20, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %21 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 6
  %22 = load ptr, ptr %handshake_func, align 8
  %cmp20 = icmp eq ptr %22, null
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end19
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2528, ptr noundef @__func__.ssl_write_internal)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 276, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end19
  %23 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 10
  %24 = load i32, ptr %shutdown, align 4
  %and = and i32 %24, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end22
  %25 = load ptr, ptr %sc, align 8
  %rwstate = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 5
  store i32 1, ptr %rwstate, align 8
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2534, ptr noundef @__func__.ssl_write_internal)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 207, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end22
  %26 = load ptr, ptr %sc, align 8
  %early_data_state = getelementptr inbounds %struct.ssl_connection_st, ptr %26, i32 0, i32 14
  %27 = load i32, ptr %early_data_state, align 8
  %cmp25 = icmp eq i32 %27, 1
  br i1 %cmp25, label %if.then32, label %lor.lhs.false26

lor.lhs.false26:                                  ; preds = %if.end24
  %28 = load ptr, ptr %sc, align 8
  %early_data_state27 = getelementptr inbounds %struct.ssl_connection_st, ptr %28, i32 0, i32 14
  %29 = load i32, ptr %early_data_state27, align 8
  %cmp28 = icmp eq i32 %29, 8
  br i1 %cmp28, label %if.then32, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %lor.lhs.false26
  %30 = load ptr, ptr %sc, align 8
  %early_data_state30 = getelementptr inbounds %struct.ssl_connection_st, ptr %30, i32 0, i32 14
  %31 = load i32, ptr %early_data_state30, align 8
  %cmp31 = icmp eq i32 %31, 10
  br i1 %cmp31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %lor.lhs.false29, %lor.lhs.false26, %if.end24
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2541, ptr noundef @__func__.ssl_write_internal)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786689, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end33:                                         ; preds = %lor.lhs.false29
  %32 = load ptr, ptr %sc, align 8
  call void @ossl_statem_check_finish_init(ptr noundef %32, i32 noundef 1)
  %33 = load ptr, ptr %sc, align 8
  %mode = getelementptr inbounds %struct.ssl_connection_st, ptr %33, i32 0, i32 71
  %34 = load i32, ptr %mode, align 8
  %and34 = and i32 %34, 256
  %tobool35 = icmp ne i32 %and34, 0
  br i1 %tobool35, label %land.lhs.true36, label %if.else

land.lhs.true36:                                  ; preds = %if.end33
  %call37 = call ptr @ASYNC_get_current_job()
  %cmp38 = icmp eq ptr %call37, null
  br i1 %cmp38, label %if.then39, label %if.else

if.then39:                                        ; preds = %land.lhs.true36
  %35 = load ptr, ptr %s.addr, align 8
  %s40 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 0
  store ptr %35, ptr %s40, align 8
  %36 = load ptr, ptr %buf.addr, align 8
  %buf41 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 1
  store ptr %36, ptr %buf41, align 8
  %37 = load i64, ptr %num.addr, align 8
  %num42 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 2
  store i64 %37, ptr %num42, align 8
  %type43 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 3
  store i32 1, ptr %type43, align 8
  %38 = load ptr, ptr %s.addr, align 8
  %method44 = getelementptr inbounds %struct.ssl_st, ptr %38, i32 0, i32 3
  %39 = load ptr, ptr %method44, align 8
  %ssl_write45 = getelementptr inbounds %struct.ssl_method_st, ptr %39, i32 0, i32 13
  %40 = load ptr, ptr %ssl_write45, align 8
  %f = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 4
  store ptr %40, ptr %f, align 8
  %41 = load ptr, ptr %s.addr, align 8
  %call46 = call i32 @ssl_start_async_job(ptr noundef %41, ptr noundef %args, ptr noundef @ssl_io_intern)
  store i32 %call46, ptr %ret, align 4
  %42 = load ptr, ptr %sc, align 8
  %asyncrw = getelementptr inbounds %struct.ssl_connection_st, ptr %42, i32 0, i32 105
  %43 = load i64, ptr %asyncrw, align 8
  %44 = load ptr, ptr %written.addr, align 8
  store i64 %43, ptr %44, align 8
  %45 = load i32, ptr %ret, align 4
  store i32 %45, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true36, %if.end33
  %46 = load ptr, ptr %s.addr, align 8
  %method47 = getelementptr inbounds %struct.ssl_st, ptr %46, i32 0, i32 3
  %47 = load ptr, ptr %method47, align 8
  %ssl_write48 = getelementptr inbounds %struct.ssl_method_st, ptr %47, i32 0, i32 13
  %48 = load ptr, ptr %ssl_write48, align 8
  %49 = load ptr, ptr %s.addr, align 8
  %50 = load ptr, ptr %buf.addr, align 8
  %51 = load i64, ptr %num.addr, align 8
  %52 = load ptr, ptr %written.addr, align 8
  %call49 = call i32 %48(ptr noundef %49, ptr noundef %50, i64 noundef %51, ptr noundef %52)
  store i32 %call49, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then39, %if.then32, %if.then23, %if.then21, %if.then18, %if.then
  %53 = load i32, ptr %retval, align 4
  ret i32 %53
}

; Function Attrs: nounwind uwtable
define i64 @SSL_sendfile(ptr noundef %s, i32 noundef %fd, i64 noundef %offset, i64 noundef %size, i32 noundef %flags) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %fd.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %fd, ptr %fd.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %handshake_func, align 8
  %cmp7 = icmp eq ptr %6, null
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2574, ptr noundef @__func__.SSL_sendfile)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 276, ptr noundef null)
  store i64 -1, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.end
  %7 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %7, i32 0, i32 10
  %8 = load i32, ptr %shutdown, align 4
  %and = and i32 %8, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end9
  %9 = load ptr, ptr %sc, align 8
  %rwstate = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 5
  store i32 1, ptr %rwstate, align 8
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2580, ptr noundef @__func__.SSL_sendfile)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 207, ptr noundef null)
  store i64 -1, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end9
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2585, ptr noundef @__func__.SSL_sendfile)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 276, ptr noundef null)
  store i64 -1, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then10, %if.then8, %if.then
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

; Function Attrs: nounwind uwtable
define i32 @SSL_write(ptr noundef %s, ptr noundef %buf, i32 noundef %num) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i32, align 4
  %ret = alloca i32, align 4
  %written = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i32 %num, ptr %num.addr, align 4
  %0 = load i32, ptr %num.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2639, ptr noundef @__func__.SSL_write)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 271, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i32, ptr %num.addr, align 4
  %conv = sext i32 %3 to i64
  %call = call i32 @ssl_write_internal(ptr noundef %1, ptr noundef %2, i64 noundef %conv, ptr noundef %written)
  store i32 %call, ptr %ret, align 4
  %4 = load i32, ptr %ret, align 4
  %cmp1 = icmp sgt i32 %4, 0
  br i1 %cmp1, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %5 = load i64, ptr %written, align 8
  %conv4 = trunc i64 %5 to i32
  store i32 %conv4, ptr %ret, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %6 = load i32, ptr %ret, align 4
  store i32 %6, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define i32 @SSL_write_ex(ptr noundef %s, ptr noundef %buf, i64 noundef %num, ptr noundef %written) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i64, align 8
  %written.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %num, ptr %num.addr, align 8
  store ptr %written, ptr %written.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %buf.addr, align 8
  %2 = load i64, ptr %num.addr, align 8
  %3 = load ptr, ptr %written.addr, align 8
  %call = call i32 @ssl_write_internal(ptr noundef %0, ptr noundef %1, i64 noundef %2, ptr noundef %3)
  store i32 %call, ptr %ret, align 4
  %4 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %ret, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %ret, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define i32 @SSL_write_early_data(ptr noundef %s, ptr noundef %buf, i64 noundef %num, ptr noundef %written) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %num.addr = alloca i64, align 8
  %written.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %early_data_state = alloca i32, align 4
  %writtmp = alloca i64, align 8
  %partialwrite = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %num, ptr %num.addr, align 8
  store ptr %written, ptr %written.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %early_data_state7 = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 14
  %6 = load i32, ptr %early_data_state7, align 8
  switch i32 %6, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb17
    i32 3, label %sw.bb24
    i32 5, label %sw.bb35
    i32 12, label %sw.bb41
    i32 10, label %sw.bb41
  ]

sw.bb:                                            ; preds = %if.end
  %7 = load ptr, ptr %sc, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %7, i32 0, i32 7
  %8 = load i32, ptr %server, align 8
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb
  %9 = load ptr, ptr %s.addr, align 8
  %call = call i32 @SSL_in_before(ptr noundef %9)
  %tobool8 = icmp ne i32 %call, 0
  br i1 %tobool8, label %lor.lhs.false9, label %if.then15

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %10 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 50
  %11 = load ptr, ptr %session, align 8
  %cmp10 = icmp eq ptr %11, null
  br i1 %cmp10, label %land.lhs.true, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %lor.lhs.false9
  %12 = load ptr, ptr %sc, align 8
  %session12 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 50
  %13 = load ptr, ptr %session12, align 8
  %ext = getelementptr inbounds %struct.ssl_session_st, ptr %13, i32 0, i32 26
  %max_early_data = getelementptr inbounds %struct.anon.5, ptr %ext, i32 0, i32 5
  %14 = load i32, ptr %max_early_data, align 4
  %cmp13 = icmp eq i32 %14, 0
  br i1 %cmp13, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %lor.lhs.false11, %lor.lhs.false9
  %15 = load ptr, ptr %sc, align 8
  %psk_use_session_cb = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 65
  %16 = load ptr, ptr %psk_use_session_cb, align 8
  %cmp14 = icmp eq ptr %16, null
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true, %lor.lhs.false, %sw.bb
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2681, ptr noundef @__func__.SSL_write_early_data)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786689, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %lor.lhs.false11
  br label %sw.bb17

sw.bb17:                                          ; preds = %if.end16, %if.end
  %17 = load ptr, ptr %sc, align 8
  %early_data_state18 = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 14
  store i32 2, ptr %early_data_state18, align 8
  %18 = load ptr, ptr %s.addr, align 8
  %call19 = call i32 @SSL_connect(ptr noundef %18)
  store i32 %call19, ptr %ret, align 4
  %19 = load i32, ptr %ret, align 4
  %cmp20 = icmp sle i32 %19, 0
  br i1 %cmp20, label %if.then21, label %if.end23

if.then21:                                        ; preds = %sw.bb17
  %20 = load ptr, ptr %sc, align 8
  %early_data_state22 = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 14
  store i32 1, ptr %early_data_state22, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %sw.bb17
  br label %sw.bb24

sw.bb24:                                          ; preds = %if.end23, %if.end
  %21 = load ptr, ptr %sc, align 8
  %early_data_state25 = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 14
  store i32 4, ptr %early_data_state25, align 8
  %22 = load ptr, ptr %sc, align 8
  %mode = getelementptr inbounds %struct.ssl_connection_st, ptr %22, i32 0, i32 71
  %23 = load i32, ptr %mode, align 8
  %and = and i32 %23, 1
  store i32 %and, ptr %partialwrite, align 4
  %24 = load ptr, ptr %sc, align 8
  %mode26 = getelementptr inbounds %struct.ssl_connection_st, ptr %24, i32 0, i32 71
  %25 = load i32, ptr %mode26, align 8
  %and27 = and i32 %25, -2
  store i32 %and27, ptr %mode26, align 8
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load ptr, ptr %buf.addr, align 8
  %28 = load i64, ptr %num.addr, align 8
  %call28 = call i32 @SSL_write_ex(ptr noundef %26, ptr noundef %27, i64 noundef %28, ptr noundef %writtmp)
  store i32 %call28, ptr %ret, align 4
  %29 = load i32, ptr %partialwrite, align 4
  %30 = load ptr, ptr %sc, align 8
  %mode29 = getelementptr inbounds %struct.ssl_connection_st, ptr %30, i32 0, i32 71
  %31 = load i32, ptr %mode29, align 8
  %or = or i32 %31, %29
  store i32 %or, ptr %mode29, align 8
  %32 = load i32, ptr %ret, align 4
  %tobool30 = icmp ne i32 %32, 0
  br i1 %tobool30, label %if.end33, label %if.then31

if.then31:                                        ; preds = %sw.bb24
  %33 = load ptr, ptr %sc, align 8
  %early_data_state32 = getelementptr inbounds %struct.ssl_connection_st, ptr %33, i32 0, i32 14
  store i32 3, ptr %early_data_state32, align 8
  %34 = load i32, ptr %ret, align 4
  store i32 %34, ptr %retval, align 4
  br label %return

if.end33:                                         ; preds = %sw.bb24
  %35 = load ptr, ptr %sc, align 8
  %early_data_state34 = getelementptr inbounds %struct.ssl_connection_st, ptr %35, i32 0, i32 14
  store i32 5, ptr %early_data_state34, align 8
  br label %sw.bb35

sw.bb35:                                          ; preds = %if.end33, %if.end
  %36 = load ptr, ptr %sc, align 8
  %call36 = call i32 @statem_flush(ptr noundef %36)
  %cmp37 = icmp ne i32 %call36, 1
  br i1 %cmp37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %sw.bb35
  store i32 0, ptr %retval, align 4
  br label %return

if.end39:                                         ; preds = %sw.bb35
  %37 = load i64, ptr %num.addr, align 8
  %38 = load ptr, ptr %written.addr, align 8
  store i64 %37, ptr %38, align 8
  %39 = load ptr, ptr %sc, align 8
  %early_data_state40 = getelementptr inbounds %struct.ssl_connection_st, ptr %39, i32 0, i32 14
  store i32 3, ptr %early_data_state40, align 8
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb41:                                          ; preds = %if.end, %if.end
  %40 = load ptr, ptr %sc, align 8
  %early_data_state42 = getelementptr inbounds %struct.ssl_connection_st, ptr %40, i32 0, i32 14
  %41 = load i32, ptr %early_data_state42, align 8
  store i32 %41, ptr %early_data_state, align 4
  %42 = load ptr, ptr %sc, align 8
  %early_data_state43 = getelementptr inbounds %struct.ssl_connection_st, ptr %42, i32 0, i32 14
  store i32 6, ptr %early_data_state43, align 8
  %43 = load ptr, ptr %s.addr, align 8
  %44 = load ptr, ptr %buf.addr, align 8
  %45 = load i64, ptr %num.addr, align 8
  %46 = load ptr, ptr %written.addr, align 8
  %call44 = call i32 @SSL_write_ex(ptr noundef %43, ptr noundef %44, i64 noundef %45, ptr noundef %46)
  store i32 %call44, ptr %ret, align 4
  %47 = load i32, ptr %ret, align 4
  %tobool45 = icmp ne i32 %47, 0
  br i1 %tobool45, label %if.then46, label %if.end48

if.then46:                                        ; preds = %sw.bb41
  %48 = load ptr, ptr %sc, align 8
  %wbio = getelementptr inbounds %struct.ssl_connection_st, ptr %48, i32 0, i32 3
  %49 = load ptr, ptr %wbio, align 8
  %call47 = call i64 @BIO_ctrl(ptr noundef %49, i32 noundef 11, i64 noundef 0, ptr noundef null)
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %sw.bb41
  %50 = load i32, ptr %early_data_state, align 4
  %51 = load ptr, ptr %sc, align 8
  %early_data_state49 = getelementptr inbounds %struct.ssl_connection_st, ptr %51, i32 0, i32 14
  store i32 %50, ptr %early_data_state49, align 8
  %52 = load i32, ptr %ret, align 4
  store i32 %52, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2735, ptr noundef @__func__.SSL_write_early_data)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786689, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %if.end48, %if.end39, %if.then38, %if.then31, %if.then21, %if.then15, %if.then
  %53 = load i32, ptr %retval, align 4
  ret i32 %53
}

declare i32 @statem_flush(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_shutdown(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  %args = alloca %struct.ssl_async_args, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_conn_shutdown(ptr noundef %13, i64 noundef 0, ptr noundef null, i64 noundef 0)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %14 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %14, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %15 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 6
  %16 = load ptr, ptr %handshake_func, align 8
  %cmp20 = icmp eq ptr %16, null
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end19
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2759, ptr noundef @__func__.SSL_shutdown)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 276, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end19
  %17 = load ptr, ptr %s.addr, align 8
  %call23 = call i32 @SSL_in_init(ptr noundef %17)
  %tobool = icmp ne i32 %call23, 0
  br i1 %tobool, label %if.else36, label %if.then24

if.then24:                                        ; preds = %if.end22
  %18 = load ptr, ptr %sc, align 8
  %mode = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 71
  %19 = load i32, ptr %mode, align 8
  %and = and i32 %19, 256
  %tobool25 = icmp ne i32 %and, 0
  br i1 %tobool25, label %land.lhs.true26, label %if.else

land.lhs.true26:                                  ; preds = %if.then24
  %call27 = call ptr @ASYNC_get_current_job()
  %cmp28 = icmp eq ptr %call27, null
  br i1 %cmp28, label %if.then29, label %if.else

if.then29:                                        ; preds = %land.lhs.true26
  call void @llvm.memset.p0.i64(ptr align 8 %args, i8 0, i64 40, i1 false)
  %20 = load ptr, ptr %s.addr, align 8
  %s30 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 0
  store ptr %20, ptr %s30, align 8
  %type31 = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 3
  store i32 2, ptr %type31, align 8
  %21 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %21, i32 0, i32 3
  %22 = load ptr, ptr %method, align 8
  %ssl_shutdown = getelementptr inbounds %struct.ssl_method_st, ptr %22, i32 0, i32 14
  %23 = load ptr, ptr %ssl_shutdown, align 8
  %f = getelementptr inbounds %struct.ssl_async_args, ptr %args, i32 0, i32 4
  store ptr %23, ptr %f, align 8
  %24 = load ptr, ptr %s.addr, align 8
  %call32 = call i32 @ssl_start_async_job(ptr noundef %24, ptr noundef %args, ptr noundef @ssl_io_intern)
  store i32 %call32, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true26, %if.then24
  %25 = load ptr, ptr %s.addr, align 8
  %method33 = getelementptr inbounds %struct.ssl_st, ptr %25, i32 0, i32 3
  %26 = load ptr, ptr %method33, align 8
  %ssl_shutdown34 = getelementptr inbounds %struct.ssl_method_st, ptr %26, i32 0, i32 14
  %27 = load ptr, ptr %ssl_shutdown34, align 8
  %28 = load ptr, ptr %s.addr, align 8
  %call35 = call i32 %27(ptr noundef %28)
  store i32 %call35, ptr %retval, align 4
  br label %return

if.else36:                                        ; preds = %if.end22
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2777, ptr noundef @__func__.SSL_shutdown)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 407, ptr noundef null)
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else36, %if.else, %if.then29, %if.then21, %if.then18, %if.then
  %29 = load i32, ptr %retval, align 4
  ret i32 %29
}

declare i32 @ossl_quic_conn_shutdown(ptr noundef, i64 noundef, ptr noundef, i64 noundef) #1

declare i32 @SSL_in_init(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_key_update(ptr noundef %s, i32 noundef %updatetype) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %updatetype.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %updatetype, ptr %updatetype.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load i32, ptr %updatetype.addr, align 4
  %call = call i32 @ossl_quic_key_update(ptr noundef %13, i32 noundef %14)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %15 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %15, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %16 = load ptr, ptr %sc, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %17 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %17, i32 0, i32 28
  %18 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %18, i32 0, i32 10
  %19 = load i32, ptr %enc_flags, align 8
  %and = and i32 %19, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then29, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %if.end19
  %20 = load ptr, ptr %sc, align 8
  %ssl21 = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 0
  %method22 = getelementptr inbounds %struct.ssl_st, ptr %ssl21, i32 0, i32 3
  %21 = load ptr, ptr %method22, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %21, i32 0, i32 0
  %22 = load i32, ptr %version, align 8
  %cmp23 = icmp sge i32 %22, 772
  br i1 %cmp23, label %land.lhs.true24, label %if.then29

land.lhs.true24:                                  ; preds = %land.lhs.true20
  %23 = load ptr, ptr %sc, align 8
  %ssl25 = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 0
  %method26 = getelementptr inbounds %struct.ssl_st, ptr %ssl25, i32 0, i32 3
  %24 = load ptr, ptr %method26, align 8
  %version27 = getelementptr inbounds %struct.ssl_method_st, ptr %24, i32 0, i32 0
  %25 = load i32, ptr %version27, align 8
  %cmp28 = icmp ne i32 %25, 65536
  br i1 %cmp28, label %if.end30, label %if.then29

if.then29:                                        ; preds = %land.lhs.true24, %land.lhs.true20, %if.end19
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2795, ptr noundef @__func__.SSL_key_update)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 266, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end30:                                         ; preds = %land.lhs.true24
  %26 = load i32, ptr %updatetype.addr, align 4
  %cmp31 = icmp ne i32 %26, 0
  br i1 %cmp31, label %land.lhs.true32, label %if.end35

land.lhs.true32:                                  ; preds = %if.end30
  %27 = load i32, ptr %updatetype.addr, align 4
  %cmp33 = icmp ne i32 %27, 1
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %land.lhs.true32
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2801, ptr noundef @__func__.SSL_key_update)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 120, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end35:                                         ; preds = %land.lhs.true32, %if.end30
  %28 = load ptr, ptr %s.addr, align 8
  %call36 = call i32 @SSL_is_init_finished(ptr noundef %28)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.end39, label %if.then38

if.then38:                                        ; preds = %if.end35
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2806, ptr noundef @__func__.SSL_key_update)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 121, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end39:                                         ; preds = %if.end35
  %29 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %29, i32 0, i32 100
  %call40 = call i32 @RECORD_LAYER_write_pending(ptr noundef %rlayer)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.end39
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2811, ptr noundef @__func__.SSL_key_update)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 127, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end43:                                         ; preds = %if.end39
  %30 = load ptr, ptr %sc, align 8
  call void @ossl_statem_set_in_init(ptr noundef %30, i32 noundef 1)
  %31 = load i32, ptr %updatetype.addr, align 4
  %32 = load ptr, ptr %sc, align 8
  %key_update = getelementptr inbounds %struct.ssl_connection_st, ptr %32, i32 0, i32 91
  store i32 %31, ptr %key_update, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end43, %if.then42, %if.then38, %if.then34, %if.then29, %if.then18, %if.then
  %33 = load i32, ptr %retval, align 4
  ret i32 %33
}

declare i32 @ossl_quic_key_update(ptr noundef, i32 noundef) #1

declare i32 @SSL_is_init_finished(ptr noundef) #1

declare i32 @RECORD_LAYER_write_pending(ptr noundef) #1

declare void @ossl_statem_set_in_init(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_key_update_type(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_get_key_update_type(ptr noundef %13)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %14 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %14, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %15 = load ptr, ptr %sc, align 8
  %key_update = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 91
  %16 = load i32, ptr %key_update, align 4
  store i32 %16, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

declare i32 @ossl_quic_get_key_update_type(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_renegotiate(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %call = call i32 @can_renegotiate(ptr noundef %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %6 = load ptr, ptr %sc, align 8
  %renegotiate = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 90
  store i32 1, ptr %renegotiate, align 8
  %7 = load ptr, ptr %sc, align 8
  %new_session = getelementptr inbounds %struct.ssl_connection_st, ptr %7, i32 0, i32 8
  store i32 1, ptr %new_session, align 4
  %8 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %method, align 8
  %ssl_renegotiate = getelementptr inbounds %struct.ssl_method_st, ptr %9, i32 0, i32 15
  %10 = load ptr, ptr %ssl_renegotiate, align 8
  %11 = load ptr, ptr %s.addr, align 8
  %call9 = call i32 %10(ptr noundef %11)
  store i32 %call9, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then7, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define internal i32 @can_renegotiate(ptr noundef %sc) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca ptr, align 8
  store ptr %sc, ptr %sc.addr, align 8
  %0 = load ptr, ptr %sc.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %1 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %1, i32 0, i32 28
  %2 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %2, i32 0, i32 10
  %3 = load i32, ptr %enc_flags, align 8
  %and = and i32 %3, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %4 = load ptr, ptr %sc.addr, align 8
  %ssl1 = getelementptr inbounds %struct.ssl_connection_st, ptr %4, i32 0, i32 0
  %method2 = getelementptr inbounds %struct.ssl_st, ptr %ssl1, i32 0, i32 3
  %5 = load ptr, ptr %method2, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %version, align 8
  %cmp = icmp sge i32 %6, 772
  br i1 %cmp, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %7 = load ptr, ptr %sc.addr, align 8
  %ssl4 = getelementptr inbounds %struct.ssl_connection_st, ptr %7, i32 0, i32 0
  %method5 = getelementptr inbounds %struct.ssl_st, ptr %ssl4, i32 0, i32 3
  %8 = load ptr, ptr %method5, align 8
  %version6 = getelementptr inbounds %struct.ssl_method_st, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %version6, align 8
  %cmp7 = icmp ne i32 %9, 65536
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true3
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2842, ptr noundef @__func__.can_renegotiate)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 266, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %10 = load ptr, ptr %sc.addr, align 8
  %options = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 70
  %11 = load i64, ptr %options, align 8
  %and8 = and i64 %11, 1073741824
  %cmp9 = icmp ne i64 %and8, 0
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 2847, ptr noundef @__func__.can_renegotiate)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 339, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then10, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define i32 @SSL_renegotiate_abbreviated(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %call = call i32 @can_renegotiate(ptr noundef %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %6 = load ptr, ptr %sc, align 8
  %renegotiate = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 90
  store i32 1, ptr %renegotiate, align 8
  %7 = load ptr, ptr %sc, align 8
  %new_session = getelementptr inbounds %struct.ssl_connection_st, ptr %7, i32 0, i32 8
  store i32 0, ptr %new_session, align 4
  %8 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %method, align 8
  %ssl_renegotiate = getelementptr inbounds %struct.ssl_method_st, ptr %9, i32 0, i32 15
  %10 = load ptr, ptr %ssl_renegotiate, align 8
  %11 = load ptr, ptr %s.addr, align 8
  %call9 = call i32 %10(ptr noundef %11)
  store i32 %call9, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then7, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define i32 @SSL_renegotiate_pending(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %renegotiate = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 90
  %6 = load i32, ptr %renegotiate, align 8
  %cmp7 = icmp ne i32 %6, 0
  %conv = zext i1 %cmp7 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define i32 @SSL_new_session_ticket(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %call = call i32 @SSL_in_init(ptr noundef %9)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end
  %10 = load ptr, ptr %sc, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 80
  %extra_tickets_expected = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 10
  %11 = load i32, ptr %extra_tickets_expected, align 4
  %cmp13 = icmp eq i32 %11, 0
  br i1 %cmp13, label %if.then32, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end
  %12 = load ptr, ptr %sc, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 20
  %tmp = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 14
  %finish_md_len = getelementptr inbounds %struct.anon.0, ptr %tmp, i32 0, i32 1
  %13 = load i64, ptr %finish_md_len, align 8
  %cmp14 = icmp eq i64 %13, 0
  br i1 %cmp14, label %if.then32, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %lor.lhs.false
  %14 = load ptr, ptr %sc, align 8
  %s316 = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 20
  %tmp17 = getelementptr inbounds %struct.anon, ptr %s316, i32 0, i32 14
  %peer_finish_md_len = getelementptr inbounds %struct.anon.0, ptr %tmp17, i32 0, i32 3
  %15 = load i64, ptr %peer_finish_md_len, align 8
  %cmp18 = icmp eq i64 %15, 0
  br i1 %cmp18, label %if.then32, label %lor.lhs.false19

lor.lhs.false19:                                  ; preds = %lor.lhs.false15
  %16 = load ptr, ptr %sc, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 7
  %17 = load i32, ptr %server, align 8
  %tobool20 = icmp ne i32 %17, 0
  br i1 %tobool20, label %lor.lhs.false21, label %if.then32

lor.lhs.false21:                                  ; preds = %lor.lhs.false19
  %18 = load ptr, ptr %sc, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %19 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %19, i32 0, i32 28
  %20 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %20, i32 0, i32 10
  %21 = load i32, ptr %enc_flags, align 8
  %and = and i32 %21, 8
  %tobool22 = icmp ne i32 %and, 0
  br i1 %tobool22, label %if.then32, label %land.lhs.true23

land.lhs.true23:                                  ; preds = %lor.lhs.false21
  %22 = load ptr, ptr %sc, align 8
  %ssl24 = getelementptr inbounds %struct.ssl_connection_st, ptr %22, i32 0, i32 0
  %method25 = getelementptr inbounds %struct.ssl_st, ptr %ssl24, i32 0, i32 3
  %23 = load ptr, ptr %method25, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %23, i32 0, i32 0
  %24 = load i32, ptr %version, align 8
  %cmp26 = icmp sge i32 %24, 772
  br i1 %cmp26, label %land.lhs.true27, label %if.then32

land.lhs.true27:                                  ; preds = %land.lhs.true23
  %25 = load ptr, ptr %sc, align 8
  %ssl28 = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 0
  %method29 = getelementptr inbounds %struct.ssl_st, ptr %ssl28, i32 0, i32 3
  %26 = load ptr, ptr %method29, align 8
  %version30 = getelementptr inbounds %struct.ssl_method_st, ptr %26, i32 0, i32 0
  %27 = load i32, ptr %version30, align 8
  %cmp31 = icmp ne i32 %27, 65536
  br i1 %cmp31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %land.lhs.true27, %land.lhs.true23, %lor.lhs.false21, %lor.lhs.false19, %lor.lhs.false15, %lor.lhs.false, %land.lhs.true
  store i32 0, ptr %retval, align 4
  br label %return

if.end33:                                         ; preds = %land.lhs.true27
  %28 = load ptr, ptr %sc, align 8
  %ext34 = getelementptr inbounds %struct.ssl_connection_st, ptr %28, i32 0, i32 80
  %extra_tickets_expected35 = getelementptr inbounds %struct.anon.1, ptr %ext34, i32 0, i32 10
  %29 = load i32, ptr %extra_tickets_expected35, align 4
  %inc = add nsw i32 %29, 1
  store i32 %inc, ptr %extra_tickets_expected35, align 4
  %30 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %30, i32 0, i32 100
  %call36 = call i32 @RECORD_LAYER_write_pending(ptr noundef %rlayer)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.end42, label %land.lhs.true38

land.lhs.true38:                                  ; preds = %if.end33
  %31 = load ptr, ptr %s.addr, align 8
  %call39 = call i32 @SSL_in_init(ptr noundef %31)
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %land.lhs.true38
  %32 = load ptr, ptr %sc, align 8
  call void @ossl_statem_set_in_init(ptr noundef %32, i32 noundef 1)
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %land.lhs.true38, %if.end33
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end42, %if.then32, %if.then
  %33 = load i32, ptr %retval, align 4
  ret i32 %33
}

; Function Attrs: nounwind uwtable
define i64 @ossl_ctrl_internal(ptr noundef %s, i32 noundef %cmd, i64 noundef %larg, ptr noundef %parg, i32 noundef %no_quic) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %cmd.addr = alloca i32, align 4
  %larg.addr = alloca i64, align 8
  %parg.addr = alloca ptr, align 8
  %no_quic.addr = alloca i32, align 4
  %l = alloca i64, align 8
  %sc = alloca ptr, align 8
  %options = alloca [2 x %struct.ossl_param_st], align 16
  %opts = alloca ptr, align 8
  %tmp = alloca %struct.ossl_param_st, align 8
  %tmp32 = alloca %struct.ossl_param_st, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %larg, ptr %larg.addr, align 8
  store ptr %parg, ptr %parg.addr, align 8
  store i32 %no_quic, ptr %no_quic.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load i32, ptr %no_quic.addr, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.end20, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %10 = load ptr, ptr %s.addr, align 8
  %cmp13 = icmp ne ptr %10, null
  br i1 %cmp13, label %land.lhs.true14, label %if.end20

land.lhs.true14:                                  ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 1
  br i1 %cmp16, label %if.then19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true14
  %13 = load ptr, ptr %s.addr, align 8
  %type17 = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 0
  %14 = load i32, ptr %type17, align 8
  %cmp18 = icmp eq i32 %14, 2
  br i1 %cmp18, label %if.then19, label %if.end20

if.then19:                                        ; preds = %lor.lhs.false, %land.lhs.true14
  %15 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %15, i32 0, i32 3
  %16 = load ptr, ptr %method, align 8
  %ssl_ctrl = getelementptr inbounds %struct.ssl_method_st, ptr %16, i32 0, i32 20
  %17 = load ptr, ptr %ssl_ctrl, align 8
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load i32, ptr %cmd.addr, align 4
  %20 = load i64, ptr %larg.addr, align 8
  %21 = load ptr, ptr %parg.addr, align 8
  %call = call i64 %17(ptr noundef %18, i32 noundef %19, i64 noundef %20, ptr noundef %21)
  store i64 %call, ptr %retval, align 8
  br label %return

if.end20:                                         ; preds = %lor.lhs.false, %land.lhs.true, %if.end
  %22 = load i32, ptr %cmd.addr, align 4
  switch i32 %22, label %sw.default [
    i32 40, label %sw.bb
    i32 41, label %sw.bb21
    i32 33, label %sw.bb28
    i32 78, label %sw.bb39
    i32 50, label %sw.bb44
    i32 51, label %sw.bb45
    i32 52, label %sw.bb52
    i32 125, label %sw.bb69
    i32 126, label %sw.bb79
    i32 76, label %sw.bb98
    i32 136, label %sw.bb100
    i32 99, label %sw.bb101
    i32 100, label %sw.bb106
    i32 110, label %sw.bb114
    i32 122, label %sw.bb130
    i32 123, label %sw.bb145
    i32 130, label %sw.bb153
    i32 124, label %sw.bb156
    i32 131, label %sw.bb171
  ]

sw.bb:                                            ; preds = %if.end20
  %23 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 100
  %read_ahead = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 9
  %24 = load i32, ptr %read_ahead, align 8
  %conv = sext i32 %24 to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

sw.bb21:                                          ; preds = %if.end20
  %25 = load ptr, ptr %sc, align 8
  %rlayer22 = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 100
  %read_ahead23 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer22, i32 0, i32 9
  %26 = load i32, ptr %read_ahead23, align 8
  %conv24 = sext i32 %26 to i64
  store i64 %conv24, ptr %l, align 8
  %27 = load i64, ptr %larg.addr, align 8
  %conv25 = trunc i64 %27 to i32
  %28 = load ptr, ptr %sc, align 8
  %rlayer26 = getelementptr inbounds %struct.ssl_connection_st, ptr %28, i32 0, i32 100
  %read_ahead27 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer26, i32 0, i32 9
  store i32 %conv25, ptr %read_ahead27, align 8
  %29 = load i64, ptr %l, align 8
  store i64 %29, ptr %retval, align 8
  br label %return

sw.bb28:                                          ; preds = %if.end20
  %arraydecay = getelementptr inbounds [2 x %struct.ossl_param_st], ptr %options, i64 0, i64 0
  store ptr %arraydecay, ptr %opts, align 8
  %30 = load i64, ptr %larg.addr, align 8
  %31 = load ptr, ptr %sc, align 8
  %mode = getelementptr inbounds %struct.ssl_connection_st, ptr %31, i32 0, i32 71
  %32 = load i32, ptr %mode, align 8
  %conv29 = zext i32 %32 to i64
  %or = or i64 %conv29, %30
  %conv30 = trunc i64 %or to i32
  store i32 %conv30, ptr %mode, align 8
  %33 = load ptr, ptr %opts, align 8
  %incdec.ptr = getelementptr inbounds %struct.ossl_param_st, ptr %33, i32 1
  store ptr %incdec.ptr, ptr %opts, align 8
  %34 = load ptr, ptr %sc, align 8
  %mode31 = getelementptr inbounds %struct.ssl_connection_st, ptr %34, i32 0, i32 71
  call void @OSSL_PARAM_construct_uint32(ptr sret(%struct.ossl_param_st) align 8 %tmp, ptr noundef @.str.2, ptr noundef %mode31)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %33, ptr align 8 %tmp, i64 40, i1 false)
  %35 = load ptr, ptr %opts, align 8
  call void @OSSL_PARAM_construct_end(ptr sret(%struct.ossl_param_st) align 8 %tmp32)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %35, ptr align 8 %tmp32, i64 40, i1 false)
  %36 = load ptr, ptr %sc, align 8
  %rlayer33 = getelementptr inbounds %struct.ssl_connection_st, ptr %36, i32 0, i32 100
  %rrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %rlayer33, i32 0, i32 3
  %37 = load ptr, ptr %rrlmethod, align 8
  %set_options = getelementptr inbounds %struct.ossl_record_method_st, ptr %37, i32 0, i32 18
  %38 = load ptr, ptr %set_options, align 8
  %39 = load ptr, ptr %sc, align 8
  %rlayer34 = getelementptr inbounds %struct.ssl_connection_st, ptr %39, i32 0, i32 100
  %rrl = getelementptr inbounds %struct.record_layer_st, ptr %rlayer34, i32 0, i32 5
  %40 = load ptr, ptr %rrl, align 8
  %arraydecay35 = getelementptr inbounds [2 x %struct.ossl_param_st], ptr %options, i64 0, i64 0
  %call36 = call i32 %38(ptr noundef %40, ptr noundef %arraydecay35)
  %41 = load ptr, ptr %sc, align 8
  %mode37 = getelementptr inbounds %struct.ssl_connection_st, ptr %41, i32 0, i32 71
  %42 = load i32, ptr %mode37, align 8
  %conv38 = zext i32 %42 to i64
  store i64 %conv38, ptr %retval, align 8
  br label %return

sw.bb39:                                          ; preds = %if.end20
  %43 = load i64, ptr %larg.addr, align 8
  %not = xor i64 %43, -1
  %44 = load ptr, ptr %sc, align 8
  %mode40 = getelementptr inbounds %struct.ssl_connection_st, ptr %44, i32 0, i32 71
  %45 = load i32, ptr %mode40, align 8
  %conv41 = zext i32 %45 to i64
  %and = and i64 %conv41, %not
  %conv42 = trunc i64 %and to i32
  store i32 %conv42, ptr %mode40, align 8
  %conv43 = zext i32 %conv42 to i64
  store i64 %conv43, ptr %retval, align 8
  br label %return

sw.bb44:                                          ; preds = %if.end20
  %46 = load ptr, ptr %sc, align 8
  %max_cert_list = getelementptr inbounds %struct.ssl_connection_st, ptr %46, i32 0, i32 74
  %47 = load i64, ptr %max_cert_list, align 8
  store i64 %47, ptr %retval, align 8
  br label %return

sw.bb45:                                          ; preds = %if.end20
  %48 = load i64, ptr %larg.addr, align 8
  %cmp46 = icmp slt i64 %48, 0
  br i1 %cmp46, label %if.then48, label %if.end49

if.then48:                                        ; preds = %sw.bb45
  store i64 0, ptr %retval, align 8
  br label %return

if.end49:                                         ; preds = %sw.bb45
  %49 = load ptr, ptr %sc, align 8
  %max_cert_list50 = getelementptr inbounds %struct.ssl_connection_st, ptr %49, i32 0, i32 74
  %50 = load i64, ptr %max_cert_list50, align 8
  store i64 %50, ptr %l, align 8
  %51 = load i64, ptr %larg.addr, align 8
  %52 = load ptr, ptr %sc, align 8
  %max_cert_list51 = getelementptr inbounds %struct.ssl_connection_st, ptr %52, i32 0, i32 74
  store i64 %51, ptr %max_cert_list51, align 8
  %53 = load i64, ptr %l, align 8
  store i64 %53, ptr %retval, align 8
  br label %return

sw.bb52:                                          ; preds = %if.end20
  %54 = load i64, ptr %larg.addr, align 8
  %cmp53 = icmp slt i64 %54, 512
  br i1 %cmp53, label %if.then58, label %lor.lhs.false55

lor.lhs.false55:                                  ; preds = %sw.bb52
  %55 = load i64, ptr %larg.addr, align 8
  %cmp56 = icmp sgt i64 %55, 16384
  br i1 %cmp56, label %if.then58, label %if.end59

if.then58:                                        ; preds = %lor.lhs.false55, %sw.bb52
  store i64 0, ptr %retval, align 8
  br label %return

if.end59:                                         ; preds = %lor.lhs.false55
  %56 = load i64, ptr %larg.addr, align 8
  %57 = load ptr, ptr %sc, align 8
  %max_send_fragment = getelementptr inbounds %struct.ssl_connection_st, ptr %57, i32 0, i32 78
  store i64 %56, ptr %max_send_fragment, align 8
  %58 = load ptr, ptr %sc, align 8
  %max_send_fragment60 = getelementptr inbounds %struct.ssl_connection_st, ptr %58, i32 0, i32 78
  %59 = load i64, ptr %max_send_fragment60, align 8
  %60 = load ptr, ptr %sc, align 8
  %split_send_fragment = getelementptr inbounds %struct.ssl_connection_st, ptr %60, i32 0, i32 77
  %61 = load i64, ptr %split_send_fragment, align 8
  %cmp61 = icmp ult i64 %59, %61
  br i1 %cmp61, label %if.then63, label %if.end66

if.then63:                                        ; preds = %if.end59
  %62 = load ptr, ptr %sc, align 8
  %max_send_fragment64 = getelementptr inbounds %struct.ssl_connection_st, ptr %62, i32 0, i32 78
  %63 = load i64, ptr %max_send_fragment64, align 8
  %64 = load ptr, ptr %sc, align 8
  %split_send_fragment65 = getelementptr inbounds %struct.ssl_connection_st, ptr %64, i32 0, i32 77
  store i64 %63, ptr %split_send_fragment65, align 8
  br label %if.end66

if.end66:                                         ; preds = %if.then63, %if.end59
  %65 = load ptr, ptr %sc, align 8
  %rlayer67 = getelementptr inbounds %struct.ssl_connection_st, ptr %65, i32 0, i32 100
  %wrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %rlayer67, i32 0, i32 4
  %66 = load ptr, ptr %wrlmethod, align 8
  %set_max_frag_len = getelementptr inbounds %struct.ossl_record_method_st, ptr %66, i32 0, i32 20
  %67 = load ptr, ptr %set_max_frag_len, align 8
  %68 = load ptr, ptr %sc, align 8
  %rlayer68 = getelementptr inbounds %struct.ssl_connection_st, ptr %68, i32 0, i32 100
  %wrl = getelementptr inbounds %struct.record_layer_st, ptr %rlayer68, i32 0, i32 6
  %69 = load ptr, ptr %wrl, align 8
  %70 = load i64, ptr %larg.addr, align 8
  call void %67(ptr noundef %69, i64 noundef %70)
  store i64 1, ptr %retval, align 8
  br label %return

sw.bb69:                                          ; preds = %if.end20
  %71 = load i64, ptr %larg.addr, align 8
  %72 = load ptr, ptr %sc, align 8
  %max_send_fragment70 = getelementptr inbounds %struct.ssl_connection_st, ptr %72, i32 0, i32 78
  %73 = load i64, ptr %max_send_fragment70, align 8
  %cmp71 = icmp ugt i64 %71, %73
  br i1 %cmp71, label %if.then76, label %lor.lhs.false73

lor.lhs.false73:                                  ; preds = %sw.bb69
  %74 = load i64, ptr %larg.addr, align 8
  %cmp74 = icmp eq i64 %74, 0
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %lor.lhs.false73, %sw.bb69
  store i64 0, ptr %retval, align 8
  br label %return

if.end77:                                         ; preds = %lor.lhs.false73
  %75 = load i64, ptr %larg.addr, align 8
  %76 = load ptr, ptr %sc, align 8
  %split_send_fragment78 = getelementptr inbounds %struct.ssl_connection_st, ptr %76, i32 0, i32 77
  store i64 %75, ptr %split_send_fragment78, align 8
  store i64 1, ptr %retval, align 8
  br label %return

sw.bb79:                                          ; preds = %if.end20
  %77 = load i64, ptr %larg.addr, align 8
  %cmp80 = icmp slt i64 %77, 1
  br i1 %cmp80, label %if.then85, label %lor.lhs.false82

lor.lhs.false82:                                  ; preds = %sw.bb79
  %78 = load i64, ptr %larg.addr, align 8
  %cmp83 = icmp sgt i64 %78, 32
  br i1 %cmp83, label %if.then85, label %if.end86

if.then85:                                        ; preds = %lor.lhs.false82, %sw.bb79
  store i64 0, ptr %retval, align 8
  br label %return

if.end86:                                         ; preds = %lor.lhs.false82
  %79 = load i64, ptr %larg.addr, align 8
  %80 = load ptr, ptr %sc, align 8
  %max_pipelines = getelementptr inbounds %struct.ssl_connection_st, ptr %80, i32 0, i32 79
  store i64 %79, ptr %max_pipelines, align 8
  %81 = load ptr, ptr %sc, align 8
  %rlayer87 = getelementptr inbounds %struct.ssl_connection_st, ptr %81, i32 0, i32 100
  %rrlmethod88 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer87, i32 0, i32 3
  %82 = load ptr, ptr %rrlmethod88, align 8
  %set_max_pipelines = getelementptr inbounds %struct.ossl_record_method_st, ptr %82, i32 0, i32 15
  %83 = load ptr, ptr %set_max_pipelines, align 8
  %cmp89 = icmp ne ptr %83, null
  br i1 %cmp89, label %if.then91, label %if.end97

if.then91:                                        ; preds = %if.end86
  %84 = load ptr, ptr %sc, align 8
  %rlayer92 = getelementptr inbounds %struct.ssl_connection_st, ptr %84, i32 0, i32 100
  %rrlmethod93 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer92, i32 0, i32 3
  %85 = load ptr, ptr %rrlmethod93, align 8
  %set_max_pipelines94 = getelementptr inbounds %struct.ossl_record_method_st, ptr %85, i32 0, i32 15
  %86 = load ptr, ptr %set_max_pipelines94, align 8
  %87 = load ptr, ptr %sc, align 8
  %rlayer95 = getelementptr inbounds %struct.ssl_connection_st, ptr %87, i32 0, i32 100
  %rrl96 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer95, i32 0, i32 5
  %88 = load ptr, ptr %rrl96, align 8
  %89 = load i64, ptr %larg.addr, align 8
  call void %86(ptr noundef %88, i64 noundef %89)
  br label %if.end97

if.end97:                                         ; preds = %if.then91, %if.end86
  store i64 1, ptr %retval, align 8
  br label %return

sw.bb98:                                          ; preds = %if.end20
  %90 = load ptr, ptr %sc, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %90, i32 0, i32 20
  %send_connection_binding = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 19
  %91 = load i32, ptr %send_connection_binding, align 8
  %conv99 = sext i32 %91 to i64
  store i64 %conv99, ptr %retval, align 8
  br label %return

sw.bb100:                                         ; preds = %if.end20
  %92 = load ptr, ptr %sc, align 8
  %rwstate = getelementptr inbounds %struct.ssl_connection_st, ptr %92, i32 0, i32 5
  store i32 8, ptr %rwstate, align 8
  store i64 1, ptr %retval, align 8
  br label %return

sw.bb101:                                         ; preds = %if.end20
  %93 = load i64, ptr %larg.addr, align 8
  %94 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %94, i32 0, i32 44
  %95 = load ptr, ptr %cert, align 8
  %cert_flags = getelementptr inbounds %struct.cert_st, ptr %95, i32 0, i32 4
  %96 = load i32, ptr %cert_flags, align 4
  %conv102 = zext i32 %96 to i64
  %or103 = or i64 %conv102, %93
  %conv104 = trunc i64 %or103 to i32
  store i32 %conv104, ptr %cert_flags, align 4
  %conv105 = zext i32 %conv104 to i64
  store i64 %conv105, ptr %retval, align 8
  br label %return

sw.bb106:                                         ; preds = %if.end20
  %97 = load i64, ptr %larg.addr, align 8
  %not107 = xor i64 %97, -1
  %98 = load ptr, ptr %sc, align 8
  %cert108 = getelementptr inbounds %struct.ssl_connection_st, ptr %98, i32 0, i32 44
  %99 = load ptr, ptr %cert108, align 8
  %cert_flags109 = getelementptr inbounds %struct.cert_st, ptr %99, i32 0, i32 4
  %100 = load i32, ptr %cert_flags109, align 4
  %conv110 = zext i32 %100 to i64
  %and111 = and i64 %conv110, %not107
  %conv112 = trunc i64 %and111 to i32
  store i32 %conv112, ptr %cert_flags109, align 4
  %conv113 = zext i32 %conv112 to i64
  store i64 %conv113, ptr %retval, align 8
  br label %return

sw.bb114:                                         ; preds = %if.end20
  %101 = load ptr, ptr %parg.addr, align 8
  %tobool115 = icmp ne ptr %101, null
  br i1 %tobool115, label %if.then116, label %if.else

if.then116:                                       ; preds = %sw.bb114
  %102 = load ptr, ptr %sc, align 8
  %s3117 = getelementptr inbounds %struct.ssl_connection_st, ptr %102, i32 0, i32 20
  %tmp118 = getelementptr inbounds %struct.anon, ptr %s3117, i32 0, i32 14
  %ciphers_raw = getelementptr inbounds %struct.anon.0, ptr %tmp118, i32 0, i32 20
  %103 = load ptr, ptr %ciphers_raw, align 8
  %cmp119 = icmp eq ptr %103, null
  br i1 %cmp119, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.then116
  store i64 0, ptr %retval, align 8
  br label %return

if.end122:                                        ; preds = %if.then116
  %104 = load ptr, ptr %sc, align 8
  %s3123 = getelementptr inbounds %struct.ssl_connection_st, ptr %104, i32 0, i32 20
  %tmp124 = getelementptr inbounds %struct.anon, ptr %s3123, i32 0, i32 14
  %ciphers_raw125 = getelementptr inbounds %struct.anon.0, ptr %tmp124, i32 0, i32 20
  %105 = load ptr, ptr %ciphers_raw125, align 8
  %106 = load ptr, ptr %parg.addr, align 8
  store ptr %105, ptr %106, align 8
  %107 = load ptr, ptr %sc, align 8
  %s3126 = getelementptr inbounds %struct.ssl_connection_st, ptr %107, i32 0, i32 20
  %tmp127 = getelementptr inbounds %struct.anon, ptr %s3126, i32 0, i32 14
  %ciphers_rawlen = getelementptr inbounds %struct.anon.0, ptr %tmp127, i32 0, i32 21
  %108 = load i64, ptr %ciphers_rawlen, align 8
  %conv128 = trunc i64 %108 to i32
  %conv129 = sext i32 %conv128 to i64
  store i64 %conv129, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %sw.bb114
  store i64 2, ptr %retval, align 8
  br label %return

sw.bb130:                                         ; preds = %if.end20
  %109 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %109, i32 0, i32 50
  %110 = load ptr, ptr %session, align 8
  %tobool131 = icmp ne ptr %110, null
  br i1 %tobool131, label %lor.lhs.false132, label %if.then138

lor.lhs.false132:                                 ; preds = %sw.bb130
  %111 = load ptr, ptr %s.addr, align 8
  %call133 = call i32 @SSL_in_init(ptr noundef %111)
  %tobool134 = icmp ne i32 %call133, 0
  br i1 %tobool134, label %if.then138, label %lor.lhs.false135

lor.lhs.false135:                                 ; preds = %lor.lhs.false132
  %112 = load ptr, ptr %sc, align 8
  %call136 = call i32 @ossl_statem_get_in_handshake(ptr noundef %112)
  %tobool137 = icmp ne i32 %call136, 0
  br i1 %tobool137, label %if.then138, label %if.end139

if.then138:                                       ; preds = %lor.lhs.false135, %lor.lhs.false132, %sw.bb130
  store i64 -1, ptr %retval, align 8
  br label %return

if.end139:                                        ; preds = %lor.lhs.false135
  %113 = load ptr, ptr %sc, align 8
  %session140 = getelementptr inbounds %struct.ssl_connection_st, ptr %113, i32 0, i32 50
  %114 = load ptr, ptr %session140, align 8
  %flags = getelementptr inbounds %struct.ssl_session_st, ptr %114, i32 0, i32 30
  %115 = load i32, ptr %flags, align 8
  %and141 = and i32 %115, 1
  %tobool142 = icmp ne i32 %and141, 0
  br i1 %tobool142, label %if.then143, label %if.else144

if.then143:                                       ; preds = %if.end139
  store i64 1, ptr %retval, align 8
  br label %return

if.else144:                                       ; preds = %if.end139
  store i64 0, ptr %retval, align 8
  br label %return

sw.bb145:                                         ; preds = %if.end20
  %116 = load i64, ptr %larg.addr, align 8
  %conv146 = trunc i64 %116 to i32
  %117 = load ptr, ptr %sc, align 8
  %max_proto_version = getelementptr inbounds %struct.ssl_connection_st, ptr %117, i32 0, i32 73
  %118 = load i32, ptr %max_proto_version, align 8
  %call147 = call i32 @ssl_check_allowed_versions(i32 noundef %conv146, i32 noundef %118)
  %tobool148 = icmp ne i32 %call147, 0
  br i1 %tobool148, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %sw.bb145
  %119 = load ptr, ptr %s.addr, align 8
  %defltmeth = getelementptr inbounds %struct.ssl_st, ptr %119, i32 0, i32 2
  %120 = load ptr, ptr %defltmeth, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %120, i32 0, i32 0
  %121 = load i32, ptr %version, align 8
  %122 = load i64, ptr %larg.addr, align 8
  %conv149 = trunc i64 %122 to i32
  %123 = load ptr, ptr %sc, align 8
  %min_proto_version = getelementptr inbounds %struct.ssl_connection_st, ptr %123, i32 0, i32 72
  %call150 = call i32 @ssl_set_version_bound(i32 noundef %121, i32 noundef %conv149, ptr noundef %min_proto_version)
  %tobool151 = icmp ne i32 %call150, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %sw.bb145
  %124 = phi i1 [ false, %sw.bb145 ], [ %tobool151, %land.rhs ]
  %land.ext = zext i1 %124 to i32
  %conv152 = sext i32 %land.ext to i64
  store i64 %conv152, ptr %retval, align 8
  br label %return

sw.bb153:                                         ; preds = %if.end20
  %125 = load ptr, ptr %sc, align 8
  %min_proto_version154 = getelementptr inbounds %struct.ssl_connection_st, ptr %125, i32 0, i32 72
  %126 = load i32, ptr %min_proto_version154, align 4
  %conv155 = sext i32 %126 to i64
  store i64 %conv155, ptr %retval, align 8
  br label %return

sw.bb156:                                         ; preds = %if.end20
  %127 = load ptr, ptr %sc, align 8
  %min_proto_version157 = getelementptr inbounds %struct.ssl_connection_st, ptr %127, i32 0, i32 72
  %128 = load i32, ptr %min_proto_version157, align 4
  %129 = load i64, ptr %larg.addr, align 8
  %conv158 = trunc i64 %129 to i32
  %call159 = call i32 @ssl_check_allowed_versions(i32 noundef %128, i32 noundef %conv158)
  %tobool160 = icmp ne i32 %call159, 0
  br i1 %tobool160, label %land.rhs161, label %land.end168

land.rhs161:                                      ; preds = %sw.bb156
  %130 = load ptr, ptr %s.addr, align 8
  %defltmeth162 = getelementptr inbounds %struct.ssl_st, ptr %130, i32 0, i32 2
  %131 = load ptr, ptr %defltmeth162, align 8
  %version163 = getelementptr inbounds %struct.ssl_method_st, ptr %131, i32 0, i32 0
  %132 = load i32, ptr %version163, align 8
  %133 = load i64, ptr %larg.addr, align 8
  %conv164 = trunc i64 %133 to i32
  %134 = load ptr, ptr %sc, align 8
  %max_proto_version165 = getelementptr inbounds %struct.ssl_connection_st, ptr %134, i32 0, i32 73
  %call166 = call i32 @ssl_set_version_bound(i32 noundef %132, i32 noundef %conv164, ptr noundef %max_proto_version165)
  %tobool167 = icmp ne i32 %call166, 0
  br label %land.end168

land.end168:                                      ; preds = %land.rhs161, %sw.bb156
  %135 = phi i1 [ false, %sw.bb156 ], [ %tobool167, %land.rhs161 ]
  %land.ext169 = zext i1 %135 to i32
  %conv170 = sext i32 %land.ext169 to i64
  store i64 %conv170, ptr %retval, align 8
  br label %return

sw.bb171:                                         ; preds = %if.end20
  %136 = load ptr, ptr %sc, align 8
  %max_proto_version172 = getelementptr inbounds %struct.ssl_connection_st, ptr %136, i32 0, i32 73
  %137 = load i32, ptr %max_proto_version172, align 8
  %conv173 = sext i32 %137 to i64
  store i64 %conv173, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %if.end20
  %138 = load ptr, ptr %s.addr, align 8
  %cmp174 = icmp ne ptr %138, null
  br i1 %cmp174, label %land.lhs.true176, label %if.else186

land.lhs.true176:                                 ; preds = %sw.default
  %139 = load ptr, ptr %s.addr, align 8
  %type177 = getelementptr inbounds %struct.ssl_st, ptr %139, i32 0, i32 0
  %140 = load i32, ptr %type177, align 8
  %cmp178 = icmp eq i32 %140, 1
  br i1 %cmp178, label %if.then184, label %lor.lhs.false180

lor.lhs.false180:                                 ; preds = %land.lhs.true176
  %141 = load ptr, ptr %s.addr, align 8
  %type181 = getelementptr inbounds %struct.ssl_st, ptr %141, i32 0, i32 0
  %142 = load i32, ptr %type181, align 8
  %cmp182 = icmp eq i32 %142, 2
  br i1 %cmp182, label %if.then184, label %if.else186

if.then184:                                       ; preds = %lor.lhs.false180, %land.lhs.true176
  %143 = load ptr, ptr %sc, align 8
  %144 = load i32, ptr %cmd.addr, align 4
  %145 = load i64, ptr %larg.addr, align 8
  %146 = load ptr, ptr %parg.addr, align 8
  %call185 = call i64 @SSL_ctrl(ptr noundef %143, i32 noundef %144, i64 noundef %145, ptr noundef %146)
  store i64 %call185, ptr %retval, align 8
  br label %return

if.else186:                                       ; preds = %lor.lhs.false180, %sw.default
  %147 = load ptr, ptr %s.addr, align 8
  %method187 = getelementptr inbounds %struct.ssl_st, ptr %147, i32 0, i32 3
  %148 = load ptr, ptr %method187, align 8
  %ssl_ctrl188 = getelementptr inbounds %struct.ssl_method_st, ptr %148, i32 0, i32 20
  %149 = load ptr, ptr %ssl_ctrl188, align 8
  %150 = load ptr, ptr %s.addr, align 8
  %151 = load i32, ptr %cmd.addr, align 4
  %152 = load i64, ptr %larg.addr, align 8
  %153 = load ptr, ptr %parg.addr, align 8
  %call189 = call i64 %149(ptr noundef %150, i32 noundef %151, i64 noundef %152, ptr noundef %153)
  store i64 %call189, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else186, %if.then184, %sw.bb171, %land.end168, %sw.bb153, %land.end, %if.else144, %if.then143, %if.then138, %if.else, %if.end122, %if.then121, %sw.bb106, %sw.bb101, %sw.bb100, %sw.bb98, %if.end97, %if.then85, %if.end77, %if.then76, %if.end66, %if.then58, %if.end49, %if.then48, %sw.bb44, %sw.bb39, %sw.bb28, %sw.bb21, %sw.bb, %if.then19, %if.then
  %154 = load i64, ptr %retval, align 8
  ret i64 %154
}

declare void @OSSL_PARAM_construct_uint32(ptr sret(%struct.ossl_param_st) align 8, ptr noundef, ptr noundef) #1

declare i32 @ossl_statem_get_in_handshake(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @ssl_check_allowed_versions(i32 noundef %min_version, i32 noundef %max_version) #0 {
entry:
  %retval = alloca i32, align 4
  %min_version.addr = alloca i32, align 4
  %max_version.addr = alloca i32, align 4
  %minisdtls = alloca i32, align 4
  %maxisdtls = alloca i32, align 4
  store i32 %min_version, ptr %min_version.addr, align 4
  store i32 %max_version, ptr %max_version.addr, align 4
  store i32 0, ptr %minisdtls, align 4
  store i32 0, ptr %maxisdtls, align 4
  %0 = load i32, ptr %min_version.addr, align 4
  %cmp = icmp eq i32 %0, 256
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %min_version.addr, align 4
  %shr = ashr i32 %1, 8
  %cmp1 = icmp eq i32 %shr, 254
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, ptr %minisdtls, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %2 = load i32, ptr %max_version.addr, align 4
  %cmp2 = icmp eq i32 %2, 256
  br i1 %cmp2, label %if.then6, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %if.end
  %3 = load i32, ptr %max_version.addr, align 4
  %shr4 = ashr i32 %3, 8
  %cmp5 = icmp eq i32 %shr4, 254
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %lor.lhs.false3, %if.end
  store i32 1, ptr %maxisdtls, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %lor.lhs.false3
  %4 = load i32, ptr %minisdtls, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false11

land.lhs.true:                                    ; preds = %if.end7
  %5 = load i32, ptr %maxisdtls, align 4
  %tobool8 = icmp ne i32 %5, 0
  br i1 %tobool8, label %lor.lhs.false11, label %land.lhs.true9

land.lhs.true9:                                   ; preds = %land.lhs.true
  %6 = load i32, ptr %max_version.addr, align 4
  %cmp10 = icmp ne i32 %6, 0
  br i1 %cmp10, label %if.then17, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %land.lhs.true9, %land.lhs.true, %if.end7
  %7 = load i32, ptr %maxisdtls, align 4
  %tobool12 = icmp ne i32 %7, 0
  br i1 %tobool12, label %land.lhs.true13, label %if.end18

land.lhs.true13:                                  ; preds = %lor.lhs.false11
  %8 = load i32, ptr %minisdtls, align 4
  %tobool14 = icmp ne i32 %8, 0
  br i1 %tobool14, label %if.end18, label %land.lhs.true15

land.lhs.true15:                                  ; preds = %land.lhs.true13
  %9 = load i32, ptr %min_version.addr, align 4
  %cmp16 = icmp ne i32 %9, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true15, %land.lhs.true9
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %land.lhs.true15, %land.lhs.true13, %lor.lhs.false11
  %10 = load i32, ptr %minisdtls, align 4
  %tobool19 = icmp ne i32 %10, 0
  br i1 %tobool19, label %if.then22, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %if.end18
  %11 = load i32, ptr %maxisdtls, align 4
  %tobool21 = icmp ne i32 %11, 0
  br i1 %tobool21, label %if.then22, label %if.else

if.then22:                                        ; preds = %lor.lhs.false20, %if.end18
  %12 = load i32, ptr %min_version.addr, align 4
  %cmp23 = icmp eq i32 %12, 0
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.then22
  store i32 65279, ptr %min_version.addr, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.then22
  %13 = load i32, ptr %max_version.addr, align 4
  %cmp26 = icmp eq i32 %13, 0
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end25
  store i32 65277, ptr %max_version.addr, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %if.end25
  br label %if.end43

if.else:                                          ; preds = %lor.lhs.false20
  %14 = load i32, ptr %min_version.addr, align 4
  %cmp29 = icmp eq i32 %14, 0
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.else
  store i32 768, ptr %min_version.addr, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then30, %if.else
  %15 = load i32, ptr %max_version.addr, align 4
  %cmp32 = icmp eq i32 %15, 0
  br i1 %cmp32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end31
  store i32 772, ptr %max_version.addr, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.end31
  %16 = load i32, ptr %min_version.addr, align 4
  %cmp35 = icmp eq i32 %16, 768
  br i1 %cmp35, label %if.then36, label %if.end37

if.then36:                                        ; preds = %if.end34
  store i32 769, ptr %min_version.addr, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.end34
  %17 = load i32, ptr %min_version.addr, align 4
  %cmp38 = icmp sle i32 %17, 768
  br i1 %cmp38, label %land.lhs.true39, label %if.end42

land.lhs.true39:                                  ; preds = %if.end37
  %18 = load i32, ptr %max_version.addr, align 4
  %cmp40 = icmp sle i32 768, %18
  br i1 %cmp40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %land.lhs.true39
  store i32 0, ptr %retval, align 4
  br label %return

if.end42:                                         ; preds = %land.lhs.true39, %if.end37
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %if.end28
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end43, %if.then41, %if.then17
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

declare i32 @ssl_set_version_bound(i32 noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i64 @SSL_callback_ctrl(ptr noundef %s, i32 noundef %cmd, ptr noundef %fp) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cmd.addr = alloca i32, align 4
  %fp.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %cmd, ptr %cmd.addr, align 4
  store ptr %fp, ptr %fp.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %method, align 8
  %ssl_callback_ctrl = getelementptr inbounds %struct.ssl_method_st, ptr %1, i32 0, i32 30
  %2 = load ptr, ptr %ssl_callback_ctrl, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load i32, ptr %cmd.addr, align 4
  %5 = load ptr, ptr %fp.addr, align 8
  %call = call i64 %2(ptr noundef %3, i32 noundef %4, ptr noundef %5)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_sessions(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %sessions = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %sessions, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define i64 @SSL_CTX_ctrl(ptr noundef %ctx, i32 noundef %cmd, i64 noundef %larg, ptr noundef %parg) #0 {
entry:
  %retval = alloca i64, align 8
  %ctx.addr = alloca ptr, align 8
  %cmd.addr = alloca i32, align 4
  %larg.addr = alloca i64, align 8
  %parg.addr = alloca ptr, align 8
  %l = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %cmd, ptr %cmd.addr, align 4
  store i64 %larg, ptr %larg.addr, align 8
  store ptr %parg, ptr %parg.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %cmd.addr, align 4
  switch i32 %1, label %sw.default [
    i32 92, label %sw.bb
    i32 98, label %sw.bb1
    i32 102, label %sw.bb1
  ]

sw.bb:                                            ; preds = %if.then
  %2 = load ptr, ptr %ctx.addr, align 8
  %3 = load ptr, ptr %parg.addr, align 8
  %call = call i32 @tls1_set_groups_list(ptr noundef %2, ptr noundef null, ptr noundef null, ptr noundef %3)
  %conv = sext i32 %call to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %if.then, %if.then
  %4 = load ptr, ptr %parg.addr, align 8
  %call2 = call i32 @tls1_set_sigalgs_list(ptr noundef null, ptr noundef %4, i32 noundef 0)
  %conv3 = sext i32 %call2 to i64
  store i64 %conv3, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %if.then
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, ptr %cmd.addr, align 4
  switch i32 %5, label %sw.default162 [
    i32 40, label %sw.bb4
    i32 41, label %sw.bb6
    i32 16, label %sw.bb11
    i32 50, label %sw.bb12
    i32 51, label %sw.bb13
    i32 42, label %sw.bb20
    i32 43, label %sw.bb26
    i32 44, label %sw.bb28
    i32 45, label %sw.bb32
    i32 20, label %sw.bb35
    i32 21, label %sw.bb37
    i32 22, label %sw.bb40
    i32 23, label %sw.bb44
    i32 24, label %sw.bb48
    i32 25, label %sw.bb52
    i32 26, label %sw.bb56
    i32 27, label %sw.bb60
    i32 28, label %sw.bb64
    i32 29, label %sw.bb68
    i32 30, label %sw.bb72
    i32 31, label %sw.bb76
    i32 33, label %sw.bb80
    i32 78, label %sw.bb84
    i32 52, label %sw.bb89
    i32 125, label %sw.bb103
    i32 126, label %sw.bb113
    i32 99, label %sw.bb121
    i32 100, label %sw.bb126
    i32 123, label %sw.bb134
    i32 130, label %sw.bb141
    i32 124, label %sw.bb144
    i32 131, label %sw.bb159
  ]

sw.bb4:                                           ; preds = %if.end
  %6 = load ptr, ptr %ctx.addr, align 8
  %read_ahead = getelementptr inbounds %struct.ssl_ctx_st, ptr %6, i32 0, i32 41
  %7 = load i32, ptr %read_ahead, align 8
  %conv5 = sext i32 %7 to i64
  store i64 %conv5, ptr %retval, align 8
  br label %return

sw.bb6:                                           ; preds = %if.end
  %8 = load ptr, ptr %ctx.addr, align 8
  %read_ahead7 = getelementptr inbounds %struct.ssl_ctx_st, ptr %8, i32 0, i32 41
  %9 = load i32, ptr %read_ahead7, align 8
  %conv8 = sext i32 %9 to i64
  store i64 %conv8, ptr %l, align 8
  %10 = load i64, ptr %larg.addr, align 8
  %conv9 = trunc i64 %10 to i32
  %11 = load ptr, ptr %ctx.addr, align 8
  %read_ahead10 = getelementptr inbounds %struct.ssl_ctx_st, ptr %11, i32 0, i32 41
  store i32 %conv9, ptr %read_ahead10, align 8
  %12 = load i64, ptr %l, align 8
  store i64 %12, ptr %retval, align 8
  br label %return

sw.bb11:                                          ; preds = %if.end
  %13 = load ptr, ptr %parg.addr, align 8
  %14 = load ptr, ptr %ctx.addr, align 8
  %msg_callback_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %14, i32 0, i32 43
  store ptr %13, ptr %msg_callback_arg, align 8
  store i64 1, ptr %retval, align 8
  br label %return

sw.bb12:                                          ; preds = %if.end
  %15 = load ptr, ptr %ctx.addr, align 8
  %max_cert_list = getelementptr inbounds %struct.ssl_ctx_st, ptr %15, i32 0, i32 38
  %16 = load i64, ptr %max_cert_list, align 8
  store i64 %16, ptr %retval, align 8
  br label %return

sw.bb13:                                          ; preds = %if.end
  %17 = load i64, ptr %larg.addr, align 8
  %cmp14 = icmp slt i64 %17, 0
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %sw.bb13
  store i64 0, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %sw.bb13
  %18 = load ptr, ptr %ctx.addr, align 8
  %max_cert_list18 = getelementptr inbounds %struct.ssl_ctx_st, ptr %18, i32 0, i32 38
  %19 = load i64, ptr %max_cert_list18, align 8
  store i64 %19, ptr %l, align 8
  %20 = load i64, ptr %larg.addr, align 8
  %21 = load ptr, ptr %ctx.addr, align 8
  %max_cert_list19 = getelementptr inbounds %struct.ssl_ctx_st, ptr %21, i32 0, i32 38
  store i64 %20, ptr %max_cert_list19, align 8
  %22 = load i64, ptr %l, align 8
  store i64 %22, ptr %retval, align 8
  br label %return

sw.bb20:                                          ; preds = %if.end
  %23 = load i64, ptr %larg.addr, align 8
  %cmp21 = icmp slt i64 %23, 0
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %sw.bb20
  store i64 0, ptr %retval, align 8
  br label %return

if.end24:                                         ; preds = %sw.bb20
  %24 = load ptr, ptr %ctx.addr, align 8
  %session_cache_size = getelementptr inbounds %struct.ssl_ctx_st, ptr %24, i32 0, i32 7
  %25 = load i64, ptr %session_cache_size, align 8
  store i64 %25, ptr %l, align 8
  %26 = load i64, ptr %larg.addr, align 8
  %27 = load ptr, ptr %ctx.addr, align 8
  %session_cache_size25 = getelementptr inbounds %struct.ssl_ctx_st, ptr %27, i32 0, i32 7
  store i64 %26, ptr %session_cache_size25, align 8
  %28 = load i64, ptr %l, align 8
  store i64 %28, ptr %retval, align 8
  br label %return

sw.bb26:                                          ; preds = %if.end
  %29 = load ptr, ptr %ctx.addr, align 8
  %session_cache_size27 = getelementptr inbounds %struct.ssl_ctx_st, ptr %29, i32 0, i32 7
  %30 = load i64, ptr %session_cache_size27, align 8
  store i64 %30, ptr %retval, align 8
  br label %return

sw.bb28:                                          ; preds = %if.end
  %31 = load ptr, ptr %ctx.addr, align 8
  %session_cache_mode = getelementptr inbounds %struct.ssl_ctx_st, ptr %31, i32 0, i32 10
  %32 = load i32, ptr %session_cache_mode, align 8
  %conv29 = zext i32 %32 to i64
  store i64 %conv29, ptr %l, align 8
  %33 = load i64, ptr %larg.addr, align 8
  %conv30 = trunc i64 %33 to i32
  %34 = load ptr, ptr %ctx.addr, align 8
  %session_cache_mode31 = getelementptr inbounds %struct.ssl_ctx_st, ptr %34, i32 0, i32 10
  store i32 %conv30, ptr %session_cache_mode31, align 8
  %35 = load i64, ptr %l, align 8
  store i64 %35, ptr %retval, align 8
  br label %return

sw.bb32:                                          ; preds = %if.end
  %36 = load ptr, ptr %ctx.addr, align 8
  %session_cache_mode33 = getelementptr inbounds %struct.ssl_ctx_st, ptr %36, i32 0, i32 10
  %37 = load i32, ptr %session_cache_mode33, align 8
  %conv34 = zext i32 %37 to i64
  store i64 %conv34, ptr %retval, align 8
  br label %return

sw.bb35:                                          ; preds = %if.end
  %38 = load ptr, ptr %ctx.addr, align 8
  %sessions = getelementptr inbounds %struct.ssl_ctx_st, ptr %38, i32 0, i32 6
  %39 = load ptr, ptr %sessions, align 8
  %call36 = call i64 @lh_SSL_SESSION_num_items(ptr noundef %39)
  store i64 %call36, ptr %retval, align 8
  br label %return

sw.bb37:                                          ; preds = %if.end
  %40 = load ptr, ptr %ctx.addr, align 8
  %41 = load ptr, ptr %ctx.addr, align 8
  %stats = getelementptr inbounds %struct.ssl_ctx_st, ptr %41, i32 0, i32 15
  %sess_connect = getelementptr inbounds %struct.anon.3, ptr %stats, i32 0, i32 0
  %call38 = call i32 @ssl_tsan_load(ptr noundef %40, ptr noundef %sess_connect)
  %conv39 = sext i32 %call38 to i64
  store i64 %conv39, ptr %retval, align 8
  br label %return

sw.bb40:                                          ; preds = %if.end
  %42 = load ptr, ptr %ctx.addr, align 8
  %43 = load ptr, ptr %ctx.addr, align 8
  %stats41 = getelementptr inbounds %struct.ssl_ctx_st, ptr %43, i32 0, i32 15
  %sess_connect_good = getelementptr inbounds %struct.anon.3, ptr %stats41, i32 0, i32 2
  %call42 = call i32 @ssl_tsan_load(ptr noundef %42, ptr noundef %sess_connect_good)
  %conv43 = sext i32 %call42 to i64
  store i64 %conv43, ptr %retval, align 8
  br label %return

sw.bb44:                                          ; preds = %if.end
  %44 = load ptr, ptr %ctx.addr, align 8
  %45 = load ptr, ptr %ctx.addr, align 8
  %stats45 = getelementptr inbounds %struct.ssl_ctx_st, ptr %45, i32 0, i32 15
  %sess_connect_renegotiate = getelementptr inbounds %struct.anon.3, ptr %stats45, i32 0, i32 1
  %call46 = call i32 @ssl_tsan_load(ptr noundef %44, ptr noundef %sess_connect_renegotiate)
  %conv47 = sext i32 %call46 to i64
  store i64 %conv47, ptr %retval, align 8
  br label %return

sw.bb48:                                          ; preds = %if.end
  %46 = load ptr, ptr %ctx.addr, align 8
  %47 = load ptr, ptr %ctx.addr, align 8
  %stats49 = getelementptr inbounds %struct.ssl_ctx_st, ptr %47, i32 0, i32 15
  %sess_accept = getelementptr inbounds %struct.anon.3, ptr %stats49, i32 0, i32 3
  %call50 = call i32 @ssl_tsan_load(ptr noundef %46, ptr noundef %sess_accept)
  %conv51 = sext i32 %call50 to i64
  store i64 %conv51, ptr %retval, align 8
  br label %return

sw.bb52:                                          ; preds = %if.end
  %48 = load ptr, ptr %ctx.addr, align 8
  %49 = load ptr, ptr %ctx.addr, align 8
  %stats53 = getelementptr inbounds %struct.ssl_ctx_st, ptr %49, i32 0, i32 15
  %sess_accept_good = getelementptr inbounds %struct.anon.3, ptr %stats53, i32 0, i32 5
  %call54 = call i32 @ssl_tsan_load(ptr noundef %48, ptr noundef %sess_accept_good)
  %conv55 = sext i32 %call54 to i64
  store i64 %conv55, ptr %retval, align 8
  br label %return

sw.bb56:                                          ; preds = %if.end
  %50 = load ptr, ptr %ctx.addr, align 8
  %51 = load ptr, ptr %ctx.addr, align 8
  %stats57 = getelementptr inbounds %struct.ssl_ctx_st, ptr %51, i32 0, i32 15
  %sess_accept_renegotiate = getelementptr inbounds %struct.anon.3, ptr %stats57, i32 0, i32 4
  %call58 = call i32 @ssl_tsan_load(ptr noundef %50, ptr noundef %sess_accept_renegotiate)
  %conv59 = sext i32 %call58 to i64
  store i64 %conv59, ptr %retval, align 8
  br label %return

sw.bb60:                                          ; preds = %if.end
  %52 = load ptr, ptr %ctx.addr, align 8
  %53 = load ptr, ptr %ctx.addr, align 8
  %stats61 = getelementptr inbounds %struct.ssl_ctx_st, ptr %53, i32 0, i32 15
  %sess_hit = getelementptr inbounds %struct.anon.3, ptr %stats61, i32 0, i32 9
  %call62 = call i32 @ssl_tsan_load(ptr noundef %52, ptr noundef %sess_hit)
  %conv63 = sext i32 %call62 to i64
  store i64 %conv63, ptr %retval, align 8
  br label %return

sw.bb64:                                          ; preds = %if.end
  %54 = load ptr, ptr %ctx.addr, align 8
  %55 = load ptr, ptr %ctx.addr, align 8
  %stats65 = getelementptr inbounds %struct.ssl_ctx_st, ptr %55, i32 0, i32 15
  %sess_cb_hit = getelementptr inbounds %struct.anon.3, ptr %stats65, i32 0, i32 10
  %call66 = call i32 @ssl_tsan_load(ptr noundef %54, ptr noundef %sess_cb_hit)
  %conv67 = sext i32 %call66 to i64
  store i64 %conv67, ptr %retval, align 8
  br label %return

sw.bb68:                                          ; preds = %if.end
  %56 = load ptr, ptr %ctx.addr, align 8
  %57 = load ptr, ptr %ctx.addr, align 8
  %stats69 = getelementptr inbounds %struct.ssl_ctx_st, ptr %57, i32 0, i32 15
  %sess_miss = getelementptr inbounds %struct.anon.3, ptr %stats69, i32 0, i32 6
  %call70 = call i32 @ssl_tsan_load(ptr noundef %56, ptr noundef %sess_miss)
  %conv71 = sext i32 %call70 to i64
  store i64 %conv71, ptr %retval, align 8
  br label %return

sw.bb72:                                          ; preds = %if.end
  %58 = load ptr, ptr %ctx.addr, align 8
  %59 = load ptr, ptr %ctx.addr, align 8
  %stats73 = getelementptr inbounds %struct.ssl_ctx_st, ptr %59, i32 0, i32 15
  %sess_timeout = getelementptr inbounds %struct.anon.3, ptr %stats73, i32 0, i32 7
  %call74 = call i32 @ssl_tsan_load(ptr noundef %58, ptr noundef %sess_timeout)
  %conv75 = sext i32 %call74 to i64
  store i64 %conv75, ptr %retval, align 8
  br label %return

sw.bb76:                                          ; preds = %if.end
  %60 = load ptr, ptr %ctx.addr, align 8
  %61 = load ptr, ptr %ctx.addr, align 8
  %stats77 = getelementptr inbounds %struct.ssl_ctx_st, ptr %61, i32 0, i32 15
  %sess_cache_full = getelementptr inbounds %struct.anon.3, ptr %stats77, i32 0, i32 8
  %call78 = call i32 @ssl_tsan_load(ptr noundef %60, ptr noundef %sess_cache_full)
  %conv79 = sext i32 %call78 to i64
  store i64 %conv79, ptr %retval, align 8
  br label %return

sw.bb80:                                          ; preds = %if.end
  %62 = load i64, ptr %larg.addr, align 8
  %63 = load ptr, ptr %ctx.addr, align 8
  %mode = getelementptr inbounds %struct.ssl_ctx_st, ptr %63, i32 0, i32 35
  %64 = load i32, ptr %mode, align 8
  %conv81 = zext i32 %64 to i64
  %or = or i64 %conv81, %62
  %conv82 = trunc i64 %or to i32
  store i32 %conv82, ptr %mode, align 8
  %conv83 = zext i32 %conv82 to i64
  store i64 %conv83, ptr %retval, align 8
  br label %return

sw.bb84:                                          ; preds = %if.end
  %65 = load i64, ptr %larg.addr, align 8
  %not = xor i64 %65, -1
  %66 = load ptr, ptr %ctx.addr, align 8
  %mode85 = getelementptr inbounds %struct.ssl_ctx_st, ptr %66, i32 0, i32 35
  %67 = load i32, ptr %mode85, align 8
  %conv86 = zext i32 %67 to i64
  %and = and i64 %conv86, %not
  %conv87 = trunc i64 %and to i32
  store i32 %conv87, ptr %mode85, align 8
  %conv88 = zext i32 %conv87 to i64
  store i64 %conv88, ptr %retval, align 8
  br label %return

sw.bb89:                                          ; preds = %if.end
  %68 = load i64, ptr %larg.addr, align 8
  %cmp90 = icmp slt i64 %68, 512
  br i1 %cmp90, label %if.then94, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb89
  %69 = load i64, ptr %larg.addr, align 8
  %cmp92 = icmp sgt i64 %69, 16384
  br i1 %cmp92, label %if.then94, label %if.end95

if.then94:                                        ; preds = %lor.lhs.false, %sw.bb89
  store i64 0, ptr %retval, align 8
  br label %return

if.end95:                                         ; preds = %lor.lhs.false
  %70 = load i64, ptr %larg.addr, align 8
  %71 = load ptr, ptr %ctx.addr, align 8
  %max_send_fragment = getelementptr inbounds %struct.ssl_ctx_st, ptr %71, i32 0, i32 55
  store i64 %70, ptr %max_send_fragment, align 8
  %72 = load ptr, ptr %ctx.addr, align 8
  %max_send_fragment96 = getelementptr inbounds %struct.ssl_ctx_st, ptr %72, i32 0, i32 55
  %73 = load i64, ptr %max_send_fragment96, align 8
  %74 = load ptr, ptr %ctx.addr, align 8
  %split_send_fragment = getelementptr inbounds %struct.ssl_ctx_st, ptr %74, i32 0, i32 54
  %75 = load i64, ptr %split_send_fragment, align 8
  %cmp97 = icmp ult i64 %73, %75
  br i1 %cmp97, label %if.then99, label %if.end102

if.then99:                                        ; preds = %if.end95
  %76 = load ptr, ptr %ctx.addr, align 8
  %max_send_fragment100 = getelementptr inbounds %struct.ssl_ctx_st, ptr %76, i32 0, i32 55
  %77 = load i64, ptr %max_send_fragment100, align 8
  %78 = load ptr, ptr %ctx.addr, align 8
  %split_send_fragment101 = getelementptr inbounds %struct.ssl_ctx_st, ptr %78, i32 0, i32 54
  store i64 %77, ptr %split_send_fragment101, align 8
  br label %if.end102

if.end102:                                        ; preds = %if.then99, %if.end95
  store i64 1, ptr %retval, align 8
  br label %return

sw.bb103:                                         ; preds = %if.end
  %79 = load i64, ptr %larg.addr, align 8
  %80 = load ptr, ptr %ctx.addr, align 8
  %max_send_fragment104 = getelementptr inbounds %struct.ssl_ctx_st, ptr %80, i32 0, i32 55
  %81 = load i64, ptr %max_send_fragment104, align 8
  %cmp105 = icmp ugt i64 %79, %81
  br i1 %cmp105, label %if.then110, label %lor.lhs.false107

lor.lhs.false107:                                 ; preds = %sw.bb103
  %82 = load i64, ptr %larg.addr, align 8
  %cmp108 = icmp eq i64 %82, 0
  br i1 %cmp108, label %if.then110, label %if.end111

if.then110:                                       ; preds = %lor.lhs.false107, %sw.bb103
  store i64 0, ptr %retval, align 8
  br label %return

if.end111:                                        ; preds = %lor.lhs.false107
  %83 = load i64, ptr %larg.addr, align 8
  %84 = load ptr, ptr %ctx.addr, align 8
  %split_send_fragment112 = getelementptr inbounds %struct.ssl_ctx_st, ptr %84, i32 0, i32 54
  store i64 %83, ptr %split_send_fragment112, align 8
  store i64 1, ptr %retval, align 8
  br label %return

sw.bb113:                                         ; preds = %if.end
  %85 = load i64, ptr %larg.addr, align 8
  %cmp114 = icmp slt i64 %85, 1
  br i1 %cmp114, label %if.then119, label %lor.lhs.false116

lor.lhs.false116:                                 ; preds = %sw.bb113
  %86 = load i64, ptr %larg.addr, align 8
  %cmp117 = icmp sgt i64 %86, 32
  br i1 %cmp117, label %if.then119, label %if.end120

if.then119:                                       ; preds = %lor.lhs.false116, %sw.bb113
  store i64 0, ptr %retval, align 8
  br label %return

if.end120:                                        ; preds = %lor.lhs.false116
  %87 = load i64, ptr %larg.addr, align 8
  %88 = load ptr, ptr %ctx.addr, align 8
  %max_pipelines = getelementptr inbounds %struct.ssl_ctx_st, ptr %88, i32 0, i32 56
  store i64 %87, ptr %max_pipelines, align 8
  store i64 1, ptr %retval, align 8
  br label %return

sw.bb121:                                         ; preds = %if.end
  %89 = load i64, ptr %larg.addr, align 8
  %90 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %90, i32 0, i32 39
  %91 = load ptr, ptr %cert, align 8
  %cert_flags = getelementptr inbounds %struct.cert_st, ptr %91, i32 0, i32 4
  %92 = load i32, ptr %cert_flags, align 4
  %conv122 = zext i32 %92 to i64
  %or123 = or i64 %conv122, %89
  %conv124 = trunc i64 %or123 to i32
  store i32 %conv124, ptr %cert_flags, align 4
  %conv125 = zext i32 %conv124 to i64
  store i64 %conv125, ptr %retval, align 8
  br label %return

sw.bb126:                                         ; preds = %if.end
  %93 = load i64, ptr %larg.addr, align 8
  %not127 = xor i64 %93, -1
  %94 = load ptr, ptr %ctx.addr, align 8
  %cert128 = getelementptr inbounds %struct.ssl_ctx_st, ptr %94, i32 0, i32 39
  %95 = load ptr, ptr %cert128, align 8
  %cert_flags129 = getelementptr inbounds %struct.cert_st, ptr %95, i32 0, i32 4
  %96 = load i32, ptr %cert_flags129, align 4
  %conv130 = zext i32 %96 to i64
  %and131 = and i64 %conv130, %not127
  %conv132 = trunc i64 %and131 to i32
  store i32 %conv132, ptr %cert_flags129, align 4
  %conv133 = zext i32 %conv132 to i64
  store i64 %conv133, ptr %retval, align 8
  br label %return

sw.bb134:                                         ; preds = %if.end
  %97 = load i64, ptr %larg.addr, align 8
  %conv135 = trunc i64 %97 to i32
  %98 = load ptr, ptr %ctx.addr, align 8
  %max_proto_version = getelementptr inbounds %struct.ssl_ctx_st, ptr %98, i32 0, i32 37
  %99 = load i32, ptr %max_proto_version, align 8
  %call136 = call i32 @ssl_check_allowed_versions(i32 noundef %conv135, i32 noundef %99)
  %tobool = icmp ne i32 %call136, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %sw.bb134
  %100 = load ptr, ptr %ctx.addr, align 8
  %method = getelementptr inbounds %struct.ssl_ctx_st, ptr %100, i32 0, i32 1
  %101 = load ptr, ptr %method, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %101, i32 0, i32 0
  %102 = load i32, ptr %version, align 8
  %103 = load i64, ptr %larg.addr, align 8
  %conv137 = trunc i64 %103 to i32
  %104 = load ptr, ptr %ctx.addr, align 8
  %min_proto_version = getelementptr inbounds %struct.ssl_ctx_st, ptr %104, i32 0, i32 36
  %call138 = call i32 @ssl_set_version_bound(i32 noundef %102, i32 noundef %conv137, ptr noundef %min_proto_version)
  %tobool139 = icmp ne i32 %call138, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %sw.bb134
  %105 = phi i1 [ false, %sw.bb134 ], [ %tobool139, %land.rhs ]
  %land.ext = zext i1 %105 to i32
  %conv140 = sext i32 %land.ext to i64
  store i64 %conv140, ptr %retval, align 8
  br label %return

sw.bb141:                                         ; preds = %if.end
  %106 = load ptr, ptr %ctx.addr, align 8
  %min_proto_version142 = getelementptr inbounds %struct.ssl_ctx_st, ptr %106, i32 0, i32 36
  %107 = load i32, ptr %min_proto_version142, align 4
  %conv143 = sext i32 %107 to i64
  store i64 %conv143, ptr %retval, align 8
  br label %return

sw.bb144:                                         ; preds = %if.end
  %108 = load ptr, ptr %ctx.addr, align 8
  %min_proto_version145 = getelementptr inbounds %struct.ssl_ctx_st, ptr %108, i32 0, i32 36
  %109 = load i32, ptr %min_proto_version145, align 4
  %110 = load i64, ptr %larg.addr, align 8
  %conv146 = trunc i64 %110 to i32
  %call147 = call i32 @ssl_check_allowed_versions(i32 noundef %109, i32 noundef %conv146)
  %tobool148 = icmp ne i32 %call147, 0
  br i1 %tobool148, label %land.rhs149, label %land.end156

land.rhs149:                                      ; preds = %sw.bb144
  %111 = load ptr, ptr %ctx.addr, align 8
  %method150 = getelementptr inbounds %struct.ssl_ctx_st, ptr %111, i32 0, i32 1
  %112 = load ptr, ptr %method150, align 8
  %version151 = getelementptr inbounds %struct.ssl_method_st, ptr %112, i32 0, i32 0
  %113 = load i32, ptr %version151, align 8
  %114 = load i64, ptr %larg.addr, align 8
  %conv152 = trunc i64 %114 to i32
  %115 = load ptr, ptr %ctx.addr, align 8
  %max_proto_version153 = getelementptr inbounds %struct.ssl_ctx_st, ptr %115, i32 0, i32 37
  %call154 = call i32 @ssl_set_version_bound(i32 noundef %113, i32 noundef %conv152, ptr noundef %max_proto_version153)
  %tobool155 = icmp ne i32 %call154, 0
  br label %land.end156

land.end156:                                      ; preds = %land.rhs149, %sw.bb144
  %116 = phi i1 [ false, %sw.bb144 ], [ %tobool155, %land.rhs149 ]
  %land.ext157 = zext i1 %116 to i32
  %conv158 = sext i32 %land.ext157 to i64
  store i64 %conv158, ptr %retval, align 8
  br label %return

sw.bb159:                                         ; preds = %if.end
  %117 = load ptr, ptr %ctx.addr, align 8
  %max_proto_version160 = getelementptr inbounds %struct.ssl_ctx_st, ptr %117, i32 0, i32 37
  %118 = load i32, ptr %max_proto_version160, align 8
  %conv161 = sext i32 %118 to i64
  store i64 %conv161, ptr %retval, align 8
  br label %return

sw.default162:                                    ; preds = %if.end
  %119 = load ptr, ptr %ctx.addr, align 8
  %method163 = getelementptr inbounds %struct.ssl_ctx_st, ptr %119, i32 0, i32 1
  %120 = load ptr, ptr %method163, align 8
  %ssl_ctx_ctrl = getelementptr inbounds %struct.ssl_method_st, ptr %120, i32 0, i32 21
  %121 = load ptr, ptr %ssl_ctx_ctrl, align 8
  %122 = load ptr, ptr %ctx.addr, align 8
  %123 = load i32, ptr %cmd.addr, align 4
  %124 = load i64, ptr %larg.addr, align 8
  %125 = load ptr, ptr %parg.addr, align 8
  %call164 = call i64 %121(ptr noundef %122, i32 noundef %123, i64 noundef %124, ptr noundef %125)
  store i64 %call164, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.default162, %sw.bb159, %land.end156, %sw.bb141, %land.end, %sw.bb126, %sw.bb121, %if.end120, %if.then119, %if.end111, %if.then110, %if.end102, %if.then94, %sw.bb84, %sw.bb80, %sw.bb76, %sw.bb72, %sw.bb68, %sw.bb64, %sw.bb60, %sw.bb56, %sw.bb52, %sw.bb48, %sw.bb44, %sw.bb40, %sw.bb37, %sw.bb35, %sw.bb32, %sw.bb28, %sw.bb26, %if.end24, %if.then23, %if.end17, %if.then16, %sw.bb12, %sw.bb11, %sw.bb6, %sw.bb4, %sw.default, %sw.bb1, %sw.bb
  %126 = load i64, ptr %retval, align 8
  ret i64 %126
}

declare i32 @tls1_set_groups_list(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare i32 @tls1_set_sigalgs_list(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal i64 @lh_SSL_SESSION_num_items(ptr noundef %lh) #0 {
entry:
  %lh.addr = alloca ptr, align 8
  store ptr %lh, ptr %lh.addr, align 8
  %0 = load ptr, ptr %lh.addr, align 8
  %call = call i64 @OPENSSL_LH_num_items(ptr noundef %0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @ssl_tsan_load(ptr noundef %ctx, ptr noundef %stat) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %stat.addr = alloca ptr, align 8
  %res = alloca i32, align 4
  %atomic-temp = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %stat, ptr %stat.addr, align 8
  store i32 0, ptr %res, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %call = call i32 @ssl_tsan_lock(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %stat.addr, align 8
  %2 = load atomic i32, ptr %1 monotonic, align 4
  store i32 %2, ptr %atomic-temp, align 4
  %3 = load i32, ptr %atomic-temp, align 4
  store i32 %3, ptr %res, align 4
  %4 = load ptr, ptr %ctx.addr, align 8
  call void @ssl_tsan_unlock(ptr noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, ptr %res, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define i64 @SSL_CTX_callback_ctrl(ptr noundef %ctx, i32 noundef %cmd, ptr noundef %fp) #0 {
entry:
  %retval = alloca i64, align 8
  %ctx.addr = alloca ptr, align 8
  %cmd.addr = alloca i32, align 4
  %fp.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %cmd, ptr %cmd.addr, align 4
  store ptr %fp, ptr %fp.addr, align 8
  %0 = load i32, ptr %cmd.addr, align 4
  switch i32 %0, label %sw.default [
    i32 15, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %fp.addr, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %msg_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 42
  store ptr %1, ptr %msg_callback, align 8
  store i64 1, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %entry
  %3 = load ptr, ptr %ctx.addr, align 8
  %method = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %method, align 8
  %ssl_ctx_callback_ctrl = getelementptr inbounds %struct.ssl_method_st, ptr %4, i32 0, i32 31
  %5 = load ptr, ptr %ssl_ctx_callback_ctrl, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %7 = load i32, ptr %cmd.addr, align 4
  %8 = load ptr, ptr %fp.addr, align 8
  %call = call i64 %5(ptr noundef %6, i32 noundef %7, ptr noundef %8)
  store i64 %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.default, %sw.bb
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: nounwind uwtable
define i32 @ssl_cipher_id_cmp(ptr noundef %a, ptr noundef %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %id = getelementptr inbounds %struct.ssl_cipher_st, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %id, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %id1 = getelementptr inbounds %struct.ssl_cipher_st, ptr %2, i32 0, i32 3
  %3 = load i32, ptr %id1, align 8
  %cmp = icmp ugt i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %a.addr, align 8
  %id2 = getelementptr inbounds %struct.ssl_cipher_st, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %id2, align 8
  %6 = load ptr, ptr %b.addr, align 8
  %id3 = getelementptr inbounds %struct.ssl_cipher_st, ptr %6, i32 0, i32 3
  %7 = load i32, ptr %id3, align 8
  %cmp4 = icmp ult i32 %5, %7
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define i32 @ssl_cipher_ptr_id_cmp(ptr noundef %ap, ptr noundef %bp) #0 {
entry:
  %retval = alloca i32, align 4
  %ap.addr = alloca ptr, align 8
  %bp.addr = alloca ptr, align 8
  store ptr %ap, ptr %ap.addr, align 8
  store ptr %bp, ptr %bp.addr, align 8
  %0 = load ptr, ptr %ap.addr, align 8
  %1 = load ptr, ptr %0, align 8
  %id = getelementptr inbounds %struct.ssl_cipher_st, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %id, align 8
  %3 = load ptr, ptr %bp.addr, align 8
  %4 = load ptr, ptr %3, align 8
  %id1 = getelementptr inbounds %struct.ssl_cipher_st, ptr %4, i32 0, i32 3
  %5 = load i32, ptr %id1, align 8
  %cmp = icmp ugt i32 %2, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %ap.addr, align 8
  %7 = load ptr, ptr %6, align 8
  %id2 = getelementptr inbounds %struct.ssl_cipher_st, ptr %7, i32 0, i32 3
  %8 = load i32, ptr %id2, align 8
  %9 = load ptr, ptr %bp.addr, align 8
  %10 = load ptr, ptr %9, align 8
  %id3 = getelementptr inbounds %struct.ssl_cipher_st, ptr %10, i32 0, i32 3
  %11 = load i32, ptr %id3, align 8
  %cmp4 = icmp ult i32 %8, %11
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_ciphers(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end24

if.then:                                          ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %cipher_list = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 28
  %10 = load ptr, ptr %cipher_list, align 8
  %cmp13 = icmp ne ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.then
  %11 = load ptr, ptr %sc, align 8
  %cipher_list15 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 28
  %12 = load ptr, ptr %cipher_list15, align 8
  store ptr %12, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.then
  %13 = load ptr, ptr %s.addr, align 8
  %ctx = getelementptr inbounds %struct.ssl_st, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %ctx, align 8
  %cmp16 = icmp ne ptr %14, null
  br i1 %cmp16, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %15 = load ptr, ptr %s.addr, align 8
  %ctx17 = getelementptr inbounds %struct.ssl_st, ptr %15, i32 0, i32 1
  %16 = load ptr, ptr %ctx17, align 8
  %cipher_list18 = getelementptr inbounds %struct.ssl_ctx_st, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %cipher_list18, align 8
  %cmp19 = icmp ne ptr %17, null
  br i1 %cmp19, label %if.then20, label %if.end

if.then20:                                        ; preds = %land.lhs.true
  %18 = load ptr, ptr %s.addr, align 8
  %ctx21 = getelementptr inbounds %struct.ssl_st, ptr %18, i32 0, i32 1
  %19 = load ptr, ptr %ctx21, align 8
  %cipher_list22 = getelementptr inbounds %struct.ssl_ctx_st, ptr %19, i32 0, i32 2
  %20 = load ptr, ptr %cipher_list22, align 8
  store ptr %20, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.else
  br label %if.end23

if.end23:                                         ; preds = %if.end
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end24, %if.then20, %if.then14
  %21 = load ptr, ptr %retval, align 8
  ret ptr %21
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_client_ciphers(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 7
  %10 = load i32, ptr %server, align 8
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %11 = load ptr, ptr %sc, align 8
  %peer_ciphers = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 27
  %12 = load ptr, ptr %peer_ciphers, align 8
  store ptr %12, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load ptr, ptr %retval, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get1_supported_ciphers(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sk = alloca ptr, align 8
  %ciphers = alloca ptr, align 8
  %i = alloca i32, align 4
  %sc = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr null, ptr %sk, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get_ciphers(ptr noundef %9)
  store ptr %call, ptr %ciphers, align 8
  %10 = load ptr, ptr %ciphers, align 8
  %tobool = icmp ne ptr %10, null
  br i1 %tobool, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %call15 = call i32 @ssl_set_client_disabled(ptr noundef %11)
  %tobool16 = icmp ne i32 %call15, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end14
  store ptr null, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.end14
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end18
  %12 = load i32, ptr %i, align 4
  %13 = load ptr, ptr %ciphers, align 8
  %call19 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %13)
  %call20 = call i32 @OPENSSL_sk_num(ptr noundef %call19)
  %cmp21 = icmp slt i32 %12, %call20
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load ptr, ptr %ciphers, align 8
  %call22 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %14)
  %15 = load i32, ptr %i, align 4
  %call23 = call ptr @OPENSSL_sk_value(ptr noundef %call22, i32 noundef %15)
  store ptr %call23, ptr %c, align 8
  %16 = load ptr, ptr %sc, align 8
  %17 = load ptr, ptr %c, align 8
  %call24 = call i32 @ssl_cipher_disabled(ptr noundef %16, ptr noundef %17, i32 noundef 65537, i32 noundef 0)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.end41, label %if.then26

if.then26:                                        ; preds = %for.body
  %18 = load ptr, ptr %sk, align 8
  %tobool27 = icmp ne ptr %18, null
  br i1 %tobool27, label %if.end30, label %if.then28

if.then28:                                        ; preds = %if.then26
  %call29 = call ptr @OPENSSL_sk_new_null()
  store ptr %call29, ptr %sk, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.then26
  %19 = load ptr, ptr %sk, align 8
  %tobool31 = icmp ne ptr %19, null
  br i1 %tobool31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %if.end30
  store ptr null, ptr %retval, align 8
  br label %return

if.end33:                                         ; preds = %if.end30
  %20 = load ptr, ptr %sk, align 8
  %call34 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %20)
  %21 = load ptr, ptr %c, align 8
  %call35 = call ptr @ossl_check_SSL_CIPHER_type(ptr noundef %21)
  %call36 = call i32 @OPENSSL_sk_push(ptr noundef %call34, ptr noundef %call35)
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.end40, label %if.then38

if.then38:                                        ; preds = %if.end33
  %22 = load ptr, ptr %sk, align 8
  %call39 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %22)
  call void @OPENSSL_sk_free(ptr noundef %call39)
  store ptr null, ptr %retval, align 8
  br label %return

if.end40:                                         ; preds = %if.end33
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end41
  %23 = load i32, ptr %i, align 4
  %inc = add nsw i32 %23, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !13

for.end:                                          ; preds = %for.cond
  %24 = load ptr, ptr %sk, align 8
  store ptr %24, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then38, %if.then32, %if.then17, %if.then13, %if.then
  %25 = load ptr, ptr %retval, align 8
  ret ptr %25
}

declare i32 @ssl_set_client_disabled(ptr noundef) #1

declare ptr @OPENSSL_sk_value(ptr noundef, i32 noundef) #1

declare i32 @ssl_cipher_disabled(ptr noundef, ptr noundef, i32 noundef, i32 noundef) #1

declare ptr @OPENSSL_sk_new_null() #1

declare i32 @OPENSSL_sk_push(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_SSL_CIPHER_type(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define ptr @ssl_get_ciphers_by_id(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %cipher_list_by_id = getelementptr inbounds %struct.ssl_connection_st, ptr %1, i32 0, i32 29
  %2 = load ptr, ptr %cipher_list_by_id, align 8
  %cmp1 = icmp ne ptr %2, null
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %3 = load ptr, ptr %s.addr, align 8
  %cipher_list_by_id3 = getelementptr inbounds %struct.ssl_connection_st, ptr %3, i32 0, i32 29
  %4 = load ptr, ptr %cipher_list_by_id3, align 8
  store ptr %4, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.then
  %5 = load ptr, ptr %s.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 0
  %ctx = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 1
  %6 = load ptr, ptr %ctx, align 8
  %cmp4 = icmp ne ptr %6, null
  br i1 %cmp4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %7 = load ptr, ptr %s.addr, align 8
  %ssl5 = getelementptr inbounds %struct.ssl_connection_st, ptr %7, i32 0, i32 0
  %ctx6 = getelementptr inbounds %struct.ssl_st, ptr %ssl5, i32 0, i32 1
  %8 = load ptr, ptr %ctx6, align 8
  %cipher_list_by_id7 = getelementptr inbounds %struct.ssl_ctx_st, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %cipher_list_by_id7, align 8
  %cmp8 = icmp ne ptr %9, null
  br i1 %cmp8, label %if.then9, label %if.end

if.then9:                                         ; preds = %land.lhs.true
  %10 = load ptr, ptr %s.addr, align 8
  %ssl10 = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 0
  %ctx11 = getelementptr inbounds %struct.ssl_st, ptr %ssl10, i32 0, i32 1
  %11 = load ptr, ptr %ctx11, align 8
  %cipher_list_by_id12 = getelementptr inbounds %struct.ssl_ctx_st, ptr %11, i32 0, i32 3
  %12 = load ptr, ptr %cipher_list_by_id12, align 8
  store ptr %12, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.then9, %if.then2
  %13 = load ptr, ptr %retval, align 8
  ret ptr %13
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_cipher_list(ptr noundef %s, i32 noundef %n) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %c = alloca ptr, align 8
  %sk = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get_ciphers(ptr noundef %1)
  store ptr %call, ptr %sk, align 8
  %2 = load ptr, ptr %sk, align 8
  %cmp1 = icmp eq ptr %2, null
  br i1 %cmp1, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load ptr, ptr %sk, align 8
  %call2 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %3)
  %call3 = call i32 @OPENSSL_sk_num(ptr noundef %call2)
  %4 = load i32, ptr %n.addr, align 4
  %cmp4 = icmp sle i32 %call3, %4
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false, %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  %5 = load ptr, ptr %sk, align 8
  %call7 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %5)
  %6 = load i32, ptr %n.addr, align 4
  %call8 = call ptr @OPENSSL_sk_value(ptr noundef %call7, i32 noundef %6)
  store ptr %call8, ptr %c, align 8
  %7 = load ptr, ptr %c, align 8
  %cmp9 = icmp eq ptr %7, null
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end6
  store ptr null, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end6
  %8 = load ptr, ptr %c, align 8
  %name = getelementptr inbounds %struct.ssl_cipher_st, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %name, align 8
  store ptr %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end11, %if.then10, %if.then5, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get_ciphers(ptr noundef %ctx) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %cipher_list = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 2
  %2 = load ptr, ptr %cipher_list, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load ptr, ptr %retval, align 8
  ret ptr %3
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_cipher_list(ptr noundef %ctx, ptr noundef %str) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %sk = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %tls13_ciphersuites = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %tls13_ciphersuites, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %cipher_list = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %ctx.addr, align 8
  %cipher_list_by_id = getelementptr inbounds %struct.ssl_ctx_st, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %str.addr, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %6, i32 0, i32 39
  %7 = load ptr, ptr %cert, align 8
  %call = call ptr @ssl_create_cipher_list(ptr noundef %0, ptr noundef %2, ptr noundef %cipher_list, ptr noundef %cipher_list_by_id, ptr noundef %5, ptr noundef %7)
  store ptr %call, ptr %sk, align 8
  %8 = load ptr, ptr %sk, align 8
  %cmp = icmp eq ptr %8, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %entry
  %9 = load ptr, ptr %sk, align 8
  %call1 = call i32 @cipher_list_tls12_num(ptr noundef %9)
  %cmp2 = icmp eq i32 %call1, 0
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.else
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3358, ptr noundef @__func__.SSL_CTX_set_cipher_list)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 185, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end4

if.end4:                                          ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal i32 @cipher_list_tls12_num(ptr noundef %sk) #0 {
entry:
  %retval = alloca i32, align 4
  %sk.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %num = alloca i32, align 4
  %c = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  store i32 0, ptr %num, align 4
  %0 = load ptr, ptr %sk.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %1 = load i32, ptr %i, align 4
  %2 = load ptr, ptr %sk.addr, align 8
  %call = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %2)
  %call1 = call i32 @OPENSSL_sk_num(ptr noundef %call)
  %cmp2 = icmp slt i32 %1, %call1
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %sk.addr, align 8
  %call3 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %3)
  %4 = load i32, ptr %i, align 4
  %call4 = call ptr @OPENSSL_sk_value(ptr noundef %call3, i32 noundef %4)
  store ptr %call4, ptr %c, align 8
  %5 = load ptr, ptr %c, align 8
  %min_tls = getelementptr inbounds %struct.ssl_cipher_st, ptr %5, i32 0, i32 8
  %6 = load i32, ptr %min_tls, align 4
  %cmp5 = icmp sge i32 %6, 772
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body
  br label %for.inc

if.end7:                                          ; preds = %for.body
  %7 = load i32, ptr %num, align 4
  %inc = add nsw i32 %7, 1
  store i32 %inc, ptr %num, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end7, %if.then6
  %8 = load i32, ptr %i, align 4
  %inc8 = add nsw i32 %8, 1
  store i32 %inc8, ptr %i, align 4
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %for.cond
  %9 = load i32, ptr %num, align 4
  store i32 %9, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_cipher_list(ptr noundef %s, ptr noundef %str) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %sk = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %ctx = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %ctx, align 8
  %11 = load ptr, ptr %sc, align 8
  %tls13_ciphersuites = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 30
  %12 = load ptr, ptr %tls13_ciphersuites, align 8
  %13 = load ptr, ptr %sc, align 8
  %cipher_list = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 28
  %14 = load ptr, ptr %sc, align 8
  %cipher_list_by_id = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 29
  %15 = load ptr, ptr %str.addr, align 8
  %16 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 44
  %17 = load ptr, ptr %cert, align 8
  %call = call ptr @ssl_create_cipher_list(ptr noundef %10, ptr noundef %12, ptr noundef %cipher_list, ptr noundef %cipher_list_by_id, ptr noundef %15, ptr noundef %17)
  store ptr %call, ptr %sk, align 8
  %18 = load ptr, ptr %sk, align 8
  %cmp13 = icmp eq ptr %18, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.end
  %19 = load ptr, ptr %sk, align 8
  %call15 = call i32 @cipher_list_tls12_num(ptr noundef %19)
  %cmp16 = icmp eq i32 %call15, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.else
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3380, ptr noundef @__func__.SSL_set_cipher_list)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 185, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.else
  br label %if.end19

if.end19:                                         ; preds = %if.end18
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end19, %if.then17, %if.then14, %if.then
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_shared_ciphers(ptr noundef %s, ptr noundef %buf, i32 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  %p = alloca ptr, align 8
  %clntsk = alloca ptr, align 8
  %srvrsk = alloca ptr, align 8
  %c = alloca ptr, align 8
  %i = alloca i32, align 4
  %sc = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 7
  %10 = load i32, ptr %server, align 8
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then16

lor.lhs.false:                                    ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %peer_ciphers = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 27
  %12 = load ptr, ptr %peer_ciphers, align 8
  %cmp13 = icmp eq ptr %12, null
  br i1 %cmp13, label %if.then16, label %lor.lhs.false14

lor.lhs.false14:                                  ; preds = %lor.lhs.false
  %13 = load i32, ptr %size.addr, align 4
  %cmp15 = icmp slt i32 %13, 2
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false14, %lor.lhs.false, %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %lor.lhs.false14
  %14 = load ptr, ptr %buf.addr, align 8
  store ptr %14, ptr %p, align 8
  %15 = load ptr, ptr %sc, align 8
  %peer_ciphers18 = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 27
  %16 = load ptr, ptr %peer_ciphers18, align 8
  store ptr %16, ptr %clntsk, align 8
  %17 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get_ciphers(ptr noundef %17)
  store ptr %call, ptr %srvrsk, align 8
  %18 = load ptr, ptr %clntsk, align 8
  %cmp19 = icmp eq ptr %18, null
  br i1 %cmp19, label %if.then22, label %lor.lhs.false20

lor.lhs.false20:                                  ; preds = %if.end17
  %19 = load ptr, ptr %srvrsk, align 8
  %cmp21 = icmp eq ptr %19, null
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %lor.lhs.false20, %if.end17
  store ptr null, ptr %retval, align 8
  br label %return

if.end23:                                         ; preds = %lor.lhs.false20
  %20 = load ptr, ptr %clntsk, align 8
  %call24 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %20)
  %call25 = call i32 @OPENSSL_sk_num(ptr noundef %call24)
  %cmp26 = icmp eq i32 %call25, 0
  br i1 %cmp26, label %if.then31, label %lor.lhs.false27

lor.lhs.false27:                                  ; preds = %if.end23
  %21 = load ptr, ptr %srvrsk, align 8
  %call28 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %21)
  %call29 = call i32 @OPENSSL_sk_num(ptr noundef %call28)
  %cmp30 = icmp eq i32 %call29, 0
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %lor.lhs.false27, %if.end23
  store ptr null, ptr %retval, align 8
  br label %return

if.end32:                                         ; preds = %lor.lhs.false27
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end32
  %22 = load i32, ptr %i, align 4
  %23 = load ptr, ptr %clntsk, align 8
  %call33 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %23)
  %call34 = call i32 @OPENSSL_sk_num(ptr noundef %call33)
  %cmp35 = icmp slt i32 %22, %call34
  br i1 %cmp35, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %24 = load ptr, ptr %clntsk, align 8
  %call36 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %24)
  %25 = load i32, ptr %i, align 4
  %call37 = call ptr @OPENSSL_sk_value(ptr noundef %call36, i32 noundef %25)
  store ptr %call37, ptr %c, align 8
  %26 = load ptr, ptr %srvrsk, align 8
  %call38 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %26)
  %27 = load ptr, ptr %c, align 8
  %call39 = call ptr @ossl_check_SSL_CIPHER_type(ptr noundef %27)
  %call40 = call i32 @OPENSSL_sk_find(ptr noundef %call38, ptr noundef %call39)
  %cmp41 = icmp slt i32 %call40, 0
  br i1 %cmp41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %for.body
  br label %for.inc

if.end43:                                         ; preds = %for.body
  %28 = load ptr, ptr %c, align 8
  %name = getelementptr inbounds %struct.ssl_cipher_st, ptr %28, i32 0, i32 1
  %29 = load ptr, ptr %name, align 8
  %30 = load i32, ptr %size.addr, align 4
  %conv = sext i32 %30 to i64
  %call44 = call i64 @OPENSSL_strnlen(ptr noundef %29, i64 noundef %conv)
  %conv45 = trunc i64 %call44 to i32
  store i32 %conv45, ptr %n, align 4
  %31 = load i32, ptr %n, align 4
  %32 = load i32, ptr %size.addr, align 4
  %cmp46 = icmp sge i32 %31, %32
  br i1 %cmp46, label %if.then48, label %if.end53

if.then48:                                        ; preds = %if.end43
  %33 = load ptr, ptr %p, align 8
  %34 = load ptr, ptr %buf.addr, align 8
  %cmp49 = icmp ne ptr %33, %34
  br i1 %cmp49, label %if.then51, label %if.end52

if.then51:                                        ; preds = %if.then48
  %35 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %35, i32 -1
  store ptr %incdec.ptr, ptr %p, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %if.then48
  %36 = load ptr, ptr %p, align 8
  store i8 0, ptr %36, align 1
  %37 = load ptr, ptr %buf.addr, align 8
  store ptr %37, ptr %retval, align 8
  br label %return

if.end53:                                         ; preds = %if.end43
  %38 = load ptr, ptr %p, align 8
  %39 = load ptr, ptr %c, align 8
  %name54 = getelementptr inbounds %struct.ssl_cipher_st, ptr %39, i32 0, i32 1
  %40 = load ptr, ptr %name54, align 8
  %41 = load i32, ptr %n, align 4
  %conv55 = sext i32 %41 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %38, ptr align 1 %40, i64 %conv55, i1 false)
  %42 = load i32, ptr %n, align 4
  %43 = load ptr, ptr %p, align 8
  %idx.ext = sext i32 %42 to i64
  %add.ptr = getelementptr inbounds i8, ptr %43, i64 %idx.ext
  store ptr %add.ptr, ptr %p, align 8
  %44 = load ptr, ptr %p, align 8
  %incdec.ptr56 = getelementptr inbounds i8, ptr %44, i32 1
  store ptr %incdec.ptr56, ptr %p, align 8
  store i8 58, ptr %44, align 1
  %45 = load i32, ptr %n, align 4
  %add = add nsw i32 %45, 1
  %46 = load i32, ptr %size.addr, align 4
  %sub = sub nsw i32 %46, %add
  store i32 %sub, ptr %size.addr, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end53, %if.then42
  %47 = load i32, ptr %i, align 4
  %inc = add nsw i32 %47, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !15

for.end:                                          ; preds = %for.cond
  %48 = load ptr, ptr %p, align 8
  %arrayidx = getelementptr inbounds i8, ptr %48, i64 -1
  store i8 0, ptr %arrayidx, align 1
  %49 = load ptr, ptr %buf.addr, align 8
  store ptr %49, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.end52, %if.then31, %if.then22, %if.then16, %if.then
  %50 = load ptr, ptr %retval, align 8
  ret ptr %50
}

declare i32 @OPENSSL_sk_find(ptr noundef, ptr noundef) #1

declare i64 @OPENSSL_strnlen(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_get_servername(ptr noundef %s, i32 noundef %type) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  %server = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end11

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type1 = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type1, align 8
  %cmp2 = icmp eq i32 %2, 0
  br i1 %cmp2, label %cond.true3, label %cond.false4

cond.true3:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end9

cond.false4:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type5 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type5, align 8
  %cmp6 = icmp eq i32 %5, 1
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.false4
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false8:                                      ; preds = %cond.false4
  br label %cond.end

cond.end:                                         ; preds = %cond.false8, %cond.true7
  %cond = phi ptr [ %7, %cond.true7 ], [ null, %cond.false8 ]
  br label %cond.end9

cond.end9:                                        ; preds = %cond.end, %cond.true3
  %cond10 = phi ptr [ %3, %cond.true3 ], [ %cond, %cond.end ]
  br label %cond.end11

cond.end11:                                       ; preds = %cond.end9, %cond.true
  %cond12 = phi ptr [ null, %cond.true ], [ %cond10, %cond.end9 ]
  store ptr %cond12, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp13 = icmp eq ptr %8, null
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end11
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end11
  %9 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 6
  %10 = load ptr, ptr %handshake_func, align 8
  %cmp14 = icmp eq ptr %10, null
  br i1 %cmp14, label %cond.true15, label %cond.false16

cond.true15:                                      ; preds = %if.end
  br label %cond.end18

cond.false16:                                     ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %server17 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 7
  %12 = load i32, ptr %server17, align 8
  br label %cond.end18

cond.end18:                                       ; preds = %cond.false16, %cond.true15
  %cond19 = phi i32 [ 0, %cond.true15 ], [ %12, %cond.false16 ]
  store i32 %cond19, ptr %server, align 4
  %13 = load i32, ptr %type.addr, align 4
  %cmp20 = icmp ne i32 %13, 0
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %cond.end18
  store ptr null, ptr %retval, align 8
  br label %return

if.end22:                                         ; preds = %cond.end18
  %14 = load i32, ptr %server, align 4
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.then23, label %if.else

if.then23:                                        ; preds = %if.end22
  %15 = load ptr, ptr %sc, align 8
  %hit = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 24
  %16 = load i32, ptr %hit, align 8
  %tobool24 = icmp ne i32 %16, 0
  br i1 %tobool24, label %land.lhs.true, label %if.end36

land.lhs.true:                                    ; preds = %if.then23
  %17 = load ptr, ptr %sc, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %18 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %18, i32 0, i32 28
  %19 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %19, i32 0, i32 10
  %20 = load i32, ptr %enc_flags, align 8
  %and = and i32 %20, 8
  %tobool25 = icmp ne i32 %and, 0
  br i1 %tobool25, label %if.then35, label %land.lhs.true26

land.lhs.true26:                                  ; preds = %land.lhs.true
  %21 = load ptr, ptr %sc, align 8
  %ssl27 = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 0
  %method28 = getelementptr inbounds %struct.ssl_st, ptr %ssl27, i32 0, i32 3
  %22 = load ptr, ptr %method28, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %22, i32 0, i32 0
  %23 = load i32, ptr %version, align 8
  %cmp29 = icmp sge i32 %23, 772
  br i1 %cmp29, label %land.lhs.true30, label %if.then35

land.lhs.true30:                                  ; preds = %land.lhs.true26
  %24 = load ptr, ptr %sc, align 8
  %ssl31 = getelementptr inbounds %struct.ssl_connection_st, ptr %24, i32 0, i32 0
  %method32 = getelementptr inbounds %struct.ssl_st, ptr %ssl31, i32 0, i32 3
  %25 = load ptr, ptr %method32, align 8
  %version33 = getelementptr inbounds %struct.ssl_method_st, ptr %25, i32 0, i32 0
  %26 = load i32, ptr %version33, align 8
  %cmp34 = icmp ne i32 %26, 65536
  br i1 %cmp34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %land.lhs.true30, %land.lhs.true26, %land.lhs.true
  %27 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 50
  %28 = load ptr, ptr %session, align 8
  %ext = getelementptr inbounds %struct.ssl_session_st, ptr %28, i32 0, i32 26
  %hostname = getelementptr inbounds %struct.anon.5, ptr %ext, i32 0, i32 0
  %29 = load ptr, ptr %hostname, align 8
  store ptr %29, ptr %retval, align 8
  br label %return

if.end36:                                         ; preds = %land.lhs.true30, %if.then23
  br label %if.end84

if.else:                                          ; preds = %if.end22
  %30 = load ptr, ptr %s.addr, align 8
  %call = call i32 @SSL_in_before(ptr noundef %30)
  %tobool37 = icmp ne i32 %call, 0
  br i1 %tobool37, label %if.then38, label %if.else53

if.then38:                                        ; preds = %if.else
  %31 = load ptr, ptr %sc, align 8
  %ext39 = getelementptr inbounds %struct.ssl_connection_st, ptr %31, i32 0, i32 80
  %hostname40 = getelementptr inbounds %struct.anon.1, ptr %ext39, i32 0, i32 3
  %32 = load ptr, ptr %hostname40, align 8
  %cmp41 = icmp eq ptr %32, null
  br i1 %cmp41, label %land.lhs.true42, label %if.end52

land.lhs.true42:                                  ; preds = %if.then38
  %33 = load ptr, ptr %sc, align 8
  %session43 = getelementptr inbounds %struct.ssl_connection_st, ptr %33, i32 0, i32 50
  %34 = load ptr, ptr %session43, align 8
  %cmp44 = icmp ne ptr %34, null
  br i1 %cmp44, label %land.lhs.true45, label %if.end52

land.lhs.true45:                                  ; preds = %land.lhs.true42
  %35 = load ptr, ptr %sc, align 8
  %session46 = getelementptr inbounds %struct.ssl_connection_st, ptr %35, i32 0, i32 50
  %36 = load ptr, ptr %session46, align 8
  %ssl_version = getelementptr inbounds %struct.ssl_session_st, ptr %36, i32 0, i32 0
  %37 = load i32, ptr %ssl_version, align 8
  %cmp47 = icmp ne i32 %37, 772
  br i1 %cmp47, label %if.then48, label %if.end52

if.then48:                                        ; preds = %land.lhs.true45
  %38 = load ptr, ptr %sc, align 8
  %session49 = getelementptr inbounds %struct.ssl_connection_st, ptr %38, i32 0, i32 50
  %39 = load ptr, ptr %session49, align 8
  %ext50 = getelementptr inbounds %struct.ssl_session_st, ptr %39, i32 0, i32 26
  %hostname51 = getelementptr inbounds %struct.anon.5, ptr %ext50, i32 0, i32 0
  %40 = load ptr, ptr %hostname51, align 8
  store ptr %40, ptr %retval, align 8
  br label %return

if.end52:                                         ; preds = %land.lhs.true45, %land.lhs.true42, %if.then38
  br label %if.end83

if.else53:                                        ; preds = %if.else
  %41 = load ptr, ptr %sc, align 8
  %ssl54 = getelementptr inbounds %struct.ssl_connection_st, ptr %41, i32 0, i32 0
  %method55 = getelementptr inbounds %struct.ssl_st, ptr %ssl54, i32 0, i32 3
  %42 = load ptr, ptr %method55, align 8
  %ssl3_enc56 = getelementptr inbounds %struct.ssl_method_st, ptr %42, i32 0, i32 28
  %43 = load ptr, ptr %ssl3_enc56, align 8
  %enc_flags57 = getelementptr inbounds %struct.ssl3_enc_method, ptr %43, i32 0, i32 10
  %44 = load i32, ptr %enc_flags57, align 8
  %and58 = and i32 %44, 8
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %land.lhs.true70, label %land.lhs.true60

land.lhs.true60:                                  ; preds = %if.else53
  %45 = load ptr, ptr %sc, align 8
  %ssl61 = getelementptr inbounds %struct.ssl_connection_st, ptr %45, i32 0, i32 0
  %method62 = getelementptr inbounds %struct.ssl_st, ptr %ssl61, i32 0, i32 3
  %46 = load ptr, ptr %method62, align 8
  %version63 = getelementptr inbounds %struct.ssl_method_st, ptr %46, i32 0, i32 0
  %47 = load i32, ptr %version63, align 8
  %cmp64 = icmp sge i32 %47, 772
  br i1 %cmp64, label %land.lhs.true65, label %land.lhs.true70

land.lhs.true65:                                  ; preds = %land.lhs.true60
  %48 = load ptr, ptr %sc, align 8
  %ssl66 = getelementptr inbounds %struct.ssl_connection_st, ptr %48, i32 0, i32 0
  %method67 = getelementptr inbounds %struct.ssl_st, ptr %ssl66, i32 0, i32 3
  %49 = load ptr, ptr %method67, align 8
  %version68 = getelementptr inbounds %struct.ssl_method_st, ptr %49, i32 0, i32 0
  %50 = load i32, ptr %version68, align 8
  %cmp69 = icmp ne i32 %50, 65536
  br i1 %cmp69, label %if.end82, label %land.lhs.true70

land.lhs.true70:                                  ; preds = %land.lhs.true65, %land.lhs.true60, %if.else53
  %51 = load ptr, ptr %sc, align 8
  %hit71 = getelementptr inbounds %struct.ssl_connection_st, ptr %51, i32 0, i32 24
  %52 = load i32, ptr %hit71, align 8
  %tobool72 = icmp ne i32 %52, 0
  br i1 %tobool72, label %land.lhs.true73, label %if.end82

land.lhs.true73:                                  ; preds = %land.lhs.true70
  %53 = load ptr, ptr %sc, align 8
  %session74 = getelementptr inbounds %struct.ssl_connection_st, ptr %53, i32 0, i32 50
  %54 = load ptr, ptr %session74, align 8
  %ext75 = getelementptr inbounds %struct.ssl_session_st, ptr %54, i32 0, i32 26
  %hostname76 = getelementptr inbounds %struct.anon.5, ptr %ext75, i32 0, i32 0
  %55 = load ptr, ptr %hostname76, align 8
  %cmp77 = icmp ne ptr %55, null
  br i1 %cmp77, label %if.then78, label %if.end82

if.then78:                                        ; preds = %land.lhs.true73
  %56 = load ptr, ptr %sc, align 8
  %session79 = getelementptr inbounds %struct.ssl_connection_st, ptr %56, i32 0, i32 50
  %57 = load ptr, ptr %session79, align 8
  %ext80 = getelementptr inbounds %struct.ssl_session_st, ptr %57, i32 0, i32 26
  %hostname81 = getelementptr inbounds %struct.anon.5, ptr %ext80, i32 0, i32 0
  %58 = load ptr, ptr %hostname81, align 8
  store ptr %58, ptr %retval, align 8
  br label %return

if.end82:                                         ; preds = %land.lhs.true73, %land.lhs.true70, %land.lhs.true65
  br label %if.end83

if.end83:                                         ; preds = %if.end82, %if.end52
  br label %if.end84

if.end84:                                         ; preds = %if.end83, %if.end36
  %59 = load ptr, ptr %sc, align 8
  %ext85 = getelementptr inbounds %struct.ssl_connection_st, ptr %59, i32 0, i32 80
  %hostname86 = getelementptr inbounds %struct.anon.1, ptr %ext85, i32 0, i32 3
  %60 = load ptr, ptr %hostname86, align 8
  store ptr %60, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end84, %if.then78, %if.then48, %if.then35, %if.then21, %if.then
  %61 = load ptr, ptr %retval, align 8
  ret ptr %61
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_servername_type(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get_servername(ptr noundef %0, i32 noundef 0)
  %cmp = icmp ne ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load i32, ptr %retval, align 4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_select_next_proto(ptr noundef %out, ptr noundef %outlen, ptr noundef %server, i32 noundef %server_len, ptr noundef %client, i32 noundef %client_len) #0 {
entry:
  %out.addr = alloca ptr, align 8
  %outlen.addr = alloca ptr, align 8
  %server.addr = alloca ptr, align 8
  %server_len.addr = alloca i32, align 4
  %client.addr = alloca ptr, align 8
  %client_len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %result = alloca ptr, align 8
  %status = alloca i32, align 4
  store ptr %out, ptr %out.addr, align 8
  store ptr %outlen, ptr %outlen.addr, align 8
  store ptr %server, ptr %server.addr, align 8
  store i32 %server_len, ptr %server_len.addr, align 4
  store ptr %client, ptr %client.addr, align 8
  store i32 %client_len, ptr %client_len.addr, align 4
  store i32 0, ptr %status, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.end, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %server_len.addr, align 4
  %cmp = icmp ult i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end30

for.body:                                         ; preds = %for.cond
  store i32 0, ptr %j, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %if.end, %for.body
  %2 = load i32, ptr %j, align 4
  %3 = load i32, ptr %client_len.addr, align 4
  %cmp2 = icmp ult i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load ptr, ptr %server.addr, align 8
  %5 = load i32, ptr %i, align 4
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, ptr %4, i64 %idxprom
  %6 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %6 to i32
  %7 = load ptr, ptr %client.addr, align 8
  %8 = load i32, ptr %j, align 4
  %idxprom4 = zext i32 %8 to i64
  %arrayidx5 = getelementptr inbounds i8, ptr %7, i64 %idxprom4
  %9 = load i8, ptr %arrayidx5, align 1
  %conv6 = zext i8 %9 to i32
  %cmp7 = icmp eq i32 %conv, %conv6
  br i1 %cmp7, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body3
  %10 = load ptr, ptr %server.addr, align 8
  %11 = load i32, ptr %i, align 4
  %add = add i32 %11, 1
  %idxprom9 = zext i32 %add to i64
  %arrayidx10 = getelementptr inbounds i8, ptr %10, i64 %idxprom9
  %12 = load ptr, ptr %client.addr, align 8
  %13 = load i32, ptr %j, align 4
  %add11 = add i32 %13, 1
  %idxprom12 = zext i32 %add11 to i64
  %arrayidx13 = getelementptr inbounds i8, ptr %12, i64 %idxprom12
  %14 = load ptr, ptr %server.addr, align 8
  %15 = load i32, ptr %i, align 4
  %idxprom14 = zext i32 %15 to i64
  %arrayidx15 = getelementptr inbounds i8, ptr %14, i64 %idxprom14
  %16 = load i8, ptr %arrayidx15, align 1
  %conv16 = zext i8 %16 to i64
  %call = call i32 @memcmp(ptr noundef %arrayidx10, ptr noundef %arrayidx13, i64 noundef %conv16) #6
  %cmp17 = icmp eq i32 %call, 0
  br i1 %cmp17, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %17 = load ptr, ptr %server.addr, align 8
  %18 = load i32, ptr %i, align 4
  %idxprom19 = zext i32 %18 to i64
  %arrayidx20 = getelementptr inbounds i8, ptr %17, i64 %idxprom19
  store ptr %arrayidx20, ptr %result, align 8
  store i32 1, ptr %status, align 4
  br label %found

if.end:                                           ; preds = %land.lhs.true, %for.body3
  %19 = load ptr, ptr %client.addr, align 8
  %20 = load i32, ptr %j, align 4
  %idxprom21 = zext i32 %20 to i64
  %arrayidx22 = getelementptr inbounds i8, ptr %19, i64 %idxprom21
  %21 = load i8, ptr %arrayidx22, align 1
  %conv23 = zext i8 %21 to i32
  %22 = load i32, ptr %j, align 4
  %add24 = add i32 %22, %conv23
  store i32 %add24, ptr %j, align 4
  %23 = load i32, ptr %j, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %j, align 4
  br label %for.cond1, !llvm.loop !16

for.end:                                          ; preds = %for.cond1
  %24 = load ptr, ptr %server.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idxprom25 = zext i32 %25 to i64
  %arrayidx26 = getelementptr inbounds i8, ptr %24, i64 %idxprom25
  %26 = load i8, ptr %arrayidx26, align 1
  %conv27 = zext i8 %26 to i32
  %27 = load i32, ptr %i, align 4
  %add28 = add i32 %27, %conv27
  store i32 %add28, ptr %i, align 4
  %28 = load i32, ptr %i, align 4
  %inc29 = add i32 %28, 1
  store i32 %inc29, ptr %i, align 4
  br label %for.cond, !llvm.loop !17

for.end30:                                        ; preds = %for.cond
  %29 = load ptr, ptr %client.addr, align 8
  store ptr %29, ptr %result, align 8
  store i32 2, ptr %status, align 4
  br label %found

found:                                            ; preds = %for.end30, %if.then
  %30 = load ptr, ptr %result, align 8
  %add.ptr = getelementptr inbounds i8, ptr %30, i64 1
  %31 = load ptr, ptr %out.addr, align 8
  store ptr %add.ptr, ptr %31, align 8
  %32 = load ptr, ptr %result, align 8
  %arrayidx31 = getelementptr inbounds i8, ptr %32, i64 0
  %33 = load i8, ptr %arrayidx31, align 1
  %34 = load ptr, ptr %outlen.addr, align 8
  store i8 %33, ptr %34, align 1
  %35 = load i32, ptr %status, align 4
  ret i32 %35
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #4

; Function Attrs: nounwind uwtable
define void @SSL_get0_next_proto_negotiated(ptr noundef %s, ptr noundef %data, ptr noundef %len) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  %9 = load ptr, ptr %data.addr, align 8
  store ptr null, ptr %9, align 8
  %10 = load ptr, ptr %len.addr, align 8
  store i32 0, ptr %10, align 4
  br label %if.end16

if.end:                                           ; preds = %cond.end10
  %11 = load ptr, ptr %sc, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 80
  %npn = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 26
  %12 = load ptr, ptr %npn, align 8
  %13 = load ptr, ptr %data.addr, align 8
  store ptr %12, ptr %13, align 8
  %14 = load ptr, ptr %data.addr, align 8
  %15 = load ptr, ptr %14, align 8
  %cmp13 = icmp eq ptr %15, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  %16 = load ptr, ptr %len.addr, align 8
  store i32 0, ptr %16, align 4
  br label %if.end16

if.else:                                          ; preds = %if.end
  %17 = load ptr, ptr %sc, align 8
  %ext15 = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 80
  %npn_len = getelementptr inbounds %struct.anon.1, ptr %ext15, i32 0, i32 27
  %18 = load i64, ptr %npn_len, align 8
  %conv = trunc i64 %18 to i32
  %19 = load ptr, ptr %len.addr, align 8
  store i32 %conv, ptr %19, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then14, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_next_protos_advertised_cb(ptr noundef %ctx, ptr noundef %cb, ptr noundef %arg) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %method = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %method, align 8
  %call = call ptr @OSSL_QUIC_client_method()
  %cmp = icmp eq ptr %1, %call
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %method1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %method1, align 8
  %call2 = call ptr @OSSL_QUIC_client_thread_method()
  %cmp3 = icmp eq ptr %3, %call2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %cb.addr, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %ext = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 61
  %npn_advertised_cb = getelementptr inbounds %struct.anon.4, ptr %ext, i32 0, i32 20
  store ptr %4, ptr %npn_advertised_cb, align 8
  %6 = load ptr, ptr %arg.addr, align 8
  %7 = load ptr, ptr %ctx.addr, align 8
  %ext4 = getelementptr inbounds %struct.ssl_ctx_st, ptr %7, i32 0, i32 61
  %npn_advertised_cb_arg = getelementptr inbounds %struct.anon.4, ptr %ext4, i32 0, i32 21
  store ptr %6, ptr %npn_advertised_cb_arg, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_next_proto_select_cb(ptr noundef %ctx, ptr noundef %cb, ptr noundef %arg) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %method = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %method, align 8
  %call = call ptr @OSSL_QUIC_client_method()
  %cmp = icmp eq ptr %1, %call
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %method1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %method1, align 8
  %call2 = call ptr @OSSL_QUIC_client_thread_method()
  %cmp3 = icmp eq ptr %3, %call2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %cb.addr, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %ext = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 61
  %npn_select_cb = getelementptr inbounds %struct.anon.4, ptr %ext, i32 0, i32 22
  store ptr %4, ptr %npn_select_cb, align 8
  %6 = load ptr, ptr %arg.addr, align 8
  %7 = load ptr, ptr %ctx.addr, align 8
  %ext4 = getelementptr inbounds %struct.ssl_ctx_st, ptr %7, i32 0, i32 61
  %npn_select_cb_arg = getelementptr inbounds %struct.anon.4, ptr %ext4, i32 0, i32 23
  store ptr %6, ptr %npn_select_cb_arg, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_alpn_protos(ptr noundef %ctx, ptr noundef %protos, i32 noundef %protos_len) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %protos.addr = alloca ptr, align 8
  %protos_len.addr = alloca i32, align 4
  %alpn = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %protos, ptr %protos.addr, align 8
  store i32 %protos_len, ptr %protos_len.addr, align 4
  %0 = load i32, ptr %protos_len.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %protos.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %ext = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 61
  %alpn2 = getelementptr inbounds %struct.anon.4, ptr %ext, i32 0, i32 18
  %3 = load ptr, ptr %alpn2, align 8
  call void @CRYPTO_free(ptr noundef %3, ptr noundef @.str, i32 noundef 3681)
  %4 = load ptr, ptr %ctx.addr, align 8
  %ext3 = getelementptr inbounds %struct.ssl_ctx_st, ptr %4, i32 0, i32 61
  %alpn4 = getelementptr inbounds %struct.anon.4, ptr %ext3, i32 0, i32 18
  store ptr null, ptr %alpn4, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %ext5 = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 61
  %alpn_len = getelementptr inbounds %struct.anon.4, ptr %ext5, i32 0, i32 19
  store i64 0, ptr %alpn_len, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %6 = load ptr, ptr %protos.addr, align 8
  %7 = load i32, ptr %protos_len.addr, align 4
  %call = call i32 @alpn_value_ok(ptr noundef %6, i32 noundef %7)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %8 = load ptr, ptr %protos.addr, align 8
  %9 = load i32, ptr %protos_len.addr, align 4
  %conv = zext i32 %9 to i64
  %call8 = call noalias ptr @CRYPTO_memdup(ptr noundef %8, i64 noundef %conv, ptr noundef @.str, i32 noundef 3690)
  store ptr %call8, ptr %alpn, align 8
  %10 = load ptr, ptr %alpn, align 8
  %cmp9 = icmp eq ptr %10, null
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end7
  store i32 1, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end7
  %11 = load ptr, ptr %ctx.addr, align 8
  %ext13 = getelementptr inbounds %struct.ssl_ctx_st, ptr %11, i32 0, i32 61
  %alpn14 = getelementptr inbounds %struct.anon.4, ptr %ext13, i32 0, i32 18
  %12 = load ptr, ptr %alpn14, align 8
  call void @CRYPTO_free(ptr noundef %12, ptr noundef @.str, i32 noundef 3693)
  %13 = load ptr, ptr %alpn, align 8
  %14 = load ptr, ptr %ctx.addr, align 8
  %ext15 = getelementptr inbounds %struct.ssl_ctx_st, ptr %14, i32 0, i32 61
  %alpn16 = getelementptr inbounds %struct.anon.4, ptr %ext15, i32 0, i32 18
  store ptr %13, ptr %alpn16, align 8
  %15 = load i32, ptr %protos_len.addr, align 4
  %conv17 = zext i32 %15 to i64
  %16 = load ptr, ptr %ctx.addr, align 8
  %ext18 = getelementptr inbounds %struct.ssl_ctx_st, ptr %16, i32 0, i32 61
  %alpn_len19 = getelementptr inbounds %struct.anon.4, ptr %ext18, i32 0, i32 19
  store i64 %conv17, ptr %alpn_len19, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then11, %if.then6, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define internal i32 @alpn_value_ok(ptr noundef %protos, i32 noundef %protos_len) #0 {
entry:
  %retval = alloca i32, align 4
  %protos.addr = alloca ptr, align 8
  %protos_len.addr = alloca i32, align 4
  %idx = alloca i32, align 4
  store ptr %protos, ptr %protos.addr, align 8
  store i32 %protos_len, ptr %protos_len.addr, align 4
  %0 = load i32, ptr %protos_len.addr, align 4
  %cmp = icmp ult i32 %0, 2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %protos.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  store i32 0, ptr %idx, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i32, ptr %idx, align 4
  %3 = load i32, ptr %protos_len.addr, align 4
  %cmp2 = icmp ult i32 %2, %3
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %protos.addr, align 8
  %5 = load i32, ptr %idx, align 4
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, ptr %4, i64 %idxprom
  %6 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %6 to i32
  %cmp3 = icmp eq i32 %conv, 0
  br i1 %cmp3, label %if.then5, label %if.end6

if.then5:                                         ; preds = %for.body
  store i32 0, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %7 = load ptr, ptr %protos.addr, align 8
  %8 = load i32, ptr %idx, align 4
  %idxprom7 = zext i32 %8 to i64
  %arrayidx8 = getelementptr inbounds i8, ptr %7, i64 %idxprom7
  %9 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %9 to i32
  %add = add nsw i32 %conv9, 1
  %10 = load i32, ptr %idx, align 4
  %add10 = add i32 %10, %add
  store i32 %add10, ptr %idx, align 4
  br label %for.cond, !llvm.loop !18

for.end:                                          ; preds = %for.cond
  %11 = load i32, ptr %idx, align 4
  %12 = load i32, ptr %protos_len.addr, align 4
  %cmp11 = icmp eq i32 %11, %12
  %conv12 = zext i1 %cmp11 to i32
  store i32 %conv12, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_alpn_protos(ptr noundef %ssl, ptr noundef %protos, i32 noundef %protos_len) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %protos.addr = alloca ptr, align 8
  %protos_len.addr = alloca i32, align 4
  %alpn = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %protos, ptr %protos.addr, align 8
  store i32 %protos_len, ptr %protos_len.addr, align 4
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load i32, ptr %protos_len.addr, align 4
  %cmp13 = icmp eq i32 %9, 0
  br i1 %cmp13, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %10 = load ptr, ptr %protos.addr, align 8
  %cmp14 = icmp eq ptr %10, null
  br i1 %cmp14, label %if.then15, label %if.end20

if.then15:                                        ; preds = %lor.lhs.false, %if.end
  %11 = load ptr, ptr %sc, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 80
  %alpn16 = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 24
  %12 = load ptr, ptr %alpn16, align 8
  call void @CRYPTO_free(ptr noundef %12, ptr noundef @.str, i32 noundef 3715)
  %13 = load ptr, ptr %sc, align 8
  %ext17 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 80
  %alpn18 = getelementptr inbounds %struct.anon.1, ptr %ext17, i32 0, i32 24
  store ptr null, ptr %alpn18, align 8
  %14 = load ptr, ptr %sc, align 8
  %ext19 = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 80
  %alpn_len = getelementptr inbounds %struct.anon.1, ptr %ext19, i32 0, i32 25
  store i64 0, ptr %alpn_len, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end20:                                         ; preds = %lor.lhs.false
  %15 = load ptr, ptr %protos.addr, align 8
  %16 = load i32, ptr %protos_len.addr, align 4
  %call = call i32 @alpn_value_ok(ptr noundef %15, i32 noundef %16)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end22, label %if.then21

if.then21:                                        ; preds = %if.end20
  store i32 1, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end20
  %17 = load ptr, ptr %protos.addr, align 8
  %18 = load i32, ptr %protos_len.addr, align 4
  %conv = zext i32 %18 to i64
  %call23 = call noalias ptr @CRYPTO_memdup(ptr noundef %17, i64 noundef %conv, ptr noundef @.str, i32 noundef 3724)
  store ptr %call23, ptr %alpn, align 8
  %19 = load ptr, ptr %alpn, align 8
  %cmp24 = icmp eq ptr %19, null
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.end22
  store i32 1, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.end22
  %20 = load ptr, ptr %sc, align 8
  %ext28 = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 80
  %alpn29 = getelementptr inbounds %struct.anon.1, ptr %ext28, i32 0, i32 24
  %21 = load ptr, ptr %alpn29, align 8
  call void @CRYPTO_free(ptr noundef %21, ptr noundef @.str, i32 noundef 3727)
  %22 = load ptr, ptr %alpn, align 8
  %23 = load ptr, ptr %sc, align 8
  %ext30 = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 80
  %alpn31 = getelementptr inbounds %struct.anon.1, ptr %ext30, i32 0, i32 24
  store ptr %22, ptr %alpn31, align 8
  %24 = load i32, ptr %protos_len.addr, align 4
  %conv32 = zext i32 %24 to i64
  %25 = load ptr, ptr %sc, align 8
  %ext33 = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 80
  %alpn_len34 = getelementptr inbounds %struct.anon.1, ptr %ext33, i32 0, i32 25
  store i64 %conv32, ptr %alpn_len34, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end27, %if.then26, %if.then21, %if.then15, %if.then
  %26 = load i32, ptr %retval, align 4
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_alpn_select_cb(ptr noundef %ctx, ptr noundef %cb, ptr noundef %arg) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %ext = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 61
  %alpn_select_cb = getelementptr inbounds %struct.anon.4, ptr %ext, i32 0, i32 16
  store ptr %0, ptr %alpn_select_cb, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %ext1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 61
  %alpn_select_cb_arg = getelementptr inbounds %struct.anon.4, ptr %ext1, i32 0, i32 17
  store ptr %2, ptr %alpn_select_cb_arg, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_get0_alpn_selected(ptr noundef %ssl, ptr noundef %data, ptr noundef %len) #0 {
entry:
  %ssl.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  %9 = load ptr, ptr %data.addr, align 8
  store ptr null, ptr %9, align 8
  %10 = load ptr, ptr %len.addr, align 8
  store i32 0, ptr %10, align 4
  br label %if.end16

if.end:                                           ; preds = %cond.end10
  %11 = load ptr, ptr %sc, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 20
  %alpn_selected = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 21
  %12 = load ptr, ptr %alpn_selected, align 8
  %13 = load ptr, ptr %data.addr, align 8
  store ptr %12, ptr %13, align 8
  %14 = load ptr, ptr %data.addr, align 8
  %15 = load ptr, ptr %14, align 8
  %cmp13 = icmp eq ptr %15, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  %16 = load ptr, ptr %len.addr, align 8
  store i32 0, ptr %16, align 4
  br label %if.end16

if.else:                                          ; preds = %if.end
  %17 = load ptr, ptr %sc, align 8
  %s315 = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 20
  %alpn_selected_len = getelementptr inbounds %struct.anon, ptr %s315, i32 0, i32 22
  %18 = load i64, ptr %alpn_selected_len, align 8
  %conv = trunc i64 %18 to i32
  %19 = load ptr, ptr %len.addr, align 8
  store i32 %conv, ptr %19, align 4
  br label %if.end16

if.end16:                                         ; preds = %if.else, %if.then14, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_export_keying_material(ptr noundef %s, ptr noundef %out, i64 noundef %olen, ptr noundef %label, i64 noundef %llen, ptr noundef %context, i64 noundef %contextlen, i32 noundef %use_context) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %olen.addr = alloca i64, align 8
  %label.addr = alloca ptr, align 8
  %llen.addr = alloca i64, align 8
  %context.addr = alloca ptr, align 8
  %contextlen.addr = alloca i64, align 8
  %use_context.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store i64 %olen, ptr %olen.addr, align 8
  store ptr %label, ptr %label.addr, align 8
  store i64 %llen, ptr %llen.addr, align 8
  store ptr %context, ptr %context.addr, align 8
  store i64 %contextlen, ptr %contextlen.addr, align 8
  store i32 %use_context, ptr %use_context.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 50
  %10 = load ptr, ptr %session, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %version = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 1
  %12 = load i32, ptr %version, align 8
  %cmp14 = icmp slt i32 %12, 769
  br i1 %cmp14, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %lor.lhs.false
  %13 = load ptr, ptr %sc, align 8
  %version15 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 1
  %14 = load i32, ptr %version15, align 8
  %cmp16 = icmp ne i32 %14, 256
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true, %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %land.lhs.true, %lor.lhs.false
  %15 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %15, i32 0, i32 3
  %16 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %16, i32 0, i32 28
  %17 = load ptr, ptr %ssl3_enc, align 8
  %export_keying_material = getelementptr inbounds %struct.ssl3_enc_method, ptr %17, i32 0, i32 9
  %18 = load ptr, ptr %export_keying_material, align 8
  %19 = load ptr, ptr %sc, align 8
  %20 = load ptr, ptr %out.addr, align 8
  %21 = load i64, ptr %olen.addr, align 8
  %22 = load ptr, ptr %label.addr, align 8
  %23 = load i64, ptr %llen.addr, align 8
  %24 = load ptr, ptr %context.addr, align 8
  %25 = load i64, ptr %contextlen.addr, align 8
  %26 = load i32, ptr %use_context.addr, align 4
  %call = call i32 %18(ptr noundef %19, ptr noundef %20, i64 noundef %21, ptr noundef %22, i64 noundef %23, ptr noundef %24, i64 noundef %25, i32 noundef %26)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then17, %if.then
  %27 = load i32, ptr %retval, align 4
  ret i32 %27
}

; Function Attrs: nounwind uwtable
define i32 @SSL_export_keying_material_early(ptr noundef %s, ptr noundef %out, i64 noundef %olen, ptr noundef %label, i64 noundef %llen, ptr noundef %context, i64 noundef %contextlen) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %olen.addr = alloca i64, align 8
  %label.addr = alloca ptr, align 8
  %llen.addr = alloca i64, align 8
  %context.addr = alloca ptr, align 8
  %contextlen.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store i64 %olen, ptr %olen.addr, align 8
  store ptr %label, ptr %label.addr, align 8
  store i64 %llen, ptr %llen.addr, align 8
  store ptr %context, ptr %context.addr, align 8
  store i64 %contextlen, ptr %contextlen.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %version = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 1
  %10 = load i32, ptr %version, align 8
  %cmp13 = icmp ne i32 %10, 772
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %12 = load ptr, ptr %out.addr, align 8
  %13 = load i64, ptr %olen.addr, align 8
  %14 = load ptr, ptr %label.addr, align 8
  %15 = load i64, ptr %llen.addr, align 8
  %16 = load ptr, ptr %context.addr, align 8
  %17 = load i64, ptr %contextlen.addr, align 8
  %call = call i32 @tls13_export_keying_material_early(ptr noundef %11, ptr noundef %12, i64 noundef %13, ptr noundef %14, i64 noundef %15, ptr noundef %16, i64 noundef %17)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then14, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

declare i32 @tls13_export_keying_material_early(ptr noundef, ptr noundef, i64 noundef, ptr noundef, i64 noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_new_ex(ptr noundef %libctx, ptr noundef %propq, ptr noundef %meth) #0 {
entry:
  %retval = alloca ptr, align 8
  %libctx.addr = alloca ptr, align 8
  %propq.addr = alloca ptr, align 8
  %meth.addr = alloca ptr, align 8
  %ret = alloca ptr, align 8
  %tmp = alloca %struct.OSSL_TIME, align 8
  store ptr %libctx, ptr %libctx.addr, align 8
  store ptr %propq, ptr %propq.addr, align 8
  store ptr %meth, ptr %meth.addr, align 8
  store ptr null, ptr %ret, align 8
  %0 = load ptr, ptr %meth.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3860, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 196, ptr noundef null)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call = call i32 @OPENSSL_init_ssl(i64 noundef 2097152, ptr noundef null)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %if.end
  %call3 = call i32 @SSL_get_ex_data_X509_STORE_CTX_idx()
  %cmp4 = icmp slt i32 %call3, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end2
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3869, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 269, ptr noundef null)
  br label %err

if.end6:                                          ; preds = %if.end2
  %call7 = call noalias ptr @CRYPTO_zalloc(i64 noundef 1696, ptr noundef @.str, i32 noundef 3873)
  store ptr %call7, ptr %ret, align 8
  %1 = load ptr, ptr %ret, align 8
  %cmp8 = icmp eq ptr %1, null
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  store ptr null, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end6
  %2 = load ptr, ptr %ret, align 8
  %references = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 16
  %call11 = call i32 @CRYPTO_NEW_REF(ptr noundef %references, i32 noundef 1)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end10
  %3 = load ptr, ptr %ret, align 8
  call void @CRYPTO_free(ptr noundef %3, ptr noundef @.str, i32 noundef 3879)
  store ptr null, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end10
  %call15 = call ptr @CRYPTO_THREAD_lock_new()
  %4 = load ptr, ptr %ret, align 8
  %lock = getelementptr inbounds %struct.ssl_ctx_st, ptr %4, i32 0, i32 70
  store ptr %call15, ptr %lock, align 8
  %5 = load ptr, ptr %ret, align 8
  %lock16 = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 70
  %6 = load ptr, ptr %lock16, align 8
  %cmp17 = icmp eq ptr %6, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3885, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  br label %err

if.end19:                                         ; preds = %if.end14
  %7 = load ptr, ptr %libctx.addr, align 8
  %8 = load ptr, ptr %ret, align 8
  %libctx20 = getelementptr inbounds %struct.ssl_ctx_st, ptr %8, i32 0, i32 0
  store ptr %7, ptr %libctx20, align 8
  %9 = load ptr, ptr %propq.addr, align 8
  %cmp21 = icmp ne ptr %9, null
  br i1 %cmp21, label %if.then22, label %if.end29

if.then22:                                        ; preds = %if.end19
  %10 = load ptr, ptr %propq.addr, align 8
  %call23 = call noalias ptr @CRYPTO_strdup(ptr noundef %10, ptr noundef @.str, i32 noundef 3899)
  %11 = load ptr, ptr %ret, align 8
  %propq24 = getelementptr inbounds %struct.ssl_ctx_st, ptr %11, i32 0, i32 86
  store ptr %call23, ptr %propq24, align 8
  %12 = load ptr, ptr %ret, align 8
  %propq25 = getelementptr inbounds %struct.ssl_ctx_st, ptr %12, i32 0, i32 86
  %13 = load ptr, ptr %propq25, align 8
  %cmp26 = icmp eq ptr %13, null
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.then22
  br label %err

if.end28:                                         ; preds = %if.then22
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.end19
  %14 = load ptr, ptr %meth.addr, align 8
  %15 = load ptr, ptr %ret, align 8
  %method = getelementptr inbounds %struct.ssl_ctx_st, ptr %15, i32 0, i32 1
  store ptr %14, ptr %method, align 8
  %16 = load ptr, ptr %ret, align 8
  %min_proto_version = getelementptr inbounds %struct.ssl_ctx_st, ptr %16, i32 0, i32 36
  store i32 0, ptr %min_proto_version, align 4
  %17 = load ptr, ptr %ret, align 8
  %max_proto_version = getelementptr inbounds %struct.ssl_ctx_st, ptr %17, i32 0, i32 37
  store i32 0, ptr %max_proto_version, align 8
  %18 = load ptr, ptr %ret, align 8
  %mode = getelementptr inbounds %struct.ssl_ctx_st, ptr %18, i32 0, i32 35
  store i32 4, ptr %mode, align 8
  %19 = load ptr, ptr %ret, align 8
  %session_cache_mode = getelementptr inbounds %struct.ssl_ctx_st, ptr %19, i32 0, i32 10
  store i32 2, ptr %session_cache_mode, align 8
  %20 = load ptr, ptr %ret, align 8
  %session_cache_size = getelementptr inbounds %struct.ssl_ctx_st, ptr %20, i32 0, i32 7
  store i64 20480, ptr %session_cache_size, align 8
  %21 = load ptr, ptr %ret, align 8
  %session_timeout = getelementptr inbounds %struct.ssl_ctx_st, ptr %21, i32 0, i32 11
  %22 = load ptr, ptr %meth.addr, align 8
  %get_timeout = getelementptr inbounds %struct.ssl_method_st, ptr %22, i32 0, i32 27
  %23 = load ptr, ptr %get_timeout, align 8
  %call30 = call i64 %23()
  %coerce.dive = getelementptr inbounds %struct.OSSL_TIME, ptr %tmp, i32 0, i32 0
  store i64 %call30, ptr %coerce.dive, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %session_timeout, ptr align 8 %tmp, i64 8, i1 false)
  %24 = load ptr, ptr %ret, align 8
  %max_cert_list = getelementptr inbounds %struct.ssl_ctx_st, ptr %24, i32 0, i32 38
  store i64 102400, ptr %max_cert_list, align 8
  %25 = load ptr, ptr %ret, align 8
  %verify_mode = getelementptr inbounds %struct.ssl_ctx_st, ptr %25, i32 0, i32 44
  store i32 0, ptr %verify_mode, align 8
  %call31 = call ptr @lh_SSL_SESSION_new(ptr noundef @ssl_session_hash, ptr noundef @ssl_session_cmp)
  %26 = load ptr, ptr %ret, align 8
  %sessions = getelementptr inbounds %struct.ssl_ctx_st, ptr %26, i32 0, i32 6
  store ptr %call31, ptr %sessions, align 8
  %27 = load ptr, ptr %ret, align 8
  %sessions32 = getelementptr inbounds %struct.ssl_ctx_st, ptr %27, i32 0, i32 6
  %28 = load ptr, ptr %sessions32, align 8
  %cmp33 = icmp eq ptr %28, null
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end29
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3917, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  br label %err

if.end35:                                         ; preds = %if.end29
  %call36 = call ptr @X509_STORE_new()
  %29 = load ptr, ptr %ret, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %29, i32 0, i32 5
  store ptr %call36, ptr %cert_store, align 8
  %30 = load ptr, ptr %ret, align 8
  %cert_store37 = getelementptr inbounds %struct.ssl_ctx_st, ptr %30, i32 0, i32 5
  %31 = load ptr, ptr %cert_store37, align 8
  %cmp38 = icmp eq ptr %31, null
  br i1 %cmp38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end35
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3922, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524299, ptr noundef null)
  br label %err

if.end40:                                         ; preds = %if.end35
  %32 = load ptr, ptr %libctx.addr, align 8
  %33 = load ptr, ptr %propq.addr, align 8
  %call41 = call ptr @CTLOG_STORE_new_ex(ptr noundef %32, ptr noundef %33)
  %34 = load ptr, ptr %ret, align 8
  %ctlog_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %34, i32 0, i32 51
  store ptr %call41, ptr %ctlog_store, align 8
  %35 = load ptr, ptr %ret, align 8
  %ctlog_store42 = getelementptr inbounds %struct.ssl_ctx_st, ptr %35, i32 0, i32 51
  %36 = load ptr, ptr %ctlog_store42, align 8
  %cmp43 = icmp eq ptr %36, null
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end40
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3928, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524338, ptr noundef null)
  br label %err

if.end45:                                         ; preds = %if.end40
  %37 = load ptr, ptr %ret, align 8
  %call46 = call i32 @ssl_load_ciphers(ptr noundef %37)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.end49, label %if.then48

if.then48:                                        ; preds = %if.end45
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3935, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524308, ptr noundef null)
  br label %err

if.end49:                                         ; preds = %if.end45
  %38 = load ptr, ptr %ret, align 8
  %call50 = call i32 @ssl_load_groups(ptr noundef %38)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %if.end53, label %if.then52

if.then52:                                        ; preds = %if.end49
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3940, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524308, ptr noundef null)
  br label %err

if.end53:                                         ; preds = %if.end49
  %39 = load ptr, ptr %ret, align 8
  %call54 = call i32 @ssl_load_sigalgs(ptr noundef %39)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %if.end53
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3946, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524308, ptr noundef null)
  br label %err

if.end57:                                         ; preds = %if.end53
  %40 = load ptr, ptr %ret, align 8
  %call58 = call i32 @ssl_setup_sigalgs(ptr noundef %40)
  %tobool59 = icmp ne i32 %call58, 0
  br i1 %tobool59, label %if.end61, label %if.then60

if.then60:                                        ; preds = %if.end57
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3952, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524308, ptr noundef null)
  br label %err

if.end61:                                         ; preds = %if.end57
  %41 = load ptr, ptr %ret, align 8
  %call62 = call ptr @OSSL_default_ciphersuites()
  %call63 = call i32 @SSL_CTX_set_ciphersuites(ptr noundef %41, ptr noundef %call62)
  %tobool64 = icmp ne i32 %call63, 0
  br i1 %tobool64, label %if.end66, label %if.then65

if.then65:                                        ; preds = %if.end61
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3957, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524308, ptr noundef null)
  br label %err

if.end66:                                         ; preds = %if.end61
  %42 = load ptr, ptr %ret, align 8
  %sigalg_list_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %42, i32 0, i32 98
  %43 = load i64, ptr %sigalg_list_len, align 8
  %add = add i64 9, %43
  %call67 = call ptr @ssl_cert_new(i64 noundef %add)
  %44 = load ptr, ptr %ret, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %44, i32 0, i32 39
  store ptr %call67, ptr %cert, align 8
  %cmp68 = icmp eq ptr %call67, null
  br i1 %cmp68, label %if.then69, label %if.end70

if.then69:                                        ; preds = %if.end66
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3962, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524308, ptr noundef null)
  br label %err

if.end70:                                         ; preds = %if.end66
  %45 = load ptr, ptr %ret, align 8
  %46 = load ptr, ptr %ret, align 8
  %tls13_ciphersuites = getelementptr inbounds %struct.ssl_ctx_st, ptr %46, i32 0, i32 4
  %47 = load ptr, ptr %tls13_ciphersuites, align 8
  %48 = load ptr, ptr %ret, align 8
  %cipher_list = getelementptr inbounds %struct.ssl_ctx_st, ptr %48, i32 0, i32 2
  %49 = load ptr, ptr %ret, align 8
  %cipher_list_by_id = getelementptr inbounds %struct.ssl_ctx_st, ptr %49, i32 0, i32 3
  %call71 = call ptr @OSSL_default_cipher_list()
  %50 = load ptr, ptr %ret, align 8
  %cert72 = getelementptr inbounds %struct.ssl_ctx_st, ptr %50, i32 0, i32 39
  %51 = load ptr, ptr %cert72, align 8
  %call73 = call ptr @ssl_create_cipher_list(ptr noundef %45, ptr noundef %47, ptr noundef %cipher_list, ptr noundef %cipher_list_by_id, ptr noundef %call71, ptr noundef %51)
  %tobool74 = icmp ne ptr %call73, null
  br i1 %tobool74, label %lor.lhs.false, label %if.then79

lor.lhs.false:                                    ; preds = %if.end70
  %52 = load ptr, ptr %ret, align 8
  %cipher_list75 = getelementptr inbounds %struct.ssl_ctx_st, ptr %52, i32 0, i32 2
  %53 = load ptr, ptr %cipher_list75, align 8
  %call76 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %53)
  %call77 = call i32 @OPENSSL_sk_num(ptr noundef %call76)
  %cmp78 = icmp sle i32 %call77, 0
  br i1 %cmp78, label %if.then79, label %if.end80

if.then79:                                        ; preds = %lor.lhs.false, %if.end70
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3971, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 161, ptr noundef null)
  br label %err

if.end80:                                         ; preds = %lor.lhs.false
  %call81 = call ptr @X509_VERIFY_PARAM_new()
  %54 = load ptr, ptr %ret, align 8
  %param = getelementptr inbounds %struct.ssl_ctx_st, ptr %54, i32 0, i32 49
  store ptr %call81, ptr %param, align 8
  %55 = load ptr, ptr %ret, align 8
  %param82 = getelementptr inbounds %struct.ssl_ctx_st, ptr %55, i32 0, i32 49
  %56 = load ptr, ptr %param82, align 8
  %cmp83 = icmp eq ptr %56, null
  br i1 %cmp83, label %if.then84, label %if.end85

if.then84:                                        ; preds = %if.end80
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3977, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524299, ptr noundef null)
  br label %err

if.end85:                                         ; preds = %if.end80
  %57 = load ptr, ptr %libctx.addr, align 8
  %58 = load ptr, ptr %propq.addr, align 8
  %call86 = call ptr @ssl_evp_md_fetch(ptr noundef %57, i32 noundef 4, ptr noundef %58)
  %59 = load ptr, ptr %ret, align 8
  %md5 = getelementptr inbounds %struct.ssl_ctx_st, ptr %59, i32 0, i32 27
  store ptr %call86, ptr %md5, align 8
  %60 = load ptr, ptr %libctx.addr, align 8
  %61 = load ptr, ptr %propq.addr, align 8
  %call87 = call ptr @ssl_evp_md_fetch(ptr noundef %60, i32 noundef 64, ptr noundef %61)
  %62 = load ptr, ptr %ret, align 8
  %sha1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %62, i32 0, i32 28
  store ptr %call87, ptr %sha1, align 8
  %call88 = call ptr @OPENSSL_sk_new_null()
  %63 = load ptr, ptr %ret, align 8
  %ca_names = getelementptr inbounds %struct.ssl_ctx_st, ptr %63, i32 0, i32 32
  store ptr %call88, ptr %ca_names, align 8
  %cmp89 = icmp eq ptr %call88, null
  br i1 %cmp89, label %if.then90, label %if.end91

if.then90:                                        ; preds = %if.end85
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3989, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  br label %err

if.end91:                                         ; preds = %if.end85
  %call92 = call ptr @OPENSSL_sk_new_null()
  %64 = load ptr, ptr %ret, align 8
  %client_ca_names = getelementptr inbounds %struct.ssl_ctx_st, ptr %64, i32 0, i32 33
  store ptr %call92, ptr %client_ca_names, align 8
  %cmp93 = icmp eq ptr %call92, null
  br i1 %cmp93, label %if.then94, label %if.end95

if.then94:                                        ; preds = %if.end91
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3994, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  br label %err

if.end95:                                         ; preds = %if.end91
  %65 = load ptr, ptr %ret, align 8
  %66 = load ptr, ptr %ret, align 8
  %ex_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %66, i32 0, i32 26
  %call96 = call i32 @CRYPTO_new_ex_data(i32 noundef 1, ptr noundef %65, ptr noundef %ex_data)
  %tobool97 = icmp ne i32 %call96, 0
  br i1 %tobool97, label %if.end99, label %if.then98

if.then98:                                        ; preds = %if.end95
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 3999, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  br label %err

if.end99:                                         ; preds = %if.end95
  %call100 = call noalias ptr @CRYPTO_secure_zalloc(i64 noundef 64, ptr noundef @.str, i32 noundef 4003)
  %67 = load ptr, ptr %ret, align 8
  %ext = getelementptr inbounds %struct.ssl_ctx_st, ptr %67, i32 0, i32 61
  %secure = getelementptr inbounds %struct.anon.4, ptr %ext, i32 0, i32 3
  store ptr %call100, ptr %secure, align 8
  %cmp101 = icmp eq ptr %call100, null
  br i1 %cmp101, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.end99
  br label %err

if.end103:                                        ; preds = %if.end99
  %68 = load ptr, ptr %meth.addr, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %68, i32 0, i32 28
  %69 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %69, i32 0, i32 10
  %70 = load i32, ptr %enc_flags, align 8
  %and = and i32 %70, 8
  %tobool104 = icmp ne i32 %and, 0
  br i1 %tobool104, label %if.end107, label %if.then105

if.then105:                                       ; preds = %if.end103
  %call106 = call ptr @SSL_COMP_get_compression_methods()
  %71 = load ptr, ptr %ret, align 8
  %comp_methods = getelementptr inbounds %struct.ssl_ctx_st, ptr %71, i32 0, i32 30
  store ptr %call106, ptr %comp_methods, align 8
  br label %if.end107

if.end107:                                        ; preds = %if.then105, %if.end103
  %72 = load ptr, ptr %ret, align 8
  %max_send_fragment = getelementptr inbounds %struct.ssl_ctx_st, ptr %72, i32 0, i32 55
  store i64 16384, ptr %max_send_fragment, align 8
  %73 = load ptr, ptr %ret, align 8
  %split_send_fragment = getelementptr inbounds %struct.ssl_ctx_st, ptr %73, i32 0, i32 54
  store i64 16384, ptr %split_send_fragment, align 8
  %74 = load ptr, ptr %libctx.addr, align 8
  %75 = load ptr, ptr %ret, align 8
  %ext108 = getelementptr inbounds %struct.ssl_ctx_st, ptr %75, i32 0, i32 61
  %tick_key_name = getelementptr inbounds %struct.anon.4, ptr %ext108, i32 0, i32 2
  %arraydecay = getelementptr inbounds [16 x i8], ptr %tick_key_name, i64 0, i64 0
  %call109 = call i32 @RAND_bytes_ex(ptr noundef %74, ptr noundef %arraydecay, i64 noundef 16, i32 noundef 0)
  %cmp110 = icmp sle i32 %call109, 0
  br i1 %cmp110, label %if.then123, label %lor.lhs.false111

lor.lhs.false111:                                 ; preds = %if.end107
  %76 = load ptr, ptr %libctx.addr, align 8
  %77 = load ptr, ptr %ret, align 8
  %ext112 = getelementptr inbounds %struct.ssl_ctx_st, ptr %77, i32 0, i32 61
  %secure113 = getelementptr inbounds %struct.anon.4, ptr %ext112, i32 0, i32 3
  %78 = load ptr, ptr %secure113, align 8
  %tick_hmac_key = getelementptr inbounds %struct.ssl_ctx_ext_secure_st, ptr %78, i32 0, i32 0
  %arraydecay114 = getelementptr inbounds [32 x i8], ptr %tick_hmac_key, i64 0, i64 0
  %call115 = call i32 @RAND_priv_bytes_ex(ptr noundef %76, ptr noundef %arraydecay114, i64 noundef 32, i32 noundef 0)
  %cmp116 = icmp sle i32 %call115, 0
  br i1 %cmp116, label %if.then123, label %lor.lhs.false117

lor.lhs.false117:                                 ; preds = %lor.lhs.false111
  %79 = load ptr, ptr %libctx.addr, align 8
  %80 = load ptr, ptr %ret, align 8
  %ext118 = getelementptr inbounds %struct.ssl_ctx_st, ptr %80, i32 0, i32 61
  %secure119 = getelementptr inbounds %struct.anon.4, ptr %ext118, i32 0, i32 3
  %81 = load ptr, ptr %secure119, align 8
  %tick_aes_key = getelementptr inbounds %struct.ssl_ctx_ext_secure_st, ptr %81, i32 0, i32 1
  %arraydecay120 = getelementptr inbounds [32 x i8], ptr %tick_aes_key, i64 0, i64 0
  %call121 = call i32 @RAND_priv_bytes_ex(ptr noundef %79, ptr noundef %arraydecay120, i64 noundef 32, i32 noundef 0)
  %cmp122 = icmp sle i32 %call121, 0
  br i1 %cmp122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %lor.lhs.false117, %lor.lhs.false111, %if.end107
  %82 = load ptr, ptr %ret, align 8
  %options = getelementptr inbounds %struct.ssl_ctx_st, ptr %82, i32 0, i32 34
  %83 = load i64, ptr %options, align 8
  %or = or i64 %83, 16384
  store i64 %or, ptr %options, align 8
  br label %if.end124

if.end124:                                        ; preds = %if.then123, %lor.lhs.false117
  %84 = load ptr, ptr %libctx.addr, align 8
  %85 = load ptr, ptr %ret, align 8
  %ext125 = getelementptr inbounds %struct.ssl_ctx_st, ptr %85, i32 0, i32 61
  %cookie_hmac_key = getelementptr inbounds %struct.anon.4, ptr %ext125, i32 0, i32 24
  %arraydecay126 = getelementptr inbounds [32 x i8], ptr %cookie_hmac_key, i64 0, i64 0
  %call127 = call i32 @RAND_priv_bytes_ex(ptr noundef %84, ptr noundef %arraydecay126, i64 noundef 32, i32 noundef 0)
  %cmp128 = icmp sle i32 %call127, 0
  br i1 %cmp128, label %if.then129, label %if.end130

if.then129:                                       ; preds = %if.end124
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 4024, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524324, ptr noundef null)
  br label %err

if.end130:                                        ; preds = %if.end124
  %86 = load ptr, ptr %ret, align 8
  %call131 = call i32 @ssl_ctx_srp_ctx_init_intern(ptr noundef %86)
  %tobool132 = icmp ne i32 %call131, 0
  br i1 %tobool132, label %if.end134, label %if.then133

if.then133:                                       ; preds = %if.end130
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 4030, ptr noundef @__func__.SSL_CTX_new_ex)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524308, ptr noundef null)
  br label %err

if.end134:                                        ; preds = %if.end130
  %87 = load ptr, ptr %ret, align 8
  %options135 = getelementptr inbounds %struct.ssl_ctx_st, ptr %87, i32 0, i32 34
  %88 = load i64, ptr %options135, align 8
  %or136 = or i64 %88, 1179648
  store i64 %or136, ptr %options135, align 8
  %89 = load ptr, ptr %ret, align 8
  %ext137 = getelementptr inbounds %struct.ssl_ctx_st, ptr %89, i32 0, i32 61
  %status_type = getelementptr inbounds %struct.anon.4, ptr %ext137, i32 0, i32 8
  store i32 -1, ptr %status_type, align 8
  %90 = load ptr, ptr %ret, align 8
  %max_early_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %90, i32 0, i32 72
  store i32 0, ptr %max_early_data, align 8
  %91 = load ptr, ptr %ret, align 8
  %recv_max_early_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %91, i32 0, i32 73
  store i32 16384, ptr %recv_max_early_data, align 4
  %92 = load ptr, ptr %ret, align 8
  %num_tickets = getelementptr inbounds %struct.ssl_ctx_st, ptr %92, i32 0, i32 80
  store i64 2, ptr %num_tickets, align 8
  %93 = load ptr, ptr %ret, align 8
  call void @ssl_ctx_system_config(ptr noundef %93)
  %94 = load ptr, ptr %ret, align 8
  store ptr %94, ptr %retval, align 8
  br label %return

err:                                              ; preds = %if.then133, %if.then129, %if.then102, %if.then98, %if.then94, %if.then90, %if.then84, %if.then79, %if.then69, %if.then65, %if.then60, %if.then56, %if.then52, %if.then48, %if.then44, %if.then39, %if.then34, %if.then27, %if.then18, %if.then5
  %95 = load ptr, ptr %ret, align 8
  call void @SSL_CTX_free(ptr noundef %95)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %err, %if.end134, %if.then13, %if.then9, %if.then1, %if.then
  %96 = load ptr, ptr %retval, align 8
  ret ptr %96
}

declare i32 @OPENSSL_init_ssl(i64 noundef, ptr noundef) #1

declare i32 @SSL_get_ex_data_X509_STORE_CTX_idx() #1

declare noalias ptr @CRYPTO_strdup(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @lh_SSL_SESSION_new(ptr noundef %hfn, ptr noundef %cfn) #0 {
entry:
  %hfn.addr = alloca ptr, align 8
  %cfn.addr = alloca ptr, align 8
  store ptr %hfn, ptr %hfn.addr, align 8
  store ptr %cfn, ptr %cfn.addr, align 8
  %0 = load ptr, ptr %hfn.addr, align 8
  %1 = load ptr, ptr %cfn.addr, align 8
  %call = call ptr @OPENSSL_LH_new(ptr noundef %0, ptr noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal i64 @ssl_session_hash(ptr noundef %a) #0 {
entry:
  %a.addr = alloca ptr, align 8
  %session_id = alloca ptr, align 8
  %l = alloca i64, align 8
  %tmp_storage = alloca [4 x i8], align 1
  store ptr %a, ptr %a.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %session_id1 = getelementptr inbounds %struct.ssl_session_st, ptr %0, i32 0, i32 5
  %arraydecay = getelementptr inbounds [32 x i8], ptr %session_id1, i64 0, i64 0
  store ptr %arraydecay, ptr %session_id, align 8
  %1 = load ptr, ptr %a.addr, align 8
  %session_id_length = getelementptr inbounds %struct.ssl_session_st, ptr %1, i32 0, i32 4
  %2 = load i64, ptr %session_id_length, align 8
  %cmp = icmp ult i64 %2, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %arraydecay2 = getelementptr inbounds [4 x i8], ptr %tmp_storage, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 1 %arraydecay2, i8 0, i64 4, i1 false)
  %arraydecay3 = getelementptr inbounds [4 x i8], ptr %tmp_storage, i64 0, i64 0
  %3 = load ptr, ptr %a.addr, align 8
  %session_id4 = getelementptr inbounds %struct.ssl_session_st, ptr %3, i32 0, i32 5
  %arraydecay5 = getelementptr inbounds [32 x i8], ptr %session_id4, i64 0, i64 0
  %4 = load ptr, ptr %a.addr, align 8
  %session_id_length6 = getelementptr inbounds %struct.ssl_session_st, ptr %4, i32 0, i32 4
  %5 = load i64, ptr %session_id_length6, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arraydecay3, ptr align 8 %arraydecay5, i64 %5, i1 false)
  %arraydecay7 = getelementptr inbounds [4 x i8], ptr %tmp_storage, i64 0, i64 0
  store ptr %arraydecay7, ptr %session_id, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load ptr, ptr %session_id, align 8
  %arrayidx = getelementptr inbounds i8, ptr %6, i64 0
  %7 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %7 to i64
  %8 = load ptr, ptr %session_id, align 8
  %arrayidx8 = getelementptr inbounds i8, ptr %8, i64 1
  %9 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %9 to i64
  %shl = shl i64 %conv9, 8
  %or = or i64 %conv, %shl
  %10 = load ptr, ptr %session_id, align 8
  %arrayidx10 = getelementptr inbounds i8, ptr %10, i64 2
  %11 = load i8, ptr %arrayidx10, align 1
  %conv11 = zext i8 %11 to i64
  %shl12 = shl i64 %conv11, 16
  %or13 = or i64 %or, %shl12
  %12 = load ptr, ptr %session_id, align 8
  %arrayidx14 = getelementptr inbounds i8, ptr %12, i64 3
  %13 = load i8, ptr %arrayidx14, align 1
  %conv15 = zext i8 %13 to i64
  %shl16 = shl i64 %conv15, 24
  %or17 = or i64 %or13, %shl16
  store i64 %or17, ptr %l, align 8
  %14 = load i64, ptr %l, align 8
  ret i64 %14
}

; Function Attrs: nounwind uwtable
define internal i32 @ssl_session_cmp(ptr noundef %a, ptr noundef %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %ssl_version = getelementptr inbounds %struct.ssl_session_st, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %ssl_version, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %ssl_version1 = getelementptr inbounds %struct.ssl_session_st, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %ssl_version1, align 8
  %cmp = icmp ne i32 %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %a.addr, align 8
  %session_id_length = getelementptr inbounds %struct.ssl_session_st, ptr %4, i32 0, i32 4
  %5 = load i64, ptr %session_id_length, align 8
  %6 = load ptr, ptr %b.addr, align 8
  %session_id_length2 = getelementptr inbounds %struct.ssl_session_st, ptr %6, i32 0, i32 4
  %7 = load i64, ptr %session_id_length2, align 8
  %cmp3 = icmp ne i64 %5, %7
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %8 = load ptr, ptr %a.addr, align 8
  %session_id = getelementptr inbounds %struct.ssl_session_st, ptr %8, i32 0, i32 5
  %arraydecay = getelementptr inbounds [32 x i8], ptr %session_id, i64 0, i64 0
  %9 = load ptr, ptr %b.addr, align 8
  %session_id6 = getelementptr inbounds %struct.ssl_session_st, ptr %9, i32 0, i32 5
  %arraydecay7 = getelementptr inbounds [32 x i8], ptr %session_id6, i64 0, i64 0
  %10 = load ptr, ptr %a.addr, align 8
  %session_id_length8 = getelementptr inbounds %struct.ssl_session_st, ptr %10, i32 0, i32 4
  %11 = load i64, ptr %session_id_length8, align 8
  %call = call i32 @memcmp(ptr noundef %arraydecay, ptr noundef %arraydecay7, i64 noundef %11) #6
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

declare ptr @X509_STORE_new() #1

declare ptr @CTLOG_STORE_new_ex(ptr noundef, ptr noundef) #1

declare i32 @ssl_load_ciphers(ptr noundef) #1

declare i32 @ssl_load_groups(ptr noundef) #1

declare i32 @ssl_load_sigalgs(ptr noundef) #1

declare i32 @ssl_setup_sigalgs(ptr noundef) #1

declare ptr @ssl_cert_new(i64 noundef) #1

; Function Attrs: nounwind uwtable
define ptr @ssl_evp_md_fetch(ptr noundef %libctx, i32 noundef %nid, ptr noundef %properties) #0 {
entry:
  %retval = alloca ptr, align 8
  %libctx.addr = alloca ptr, align 8
  %nid.addr = alloca i32, align 4
  %properties.addr = alloca ptr, align 8
  %md = alloca ptr, align 8
  store ptr %libctx, ptr %libctx.addr, align 8
  store i32 %nid, ptr %nid.addr, align 4
  store ptr %properties, ptr %properties.addr, align 8
  %0 = load i32, ptr %nid.addr, align 4
  %call = call ptr @tls_get_digest_from_engine(i32 noundef %0)
  store ptr %call, ptr %md, align 8
  %1 = load ptr, ptr %md, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %md, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @ERR_set_mark()
  %3 = load ptr, ptr %libctx.addr, align 8
  %4 = load i32, ptr %nid.addr, align 4
  %call2 = call ptr @OBJ_nid2sn(i32 noundef %4)
  %5 = load ptr, ptr %properties.addr, align 8
  %call3 = call ptr @EVP_MD_fetch(ptr noundef %3, ptr noundef %call2, ptr noundef %5)
  store ptr %call3, ptr %md, align 8
  %call4 = call i32 @ERR_pop_to_mark()
  %6 = load ptr, ptr %md, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

declare noalias ptr @CRYPTO_secure_zalloc(i64 noundef, ptr noundef, i32 noundef) #1

declare ptr @SSL_COMP_get_compression_methods() #1

declare i32 @RAND_bytes_ex(ptr noundef, ptr noundef, i64 noundef, i32 noundef) #1

declare i32 @RAND_priv_bytes_ex(ptr noundef, ptr noundef, i64 noundef, i32 noundef) #1

declare i32 @ssl_ctx_srp_ctx_init_intern(ptr noundef) #1

declare void @ssl_ctx_system_config(ptr noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_new(ptr noundef %meth) #0 {
entry:
  %meth.addr = alloca ptr, align 8
  store ptr %meth, ptr %meth.addr, align 8
  %0 = load ptr, ptr %meth.addr, align 8
  %call = call ptr @SSL_CTX_new_ex(ptr noundef null, ptr noundef null, ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal void @dane_ctx_final(ptr noundef %dctx) #0 {
entry:
  %dctx.addr = alloca ptr, align 8
  store ptr %dctx, ptr %dctx.addr, align 8
  %0 = load ptr, ptr %dctx.addr, align 8
  %mdevp = getelementptr inbounds %struct.dane_ctx_st, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %mdevp, align 8
  call void @CRYPTO_free(ptr noundef %1, ptr noundef @.str, i32 noundef 146)
  %2 = load ptr, ptr %dctx.addr, align 8
  %mdevp1 = getelementptr inbounds %struct.dane_ctx_st, ptr %2, i32 0, i32 0
  store ptr null, ptr %mdevp1, align 8
  %3 = load ptr, ptr %dctx.addr, align 8
  %mdord = getelementptr inbounds %struct.dane_ctx_st, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %mdord, align 8
  call void @CRYPTO_free(ptr noundef %4, ptr noundef @.str, i32 noundef 149)
  %5 = load ptr, ptr %dctx.addr, align 8
  %mdord2 = getelementptr inbounds %struct.dane_ctx_st, ptr %5, i32 0, i32 1
  store ptr null, ptr %mdord2, align 8
  %6 = load ptr, ptr %dctx.addr, align 8
  %mdmax = getelementptr inbounds %struct.dane_ctx_st, ptr %6, i32 0, i32 2
  store i8 0, ptr %mdmax, align 8
  ret void
}

declare void @SSL_CTX_flush_sessions(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @lh_SSL_SESSION_free(ptr noundef %lh) #0 {
entry:
  %lh.addr = alloca ptr, align 8
  store ptr %lh, ptr %lh.addr, align 8
  %0 = load ptr, ptr %lh.addr, align 8
  call void @OPENSSL_LH_free(ptr noundef %0)
  ret void
}

declare void @X509_STORE_free(ptr noundef) #1

declare void @CTLOG_STORE_free(ptr noundef) #1

declare i32 @ssl_ctx_srp_ctx_free_intern(ptr noundef) #1

declare void @tls_engine_finish(ptr noundef) #1

declare void @CRYPTO_secure_free(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define void @ssl_evp_md_free(ptr noundef %md) #0 {
entry:
  %md.addr = alloca ptr, align 8
  store ptr %md, ptr %md.addr, align 8
  %0 = load ptr, ptr %md.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end3

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %md.addr, align 8
  %call = call ptr @EVP_MD_get0_provider(ptr noundef %1)
  %cmp1 = icmp ne ptr %call, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %2 = load ptr, ptr %md.addr, align 8
  call void @EVP_MD_free(ptr noundef %2)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @ssl_evp_cipher_free(ptr noundef %cipher) #0 {
entry:
  %cipher.addr = alloca ptr, align 8
  store ptr %cipher, ptr %cipher.addr, align 8
  %0 = load ptr, ptr %cipher.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end3

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %cipher.addr, align 8
  %call = call ptr @EVP_CIPHER_get0_provider(ptr noundef %1)
  %cmp1 = icmp ne ptr %call, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %2 = load ptr, ptr %cipher.addr, align 8
  call void @EVP_CIPHER_free(ptr noundef %2)
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_default_passwd_cb(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %default_passwd_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 19
  store ptr %0, ptr %default_passwd_callback, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_default_passwd_cb_userdata(ptr noundef %ctx, ptr noundef %u) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %u.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %u, ptr %u.addr, align 8
  %0 = load ptr, ptr %u.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %default_passwd_callback_userdata = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 20
  store ptr %0, ptr %default_passwd_callback_userdata, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get_default_passwd_cb(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %default_passwd_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 19
  %1 = load ptr, ptr %default_passwd_callback, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get_default_passwd_cb_userdata(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %default_passwd_callback_userdata = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 20
  %1 = load ptr, ptr %default_passwd_callback_userdata, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define void @SSL_set_default_passwd_cb(ptr noundef %s, ptr noundef %cb) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %cb.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %default_passwd_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 101
  store ptr %9, ptr %default_passwd_callback, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_set_default_passwd_cb_userdata(ptr noundef %s, ptr noundef %u) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %u.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %u, ptr %u.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %u.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %default_passwd_callback_userdata = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 102
  store ptr %9, ptr %default_passwd_callback_userdata, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_default_passwd_cb(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %default_passwd_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 101
  %10 = load ptr, ptr %default_passwd_callback, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_default_passwd_cb_userdata(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %default_passwd_callback_userdata = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 102
  %10 = load ptr, ptr %default_passwd_callback_userdata, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_cert_verify_callback(ptr noundef %ctx, ptr noundef %cb, ptr noundef %arg) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %app_verify_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 17
  store ptr %0, ptr %app_verify_callback, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %app_verify_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 18
  store ptr %2, ptr %app_verify_arg, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_verify(ptr noundef %ctx, i32 noundef %mode, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load i32, ptr %mode.addr, align 4
  %1 = load ptr, ptr %ctx.addr, align 8
  %verify_mode = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 44
  store i32 %0, ptr %verify_mode, align 8
  %2 = load ptr, ptr %cb.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %default_verify_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 47
  store ptr %2, ptr %default_verify_callback, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_verify_depth(ptr noundef %ctx, i32 noundef %depth) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %depth.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %depth, ptr %depth.addr, align 4
  %0 = load ptr, ptr %ctx.addr, align 8
  %param = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 49
  %1 = load ptr, ptr %param, align 8
  %2 = load i32, ptr %depth.addr, align 4
  call void @X509_VERIFY_PARAM_set_depth(ptr noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_cert_cb(ptr noundef %c, ptr noundef %cb, ptr noundef %arg) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 39
  %1 = load ptr, ptr %cert, align 8
  %2 = load ptr, ptr %cb.addr, align 8
  %3 = load ptr, ptr %arg.addr, align 8
  call void @ssl_cert_set_cert_cb(ptr noundef %1, ptr noundef %2, ptr noundef %3)
  ret void
}

declare void @ssl_cert_set_cert_cb(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define void @SSL_set_cert_cb(ptr noundef %s, ptr noundef %cb, ptr noundef %arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 44
  %10 = load ptr, ptr %cert, align 8
  %11 = load ptr, ptr %cb.addr, align 8
  %12 = load ptr, ptr %arg.addr, align 8
  call void @ssl_cert_set_cert_cb(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @ssl_set_masks(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %pvalid = alloca ptr, align 8
  %rsa_enc = alloca i32, align 4
  %rsa_sign = alloca i32, align 4
  %dh_tmp = alloca i32, align 4
  %dsa_sign = alloca i32, align 4
  %mask_k = alloca i64, align 8
  %mask_a = alloca i64, align 8
  %have_ecc_cert = alloca i32, align 4
  %ecdsa_ok = alloca i32, align 4
  %ex_kusage = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 44
  %1 = load ptr, ptr %cert, align 8
  store ptr %1, ptr %c, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 20
  %tmp = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 14
  %valid_flags = getelementptr inbounds %struct.anon.0, ptr %tmp, i32 0, i32 33
  %3 = load ptr, ptr %valid_flags, align 8
  store ptr %3, ptr %pvalid, align 8
  %4 = load ptr, ptr %c, align 8
  %cmp = icmp eq ptr %4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %5 = load ptr, ptr %c, align 8
  %dh_tmp1 = getelementptr inbounds %struct.cert_st, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %dh_tmp1, align 8
  %cmp2 = icmp ne ptr %6, null
  br i1 %cmp2, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %7 = load ptr, ptr %c, align 8
  %dh_tmp_cb = getelementptr inbounds %struct.cert_st, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %dh_tmp_cb, align 8
  %cmp3 = icmp ne ptr %8, null
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %9 = load ptr, ptr %c, align 8
  %dh_tmp_auto = getelementptr inbounds %struct.cert_st, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %dh_tmp_auto, align 8
  %tobool = icmp ne i32 %10, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %if.end
  %11 = phi i1 [ true, %lor.lhs.false ], [ true, %if.end ], [ %tobool, %lor.rhs ]
  %lor.ext = zext i1 %11 to i32
  store i32 %lor.ext, ptr %dh_tmp, align 4
  %12 = load ptr, ptr %pvalid, align 8
  %arrayidx = getelementptr inbounds i32, ptr %12, i64 0
  %13 = load i32, ptr %arrayidx, align 4
  %and = and i32 %13, 1
  store i32 %and, ptr %rsa_enc, align 4
  %14 = load ptr, ptr %pvalid, align 8
  %arrayidx4 = getelementptr inbounds i32, ptr %14, i64 0
  %15 = load i32, ptr %arrayidx4, align 4
  %and5 = and i32 %15, 1
  store i32 %and5, ptr %rsa_sign, align 4
  %16 = load ptr, ptr %pvalid, align 8
  %arrayidx6 = getelementptr inbounds i32, ptr %16, i64 2
  %17 = load i32, ptr %arrayidx6, align 4
  %and7 = and i32 %17, 1
  store i32 %and7, ptr %dsa_sign, align 4
  %18 = load ptr, ptr %pvalid, align 8
  %arrayidx8 = getelementptr inbounds i32, ptr %18, i64 3
  %19 = load i32, ptr %arrayidx8, align 4
  %and9 = and i32 %19, 1
  store i32 %and9, ptr %have_ecc_cert, align 4
  store i64 0, ptr %mask_k, align 8
  store i64 0, ptr %mask_a, align 8
  %20 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ssl_has_cert(ptr noundef %20, i32 noundef 6)
  %tobool10 = icmp ne i32 %call, 0
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %lor.end
  %21 = load i64, ptr %mask_k, align 8
  %or = or i64 %21, 528
  store i64 %or, ptr %mask_k, align 8
  %22 = load i64, ptr %mask_a, align 8
  %or12 = or i64 %22, 128
  store i64 %or12, ptr %mask_a, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %lor.end
  %23 = load ptr, ptr %s.addr, align 8
  %call14 = call i32 @ssl_has_cert(ptr noundef %23, i32 noundef 5)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %if.end13
  %24 = load i64, ptr %mask_k, align 8
  %or17 = or i64 %24, 528
  store i64 %or17, ptr %mask_k, align 8
  %25 = load i64, ptr %mask_a, align 8
  %or18 = or i64 %25, 128
  store i64 %or18, ptr %mask_a, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then16, %if.end13
  %26 = load ptr, ptr %s.addr, align 8
  %call20 = call i32 @ssl_has_cert(ptr noundef %26, i32 noundef 4)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.then22, label %if.end25

if.then22:                                        ; preds = %if.end19
  %27 = load i64, ptr %mask_k, align 8
  %or23 = or i64 %27, 16
  store i64 %or23, ptr %mask_k, align 8
  %28 = load i64, ptr %mask_a, align 8
  %or24 = or i64 %28, 32
  store i64 %or24, ptr %mask_a, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then22, %if.end19
  %29 = load i32, ptr %rsa_enc, align 4
  %tobool26 = icmp ne i32 %29, 0
  br i1 %tobool26, label %if.then27, label %if.end29

if.then27:                                        ; preds = %if.end25
  %30 = load i64, ptr %mask_k, align 8
  %or28 = or i64 %30, 1
  store i64 %or28, ptr %mask_k, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %if.end25
  %31 = load i32, ptr %dh_tmp, align 4
  %tobool30 = icmp ne i32 %31, 0
  br i1 %tobool30, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.end29
  %32 = load i64, ptr %mask_k, align 8
  %or32 = or i64 %32, 2
  store i64 %or32, ptr %mask_k, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.end29
  %33 = load i32, ptr %rsa_enc, align 4
  %tobool34 = icmp ne i32 %33, 0
  br i1 %tobool34, label %if.then49, label %lor.lhs.false35

lor.lhs.false35:                                  ; preds = %if.end33
  %34 = load i32, ptr %rsa_sign, align 4
  %tobool36 = icmp ne i32 %34, 0
  br i1 %tobool36, label %if.then49, label %lor.lhs.false37

lor.lhs.false37:                                  ; preds = %lor.lhs.false35
  %35 = load ptr, ptr %s.addr, align 8
  %call38 = call i32 @ssl_has_cert(ptr noundef %35, i32 noundef 1)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %land.lhs.true, label %if.end51

land.lhs.true:                                    ; preds = %lor.lhs.false37
  %36 = load ptr, ptr %pvalid, align 8
  %arrayidx40 = getelementptr inbounds i32, ptr %36, i64 1
  %37 = load i32, ptr %arrayidx40, align 4
  %and41 = and i32 %37, 256
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %land.lhs.true43, label %if.end51

land.lhs.true43:                                  ; preds = %land.lhs.true
  %38 = load ptr, ptr %s.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %38, i32 0, i32 0
  %call44 = call i32 @SSL_version(ptr noundef %ssl)
  %shr = ashr i32 %call44, 8
  %cmp45 = icmp eq i32 %shr, 3
  br i1 %cmp45, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true43
  %39 = load ptr, ptr %s.addr, align 8
  %ssl46 = getelementptr inbounds %struct.ssl_connection_st, ptr %39, i32 0, i32 0
  %call47 = call i32 @SSL_version(ptr noundef %ssl46)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true43
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call47, %cond.true ], [ 0, %cond.false ]
  %cmp48 = icmp eq i32 %cond, 771
  br i1 %cmp48, label %if.then49, label %if.end51

if.then49:                                        ; preds = %cond.end, %lor.lhs.false35, %if.end33
  %40 = load i64, ptr %mask_a, align 8
  %or50 = or i64 %40, 1
  store i64 %or50, ptr %mask_a, align 8
  br label %if.end51

if.end51:                                         ; preds = %if.then49, %cond.end, %land.lhs.true, %lor.lhs.false37
  %41 = load i32, ptr %dsa_sign, align 4
  %tobool52 = icmp ne i32 %41, 0
  br i1 %tobool52, label %if.then53, label %if.end55

if.then53:                                        ; preds = %if.end51
  %42 = load i64, ptr %mask_a, align 8
  %or54 = or i64 %42, 2
  store i64 %or54, ptr %mask_a, align 8
  br label %if.end55

if.end55:                                         ; preds = %if.then53, %if.end51
  %43 = load i64, ptr %mask_a, align 8
  %or56 = or i64 %43, 4
  store i64 %or56, ptr %mask_a, align 8
  %44 = load ptr, ptr %pvalid, align 8
  %arrayidx57 = getelementptr inbounds i32, ptr %44, i64 0
  %45 = load i32, ptr %arrayidx57, align 4
  %and58 = and i32 %45, 4096
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.then60, label %if.end63

if.then60:                                        ; preds = %if.end55
  %46 = load i64, ptr %mask_a, align 8
  %or61 = or i64 %46, 1
  store i64 %or61, ptr %mask_a, align 8
  %47 = load i64, ptr %mask_k, align 8
  %or62 = or i64 %47, 1
  store i64 %or62, ptr %mask_k, align 8
  br label %if.end63

if.end63:                                         ; preds = %if.then60, %if.end55
  %48 = load ptr, ptr %pvalid, align 8
  %arrayidx64 = getelementptr inbounds i32, ptr %48, i64 3
  %49 = load i32, ptr %arrayidx64, align 4
  %and65 = and i32 %49, 4096
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %if.then67, label %if.end69

if.then67:                                        ; preds = %if.end63
  %50 = load i64, ptr %mask_a, align 8
  %or68 = or i64 %50, 8
  store i64 %or68, ptr %mask_a, align 8
  br label %if.end69

if.end69:                                         ; preds = %if.then67, %if.end63
  %51 = load ptr, ptr %s.addr, align 8
  %ssl70 = getelementptr inbounds %struct.ssl_connection_st, ptr %51, i32 0, i32 0
  %call71 = call i32 @SSL_version(ptr noundef %ssl70)
  %shr72 = ashr i32 %call71, 8
  %cmp73 = icmp eq i32 %shr72, 3
  br i1 %cmp73, label %cond.true74, label %cond.false77

cond.true74:                                      ; preds = %if.end69
  %52 = load ptr, ptr %s.addr, align 8
  %ssl75 = getelementptr inbounds %struct.ssl_connection_st, ptr %52, i32 0, i32 0
  %call76 = call i32 @SSL_version(ptr noundef %ssl75)
  br label %cond.end78

cond.false77:                                     ; preds = %if.end69
  br label %cond.end78

cond.end78:                                       ; preds = %cond.false77, %cond.true74
  %cond79 = phi i32 [ %call76, %cond.true74 ], [ 0, %cond.false77 ]
  %cmp80 = icmp eq i32 %cond79, 771
  br i1 %cmp80, label %if.then81, label %if.end98

if.then81:                                        ; preds = %cond.end78
  %53 = load ptr, ptr %pvalid, align 8
  %arrayidx82 = getelementptr inbounds i32, ptr %53, i64 1
  %54 = load i32, ptr %arrayidx82, align 4
  %and83 = and i32 %54, 4096
  %tobool84 = icmp ne i32 %and83, 0
  br i1 %tobool84, label %if.then85, label %if.end87

if.then85:                                        ; preds = %if.then81
  %55 = load i64, ptr %mask_a, align 8
  %or86 = or i64 %55, 1
  store i64 %or86, ptr %mask_a, align 8
  br label %if.end87

if.end87:                                         ; preds = %if.then85, %if.then81
  %56 = load ptr, ptr %pvalid, align 8
  %arrayidx88 = getelementptr inbounds i32, ptr %56, i64 7
  %57 = load i32, ptr %arrayidx88, align 4
  %and89 = and i32 %57, 4096
  %tobool90 = icmp ne i32 %and89, 0
  br i1 %tobool90, label %if.then95, label %lor.lhs.false91

lor.lhs.false91:                                  ; preds = %if.end87
  %58 = load ptr, ptr %pvalid, align 8
  %arrayidx92 = getelementptr inbounds i32, ptr %58, i64 8
  %59 = load i32, ptr %arrayidx92, align 4
  %and93 = and i32 %59, 4096
  %tobool94 = icmp ne i32 %and93, 0
  br i1 %tobool94, label %if.then95, label %if.end97

if.then95:                                        ; preds = %lor.lhs.false91, %if.end87
  %60 = load i64, ptr %mask_a, align 8
  %or96 = or i64 %60, 8
  store i64 %or96, ptr %mask_a, align 8
  br label %if.end97

if.end97:                                         ; preds = %if.then95, %lor.lhs.false91
  br label %if.end98

if.end98:                                         ; preds = %if.end97, %cond.end78
  %61 = load i32, ptr %have_ecc_cert, align 4
  %tobool99 = icmp ne i32 %61, 0
  br i1 %tobool99, label %if.then100, label %if.end113

if.then100:                                       ; preds = %if.end98
  %62 = load ptr, ptr %c, align 8
  %pkeys = getelementptr inbounds %struct.cert_st, ptr %62, i32 0, i32 5
  %63 = load ptr, ptr %pkeys, align 8
  %arrayidx101 = getelementptr inbounds %struct.cert_pkey_st, ptr %63, i64 3
  %x509 = getelementptr inbounds %struct.cert_pkey_st, ptr %arrayidx101, i32 0, i32 0
  %64 = load ptr, ptr %x509, align 8
  %call102 = call i32 @X509_get_key_usage(ptr noundef %64)
  store i32 %call102, ptr %ex_kusage, align 4
  %65 = load i32, ptr %ex_kusage, align 4
  %and103 = and i32 %65, 128
  store i32 %and103, ptr %ecdsa_ok, align 4
  %66 = load ptr, ptr %pvalid, align 8
  %arrayidx104 = getelementptr inbounds i32, ptr %66, i64 3
  %67 = load i32, ptr %arrayidx104, align 4
  %and105 = and i32 %67, 2
  %tobool106 = icmp ne i32 %and105, 0
  br i1 %tobool106, label %if.end108, label %if.then107

if.then107:                                       ; preds = %if.then100
  store i32 0, ptr %ecdsa_ok, align 4
  br label %if.end108

if.end108:                                        ; preds = %if.then107, %if.then100
  %68 = load i32, ptr %ecdsa_ok, align 4
  %tobool109 = icmp ne i32 %68, 0
  br i1 %tobool109, label %if.then110, label %if.end112

if.then110:                                       ; preds = %if.end108
  %69 = load i64, ptr %mask_a, align 8
  %or111 = or i64 %69, 8
  store i64 %or111, ptr %mask_a, align 8
  br label %if.end112

if.end112:                                        ; preds = %if.then110, %if.end108
  br label %if.end113

if.end113:                                        ; preds = %if.end112, %if.end98
  %70 = load i64, ptr %mask_a, align 8
  %and114 = and i64 %70, 8
  %tobool115 = icmp ne i64 %and114, 0
  br i1 %tobool115, label %if.end137, label %land.lhs.true116

land.lhs.true116:                                 ; preds = %if.end113
  %71 = load ptr, ptr %s.addr, align 8
  %call117 = call i32 @ssl_has_cert(ptr noundef %71, i32 noundef 7)
  %tobool118 = icmp ne i32 %call117, 0
  br i1 %tobool118, label %land.lhs.true119, label %if.end137

land.lhs.true119:                                 ; preds = %land.lhs.true116
  %72 = load ptr, ptr %pvalid, align 8
  %arrayidx120 = getelementptr inbounds i32, ptr %72, i64 7
  %73 = load i32, ptr %arrayidx120, align 4
  %and121 = and i32 %73, 256
  %tobool122 = icmp ne i32 %and121, 0
  br i1 %tobool122, label %land.lhs.true123, label %if.end137

land.lhs.true123:                                 ; preds = %land.lhs.true119
  %74 = load ptr, ptr %s.addr, align 8
  %ssl124 = getelementptr inbounds %struct.ssl_connection_st, ptr %74, i32 0, i32 0
  %call125 = call i32 @SSL_version(ptr noundef %ssl124)
  %shr126 = ashr i32 %call125, 8
  %cmp127 = icmp eq i32 %shr126, 3
  br i1 %cmp127, label %cond.true128, label %cond.false131

cond.true128:                                     ; preds = %land.lhs.true123
  %75 = load ptr, ptr %s.addr, align 8
  %ssl129 = getelementptr inbounds %struct.ssl_connection_st, ptr %75, i32 0, i32 0
  %call130 = call i32 @SSL_version(ptr noundef %ssl129)
  br label %cond.end132

cond.false131:                                    ; preds = %land.lhs.true123
  br label %cond.end132

cond.end132:                                      ; preds = %cond.false131, %cond.true128
  %cond133 = phi i32 [ %call130, %cond.true128 ], [ 0, %cond.false131 ]
  %cmp134 = icmp eq i32 %cond133, 771
  br i1 %cmp134, label %if.then135, label %if.end137

if.then135:                                       ; preds = %cond.end132
  %76 = load i64, ptr %mask_a, align 8
  %or136 = or i64 %76, 8
  store i64 %or136, ptr %mask_a, align 8
  br label %if.end137

if.end137:                                        ; preds = %if.then135, %cond.end132, %land.lhs.true119, %land.lhs.true116, %if.end113
  %77 = load i64, ptr %mask_a, align 8
  %and138 = and i64 %77, 8
  %tobool139 = icmp ne i64 %and138, 0
  br i1 %tobool139, label %if.end161, label %land.lhs.true140

land.lhs.true140:                                 ; preds = %if.end137
  %78 = load ptr, ptr %s.addr, align 8
  %call141 = call i32 @ssl_has_cert(ptr noundef %78, i32 noundef 8)
  %tobool142 = icmp ne i32 %call141, 0
  br i1 %tobool142, label %land.lhs.true143, label %if.end161

land.lhs.true143:                                 ; preds = %land.lhs.true140
  %79 = load ptr, ptr %pvalid, align 8
  %arrayidx144 = getelementptr inbounds i32, ptr %79, i64 8
  %80 = load i32, ptr %arrayidx144, align 4
  %and145 = and i32 %80, 256
  %tobool146 = icmp ne i32 %and145, 0
  br i1 %tobool146, label %land.lhs.true147, label %if.end161

land.lhs.true147:                                 ; preds = %land.lhs.true143
  %81 = load ptr, ptr %s.addr, align 8
  %ssl148 = getelementptr inbounds %struct.ssl_connection_st, ptr %81, i32 0, i32 0
  %call149 = call i32 @SSL_version(ptr noundef %ssl148)
  %shr150 = ashr i32 %call149, 8
  %cmp151 = icmp eq i32 %shr150, 3
  br i1 %cmp151, label %cond.true152, label %cond.false155

cond.true152:                                     ; preds = %land.lhs.true147
  %82 = load ptr, ptr %s.addr, align 8
  %ssl153 = getelementptr inbounds %struct.ssl_connection_st, ptr %82, i32 0, i32 0
  %call154 = call i32 @SSL_version(ptr noundef %ssl153)
  br label %cond.end156

cond.false155:                                    ; preds = %land.lhs.true147
  br label %cond.end156

cond.end156:                                      ; preds = %cond.false155, %cond.true152
  %cond157 = phi i32 [ %call154, %cond.true152 ], [ 0, %cond.false155 ]
  %cmp158 = icmp eq i32 %cond157, 771
  br i1 %cmp158, label %if.then159, label %if.end161

if.then159:                                       ; preds = %cond.end156
  %83 = load i64, ptr %mask_a, align 8
  %or160 = or i64 %83, 8
  store i64 %or160, ptr %mask_a, align 8
  br label %if.end161

if.end161:                                        ; preds = %if.then159, %cond.end156, %land.lhs.true143, %land.lhs.true140, %if.end137
  %84 = load i64, ptr %mask_k, align 8
  %or162 = or i64 %84, 4
  store i64 %or162, ptr %mask_k, align 8
  %85 = load i64, ptr %mask_k, align 8
  %or163 = or i64 %85, 8
  store i64 %or163, ptr %mask_k, align 8
  %86 = load i64, ptr %mask_a, align 8
  %or164 = or i64 %86, 16
  store i64 %or164, ptr %mask_a, align 8
  %87 = load i64, ptr %mask_k, align 8
  %and165 = and i64 %87, 1
  %tobool166 = icmp ne i64 %and165, 0
  br i1 %tobool166, label %if.then167, label %if.end169

if.then167:                                       ; preds = %if.end161
  %88 = load i64, ptr %mask_k, align 8
  %or168 = or i64 %88, 64
  store i64 %or168, ptr %mask_k, align 8
  br label %if.end169

if.end169:                                        ; preds = %if.then167, %if.end161
  %89 = load i64, ptr %mask_k, align 8
  %and170 = and i64 %89, 2
  %tobool171 = icmp ne i64 %and170, 0
  br i1 %tobool171, label %if.then172, label %if.end174

if.then172:                                       ; preds = %if.end169
  %90 = load i64, ptr %mask_k, align 8
  %or173 = or i64 %90, 256
  store i64 %or173, ptr %mask_k, align 8
  br label %if.end174

if.end174:                                        ; preds = %if.then172, %if.end169
  %91 = load i64, ptr %mask_k, align 8
  %and175 = and i64 %91, 4
  %tobool176 = icmp ne i64 %and175, 0
  br i1 %tobool176, label %if.then177, label %if.end179

if.then177:                                       ; preds = %if.end174
  %92 = load i64, ptr %mask_k, align 8
  %or178 = or i64 %92, 128
  store i64 %or178, ptr %mask_k, align 8
  br label %if.end179

if.end179:                                        ; preds = %if.then177, %if.end174
  %93 = load i64, ptr %mask_k, align 8
  %conv = trunc i64 %93 to i32
  %94 = load ptr, ptr %s.addr, align 8
  %s3180 = getelementptr inbounds %struct.ssl_connection_st, ptr %94, i32 0, i32 20
  %tmp181 = getelementptr inbounds %struct.anon, ptr %s3180, i32 0, i32 14
  %mask_k182 = getelementptr inbounds %struct.anon.0, ptr %tmp181, i32 0, i32 34
  store i32 %conv, ptr %mask_k182, align 8
  %95 = load i64, ptr %mask_a, align 8
  %conv183 = trunc i64 %95 to i32
  %96 = load ptr, ptr %s.addr, align 8
  %s3184 = getelementptr inbounds %struct.ssl_connection_st, ptr %96, i32 0, i32 20
  %tmp185 = getelementptr inbounds %struct.anon, ptr %s3184, i32 0, i32 14
  %mask_a186 = getelementptr inbounds %struct.anon.0, ptr %tmp185, i32 0, i32 35
  store i32 %conv183, ptr %mask_a186, align 4
  br label %return

return:                                           ; preds = %if.end179, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @ssl_has_cert(ptr noundef %s, i32 noundef %idx) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  %0 = load i32, ptr %idx.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %idx.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %ssl_pkey_num = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 19
  %3 = load i64, ptr %ssl_pkey_num, align 8
  %conv = trunc i64 %3 to i32
  %cmp1 = icmp sge i32 %1, %conv
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ssl_has_cert_type(ptr noundef %4, i8 noundef zeroext 2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %s.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 44
  %6 = load ptr, ptr %cert, align 8
  %pkeys = getelementptr inbounds %struct.cert_st, ptr %6, i32 0, i32 5
  %7 = load ptr, ptr %pkeys, align 8
  %8 = load i32, ptr %idx.addr, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds %struct.cert_pkey_st, ptr %7, i64 %idxprom
  %privatekey = getelementptr inbounds %struct.cert_pkey_st, ptr %arrayidx, i32 0, i32 1
  %9 = load ptr, ptr %privatekey, align 8
  %cmp4 = icmp ne ptr %9, null
  %conv5 = zext i1 %cmp4 to i32
  store i32 %conv5, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  %10 = load ptr, ptr %s.addr, align 8
  %cert7 = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 44
  %11 = load ptr, ptr %cert7, align 8
  %pkeys8 = getelementptr inbounds %struct.cert_st, ptr %11, i32 0, i32 5
  %12 = load ptr, ptr %pkeys8, align 8
  %13 = load i32, ptr %idx.addr, align 4
  %idxprom9 = sext i32 %13 to i64
  %arrayidx10 = getelementptr inbounds %struct.cert_pkey_st, ptr %12, i64 %idxprom9
  %x509 = getelementptr inbounds %struct.cert_pkey_st, ptr %arrayidx10, i32 0, i32 0
  %14 = load ptr, ptr %x509, align 8
  %cmp11 = icmp ne ptr %14, null
  br i1 %cmp11, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end6
  %15 = load ptr, ptr %s.addr, align 8
  %cert13 = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 44
  %16 = load ptr, ptr %cert13, align 8
  %pkeys14 = getelementptr inbounds %struct.cert_st, ptr %16, i32 0, i32 5
  %17 = load ptr, ptr %pkeys14, align 8
  %18 = load i32, ptr %idx.addr, align 4
  %idxprom15 = sext i32 %18 to i64
  %arrayidx16 = getelementptr inbounds %struct.cert_pkey_st, ptr %17, i64 %idxprom15
  %privatekey17 = getelementptr inbounds %struct.cert_pkey_st, ptr %arrayidx16, i32 0, i32 1
  %19 = load ptr, ptr %privatekey17, align 8
  %cmp18 = icmp ne ptr %19, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end6
  %20 = phi i1 [ false, %if.end6 ], [ %cmp18, %land.rhs ]
  %land.ext = zext i1 %20 to i32
  store i32 %land.ext, ptr %retval, align 4
  br label %return

return:                                           ; preds = %land.end, %if.then3, %if.then
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define i32 @SSL_version(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %type12 = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type12, align 8
  %cmp13 = icmp eq i32 %9, 1
  br i1 %cmp13, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %10 = load ptr, ptr %s.addr, align 8
  %type14 = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %type14, align 8
  %cmp15 = icmp eq i32 %11, 2
  br i1 %cmp15, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %12 = load ptr, ptr %sc, align 8
  %cmp16 = icmp eq ptr %12, null
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end
  %13 = load ptr, ptr %sc, align 8
  %version = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 1
  %14 = load i32, ptr %version, align 8
  store i32 %14, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then17, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

declare i32 @X509_get_key_usage(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @ssl_check_srvr_ecc_cert_and_alg(ptr noundef %x, ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 20
  %tmp = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 14
  %new_cipher = getelementptr inbounds %struct.anon.0, ptr %tmp, i32 0, i32 6
  %1 = load ptr, ptr %new_cipher, align 8
  %algorithm_auth = getelementptr inbounds %struct.ssl_cipher_st, ptr %1, i32 0, i32 5
  %2 = load i32, ptr %algorithm_auth, align 8
  %and = and i32 %2, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %x.addr, align 8
  %call = call i32 @X509_get_key_usage(ptr noundef %3)
  %and1 = and i32 %call, 128
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 4460, ptr noundef @__func__.ssl_check_srvr_ecc_cert_and_alg)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 318, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end4

if.end4:                                          ; preds = %if.end, %entry
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define i32 @ssl_get_server_cert_serverinfo(ptr noundef %s, ptr noundef %serverinfo, ptr noundef %serverinfo_length) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %serverinfo.addr = alloca ptr, align 8
  %serverinfo_length.addr = alloca ptr, align 8
  %cpk = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %serverinfo, ptr %serverinfo.addr, align 8
  store ptr %serverinfo_length, ptr %serverinfo_length.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 20
  %tmp = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 14
  %cert = getelementptr inbounds %struct.anon.0, ptr %tmp, i32 0, i32 27
  %1 = load ptr, ptr %cert, align 8
  store ptr %1, ptr %cpk, align 8
  %2 = load ptr, ptr %serverinfo_length.addr, align 8
  store i64 0, ptr %2, align 8
  %3 = load ptr, ptr %cpk, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load ptr, ptr %cpk, align 8
  %serverinfo1 = getelementptr inbounds %struct.cert_pkey_st, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %serverinfo1, align 8
  %cmp2 = icmp eq ptr %5, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %6 = load ptr, ptr %cpk, align 8
  %serverinfo3 = getelementptr inbounds %struct.cert_pkey_st, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %serverinfo3, align 8
  %8 = load ptr, ptr %serverinfo.addr, align 8
  store ptr %7, ptr %8, align 8
  %9 = load ptr, ptr %cpk, align 8
  %serverinfo_length4 = getelementptr inbounds %struct.cert_pkey_st, ptr %9, i32 0, i32 4
  %10 = load i64, ptr %serverinfo_length4, align 8
  %11 = load ptr, ptr %serverinfo_length.addr, align 8
  store i64 %10, ptr %11, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define void @ssl_update_cache(ptr noundef %s, i32 noundef %mode) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %stat = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 50
  %1 = load ptr, ptr %session, align 8
  %session_id_length = getelementptr inbounds %struct.ssl_session_st, ptr %1, i32 0, i32 4
  %2 = load i64, ptr %session_id_length, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end98

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %s.addr, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %3, i32 0, i32 7
  %4 = load i32, ptr %server, align 8
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %5 = load ptr, ptr %s.addr, align 8
  %session1 = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 50
  %6 = load ptr, ptr %session1, align 8
  %sid_ctx_length = getelementptr inbounds %struct.ssl_session_st, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %sid_ctx_length, align 8
  %cmp2 = icmp eq i64 %7, 0
  br i1 %cmp2, label %land.lhs.true3, label %if.end6

land.lhs.true3:                                   ; preds = %land.lhs.true
  %8 = load ptr, ptr %s.addr, align 8
  %verify_mode = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 57
  %9 = load i32, ptr %verify_mode, align 8
  %and = and i32 %9, 1
  %cmp4 = icmp ne i32 %and, 0
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true3
  br label %if.end98

if.end6:                                          ; preds = %land.lhs.true3, %land.lhs.true, %if.end
  %10 = load ptr, ptr %s.addr, align 8
  %session_ctx = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 87
  %11 = load ptr, ptr %session_ctx, align 8
  %session_cache_mode = getelementptr inbounds %struct.ssl_ctx_st, ptr %11, i32 0, i32 10
  %12 = load i32, ptr %session_cache_mode, align 8
  store i32 %12, ptr %i, align 4
  %13 = load i32, ptr %i, align 4
  %14 = load i32, ptr %mode.addr, align 4
  %and7 = and i32 %13, %14
  %cmp8 = icmp ne i32 %and7, 0
  br i1 %cmp8, label %land.lhs.true9, label %if.end76

land.lhs.true9:                                   ; preds = %if.end6
  %15 = load ptr, ptr %s.addr, align 8
  %hit = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 24
  %16 = load i32, ptr %hit, align 8
  %tobool10 = icmp ne i32 %16, 0
  br i1 %tobool10, label %lor.lhs.false, label %if.then22

lor.lhs.false:                                    ; preds = %land.lhs.true9
  %17 = load ptr, ptr %s.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %18 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %18, i32 0, i32 28
  %19 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %19, i32 0, i32 10
  %20 = load i32, ptr %enc_flags, align 8
  %and11 = and i32 %20, 8
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.end76, label %land.lhs.true13

land.lhs.true13:                                  ; preds = %lor.lhs.false
  %21 = load ptr, ptr %s.addr, align 8
  %ssl14 = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 0
  %method15 = getelementptr inbounds %struct.ssl_st, ptr %ssl14, i32 0, i32 3
  %22 = load ptr, ptr %method15, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %22, i32 0, i32 0
  %23 = load i32, ptr %version, align 8
  %cmp16 = icmp sge i32 %23, 772
  br i1 %cmp16, label %land.lhs.true17, label %if.end76

land.lhs.true17:                                  ; preds = %land.lhs.true13
  %24 = load ptr, ptr %s.addr, align 8
  %ssl18 = getelementptr inbounds %struct.ssl_connection_st, ptr %24, i32 0, i32 0
  %method19 = getelementptr inbounds %struct.ssl_st, ptr %ssl18, i32 0, i32 3
  %25 = load ptr, ptr %method19, align 8
  %version20 = getelementptr inbounds %struct.ssl_method_st, ptr %25, i32 0, i32 0
  %26 = load i32, ptr %version20, align 8
  %cmp21 = icmp ne i32 %26, 65536
  br i1 %cmp21, label %if.then22, label %if.end76

if.then22:                                        ; preds = %land.lhs.true17, %land.lhs.true9
  %27 = load i32, ptr %i, align 4
  %and23 = and i32 %27, 512
  %cmp24 = icmp eq i32 %and23, 0
  br i1 %cmp24, label %land.lhs.true25, label %if.end60

land.lhs.true25:                                  ; preds = %if.then22
  %28 = load ptr, ptr %s.addr, align 8
  %ssl26 = getelementptr inbounds %struct.ssl_connection_st, ptr %28, i32 0, i32 0
  %method27 = getelementptr inbounds %struct.ssl_st, ptr %ssl26, i32 0, i32 3
  %29 = load ptr, ptr %method27, align 8
  %ssl3_enc28 = getelementptr inbounds %struct.ssl_method_st, ptr %29, i32 0, i32 28
  %30 = load ptr, ptr %ssl3_enc28, align 8
  %enc_flags29 = getelementptr inbounds %struct.ssl3_enc_method, ptr %30, i32 0, i32 10
  %31 = load i32, ptr %enc_flags29, align 8
  %and30 = and i32 %31, 8
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.then57, label %land.lhs.true32

land.lhs.true32:                                  ; preds = %land.lhs.true25
  %32 = load ptr, ptr %s.addr, align 8
  %ssl33 = getelementptr inbounds %struct.ssl_connection_st, ptr %32, i32 0, i32 0
  %method34 = getelementptr inbounds %struct.ssl_st, ptr %ssl33, i32 0, i32 3
  %33 = load ptr, ptr %method34, align 8
  %version35 = getelementptr inbounds %struct.ssl_method_st, ptr %33, i32 0, i32 0
  %34 = load i32, ptr %version35, align 8
  %cmp36 = icmp sge i32 %34, 772
  br i1 %cmp36, label %land.lhs.true37, label %if.then57

land.lhs.true37:                                  ; preds = %land.lhs.true32
  %35 = load ptr, ptr %s.addr, align 8
  %ssl38 = getelementptr inbounds %struct.ssl_connection_st, ptr %35, i32 0, i32 0
  %method39 = getelementptr inbounds %struct.ssl_st, ptr %ssl38, i32 0, i32 3
  %36 = load ptr, ptr %method39, align 8
  %version40 = getelementptr inbounds %struct.ssl_method_st, ptr %36, i32 0, i32 0
  %37 = load i32, ptr %version40, align 8
  %cmp41 = icmp ne i32 %37, 65536
  br i1 %cmp41, label %lor.lhs.false42, label %if.then57

lor.lhs.false42:                                  ; preds = %land.lhs.true37
  %38 = load ptr, ptr %s.addr, align 8
  %server43 = getelementptr inbounds %struct.ssl_connection_st, ptr %38, i32 0, i32 7
  %39 = load i32, ptr %server43, align 8
  %tobool44 = icmp ne i32 %39, 0
  br i1 %tobool44, label %lor.lhs.false45, label %if.then57

lor.lhs.false45:                                  ; preds = %lor.lhs.false42
  %40 = load ptr, ptr %s.addr, align 8
  %max_early_data = getelementptr inbounds %struct.ssl_connection_st, ptr %40, i32 0, i32 106
  %41 = load i32, ptr %max_early_data, align 8
  %cmp46 = icmp ugt i32 %41, 0
  br i1 %cmp46, label %land.lhs.true47, label %lor.lhs.false50

land.lhs.true47:                                  ; preds = %lor.lhs.false45
  %42 = load ptr, ptr %s.addr, align 8
  %options = getelementptr inbounds %struct.ssl_connection_st, ptr %42, i32 0, i32 70
  %43 = load i64, ptr %options, align 8
  %and48 = and i64 %43, 16777216
  %cmp49 = icmp eq i64 %and48, 0
  br i1 %cmp49, label %if.then57, label %lor.lhs.false50

lor.lhs.false50:                                  ; preds = %land.lhs.true47, %lor.lhs.false45
  %44 = load ptr, ptr %s.addr, align 8
  %session_ctx51 = getelementptr inbounds %struct.ssl_connection_st, ptr %44, i32 0, i32 87
  %45 = load ptr, ptr %session_ctx51, align 8
  %remove_session_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %45, i32 0, i32 13
  %46 = load ptr, ptr %remove_session_cb, align 8
  %cmp52 = icmp ne ptr %46, null
  br i1 %cmp52, label %if.then57, label %lor.lhs.false53

lor.lhs.false53:                                  ; preds = %lor.lhs.false50
  %47 = load ptr, ptr %s.addr, align 8
  %options54 = getelementptr inbounds %struct.ssl_connection_st, ptr %47, i32 0, i32 70
  %48 = load i64, ptr %options54, align 8
  %and55 = and i64 %48, 16384
  %cmp56 = icmp ne i64 %and55, 0
  br i1 %cmp56, label %if.then57, label %if.end60

if.then57:                                        ; preds = %lor.lhs.false53, %lor.lhs.false50, %land.lhs.true47, %lor.lhs.false42, %land.lhs.true37, %land.lhs.true32, %land.lhs.true25
  %49 = load ptr, ptr %s.addr, align 8
  %session_ctx58 = getelementptr inbounds %struct.ssl_connection_st, ptr %49, i32 0, i32 87
  %50 = load ptr, ptr %session_ctx58, align 8
  %51 = load ptr, ptr %s.addr, align 8
  %session59 = getelementptr inbounds %struct.ssl_connection_st, ptr %51, i32 0, i32 50
  %52 = load ptr, ptr %session59, align 8
  %call = call i32 @SSL_CTX_add_session(ptr noundef %50, ptr noundef %52)
  br label %if.end60

if.end60:                                         ; preds = %if.then57, %lor.lhs.false53, %if.then22
  %53 = load ptr, ptr %s.addr, align 8
  %session_ctx61 = getelementptr inbounds %struct.ssl_connection_st, ptr %53, i32 0, i32 87
  %54 = load ptr, ptr %session_ctx61, align 8
  %new_session_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %54, i32 0, i32 12
  %55 = load ptr, ptr %new_session_cb, align 8
  %cmp62 = icmp ne ptr %55, null
  br i1 %cmp62, label %if.then63, label %if.end75

if.then63:                                        ; preds = %if.end60
  %56 = load ptr, ptr %s.addr, align 8
  %session64 = getelementptr inbounds %struct.ssl_connection_st, ptr %56, i32 0, i32 50
  %57 = load ptr, ptr %session64, align 8
  %call65 = call i32 @SSL_SESSION_up_ref(ptr noundef %57)
  %58 = load ptr, ptr %s.addr, align 8
  %session_ctx66 = getelementptr inbounds %struct.ssl_connection_st, ptr %58, i32 0, i32 87
  %59 = load ptr, ptr %session_ctx66, align 8
  %new_session_cb67 = getelementptr inbounds %struct.ssl_ctx_st, ptr %59, i32 0, i32 12
  %60 = load ptr, ptr %new_session_cb67, align 8
  %61 = load ptr, ptr %s.addr, align 8
  %ssl68 = getelementptr inbounds %struct.ssl_connection_st, ptr %61, i32 0, i32 0
  %62 = load ptr, ptr %s.addr, align 8
  %session69 = getelementptr inbounds %struct.ssl_connection_st, ptr %62, i32 0, i32 50
  %63 = load ptr, ptr %session69, align 8
  %call70 = call i32 %60(ptr noundef %ssl68, ptr noundef %63)
  %tobool71 = icmp ne i32 %call70, 0
  br i1 %tobool71, label %if.end74, label %if.then72

if.then72:                                        ; preds = %if.then63
  %64 = load ptr, ptr %s.addr, align 8
  %session73 = getelementptr inbounds %struct.ssl_connection_st, ptr %64, i32 0, i32 50
  %65 = load ptr, ptr %session73, align 8
  call void @SSL_SESSION_free(ptr noundef %65)
  br label %if.end74

if.end74:                                         ; preds = %if.then72, %if.then63
  br label %if.end75

if.end75:                                         ; preds = %if.end74, %if.end60
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %land.lhs.true17, %land.lhs.true13, %lor.lhs.false, %if.end6
  %66 = load i32, ptr %i, align 4
  %and77 = and i32 %66, 128
  %tobool78 = icmp ne i32 %and77, 0
  br i1 %tobool78, label %if.end98, label %land.lhs.true79

land.lhs.true79:                                  ; preds = %if.end76
  %67 = load i32, ptr %i, align 4
  %68 = load i32, ptr %mode.addr, align 4
  %and80 = and i32 %67, %68
  %69 = load i32, ptr %mode.addr, align 4
  %cmp81 = icmp eq i32 %and80, %69
  br i1 %cmp81, label %if.then82, label %if.end98

if.then82:                                        ; preds = %land.lhs.true79
  %70 = load i32, ptr %mode.addr, align 4
  %and83 = and i32 %70, 1
  %tobool84 = icmp ne i32 %and83, 0
  br i1 %tobool84, label %if.then85, label %if.else

if.then85:                                        ; preds = %if.then82
  %71 = load ptr, ptr %s.addr, align 8
  %session_ctx86 = getelementptr inbounds %struct.ssl_connection_st, ptr %71, i32 0, i32 87
  %72 = load ptr, ptr %session_ctx86, align 8
  %stats = getelementptr inbounds %struct.ssl_ctx_st, ptr %72, i32 0, i32 15
  %sess_connect_good = getelementptr inbounds %struct.anon.3, ptr %stats, i32 0, i32 2
  store ptr %sess_connect_good, ptr %stat, align 8
  br label %if.end89

if.else:                                          ; preds = %if.then82
  %73 = load ptr, ptr %s.addr, align 8
  %session_ctx87 = getelementptr inbounds %struct.ssl_connection_st, ptr %73, i32 0, i32 87
  %74 = load ptr, ptr %session_ctx87, align 8
  %stats88 = getelementptr inbounds %struct.ssl_ctx_st, ptr %74, i32 0, i32 15
  %sess_accept_good = getelementptr inbounds %struct.anon.3, ptr %stats88, i32 0, i32 5
  store ptr %sess_accept_good, ptr %stat, align 8
  br label %if.end89

if.end89:                                         ; preds = %if.else, %if.then85
  %75 = load ptr, ptr %s.addr, align 8
  %session_ctx90 = getelementptr inbounds %struct.ssl_connection_st, ptr %75, i32 0, i32 87
  %76 = load ptr, ptr %session_ctx90, align 8
  %77 = load ptr, ptr %stat, align 8
  %call91 = call i32 @ssl_tsan_load(ptr noundef %76, ptr noundef %77)
  %and92 = and i32 %call91, 255
  %cmp93 = icmp eq i32 %and92, 255
  br i1 %cmp93, label %if.then94, label %if.end97

if.then94:                                        ; preds = %if.end89
  %78 = load ptr, ptr %s.addr, align 8
  %session_ctx95 = getelementptr inbounds %struct.ssl_connection_st, ptr %78, i32 0, i32 87
  %79 = load ptr, ptr %session_ctx95, align 8
  %call96 = call i64 @time(ptr noundef null) #7
  call void @SSL_CTX_flush_sessions(ptr noundef %79, i64 noundef %call96)
  br label %if.end97

if.end97:                                         ; preds = %if.then94, %if.end89
  br label %if.end98

if.end98:                                         ; preds = %if.end97, %land.lhs.true79, %if.end76, %if.then5, %if.then
  ret void
}

declare i32 @SSL_CTX_add_session(ptr noundef, ptr noundef) #1

declare i32 @SSL_SESSION_up_ref(ptr noundef) #1

; Function Attrs: nounwind
declare i64 @time(ptr noundef) #5

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get_ssl_method(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %method = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %method, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_ssl_method(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 3
  %1 = load ptr, ptr %method, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_ssl_method(ptr noundef %s, ptr noundef %meth) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %meth.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %sc = alloca ptr, align 8
  %sm = alloca ptr, align 8
  %hf = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %meth, ptr %meth.addr, align 8
  store i32 1, ptr %ret, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp ne i32 %10, 0
  br i1 %cmp14, label %land.lhs.true, label %lor.lhs.false16

land.lhs.true:                                    ; preds = %lor.lhs.false
  %11 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 3
  %12 = load ptr, ptr %method, align 8
  %13 = load ptr, ptr %meth.addr, align 8
  %cmp15 = icmp ne ptr %12, %13
  br i1 %cmp15, label %if.then, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %land.lhs.true, %lor.lhs.false
  %14 = load ptr, ptr %s.addr, align 8
  %type17 = getelementptr inbounds %struct.ssl_st, ptr %14, i32 0, i32 0
  %15 = load i32, ptr %type17, align 8
  %cmp18 = icmp eq i32 %15, 0
  br i1 %cmp18, label %land.lhs.true19, label %if.end

land.lhs.true19:                                  ; preds = %lor.lhs.false16
  %16 = load ptr, ptr %meth.addr, align 8
  %call = call ptr @OSSL_QUIC_client_method()
  %cmp20 = icmp eq ptr %16, %call
  br i1 %cmp20, label %if.then, label %lor.lhs.false21

lor.lhs.false21:                                  ; preds = %land.lhs.true19
  %17 = load ptr, ptr %meth.addr, align 8
  %call22 = call ptr @OSSL_QUIC_client_thread_method()
  %cmp23 = icmp eq ptr %17, %call22
  br i1 %cmp23, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false21, %land.lhs.true19, %land.lhs.true, %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false21, %lor.lhs.false16
  %18 = load ptr, ptr %s.addr, align 8
  %method24 = getelementptr inbounds %struct.ssl_st, ptr %18, i32 0, i32 3
  %19 = load ptr, ptr %method24, align 8
  %20 = load ptr, ptr %meth.addr, align 8
  %cmp25 = icmp ne ptr %19, %20
  br i1 %cmp25, label %if.then26, label %if.end47

if.then26:                                        ; preds = %if.end
  %21 = load ptr, ptr %s.addr, align 8
  %method27 = getelementptr inbounds %struct.ssl_st, ptr %21, i32 0, i32 3
  %22 = load ptr, ptr %method27, align 8
  store ptr %22, ptr %sm, align 8
  %23 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 6
  %24 = load ptr, ptr %handshake_func, align 8
  store ptr %24, ptr %hf, align 8
  %25 = load ptr, ptr %sm, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %25, i32 0, i32 0
  %26 = load i32, ptr %version, align 8
  %27 = load ptr, ptr %meth.addr, align 8
  %version28 = getelementptr inbounds %struct.ssl_method_st, ptr %27, i32 0, i32 0
  %28 = load i32, ptr %version28, align 8
  %cmp29 = icmp eq i32 %26, %28
  br i1 %cmp29, label %if.then30, label %if.else

if.then30:                                        ; preds = %if.then26
  %29 = load ptr, ptr %meth.addr, align 8
  %30 = load ptr, ptr %s.addr, align 8
  %method31 = getelementptr inbounds %struct.ssl_st, ptr %30, i32 0, i32 3
  store ptr %29, ptr %method31, align 8
  br label %if.end35

if.else:                                          ; preds = %if.then26
  %31 = load ptr, ptr %sm, align 8
  %ssl_deinit = getelementptr inbounds %struct.ssl_method_st, ptr %31, i32 0, i32 8
  %32 = load ptr, ptr %ssl_deinit, align 8
  %33 = load ptr, ptr %s.addr, align 8
  call void %32(ptr noundef %33)
  %34 = load ptr, ptr %meth.addr, align 8
  %35 = load ptr, ptr %s.addr, align 8
  %method32 = getelementptr inbounds %struct.ssl_st, ptr %35, i32 0, i32 3
  store ptr %34, ptr %method32, align 8
  %36 = load ptr, ptr %s.addr, align 8
  %method33 = getelementptr inbounds %struct.ssl_st, ptr %36, i32 0, i32 3
  %37 = load ptr, ptr %method33, align 8
  %ssl_init = getelementptr inbounds %struct.ssl_method_st, ptr %37, i32 0, i32 6
  %38 = load ptr, ptr %ssl_init, align 8
  %39 = load ptr, ptr %s.addr, align 8
  %call34 = call i32 %38(ptr noundef %39)
  store i32 %call34, ptr %ret, align 4
  br label %if.end35

if.end35:                                         ; preds = %if.else, %if.then30
  %40 = load ptr, ptr %hf, align 8
  %41 = load ptr, ptr %sm, align 8
  %ssl_connect = getelementptr inbounds %struct.ssl_method_st, ptr %41, i32 0, i32 10
  %42 = load ptr, ptr %ssl_connect, align 8
  %cmp36 = icmp eq ptr %40, %42
  br i1 %cmp36, label %if.then37, label %if.else40

if.then37:                                        ; preds = %if.end35
  %43 = load ptr, ptr %meth.addr, align 8
  %ssl_connect38 = getelementptr inbounds %struct.ssl_method_st, ptr %43, i32 0, i32 10
  %44 = load ptr, ptr %ssl_connect38, align 8
  %45 = load ptr, ptr %sc, align 8
  %handshake_func39 = getelementptr inbounds %struct.ssl_connection_st, ptr %45, i32 0, i32 6
  store ptr %44, ptr %handshake_func39, align 8
  br label %if.end46

if.else40:                                        ; preds = %if.end35
  %46 = load ptr, ptr %hf, align 8
  %47 = load ptr, ptr %sm, align 8
  %ssl_accept = getelementptr inbounds %struct.ssl_method_st, ptr %47, i32 0, i32 9
  %48 = load ptr, ptr %ssl_accept, align 8
  %cmp41 = icmp eq ptr %46, %48
  br i1 %cmp41, label %if.then42, label %if.end45

if.then42:                                        ; preds = %if.else40
  %49 = load ptr, ptr %meth.addr, align 8
  %ssl_accept43 = getelementptr inbounds %struct.ssl_method_st, ptr %49, i32 0, i32 9
  %50 = load ptr, ptr %ssl_accept43, align 8
  %51 = load ptr, ptr %sc, align 8
  %handshake_func44 = getelementptr inbounds %struct.ssl_connection_st, ptr %51, i32 0, i32 6
  store ptr %50, ptr %handshake_func44, align 8
  br label %if.end45

if.end45:                                         ; preds = %if.then42, %if.else40
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.then37
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.end
  %52 = load i32, ptr %ret, align 4
  store i32 %52, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end47, %if.then
  %53 = load i32, ptr %retval, align 4
  ret i32 %53
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_error(ptr noundef %s, i32 noundef %i) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %i.addr, align 4
  %call = call i32 @ossl_ssl_get_error(ptr noundef %0, i32 noundef %1, i32 noundef 1)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @ossl_ssl_get_error(ptr noundef %s, i32 noundef %i, i32 noundef %check_err) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  %check_err.addr = alloca i32, align 4
  %reason = alloca i32, align 4
  %l = alloca i64, align 8
  %bio = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  store i32 %check_err, ptr %check_err.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load i32, ptr %i.addr, align 4
  %cmp12 = icmp sgt i32 %8, 0
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %cmp13 = icmp ne ptr %9, null
  br i1 %cmp13, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %if.end
  %10 = load ptr, ptr %s.addr, align 8
  %type14 = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %type14, align 8
  %cmp15 = icmp eq i32 %11, 1
  br i1 %cmp15, label %if.then18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %12 = load ptr, ptr %s.addr, align 8
  %type16 = getelementptr inbounds %struct.ssl_st, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %type16, align 8
  %cmp17 = icmp eq i32 %13, 2
  br i1 %cmp17, label %if.then18, label %if.end22

if.then18:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load i32, ptr %i.addr, align 4
  %call = call i32 @ossl_quic_get_error(ptr noundef %14, i32 noundef %15)
  store i32 %call, ptr %reason, align 4
  %16 = load i32, ptr %reason, align 4
  %cmp19 = icmp ne i32 %16, 0
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.then18
  %17 = load i32, ptr %reason, align 4
  store i32 %17, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.then18
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %lor.lhs.false, %if.end
  %18 = load ptr, ptr %sc, align 8
  %cmp23 = icmp eq ptr %18, null
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.end22
  store i32 1, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %if.end22
  %19 = load i32, ptr %check_err.addr, align 4
  %tobool = icmp ne i32 %19, 0
  br i1 %tobool, label %land.lhs.true26, label %if.end33

land.lhs.true26:                                  ; preds = %if.end25
  %call27 = call i64 @ERR_peek_error()
  store i64 %call27, ptr %l, align 8
  %cmp28 = icmp ne i64 %call27, 0
  br i1 %cmp28, label %if.then29, label %if.end33

if.then29:                                        ; preds = %land.lhs.true26
  %20 = load i64, ptr %l, align 8
  %call30 = call i32 @ERR_GET_LIB(i64 noundef %20)
  %cmp31 = icmp eq i32 %call30, 2
  br i1 %cmp31, label %if.then32, label %if.else

if.then32:                                        ; preds = %if.then29
  store i32 5, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %if.then29
  store i32 1, ptr %retval, align 4
  br label %return

if.end33:                                         ; preds = %land.lhs.true26, %if.end25
  %21 = load ptr, ptr %s.addr, align 8
  %cmp34 = icmp ne ptr %21, null
  br i1 %cmp34, label %land.lhs.true35, label %if.then41

land.lhs.true35:                                  ; preds = %if.end33
  %22 = load ptr, ptr %s.addr, align 8
  %type36 = getelementptr inbounds %struct.ssl_st, ptr %22, i32 0, i32 0
  %23 = load i32, ptr %type36, align 8
  %cmp37 = icmp eq i32 %23, 1
  br i1 %cmp37, label %if.end93, label %lor.lhs.false38

lor.lhs.false38:                                  ; preds = %land.lhs.true35
  %24 = load ptr, ptr %s.addr, align 8
  %type39 = getelementptr inbounds %struct.ssl_st, ptr %24, i32 0, i32 0
  %25 = load i32, ptr %type39, align 8
  %cmp40 = icmp eq i32 %25, 2
  br i1 %cmp40, label %if.end93, label %if.then41

if.then41:                                        ; preds = %lor.lhs.false38, %if.end33
  %26 = load ptr, ptr %s.addr, align 8
  %call42 = call i32 @SSL_want(ptr noundef %26)
  %cmp43 = icmp eq i32 %call42, 3
  br i1 %cmp43, label %if.then44, label %if.end67

if.then44:                                        ; preds = %if.then41
  %27 = load ptr, ptr %s.addr, align 8
  %call45 = call ptr @SSL_get_rbio(ptr noundef %27)
  store ptr %call45, ptr %bio, align 8
  %28 = load ptr, ptr %bio, align 8
  %call46 = call i32 @BIO_test_flags(ptr noundef %28, i32 noundef 1)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.then48, label %if.else49

if.then48:                                        ; preds = %if.then44
  store i32 2, ptr %retval, align 4
  br label %return

if.else49:                                        ; preds = %if.then44
  %29 = load ptr, ptr %bio, align 8
  %call50 = call i32 @BIO_test_flags(ptr noundef %29, i32 noundef 2)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %if.then52, label %if.else53

if.then52:                                        ; preds = %if.else49
  store i32 3, ptr %retval, align 4
  br label %return

if.else53:                                        ; preds = %if.else49
  %30 = load ptr, ptr %bio, align 8
  %call54 = call i32 @BIO_test_flags(ptr noundef %30, i32 noundef 4)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.then56, label %if.end64

if.then56:                                        ; preds = %if.else53
  %31 = load ptr, ptr %bio, align 8
  %call57 = call i32 @BIO_get_retry_reason(ptr noundef %31)
  store i32 %call57, ptr %reason, align 4
  %32 = load i32, ptr %reason, align 4
  %cmp58 = icmp eq i32 %32, 2
  br i1 %cmp58, label %if.then59, label %if.else60

if.then59:                                        ; preds = %if.then56
  store i32 7, ptr %retval, align 4
  br label %return

if.else60:                                        ; preds = %if.then56
  %33 = load i32, ptr %reason, align 4
  %cmp61 = icmp eq i32 %33, 3
  br i1 %cmp61, label %if.then62, label %if.else63

if.then62:                                        ; preds = %if.else60
  store i32 8, ptr %retval, align 4
  br label %return

if.else63:                                        ; preds = %if.else60
  store i32 5, ptr %retval, align 4
  br label %return

if.end64:                                         ; preds = %if.else53
  br label %if.end65

if.end65:                                         ; preds = %if.end64
  br label %if.end66

if.end66:                                         ; preds = %if.end65
  br label %if.end67

if.end67:                                         ; preds = %if.end66, %if.then41
  %34 = load ptr, ptr %s.addr, align 8
  %call68 = call i32 @SSL_want(ptr noundef %34)
  %cmp69 = icmp eq i32 %call68, 2
  br i1 %cmp69, label %if.then70, label %if.end92

if.then70:                                        ; preds = %if.end67
  %35 = load ptr, ptr %sc, align 8
  %wbio = getelementptr inbounds %struct.ssl_connection_st, ptr %35, i32 0, i32 3
  %36 = load ptr, ptr %wbio, align 8
  store ptr %36, ptr %bio, align 8
  %37 = load ptr, ptr %bio, align 8
  %call71 = call i32 @BIO_test_flags(ptr noundef %37, i32 noundef 2)
  %tobool72 = icmp ne i32 %call71, 0
  br i1 %tobool72, label %if.then73, label %if.else74

if.then73:                                        ; preds = %if.then70
  store i32 3, ptr %retval, align 4
  br label %return

if.else74:                                        ; preds = %if.then70
  %38 = load ptr, ptr %bio, align 8
  %call75 = call i32 @BIO_test_flags(ptr noundef %38, i32 noundef 1)
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %if.then77, label %if.else78

if.then77:                                        ; preds = %if.else74
  store i32 2, ptr %retval, align 4
  br label %return

if.else78:                                        ; preds = %if.else74
  %39 = load ptr, ptr %bio, align 8
  %call79 = call i32 @BIO_test_flags(ptr noundef %39, i32 noundef 4)
  %tobool80 = icmp ne i32 %call79, 0
  br i1 %tobool80, label %if.then81, label %if.end89

if.then81:                                        ; preds = %if.else78
  %40 = load ptr, ptr %bio, align 8
  %call82 = call i32 @BIO_get_retry_reason(ptr noundef %40)
  store i32 %call82, ptr %reason, align 4
  %41 = load i32, ptr %reason, align 4
  %cmp83 = icmp eq i32 %41, 2
  br i1 %cmp83, label %if.then84, label %if.else85

if.then84:                                        ; preds = %if.then81
  store i32 7, ptr %retval, align 4
  br label %return

if.else85:                                        ; preds = %if.then81
  %42 = load i32, ptr %reason, align 4
  %cmp86 = icmp eq i32 %42, 3
  br i1 %cmp86, label %if.then87, label %if.else88

if.then87:                                        ; preds = %if.else85
  store i32 8, ptr %retval, align 4
  br label %return

if.else88:                                        ; preds = %if.else85
  store i32 5, ptr %retval, align 4
  br label %return

if.end89:                                         ; preds = %if.else78
  br label %if.end90

if.end90:                                         ; preds = %if.end89
  br label %if.end91

if.end91:                                         ; preds = %if.end90
  br label %if.end92

if.end92:                                         ; preds = %if.end91, %if.end67
  br label %if.end93

if.end93:                                         ; preds = %if.end92, %lor.lhs.false38, %land.lhs.true35
  %43 = load ptr, ptr %s.addr, align 8
  %call94 = call i32 @SSL_want(ptr noundef %43)
  %cmp95 = icmp eq i32 %call94, 4
  br i1 %cmp95, label %if.then96, label %if.end97

if.then96:                                        ; preds = %if.end93
  store i32 4, ptr %retval, align 4
  br label %return

if.end97:                                         ; preds = %if.end93
  %44 = load ptr, ptr %s.addr, align 8
  %call98 = call i32 @SSL_want(ptr noundef %44)
  %cmp99 = icmp eq i32 %call98, 8
  br i1 %cmp99, label %if.then100, label %if.end101

if.then100:                                       ; preds = %if.end97
  store i32 12, ptr %retval, align 4
  br label %return

if.end101:                                        ; preds = %if.end97
  %45 = load ptr, ptr %s.addr, align 8
  %call102 = call i32 @SSL_want(ptr noundef %45)
  %cmp103 = icmp eq i32 %call102, 5
  br i1 %cmp103, label %if.then104, label %if.end105

if.then104:                                       ; preds = %if.end101
  store i32 9, ptr %retval, align 4
  br label %return

if.end105:                                        ; preds = %if.end101
  %46 = load ptr, ptr %s.addr, align 8
  %call106 = call i32 @SSL_want(ptr noundef %46)
  %cmp107 = icmp eq i32 %call106, 6
  br i1 %cmp107, label %if.then108, label %if.end109

if.then108:                                       ; preds = %if.end105
  store i32 10, ptr %retval, align 4
  br label %return

if.end109:                                        ; preds = %if.end105
  %47 = load ptr, ptr %s.addr, align 8
  %call110 = call i32 @SSL_want(ptr noundef %47)
  %cmp111 = icmp eq i32 %call110, 7
  br i1 %cmp111, label %if.then112, label %if.end113

if.then112:                                       ; preds = %if.end109
  store i32 11, ptr %retval, align 4
  br label %return

if.end113:                                        ; preds = %if.end109
  %48 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %48, i32 0, i32 10
  %49 = load i32, ptr %shutdown, align 4
  %and = and i32 %49, 2
  %tobool114 = icmp ne i32 %and, 0
  br i1 %tobool114, label %land.lhs.true115, label %if.end118

land.lhs.true115:                                 ; preds = %if.end113
  %50 = load ptr, ptr %sc, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %50, i32 0, i32 20
  %warn_alert = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 6
  %51 = load i32, ptr %warn_alert, align 4
  %cmp116 = icmp eq i32 %51, 0
  br i1 %cmp116, label %if.then117, label %if.end118

if.then117:                                       ; preds = %land.lhs.true115
  store i32 6, ptr %retval, align 4
  br label %return

if.end118:                                        ; preds = %land.lhs.true115, %if.end113
  store i32 5, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end118, %if.then117, %if.then112, %if.then108, %if.then104, %if.then100, %if.then96, %if.else88, %if.then87, %if.then84, %if.then77, %if.then73, %if.else63, %if.then62, %if.then59, %if.then52, %if.then48, %if.else, %if.then32, %if.then24, %if.then20, %if.then
  %52 = load i32, ptr %retval, align 4
  ret i32 %52
}

declare i32 @ossl_quic_get_error(ptr noundef, i32 noundef) #1

declare i64 @ERR_peek_error() #1

; Function Attrs: nounwind uwtable
define internal i32 @ERR_GET_LIB(i64 noundef %errcode) #0 {
entry:
  %retval = alloca i32, align 4
  %errcode.addr = alloca i64, align 8
  store i64 %errcode, ptr %errcode.addr, align 8
  %0 = load i64, ptr %errcode.addr, align 8
  %and = and i64 %0, 2147483648
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 2, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %errcode.addr, align 8
  %shr = lshr i64 %1, 23
  %and1 = and i64 %shr, 255
  %conv = trunc i64 %and1 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define i32 @SSL_want(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_want(ptr noundef %13)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %14 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %14, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %15 = load ptr, ptr %sc, align 8
  %rwstate = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 5
  %16 = load i32, ptr %rwstate, align 8
  store i32 %16, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

declare i32 @BIO_test_flags(ptr noundef, i32 noundef) #1

declare i32 @BIO_get_retry_reason(ptr noundef) #1

declare i32 @ossl_quic_do_handshake(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @ssl_do_handshake_intern(ptr noundef %vargs) #0 {
entry:
  %retval = alloca i32, align 4
  %vargs.addr = alloca ptr, align 8
  %args = alloca ptr, align 8
  %s = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %vargs, ptr %vargs.addr, align 8
  %0 = load ptr, ptr %vargs.addr, align 8
  store ptr %0, ptr %args, align 8
  %1 = load ptr, ptr %args, align 8
  %s1 = getelementptr inbounds %struct.ssl_async_args, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %s1, align 8
  store ptr %2, ptr %s, align 8
  %3 = load ptr, ptr %s, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end11

cond.false:                                       ; preds = %entry
  %4 = load ptr, ptr %s, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type, align 8
  %cmp2 = icmp eq i32 %5, 0
  br i1 %cmp2, label %cond.true3, label %cond.false4

cond.true3:                                       ; preds = %cond.false
  %6 = load ptr, ptr %s, align 8
  br label %cond.end9

cond.false4:                                      ; preds = %cond.false
  %7 = load ptr, ptr %s, align 8
  %type5 = getelementptr inbounds %struct.ssl_st, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %type5, align 8
  %cmp6 = icmp eq i32 %8, 1
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.false4
  %9 = load ptr, ptr %s, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false8:                                      ; preds = %cond.false4
  br label %cond.end

cond.end:                                         ; preds = %cond.false8, %cond.true7
  %cond = phi ptr [ %10, %cond.true7 ], [ null, %cond.false8 ]
  br label %cond.end9

cond.end9:                                        ; preds = %cond.end, %cond.true3
  %cond10 = phi ptr [ %6, %cond.true3 ], [ %cond, %cond.end ]
  br label %cond.end11

cond.end11:                                       ; preds = %cond.end9, %cond.true
  %cond12 = phi ptr [ null, %cond.true ], [ %cond10, %cond.end9 ]
  store ptr %cond12, ptr %sc, align 8
  %11 = load ptr, ptr %sc, align 8
  %cmp13 = icmp eq ptr %11, null
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end11
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end11
  %12 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 6
  %13 = load ptr, ptr %handshake_func, align 8
  %14 = load ptr, ptr %s, align 8
  %call = call i32 %13(ptr noundef %14)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

declare void @ossl_quic_set_accept_state(ptr noundef) #1

declare void @ossl_quic_set_connect_state(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @ssl_undefined_void_function() #0 {
entry:
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 4798, ptr noundef @__func__.ssl_undefined_void_function)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786689, ptr noundef null)
  ret i32 0
}

; Function Attrs: nounwind uwtable
define i32 @ssl_undefined_const_function(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  ret i32 0
}

; Function Attrs: nounwind uwtable
define ptr @ssl_bad_method(i32 noundef %ver) #0 {
entry:
  %ver.addr = alloca i32, align 4
  store i32 %ver, ptr %ver.addr, align 4
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 4809, ptr noundef @__func__.ssl_bad_method)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786689, ptr noundef null)
  ret ptr null
}

; Function Attrs: nounwind uwtable
define ptr @ssl_protocol_to_string(i32 noundef %version) #0 {
entry:
  %retval = alloca ptr, align 8
  %version.addr = alloca i32, align 4
  store i32 %version, ptr %version.addr, align 4
  %0 = load i32, ptr %version.addr, align 4
  switch i32 %0, label %sw.default [
    i32 772, label %sw.bb
    i32 771, label %sw.bb1
    i32 770, label %sw.bb2
    i32 769, label %sw.bb3
    i32 768, label %sw.bb4
    i32 256, label %sw.bb5
    i32 65279, label %sw.bb6
    i32 65277, label %sw.bb7
  ]

sw.bb:                                            ; preds = %entry
  store ptr @.str.3, ptr %retval, align 8
  br label %return

sw.bb1:                                           ; preds = %entry
  store ptr @.str.4, ptr %retval, align 8
  br label %return

sw.bb2:                                           ; preds = %entry
  store ptr @.str.5, ptr %retval, align 8
  br label %return

sw.bb3:                                           ; preds = %entry
  store ptr @.str.6, ptr %retval, align 8
  br label %return

sw.bb4:                                           ; preds = %entry
  store ptr @.str.7, ptr %retval, align 8
  br label %return

sw.bb5:                                           ; preds = %entry
  store ptr @.str.8, ptr %retval, align 8
  br label %return

sw.bb6:                                           ; preds = %entry
  store ptr @.str.9, ptr %retval, align 8
  br label %return

sw.bb7:                                           ; preds = %entry
  store ptr @.str.10, ptr %retval, align 8
  br label %return

sw.default:                                       ; preds = %entry
  store ptr @.str.11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %sw.default, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %1 = load ptr, ptr %retval, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_version(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %type12 = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type12, align 8
  %cmp13 = icmp eq i32 %9, 1
  br i1 %cmp13, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %10 = load ptr, ptr %s.addr, align 8
  %type14 = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %type14, align 8
  %cmp15 = icmp eq i32 %11, 2
  br i1 %cmp15, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store ptr @.str.12, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %12 = load ptr, ptr %sc, align 8
  %cmp16 = icmp eq ptr %12, null
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end18:                                         ; preds = %if.end
  %13 = load ptr, ptr %sc, align 8
  %version = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 1
  %14 = load i32, ptr %version, align 8
  %call = call ptr @ssl_protocol_to_string(i32 noundef %14)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end18, %if.then17, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_handshake_rtt(ptr noundef %s, ptr noundef %rtt) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %rtt.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  %agg.tmp = alloca %struct.OSSL_TIME, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %rtt, ptr %rtt.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %ts_msg_write = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 11
  %t = getelementptr inbounds %struct.OSSL_TIME, ptr %ts_msg_write, i32 0, i32 0
  %10 = load i64, ptr %t, align 8
  %cmp13 = icmp ule i64 %10, 0
  br i1 %cmp13, label %if.then16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %ts_msg_read = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 12
  %t14 = getelementptr inbounds %struct.OSSL_TIME, ptr %ts_msg_read, i32 0, i32 0
  %12 = load i64, ptr %t14, align 8
  %cmp15 = icmp ule i64 %12, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %lor.lhs.false, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %lor.lhs.false
  %13 = load ptr, ptr %sc, align 8
  %ts_msg_read18 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 12
  %t19 = getelementptr inbounds %struct.OSSL_TIME, ptr %ts_msg_read18, i32 0, i32 0
  %14 = load i64, ptr %t19, align 8
  %15 = load ptr, ptr %sc, align 8
  %ts_msg_write20 = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 11
  %t21 = getelementptr inbounds %struct.OSSL_TIME, ptr %ts_msg_write20, i32 0, i32 0
  %16 = load i64, ptr %t21, align 8
  %cmp22 = icmp ult i64 %14, %16
  br i1 %cmp22, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end17
  store i32 -1, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end17
  %17 = load ptr, ptr %sc, align 8
  %ts_msg_read25 = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 12
  %18 = load ptr, ptr %sc, align 8
  %ts_msg_write26 = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 11
  %coerce.dive = getelementptr inbounds %struct.OSSL_TIME, ptr %ts_msg_read25, i32 0, i32 0
  %19 = load i64, ptr %coerce.dive, align 8
  %coerce.dive27 = getelementptr inbounds %struct.OSSL_TIME, ptr %ts_msg_write26, i32 0, i32 0
  %20 = load i64, ptr %coerce.dive27, align 8
  %call = call i64 @ossl_time_subtract(i64 %19, i64 %20)
  %coerce.dive28 = getelementptr inbounds %struct.OSSL_TIME, ptr %agg.tmp, i32 0, i32 0
  store i64 %call, ptr %coerce.dive28, align 8
  %coerce.dive29 = getelementptr inbounds %struct.OSSL_TIME, ptr %agg.tmp, i32 0, i32 0
  %21 = load i64, ptr %coerce.dive29, align 8
  %call30 = call i64 @ossl_time2ticks(i64 %21)
  %div = udiv i64 %call30, 1000
  %22 = load ptr, ptr %rtt.addr, align 8
  store i64 %div, ptr %22, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end24, %if.then23, %if.then16, %if.then
  %23 = load i32, ptr %retval, align 4
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define internal i64 @ossl_time_subtract(i64 %a.coerce, i64 %b.coerce) #0 {
entry:
  %retval = alloca %struct.OSSL_TIME, align 8
  %a = alloca %struct.OSSL_TIME, align 8
  %b = alloca %struct.OSSL_TIME, align 8
  %r = alloca %struct.OSSL_TIME, align 8
  %err = alloca i32, align 4
  %coerce.dive = getelementptr inbounds %struct.OSSL_TIME, ptr %a, i32 0, i32 0
  store i64 %a.coerce, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %struct.OSSL_TIME, ptr %b, i32 0, i32 0
  store i64 %b.coerce, ptr %coerce.dive1, align 8
  store i32 0, ptr %err, align 4
  %t = getelementptr inbounds %struct.OSSL_TIME, ptr %a, i32 0, i32 0
  %0 = load i64, ptr %t, align 8
  %t2 = getelementptr inbounds %struct.OSSL_TIME, ptr %b, i32 0, i32 0
  %1 = load i64, ptr %t2, align 8
  %call = call i64 @safe_sub_time(i64 noundef %0, i64 noundef %1, ptr noundef %err)
  %t3 = getelementptr inbounds %struct.OSSL_TIME, ptr %r, i32 0, i32 0
  store i64 %call, ptr %t3, align 8
  %2 = load i32, ptr %err, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call4 = call i64 @ossl_time_zero()
  %coerce.dive5 = getelementptr inbounds %struct.OSSL_TIME, ptr %retval, i32 0, i32 0
  store i64 %call4, ptr %coerce.dive5, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %retval, ptr align 8 %r, i64 8, i1 false)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %coerce.dive6 = getelementptr inbounds %struct.OSSL_TIME, ptr %retval, i32 0, i32 0
  %3 = load i64, ptr %coerce.dive6, align 8
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define ptr @SSL_dup(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %ret = alloca ptr, align 8
  %i = alloca i32, align 4
  %retsc = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @SSL_in_init(ptr noundef %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then9

lor.lhs.false:                                    ; preds = %if.end
  %6 = load ptr, ptr %s.addr, align 8
  %call7 = call i32 @SSL_in_before(ptr noundef %6)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false, %if.end
  %7 = load ptr, ptr %s.addr, align 8
  %references = getelementptr inbounds %struct.ssl_st, ptr %7, i32 0, i32 4
  %call10 = call i32 @CRYPTO_UP_REF(ptr noundef %references, ptr noundef %i)
  %8 = load ptr, ptr %s.addr, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %lor.lhs.false
  %9 = load ptr, ptr %s.addr, align 8
  %call12 = call ptr @SSL_get_SSL_CTX(ptr noundef %9)
  %call13 = call ptr @SSL_new(ptr noundef %call12)
  store ptr %call13, ptr %ret, align 8
  %cmp14 = icmp eq ptr %call13, null
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end11
  store ptr null, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.end11
  %10 = load ptr, ptr %ret, align 8
  %cmp17 = icmp eq ptr %10, null
  br i1 %cmp17, label %cond.true18, label %cond.false19

cond.true18:                                      ; preds = %if.end16
  br label %cond.end26

cond.false19:                                     ; preds = %if.end16
  %11 = load ptr, ptr %ret, align 8
  %type20 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type20, align 8
  %cmp21 = icmp eq i32 %12, 0
  br i1 %cmp21, label %cond.true22, label %cond.false23

cond.true22:                                      ; preds = %cond.false19
  %13 = load ptr, ptr %ret, align 8
  br label %cond.end24

cond.false23:                                     ; preds = %cond.false19
  br label %cond.end24

cond.end24:                                       ; preds = %cond.false23, %cond.true22
  %cond25 = phi ptr [ %13, %cond.true22 ], [ null, %cond.false23 ]
  br label %cond.end26

cond.end26:                                       ; preds = %cond.end24, %cond.true18
  %cond27 = phi ptr [ null, %cond.true18 ], [ %cond25, %cond.end24 ]
  store ptr %cond27, ptr %retsc, align 8
  %cmp28 = icmp eq ptr %cond27, null
  br i1 %cmp28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %cond.end26
  br label %err

if.end30:                                         ; preds = %cond.end26
  %14 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 50
  %15 = load ptr, ptr %session, align 8
  %cmp31 = icmp ne ptr %15, null
  br i1 %cmp31, label %if.then32, label %if.else

if.then32:                                        ; preds = %if.end30
  %16 = load ptr, ptr %ret, align 8
  %17 = load ptr, ptr %s.addr, align 8
  %call33 = call i32 @SSL_copy_session_id(ptr noundef %16, ptr noundef %17)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.then32
  br label %err

if.end36:                                         ; preds = %if.then32
  br label %if.end56

if.else:                                          ; preds = %if.end30
  %18 = load ptr, ptr %ret, align 8
  %19 = load ptr, ptr %s.addr, align 8
  %method = getelementptr inbounds %struct.ssl_st, ptr %19, i32 0, i32 3
  %20 = load ptr, ptr %method, align 8
  %call37 = call i32 @SSL_set_ssl_method(ptr noundef %18, ptr noundef %20)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.end40, label %if.then39

if.then39:                                        ; preds = %if.else
  br label %err

if.end40:                                         ; preds = %if.else
  %21 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 44
  %22 = load ptr, ptr %cert, align 8
  %cmp41 = icmp ne ptr %22, null
  br i1 %cmp41, label %if.then42, label %if.end51

if.then42:                                        ; preds = %if.end40
  %23 = load ptr, ptr %retsc, align 8
  %cert43 = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 44
  %24 = load ptr, ptr %cert43, align 8
  call void @ssl_cert_free(ptr noundef %24)
  %25 = load ptr, ptr %sc, align 8
  %cert44 = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 44
  %26 = load ptr, ptr %cert44, align 8
  %call45 = call ptr @ssl_cert_dup(ptr noundef %26)
  %27 = load ptr, ptr %retsc, align 8
  %cert46 = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 44
  store ptr %call45, ptr %cert46, align 8
  %28 = load ptr, ptr %retsc, align 8
  %cert47 = getelementptr inbounds %struct.ssl_connection_st, ptr %28, i32 0, i32 44
  %29 = load ptr, ptr %cert47, align 8
  %cmp48 = icmp eq ptr %29, null
  br i1 %cmp48, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.then42
  br label %err

if.end50:                                         ; preds = %if.then42
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.end40
  %30 = load ptr, ptr %ret, align 8
  %31 = load ptr, ptr %sc, align 8
  %sid_ctx = getelementptr inbounds %struct.ssl_connection_st, ptr %31, i32 0, i32 49
  %arraydecay = getelementptr inbounds [32 x i8], ptr %sid_ctx, i64 0, i64 0
  %32 = load ptr, ptr %sc, align 8
  %sid_ctx_length = getelementptr inbounds %struct.ssl_connection_st, ptr %32, i32 0, i32 48
  %33 = load i64, ptr %sid_ctx_length, align 8
  %conv = trunc i64 %33 to i32
  %call52 = call i32 @SSL_set_session_id_context(ptr noundef %30, ptr noundef %arraydecay, i32 noundef %conv)
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.end55, label %if.then54

if.then54:                                        ; preds = %if.end51
  br label %err

if.end55:                                         ; preds = %if.end51
  br label %if.end56

if.end56:                                         ; preds = %if.end55, %if.end36
  %34 = load ptr, ptr %retsc, align 8
  %35 = load ptr, ptr %sc, align 8
  %call57 = call i32 @ssl_dane_dup(ptr noundef %34, ptr noundef %35)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.end60, label %if.then59

if.then59:                                        ; preds = %if.end56
  br label %err

if.end60:                                         ; preds = %if.end56
  %36 = load ptr, ptr %sc, align 8
  %version = getelementptr inbounds %struct.ssl_connection_st, ptr %36, i32 0, i32 1
  %37 = load i32, ptr %version, align 8
  %38 = load ptr, ptr %retsc, align 8
  %version61 = getelementptr inbounds %struct.ssl_connection_st, ptr %38, i32 0, i32 1
  store i32 %37, ptr %version61, align 8
  %39 = load ptr, ptr %sc, align 8
  %options = getelementptr inbounds %struct.ssl_connection_st, ptr %39, i32 0, i32 70
  %40 = load i64, ptr %options, align 8
  %41 = load ptr, ptr %retsc, align 8
  %options62 = getelementptr inbounds %struct.ssl_connection_st, ptr %41, i32 0, i32 70
  store i64 %40, ptr %options62, align 8
  %42 = load ptr, ptr %sc, align 8
  %min_proto_version = getelementptr inbounds %struct.ssl_connection_st, ptr %42, i32 0, i32 72
  %43 = load i32, ptr %min_proto_version, align 4
  %44 = load ptr, ptr %retsc, align 8
  %min_proto_version63 = getelementptr inbounds %struct.ssl_connection_st, ptr %44, i32 0, i32 72
  store i32 %43, ptr %min_proto_version63, align 4
  %45 = load ptr, ptr %sc, align 8
  %max_proto_version = getelementptr inbounds %struct.ssl_connection_st, ptr %45, i32 0, i32 73
  %46 = load i32, ptr %max_proto_version, align 8
  %47 = load ptr, ptr %retsc, align 8
  %max_proto_version64 = getelementptr inbounds %struct.ssl_connection_st, ptr %47, i32 0, i32 73
  store i32 %46, ptr %max_proto_version64, align 8
  %48 = load ptr, ptr %sc, align 8
  %mode = getelementptr inbounds %struct.ssl_connection_st, ptr %48, i32 0, i32 71
  %49 = load i32, ptr %mode, align 8
  %50 = load ptr, ptr %retsc, align 8
  %mode65 = getelementptr inbounds %struct.ssl_connection_st, ptr %50, i32 0, i32 71
  store i32 %49, ptr %mode65, align 8
  %51 = load ptr, ptr %ret, align 8
  %52 = load ptr, ptr %s.addr, align 8
  %call66 = call i64 @SSL_ctrl(ptr noundef %52, i32 noundef 50, i64 noundef 0, ptr noundef null)
  %call67 = call i64 @SSL_ctrl(ptr noundef %51, i32 noundef 51, i64 noundef %call66, ptr noundef null)
  %53 = load ptr, ptr %ret, align 8
  %54 = load ptr, ptr %s.addr, align 8
  %call68 = call i32 @SSL_get_read_ahead(ptr noundef %54)
  call void @SSL_set_read_ahead(ptr noundef %53, i32 noundef %call68)
  %55 = load ptr, ptr %sc, align 8
  %msg_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %55, i32 0, i32 22
  %56 = load ptr, ptr %msg_callback, align 8
  %57 = load ptr, ptr %retsc, align 8
  %msg_callback69 = getelementptr inbounds %struct.ssl_connection_st, ptr %57, i32 0, i32 22
  store ptr %56, ptr %msg_callback69, align 8
  %58 = load ptr, ptr %sc, align 8
  %msg_callback_arg = getelementptr inbounds %struct.ssl_connection_st, ptr %58, i32 0, i32 23
  %59 = load ptr, ptr %msg_callback_arg, align 8
  %60 = load ptr, ptr %retsc, align 8
  %msg_callback_arg70 = getelementptr inbounds %struct.ssl_connection_st, ptr %60, i32 0, i32 23
  store ptr %59, ptr %msg_callback_arg70, align 8
  %61 = load ptr, ptr %ret, align 8
  %62 = load ptr, ptr %s.addr, align 8
  %call71 = call i32 @SSL_get_verify_mode(ptr noundef %62)
  %63 = load ptr, ptr %s.addr, align 8
  %call72 = call ptr @SSL_get_verify_callback(ptr noundef %63)
  call void @SSL_set_verify(ptr noundef %61, i32 noundef %call71, ptr noundef %call72)
  %64 = load ptr, ptr %ret, align 8
  %65 = load ptr, ptr %s.addr, align 8
  %call73 = call i32 @SSL_get_verify_depth(ptr noundef %65)
  call void @SSL_set_verify_depth(ptr noundef %64, i32 noundef %call73)
  %66 = load ptr, ptr %sc, align 8
  %generate_session_id = getelementptr inbounds %struct.ssl_connection_st, ptr %66, i32 0, i32 54
  %67 = load ptr, ptr %generate_session_id, align 8
  %68 = load ptr, ptr %retsc, align 8
  %generate_session_id74 = getelementptr inbounds %struct.ssl_connection_st, ptr %68, i32 0, i32 54
  store ptr %67, ptr %generate_session_id74, align 8
  %69 = load ptr, ptr %ret, align 8
  %70 = load ptr, ptr %s.addr, align 8
  %call75 = call ptr @SSL_get_info_callback(ptr noundef %70)
  call void @SSL_set_info_callback(ptr noundef %69, ptr noundef %call75)
  %71 = load ptr, ptr %ret, align 8
  %ex_data = getelementptr inbounds %struct.ssl_st, ptr %71, i32 0, i32 6
  %72 = load ptr, ptr %s.addr, align 8
  %ex_data76 = getelementptr inbounds %struct.ssl_st, ptr %72, i32 0, i32 6
  %call77 = call i32 @CRYPTO_dup_ex_data(i32 noundef 0, ptr noundef %ex_data, ptr noundef %ex_data76)
  %tobool78 = icmp ne i32 %call77, 0
  br i1 %tobool78, label %if.end80, label %if.then79

if.then79:                                        ; preds = %if.end60
  br label %err

if.end80:                                         ; preds = %if.end60
  %73 = load ptr, ptr %sc, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %73, i32 0, i32 7
  %74 = load i32, ptr %server, align 8
  %75 = load ptr, ptr %retsc, align 8
  %server81 = getelementptr inbounds %struct.ssl_connection_st, ptr %75, i32 0, i32 7
  store i32 %74, ptr %server81, align 8
  %76 = load ptr, ptr %sc, align 8
  %handshake_func = getelementptr inbounds %struct.ssl_connection_st, ptr %76, i32 0, i32 6
  %77 = load ptr, ptr %handshake_func, align 8
  %tobool82 = icmp ne ptr %77, null
  br i1 %tobool82, label %if.then83, label %if.end89

if.then83:                                        ; preds = %if.end80
  %78 = load ptr, ptr %sc, align 8
  %server84 = getelementptr inbounds %struct.ssl_connection_st, ptr %78, i32 0, i32 7
  %79 = load i32, ptr %server84, align 8
  %tobool85 = icmp ne i32 %79, 0
  br i1 %tobool85, label %if.then86, label %if.else87

if.then86:                                        ; preds = %if.then83
  %80 = load ptr, ptr %ret, align 8
  call void @SSL_set_accept_state(ptr noundef %80)
  br label %if.end88

if.else87:                                        ; preds = %if.then83
  %81 = load ptr, ptr %ret, align 8
  call void @SSL_set_connect_state(ptr noundef %81)
  br label %if.end88

if.end88:                                         ; preds = %if.else87, %if.then86
  br label %if.end89

if.end89:                                         ; preds = %if.end88, %if.end80
  %82 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %82, i32 0, i32 10
  %83 = load i32, ptr %shutdown, align 4
  %84 = load ptr, ptr %retsc, align 8
  %shutdown90 = getelementptr inbounds %struct.ssl_connection_st, ptr %84, i32 0, i32 10
  store i32 %83, ptr %shutdown90, align 4
  %85 = load ptr, ptr %sc, align 8
  %hit = getelementptr inbounds %struct.ssl_connection_st, ptr %85, i32 0, i32 24
  %86 = load i32, ptr %hit, align 8
  %87 = load ptr, ptr %retsc, align 8
  %hit91 = getelementptr inbounds %struct.ssl_connection_st, ptr %87, i32 0, i32 24
  store i32 %86, ptr %hit91, align 8
  %88 = load ptr, ptr %sc, align 8
  %default_passwd_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %88, i32 0, i32 101
  %89 = load ptr, ptr %default_passwd_callback, align 8
  %90 = load ptr, ptr %retsc, align 8
  %default_passwd_callback92 = getelementptr inbounds %struct.ssl_connection_st, ptr %90, i32 0, i32 101
  store ptr %89, ptr %default_passwd_callback92, align 8
  %91 = load ptr, ptr %sc, align 8
  %default_passwd_callback_userdata = getelementptr inbounds %struct.ssl_connection_st, ptr %91, i32 0, i32 102
  %92 = load ptr, ptr %default_passwd_callback_userdata, align 8
  %93 = load ptr, ptr %retsc, align 8
  %default_passwd_callback_userdata93 = getelementptr inbounds %struct.ssl_connection_st, ptr %93, i32 0, i32 102
  store ptr %92, ptr %default_passwd_callback_userdata93, align 8
  %94 = load ptr, ptr %retsc, align 8
  %param = getelementptr inbounds %struct.ssl_connection_st, ptr %94, i32 0, i32 25
  %95 = load ptr, ptr %param, align 8
  %96 = load ptr, ptr %sc, align 8
  %param94 = getelementptr inbounds %struct.ssl_connection_st, ptr %96, i32 0, i32 25
  %97 = load ptr, ptr %param94, align 8
  %call95 = call i32 @X509_VERIFY_PARAM_inherit(ptr noundef %95, ptr noundef %97)
  %98 = load ptr, ptr %sc, align 8
  %cipher_list = getelementptr inbounds %struct.ssl_connection_st, ptr %98, i32 0, i32 28
  %99 = load ptr, ptr %cipher_list, align 8
  %cmp96 = icmp ne ptr %99, null
  br i1 %cmp96, label %if.then98, label %if.end107

if.then98:                                        ; preds = %if.end89
  %100 = load ptr, ptr %sc, align 8
  %cipher_list99 = getelementptr inbounds %struct.ssl_connection_st, ptr %100, i32 0, i32 28
  %101 = load ptr, ptr %cipher_list99, align 8
  %call100 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %101)
  %call101 = call ptr @OPENSSL_sk_dup(ptr noundef %call100)
  %102 = load ptr, ptr %retsc, align 8
  %cipher_list102 = getelementptr inbounds %struct.ssl_connection_st, ptr %102, i32 0, i32 28
  store ptr %call101, ptr %cipher_list102, align 8
  %cmp103 = icmp eq ptr %call101, null
  br i1 %cmp103, label %if.then105, label %if.end106

if.then105:                                       ; preds = %if.then98
  br label %err

if.end106:                                        ; preds = %if.then98
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %if.end89
  %103 = load ptr, ptr %sc, align 8
  %cipher_list_by_id = getelementptr inbounds %struct.ssl_connection_st, ptr %103, i32 0, i32 29
  %104 = load ptr, ptr %cipher_list_by_id, align 8
  %cmp108 = icmp ne ptr %104, null
  br i1 %cmp108, label %if.then110, label %if.end119

if.then110:                                       ; preds = %if.end107
  %105 = load ptr, ptr %sc, align 8
  %cipher_list_by_id111 = getelementptr inbounds %struct.ssl_connection_st, ptr %105, i32 0, i32 29
  %106 = load ptr, ptr %cipher_list_by_id111, align 8
  %call112 = call ptr @ossl_check_const_SSL_CIPHER_sk_type(ptr noundef %106)
  %call113 = call ptr @OPENSSL_sk_dup(ptr noundef %call112)
  %107 = load ptr, ptr %retsc, align 8
  %cipher_list_by_id114 = getelementptr inbounds %struct.ssl_connection_st, ptr %107, i32 0, i32 29
  store ptr %call113, ptr %cipher_list_by_id114, align 8
  %cmp115 = icmp eq ptr %call113, null
  br i1 %cmp115, label %if.then117, label %if.end118

if.then117:                                       ; preds = %if.then110
  br label %err

if.end118:                                        ; preds = %if.then110
  br label %if.end119

if.end119:                                        ; preds = %if.end118, %if.end107
  %108 = load ptr, ptr %retsc, align 8
  %ca_names = getelementptr inbounds %struct.ssl_connection_st, ptr %108, i32 0, i32 68
  %109 = load ptr, ptr %sc, align 8
  %ca_names120 = getelementptr inbounds %struct.ssl_connection_st, ptr %109, i32 0, i32 68
  %110 = load ptr, ptr %ca_names120, align 8
  %call121 = call i32 @dup_ca_names(ptr noundef %ca_names, ptr noundef %110)
  %tobool122 = icmp ne i32 %call121, 0
  br i1 %tobool122, label %lor.lhs.false123, label %if.then127

lor.lhs.false123:                                 ; preds = %if.end119
  %111 = load ptr, ptr %retsc, align 8
  %client_ca_names = getelementptr inbounds %struct.ssl_connection_st, ptr %111, i32 0, i32 69
  %112 = load ptr, ptr %sc, align 8
  %client_ca_names124 = getelementptr inbounds %struct.ssl_connection_st, ptr %112, i32 0, i32 69
  %113 = load ptr, ptr %client_ca_names124, align 8
  %call125 = call i32 @dup_ca_names(ptr noundef %client_ca_names, ptr noundef %113)
  %tobool126 = icmp ne i32 %call125, 0
  br i1 %tobool126, label %if.end128, label %if.then127

if.then127:                                       ; preds = %lor.lhs.false123, %if.end119
  br label %err

if.end128:                                        ; preds = %lor.lhs.false123
  %114 = load ptr, ptr %ret, align 8
  store ptr %114, ptr %retval, align 8
  br label %return

err:                                              ; preds = %if.then127, %if.then117, %if.then105, %if.then79, %if.then59, %if.then54, %if.then49, %if.then39, %if.then35, %if.then29
  %115 = load ptr, ptr %ret, align 8
  call void @SSL_free(ptr noundef %115)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %err, %if.end128, %if.then15, %if.then9, %if.then
  %116 = load ptr, ptr %retval, align 8
  ret ptr %116
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_SSL_CTX(ptr noundef %ssl) #0 {
entry:
  %ssl.addr = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %ctx = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %ctx, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal i32 @ssl_dane_dup(ptr noundef %to, ptr noundef %from) #0 {
entry:
  %retval = alloca i32, align 4
  %to.addr = alloca ptr, align 8
  %from.addr = alloca ptr, align 8
  %num = alloca i32, align 4
  %i = alloca i32, align 4
  %t = alloca ptr, align 8
  store ptr %to, ptr %to.addr, align 8
  store ptr %from, ptr %from.addr, align 8
  %0 = load ptr, ptr %from.addr, align 8
  %dane = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 26
  %cmp = icmp ne ptr %dane, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %from.addr, align 8
  %dane1 = getelementptr inbounds %struct.ssl_connection_st, ptr %1, i32 0, i32 26
  %trecs = getelementptr inbounds %struct.ssl_dane_st, ptr %dane1, i32 0, i32 1
  %2 = load ptr, ptr %trecs, align 8
  %call = call i32 @sk_danetls_record_num(ptr noundef %2)
  %cmp2 = icmp sgt i32 %call, 0
  br i1 %cmp2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true
  %3 = load ptr, ptr %from.addr, align 8
  %dane3 = getelementptr inbounds %struct.ssl_connection_st, ptr %3, i32 0, i32 26
  %trecs4 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane3, i32 0, i32 1
  %4 = load ptr, ptr %trecs4, align 8
  %call5 = call i32 @sk_danetls_record_num(ptr noundef %4)
  store i32 %call5, ptr %num, align 4
  %5 = load ptr, ptr %to.addr, align 8
  %dane6 = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 26
  call void @dane_final(ptr noundef %dane6)
  %6 = load ptr, ptr %from.addr, align 8
  %dane7 = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 26
  %flags = getelementptr inbounds %struct.ssl_dane_st, ptr %dane7, i32 0, i32 8
  %7 = load i64, ptr %flags, align 8
  %8 = load ptr, ptr %to.addr, align 8
  %dane8 = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 26
  %flags9 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane8, i32 0, i32 8
  store i64 %7, ptr %flags9, align 8
  %9 = load ptr, ptr %to.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 0
  %ctx = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 1
  %10 = load ptr, ptr %ctx, align 8
  %dane10 = getelementptr inbounds %struct.ssl_ctx_st, ptr %10, i32 0, i32 67
  %11 = load ptr, ptr %to.addr, align 8
  %dane11 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 26
  %dctx = getelementptr inbounds %struct.ssl_dane_st, ptr %dane11, i32 0, i32 0
  store ptr %dane10, ptr %dctx, align 8
  %12 = load i32, ptr %num, align 4
  %call12 = call ptr @sk_danetls_record_new_reserve(ptr noundef null, i32 noundef %12)
  %13 = load ptr, ptr %to.addr, align 8
  %dane13 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 26
  %trecs14 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane13, i32 0, i32 1
  store ptr %call12, ptr %trecs14, align 8
  %14 = load ptr, ptr %to.addr, align 8
  %dane15 = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 26
  %trecs16 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane15, i32 0, i32 1
  %15 = load ptr, ptr %trecs16, align 8
  %cmp17 = icmp eq ptr %15, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 196, ptr noundef @__func__.ssl_dane_dup)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %16 = load i32, ptr %i, align 4
  %17 = load i32, ptr %num, align 4
  %cmp20 = icmp slt i32 %16, %17
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load ptr, ptr %from.addr, align 8
  %dane21 = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 26
  %trecs22 = getelementptr inbounds %struct.ssl_dane_st, ptr %dane21, i32 0, i32 1
  %19 = load ptr, ptr %trecs22, align 8
  %20 = load i32, ptr %i, align 4
  %call23 = call ptr @sk_danetls_record_value(ptr noundef %19, i32 noundef %20)
  store ptr %call23, ptr %t, align 8
  %21 = load ptr, ptr %to.addr, align 8
  %ssl24 = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 0
  %22 = load ptr, ptr %t, align 8
  %usage = getelementptr inbounds %struct.danetls_record_st, ptr %22, i32 0, i32 0
  %23 = load i8, ptr %usage, align 8
  %24 = load ptr, ptr %t, align 8
  %selector = getelementptr inbounds %struct.danetls_record_st, ptr %24, i32 0, i32 1
  %25 = load i8, ptr %selector, align 1
  %26 = load ptr, ptr %t, align 8
  %mtype = getelementptr inbounds %struct.danetls_record_st, ptr %26, i32 0, i32 2
  %27 = load i8, ptr %mtype, align 2
  %28 = load ptr, ptr %t, align 8
  %data = getelementptr inbounds %struct.danetls_record_st, ptr %28, i32 0, i32 3
  %29 = load ptr, ptr %data, align 8
  %30 = load ptr, ptr %t, align 8
  %dlen = getelementptr inbounds %struct.danetls_record_st, ptr %30, i32 0, i32 4
  %31 = load i64, ptr %dlen, align 8
  %call25 = call i32 @SSL_dane_tlsa_add(ptr noundef %ssl24, i8 noundef zeroext %23, i8 noundef zeroext %25, i8 noundef zeroext %27, ptr noundef %29, i64 noundef %31)
  %cmp26 = icmp sle i32 %call25, 0
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %for.body
  store i32 0, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end28
  %32 = load i32, ptr %i, align 4
  %inc = add nsw i32 %32, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !19

for.end:                                          ; preds = %for.cond
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then27, %if.then18, %if.then
  %33 = load i32, ptr %retval, align 4
  ret i32 %33
}

; Function Attrs: nounwind uwtable
define void @SSL_set_info_callback(ptr noundef %ssl, ptr noundef %cb) #0 {
entry:
  %ssl.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %cb.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %info_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 59
  store ptr %9, ptr %info_callback, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_info_callback(ptr noundef %ssl) #0 {
entry:
  %retval = alloca ptr, align 8
  %ssl.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %info_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 59
  %10 = load ptr, ptr %info_callback, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

declare i32 @CRYPTO_dup_ex_data(i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @dup_ca_names(ptr noundef %dst, ptr noundef %src) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %sk = alloca ptr, align 8
  %xn = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %dst, ptr %dst.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  %0 = load ptr, ptr %src.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %dst.addr, align 8
  store ptr null, ptr %1, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call = call ptr @OPENSSL_sk_new_null()
  store ptr %call, ptr %sk, align 8
  %cmp1 = icmp eq ptr %call, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %2 = load i32, ptr %i, align 4
  %3 = load ptr, ptr %src.addr, align 8
  %call4 = call ptr @ossl_check_const_X509_NAME_sk_type(ptr noundef %3)
  %call5 = call i32 @OPENSSL_sk_num(ptr noundef %call4)
  %cmp6 = icmp slt i32 %2, %call5
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %src.addr, align 8
  %call7 = call ptr @ossl_check_const_X509_NAME_sk_type(ptr noundef %4)
  %5 = load i32, ptr %i, align 4
  %call8 = call ptr @OPENSSL_sk_value(ptr noundef %call7, i32 noundef %5)
  %call9 = call ptr @X509_NAME_dup(ptr noundef %call8)
  store ptr %call9, ptr %xn, align 8
  %6 = load ptr, ptr %xn, align 8
  %cmp10 = icmp eq ptr %6, null
  br i1 %cmp10, label %if.then11, label %if.end14

if.then11:                                        ; preds = %for.body
  %7 = load ptr, ptr %sk, align 8
  %call12 = call ptr @ossl_check_X509_NAME_sk_type(ptr noundef %7)
  %call13 = call ptr @ossl_check_X509_NAME_freefunc_type(ptr noundef @X509_NAME_free)
  call void @OPENSSL_sk_pop_free(ptr noundef %call12, ptr noundef %call13)
  store i32 0, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %for.body
  %8 = load ptr, ptr %sk, align 8
  %call15 = call ptr @ossl_check_X509_NAME_sk_type(ptr noundef %8)
  %9 = load ptr, ptr %xn, align 8
  %call16 = call ptr @ossl_check_X509_NAME_type(ptr noundef %9)
  %10 = load i32, ptr %i, align 4
  %call17 = call i32 @OPENSSL_sk_insert(ptr noundef %call15, ptr noundef %call16, i32 noundef %10)
  %cmp18 = icmp eq i32 %call17, 0
  br i1 %cmp18, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.end14
  %11 = load ptr, ptr %xn, align 8
  call void @X509_NAME_free(ptr noundef %11)
  %12 = load ptr, ptr %sk, align 8
  %call20 = call ptr @ossl_check_X509_NAME_sk_type(ptr noundef %12)
  %call21 = call ptr @ossl_check_X509_NAME_freefunc_type(ptr noundef @X509_NAME_free)
  call void @OPENSSL_sk_pop_free(ptr noundef %call20, ptr noundef %call21)
  store i32 0, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end14
  br label %for.inc

for.inc:                                          ; preds = %if.end22
  %13 = load i32, ptr %i, align 4
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !20

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %sk, align 8
  %15 = load ptr, ptr %dst.addr, align 8
  store ptr %14, ptr %15, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then19, %if.then11, %if.then2, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_certificate(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 44
  %10 = load ptr, ptr %cert, align 8
  %cmp13 = icmp ne ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %cert15 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 44
  %12 = load ptr, ptr %cert15, align 8
  %key = getelementptr inbounds %struct.cert_st, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %key, align 8
  %x509 = getelementptr inbounds %struct.cert_pkey_st, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %x509, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then14, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_privatekey(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 44
  %10 = load ptr, ptr %cert, align 8
  %cmp13 = icmp ne ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %cert15 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 44
  %12 = load ptr, ptr %cert15, align 8
  %key = getelementptr inbounds %struct.cert_st, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %key, align 8
  %privatekey = getelementptr inbounds %struct.cert_pkey_st, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %privatekey, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then14, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get0_certificate(ptr noundef %ctx) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 39
  %1 = load ptr, ptr %cert, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %cert1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 39
  %3 = load ptr, ptr %cert1, align 8
  %key = getelementptr inbounds %struct.cert_st, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %key, align 8
  %x509 = getelementptr inbounds %struct.cert_pkey_st, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %x509, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get0_privatekey(ptr noundef %ctx) #0 {
entry:
  %retval = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 39
  %1 = load ptr, ptr %cert, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %cert1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 39
  %3 = load ptr, ptr %cert1, align 8
  %key = getelementptr inbounds %struct.cert_st, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %key, align 8
  %privatekey = getelementptr inbounds %struct.cert_pkey_st, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %privatekey, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %6 = load ptr, ptr %retval, align 8
  ret ptr %6
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_current_cipher(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 50
  %10 = load ptr, ptr %session, align 8
  %cmp13 = icmp ne ptr %10, null
  br i1 %cmp13, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %session14 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 50
  %12 = load ptr, ptr %session14, align 8
  %cipher = getelementptr inbounds %struct.ssl_session_st, ptr %12, i32 0, i32 20
  %13 = load ptr, ptr %cipher, align 8
  %cmp15 = icmp ne ptr %13, null
  br i1 %cmp15, label %if.then16, label %if.end19

if.then16:                                        ; preds = %land.lhs.true
  %14 = load ptr, ptr %sc, align 8
  %session17 = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 50
  %15 = load ptr, ptr %session17, align 8
  %cipher18 = getelementptr inbounds %struct.ssl_session_st, ptr %15, i32 0, i32 20
  %16 = load ptr, ptr %cipher18, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %land.lhs.true, %if.end
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then16, %if.then
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_pending_cipher(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 20
  %tmp = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 14
  %new_cipher = getelementptr inbounds %struct.anon.0, ptr %tmp, i32 0, i32 6
  %10 = load ptr, ptr %new_cipher, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_current_compression(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 100
  %wrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 4
  %6 = load ptr, ptr %wrlmethod, align 8
  %get_compression = getelementptr inbounds %struct.ossl_record_method_st, ptr %6, i32 0, i32 19
  %7 = load ptr, ptr %get_compression, align 8
  %8 = load ptr, ptr %sc, align 8
  %rlayer7 = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 100
  %wrl = getelementptr inbounds %struct.record_layer_st, ptr %rlayer7, i32 0, i32 6
  %9 = load ptr, ptr %wrl, align 8
  %call = call ptr %7(ptr noundef %9)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_current_expansion(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 100
  %rrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 3
  %6 = load ptr, ptr %rrlmethod, align 8
  %get_compression = getelementptr inbounds %struct.ossl_record_method_st, ptr %6, i32 0, i32 19
  %7 = load ptr, ptr %get_compression, align 8
  %8 = load ptr, ptr %sc, align 8
  %rlayer7 = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 100
  %rrl = getelementptr inbounds %struct.record_layer_st, ptr %rlayer7, i32 0, i32 5
  %9 = load ptr, ptr %rrl, align 8
  %call = call ptr %7(ptr noundef %9)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind uwtable
define i32 @ssl_init_wbio_buffer(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %bbio = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %bbio1 = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %bbio1, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call = call ptr @BIO_f_buffer()
  %call2 = call ptr @BIO_new(ptr noundef %call)
  store ptr %call2, ptr %bbio, align 8
  %2 = load ptr, ptr %bbio, align 8
  %cmp3 = icmp eq ptr %2, null
  br i1 %cmp3, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load ptr, ptr %bbio, align 8
  %call4 = call i64 @BIO_int_ctrl(ptr noundef %3, i32 noundef 117, i64 noundef 1, i32 noundef 0)
  %cmp5 = icmp sle i64 %call4, 0
  br i1 %cmp5, label %if.then6, label %if.end8

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  %4 = load ptr, ptr %bbio, align 8
  %call7 = call i32 @BIO_free(ptr noundef %4)
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 5123, ptr noundef @__func__.ssl_init_wbio_buffer)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524295, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %lor.lhs.false
  %5 = load ptr, ptr %bbio, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %bbio9 = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 4
  store ptr %5, ptr %bbio9, align 8
  %7 = load ptr, ptr %bbio, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %wbio = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 3
  %9 = load ptr, ptr %wbio, align 8
  %call10 = call ptr @BIO_push(ptr noundef %7, ptr noundef %9)
  %10 = load ptr, ptr %s.addr, align 8
  %wbio11 = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 3
  store ptr %call10, ptr %wbio11, align 8
  %11 = load ptr, ptr %s.addr, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 100
  %wrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 4
  %12 = load ptr, ptr %wrlmethod, align 8
  %set1_bio = getelementptr inbounds %struct.ossl_record_method_st, ptr %12, i32 0, i32 11
  %13 = load ptr, ptr %set1_bio, align 8
  %14 = load ptr, ptr %s.addr, align 8
  %rlayer12 = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 100
  %wrl = getelementptr inbounds %struct.record_layer_st, ptr %rlayer12, i32 0, i32 6
  %15 = load ptr, ptr %wrl, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %wbio13 = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 3
  %17 = load ptr, ptr %wbio13, align 8
  %call14 = call i32 %13(ptr noundef %15, ptr noundef %17)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then6, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

declare ptr @BIO_f_buffer() #1

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_quiet_shutdown(ptr noundef %ctx, i32 noundef %mode) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load i32, ptr %mode.addr, align 4
  %1 = load ptr, ptr %ctx.addr, align 8
  %quiet_shutdown = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 50
  store i32 %0, ptr %quiet_shutdown, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_get_quiet_shutdown(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %quiet_shutdown = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 50
  %1 = load i32, ptr %quiet_shutdown, align 8
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define void @SSL_set_quiet_shutdown(ptr noundef %s, i32 noundef %mode) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load i32, ptr %mode.addr, align 4
  %6 = load ptr, ptr %sc, align 8
  %quiet_shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 9
  store i32 %5, ptr %quiet_shutdown, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_quiet_shutdown(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %quiet_shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 9
  %6 = load i32, ptr %quiet_shutdown, align 8
  store i32 %6, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define void @SSL_set_shutdown(ptr noundef %s, i32 noundef %mode) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load i32, ptr %mode.addr, align 4
  %6 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 10
  store i32 %5, ptr %shutdown, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_shutdown(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %cmp6 = icmp ne ptr %4, null
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end4
  %5 = load ptr, ptr %s.addr, align 8
  %type7 = getelementptr inbounds %struct.ssl_st, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %type7, align 8
  %cmp8 = icmp eq i32 %6, 1
  br i1 %cmp8, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %7 = load ptr, ptr %s.addr, align 8
  %type9 = getelementptr inbounds %struct.ssl_st, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %type9, align 8
  %cmp10 = icmp eq i32 %8, 2
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %9 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_get_shutdown(ptr noundef %9)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end4
  %10 = load ptr, ptr %sc, align 8
  %cmp11 = icmp eq ptr %10, null
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %shutdown = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 10
  %12 = load i32, ptr %shutdown, align 4
  store i32 %12, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then12, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

declare i32 @ossl_quic_get_shutdown(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_client_version(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %type12 = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type12, align 8
  %cmp13 = icmp eq i32 %9, 1
  br i1 %cmp13, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %10 = load ptr, ptr %s.addr, align 8
  %type14 = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %type14, align 8
  %cmp15 = icmp eq i32 %11, 2
  br i1 %cmp15, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %12 = load ptr, ptr %sc, align 8
  %cmp16 = icmp eq ptr %12, null
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end
  %13 = load ptr, ptr %sc, align 8
  %client_version = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 76
  %14 = load i32, ptr %client_version, align 4
  store i32 %14, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then17, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define ptr @SSL_set_SSL_CTX(ptr noundef %ssl, ptr noundef %ctx) #0 {
entry:
  %retval = alloca ptr, align 8
  %ssl.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %new_cert = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %ssl.addr, align 8
  %ctx7 = getelementptr inbounds %struct.ssl_st, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %ctx7, align 8
  %7 = load ptr, ptr %ctx.addr, align 8
  %cmp8 = icmp eq ptr %6, %7
  br i1 %cmp8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end
  %8 = load ptr, ptr %ssl.addr, align 8
  %ctx10 = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %ctx10, align 8
  store ptr %9, ptr %retval, align 8
  br label %return

if.end11:                                         ; preds = %if.end
  %10 = load ptr, ptr %ctx.addr, align 8
  %cmp12 = icmp eq ptr %10, null
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  %11 = load ptr, ptr %sc, align 8
  %session_ctx = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 87
  %12 = load ptr, ptr %session_ctx, align 8
  store ptr %12, ptr %ctx.addr, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end11
  %13 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %13, i32 0, i32 39
  %14 = load ptr, ptr %cert, align 8
  %call = call ptr @ssl_cert_dup(ptr noundef %14)
  store ptr %call, ptr %new_cert, align 8
  %15 = load ptr, ptr %new_cert, align 8
  %cmp15 = icmp eq ptr %15, null
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end14
  store ptr null, ptr %retval, align 8
  br label %return

if.end17:                                         ; preds = %if.end14
  %16 = load ptr, ptr %new_cert, align 8
  %custext = getelementptr inbounds %struct.cert_st, ptr %16, i32 0, i32 17
  %17 = load ptr, ptr %sc, align 8
  %cert18 = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 44
  %18 = load ptr, ptr %cert18, align 8
  %custext19 = getelementptr inbounds %struct.cert_st, ptr %18, i32 0, i32 17
  %call20 = call i32 @custom_exts_copy_flags(ptr noundef %custext, ptr noundef %custext19)
  %tobool = icmp ne i32 %call20, 0
  br i1 %tobool, label %if.end22, label %if.then21

if.then21:                                        ; preds = %if.end17
  %19 = load ptr, ptr %new_cert, align 8
  call void @ssl_cert_free(ptr noundef %19)
  store ptr null, ptr %retval, align 8
  br label %return

if.end22:                                         ; preds = %if.end17
  %20 = load ptr, ptr %sc, align 8
  %cert23 = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 44
  %21 = load ptr, ptr %cert23, align 8
  call void @ssl_cert_free(ptr noundef %21)
  %22 = load ptr, ptr %new_cert, align 8
  %23 = load ptr, ptr %sc, align 8
  %cert24 = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 44
  store ptr %22, ptr %cert24, align 8
  %24 = load ptr, ptr %sc, align 8
  %sid_ctx_length = getelementptr inbounds %struct.ssl_connection_st, ptr %24, i32 0, i32 48
  %25 = load i64, ptr %sid_ctx_length, align 8
  %cmp25 = icmp ule i64 %25, 32
  %conv = zext i1 %cmp25 to i32
  %cmp26 = icmp ne i32 %conv, 0
  %lnot = xor i1 %cmp26, true
  %lnot28 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot28 to i32
  %conv29 = sext i32 %lnot.ext to i64
  %tobool30 = icmp ne i64 %conv29, 0
  br i1 %tobool30, label %if.end32, label %if.then31

if.then31:                                        ; preds = %if.end22
  store ptr null, ptr %retval, align 8
  br label %return

if.end32:                                         ; preds = %if.end22
  %26 = load ptr, ptr %ssl.addr, align 8
  %ctx33 = getelementptr inbounds %struct.ssl_st, ptr %26, i32 0, i32 1
  %27 = load ptr, ptr %ctx33, align 8
  %cmp34 = icmp ne ptr %27, null
  br i1 %cmp34, label %land.lhs.true, label %if.end54

land.lhs.true:                                    ; preds = %if.end32
  %28 = load ptr, ptr %sc, align 8
  %sid_ctx_length36 = getelementptr inbounds %struct.ssl_connection_st, ptr %28, i32 0, i32 48
  %29 = load i64, ptr %sid_ctx_length36, align 8
  %30 = load ptr, ptr %ssl.addr, align 8
  %ctx37 = getelementptr inbounds %struct.ssl_st, ptr %30, i32 0, i32 1
  %31 = load ptr, ptr %ctx37, align 8
  %sid_ctx_length38 = getelementptr inbounds %struct.ssl_ctx_st, ptr %31, i32 0, i32 45
  %32 = load i64, ptr %sid_ctx_length38, align 8
  %cmp39 = icmp eq i64 %29, %32
  br i1 %cmp39, label %land.lhs.true41, label %if.end54

land.lhs.true41:                                  ; preds = %land.lhs.true
  %33 = load ptr, ptr %sc, align 8
  %sid_ctx = getelementptr inbounds %struct.ssl_connection_st, ptr %33, i32 0, i32 49
  %arraydecay = getelementptr inbounds [32 x i8], ptr %sid_ctx, i64 0, i64 0
  %34 = load ptr, ptr %ssl.addr, align 8
  %ctx42 = getelementptr inbounds %struct.ssl_st, ptr %34, i32 0, i32 1
  %35 = load ptr, ptr %ctx42, align 8
  %sid_ctx43 = getelementptr inbounds %struct.ssl_ctx_st, ptr %35, i32 0, i32 46
  %arraydecay44 = getelementptr inbounds [32 x i8], ptr %sid_ctx43, i64 0, i64 0
  %36 = load ptr, ptr %sc, align 8
  %sid_ctx_length45 = getelementptr inbounds %struct.ssl_connection_st, ptr %36, i32 0, i32 48
  %37 = load i64, ptr %sid_ctx_length45, align 8
  %call46 = call i32 @memcmp(ptr noundef %arraydecay, ptr noundef %arraydecay44, i64 noundef %37) #6
  %cmp47 = icmp eq i32 %call46, 0
  br i1 %cmp47, label %if.then49, label %if.end54

if.then49:                                        ; preds = %land.lhs.true41
  %38 = load ptr, ptr %ctx.addr, align 8
  %sid_ctx_length50 = getelementptr inbounds %struct.ssl_ctx_st, ptr %38, i32 0, i32 45
  %39 = load i64, ptr %sid_ctx_length50, align 8
  %40 = load ptr, ptr %sc, align 8
  %sid_ctx_length51 = getelementptr inbounds %struct.ssl_connection_st, ptr %40, i32 0, i32 48
  store i64 %39, ptr %sid_ctx_length51, align 8
  %41 = load ptr, ptr %sc, align 8
  %sid_ctx52 = getelementptr inbounds %struct.ssl_connection_st, ptr %41, i32 0, i32 49
  %42 = load ptr, ptr %ctx.addr, align 8
  %sid_ctx53 = getelementptr inbounds %struct.ssl_ctx_st, ptr %42, i32 0, i32 46
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %sid_ctx52, ptr align 8 %sid_ctx53, i64 32, i1 false)
  br label %if.end54

if.end54:                                         ; preds = %if.then49, %land.lhs.true41, %land.lhs.true, %if.end32
  %43 = load ptr, ptr %ctx.addr, align 8
  %call55 = call i32 @SSL_CTX_up_ref(ptr noundef %43)
  %44 = load ptr, ptr %ssl.addr, align 8
  %ctx56 = getelementptr inbounds %struct.ssl_st, ptr %44, i32 0, i32 1
  %45 = load ptr, ptr %ctx56, align 8
  call void @SSL_CTX_free(ptr noundef %45)
  %46 = load ptr, ptr %ctx.addr, align 8
  %47 = load ptr, ptr %ssl.addr, align 8
  %ctx57 = getelementptr inbounds %struct.ssl_st, ptr %47, i32 0, i32 1
  store ptr %46, ptr %ctx57, align 8
  %48 = load ptr, ptr %ssl.addr, align 8
  %ctx58 = getelementptr inbounds %struct.ssl_st, ptr %48, i32 0, i32 1
  %49 = load ptr, ptr %ctx58, align 8
  store ptr %49, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end54, %if.then31, %if.then21, %if.then16, %if.then9, %if.then
  %50 = load ptr, ptr %retval, align 8
  ret ptr %50
}

declare i32 @custom_exts_copy_flags(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_default_verify_paths(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cert_store, align 8
  %2 = load ptr, ptr %ctx.addr, align 8
  %libctx = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %libctx, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %propq = getelementptr inbounds %struct.ssl_ctx_st, ptr %4, i32 0, i32 86
  %5 = load ptr, ptr %propq, align 8
  %call = call i32 @X509_STORE_set_default_paths_ex(ptr noundef %1, ptr noundef %3, ptr noundef %5)
  ret i32 %call
}

declare i32 @X509_STORE_set_default_paths_ex(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_default_verify_dir(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %lookup = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cert_store, align 8
  %call = call ptr @X509_LOOKUP_hash_dir()
  %call1 = call ptr @X509_STORE_add_lookup(ptr noundef %1, ptr noundef %call)
  store ptr %call1, ptr %lookup, align 8
  %2 = load ptr, ptr %lookup, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call i32 @ERR_set_mark()
  %3 = load ptr, ptr %lookup, align 8
  %call3 = call i32 @X509_LOOKUP_ctrl(ptr noundef %3, i32 noundef 2, ptr noundef null, i64 noundef 3, ptr noundef null)
  %call4 = call i32 @ERR_pop_to_mark()
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

declare ptr @X509_STORE_add_lookup(ptr noundef, ptr noundef) #1

declare ptr @X509_LOOKUP_hash_dir() #1

declare i32 @ERR_set_mark() #1

declare i32 @X509_LOOKUP_ctrl(ptr noundef, i32 noundef, ptr noundef, i64 noundef, ptr noundef) #1

declare i32 @ERR_pop_to_mark() #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_default_verify_file(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %lookup = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cert_store, align 8
  %call = call ptr @X509_LOOKUP_file()
  %call1 = call ptr @X509_STORE_add_lookup(ptr noundef %1, ptr noundef %call)
  store ptr %call1, ptr %lookup, align 8
  %2 = load ptr, ptr %lookup, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call i32 @ERR_set_mark()
  %3 = load ptr, ptr %lookup, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %libctx = getelementptr inbounds %struct.ssl_ctx_st, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %libctx, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %propq = getelementptr inbounds %struct.ssl_ctx_st, ptr %6, i32 0, i32 86
  %7 = load ptr, ptr %propq, align 8
  %call3 = call i32 @X509_LOOKUP_ctrl_ex(ptr noundef %3, i32 noundef 1, ptr noundef null, i64 noundef 3, ptr noundef null, ptr noundef %5, ptr noundef %7)
  %call4 = call i32 @ERR_pop_to_mark()
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

declare ptr @X509_LOOKUP_file() #1

declare i32 @X509_LOOKUP_ctrl_ex(ptr noundef, i32 noundef, ptr noundef, i64 noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_default_verify_store(ptr noundef %ctx) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %lookup = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cert_store, align 8
  %call = call ptr @X509_LOOKUP_store()
  %call1 = call ptr @X509_STORE_add_lookup(ptr noundef %1, ptr noundef %call)
  store ptr %call1, ptr %lookup, align 8
  %2 = load ptr, ptr %lookup, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call i32 @ERR_set_mark()
  %3 = load ptr, ptr %lookup, align 8
  %4 = load ptr, ptr %ctx.addr, align 8
  %libctx = getelementptr inbounds %struct.ssl_ctx_st, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %libctx, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %propq = getelementptr inbounds %struct.ssl_ctx_st, ptr %6, i32 0, i32 86
  %7 = load ptr, ptr %propq, align 8
  %call3 = call i32 @X509_LOOKUP_ctrl_ex(ptr noundef %3, i32 noundef 3, ptr noundef null, i64 noundef 0, ptr noundef null, ptr noundef %5, ptr noundef %7)
  %call4 = call i32 @ERR_pop_to_mark()
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

declare ptr @X509_LOOKUP_store() #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_load_verify_file(ptr noundef %ctx, ptr noundef %CAfile) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %CAfile.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %CAfile, ptr %CAfile.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cert_store, align 8
  %2 = load ptr, ptr %CAfile.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %libctx = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %libctx, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %propq = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 86
  %6 = load ptr, ptr %propq, align 8
  %call = call i32 @X509_STORE_load_file_ex(ptr noundef %1, ptr noundef %2, ptr noundef %4, ptr noundef %6)
  ret i32 %call
}

declare i32 @X509_STORE_load_file_ex(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_load_verify_dir(ptr noundef %ctx, ptr noundef %CApath) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %CApath.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %CApath, ptr %CApath.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cert_store, align 8
  %2 = load ptr, ptr %CApath.addr, align 8
  %call = call i32 @X509_STORE_load_path(ptr noundef %1, ptr noundef %2)
  ret i32 %call
}

declare i32 @X509_STORE_load_path(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_load_verify_store(ptr noundef %ctx, ptr noundef %CAstore) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %CAstore.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %CAstore, ptr %CAstore.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cert_store, align 8
  %2 = load ptr, ptr %CAstore.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %libctx = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %libctx, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %propq = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 86
  %6 = load ptr, ptr %propq, align 8
  %call = call i32 @X509_STORE_load_store_ex(ptr noundef %1, ptr noundef %2, ptr noundef %4, ptr noundef %6)
  ret i32 %call
}

declare i32 @X509_STORE_load_store_ex(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_load_verify_locations(ptr noundef %ctx, ptr noundef %CAfile, ptr noundef %CApath) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %CAfile.addr = alloca ptr, align 8
  %CApath.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %CAfile, ptr %CAfile.addr, align 8
  store ptr %CApath, ptr %CApath.addr, align 8
  %0 = load ptr, ptr %CAfile.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %CApath.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %CAfile.addr, align 8
  %cmp2 = icmp ne ptr %2, null
  br i1 %cmp2, label %land.lhs.true3, label %if.end5

land.lhs.true3:                                   ; preds = %if.end
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load ptr, ptr %CAfile.addr, align 8
  %call = call i32 @SSL_CTX_load_verify_file(ptr noundef %3, ptr noundef %4)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end5, label %if.then4

if.then4:                                         ; preds = %land.lhs.true3
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %land.lhs.true3, %if.end
  %5 = load ptr, ptr %CApath.addr, align 8
  %cmp6 = icmp ne ptr %5, null
  br i1 %cmp6, label %land.lhs.true7, label %if.end11

land.lhs.true7:                                   ; preds = %if.end5
  %6 = load ptr, ptr %ctx.addr, align 8
  %7 = load ptr, ptr %CApath.addr, align 8
  %call8 = call i32 @SSL_CTX_load_verify_dir(ptr noundef %6, ptr noundef %7)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %land.lhs.true7
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %land.lhs.true7, %if.end5
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.then10, %if.then4, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define void @SSL_set_verify_result(ptr noundef %ssl, i64 noundef %arg) #0 {
entry:
  %ssl.addr = alloca ptr, align 8
  %arg.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load i64, ptr %arg.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %verify_result = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 67
  store i64 %9, ptr %verify_result, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @SSL_get_verify_result(ptr noundef %ssl) #0 {
entry:
  %retval = alloca i64, align 8
  %ssl.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %verify_result = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 67
  %10 = load i64, ptr %verify_result, align 8
  store i64 %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i64, ptr %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind uwtable
define i64 @SSL_get_client_random(ptr noundef %ssl, ptr noundef %out, i64 noundef %outlen) #0 {
entry:
  %retval = alloca i64, align 8
  %ssl.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %outlen.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store i64 %outlen, ptr %outlen.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load i64, ptr %outlen.addr, align 8
  %cmp13 = icmp eq i64 %9, 0
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i64 32, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end
  %10 = load i64, ptr %outlen.addr, align 8
  %cmp16 = icmp ugt i64 %10, 32
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  store i64 32, ptr %outlen.addr, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end15
  %11 = load ptr, ptr %out.addr, align 8
  %12 = load ptr, ptr %sc, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 20
  %client_random = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 2
  %arraydecay = getelementptr inbounds [32 x i8], ptr %client_random, i64 0, i64 0
  %13 = load i64, ptr %outlen.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %11, ptr align 8 %arraydecay, i64 %13, i1 false)
  %14 = load i64, ptr %outlen.addr, align 8
  store i64 %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end18, %if.then14, %if.then
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define i64 @SSL_get_server_random(ptr noundef %ssl, ptr noundef %out, i64 noundef %outlen) #0 {
entry:
  %retval = alloca i64, align 8
  %ssl.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %outlen.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store i64 %outlen, ptr %outlen.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load i64, ptr %outlen.addr, align 8
  %cmp13 = icmp eq i64 %9, 0
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i64 32, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end
  %10 = load i64, ptr %outlen.addr, align 8
  %cmp16 = icmp ugt i64 %10, 32
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  store i64 32, ptr %outlen.addr, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.end15
  %11 = load ptr, ptr %out.addr, align 8
  %12 = load ptr, ptr %sc, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 20
  %server_random = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [32 x i8], ptr %server_random, i64 0, i64 0
  %13 = load i64, ptr %outlen.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %11, ptr align 8 %arraydecay, i64 %13, i1 false)
  %14 = load i64, ptr %outlen.addr, align 8
  store i64 %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end18, %if.then14, %if.then
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define i64 @SSL_SESSION_get_master_key(ptr noundef %session, ptr noundef %out, i64 noundef %outlen) #0 {
entry:
  %retval = alloca i64, align 8
  %session.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %outlen.addr = alloca i64, align 8
  store ptr %session, ptr %session.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store i64 %outlen, ptr %outlen.addr, align 8
  %0 = load i64, ptr %outlen.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %session.addr, align 8
  %master_key_length = getelementptr inbounds %struct.ssl_session_st, ptr %1, i32 0, i32 1
  %2 = load i64, ptr %master_key_length, align 8
  store i64 %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, ptr %outlen.addr, align 8
  %4 = load ptr, ptr %session.addr, align 8
  %master_key_length1 = getelementptr inbounds %struct.ssl_session_st, ptr %4, i32 0, i32 1
  %5 = load i64, ptr %master_key_length1, align 8
  %cmp2 = icmp ugt i64 %3, %5
  br i1 %cmp2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %session.addr, align 8
  %master_key_length4 = getelementptr inbounds %struct.ssl_session_st, ptr %6, i32 0, i32 1
  %7 = load i64, ptr %master_key_length4, align 8
  store i64 %7, ptr %outlen.addr, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %if.end
  %8 = load ptr, ptr %out.addr, align 8
  %9 = load ptr, ptr %session.addr, align 8
  %master_key = getelementptr inbounds %struct.ssl_session_st, ptr %9, i32 0, i32 3
  %arraydecay = getelementptr inbounds [512 x i8], ptr %master_key, i64 0, i64 0
  %10 = load i64, ptr %outlen.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %8, ptr align 8 %arraydecay, i64 %10, i1 false)
  %11 = load i64, ptr %outlen.addr, align 8
  store i64 %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end5, %if.then
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define i32 @SSL_SESSION_set1_master_key(ptr noundef %sess, ptr noundef %in, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %sess.addr = alloca ptr, align 8
  %in.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %sess, ptr %sess.addr, align 8
  store ptr %in, ptr %in.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %len.addr, align 8
  %cmp = icmp ugt i64 %0, 512
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %sess.addr, align 8
  %master_key = getelementptr inbounds %struct.ssl_session_st, ptr %1, i32 0, i32 3
  %arraydecay = getelementptr inbounds [512 x i8], ptr %master_key, i64 0, i64 0
  %2 = load ptr, ptr %in.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %arraydecay, ptr align 1 %2, i64 %3, i1 false)
  %4 = load i64, ptr %len.addr, align 8
  %5 = load ptr, ptr %sess.addr, align 8
  %master_key_length = getelementptr inbounds %struct.ssl_session_st, ptr %5, i32 0, i32 1
  store i64 %4, ptr %master_key_length, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_ex_data(ptr noundef %s, i32 noundef %idx, ptr noundef %arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %ex_data = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %idx.addr, align 4
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @CRYPTO_set_ex_data(ptr noundef %ex_data, i32 noundef %1, ptr noundef %2)
  ret i32 %call
}

declare i32 @CRYPTO_set_ex_data(ptr noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_get_ex_data(ptr noundef %s, i32 noundef %idx) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %ex_data = getelementptr inbounds %struct.ssl_st, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %idx.addr, align 4
  %call = call ptr @CRYPTO_get_ex_data(ptr noundef %ex_data, i32 noundef %1)
  ret ptr %call
}

declare ptr @CRYPTO_get_ex_data(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_ex_data(ptr noundef %s, i32 noundef %idx, ptr noundef %arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %ex_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 26
  %1 = load i32, ptr %idx.addr, align 4
  %2 = load ptr, ptr %arg.addr, align 8
  %call = call i32 @CRYPTO_set_ex_data(ptr noundef %ex_data, i32 noundef %1, ptr noundef %2)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get_ex_data(ptr noundef %s, i32 noundef %idx) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %ex_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 26
  %1 = load i32, ptr %idx.addr, align 4
  %call = call ptr @CRYPTO_get_ex_data(ptr noundef %ex_data, i32 noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get_cert_store(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cert_store, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_cert_store(ptr noundef %ctx, ptr noundef %store) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %store.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %store, ptr %store.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 5
  %1 = load ptr, ptr %cert_store, align 8
  call void @X509_STORE_free(ptr noundef %1)
  %2 = load ptr, ptr %store.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %cert_store1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 5
  store ptr %2, ptr %cert_store1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set1_cert_store(ptr noundef %ctx, ptr noundef %store) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %store.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %store, ptr %store.addr, align 8
  %0 = load ptr, ptr %store.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %store.addr, align 8
  %call = call i32 @X509_STORE_up_ref(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %3 = load ptr, ptr %store.addr, align 8
  call void @SSL_CTX_set_cert_store(ptr noundef %2, ptr noundef %3)
  ret void
}

declare i32 @X509_STORE_up_ref(ptr noundef) #1

declare i32 @ossl_quic_want(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_use_psk_identity_hint(ptr noundef %ctx, ptr noundef %identity_hint) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %identity_hint.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %identity_hint, ptr %identity_hint.addr, align 8
  %0 = load ptr, ptr %identity_hint.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %identity_hint.addr, align 8
  %call = call i64 @strlen(ptr noundef %1) #6
  %cmp1 = icmp ugt i64 %call, 256
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 5542, ptr noundef @__func__.SSL_CTX_use_psk_identity_hint)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 146, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 39
  %3 = load ptr, ptr %cert, align 8
  %psk_identity_hint = getelementptr inbounds %struct.cert_st, ptr %3, i32 0, i32 21
  %4 = load ptr, ptr %psk_identity_hint, align 8
  call void @CRYPTO_free(ptr noundef %4, ptr noundef @.str, i32 noundef 5545)
  %5 = load ptr, ptr %identity_hint.addr, align 8
  %cmp2 = icmp ne ptr %5, null
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %identity_hint.addr, align 8
  %call4 = call noalias ptr @CRYPTO_strdup(ptr noundef %6, ptr noundef @.str, i32 noundef 5547)
  %7 = load ptr, ptr %ctx.addr, align 8
  %cert5 = getelementptr inbounds %struct.ssl_ctx_st, ptr %7, i32 0, i32 39
  %8 = load ptr, ptr %cert5, align 8
  %psk_identity_hint6 = getelementptr inbounds %struct.cert_st, ptr %8, i32 0, i32 21
  store ptr %call4, ptr %psk_identity_hint6, align 8
  %9 = load ptr, ptr %ctx.addr, align 8
  %cert7 = getelementptr inbounds %struct.ssl_ctx_st, ptr %9, i32 0, i32 39
  %10 = load ptr, ptr %cert7, align 8
  %psk_identity_hint8 = getelementptr inbounds %struct.cert_st, ptr %10, i32 0, i32 21
  %11 = load ptr, ptr %psk_identity_hint8, align 8
  %cmp9 = icmp eq ptr %11, null
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.then3
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.then3
  br label %if.end14

if.else:                                          ; preds = %if.end
  %12 = load ptr, ptr %ctx.addr, align 8
  %cert12 = getelementptr inbounds %struct.ssl_ctx_st, ptr %12, i32 0, i32 39
  %13 = load ptr, ptr %cert12, align 8
  %psk_identity_hint13 = getelementptr inbounds %struct.cert_st, ptr %13, i32 0, i32 21
  store ptr null, ptr %psk_identity_hint13, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.else, %if.end11
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then10, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #4

; Function Attrs: nounwind uwtable
define i32 @SSL_use_psk_identity_hint(ptr noundef %s, ptr noundef %identity_hint) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %identity_hint.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %identity_hint, ptr %identity_hint.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %identity_hint.addr, align 8
  %cmp13 = icmp ne ptr %9, null
  br i1 %cmp13, label %land.lhs.true, label %if.end16

land.lhs.true:                                    ; preds = %if.end
  %10 = load ptr, ptr %identity_hint.addr, align 8
  %call = call i64 @strlen(ptr noundef %10) #6
  %cmp14 = icmp ugt i64 %call, 256
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %land.lhs.true
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 5563, ptr noundef @__func__.SSL_use_psk_identity_hint)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 146, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %if.end
  %11 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 44
  %12 = load ptr, ptr %cert, align 8
  %psk_identity_hint = getelementptr inbounds %struct.cert_st, ptr %12, i32 0, i32 21
  %13 = load ptr, ptr %psk_identity_hint, align 8
  call void @CRYPTO_free(ptr noundef %13, ptr noundef @.str, i32 noundef 5566)
  %14 = load ptr, ptr %identity_hint.addr, align 8
  %cmp17 = icmp ne ptr %14, null
  br i1 %cmp17, label %if.then18, label %if.else

if.then18:                                        ; preds = %if.end16
  %15 = load ptr, ptr %identity_hint.addr, align 8
  %call19 = call noalias ptr @CRYPTO_strdup(ptr noundef %15, ptr noundef @.str, i32 noundef 5568)
  %16 = load ptr, ptr %sc, align 8
  %cert20 = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 44
  %17 = load ptr, ptr %cert20, align 8
  %psk_identity_hint21 = getelementptr inbounds %struct.cert_st, ptr %17, i32 0, i32 21
  store ptr %call19, ptr %psk_identity_hint21, align 8
  %18 = load ptr, ptr %sc, align 8
  %cert22 = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 44
  %19 = load ptr, ptr %cert22, align 8
  %psk_identity_hint23 = getelementptr inbounds %struct.cert_st, ptr %19, i32 0, i32 21
  %20 = load ptr, ptr %psk_identity_hint23, align 8
  %cmp24 = icmp eq ptr %20, null
  br i1 %cmp24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.then18
  store i32 0, ptr %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.then18
  br label %if.end29

if.else:                                          ; preds = %if.end16
  %21 = load ptr, ptr %sc, align 8
  %cert27 = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 44
  %22 = load ptr, ptr %cert27, align 8
  %psk_identity_hint28 = getelementptr inbounds %struct.cert_st, ptr %22, i32 0, i32 21
  store ptr null, ptr %psk_identity_hint28, align 8
  br label %if.end29

if.end29:                                         ; preds = %if.else, %if.end26
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end29, %if.then25, %if.then15, %if.then
  %23 = load i32, ptr %retval, align 4
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_psk_identity_hint(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 50
  %10 = load ptr, ptr %session, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %11 = load ptr, ptr %sc, align 8
  %session14 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 50
  %12 = load ptr, ptr %session14, align 8
  %psk_identity_hint = getelementptr inbounds %struct.ssl_session_st, ptr %12, i32 0, i32 8
  %13 = load ptr, ptr %psk_identity_hint, align 8
  store ptr %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_psk_identity(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 50
  %10 = load ptr, ptr %session, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %11 = load ptr, ptr %sc, align 8
  %session14 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 50
  %12 = load ptr, ptr %session14, align 8
  %psk_identity = getelementptr inbounds %struct.ssl_session_st, ptr %12, i32 0, i32 9
  %13 = load ptr, ptr %psk_identity, align 8
  store ptr %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define void @SSL_set_psk_client_callback(ptr noundef %s, ptr noundef %cb) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %cb.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %psk_client_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 62
  store ptr %9, ptr %psk_client_callback, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_psk_client_callback(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %psk_client_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 62
  store ptr %0, ptr %psk_client_callback, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_set_psk_server_callback(ptr noundef %s, ptr noundef %cb) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %cb.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %psk_server_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 63
  store ptr %9, ptr %psk_server_callback, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_psk_server_callback(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %psk_server_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 63
  store ptr %0, ptr %psk_server_callback, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_set_psk_find_session_callback(ptr noundef %s, ptr noundef %cb) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %cb.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %psk_find_session_cb = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 64
  store ptr %9, ptr %psk_find_session_cb, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_psk_find_session_callback(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %psk_find_session_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 64
  store ptr %0, ptr %psk_find_session_cb, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_set_psk_use_session_callback(ptr noundef %s, ptr noundef %cb) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %cb.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %psk_use_session_cb = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 65
  store ptr %9, ptr %psk_use_session_cb, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_psk_use_session_callback(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %psk_use_session_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 65
  store ptr %0, ptr %psk_use_session_cb, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_msg_callback(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %cb.addr, align 8
  %call = call i64 @SSL_CTX_callback_ctrl(ptr noundef %0, i32 noundef 15, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_set_msg_callback(ptr noundef %ssl, ptr noundef %cb) #0 {
entry:
  %ssl.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %1 = load ptr, ptr %cb.addr, align 8
  %call = call i64 @SSL_callback_ctrl(ptr noundef %0, i32 noundef 15, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_not_resumable_session_callback(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %cb.addr, align 8
  %call = call i64 @SSL_CTX_callback_ctrl(ptr noundef %0, i32 noundef 79, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_set_not_resumable_session_callback(ptr noundef %ssl, ptr noundef %cb) #0 {
entry:
  %ssl.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %1 = load ptr, ptr %cb.addr, align 8
  %call = call i64 @SSL_callback_ctrl(ptr noundef %0, i32 noundef 79, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_record_padding_callback(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %record_padding_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 74
  store ptr %0, ptr %record_padding_cb, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_record_padding_callback_arg(ptr noundef %ctx, ptr noundef %arg) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %record_padding_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 75
  store ptr %0, ptr %record_padding_arg, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get_record_padding_callback_arg(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %record_padding_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 75
  %1 = load ptr, ptr %record_padding_arg, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_block_padding(ptr noundef %ctx, i64 noundef %block_size) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %block_size.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %method = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %method, align 8
  %call = call ptr @OSSL_QUIC_client_method()
  %cmp = icmp eq ptr %1, %call
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %method1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %method1, align 8
  %call2 = call ptr @OSSL_QUIC_client_thread_method()
  %cmp3 = icmp eq ptr %3, %call2
  br i1 %cmp3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %4 = load i64, ptr %block_size.addr, align 8
  %cmp4 = icmp ugt i64 %4, 1
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load i64, ptr %block_size.addr, align 8
  %cmp5 = icmp eq i64 %5, 1
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end
  %6 = load ptr, ptr %ctx.addr, align 8
  %block_padding = getelementptr inbounds %struct.ssl_ctx_st, ptr %6, i32 0, i32 76
  store i64 0, ptr %block_padding, align 8
  br label %if.end12

if.else:                                          ; preds = %if.end
  %7 = load i64, ptr %block_size.addr, align 8
  %cmp7 = icmp ule i64 %7, 16384
  br i1 %cmp7, label %if.then8, label %if.else10

if.then8:                                         ; preds = %if.else
  %8 = load i64, ptr %block_size.addr, align 8
  %9 = load ptr, ptr %ctx.addr, align 8
  %block_padding9 = getelementptr inbounds %struct.ssl_ctx_st, ptr %9, i32 0, i32 76
  store i64 %8, ptr %block_padding9, align 8
  br label %if.end11

if.else10:                                        ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.then8
  br label %if.end12

if.end12:                                         ; preds = %if.end11, %if.then6
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.else10, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_record_padding_callback(ptr noundef %ssl, ptr noundef %cb) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %b = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %ssl.addr, align 8
  %call = call ptr @SSL_get_wbio(ptr noundef %5)
  store ptr %call, ptr %b, align 8
  %6 = load ptr, ptr %b, align 8
  %cmp7 = icmp eq ptr %6, null
  br i1 %cmp7, label %if.then8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  br i1 false, label %if.end9, label %if.then8

if.then8:                                         ; preds = %lor.lhs.false, %if.end
  %7 = load ptr, ptr %cb.addr, align 8
  %8 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 100
  %record_padding_cb = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 19
  store ptr %7, ptr %record_padding_cb, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %lor.lhs.false
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end9, %if.then8, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define void @SSL_set_record_padding_callback_arg(ptr noundef %ssl, ptr noundef %arg) #0 {
entry:
  %ssl.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %arg.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 100
  %record_padding_arg = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 20
  store ptr %9, ptr %record_padding_arg, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_record_padding_callback_arg(ptr noundef %ssl) #0 {
entry:
  %retval = alloca ptr, align 8
  %ssl.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 100
  %record_padding_arg = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 20
  %10 = load ptr, ptr %record_padding_arg, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_block_padding(ptr noundef %ssl, i64 noundef %block_size) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %block_size.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store i64 %block_size, ptr %block_size.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %ssl.addr, align 8
  %cmp13 = icmp ne ptr %9, null
  br i1 %cmp13, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %10 = load ptr, ptr %ssl.addr, align 8
  %type14 = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %type14, align 8
  %cmp15 = icmp eq i32 %11, 1
  br i1 %cmp15, label %land.lhs.true19, label %lor.lhs.false16

lor.lhs.false16:                                  ; preds = %land.lhs.true
  %12 = load ptr, ptr %ssl.addr, align 8
  %type17 = getelementptr inbounds %struct.ssl_st, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %type17, align 8
  %cmp18 = icmp eq i32 %13, 2
  br i1 %cmp18, label %land.lhs.true19, label %if.end

land.lhs.true19:                                  ; preds = %lor.lhs.false16, %land.lhs.true
  %14 = load i64, ptr %block_size.addr, align 8
  %cmp20 = icmp ugt i64 %14, 1
  br i1 %cmp20, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true19, %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true19, %lor.lhs.false16, %lor.lhs.false
  %15 = load i64, ptr %block_size.addr, align 8
  %cmp21 = icmp eq i64 %15, 1
  br i1 %cmp21, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end
  %16 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 100
  %block_padding = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 21
  store i64 0, ptr %block_padding, align 8
  br label %if.end29

if.else:                                          ; preds = %if.end
  %17 = load i64, ptr %block_size.addr, align 8
  %cmp23 = icmp ule i64 %17, 16384
  br i1 %cmp23, label %if.then24, label %if.else27

if.then24:                                        ; preds = %if.else
  %18 = load i64, ptr %block_size.addr, align 8
  %19 = load ptr, ptr %sc, align 8
  %rlayer25 = getelementptr inbounds %struct.ssl_connection_st, ptr %19, i32 0, i32 100
  %block_padding26 = getelementptr inbounds %struct.record_layer_st, ptr %rlayer25, i32 0, i32 21
  store i64 %18, ptr %block_padding26, align 8
  br label %if.end28

if.else27:                                        ; preds = %if.else
  store i32 0, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.then24
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then22
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end29, %if.else27, %if.then
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_num_tickets(ptr noundef %s, i64 noundef %num_tickets) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %num_tickets.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %num_tickets, ptr %num_tickets.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load i64, ptr %num_tickets.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %num_tickets13 = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 109
  store i64 %9, ptr %num_tickets13, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i64 @SSL_get_num_tickets(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %num_tickets = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 109
  %10 = load i64, ptr %num_tickets, align 8
  store i64 %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i64, ptr %retval, align 8
  ret i64 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_num_tickets(ptr noundef %ctx, i64 noundef %num_tickets) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %num_tickets.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %num_tickets, ptr %num_tickets.addr, align 8
  %0 = load i64, ptr %num_tickets.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %num_tickets1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 80
  store i64 %0, ptr %num_tickets1, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i64 @SSL_CTX_get_num_tickets(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %num_tickets = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 80
  %1 = load i64, ptr %num_tickets, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i32 @ssl_handshake_hash(ptr noundef %s, ptr noundef %out, i64 noundef %outlen, ptr noundef %hashlen) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %outlen.addr = alloca i64, align 8
  %hashlen.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %hdgst = alloca ptr, align 8
  %hashleni = alloca i32, align 4
  %ret = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store i64 %outlen, ptr %outlen.addr, align 8
  store ptr %hashlen, ptr %hashlen.addr, align 8
  store ptr null, ptr %ctx, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 20
  %handshake_dgst = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 4
  %1 = load ptr, ptr %handshake_dgst, align 8
  store ptr %1, ptr %hdgst, align 8
  %2 = load ptr, ptr %hdgst, align 8
  %call = call ptr @EVP_MD_CTX_get0_md(ptr noundef %2)
  %call1 = call i32 @EVP_MD_get_size(ptr noundef %call)
  store i32 %call1, ptr %hashleni, align 4
  store i32 0, ptr %ret, align 4
  %3 = load i32, ptr %hashleni, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i32, ptr %hashleni, align 4
  %conv = sext i32 %4 to i64
  %5 = load i64, ptr %outlen.addr, align 8
  %cmp2 = icmp ugt i64 %conv, %5
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 5824, ptr noundef @__func__.ssl_handshake_hash)
  %6 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %6, i32 noundef 80, i32 noundef 786691, ptr noundef null)
  br label %err

if.end:                                           ; preds = %lor.lhs.false
  %call4 = call ptr @EVP_MD_CTX_new()
  store ptr %call4, ptr %ctx, align 8
  %7 = load ptr, ptr %ctx, align 8
  %cmp5 = icmp eq ptr %7, null
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 5830, ptr noundef @__func__.ssl_handshake_hash)
  %8 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %8, i32 noundef 80, i32 noundef 786691, ptr noundef null)
  br label %err

if.end8:                                          ; preds = %if.end
  %9 = load ptr, ptr %ctx, align 8
  %10 = load ptr, ptr %hdgst, align 8
  %call9 = call i32 @EVP_MD_CTX_copy_ex(ptr noundef %9, ptr noundef %10)
  %tobool = icmp ne i32 %call9, 0
  br i1 %tobool, label %lor.lhs.false10, label %if.then14

lor.lhs.false10:                                  ; preds = %if.end8
  %11 = load ptr, ptr %ctx, align 8
  %12 = load ptr, ptr %out.addr, align 8
  %call11 = call i32 @EVP_DigestFinal_ex(ptr noundef %11, ptr noundef %12, ptr noundef null)
  %cmp12 = icmp sle i32 %call11, 0
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %lor.lhs.false10, %if.end8
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 5836, ptr noundef @__func__.ssl_handshake_hash)
  %13 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %13, i32 noundef 80, i32 noundef 786691, ptr noundef null)
  br label %err

if.end15:                                         ; preds = %lor.lhs.false10
  %14 = load i32, ptr %hashleni, align 4
  %conv16 = sext i32 %14 to i64
  %15 = load ptr, ptr %hashlen.addr, align 8
  store i64 %conv16, ptr %15, align 8
  store i32 1, ptr %ret, align 4
  br label %err

err:                                              ; preds = %if.end15, %if.then14, %if.then7, %if.then
  %16 = load ptr, ptr %ctx, align 8
  call void @EVP_MD_CTX_free(ptr noundef %16)
  %17 = load i32, ptr %ret, align 4
  ret i32 %17
}

declare i32 @EVP_MD_get_size(ptr noundef) #1

declare ptr @EVP_MD_CTX_get0_md(ptr noundef) #1

declare void @ossl_statem_fatal(ptr noundef, i32 noundef, i32 noundef, ptr noundef, ...) #1

declare ptr @EVP_MD_CTX_new() #1

declare i32 @EVP_MD_CTX_copy_ex(ptr noundef, ptr noundef) #1

declare i32 @EVP_DigestFinal_ex(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_session_reused(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %hit = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 24
  %10 = load i32, ptr %hit, align 8
  store i32 %10, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_is_server(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 7
  %10 = load i32, ptr %server, align 8
  store i32 %10, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define void @SSL_set_debug(ptr noundef %s, i32 noundef %debug) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %debug.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %debug, ptr %debug.addr, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_set_security_level(ptr noundef %s, i32 noundef %level) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %level.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %level, ptr %level.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load i32, ptr %level.addr, align 4
  %10 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 44
  %11 = load ptr, ptr %cert, align 8
  %sec_level = getelementptr inbounds %struct.cert_st, ptr %11, i32 0, i32 19
  store i32 %9, ptr %sec_level, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_security_level(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 44
  %10 = load ptr, ptr %cert, align 8
  %sec_level = getelementptr inbounds %struct.cert_st, ptr %10, i32 0, i32 19
  %11 = load i32, ptr %sec_level, align 8
  store i32 %11, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define void @SSL_set_security_callback(ptr noundef %s, ptr noundef %cb) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %cb.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 44
  %11 = load ptr, ptr %cert, align 8
  %sec_cb = getelementptr inbounds %struct.cert_st, ptr %11, i32 0, i32 18
  store ptr %9, ptr %sec_cb, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get_security_callback(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 44
  %10 = load ptr, ptr %cert, align 8
  %sec_cb = getelementptr inbounds %struct.cert_st, ptr %10, i32 0, i32 18
  %11 = load ptr, ptr %sec_cb, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define void @SSL_set0_security_ex_data(ptr noundef %s, ptr noundef %ex) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ex.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %ex, ptr %ex.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %ex.addr, align 8
  %10 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 44
  %11 = load ptr, ptr %cert, align 8
  %sec_ex = getelementptr inbounds %struct.cert_st, ptr %11, i32 0, i32 20
  store ptr %9, ptr %sec_ex, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get0_security_ex_data(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 44
  %10 = load ptr, ptr %cert, align 8
  %sec_ex = getelementptr inbounds %struct.cert_st, ptr %10, i32 0, i32 20
  %11 = load ptr, ptr %sec_ex, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_security_level(ptr noundef %ctx, i32 noundef %level) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %level.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %level, ptr %level.addr, align 4
  %0 = load i32, ptr %level.addr, align 4
  %1 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %cert, align 8
  %sec_level = getelementptr inbounds %struct.cert_st, ptr %2, i32 0, i32 19
  store i32 %0, ptr %sec_level, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_get_security_level(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 39
  %1 = load ptr, ptr %cert, align 8
  %sec_level = getelementptr inbounds %struct.cert_st, ptr %1, i32 0, i32 19
  %2 = load i32, ptr %sec_level, align 8
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_security_callback(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %cert, align 8
  %sec_cb = getelementptr inbounds %struct.cert_st, ptr %2, i32 0, i32 18
  store ptr %0, ptr %sec_cb, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get_security_callback(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 39
  %1 = load ptr, ptr %cert, align 8
  %sec_cb = getelementptr inbounds %struct.cert_st, ptr %1, i32 0, i32 18
  %2 = load ptr, ptr %sec_cb, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set0_security_ex_data(ptr noundef %ctx, ptr noundef %ex) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %ex.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ex, ptr %ex.addr, align 8
  %0 = load ptr, ptr %ex.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 39
  %2 = load ptr, ptr %cert, align 8
  %sec_ex = getelementptr inbounds %struct.cert_st, ptr %2, i32 0, i32 20
  store ptr %0, ptr %sec_ex, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get0_security_ex_data(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 39
  %1 = load ptr, ptr %cert, align 8
  %sec_ex = getelementptr inbounds %struct.cert_st, ptr %1, i32 0, i32 20
  %2 = load ptr, ptr %sec_ex, align 8
  ret ptr %2
}

; Function Attrs: nounwind uwtable
define i64 @SSL_CTX_get_options(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %options = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 34
  %1 = load i64, ptr %options, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i64 @SSL_get_options(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %call = call i64 @ossl_quic_get_options(ptr noundef %13)
  store i64 %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %14 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %14, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i64 0, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.end
  %15 = load ptr, ptr %sc, align 8
  %options = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 70
  %16 = load i64, ptr %options, align 8
  store i64 %16, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then
  %17 = load i64, ptr %retval, align 8
  ret i64 %17
}

declare i64 @ossl_quic_get_options(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i64 @SSL_CTX_set_options(ptr noundef %ctx, i64 noundef %op) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %op.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %op, ptr %op.addr, align 8
  %0 = load i64, ptr %op.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %options = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 34
  %2 = load i64, ptr %options, align 8
  %or = or i64 %2, %0
  store i64 %or, ptr %options, align 8
  ret i64 %or
}

; Function Attrs: nounwind uwtable
define i64 @SSL_set_options(ptr noundef %s, i64 noundef %op) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %op.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  %options = alloca [2 x %struct.ossl_param_st], align 16
  %opts = alloca ptr, align 8
  %tmp = alloca %struct.ossl_param_st, align 8
  %tmp22 = alloca %struct.ossl_param_st, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %op, ptr %op.addr, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.ossl_param_st], ptr %options, i64 0, i64 0
  store ptr %arraydecay, ptr %opts, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i64, ptr %op.addr, align 8
  %call = call i64 @ossl_quic_set_options(ptr noundef %5, i64 noundef %6)
  store i64 %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %7 = load ptr, ptr %s.addr, align 8
  %cmp4 = icmp eq ptr %7, null
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end15

cond.false:                                       ; preds = %if.end
  %8 = load ptr, ptr %s.addr, align 8
  %type5 = getelementptr inbounds %struct.ssl_st, ptr %8, i32 0, i32 0
  %9 = load i32, ptr %type5, align 8
  %cmp6 = icmp eq i32 %9, 0
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.false
  %10 = load ptr, ptr %s.addr, align 8
  br label %cond.end13

cond.false8:                                      ; preds = %cond.false
  %11 = load ptr, ptr %s.addr, align 8
  %type9 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type9, align 8
  %cmp10 = icmp eq i32 %12, 1
  br i1 %cmp10, label %cond.true11, label %cond.false12

cond.true11:                                      ; preds = %cond.false8
  %13 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false12:                                     ; preds = %cond.false8
  br label %cond.end

cond.end:                                         ; preds = %cond.false12, %cond.true11
  %cond = phi ptr [ %14, %cond.true11 ], [ null, %cond.false12 ]
  br label %cond.end13

cond.end13:                                       ; preds = %cond.end, %cond.true7
  %cond14 = phi ptr [ %10, %cond.true7 ], [ %cond, %cond.end ]
  br label %cond.end15

cond.end15:                                       ; preds = %cond.end13, %cond.true
  %cond16 = phi ptr [ null, %cond.true ], [ %cond14, %cond.end13 ]
  store ptr %cond16, ptr %sc, align 8
  %15 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %15, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %cond.end15
  store i64 0, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %cond.end15
  %16 = load i64, ptr %op.addr, align 8
  %17 = load ptr, ptr %sc, align 8
  %options20 = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 70
  %18 = load i64, ptr %options20, align 8
  %or = or i64 %18, %16
  store i64 %or, ptr %options20, align 8
  %19 = load ptr, ptr %opts, align 8
  %incdec.ptr = getelementptr inbounds %struct.ossl_param_st, ptr %19, i32 1
  store ptr %incdec.ptr, ptr %opts, align 8
  %20 = load ptr, ptr %sc, align 8
  %options21 = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 70
  call void @OSSL_PARAM_construct_uint64(ptr sret(%struct.ossl_param_st) align 8 %tmp, ptr noundef @.str.13, ptr noundef %options21)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %19, ptr align 8 %tmp, i64 40, i1 false)
  %21 = load ptr, ptr %opts, align 8
  call void @OSSL_PARAM_construct_end(ptr sret(%struct.ossl_param_st) align 8 %tmp22)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %21, ptr align 8 %tmp22, i64 40, i1 false)
  %22 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %22, i32 0, i32 100
  %rrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %rlayer, i32 0, i32 3
  %23 = load ptr, ptr %rrlmethod, align 8
  %set_options = getelementptr inbounds %struct.ossl_record_method_st, ptr %23, i32 0, i32 18
  %24 = load ptr, ptr %set_options, align 8
  %25 = load ptr, ptr %sc, align 8
  %rlayer23 = getelementptr inbounds %struct.ssl_connection_st, ptr %25, i32 0, i32 100
  %rrl = getelementptr inbounds %struct.record_layer_st, ptr %rlayer23, i32 0, i32 5
  %26 = load ptr, ptr %rrl, align 8
  %arraydecay24 = getelementptr inbounds [2 x %struct.ossl_param_st], ptr %options, i64 0, i64 0
  %call25 = call i32 %24(ptr noundef %26, ptr noundef %arraydecay24)
  %27 = load ptr, ptr %sc, align 8
  %options26 = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 70
  %28 = load i64, ptr %options26, align 8
  store i64 %28, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then
  %29 = load i64, ptr %retval, align 8
  ret i64 %29
}

declare i64 @ossl_quic_set_options(ptr noundef, i64 noundef) #1

declare void @OSSL_PARAM_construct_uint64(ptr sret(%struct.ossl_param_st) align 8, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i64 @SSL_CTX_clear_options(ptr noundef %ctx, i64 noundef %op) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %op.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store i64 %op, ptr %op.addr, align 8
  %0 = load i64, ptr %op.addr, align 8
  %not = xor i64 %0, -1
  %1 = load ptr, ptr %ctx.addr, align 8
  %options = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 34
  %2 = load i64, ptr %options, align 8
  %and = and i64 %2, %not
  store i64 %and, ptr %options, align 8
  ret i64 %and
}

; Function Attrs: nounwind uwtable
define i64 @SSL_clear_options(ptr noundef %s, i64 noundef %op) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %op.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load i64, ptr %op.addr, align 8
  %call = call i64 @ossl_quic_clear_options(ptr noundef %13, i64 noundef %14)
  store i64 %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %15 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %15, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i64 0, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.end
  %16 = load i64, ptr %op.addr, align 8
  %not = xor i64 %16, -1
  %17 = load ptr, ptr %sc, align 8
  %options = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 70
  %18 = load i64, ptr %options, align 8
  %and = and i64 %18, %not
  store i64 %and, ptr %options, align 8
  store i64 %and, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then
  %19 = load i64, ptr %retval, align 8
  ret i64 %19
}

declare i64 @ossl_quic_clear_options(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_get0_verified_chain(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %verified_chain = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 66
  %10 = load ptr, ptr %verified_chain, align 8
  store ptr %10, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load ptr, ptr %retval, align 8
  ret ptr %11
}

; Function Attrs: nounwind uwtable
define ptr @OBJ_bsearch_ssl_cipher_id(ptr noundef %key, ptr noundef %base, i32 noundef %num) #0 {
entry:
  %key.addr = alloca ptr, align 8
  %base.addr = alloca ptr, align 8
  %num.addr = alloca i32, align 4
  store ptr %key, ptr %key.addr, align 8
  store ptr %base, ptr %base.addr, align 8
  store i32 %num, ptr %num.addr, align 4
  %0 = load ptr, ptr %key.addr, align 8
  %1 = load ptr, ptr %base.addr, align 8
  %2 = load i32, ptr %num.addr, align 4
  %call = call ptr @OBJ_bsearch_(ptr noundef %0, ptr noundef %1, i32 noundef %2, i32 noundef 80, ptr noundef @ssl_cipher_id_cmp_BSEARCH_CMP_FN)
  ret ptr %call
}

declare ptr @OBJ_bsearch_(ptr noundef, ptr noundef, i32 noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @ssl_cipher_id_cmp_BSEARCH_CMP_FN(ptr noundef %a_, ptr noundef %b_) #0 {
entry:
  %a_.addr = alloca ptr, align 8
  %b_.addr = alloca ptr, align 8
  %a = alloca ptr, align 8
  %b = alloca ptr, align 8
  store ptr %a_, ptr %a_.addr, align 8
  store ptr %b_, ptr %b_.addr, align 8
  %0 = load ptr, ptr %a_.addr, align 8
  store ptr %0, ptr %a, align 8
  %1 = load ptr, ptr %b_.addr, align 8
  store ptr %1, ptr %b, align 8
  %2 = load ptr, ptr %a, align 8
  %3 = load ptr, ptr %b, align 8
  %call = call i32 @ssl_cipher_id_cmp(ptr noundef %2, ptr noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define ptr @SSL_get0_peer_scts(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %scts_parsed = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 86
  %10 = load i32, ptr %scts_parsed, align 8
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.end23, label %if.then13

if.then13:                                        ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %call = call i32 @ct_extract_tls_extension_scts(ptr noundef %11)
  %cmp14 = icmp slt i32 %call, 0
  br i1 %cmp14, label %if.then20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then13
  %12 = load ptr, ptr %sc, align 8
  %call15 = call i32 @ct_extract_ocsp_response_scts(ptr noundef %12)
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %if.then20, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false
  %13 = load ptr, ptr %sc, align 8
  %call18 = call i32 @ct_extract_x509v3_extension_scts(ptr noundef %13)
  %cmp19 = icmp slt i32 %call18, 0
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false17, %lor.lhs.false, %if.then13
  br label %err

if.end21:                                         ; preds = %lor.lhs.false17
  %14 = load ptr, ptr %sc, align 8
  %scts_parsed22 = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 86
  store i32 1, ptr %scts_parsed22, align 8
  br label %if.end23

if.end23:                                         ; preds = %if.end21, %if.end
  %15 = load ptr, ptr %sc, align 8
  %scts = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 85
  %16 = load ptr, ptr %scts, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

err:                                              ; preds = %if.then20
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %err, %if.end23, %if.then
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

; Function Attrs: nounwind uwtable
define internal i32 @ct_extract_tls_extension_scts(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %scts_extracted = alloca i32, align 4
  %p = alloca ptr, align 8
  %scts3 = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 0, ptr %scts_extracted, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 80
  %scts = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 5
  %1 = load ptr, ptr %scts, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %ext1 = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 80
  %scts2 = getelementptr inbounds %struct.anon.1, ptr %ext1, i32 0, i32 5
  %3 = load ptr, ptr %scts2, align 8
  store ptr %3, ptr %p, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %ext4 = getelementptr inbounds %struct.ssl_connection_st, ptr %4, i32 0, i32 80
  %scts_len = getelementptr inbounds %struct.anon.1, ptr %ext4, i32 0, i32 6
  %5 = load i16, ptr %scts_len, align 8
  %conv = zext i16 %5 to i64
  %call = call ptr @o2i_SCT_LIST(ptr noundef null, ptr noundef %p, i64 noundef %conv)
  store ptr %call, ptr %scts3, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %scts5 = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 85
  %7 = load ptr, ptr %scts3, align 8
  %call6 = call i32 @ct_move_scts(ptr noundef %scts5, ptr noundef %7, i32 noundef 1)
  store i32 %call6, ptr %scts_extracted, align 4
  %8 = load ptr, ptr %scts3, align 8
  call void @SCT_LIST_free(ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load i32, ptr %scts_extracted, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define internal i32 @ct_extract_ocsp_response_scts(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %scts_extracted = alloca i32, align 4
  %p = alloca ptr, align 8
  %br = alloca ptr, align 8
  %rsp = alloca ptr, align 8
  %scts = alloca ptr, align 8
  %i = alloca i32, align 4
  %single = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 0, ptr %scts_extracted, align 4
  store ptr null, ptr %br, align 8
  store ptr null, ptr %rsp, align 8
  store ptr null, ptr %scts, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 80
  %ocsp = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 8
  %resp = getelementptr inbounds %struct.anon.2, ptr %ocsp, i32 0, i32 2
  %1 = load ptr, ptr %resp, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %ext1 = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 80
  %ocsp2 = getelementptr inbounds %struct.anon.1, ptr %ext1, i32 0, i32 8
  %resp_len = getelementptr inbounds %struct.anon.2, ptr %ocsp2, i32 0, i32 3
  %3 = load i64, ptr %resp_len, align 8
  %cmp3 = icmp eq i64 %3, 0
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %err

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %s.addr, align 8
  %ext4 = getelementptr inbounds %struct.ssl_connection_st, ptr %4, i32 0, i32 80
  %ocsp5 = getelementptr inbounds %struct.anon.1, ptr %ext4, i32 0, i32 8
  %resp6 = getelementptr inbounds %struct.anon.2, ptr %ocsp5, i32 0, i32 2
  %5 = load ptr, ptr %resp6, align 8
  store ptr %5, ptr %p, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %ext7 = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 80
  %ocsp8 = getelementptr inbounds %struct.anon.1, ptr %ext7, i32 0, i32 8
  %resp_len9 = getelementptr inbounds %struct.anon.2, ptr %ocsp8, i32 0, i32 3
  %7 = load i64, ptr %resp_len9, align 8
  %conv = trunc i64 %7 to i32
  %conv10 = sext i32 %conv to i64
  %call = call ptr @d2i_OCSP_RESPONSE(ptr noundef null, ptr noundef %p, i64 noundef %conv10)
  store ptr %call, ptr %rsp, align 8
  %8 = load ptr, ptr %rsp, align 8
  %cmp11 = icmp eq ptr %8, null
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  br label %err

if.end14:                                         ; preds = %if.end
  %9 = load ptr, ptr %rsp, align 8
  %call15 = call ptr @OCSP_response_get1_basic(ptr noundef %9)
  store ptr %call15, ptr %br, align 8
  %10 = load ptr, ptr %br, align 8
  %cmp16 = icmp eq ptr %10, null
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  br label %err

if.end19:                                         ; preds = %if.end14
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end19
  %11 = load i32, ptr %i, align 4
  %12 = load ptr, ptr %br, align 8
  %call20 = call i32 @OCSP_resp_count(ptr noundef %12)
  %cmp21 = icmp slt i32 %11, %call20
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load ptr, ptr %br, align 8
  %14 = load i32, ptr %i, align 4
  %call23 = call ptr @OCSP_resp_get0(ptr noundef %13, i32 noundef %14)
  store ptr %call23, ptr %single, align 8
  %15 = load ptr, ptr %single, align 8
  %cmp24 = icmp eq ptr %15, null
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %for.body
  br label %for.inc

if.end27:                                         ; preds = %for.body
  %16 = load ptr, ptr %single, align 8
  %call28 = call ptr @OCSP_SINGLERESP_get1_ext_d2i(ptr noundef %16, i32 noundef 954, ptr noundef null, ptr noundef null)
  store ptr %call28, ptr %scts, align 8
  %17 = load ptr, ptr %s.addr, align 8
  %scts29 = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 85
  %18 = load ptr, ptr %scts, align 8
  %call30 = call i32 @ct_move_scts(ptr noundef %scts29, ptr noundef %18, i32 noundef 3)
  store i32 %call30, ptr %scts_extracted, align 4
  %19 = load i32, ptr %scts_extracted, align 4
  %cmp31 = icmp slt i32 %19, 0
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end27
  br label %err

if.end34:                                         ; preds = %if.end27
  br label %for.inc

for.inc:                                          ; preds = %if.end34, %if.then26
  %20 = load i32, ptr %i, align 4
  %inc = add nsw i32 %20, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %for.cond
  br label %err

err:                                              ; preds = %for.end, %if.then33, %if.then18, %if.then13, %if.then
  %21 = load ptr, ptr %scts, align 8
  call void @SCT_LIST_free(ptr noundef %21)
  %22 = load ptr, ptr %br, align 8
  call void @OCSP_BASICRESP_free(ptr noundef %22)
  %23 = load ptr, ptr %rsp, align 8
  call void @OCSP_RESPONSE_free(ptr noundef %23)
  %24 = load i32, ptr %scts_extracted, align 4
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal i32 @ct_extract_x509v3_extension_scts(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %scts_extracted = alloca i32, align 4
  %cert = alloca ptr, align 8
  %scts = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 0, ptr %scts_extracted, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 50
  %1 = load ptr, ptr %session, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %session1 = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 50
  %3 = load ptr, ptr %session1, align 8
  %peer = getelementptr inbounds %struct.ssl_session_st, ptr %3, i32 0, i32 12
  %4 = load ptr, ptr %peer, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %cert, align 8
  %5 = load ptr, ptr %cert, align 8
  %cmp2 = icmp ne ptr %5, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %6 = load ptr, ptr %cert, align 8
  %call = call ptr @X509_get_ext_d2i(ptr noundef %6, i32 noundef 951, ptr noundef null, ptr noundef null)
  store ptr %call, ptr %scts, align 8
  %7 = load ptr, ptr %s.addr, align 8
  %scts3 = getelementptr inbounds %struct.ssl_connection_st, ptr %7, i32 0, i32 85
  %8 = load ptr, ptr %scts, align 8
  %call4 = call i32 @ct_move_scts(ptr noundef %scts3, ptr noundef %8, i32 noundef 2)
  store i32 %call4, ptr %scts_extracted, align 4
  %9 = load ptr, ptr %scts, align 8
  call void @SCT_LIST_free(ptr noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %10 = load i32, ptr %scts_extracted, align 4
  ret i32 %10
}

declare i32 @SSL_CTX_has_client_custom_ext(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_ct_validation_callback(ptr noundef %ctx, ptr noundef %callback, ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %callback.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %callback, ptr %callback.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %callback.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %call = call i32 @SSL_CTX_has_client_custom_ext(ptr noundef %1, i32 noundef 18)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6290, ptr noundef @__func__.SSL_CTX_set_ct_validation_callback)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 206, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %callback.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %ct_validation_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 52
  store ptr %2, ptr %ct_validation_callback, align 8
  %4 = load ptr, ptr %arg.addr, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %ct_validation_callback_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 53
  store ptr %4, ptr %ct_validation_callback_arg, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define i32 @SSL_ct_is_enabled(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %ct_validation_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 83
  %10 = load ptr, ptr %ct_validation_callback, align 8
  %cmp13 = icmp ne ptr %10, null
  %conv = zext i1 %cmp13 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_ct_is_enabled(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %ct_validation_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 52
  %1 = load ptr, ptr %ct_validation_callback, align 8
  %cmp = icmp ne ptr %1, null
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @ssl_validate_ct(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %cert = alloca ptr, align 8
  %issuer = alloca ptr, align 8
  %dane = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %scts = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 0, ptr %ret, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 50
  %1 = load ptr, ptr %session, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %session1 = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 50
  %3 = load ptr, ptr %session1, align 8
  %peer = getelementptr inbounds %struct.ssl_session_st, ptr %3, i32 0, i32 12
  %4 = load ptr, ptr %peer, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %cert, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %dane2 = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 26
  store ptr %dane2, ptr %dane, align 8
  store ptr null, ptr %ctx, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %ct_validation_callback = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 83
  %7 = load ptr, ptr %ct_validation_callback, align 8
  %cmp3 = icmp eq ptr %7, null
  br i1 %cmp3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %8 = load ptr, ptr %cert, align 8
  %cmp4 = icmp eq ptr %8, null
  br i1 %cmp4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %lor.lhs.false
  %9 = load ptr, ptr %s.addr, align 8
  %verify_result = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 67
  %10 = load i64, ptr %verify_result, align 8
  %cmp6 = icmp ne i64 %10, 0
  br i1 %cmp6, label %if.then, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false5
  %11 = load ptr, ptr %s.addr, align 8
  %verified_chain = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 66
  %12 = load ptr, ptr %verified_chain, align 8
  %cmp8 = icmp eq ptr %12, null
  br i1 %cmp8, label %if.then, label %lor.lhs.false9

lor.lhs.false9:                                   ; preds = %lor.lhs.false7
  %13 = load ptr, ptr %s.addr, align 8
  %verified_chain10 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 66
  %14 = load ptr, ptr %verified_chain10, align 8
  %call = call ptr @ossl_check_const_X509_sk_type(ptr noundef %14)
  %call11 = call i32 @OPENSSL_sk_num(ptr noundef %call)
  %cmp12 = icmp sle i32 %call11, 1
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false9, %lor.lhs.false7, %lor.lhs.false5, %lor.lhs.false, %cond.end
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false9
  %15 = load ptr, ptr %dane, align 8
  %cmp13 = icmp ne ptr %15, null
  br i1 %cmp13, label %land.lhs.true, label %if.end20

land.lhs.true:                                    ; preds = %if.end
  %16 = load ptr, ptr %dane, align 8
  %trecs = getelementptr inbounds %struct.ssl_dane_st, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %trecs, align 8
  %call14 = call i32 @sk_danetls_record_num(ptr noundef %17)
  %cmp15 = icmp sgt i32 %call14, 0
  br i1 %cmp15, label %land.lhs.true16, label %if.end20

land.lhs.true16:                                  ; preds = %land.lhs.true
  %18 = load ptr, ptr %dane, align 8
  %mtlsa = getelementptr inbounds %struct.ssl_dane_st, ptr %18, i32 0, i32 3
  %19 = load ptr, ptr %mtlsa, align 8
  %cmp17 = icmp ne ptr %19, null
  br i1 %cmp17, label %if.then18, label %if.end20

if.then18:                                        ; preds = %land.lhs.true16
  %20 = load ptr, ptr %dane, align 8
  %mtlsa19 = getelementptr inbounds %struct.ssl_dane_st, ptr %20, i32 0, i32 3
  %21 = load ptr, ptr %mtlsa19, align 8
  %usage = getelementptr inbounds %struct.danetls_record_st, ptr %21, i32 0, i32 0
  %22 = load i8, ptr %usage, align 8
  %conv = zext i8 %22 to i32
  switch i32 %conv, label %sw.epilog [
    i32 2, label %sw.bb
    i32 3, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.then18, %if.then18
  store i32 1, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %if.then18
  br label %if.end20

if.end20:                                         ; preds = %sw.epilog, %land.lhs.true16, %land.lhs.true, %if.end
  %23 = load ptr, ptr %s.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %23, i32 0, i32 0
  %ctx21 = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 1
  %24 = load ptr, ptr %ctx21, align 8
  %libctx = getelementptr inbounds %struct.ssl_ctx_st, ptr %24, i32 0, i32 0
  %25 = load ptr, ptr %libctx, align 8
  %26 = load ptr, ptr %s.addr, align 8
  %ssl22 = getelementptr inbounds %struct.ssl_connection_st, ptr %26, i32 0, i32 0
  %ctx23 = getelementptr inbounds %struct.ssl_st, ptr %ssl22, i32 0, i32 1
  %27 = load ptr, ptr %ctx23, align 8
  %propq = getelementptr inbounds %struct.ssl_ctx_st, ptr %27, i32 0, i32 86
  %28 = load ptr, ptr %propq, align 8
  %call24 = call ptr @CT_POLICY_EVAL_CTX_new_ex(ptr noundef %25, ptr noundef %28)
  store ptr %call24, ptr %ctx, align 8
  %29 = load ptr, ptr %ctx, align 8
  %cmp25 = icmp eq ptr %29, null
  br i1 %cmp25, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end20
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6354, ptr noundef @__func__.ssl_validate_ct)
  %30 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %30, i32 noundef 80, i32 noundef 524338, ptr noundef null)
  br label %end

if.end28:                                         ; preds = %if.end20
  %31 = load ptr, ptr %s.addr, align 8
  %verified_chain29 = getelementptr inbounds %struct.ssl_connection_st, ptr %31, i32 0, i32 66
  %32 = load ptr, ptr %verified_chain29, align 8
  %call30 = call ptr @ossl_check_const_X509_sk_type(ptr noundef %32)
  %call31 = call ptr @OPENSSL_sk_value(ptr noundef %call30, i32 noundef 1)
  store ptr %call31, ptr %issuer, align 8
  %33 = load ptr, ptr %ctx, align 8
  %34 = load ptr, ptr %cert, align 8
  %call32 = call i32 @CT_POLICY_EVAL_CTX_set1_cert(ptr noundef %33, ptr noundef %34)
  %35 = load ptr, ptr %ctx, align 8
  %36 = load ptr, ptr %issuer, align 8
  %call33 = call i32 @CT_POLICY_EVAL_CTX_set1_issuer(ptr noundef %35, ptr noundef %36)
  %37 = load ptr, ptr %ctx, align 8
  %38 = load ptr, ptr %s.addr, align 8
  %ssl34 = getelementptr inbounds %struct.ssl_connection_st, ptr %38, i32 0, i32 0
  %ctx35 = getelementptr inbounds %struct.ssl_st, ptr %ssl34, i32 0, i32 1
  %39 = load ptr, ptr %ctx35, align 8
  %ctlog_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %39, i32 0, i32 51
  %40 = load ptr, ptr %ctlog_store, align 8
  call void @CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(ptr noundef %37, ptr noundef %40)
  %41 = load ptr, ptr %ctx, align 8
  %42 = load ptr, ptr %s.addr, align 8
  %session36 = getelementptr inbounds %struct.ssl_connection_st, ptr %42, i32 0, i32 50
  %43 = load ptr, ptr %session36, align 8
  %call37 = call i64 @SSL_SESSION_get_time(ptr noundef %43)
  %mul = mul i64 %call37, 1000
  call void @CT_POLICY_EVAL_CTX_set_time(ptr noundef %41, i64 noundef %mul)
  %44 = load ptr, ptr %s.addr, align 8
  %ssl38 = getelementptr inbounds %struct.ssl_connection_st, ptr %44, i32 0, i32 0
  %call39 = call ptr @SSL_get0_peer_scts(ptr noundef %ssl38)
  store ptr %call39, ptr %scts, align 8
  %45 = load ptr, ptr %scts, align 8
  %46 = load ptr, ptr %ctx, align 8
  %call40 = call i32 @SCT_LIST_validate(ptr noundef %45, ptr noundef %46)
  %cmp41 = icmp slt i32 %call40, 0
  br i1 %cmp41, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end28
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6383, ptr noundef @__func__.ssl_validate_ct)
  %47 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %47, i32 noundef 40, i32 noundef 208, ptr noundef null)
  br label %end

if.end44:                                         ; preds = %if.end28
  %48 = load ptr, ptr %s.addr, align 8
  %ct_validation_callback45 = getelementptr inbounds %struct.ssl_connection_st, ptr %48, i32 0, i32 83
  %49 = load ptr, ptr %ct_validation_callback45, align 8
  %50 = load ptr, ptr %ctx, align 8
  %51 = load ptr, ptr %scts, align 8
  %52 = load ptr, ptr %s.addr, align 8
  %ct_validation_callback_arg = getelementptr inbounds %struct.ssl_connection_st, ptr %52, i32 0, i32 84
  %53 = load ptr, ptr %ct_validation_callback_arg, align 8
  %call46 = call i32 %49(ptr noundef %50, ptr noundef %51, ptr noundef %53)
  store i32 %call46, ptr %ret, align 4
  %54 = load i32, ptr %ret, align 4
  %cmp47 = icmp slt i32 %54, 0
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.end44
  store i32 0, ptr %ret, align 4
  br label %if.end50

if.end50:                                         ; preds = %if.then49, %if.end44
  %55 = load i32, ptr %ret, align 4
  %tobool = icmp ne i32 %55, 0
  br i1 %tobool, label %if.end52, label %if.then51

if.then51:                                        ; preds = %if.end50
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6391, ptr noundef @__func__.ssl_validate_ct)
  %56 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %56, i32 noundef 40, i32 noundef 234, ptr noundef null)
  br label %if.end52

if.end52:                                         ; preds = %if.then51, %if.end50
  br label %end

end:                                              ; preds = %if.end52, %if.then43, %if.then27
  %57 = load ptr, ptr %ctx, align 8
  call void @CT_POLICY_EVAL_CTX_free(ptr noundef %57)
  %58 = load i32, ptr %ret, align 4
  %cmp53 = icmp sle i32 %58, 0
  br i1 %cmp53, label %if.then55, label %if.end57

if.then55:                                        ; preds = %end
  %59 = load ptr, ptr %s.addr, align 8
  %verify_result56 = getelementptr inbounds %struct.ssl_connection_st, ptr %59, i32 0, i32 67
  store i64 71, ptr %verify_result56, align 8
  br label %if.end57

if.end57:                                         ; preds = %if.then55, %end
  %60 = load i32, ptr %ret, align 4
  store i32 %60, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end57, %sw.bb, %if.then
  %61 = load i32, ptr %retval, align 4
  ret i32 %61
}

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_const_X509_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

declare ptr @CT_POLICY_EVAL_CTX_new_ex(ptr noundef, ptr noundef) #1

declare i32 @CT_POLICY_EVAL_CTX_set1_cert(ptr noundef, ptr noundef) #1

declare i32 @CT_POLICY_EVAL_CTX_set1_issuer(ptr noundef, ptr noundef) #1

declare void @CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(ptr noundef, ptr noundef) #1

declare void @CT_POLICY_EVAL_CTX_set_time(ptr noundef, i64 noundef) #1

declare i64 @SSL_SESSION_get_time(ptr noundef) #1

declare i32 @SCT_LIST_validate(ptr noundef, ptr noundef) #1

declare void @CT_POLICY_EVAL_CTX_free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_enable_ct(ptr noundef %ctx, i32 noundef %validation_mode) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %validation_mode.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %validation_mode, ptr %validation_mode.addr, align 4
  %0 = load i32, ptr %validation_mode.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
  ]

sw.default:                                       ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6419, ptr noundef @__func__.SSL_CTX_enable_ct)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 212, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %ctx.addr, align 8
  %call = call i32 @SSL_CTX_set_ct_validation_callback(ptr noundef %1, ptr noundef @ct_permissive, ptr noundef null)
  store i32 %call, ptr %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  %2 = load ptr, ptr %ctx.addr, align 8
  %call2 = call i32 @SSL_CTX_set_ct_validation_callback(ptr noundef %2, ptr noundef @ct_strict, ptr noundef null)
  store i32 %call2, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.bb1, %sw.bb, %sw.default
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal i32 @ct_permissive(ptr noundef %ctx, ptr noundef %scts, ptr noundef %unused_arg) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %scts.addr = alloca ptr, align 8
  %unused_arg.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %scts, ptr %scts.addr, align 8
  store ptr %unused_arg, ptr %unused_arg.addr, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @ct_strict(ptr noundef %ctx, ptr noundef %scts, ptr noundef %unused_arg) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %scts.addr = alloca ptr, align 8
  %unused_arg.addr = alloca ptr, align 8
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %sct = alloca ptr, align 8
  %status = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %scts, ptr %scts.addr, align 8
  store ptr %unused_arg, ptr %unused_arg.addr, align 8
  %0 = load ptr, ptr %scts.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %scts.addr, align 8
  %call = call ptr @ossl_check_const_SCT_sk_type(ptr noundef %1)
  %call1 = call i32 @OPENSSL_sk_num(ptr noundef %call)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %call1, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, ptr %count, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %count, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %scts.addr, align 8
  %call3 = call ptr @ossl_check_const_SCT_sk_type(ptr noundef %4)
  %5 = load i32, ptr %i, align 4
  %call4 = call ptr @OPENSSL_sk_value(ptr noundef %call3, i32 noundef %5)
  store ptr %call4, ptr %sct, align 8
  %6 = load ptr, ptr %sct, align 8
  %call5 = call i32 @SCT_get_validation_status(ptr noundef %6)
  store i32 %call5, ptr %status, align 4
  %7 = load i32, ptr %status, align 4
  %cmp6 = icmp eq i32 %7, 2
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, ptr %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !22

for.end:                                          ; preds = %for.cond
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6243, ptr noundef @__func__.ct_strict)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 216, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define i32 @SSL_enable_ct(ptr noundef %s, i32 noundef %validation_mode) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %validation_mode.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %validation_mode, ptr %validation_mode.addr, align 4
  %0 = load i32, ptr %validation_mode.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
  ]

sw.default:                                       ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6432, ptr noundef @__func__.SSL_enable_ct)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 212, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %call = call i32 @SSL_set_ct_validation_callback(ptr noundef %1, ptr noundef @ct_permissive, ptr noundef null)
  store i32 %call, ptr %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %call2 = call i32 @SSL_set_ct_validation_callback(ptr noundef %2, ptr noundef @ct_strict, ptr noundef null)
  store i32 %call2, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.bb1, %sw.bb, %sw.default
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_default_ctlog_list_file(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %ctlog_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 51
  %1 = load ptr, ptr %ctlog_store, align 8
  %call = call i32 @CTLOG_STORE_load_default_file(ptr noundef %1)
  ret i32 %call
}

declare i32 @CTLOG_STORE_load_default_file(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_ctlog_list_file(ptr noundef %ctx, ptr noundef %path) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %path.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %ctlog_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 51
  %1 = load ptr, ptr %ctlog_store, align 8
  %2 = load ptr, ptr %path.addr, align 8
  %call = call i32 @CTLOG_STORE_load_file(ptr noundef %1, ptr noundef %2)
  ret i32 %call
}

declare i32 @CTLOG_STORE_load_file(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set0_ctlog_store(ptr noundef %ctx, ptr noundef %logs) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %logs.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %logs, ptr %logs.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %ctlog_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 51
  %1 = load ptr, ptr %ctlog_store, align 8
  call void @CTLOG_STORE_free(ptr noundef %1)
  %2 = load ptr, ptr %logs.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %ctlog_store1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 51
  store ptr %2, ptr %ctlog_store1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get0_ctlog_store(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %ctlog_store = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 51
  %1 = load ptr, ptr %ctlog_store, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_client_hello_cb(ptr noundef %c, ptr noundef %cb, ptr noundef %arg) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %c.addr, align 8
  %client_hello_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 59
  store ptr %0, ptr %client_hello_cb, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %3 = load ptr, ptr %c.addr, align 8
  %client_hello_cb_arg = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 60
  store ptr %2, ptr %client_hello_cb_arg, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_client_hello_isv2(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %clienthello = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 81
  %10 = load ptr, ptr %clienthello, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %clienthello16 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 81
  %12 = load ptr, ptr %clienthello16, align 8
  %isv2 = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %isv2, align 8
  store i32 %13, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then14, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define i32 @SSL_client_hello_get0_legacy_version(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %clienthello = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 81
  %10 = load ptr, ptr %clienthello, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %clienthello16 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 81
  %12 = load ptr, ptr %clienthello16, align 8
  %legacy_version = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %12, i32 0, i32 1
  %13 = load i32, ptr %legacy_version, align 4
  store i32 %13, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then14, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define i64 @SSL_client_hello_get0_random(ptr noundef %s, ptr noundef %out) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %clienthello = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 81
  %10 = load ptr, ptr %clienthello, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i64 0, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end
  %11 = load ptr, ptr %out.addr, align 8
  %cmp16 = icmp ne ptr %11, null
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end15
  %12 = load ptr, ptr %sc, align 8
  %clienthello18 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 81
  %13 = load ptr, ptr %clienthello18, align 8
  %random = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %13, i32 0, i32 2
  %arraydecay = getelementptr inbounds [32 x i8], ptr %random, i64 0, i64 0
  %14 = load ptr, ptr %out.addr, align 8
  store ptr %arraydecay, ptr %14, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end15
  store i64 32, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then14, %if.then
  %15 = load i64, ptr %retval, align 8
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define i64 @SSL_client_hello_get0_session_id(ptr noundef %s, ptr noundef %out) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %clienthello = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 81
  %10 = load ptr, ptr %clienthello, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i64 0, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end
  %11 = load ptr, ptr %out.addr, align 8
  %cmp16 = icmp ne ptr %11, null
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end15
  %12 = load ptr, ptr %sc, align 8
  %clienthello18 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 81
  %13 = load ptr, ptr %clienthello18, align 8
  %session_id = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %13, i32 0, i32 4
  %arraydecay = getelementptr inbounds [32 x i8], ptr %session_id, i64 0, i64 0
  %14 = load ptr, ptr %out.addr, align 8
  store ptr %arraydecay, ptr %14, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end15
  %15 = load ptr, ptr %sc, align 8
  %clienthello20 = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 81
  %16 = load ptr, ptr %clienthello20, align 8
  %session_id_len = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %16, i32 0, i32 3
  %17 = load i64, ptr %session_id_len, align 8
  store i64 %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then14, %if.then
  %18 = load i64, ptr %retval, align 8
  ret i64 %18
}

; Function Attrs: nounwind uwtable
define i64 @SSL_client_hello_get0_ciphers(ptr noundef %s, ptr noundef %out) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %clienthello = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 81
  %10 = load ptr, ptr %clienthello, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i64 0, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end
  %11 = load ptr, ptr %out.addr, align 8
  %cmp16 = icmp ne ptr %11, null
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end15
  %12 = load ptr, ptr %sc, align 8
  %clienthello18 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 81
  %13 = load ptr, ptr %clienthello18, align 8
  %ciphersuites = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %13, i32 0, i32 7
  %call = call ptr @PACKET_data(ptr noundef %ciphersuites)
  %14 = load ptr, ptr %out.addr, align 8
  store ptr %call, ptr %14, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end15
  %15 = load ptr, ptr %sc, align 8
  %clienthello20 = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 81
  %16 = load ptr, ptr %clienthello20, align 8
  %ciphersuites21 = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %16, i32 0, i32 7
  %call22 = call i64 @PACKET_remaining(ptr noundef %ciphersuites21)
  store i64 %call22, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then14, %if.then
  %17 = load i64, ptr %retval, align 8
  ret i64 %17
}

; Function Attrs: nounwind uwtable
define internal ptr @PACKET_data(ptr noundef %pkt) #0 {
entry:
  %pkt.addr = alloca ptr, align 8
  store ptr %pkt, ptr %pkt.addr, align 8
  %0 = load ptr, ptr %pkt.addr, align 8
  %curr = getelementptr inbounds %struct.PACKET, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %curr, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define internal i64 @PACKET_remaining(ptr noundef %pkt) #0 {
entry:
  %pkt.addr = alloca ptr, align 8
  store ptr %pkt, ptr %pkt.addr, align 8
  %0 = load ptr, ptr %pkt.addr, align 8
  %remaining = getelementptr inbounds %struct.PACKET, ptr %0, i32 0, i32 1
  %1 = load i64, ptr %remaining, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i64 @SSL_client_hello_get0_compression_methods(ptr noundef %s, ptr noundef %out) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %clienthello = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 81
  %10 = load ptr, ptr %clienthello, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  store i64 0, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %if.end
  %11 = load ptr, ptr %out.addr, align 8
  %cmp16 = icmp ne ptr %11, null
  br i1 %cmp16, label %if.then17, label %if.end19

if.then17:                                        ; preds = %if.end15
  %12 = load ptr, ptr %sc, align 8
  %clienthello18 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 81
  %13 = load ptr, ptr %clienthello18, align 8
  %compressions = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %13, i32 0, i32 9
  %arraydecay = getelementptr inbounds [255 x i8], ptr %compressions, i64 0, i64 0
  %14 = load ptr, ptr %out.addr, align 8
  store ptr %arraydecay, ptr %14, align 8
  br label %if.end19

if.end19:                                         ; preds = %if.then17, %if.end15
  %15 = load ptr, ptr %sc, align 8
  %clienthello20 = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 81
  %16 = load ptr, ptr %clienthello20, align 8
  %compressions_len = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %16, i32 0, i32 8
  %17 = load i64, ptr %compressions_len, align 8
  store i64 %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then14, %if.then
  %18 = load i64, ptr %retval, align 8
  ret i64 %18
}

; Function Attrs: nounwind uwtable
define i32 @SSL_client_hello_get1_extensions_present(ptr noundef %s, ptr noundef %out, ptr noundef %outlen) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %out.addr = alloca ptr, align 8
  %outlen.addr = alloca ptr, align 8
  %ext = alloca ptr, align 8
  %present = alloca ptr, align 8
  %num = alloca i64, align 8
  %i = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %out, ptr %out.addr, align 8
  store ptr %outlen, ptr %outlen.addr, align 8
  store i64 0, ptr %num, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %clienthello = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 81
  %10 = load ptr, ptr %clienthello, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %11 = load ptr, ptr %out.addr, align 8
  %cmp14 = icmp eq ptr %11, null
  br i1 %cmp14, label %if.then17, label %lor.lhs.false15

lor.lhs.false15:                                  ; preds = %lor.lhs.false
  %12 = load ptr, ptr %outlen.addr, align 8
  %cmp16 = icmp eq ptr %12, null
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %lor.lhs.false15, %lor.lhs.false, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %lor.lhs.false15
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end18
  %13 = load i64, ptr %i, align 8
  %14 = load ptr, ptr %sc, align 8
  %clienthello19 = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 81
  %15 = load ptr, ptr %clienthello19, align 8
  %pre_proc_exts_len = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %15, i32 0, i32 11
  %16 = load i64, ptr %pre_proc_exts_len, align 8
  %cmp20 = icmp ult i64 %13, %16
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load ptr, ptr %sc, align 8
  %clienthello21 = getelementptr inbounds %struct.ssl_connection_st, ptr %17, i32 0, i32 81
  %18 = load ptr, ptr %clienthello21, align 8
  %pre_proc_exts = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %18, i32 0, i32 12
  %19 = load ptr, ptr %pre_proc_exts, align 8
  %20 = load i64, ptr %i, align 8
  %add.ptr = getelementptr inbounds %struct.raw_extension_st, ptr %19, i64 %20
  store ptr %add.ptr, ptr %ext, align 8
  %21 = load ptr, ptr %ext, align 8
  %present22 = getelementptr inbounds %struct.raw_extension_st, ptr %21, i32 0, i32 1
  %22 = load i32, ptr %present22, align 8
  %tobool = icmp ne i32 %22, 0
  br i1 %tobool, label %if.then23, label %if.end24

if.then23:                                        ; preds = %for.body
  %23 = load i64, ptr %num, align 8
  %inc = add i64 %23, 1
  store i64 %inc, ptr %num, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end24
  %24 = load i64, ptr %i, align 8
  %inc25 = add i64 %24, 1
  store i64 %inc25, ptr %i, align 8
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %for.cond
  %25 = load i64, ptr %num, align 8
  %cmp26 = icmp eq i64 %25, 0
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %for.end
  %26 = load ptr, ptr %out.addr, align 8
  store ptr null, ptr %26, align 8
  %27 = load ptr, ptr %outlen.addr, align 8
  store i64 0, ptr %27, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %for.end
  %28 = load i64, ptr %num, align 8
  %mul = mul i64 4, %28
  %call = call noalias ptr @CRYPTO_malloc(i64 noundef %mul, ptr noundef @.str, i32 noundef 6573)
  store ptr %call, ptr %present, align 8
  %cmp29 = icmp eq ptr %call, null
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end28
  store i32 0, ptr %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end28
  store i64 0, ptr %i, align 8
  br label %for.cond32

for.cond32:                                       ; preds = %for.inc49, %if.end31
  %29 = load i64, ptr %i, align 8
  %30 = load ptr, ptr %sc, align 8
  %clienthello33 = getelementptr inbounds %struct.ssl_connection_st, ptr %30, i32 0, i32 81
  %31 = load ptr, ptr %clienthello33, align 8
  %pre_proc_exts_len34 = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %31, i32 0, i32 11
  %32 = load i64, ptr %pre_proc_exts_len34, align 8
  %cmp35 = icmp ult i64 %29, %32
  br i1 %cmp35, label %for.body36, label %for.end51

for.body36:                                       ; preds = %for.cond32
  %33 = load ptr, ptr %sc, align 8
  %clienthello37 = getelementptr inbounds %struct.ssl_connection_st, ptr %33, i32 0, i32 81
  %34 = load ptr, ptr %clienthello37, align 8
  %pre_proc_exts38 = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %34, i32 0, i32 12
  %35 = load ptr, ptr %pre_proc_exts38, align 8
  %36 = load i64, ptr %i, align 8
  %add.ptr39 = getelementptr inbounds %struct.raw_extension_st, ptr %35, i64 %36
  store ptr %add.ptr39, ptr %ext, align 8
  %37 = load ptr, ptr %ext, align 8
  %present40 = getelementptr inbounds %struct.raw_extension_st, ptr %37, i32 0, i32 1
  %38 = load i32, ptr %present40, align 8
  %tobool41 = icmp ne i32 %38, 0
  br i1 %tobool41, label %if.then42, label %if.end48

if.then42:                                        ; preds = %for.body36
  %39 = load ptr, ptr %ext, align 8
  %received_order = getelementptr inbounds %struct.raw_extension_st, ptr %39, i32 0, i32 4
  %40 = load i64, ptr %received_order, align 8
  %41 = load i64, ptr %num, align 8
  %cmp43 = icmp uge i64 %40, %41
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.then42
  br label %err

if.end45:                                         ; preds = %if.then42
  %42 = load ptr, ptr %ext, align 8
  %type46 = getelementptr inbounds %struct.raw_extension_st, ptr %42, i32 0, i32 3
  %43 = load i32, ptr %type46, align 8
  %44 = load ptr, ptr %present, align 8
  %45 = load ptr, ptr %ext, align 8
  %received_order47 = getelementptr inbounds %struct.raw_extension_st, ptr %45, i32 0, i32 4
  %46 = load i64, ptr %received_order47, align 8
  %arrayidx = getelementptr inbounds i32, ptr %44, i64 %46
  store i32 %43, ptr %arrayidx, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.end45, %for.body36
  br label %for.inc49

for.inc49:                                        ; preds = %if.end48
  %47 = load i64, ptr %i, align 8
  %inc50 = add i64 %47, 1
  store i64 %inc50, ptr %i, align 8
  br label %for.cond32, !llvm.loop !24

for.end51:                                        ; preds = %for.cond32
  %48 = load ptr, ptr %present, align 8
  %49 = load ptr, ptr %out.addr, align 8
  store ptr %48, ptr %49, align 8
  %50 = load i64, ptr %num, align 8
  %51 = load ptr, ptr %outlen.addr, align 8
  store i64 %50, ptr %51, align 8
  store i32 1, ptr %retval, align 4
  br label %return

err:                                              ; preds = %if.then44
  %52 = load ptr, ptr %present, align 8
  call void @CRYPTO_free(ptr noundef %52, ptr noundef @.str, i32 noundef 6587)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %err, %for.end51, %if.then30, %if.then27, %if.then17, %if.then
  %53 = load i32, ptr %retval, align 4
  ret i32 %53
}

; Function Attrs: nounwind uwtable
define i32 @SSL_client_hello_get_extension_order(ptr noundef %s, ptr noundef %exts, ptr noundef %num_exts) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %exts.addr = alloca ptr, align 8
  %num_exts.addr = alloca ptr, align 8
  %ext = alloca ptr, align 8
  %num = alloca i64, align 8
  %i = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %exts, ptr %exts.addr, align 8
  store ptr %num_exts, ptr %num_exts.addr, align 8
  store i64 0, ptr %num, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %clienthello = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 81
  %10 = load ptr, ptr %clienthello, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %11 = load ptr, ptr %num_exts.addr, align 8
  %cmp14 = icmp eq ptr %11, null
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %lor.lhs.false, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %lor.lhs.false
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end16
  %12 = load i64, ptr %i, align 8
  %13 = load ptr, ptr %sc, align 8
  %clienthello17 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 81
  %14 = load ptr, ptr %clienthello17, align 8
  %pre_proc_exts_len = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %14, i32 0, i32 11
  %15 = load i64, ptr %pre_proc_exts_len, align 8
  %cmp18 = icmp ult i64 %12, %15
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load ptr, ptr %sc, align 8
  %clienthello19 = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 81
  %17 = load ptr, ptr %clienthello19, align 8
  %pre_proc_exts = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %17, i32 0, i32 12
  %18 = load ptr, ptr %pre_proc_exts, align 8
  %19 = load i64, ptr %i, align 8
  %add.ptr = getelementptr inbounds %struct.raw_extension_st, ptr %18, i64 %19
  store ptr %add.ptr, ptr %ext, align 8
  %20 = load ptr, ptr %ext, align 8
  %present = getelementptr inbounds %struct.raw_extension_st, ptr %20, i32 0, i32 1
  %21 = load i32, ptr %present, align 8
  %tobool = icmp ne i32 %21, 0
  br i1 %tobool, label %if.then20, label %if.end21

if.then20:                                        ; preds = %for.body
  %22 = load i64, ptr %num, align 8
  %inc = add i64 %22, 1
  store i64 %inc, ptr %num, align 8
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end21
  %23 = load i64, ptr %i, align 8
  %inc22 = add i64 %23, 1
  store i64 %inc22, ptr %i, align 8
  br label %for.cond, !llvm.loop !25

for.end:                                          ; preds = %for.cond
  %24 = load i64, ptr %num, align 8
  %cmp23 = icmp eq i64 %24, 0
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %for.end
  %25 = load ptr, ptr %num_exts.addr, align 8
  store i64 0, ptr %25, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.end25:                                         ; preds = %for.end
  %26 = load ptr, ptr %exts.addr, align 8
  %cmp26 = icmp eq ptr %26, null
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end25
  %27 = load i64, ptr %num, align 8
  %28 = load ptr, ptr %num_exts.addr, align 8
  store i64 %27, ptr %28, align 8
  store i32 1, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.end25
  %29 = load ptr, ptr %num_exts.addr, align 8
  %30 = load i64, ptr %29, align 8
  %31 = load i64, ptr %num, align 8
  %cmp29 = icmp ult i64 %30, %31
  br i1 %cmp29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end28
  store i32 0, ptr %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end28
  store i64 0, ptr %i, align 8
  br label %for.cond32

for.cond32:                                       ; preds = %for.inc49, %if.end31
  %32 = load i64, ptr %i, align 8
  %33 = load ptr, ptr %sc, align 8
  %clienthello33 = getelementptr inbounds %struct.ssl_connection_st, ptr %33, i32 0, i32 81
  %34 = load ptr, ptr %clienthello33, align 8
  %pre_proc_exts_len34 = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %34, i32 0, i32 11
  %35 = load i64, ptr %pre_proc_exts_len34, align 8
  %cmp35 = icmp ult i64 %32, %35
  br i1 %cmp35, label %for.body36, label %for.end51

for.body36:                                       ; preds = %for.cond32
  %36 = load ptr, ptr %sc, align 8
  %clienthello37 = getelementptr inbounds %struct.ssl_connection_st, ptr %36, i32 0, i32 81
  %37 = load ptr, ptr %clienthello37, align 8
  %pre_proc_exts38 = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %37, i32 0, i32 12
  %38 = load ptr, ptr %pre_proc_exts38, align 8
  %39 = load i64, ptr %i, align 8
  %add.ptr39 = getelementptr inbounds %struct.raw_extension_st, ptr %38, i64 %39
  store ptr %add.ptr39, ptr %ext, align 8
  %40 = load ptr, ptr %ext, align 8
  %present40 = getelementptr inbounds %struct.raw_extension_st, ptr %40, i32 0, i32 1
  %41 = load i32, ptr %present40, align 8
  %tobool41 = icmp ne i32 %41, 0
  br i1 %tobool41, label %if.then42, label %if.end48

if.then42:                                        ; preds = %for.body36
  %42 = load ptr, ptr %ext, align 8
  %received_order = getelementptr inbounds %struct.raw_extension_st, ptr %42, i32 0, i32 4
  %43 = load i64, ptr %received_order, align 8
  %44 = load i64, ptr %num, align 8
  %cmp43 = icmp uge i64 %43, %44
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.then42
  store i32 0, ptr %retval, align 4
  br label %return

if.end45:                                         ; preds = %if.then42
  %45 = load ptr, ptr %ext, align 8
  %type46 = getelementptr inbounds %struct.raw_extension_st, ptr %45, i32 0, i32 3
  %46 = load i32, ptr %type46, align 8
  %conv = trunc i32 %46 to i16
  %47 = load ptr, ptr %exts.addr, align 8
  %48 = load ptr, ptr %ext, align 8
  %received_order47 = getelementptr inbounds %struct.raw_extension_st, ptr %48, i32 0, i32 4
  %49 = load i64, ptr %received_order47, align 8
  %arrayidx = getelementptr inbounds i16, ptr %47, i64 %49
  store i16 %conv, ptr %arrayidx, align 2
  br label %if.end48

if.end48:                                         ; preds = %if.end45, %for.body36
  br label %for.inc49

for.inc49:                                        ; preds = %if.end48
  %50 = load i64, ptr %i, align 8
  %inc50 = add i64 %50, 1
  store i64 %inc50, ptr %i, align 8
  br label %for.cond32, !llvm.loop !26

for.end51:                                        ; preds = %for.cond32
  %51 = load i64, ptr %num, align 8
  %52 = load ptr, ptr %num_exts.addr, align 8
  store i64 %51, ptr %52, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end51, %if.then44, %if.then30, %if.then27, %if.then24, %if.then15, %if.then
  %53 = load i32, ptr %retval, align 4
  ret i32 %53
}

; Function Attrs: nounwind uwtable
define i32 @SSL_client_hello_get0_ext(ptr noundef %s, i32 noundef %type, ptr noundef %out, ptr noundef %outlen) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %out.addr = alloca ptr, align 8
  %outlen.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %r = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store ptr %out, ptr %out.addr, align 8
  store ptr %outlen, ptr %outlen.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end11

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type1 = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type1, align 8
  %cmp2 = icmp eq i32 %2, 0
  br i1 %cmp2, label %cond.true3, label %cond.false4

cond.true3:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end9

cond.false4:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type5 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type5, align 8
  %cmp6 = icmp eq i32 %5, 1
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.false4
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false8:                                      ; preds = %cond.false4
  br label %cond.end

cond.end:                                         ; preds = %cond.false8, %cond.true7
  %cond = phi ptr [ %7, %cond.true7 ], [ null, %cond.false8 ]
  br label %cond.end9

cond.end9:                                        ; preds = %cond.end, %cond.true3
  %cond10 = phi ptr [ %3, %cond.true3 ], [ %cond, %cond.end ]
  br label %cond.end11

cond.end11:                                       ; preds = %cond.end9, %cond.true
  %cond12 = phi ptr [ null, %cond.true ], [ %cond10, %cond.end9 ]
  store ptr %cond12, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp13 = icmp eq ptr %8, null
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end11
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end11
  %9 = load ptr, ptr %sc, align 8
  %clienthello = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 81
  %10 = load ptr, ptr %clienthello, align 8
  %cmp14 = icmp eq ptr %10, null
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end16
  %11 = load i64, ptr %i, align 8
  %12 = load ptr, ptr %sc, align 8
  %clienthello17 = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 81
  %13 = load ptr, ptr %clienthello17, align 8
  %pre_proc_exts_len = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %13, i32 0, i32 11
  %14 = load i64, ptr %pre_proc_exts_len, align 8
  %cmp18 = icmp ult i64 %11, %14
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load ptr, ptr %sc, align 8
  %clienthello19 = getelementptr inbounds %struct.ssl_connection_st, ptr %15, i32 0, i32 81
  %16 = load ptr, ptr %clienthello19, align 8
  %pre_proc_exts = getelementptr inbounds %struct.CLIENTHELLO_MSG, ptr %16, i32 0, i32 12
  %17 = load ptr, ptr %pre_proc_exts, align 8
  %18 = load i64, ptr %i, align 8
  %add.ptr = getelementptr inbounds %struct.raw_extension_st, ptr %17, i64 %18
  store ptr %add.ptr, ptr %r, align 8
  %19 = load ptr, ptr %r, align 8
  %present = getelementptr inbounds %struct.raw_extension_st, ptr %19, i32 0, i32 1
  %20 = load i32, ptr %present, align 8
  %tobool = icmp ne i32 %20, 0
  br i1 %tobool, label %land.lhs.true, label %if.end31

land.lhs.true:                                    ; preds = %for.body
  %21 = load ptr, ptr %r, align 8
  %type20 = getelementptr inbounds %struct.raw_extension_st, ptr %21, i32 0, i32 3
  %22 = load i32, ptr %type20, align 8
  %23 = load i32, ptr %type.addr, align 4
  %cmp21 = icmp eq i32 %22, %23
  br i1 %cmp21, label %if.then22, label %if.end31

if.then22:                                        ; preds = %land.lhs.true
  %24 = load ptr, ptr %out.addr, align 8
  %cmp23 = icmp ne ptr %24, null
  br i1 %cmp23, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.then22
  %25 = load ptr, ptr %r, align 8
  %data = getelementptr inbounds %struct.raw_extension_st, ptr %25, i32 0, i32 0
  %call = call ptr @PACKET_data(ptr noundef %data)
  %26 = load ptr, ptr %out.addr, align 8
  store ptr %call, ptr %26, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.then22
  %27 = load ptr, ptr %outlen.addr, align 8
  %cmp26 = icmp ne ptr %27, null
  br i1 %cmp26, label %if.then27, label %if.end30

if.then27:                                        ; preds = %if.end25
  %28 = load ptr, ptr %r, align 8
  %data28 = getelementptr inbounds %struct.raw_extension_st, ptr %28, i32 0, i32 0
  %call29 = call i64 @PACKET_remaining(ptr noundef %data28)
  %29 = load ptr, ptr %outlen.addr, align 8
  store i64 %call29, ptr %29, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then27, %if.end25
  store i32 1, ptr %retval, align 4
  br label %return

if.end31:                                         ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end31
  %30 = load i64, ptr %i, align 8
  %inc = add i64 %30, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !27

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end30, %if.then15, %if.then
  %31 = load i32, ptr %retval, align 4
  ret i32 %31
}

; Function Attrs: nounwind uwtable
define i32 @SSL_free_buffers(ptr noundef %ssl) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %rl = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 100
  store ptr %rlayer, ptr %rl, align 8
  %6 = load ptr, ptr %rl, align 8
  %rrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %6, i32 0, i32 3
  %7 = load ptr, ptr %rrlmethod, align 8
  %free_buffers = getelementptr inbounds %struct.ossl_record_method_st, ptr %7, i32 0, i32 24
  %8 = load ptr, ptr %free_buffers, align 8
  %9 = load ptr, ptr %rl, align 8
  %rrl = getelementptr inbounds %struct.record_layer_st, ptr %9, i32 0, i32 5
  %10 = load ptr, ptr %rrl, align 8
  %call = call i32 %8(ptr noundef %10)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %11 = load ptr, ptr %rl, align 8
  %wrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %11, i32 0, i32 4
  %12 = load ptr, ptr %wrlmethod, align 8
  %free_buffers7 = getelementptr inbounds %struct.ossl_record_method_st, ptr %12, i32 0, i32 24
  %13 = load ptr, ptr %free_buffers7, align 8
  %14 = load ptr, ptr %rl, align 8
  %wrl = getelementptr inbounds %struct.record_layer_st, ptr %14, i32 0, i32 6
  %15 = load ptr, ptr %wrl, align 8
  %call8 = call i32 %13(ptr noundef %15)
  %tobool9 = icmp ne i32 %call8, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %16 = phi i1 [ false, %if.end ], [ %tobool9, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  store i32 %land.ext, ptr %retval, align 4
  br label %return

return:                                           ; preds = %land.end, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @SSL_alloc_buffers(ptr noundef %ssl) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %rl = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %ssl.addr, align 8
  %cmp13 = icmp ne ptr %9, null
  br i1 %cmp13, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %if.end
  %10 = load ptr, ptr %ssl.addr, align 8
  %type14 = getelementptr inbounds %struct.ssl_st, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %type14, align 8
  %cmp15 = icmp eq i32 %11, 1
  br i1 %cmp15, label %if.then18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %12 = load ptr, ptr %ssl.addr, align 8
  %type16 = getelementptr inbounds %struct.ssl_st, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %type16, align 8
  %cmp17 = icmp eq i32 %13, 2
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %lor.lhs.false, %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %lor.lhs.false, %if.end
  %14 = load ptr, ptr %sc, align 8
  %rlayer = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 100
  store ptr %rlayer, ptr %rl, align 8
  %15 = load ptr, ptr %rl, align 8
  %rrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %15, i32 0, i32 3
  %16 = load ptr, ptr %rrlmethod, align 8
  %alloc_buffers = getelementptr inbounds %struct.ossl_record_method_st, ptr %16, i32 0, i32 23
  %17 = load ptr, ptr %alloc_buffers, align 8
  %18 = load ptr, ptr %rl, align 8
  %rrl = getelementptr inbounds %struct.record_layer_st, ptr %18, i32 0, i32 5
  %19 = load ptr, ptr %rrl, align 8
  %call = call i32 %17(ptr noundef %19)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end19
  %20 = load ptr, ptr %rl, align 8
  %wrlmethod = getelementptr inbounds %struct.record_layer_st, ptr %20, i32 0, i32 4
  %21 = load ptr, ptr %wrlmethod, align 8
  %alloc_buffers20 = getelementptr inbounds %struct.ossl_record_method_st, ptr %21, i32 0, i32 23
  %22 = load ptr, ptr %alloc_buffers20, align 8
  %23 = load ptr, ptr %rl, align 8
  %wrl = getelementptr inbounds %struct.record_layer_st, ptr %23, i32 0, i32 6
  %24 = load ptr, ptr %wrl, align 8
  %call21 = call i32 %22(ptr noundef %24)
  %tobool22 = icmp ne i32 %call21, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end19
  %25 = phi i1 [ false, %if.end19 ], [ %tobool22, %land.rhs ]
  %land.ext = zext i1 %25 to i32
  store i32 %land.ext, ptr %retval, align 4
  br label %return

return:                                           ; preds = %land.end, %if.then18, %if.then
  %26 = load i32, ptr %retval, align 4
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_keylog_callback(ptr noundef %ctx, ptr noundef %cb) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %keylog_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 71
  store ptr %0, ptr %keylog_callback, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @SSL_CTX_get_keylog_callback(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %keylog_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 71
  %1 = load ptr, ptr %keylog_callback, align 8
  ret ptr %1
}

; Function Attrs: nounwind uwtable
define i32 @ssl_log_rsa_client_key_exchange(ptr noundef %sc, ptr noundef %encrypted_premaster, i64 noundef %encrypted_premaster_len, ptr noundef %premaster, i64 noundef %premaster_len) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca ptr, align 8
  %encrypted_premaster.addr = alloca ptr, align 8
  %encrypted_premaster_len.addr = alloca i64, align 8
  %premaster.addr = alloca ptr, align 8
  %premaster_len.addr = alloca i64, align 8
  store ptr %sc, ptr %sc.addr, align 8
  store ptr %encrypted_premaster, ptr %encrypted_premaster.addr, align 8
  store i64 %encrypted_premaster_len, ptr %encrypted_premaster_len.addr, align 8
  store ptr %premaster, ptr %premaster.addr, align 8
  store i64 %premaster_len, ptr %premaster_len.addr, align 8
  %0 = load i64, ptr %encrypted_premaster_len.addr, align 8
  %cmp = icmp ult i64 %0, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6755, ptr noundef @__func__.ssl_log_rsa_client_key_exchange)
  %1 = load ptr, ptr %sc.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %1, i32 noundef 80, i32 noundef 786691, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %sc.addr, align 8
  %3 = load ptr, ptr %encrypted_premaster.addr, align 8
  %4 = load ptr, ptr %premaster.addr, align 8
  %5 = load i64, ptr %premaster_len.addr, align 8
  %call = call i32 @nss_keylog_int(ptr noundef @.str.14, ptr noundef %2, ptr noundef %3, i64 noundef 8, ptr noundef %4, i64 noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @nss_keylog_int(ptr noundef %prefix, ptr noundef %sc, ptr noundef %parameter_1, i64 noundef %parameter_1_len, ptr noundef %parameter_2, i64 noundef %parameter_2_len) #0 {
entry:
  %retval = alloca i32, align 4
  %prefix.addr = alloca ptr, align 8
  %sc.addr = alloca ptr, align 8
  %parameter_1.addr = alloca ptr, align 8
  %parameter_1_len.addr = alloca i64, align 8
  %parameter_2.addr = alloca ptr, align 8
  %parameter_2_len.addr = alloca i64, align 8
  %out = alloca ptr, align 8
  %cursor = alloca ptr, align 8
  %out_len = alloca i64, align 8
  %i = alloca i64, align 8
  %prefix_len = alloca i64, align 8
  %sctx = alloca ptr, align 8
  store ptr %prefix, ptr %prefix.addr, align 8
  store ptr %sc, ptr %sc.addr, align 8
  store ptr %parameter_1, ptr %parameter_1.addr, align 8
  store i64 %parameter_1_len, ptr %parameter_1_len.addr, align 8
  store ptr %parameter_2, ptr %parameter_2.addr, align 8
  store i64 %parameter_2_len, ptr %parameter_2_len.addr, align 8
  store ptr null, ptr %out, align 8
  store ptr null, ptr %cursor, align 8
  store i64 0, ptr %out_len, align 8
  %0 = load ptr, ptr %sc.addr, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 0
  %ctx = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 1
  %1 = load ptr, ptr %ctx, align 8
  store ptr %1, ptr %sctx, align 8
  %2 = load ptr, ptr %sctx, align 8
  %keylog_callback = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 71
  %3 = load ptr, ptr %keylog_callback, align 8
  %cmp = icmp eq ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %prefix.addr, align 8
  %call = call i64 @strlen(ptr noundef %4) #6
  store i64 %call, ptr %prefix_len, align 8
  %5 = load i64, ptr %prefix_len, align 8
  %6 = load i64, ptr %parameter_1_len.addr, align 8
  %mul = mul i64 2, %6
  %add = add i64 %5, %mul
  %7 = load i64, ptr %parameter_2_len.addr, align 8
  %mul1 = mul i64 2, %7
  %add2 = add i64 %add, %mul1
  %add3 = add i64 %add2, 3
  store i64 %add3, ptr %out_len, align 8
  %8 = load i64, ptr %out_len, align 8
  %call4 = call noalias ptr @CRYPTO_malloc(i64 noundef %8, ptr noundef @.str, i32 noundef 6723)
  store ptr %call4, ptr %cursor, align 8
  store ptr %call4, ptr %out, align 8
  %cmp5 = icmp eq ptr %call4, null
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end
  %9 = load ptr, ptr %cursor, align 8
  %10 = load ptr, ptr %prefix.addr, align 8
  %call8 = call ptr @strcpy(ptr noundef %9, ptr noundef %10) #7
  %11 = load i64, ptr %prefix_len, align 8
  %12 = load ptr, ptr %cursor, align 8
  %add.ptr = getelementptr inbounds i8, ptr %12, i64 %11
  store ptr %add.ptr, ptr %cursor, align 8
  %13 = load ptr, ptr %cursor, align 8
  %incdec.ptr = getelementptr inbounds i8, ptr %13, i32 1
  store ptr %incdec.ptr, ptr %cursor, align 8
  store i8 32, ptr %13, align 1
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %14 = load i64, ptr %i, align 8
  %15 = load i64, ptr %parameter_1_len.addr, align 8
  %cmp9 = icmp ult i64 %14, %15
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load ptr, ptr %cursor, align 8
  %17 = load ptr, ptr %parameter_1.addr, align 8
  %18 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds i8, ptr %17, i64 %18
  %19 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %19 to i32
  %call10 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %16, ptr noundef @.str.15, i32 noundef %conv) #7
  %20 = load ptr, ptr %cursor, align 8
  %add.ptr11 = getelementptr inbounds i8, ptr %20, i64 2
  store ptr %add.ptr11, ptr %cursor, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load i64, ptr %i, align 8
  %inc = add i64 %21, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !28

for.end:                                          ; preds = %for.cond
  %22 = load ptr, ptr %cursor, align 8
  %incdec.ptr12 = getelementptr inbounds i8, ptr %22, i32 1
  store ptr %incdec.ptr12, ptr %cursor, align 8
  store i8 32, ptr %22, align 1
  store i64 0, ptr %i, align 8
  br label %for.cond13

for.cond13:                                       ; preds = %for.inc21, %for.end
  %23 = load i64, ptr %i, align 8
  %24 = load i64, ptr %parameter_2_len.addr, align 8
  %cmp14 = icmp ult i64 %23, %24
  br i1 %cmp14, label %for.body16, label %for.end23

for.body16:                                       ; preds = %for.cond13
  %25 = load ptr, ptr %cursor, align 8
  %26 = load ptr, ptr %parameter_2.addr, align 8
  %27 = load i64, ptr %i, align 8
  %arrayidx17 = getelementptr inbounds i8, ptr %26, i64 %27
  %28 = load i8, ptr %arrayidx17, align 1
  %conv18 = zext i8 %28 to i32
  %call19 = call i32 (ptr, ptr, ...) @sprintf(ptr noundef %25, ptr noundef @.str.15, i32 noundef %conv18) #7
  %29 = load ptr, ptr %cursor, align 8
  %add.ptr20 = getelementptr inbounds i8, ptr %29, i64 2
  store ptr %add.ptr20, ptr %cursor, align 8
  br label %for.inc21

for.inc21:                                        ; preds = %for.body16
  %30 = load i64, ptr %i, align 8
  %inc22 = add i64 %30, 1
  store i64 %inc22, ptr %i, align 8
  br label %for.cond13, !llvm.loop !29

for.end23:                                        ; preds = %for.cond13
  %31 = load ptr, ptr %cursor, align 8
  store i8 0, ptr %31, align 1
  %32 = load ptr, ptr %sctx, align 8
  %keylog_callback24 = getelementptr inbounds %struct.ssl_ctx_st, ptr %32, i32 0, i32 71
  %33 = load ptr, ptr %keylog_callback24, align 8
  %34 = load ptr, ptr %sc.addr, align 8
  %ssl25 = getelementptr inbounds %struct.ssl_connection_st, ptr %34, i32 0, i32 0
  %35 = load ptr, ptr %out, align 8
  call void %33(ptr noundef %ssl25, ptr noundef %35)
  %36 = load ptr, ptr %out, align 8
  %37 = load i64, ptr %out_len, align 8
  call void @CRYPTO_clear_free(ptr noundef %36, i64 noundef %37, ptr noundef @.str, i32 noundef 6743)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end23, %if.then6, %if.then
  %38 = load i32, ptr %retval, align 4
  ret i32 %38
}

; Function Attrs: nounwind uwtable
define i32 @ssl_log_secret(ptr noundef %sc, ptr noundef %label, ptr noundef %secret, i64 noundef %secret_len) #0 {
entry:
  %sc.addr = alloca ptr, align 8
  %label.addr = alloca ptr, align 8
  %secret.addr = alloca ptr, align 8
  %secret_len.addr = alloca i64, align 8
  store ptr %sc, ptr %sc.addr, align 8
  store ptr %label, ptr %label.addr, align 8
  store ptr %secret, ptr %secret.addr, align 8
  store i64 %secret_len, ptr %secret_len.addr, align 8
  %0 = load ptr, ptr %label.addr, align 8
  %1 = load ptr, ptr %sc.addr, align 8
  %2 = load ptr, ptr %sc.addr, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 20
  %client_random = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 2
  %arraydecay = getelementptr inbounds [32 x i8], ptr %client_random, i64 0, i64 0
  %3 = load ptr, ptr %secret.addr, align 8
  %4 = load i64, ptr %secret_len.addr, align 8
  %call = call i32 @nss_keylog_int(ptr noundef %0, ptr noundef %1, ptr noundef %arraydecay, i64 noundef 32, ptr noundef %3, i64 noundef %4)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @ssl_cache_cipherlist(ptr noundef %s, ptr noundef %cipher_suites, i32 noundef %sslv2format) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %cipher_suites.addr = alloca ptr, align 8
  %sslv2format.addr = alloca i32, align 4
  %n = alloca i32, align 4
  %numciphers = alloca i64, align 8
  %sslv2ciphers = alloca %struct.PACKET, align 8
  %leadbyte = alloca i32, align 4
  %raw = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %cipher_suites, ptr %cipher_suites.addr, align 8
  store i32 %sslv2format, ptr %sslv2format.addr, align 4
  %0 = load i32, ptr %sslv2format.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, i32 3, i32 2
  store i32 %cond, ptr %n, align 4
  %1 = load ptr, ptr %cipher_suites.addr, align 8
  %call = call i64 @PACKET_remaining(ptr noundef %1)
  %cmp = icmp eq i64 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6790, ptr noundef @__func__.ssl_cache_cipherlist)
  %2 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %2, i32 noundef 47, i32 noundef 183, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %cipher_suites.addr, align 8
  %call1 = call i64 @PACKET_remaining(ptr noundef %3)
  %4 = load i32, ptr %n, align 4
  %conv = sext i32 %4 to i64
  %rem = urem i64 %call1, %conv
  %cmp2 = icmp ne i64 %rem, 0
  br i1 %cmp2, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6795, ptr noundef @__func__.ssl_cache_cipherlist)
  %5 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %5, i32 noundef 50, i32 noundef 151, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %6 = load ptr, ptr %s.addr, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 20
  %tmp = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 14
  %ciphers_raw = getelementptr inbounds %struct.anon.0, ptr %tmp, i32 0, i32 20
  %7 = load ptr, ptr %ciphers_raw, align 8
  call void @CRYPTO_free(ptr noundef %7, ptr noundef @.str, i32 noundef 6799)
  %8 = load ptr, ptr %s.addr, align 8
  %s36 = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 20
  %tmp7 = getelementptr inbounds %struct.anon, ptr %s36, i32 0, i32 14
  %ciphers_raw8 = getelementptr inbounds %struct.anon.0, ptr %tmp7, i32 0, i32 20
  store ptr null, ptr %ciphers_raw8, align 8
  %9 = load ptr, ptr %s.addr, align 8
  %s39 = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 20
  %tmp10 = getelementptr inbounds %struct.anon, ptr %s39, i32 0, i32 14
  %ciphers_rawlen = getelementptr inbounds %struct.anon.0, ptr %tmp10, i32 0, i32 21
  store i64 0, ptr %ciphers_rawlen, align 8
  %10 = load i32, ptr %sslv2format.addr, align 4
  %tobool11 = icmp ne i32 %10, 0
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end5
  %11 = load ptr, ptr %cipher_suites.addr, align 8
  %call13 = call i64 @PACKET_remaining(ptr noundef %11)
  %12 = load i32, ptr %n, align 4
  %conv14 = sext i32 %12 to i64
  %div = udiv i64 %call13, %conv14
  store i64 %div, ptr %numciphers, align 8
  %13 = load ptr, ptr %cipher_suites.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %sslv2ciphers, ptr align 8 %13, i64 16, i1 false)
  %14 = load i64, ptr %numciphers, align 8
  %mul = mul i64 %14, 2
  %call15 = call noalias ptr @CRYPTO_malloc(i64 noundef %mul, ptr noundef @.str, i32 noundef 6816)
  store ptr %call15, ptr %raw, align 8
  %15 = load ptr, ptr %raw, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %s316 = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 20
  %tmp17 = getelementptr inbounds %struct.anon, ptr %s316, i32 0, i32 14
  %ciphers_raw18 = getelementptr inbounds %struct.anon.0, ptr %tmp17, i32 0, i32 20
  store ptr %15, ptr %ciphers_raw18, align 8
  %17 = load ptr, ptr %raw, align 8
  %cmp19 = icmp eq ptr %17, null
  br i1 %cmp19, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.then12
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6819, ptr noundef @__func__.ssl_cache_cipherlist)
  %18 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %18, i32 noundef 80, i32 noundef 524303, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.then12
  %19 = load ptr, ptr %s.addr, align 8
  %s323 = getelementptr inbounds %struct.ssl_connection_st, ptr %19, i32 0, i32 20
  %tmp24 = getelementptr inbounds %struct.anon, ptr %s323, i32 0, i32 14
  %ciphers_rawlen25 = getelementptr inbounds %struct.anon.0, ptr %tmp24, i32 0, i32 21
  store i64 0, ptr %ciphers_rawlen25, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end22
  %call26 = call i64 @PACKET_remaining(ptr noundef %sslv2ciphers)
  %cmp27 = icmp ugt i64 %call26, 0
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call29 = call i32 @PACKET_get_1(ptr noundef %sslv2ciphers, ptr noundef %leadbyte)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %lor.lhs.false, label %if.then41

lor.lhs.false:                                    ; preds = %for.body
  %20 = load i32, ptr %leadbyte, align 4
  %cmp31 = icmp eq i32 %20, 0
  br i1 %cmp31, label %land.lhs.true, label %lor.lhs.false35

land.lhs.true:                                    ; preds = %lor.lhs.false
  %21 = load ptr, ptr %raw, align 8
  %call33 = call i32 @PACKET_copy_bytes(ptr noundef %sslv2ciphers, ptr noundef %21, i64 noundef 2)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %lor.lhs.false35, label %if.then41

lor.lhs.false35:                                  ; preds = %land.lhs.true, %lor.lhs.false
  %22 = load i32, ptr %leadbyte, align 4
  %cmp36 = icmp ne i32 %22, 0
  br i1 %cmp36, label %land.lhs.true38, label %if.end51

land.lhs.true38:                                  ; preds = %lor.lhs.false35
  %call39 = call i32 @PACKET_forward(ptr noundef %sslv2ciphers, i64 noundef 2)
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.end51, label %if.then41

if.then41:                                        ; preds = %land.lhs.true38, %land.lhs.true, %for.body
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6831, ptr noundef @__func__.ssl_cache_cipherlist)
  %23 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %23, i32 noundef 50, i32 noundef 240, ptr noundef null)
  %24 = load ptr, ptr %s.addr, align 8
  %s342 = getelementptr inbounds %struct.ssl_connection_st, ptr %24, i32 0, i32 20
  %tmp43 = getelementptr inbounds %struct.anon, ptr %s342, i32 0, i32 14
  %ciphers_raw44 = getelementptr inbounds %struct.anon.0, ptr %tmp43, i32 0, i32 20
  %25 = load ptr, ptr %ciphers_raw44, align 8
  call void @CRYPTO_free(ptr noundef %25, ptr noundef @.str, i32 noundef 6832)
  %26 = load ptr, ptr %s.addr, align 8
  %s345 = getelementptr inbounds %struct.ssl_connection_st, ptr %26, i32 0, i32 20
  %tmp46 = getelementptr inbounds %struct.anon, ptr %s345, i32 0, i32 14
  %ciphers_raw47 = getelementptr inbounds %struct.anon.0, ptr %tmp46, i32 0, i32 20
  store ptr null, ptr %ciphers_raw47, align 8
  %27 = load ptr, ptr %s.addr, align 8
  %s348 = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 20
  %tmp49 = getelementptr inbounds %struct.anon, ptr %s348, i32 0, i32 14
  %ciphers_rawlen50 = getelementptr inbounds %struct.anon.0, ptr %tmp49, i32 0, i32 21
  store i64 0, ptr %ciphers_rawlen50, align 8
  store i32 0, ptr %retval, align 4
  br label %return

if.end51:                                         ; preds = %land.lhs.true38, %lor.lhs.false35
  %28 = load i32, ptr %leadbyte, align 4
  %cmp52 = icmp eq i32 %28, 0
  br i1 %cmp52, label %if.then54, label %if.end58

if.then54:                                        ; preds = %if.end51
  %29 = load ptr, ptr %s.addr, align 8
  %s355 = getelementptr inbounds %struct.ssl_connection_st, ptr %29, i32 0, i32 20
  %tmp56 = getelementptr inbounds %struct.anon, ptr %s355, i32 0, i32 14
  %ciphers_rawlen57 = getelementptr inbounds %struct.anon.0, ptr %tmp56, i32 0, i32 21
  %30 = load i64, ptr %ciphers_rawlen57, align 8
  %add = add i64 %30, 2
  store i64 %add, ptr %ciphers_rawlen57, align 8
  br label %if.end58

if.end58:                                         ; preds = %if.then54, %if.end51
  br label %for.inc

for.inc:                                          ; preds = %if.end58
  %31 = load ptr, ptr %raw, align 8
  %add.ptr = getelementptr inbounds i8, ptr %31, i64 2
  store ptr %add.ptr, ptr %raw, align 8
  br label %for.cond, !llvm.loop !30

for.end:                                          ; preds = %for.cond
  br label %if.end69

if.else:                                          ; preds = %if.end5
  %32 = load ptr, ptr %cipher_suites.addr, align 8
  %33 = load ptr, ptr %s.addr, align 8
  %s359 = getelementptr inbounds %struct.ssl_connection_st, ptr %33, i32 0, i32 20
  %tmp60 = getelementptr inbounds %struct.anon, ptr %s359, i32 0, i32 14
  %ciphers_raw61 = getelementptr inbounds %struct.anon.0, ptr %tmp60, i32 0, i32 20
  %34 = load ptr, ptr %s.addr, align 8
  %s362 = getelementptr inbounds %struct.ssl_connection_st, ptr %34, i32 0, i32 20
  %tmp63 = getelementptr inbounds %struct.anon, ptr %s362, i32 0, i32 14
  %ciphers_rawlen64 = getelementptr inbounds %struct.anon.0, ptr %tmp63, i32 0, i32 21
  %call65 = call i32 @PACKET_memdup(ptr noundef %32, ptr noundef %ciphers_raw61, ptr noundef %ciphers_rawlen64)
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.end68, label %if.then67

if.then67:                                        ; preds = %if.else
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6842, ptr noundef @__func__.ssl_cache_cipherlist)
  %35 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %35, i32 noundef 80, i32 noundef 786691, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end68:                                         ; preds = %if.else
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %for.end
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end69, %if.then67, %if.then41, %if.then21, %if.then4, %if.then
  %36 = load i32, ptr %retval, align 4
  ret i32 %36
}

; Function Attrs: nounwind uwtable
define internal i32 @PACKET_get_1(ptr noundef %pkt, ptr noundef %data) #0 {
entry:
  %retval = alloca i32, align 4
  %pkt.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  store ptr %pkt, ptr %pkt.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr %pkt.addr, align 8
  %1 = load ptr, ptr %data.addr, align 8
  %call = call i32 @PACKET_peek_1(ptr noundef %0, ptr noundef %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %pkt.addr, align 8
  call void @packet_forward(ptr noundef %2, i64 noundef 1)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i32, ptr %retval, align 4
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal i32 @PACKET_copy_bytes(ptr noundef %pkt, ptr noundef %data, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %pkt.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %pkt, ptr %pkt.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %pkt.addr, align 8
  %1 = load ptr, ptr %data.addr, align 8
  %2 = load i64, ptr %len.addr, align 8
  %call = call i32 @PACKET_peek_copy_bytes(ptr noundef %0, ptr noundef %1, i64 noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %pkt.addr, align 8
  %4 = load i64, ptr %len.addr, align 8
  call void @packet_forward(ptr noundef %3, i64 noundef %4)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal i32 @PACKET_forward(ptr noundef %pkt, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %pkt.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %pkt, ptr %pkt.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %pkt.addr, align 8
  %call = call i64 @PACKET_remaining(ptr noundef %0)
  %1 = load i64, ptr %len.addr, align 8
  %cmp = icmp ult i64 %call, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %pkt.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  call void @packet_forward(ptr noundef %2, i64 noundef %3)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @PACKET_memdup(ptr noundef %pkt, ptr noundef %data, ptr noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %pkt.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %length = alloca i64, align 8
  store ptr %pkt, ptr %pkt.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  %1 = load ptr, ptr %0, align 8
  call void @CRYPTO_free(ptr noundef %1, ptr noundef @.str.16, i32 noundef 454)
  %2 = load ptr, ptr %data.addr, align 8
  store ptr null, ptr %2, align 8
  %3 = load ptr, ptr %len.addr, align 8
  store i64 0, ptr %3, align 8
  %4 = load ptr, ptr %pkt.addr, align 8
  %call = call i64 @PACKET_remaining(ptr noundef %4)
  store i64 %call, ptr %length, align 8
  %5 = load i64, ptr %length, align 8
  %cmp = icmp eq i64 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %pkt.addr, align 8
  %curr = getelementptr inbounds %struct.PACKET, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %curr, align 8
  %8 = load i64, ptr %length, align 8
  %call1 = call noalias ptr @CRYPTO_memdup(ptr noundef %7, i64 noundef %8, ptr noundef @.str.16, i32 noundef 463)
  %9 = load ptr, ptr %data.addr, align 8
  store ptr %call1, ptr %9, align 8
  %10 = load ptr, ptr %data.addr, align 8
  %11 = load ptr, ptr %10, align 8
  %cmp2 = icmp eq ptr %11, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %12 = load i64, ptr %length, align 8
  %13 = load ptr, ptr %len.addr, align 8
  store i64 %12, ptr %13, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define i32 @SSL_bytes_to_cipher_list(ptr noundef %s, ptr noundef %bytes, i64 noundef %len, i32 noundef %isv2format, ptr noundef %sk, ptr noundef %scsvs) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %bytes.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %isv2format.addr = alloca i32, align 4
  %sk.addr = alloca ptr, align 8
  %scsvs.addr = alloca ptr, align 8
  %pkt = alloca %struct.PACKET, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %bytes, ptr %bytes.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 %isv2format, ptr %isv2format.addr, align 4
  store ptr %sk, ptr %sk.addr, align 8
  store ptr %scsvs, ptr %scsvs.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %bytes.addr, align 8
  %10 = load i64, ptr %len.addr, align 8
  %call = call i32 @PACKET_buf_init(ptr noundef %pkt, ptr noundef %9, i64 noundef %10)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end
  %11 = load ptr, ptr %sc, align 8
  %12 = load ptr, ptr %sk.addr, align 8
  %13 = load ptr, ptr %scsvs.addr, align 8
  %14 = load i32, ptr %isv2format.addr, align 4
  %call15 = call i32 @ossl_bytes_to_cipher_list(ptr noundef %11, ptr noundef %pkt, ptr noundef %12, ptr noundef %13, i32 noundef %14, i32 noundef 0)
  store i32 %call15, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then13, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define internal i32 @PACKET_buf_init(ptr noundef %pkt, ptr noundef %buf, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %pkt.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %pkt, ptr %pkt.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %len.addr, align 8
  %cmp = icmp ugt i64 %0, 9223372036854775807
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %buf.addr, align 8
  %2 = load ptr, ptr %pkt.addr, align 8
  %curr = getelementptr inbounds %struct.PACKET, ptr %2, i32 0, i32 0
  store ptr %1, ptr %curr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %4 = load ptr, ptr %pkt.addr, align 8
  %remaining = getelementptr inbounds %struct.PACKET, ptr %4, i32 0, i32 1
  store i64 %3, ptr %remaining, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define i32 @ossl_bytes_to_cipher_list(ptr noundef %s, ptr noundef %cipher_suites, ptr noundef %skp, ptr noundef %scsvs_out, i32 noundef %sslv2format, i32 noundef %fatal) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %cipher_suites.addr = alloca ptr, align 8
  %skp.addr = alloca ptr, align 8
  %scsvs_out.addr = alloca ptr, align 8
  %sslv2format.addr = alloca i32, align 4
  %fatal.addr = alloca i32, align 4
  %c = alloca ptr, align 8
  %sk = alloca ptr, align 8
  %scsvs = alloca ptr, align 8
  %n = alloca i32, align 4
  %cipher = alloca [3 x i8], align 1
  store ptr %s, ptr %s.addr, align 8
  store ptr %cipher_suites, ptr %cipher_suites.addr, align 8
  store ptr %skp, ptr %skp.addr, align 8
  store ptr %scsvs_out, ptr %scsvs_out.addr, align 8
  store i32 %sslv2format, ptr %sslv2format.addr, align 4
  store i32 %fatal, ptr %fatal.addr, align 4
  store ptr null, ptr %sk, align 8
  store ptr null, ptr %scsvs, align 8
  %0 = load i32, ptr %sslv2format.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, i32 3, i32 2
  store i32 %cond, ptr %n, align 4
  %1 = load ptr, ptr %cipher_suites.addr, align 8
  %call = call i64 @PACKET_remaining(ptr noundef %1)
  %cmp = icmp eq i64 %call, 0
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %2 = load i32, ptr %fatal.addr, align 4
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6879, ptr noundef @__func__.ossl_bytes_to_cipher_list)
  %3 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %3, i32 noundef 47, i32 noundef 183, ptr noundef null)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6881, ptr noundef @__func__.ossl_bytes_to_cipher_list)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 183, ptr noundef null)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then2
  store i32 0, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %entry
  %4 = load ptr, ptr %cipher_suites.addr, align 8
  %call4 = call i64 @PACKET_remaining(ptr noundef %4)
  %5 = load i32, ptr %n, align 4
  %conv = sext i32 %5 to i64
  %rem = urem i64 %call4, %conv
  %cmp5 = icmp ne i64 %rem, 0
  br i1 %cmp5, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end3
  %6 = load i32, ptr %fatal.addr, align 4
  %tobool8 = icmp ne i32 %6, 0
  br i1 %tobool8, label %if.then9, label %if.else10

if.then9:                                         ; preds = %if.then7
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6888, ptr noundef @__func__.ossl_bytes_to_cipher_list)
  %7 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %7, i32 noundef 50, i32 noundef 151, ptr noundef null)
  br label %if.end11

if.else10:                                        ; preds = %if.then7
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6890, ptr noundef @__func__.ossl_bytes_to_cipher_list)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 151, ptr noundef null)
  br label %if.end11

if.end11:                                         ; preds = %if.else10, %if.then9
  store i32 0, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %if.end3
  %call13 = call ptr @OPENSSL_sk_new_null()
  store ptr %call13, ptr %sk, align 8
  %call14 = call ptr @OPENSSL_sk_new_null()
  store ptr %call14, ptr %scsvs, align 8
  %8 = load ptr, ptr %sk, align 8
  %cmp15 = icmp eq ptr %8, null
  br i1 %cmp15, label %if.then19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end12
  %9 = load ptr, ptr %scsvs, align 8
  %cmp17 = icmp eq ptr %9, null
  br i1 %cmp17, label %if.then19, label %if.end24

if.then19:                                        ; preds = %lor.lhs.false, %if.end12
  %10 = load i32, ptr %fatal.addr, align 4
  %tobool20 = icmp ne i32 %10, 0
  br i1 %tobool20, label %if.then21, label %if.else22

if.then21:                                        ; preds = %if.then19
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6898, ptr noundef @__func__.ossl_bytes_to_cipher_list)
  %11 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %11, i32 noundef 80, i32 noundef 524303, ptr noundef null)
  br label %if.end23

if.else22:                                        ; preds = %if.then19
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6900, ptr noundef @__func__.ossl_bytes_to_cipher_list)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  br label %if.end23

if.end23:                                         ; preds = %if.else22, %if.then21
  br label %err

if.end24:                                         ; preds = %lor.lhs.false
  br label %while.cond

while.cond:                                       ; preds = %if.end62, %if.then32, %if.end24
  %12 = load ptr, ptr %cipher_suites.addr, align 8
  %arraydecay = getelementptr inbounds [3 x i8], ptr %cipher, i64 0, i64 0
  %13 = load i32, ptr %n, align 4
  %conv25 = sext i32 %13 to i64
  %call26 = call i32 @PACKET_copy_bytes(ptr noundef %12, ptr noundef %arraydecay, i64 noundef %conv25)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %14 = load i32, ptr %sslv2format.addr, align 4
  %tobool28 = icmp ne i32 %14, 0
  br i1 %tobool28, label %land.lhs.true, label %if.end33

land.lhs.true:                                    ; preds = %while.body
  %arrayidx = getelementptr inbounds [3 x i8], ptr %cipher, i64 0, i64 0
  %15 = load i8, ptr %arrayidx, align 1
  %conv29 = zext i8 %15 to i32
  %cmp30 = icmp ne i32 %conv29, 0
  br i1 %cmp30, label %if.then32, label %if.end33

if.then32:                                        ; preds = %land.lhs.true
  br label %while.cond, !llvm.loop !31

if.end33:                                         ; preds = %land.lhs.true, %while.body
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i32, ptr %sslv2format.addr, align 4
  %tobool34 = icmp ne i32 %17, 0
  br i1 %tobool34, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end33
  %arrayidx35 = getelementptr inbounds [3 x i8], ptr %cipher, i64 0, i64 1
  br label %cond.end

cond.false:                                       ; preds = %if.end33
  %arraydecay36 = getelementptr inbounds [3 x i8], ptr %cipher, i64 0, i64 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond37 = phi ptr [ %arrayidx35, %cond.true ], [ %arraydecay36, %cond.false ]
  %call38 = call ptr @ssl_get_cipher_by_char(ptr noundef %16, ptr noundef %cond37, i32 noundef 1)
  store ptr %call38, ptr %c, align 8
  %18 = load ptr, ptr %c, align 8
  %cmp39 = icmp ne ptr %18, null
  br i1 %cmp39, label %if.then41, label %if.end62

if.then41:                                        ; preds = %cond.end
  %19 = load ptr, ptr %c, align 8
  %valid = getelementptr inbounds %struct.ssl_cipher_st, ptr %19, i32 0, i32 0
  %20 = load i32, ptr %valid, align 8
  %tobool42 = icmp ne i32 %20, 0
  br i1 %tobool42, label %land.lhs.true43, label %lor.lhs.false48

land.lhs.true43:                                  ; preds = %if.then41
  %21 = load ptr, ptr %sk, align 8
  %call44 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %21)
  %22 = load ptr, ptr %c, align 8
  %call45 = call ptr @ossl_check_SSL_CIPHER_type(ptr noundef %22)
  %call46 = call i32 @OPENSSL_sk_push(ptr noundef %call44, ptr noundef %call45)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %lor.lhs.false48, label %if.then56

lor.lhs.false48:                                  ; preds = %land.lhs.true43, %if.then41
  %23 = load ptr, ptr %c, align 8
  %valid49 = getelementptr inbounds %struct.ssl_cipher_st, ptr %23, i32 0, i32 0
  %24 = load i32, ptr %valid49, align 8
  %tobool50 = icmp ne i32 %24, 0
  br i1 %tobool50, label %if.end61, label %land.lhs.true51

land.lhs.true51:                                  ; preds = %lor.lhs.false48
  %25 = load ptr, ptr %scsvs, align 8
  %call52 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %25)
  %26 = load ptr, ptr %c, align 8
  %call53 = call ptr @ossl_check_SSL_CIPHER_type(ptr noundef %26)
  %call54 = call i32 @OPENSSL_sk_push(ptr noundef %call52, ptr noundef %call53)
  %tobool55 = icmp ne i32 %call54, 0
  br i1 %tobool55, label %if.end61, label %if.then56

if.then56:                                        ; preds = %land.lhs.true51, %land.lhs.true43
  %27 = load i32, ptr %fatal.addr, align 4
  %tobool57 = icmp ne i32 %27, 0
  br i1 %tobool57, label %if.then58, label %if.else59

if.then58:                                        ; preds = %if.then56
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6919, ptr noundef @__func__.ossl_bytes_to_cipher_list)
  %28 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %28, i32 noundef 80, i32 noundef 524303, ptr noundef null)
  br label %if.end60

if.else59:                                        ; preds = %if.then56
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6921, ptr noundef @__func__.ossl_bytes_to_cipher_list)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  br label %if.end60

if.end60:                                         ; preds = %if.else59, %if.then58
  br label %err

if.end61:                                         ; preds = %land.lhs.true51, %lor.lhs.false48
  br label %if.end62

if.end62:                                         ; preds = %if.end61, %cond.end
  br label %while.cond, !llvm.loop !31

while.end:                                        ; preds = %while.cond
  %29 = load ptr, ptr %cipher_suites.addr, align 8
  %call63 = call i64 @PACKET_remaining(ptr noundef %29)
  %cmp64 = icmp ugt i64 %call63, 0
  br i1 %cmp64, label %if.then66, label %if.end71

if.then66:                                        ; preds = %while.end
  %30 = load i32, ptr %fatal.addr, align 4
  %tobool67 = icmp ne i32 %30, 0
  br i1 %tobool67, label %if.then68, label %if.else69

if.then68:                                        ; preds = %if.then66
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6928, ptr noundef @__func__.ossl_bytes_to_cipher_list)
  %31 = load ptr, ptr %s.addr, align 8
  call void (ptr, i32, i32, ptr, ...) @ossl_statem_fatal(ptr noundef %31, i32 noundef 50, i32 noundef 271, ptr noundef null)
  br label %if.end70

if.else69:                                        ; preds = %if.then66
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6930, ptr noundef @__func__.ossl_bytes_to_cipher_list)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 271, ptr noundef null)
  br label %if.end70

if.end70:                                         ; preds = %if.else69, %if.then68
  br label %err

if.end71:                                         ; preds = %while.end
  %32 = load ptr, ptr %skp.addr, align 8
  %cmp72 = icmp ne ptr %32, null
  br i1 %cmp72, label %if.then74, label %if.else75

if.then74:                                        ; preds = %if.end71
  %33 = load ptr, ptr %sk, align 8
  %34 = load ptr, ptr %skp.addr, align 8
  store ptr %33, ptr %34, align 8
  br label %if.end77

if.else75:                                        ; preds = %if.end71
  %35 = load ptr, ptr %sk, align 8
  %call76 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %35)
  call void @OPENSSL_sk_free(ptr noundef %call76)
  br label %if.end77

if.end77:                                         ; preds = %if.else75, %if.then74
  %36 = load ptr, ptr %scsvs_out.addr, align 8
  %cmp78 = icmp ne ptr %36, null
  br i1 %cmp78, label %if.then80, label %if.else81

if.then80:                                        ; preds = %if.end77
  %37 = load ptr, ptr %scsvs, align 8
  %38 = load ptr, ptr %scsvs_out.addr, align 8
  store ptr %37, ptr %38, align 8
  br label %if.end83

if.else81:                                        ; preds = %if.end77
  %39 = load ptr, ptr %scsvs, align 8
  %call82 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %39)
  call void @OPENSSL_sk_free(ptr noundef %call82)
  br label %if.end83

if.end83:                                         ; preds = %if.else81, %if.then80
  store i32 1, ptr %retval, align 4
  br label %return

err:                                              ; preds = %if.end70, %if.end60, %if.end23
  %40 = load ptr, ptr %sk, align 8
  %call84 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %40)
  call void @OPENSSL_sk_free(ptr noundef %call84)
  %41 = load ptr, ptr %scsvs, align 8
  %call85 = call ptr @ossl_check_SSL_CIPHER_sk_type(ptr noundef %41)
  call void @OPENSSL_sk_free(ptr noundef %call85)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %err, %if.end83, %if.end11, %if.end
  %42 = load i32, ptr %retval, align 4
  ret i32 %42
}

declare ptr @ssl_get_cipher_by_char(ptr noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_max_early_data(ptr noundef %ctx, i32 noundef %max_early_data) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %max_early_data.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %max_early_data, ptr %max_early_data.addr, align 4
  %0 = load i32, ptr %max_early_data.addr, align 4
  %1 = load ptr, ptr %ctx.addr, align 8
  %max_early_data1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 72
  store i32 %0, ptr %max_early_data1, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_get_max_early_data(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %max_early_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 72
  %1 = load i32, ptr %max_early_data, align 8
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_max_early_data(ptr noundef %s, i32 noundef %max_early_data) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %max_early_data.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %max_early_data, ptr %max_early_data.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load i32, ptr %max_early_data.addr, align 4
  %6 = load ptr, ptr %sc, align 8
  %max_early_data7 = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 106
  store i32 %5, ptr %max_early_data7, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_max_early_data(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %max_early_data = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 106
  %10 = load i32, ptr %max_early_data, align 8
  store i32 %10, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_recv_max_early_data(ptr noundef %ctx, i32 noundef %recv_max_early_data) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %recv_max_early_data.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %recv_max_early_data, ptr %recv_max_early_data.addr, align 4
  %0 = load i32, ptr %recv_max_early_data.addr, align 4
  %1 = load ptr, ptr %ctx.addr, align 8
  %recv_max_early_data1 = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 73
  store i32 %0, ptr %recv_max_early_data1, align 4
  ret i32 1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_get_recv_max_early_data(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %recv_max_early_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 73
  %1 = load i32, ptr %recv_max_early_data, align 4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set_recv_max_early_data(ptr noundef %s, i32 noundef %recv_max_early_data) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %recv_max_early_data.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %recv_max_early_data, ptr %recv_max_early_data.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load i32, ptr %recv_max_early_data.addr, align 4
  %6 = load ptr, ptr %sc, align 8
  %recv_max_early_data7 = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 107
  store i32 %5, ptr %recv_max_early_data7, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_recv_max_early_data(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %recv_max_early_data = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 107
  %10 = load i32, ptr %recv_max_early_data, align 4
  store i32 %10, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @ssl_get_max_send_fragment(ptr noundef %sc) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca ptr, align 8
  store ptr %sc, ptr %sc.addr, align 8
  %0 = load ptr, ptr %sc.addr, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 50
  %1 = load ptr, ptr %session, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %sc.addr, align 8
  %session1 = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 50
  %3 = load ptr, ptr %session1, align 8
  %ext = getelementptr inbounds %struct.ssl_session_st, ptr %3, i32 0, i32 26
  %max_fragment_len_mode = getelementptr inbounds %struct.anon.5, ptr %ext, i32 0, i32 8
  %4 = load i8, ptr %max_fragment_len_mode, align 8
  %conv = zext i8 %4 to i32
  %cmp2 = icmp sge i32 %conv, 1
  br i1 %cmp2, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %5 = load ptr, ptr %sc.addr, align 8
  %session5 = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 50
  %6 = load ptr, ptr %session5, align 8
  %ext6 = getelementptr inbounds %struct.ssl_session_st, ptr %6, i32 0, i32 26
  %max_fragment_len_mode7 = getelementptr inbounds %struct.anon.5, ptr %ext6, i32 0, i32 8
  %7 = load i8, ptr %max_fragment_len_mode7, align 8
  %conv8 = zext i8 %7 to i32
  %cmp9 = icmp sle i32 %conv8, 4
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true4
  %8 = load ptr, ptr %sc.addr, align 8
  %session11 = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 50
  %9 = load ptr, ptr %session11, align 8
  %ext12 = getelementptr inbounds %struct.ssl_session_st, ptr %9, i32 0, i32 26
  %max_fragment_len_mode13 = getelementptr inbounds %struct.anon.5, ptr %ext12, i32 0, i32 8
  %10 = load i8, ptr %max_fragment_len_mode13, align 8
  %conv14 = zext i8 %10 to i32
  %sub = sub nsw i32 %conv14, 1
  %shl = shl i32 512, %sub
  store i32 %shl, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true4, %land.lhs.true, %entry
  %11 = load ptr, ptr %sc.addr, align 8
  %max_send_fragment = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 78
  %12 = load i64, ptr %max_send_fragment, align 8
  %conv15 = trunc i64 %12 to i32
  store i32 %conv15, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind uwtable
define i32 @ssl_get_split_send_fragment(ptr noundef %sc) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca ptr, align 8
  store ptr %sc, ptr %sc.addr, align 8
  %0 = load ptr, ptr %sc.addr, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 50
  %1 = load ptr, ptr %session, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %sc.addr, align 8
  %session1 = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 50
  %3 = load ptr, ptr %session1, align 8
  %ext = getelementptr inbounds %struct.ssl_session_st, ptr %3, i32 0, i32 26
  %max_fragment_len_mode = getelementptr inbounds %struct.anon.5, ptr %ext, i32 0, i32 8
  %4 = load i8, ptr %max_fragment_len_mode, align 8
  %conv = zext i8 %4 to i32
  %cmp2 = icmp sge i32 %conv, 1
  br i1 %cmp2, label %land.lhs.true4, label %if.end

land.lhs.true4:                                   ; preds = %land.lhs.true
  %5 = load ptr, ptr %sc.addr, align 8
  %session5 = getelementptr inbounds %struct.ssl_connection_st, ptr %5, i32 0, i32 50
  %6 = load ptr, ptr %session5, align 8
  %ext6 = getelementptr inbounds %struct.ssl_session_st, ptr %6, i32 0, i32 26
  %max_fragment_len_mode7 = getelementptr inbounds %struct.anon.5, ptr %ext6, i32 0, i32 8
  %7 = load i8, ptr %max_fragment_len_mode7, align 8
  %conv8 = zext i8 %7 to i32
  %cmp9 = icmp sle i32 %conv8, 4
  br i1 %cmp9, label %land.lhs.true11, label %if.end

land.lhs.true11:                                  ; preds = %land.lhs.true4
  %8 = load ptr, ptr %sc.addr, align 8
  %split_send_fragment = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 77
  %9 = load i64, ptr %split_send_fragment, align 8
  %10 = load ptr, ptr %sc.addr, align 8
  %session12 = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 50
  %11 = load ptr, ptr %session12, align 8
  %ext13 = getelementptr inbounds %struct.ssl_session_st, ptr %11, i32 0, i32 26
  %max_fragment_len_mode14 = getelementptr inbounds %struct.anon.5, ptr %ext13, i32 0, i32 8
  %12 = load i8, ptr %max_fragment_len_mode14, align 8
  %conv15 = zext i8 %12 to i32
  %sub = sub nsw i32 %conv15, 1
  %shl = shl i32 512, %sub
  %conv16 = zext i32 %shl to i64
  %cmp17 = icmp ugt i64 %9, %conv16
  br i1 %cmp17, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true11
  %13 = load ptr, ptr %sc.addr, align 8
  %session19 = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 50
  %14 = load ptr, ptr %session19, align 8
  %ext20 = getelementptr inbounds %struct.ssl_session_st, ptr %14, i32 0, i32 26
  %max_fragment_len_mode21 = getelementptr inbounds %struct.anon.5, ptr %ext20, i32 0, i32 8
  %15 = load i8, ptr %max_fragment_len_mode21, align 8
  %conv22 = zext i8 %15 to i32
  %sub23 = sub nsw i32 %conv22, 1
  %shl24 = shl i32 512, %sub23
  store i32 %shl24, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true11, %land.lhs.true4, %land.lhs.true, %entry
  %16 = load ptr, ptr %sc.addr, align 8
  %split_send_fragment25 = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 77
  %17 = load i64, ptr %split_send_fragment25, align 8
  %18 = load ptr, ptr %sc.addr, align 8
  %max_send_fragment = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 78
  %19 = load i64, ptr %max_send_fragment, align 8
  %cmp26 = icmp ugt i64 %17, %19
  br i1 %cmp26, label %if.then28, label %if.end31

if.then28:                                        ; preds = %if.end
  %20 = load ptr, ptr %sc.addr, align 8
  %max_send_fragment29 = getelementptr inbounds %struct.ssl_connection_st, ptr %20, i32 0, i32 78
  %21 = load i64, ptr %max_send_fragment29, align 8
  %conv30 = trunc i64 %21 to i32
  store i32 %conv30, ptr %retval, align 4
  br label %return

if.end31:                                         ; preds = %if.end
  %22 = load ptr, ptr %sc.addr, align 8
  %split_send_fragment32 = getelementptr inbounds %struct.ssl_connection_st, ptr %22, i32 0, i32 77
  %23 = load i64, ptr %split_send_fragment32, align 8
  %conv33 = trunc i64 %23 to i32
  store i32 %conv33, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end31, %if.then28, %if.then
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define i32 @SSL_stateless(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @SSL_clear(ptr noundef %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  call void @ERR_clear_error()
  %6 = load ptr, ptr %sc, align 8
  %s3 = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 20
  %flags = getelementptr inbounds %struct.anon, ptr %s3, i32 0, i32 0
  %7 = load i64, ptr %flags, align 8
  %or = or i64 %7, 2048
  store i64 %or, ptr %flags, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %call9 = call i32 @SSL_accept(ptr noundef %8)
  store i32 %call9, ptr %ret, align 4
  %9 = load ptr, ptr %sc, align 8
  %s310 = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 20
  %flags11 = getelementptr inbounds %struct.anon, ptr %s310, i32 0, i32 0
  %10 = load i64, ptr %flags11, align 8
  %and = and i64 %10, -2049
  store i64 %and, ptr %flags11, align 8
  %11 = load i32, ptr %ret, align 4
  %cmp12 = icmp sgt i32 %11, 0
  br i1 %cmp12, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.end8
  %12 = load ptr, ptr %sc, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 80
  %cookieok = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 34
  %13 = load i32, ptr %cookieok, align 8
  %tobool13 = icmp ne i32 %13, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %land.lhs.true, %if.end8
  %14 = load ptr, ptr %sc, align 8
  %hello_retry_request = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 47
  %15 = load i32, ptr %hello_retry_request, align 8
  %cmp16 = icmp eq i32 %15, 1
  br i1 %cmp16, label %land.lhs.true17, label %if.end21

land.lhs.true17:                                  ; preds = %if.end15
  %16 = load ptr, ptr %sc, align 8
  %call18 = call i32 @ossl_statem_in_error(ptr noundef %16)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %land.lhs.true17
  store i32 0, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %land.lhs.true17, %if.end15
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end21, %if.then20, %if.then14, %if.then7, %if.then
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

declare void @ERR_clear_error() #1

declare i32 @ossl_statem_in_error(ptr noundef) #1

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_post_handshake_auth(ptr noundef %ctx, i32 noundef %val) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %val.addr = alloca i32, align 4
  store ptr %ctx, ptr %ctx.addr, align 8
  store i32 %val, ptr %val.addr, align 4
  %0 = load i32, ptr %val.addr, align 4
  %1 = load ptr, ptr %ctx.addr, align 8
  %pha_enabled = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 83
  store i32 %0, ptr %pha_enabled, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_set_post_handshake_auth(ptr noundef %ssl, i32 noundef %val) #0 {
entry:
  %ssl.addr = alloca ptr, align 8
  %val.addr = alloca i32, align 4
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store i32 %val, ptr %val.addr, align 4
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load i32, ptr %val.addr, align 4
  %6 = load ptr, ptr %sc, align 8
  %pha_enabled = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 93
  store i32 %5, ptr %pha_enabled, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @SSL_verify_client_post_handshake(ptr noundef %ssl) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %ssl.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %ssl.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %ssl.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %ssl.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %ssl.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %ssl.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7090, ptr noundef @__func__.SSL_verify_client_post_handshake)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 266, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %13 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %13, null
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end19:                                         ; preds = %if.end
  %14 = load ptr, ptr %sc, align 8
  %ssl20 = getelementptr inbounds %struct.ssl_connection_st, ptr %14, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl20, i32 0, i32 3
  %15 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %15, i32 0, i32 28
  %16 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %16, i32 0, i32 10
  %17 = load i32, ptr %enc_flags, align 8
  %and = and i32 %17, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then30, label %land.lhs.true21

land.lhs.true21:                                  ; preds = %if.end19
  %18 = load ptr, ptr %sc, align 8
  %ssl22 = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 0
  %method23 = getelementptr inbounds %struct.ssl_st, ptr %ssl22, i32 0, i32 3
  %19 = load ptr, ptr %method23, align 8
  %version = getelementptr inbounds %struct.ssl_method_st, ptr %19, i32 0, i32 0
  %20 = load i32, ptr %version, align 8
  %cmp24 = icmp sge i32 %20, 772
  br i1 %cmp24, label %land.lhs.true25, label %if.then30

land.lhs.true25:                                  ; preds = %land.lhs.true21
  %21 = load ptr, ptr %sc, align 8
  %ssl26 = getelementptr inbounds %struct.ssl_connection_st, ptr %21, i32 0, i32 0
  %method27 = getelementptr inbounds %struct.ssl_st, ptr %ssl26, i32 0, i32 3
  %22 = load ptr, ptr %method27, align 8
  %version28 = getelementptr inbounds %struct.ssl_method_st, ptr %22, i32 0, i32 0
  %23 = load i32, ptr %version28, align 8
  %cmp29 = icmp ne i32 %23, 65536
  br i1 %cmp29, label %if.end31, label %if.then30

if.then30:                                        ; preds = %land.lhs.true25, %land.lhs.true21, %if.end19
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7099, ptr noundef @__func__.SSL_verify_client_post_handshake)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 266, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end31:                                         ; preds = %land.lhs.true25
  %24 = load ptr, ptr %sc, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %24, i32 0, i32 7
  %25 = load i32, ptr %server, align 8
  %tobool32 = icmp ne i32 %25, 0
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.end31
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7103, ptr noundef @__func__.SSL_verify_client_post_handshake)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 284, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.end31
  %26 = load ptr, ptr %ssl.addr, align 8
  %call = call i32 @SSL_is_init_finished(ptr noundef %26)
  %tobool35 = icmp ne i32 %call, 0
  br i1 %tobool35, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.end34
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7108, ptr noundef @__func__.SSL_verify_client_post_handshake)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 121, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end37:                                         ; preds = %if.end34
  %27 = load ptr, ptr %sc, align 8
  %post_handshake_auth = getelementptr inbounds %struct.ssl_connection_st, ptr %27, i32 0, i32 92
  %28 = load i32, ptr %post_handshake_auth, align 8
  switch i32 %28, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb38
    i32 2, label %sw.bb39
    i32 3, label %sw.bb40
    i32 4, label %sw.bb41
  ]

sw.bb:                                            ; preds = %if.end37
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7114, ptr noundef @__func__.SSL_verify_client_post_handshake)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 279, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %if.end37
  br label %sw.bb38

sw.bb38:                                          ; preds = %sw.default, %if.end37
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7118, ptr noundef @__func__.SSL_verify_client_post_handshake)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 786691, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb39:                                          ; preds = %if.end37
  br label %sw.epilog

sw.bb40:                                          ; preds = %if.end37
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7123, ptr noundef @__func__.SSL_verify_client_post_handshake)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 285, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb41:                                          ; preds = %if.end37
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7126, ptr noundef @__func__.SSL_verify_client_post_handshake)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 286, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb39
  %29 = load ptr, ptr %sc, align 8
  %post_handshake_auth42 = getelementptr inbounds %struct.ssl_connection_st, ptr %29, i32 0, i32 92
  store i32 3, ptr %post_handshake_auth42, align 8
  %30 = load ptr, ptr %sc, align 8
  %call43 = call i32 @send_certificate_request(ptr noundef %30)
  %tobool44 = icmp ne i32 %call43, 0
  br i1 %tobool44, label %if.end47, label %if.then45

if.then45:                                        ; preds = %sw.epilog
  %31 = load ptr, ptr %sc, align 8
  %post_handshake_auth46 = getelementptr inbounds %struct.ssl_connection_st, ptr %31, i32 0, i32 92
  store i32 2, ptr %post_handshake_auth46, align 8
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7135, ptr noundef @__func__.SSL_verify_client_post_handshake)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 283, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end47:                                         ; preds = %sw.epilog
  %32 = load ptr, ptr %sc, align 8
  call void @ossl_statem_set_in_init(ptr noundef %32, i32 noundef 1)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end47, %if.then45, %sw.bb41, %sw.bb40, %sw.bb38, %sw.bb, %if.then36, %if.then33, %if.then30, %if.then18, %if.then
  %33 = load i32, ptr %retval, align 4
  ret i32 %33
}

declare i32 @send_certificate_request(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set_session_ticket_cb(ptr noundef %ctx, ptr noundef %gen_cb, ptr noundef %dec_cb, ptr noundef %arg) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %gen_cb.addr = alloca ptr, align 8
  %dec_cb.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %gen_cb, ptr %gen_cb.addr, align 8
  store ptr %dec_cb, ptr %dec_cb.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %gen_cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %generate_ticket_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 77
  store ptr %0, ptr %generate_ticket_cb, align 8
  %2 = load ptr, ptr %dec_cb.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %decrypt_ticket_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 78
  store ptr %2, ptr %decrypt_ticket_cb, align 8
  %4 = load ptr, ptr %arg.addr, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %ticket_cb_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 79
  store ptr %4, ptr %ticket_cb_data, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define void @SSL_CTX_set_allow_early_data_cb(ptr noundef %ctx, ptr noundef %cb, ptr noundef %arg) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %cb.addr, align 8
  %1 = load ptr, ptr %ctx.addr, align 8
  %allow_early_data_cb = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 81
  store ptr %0, ptr %allow_early_data_cb, align 8
  %2 = load ptr, ptr %arg.addr, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %allow_early_data_cb_data = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 82
  store ptr %2, ptr %allow_early_data_cb_data, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @SSL_set_allow_early_data_cb(ptr noundef %s, ptr noundef %cb, ptr noundef %arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cb.addr = alloca ptr, align 8
  %arg.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %cb, ptr %cb.addr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end4

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false3:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false3, %cond.true2
  %cond = phi ptr [ %3, %cond.true2 ], [ null, %cond.false3 ]
  br label %cond.end4

cond.end4:                                        ; preds = %cond.end, %cond.true
  %cond5 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond5, ptr %sc, align 8
  %4 = load ptr, ptr %sc, align 8
  %cmp6 = icmp eq ptr %4, null
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end4
  br label %return

if.end:                                           ; preds = %cond.end4
  %5 = load ptr, ptr %cb.addr, align 8
  %6 = load ptr, ptr %sc, align 8
  %allow_early_data_cb = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 112
  store ptr %5, ptr %allow_early_data_cb, align 8
  %7 = load ptr, ptr %arg.addr, align 8
  %8 = load ptr, ptr %sc, align 8
  %allow_early_data_cb_data = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 113
  store ptr %7, ptr %allow_early_data_cb_data, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define ptr @ssl_evp_cipher_fetch(ptr noundef %libctx, i32 noundef %nid, ptr noundef %properties) #0 {
entry:
  %retval = alloca ptr, align 8
  %libctx.addr = alloca ptr, align 8
  %nid.addr = alloca i32, align 4
  %properties.addr = alloca ptr, align 8
  %ciph = alloca ptr, align 8
  store ptr %libctx, ptr %libctx.addr, align 8
  store i32 %nid, ptr %nid.addr, align 4
  store ptr %properties, ptr %properties.addr, align 8
  %0 = load i32, ptr %nid.addr, align 4
  %call = call ptr @tls_get_cipher_from_engine(i32 noundef %0)
  store ptr %call, ptr %ciph, align 8
  %1 = load ptr, ptr %ciph, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %ciph, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call i32 @ERR_set_mark()
  %3 = load ptr, ptr %libctx.addr, align 8
  %4 = load i32, ptr %nid.addr, align 4
  %call2 = call ptr @OBJ_nid2sn(i32 noundef %4)
  %5 = load ptr, ptr %properties.addr, align 8
  %call3 = call ptr @EVP_CIPHER_fetch(ptr noundef %3, ptr noundef %call2, ptr noundef %5)
  store ptr %call3, ptr %ciph, align 8
  %call4 = call i32 @ERR_pop_to_mark()
  %6 = load ptr, ptr %ciph, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

declare ptr @tls_get_cipher_from_engine(i32 noundef) #1

declare ptr @EVP_CIPHER_fetch(ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @OBJ_nid2sn(i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @ssl_evp_cipher_up_ref(ptr noundef %cipher) #0 {
entry:
  %retval = alloca i32, align 4
  %cipher.addr = alloca ptr, align 8
  store ptr %cipher, ptr %cipher.addr, align 8
  %0 = load ptr, ptr %cipher.addr, align 8
  %call = call ptr @EVP_CIPHER_get0_provider(ptr noundef %0)
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %cipher.addr, align 8
  %call1 = call i32 @EVP_CIPHER_up_ref(ptr noundef %1)
  store i32 %call1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

declare ptr @EVP_CIPHER_get0_provider(ptr noundef) #1

declare i32 @EVP_CIPHER_up_ref(ptr noundef) #1

declare void @EVP_CIPHER_free(ptr noundef) #1

declare ptr @tls_get_digest_from_engine(i32 noundef) #1

declare ptr @EVP_MD_fetch(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @ssl_evp_md_up_ref(ptr noundef %md) #0 {
entry:
  %retval = alloca i32, align 4
  %md.addr = alloca ptr, align 8
  store ptr %md, ptr %md.addr, align 8
  %0 = load ptr, ptr %md.addr, align 8
  %call = call ptr @EVP_MD_get0_provider(ptr noundef %0)
  %cmp = icmp eq ptr %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %md.addr, align 8
  %call1 = call i32 @EVP_MD_up_ref(ptr noundef %1)
  store i32 %call1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, ptr %retval, align 4
  ret i32 %2
}

declare ptr @EVP_MD_get0_provider(ptr noundef) #1

declare i32 @EVP_MD_up_ref(ptr noundef) #1

declare void @EVP_MD_free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set0_tmp_dh_pkey(ptr noundef %s, ptr noundef %dhpkey) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %dhpkey.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %dhpkey, ptr %dhpkey.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %10 = load ptr, ptr %dhpkey.addr, align 8
  %call = call i32 @EVP_PKEY_get_security_bits(ptr noundef %10)
  %11 = load ptr, ptr %dhpkey.addr, align 8
  %call13 = call i32 @ssl_security(ptr noundef %9, i32 noundef 262151, i32 noundef %call, i32 noundef 0, ptr noundef %11)
  %tobool = icmp ne i32 %call13, 0
  br i1 %tobool, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7276, ptr noundef @__func__.SSL_set0_tmp_dh_pkey)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 394, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end
  %12 = load ptr, ptr %sc, align 8
  %cert = getelementptr inbounds %struct.ssl_connection_st, ptr %12, i32 0, i32 44
  %13 = load ptr, ptr %cert, align 8
  %dh_tmp = getelementptr inbounds %struct.cert_st, ptr %13, i32 0, i32 1
  %14 = load ptr, ptr %dh_tmp, align 8
  call void @EVP_PKEY_free(ptr noundef %14)
  %15 = load ptr, ptr %dhpkey.addr, align 8
  %16 = load ptr, ptr %sc, align 8
  %cert16 = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 44
  %17 = load ptr, ptr %cert16, align 8
  %dh_tmp17 = getelementptr inbounds %struct.cert_st, ptr %17, i32 0, i32 1
  store ptr %15, ptr %dh_tmp17, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then14, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

declare i32 @ssl_security(ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef) #1

declare i32 @EVP_PKEY_get_security_bits(ptr noundef) #1

declare void @EVP_PKEY_free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set0_tmp_dh_pkey(ptr noundef %ctx, ptr noundef %dhpkey) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %dhpkey.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %dhpkey, ptr %dhpkey.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %1 = load ptr, ptr %dhpkey.addr, align 8
  %call = call i32 @EVP_PKEY_get_security_bits(ptr noundef %1)
  %2 = load ptr, ptr %dhpkey.addr, align 8
  %call1 = call i32 @ssl_ctx_security(ptr noundef %0, i32 noundef 262151, i32 noundef %call, i32 noundef 0, ptr noundef %2)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 7288, ptr noundef @__func__.SSL_CTX_set0_tmp_dh_pkey)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 394, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %ctx.addr, align 8
  %cert = getelementptr inbounds %struct.ssl_ctx_st, ptr %3, i32 0, i32 39
  %4 = load ptr, ptr %cert, align 8
  %dh_tmp = getelementptr inbounds %struct.cert_st, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %dh_tmp, align 8
  call void @EVP_PKEY_free(ptr noundef %5)
  %6 = load ptr, ptr %dhpkey.addr, align 8
  %7 = load ptr, ptr %ctx.addr, align 8
  %cert2 = getelementptr inbounds %struct.ssl_ctx_st, ptr %7, i32 0, i32 39
  %8 = load ptr, ptr %cert2, align 8
  %dh_tmp3 = getelementptr inbounds %struct.cert_st, ptr %8, i32 0, i32 1
  store ptr %6, ptr %dh_tmp3, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i32, ptr %retval, align 4
  ret i32 %9
}

declare i32 @ssl_ctx_security(ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_handle_events(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_handle_events(ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %6 = load ptr, ptr %s.addr, align 8
  %cmp4 = icmp eq ptr %6, null
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end9

cond.false:                                       ; preds = %if.end
  %7 = load ptr, ptr %s.addr, align 8
  %type5 = getelementptr inbounds %struct.ssl_st, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %type5, align 8
  %cmp6 = icmp eq i32 %8, 0
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.false
  %9 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false8:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false8, %cond.true7
  %cond = phi ptr [ %9, %cond.true7 ], [ null, %cond.false8 ]
  br label %cond.end9

cond.end9:                                        ; preds = %cond.end, %cond.true
  %cond10 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond10, ptr %sc, align 8
  %10 = load ptr, ptr %sc, align 8
  %cmp11 = icmp ne ptr %10, null
  br i1 %cmp11, label %land.lhs.true12, label %if.end16

land.lhs.true12:                                  ; preds = %cond.end9
  %11 = load ptr, ptr %sc, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %12 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %12, i32 0, i32 28
  %13 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %13, i32 0, i32 10
  %14 = load i32, ptr %enc_flags, align 8
  %and = and i32 %14, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then13, label %if.end16

if.then13:                                        ; preds = %land.lhs.true12
  %15 = load ptr, ptr %s.addr, align 8
  %call14 = call i64 @SSL_ctrl(ptr noundef %15, i32 noundef 74, i64 noundef 0, ptr noundef null)
  %cmp15 = icmp sge i64 %call14, 0
  %conv = zext i1 %cmp15 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %land.lhs.true12, %cond.end9
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end16, %if.then13, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

declare i32 @ossl_quic_handle_events(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_event_timeout(ptr noundef %s, ptr noundef %tv, ptr noundef %is_infinite) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %tv.addr = alloca ptr, align 8
  %is_infinite.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %tv, ptr %tv.addr, align 8
  store ptr %is_infinite, ptr %is_infinite.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %tv.addr, align 8
  %7 = load ptr, ptr %is_infinite.addr, align 8
  %call = call i32 @ossl_quic_get_event_timeout(ptr noundef %5, ptr noundef %6, ptr noundef %7)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %entry
  %8 = load ptr, ptr %s.addr, align 8
  %cmp4 = icmp eq ptr %8, null
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end9

cond.false:                                       ; preds = %if.end
  %9 = load ptr, ptr %s.addr, align 8
  %type5 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type5, align 8
  %cmp6 = icmp eq i32 %10, 0
  br i1 %cmp6, label %cond.true7, label %cond.false8

cond.true7:                                       ; preds = %cond.false
  %11 = load ptr, ptr %s.addr, align 8
  br label %cond.end

cond.false8:                                      ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false8, %cond.true7
  %cond = phi ptr [ %11, %cond.true7 ], [ null, %cond.false8 ]
  br label %cond.end9

cond.end9:                                        ; preds = %cond.end, %cond.true
  %cond10 = phi ptr [ null, %cond.true ], [ %cond, %cond.end ]
  store ptr %cond10, ptr %sc, align 8
  %12 = load ptr, ptr %sc, align 8
  %cmp11 = icmp ne ptr %12, null
  br i1 %cmp11, label %land.lhs.true12, label %if.end17

land.lhs.true12:                                  ; preds = %cond.end9
  %13 = load ptr, ptr %sc, align 8
  %ssl = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 0
  %method = getelementptr inbounds %struct.ssl_st, ptr %ssl, i32 0, i32 3
  %14 = load ptr, ptr %method, align 8
  %ssl3_enc = getelementptr inbounds %struct.ssl_method_st, ptr %14, i32 0, i32 28
  %15 = load ptr, ptr %ssl3_enc, align 8
  %enc_flags = getelementptr inbounds %struct.ssl3_enc_method, ptr %15, i32 0, i32 10
  %16 = load i32, ptr %enc_flags, align 8
  %and = and i32 %16, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true13, label %if.end17

land.lhs.true13:                                  ; preds = %land.lhs.true12
  %17 = load ptr, ptr %s.addr, align 8
  %18 = load ptr, ptr %tv.addr, align 8
  %call14 = call i64 @SSL_ctrl(ptr noundef %17, i32 noundef 73, i64 noundef 0, ptr noundef %18)
  %tobool15 = icmp ne i64 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true13
  %19 = load ptr, ptr %is_infinite.addr, align 8
  store i32 0, ptr %19, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %land.lhs.true13, %land.lhs.true12, %cond.end9
  %20 = load ptr, ptr %tv.addr, align 8
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %20, i32 0, i32 0
  store i64 1000000, ptr %tv_sec, align 8
  %21 = load ptr, ptr %tv.addr, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %21, i32 0, i32 1
  store i64 0, ptr %tv_usec, align 8
  %22 = load ptr, ptr %is_infinite.addr, align 8
  store i32 1, ptr %22, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end17, %if.then16, %if.then
  %23 = load i32, ptr %retval, align 4
  ret i32 %23
}

declare i32 @ossl_quic_get_event_timeout(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_rpoll_descriptor(ptr noundef %s, ptr noundef %desc) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %desc.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %desc, ptr %desc.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load ptr, ptr %desc.addr, align 8
  %call = call i32 @ossl_quic_get_rpoll_descriptor(ptr noundef %13, ptr noundef %14)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %15 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %15, null
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %if.end
  %16 = load ptr, ptr %sc, align 8
  %rbio = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %rbio, align 8
  %cmp19 = icmp eq ptr %17, null
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false18, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %lor.lhs.false18
  %18 = load ptr, ptr %sc, align 8
  %rbio22 = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 2
  %19 = load ptr, ptr %rbio22, align 8
  %20 = load ptr, ptr %desc.addr, align 8
  %call23 = call i32 @BIO_get_rpoll_descriptor(ptr noundef %19, ptr noundef %20)
  store i32 %call23, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end21, %if.then20, %if.then
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

declare i32 @ossl_quic_get_rpoll_descriptor(ptr noundef, ptr noundef) #1

declare i32 @BIO_get_rpoll_descriptor(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_wpoll_descriptor(ptr noundef %s, ptr noundef %desc) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %desc.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %desc, ptr %desc.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %cmp12 = icmp ne ptr %8, null
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %s.addr, align 8
  %type13 = getelementptr inbounds %struct.ssl_st, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %type13, align 8
  %cmp14 = icmp eq i32 %10, 1
  br i1 %cmp14, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %11 = load ptr, ptr %s.addr, align 8
  %type15 = getelementptr inbounds %struct.ssl_st, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %type15, align 8
  %cmp16 = icmp eq i32 %12, 2
  br i1 %cmp16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load ptr, ptr %desc.addr, align 8
  %call = call i32 @ossl_quic_get_wpoll_descriptor(ptr noundef %13, ptr noundef %14)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %cond.end10
  %15 = load ptr, ptr %sc, align 8
  %cmp17 = icmp eq ptr %15, null
  br i1 %cmp17, label %if.then20, label %lor.lhs.false18

lor.lhs.false18:                                  ; preds = %if.end
  %16 = load ptr, ptr %sc, align 8
  %wbio = getelementptr inbounds %struct.ssl_connection_st, ptr %16, i32 0, i32 3
  %17 = load ptr, ptr %wbio, align 8
  %cmp19 = icmp eq ptr %17, null
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %lor.lhs.false18, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %lor.lhs.false18
  %18 = load ptr, ptr %sc, align 8
  %wbio22 = getelementptr inbounds %struct.ssl_connection_st, ptr %18, i32 0, i32 3
  %19 = load ptr, ptr %wbio22, align 8
  %20 = load ptr, ptr %desc.addr, align 8
  %call23 = call i32 @BIO_get_wpoll_descriptor(ptr noundef %19, ptr noundef %20)
  store i32 %call23, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end21, %if.then20, %if.then
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

declare i32 @ossl_quic_get_wpoll_descriptor(ptr noundef, ptr noundef) #1

declare i32 @BIO_get_wpoll_descriptor(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_net_read_desired(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @SSL_want(ptr noundef %5)
  %cmp4 = icmp eq i32 %call, 3
  %conv = zext i1 %cmp4 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %6 = load ptr, ptr %s.addr, align 8
  %call5 = call i32 @ossl_quic_get_net_read_desired(ptr noundef %6)
  store i32 %call5, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i32 @ossl_quic_get_net_read_desired(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_net_write_desired(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @SSL_want(ptr noundef %5)
  %cmp4 = icmp eq i32 %call, 2
  %conv = zext i1 %cmp4 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %6 = load ptr, ptr %s.addr, align 8
  %call5 = call i32 @ossl_quic_get_net_write_desired(ptr noundef %6)
  store i32 %call5, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i32 @ossl_quic_get_net_write_desired(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set_blocking_mode(ptr noundef %s, i32 noundef %blocking) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %blocking.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %blocking, ptr %blocking.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i32, ptr %blocking.addr, align 4
  %call = call i32 @ossl_quic_conn_set_blocking_mode(ptr noundef %5, i32 noundef %6)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i32 @ossl_quic_conn_set_blocking_mode(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_blocking_mode(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_conn_get_blocking_mode(ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare i32 @ossl_quic_conn_get_blocking_mode(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set1_initial_peer_addr(ptr noundef %s, ptr noundef %peer_addr) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %peer_addr.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %peer_addr, ptr %peer_addr.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %peer_addr.addr, align 8
  %call = call i32 @ossl_quic_conn_set_initial_peer_addr(ptr noundef %5, ptr noundef %6)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i32 @ossl_quic_conn_set_initial_peer_addr(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_shutdown_ex(ptr noundef %ssl, i64 noundef %flags, ptr noundef %args, i64 noundef %args_len) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  %args.addr = alloca ptr, align 8
  %args_len.addr = alloca i64, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %args_len, ptr %args_len.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %ssl.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load ptr, ptr %ssl.addr, align 8
  %call = call i32 @SSL_shutdown(ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %6 = load ptr, ptr %ssl.addr, align 8
  %7 = load i64, ptr %flags.addr, align 8
  %8 = load ptr, ptr %args.addr, align 8
  %9 = load i64, ptr %args_len.addr, align 8
  %call4 = call i32 @ossl_quic_conn_shutdown(ptr noundef %6, i64 noundef %7, ptr noundef %8, i64 noundef %9)
  store i32 %call4, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define i32 @SSL_stream_conclude(ptr noundef %ssl, i64 noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %ssl.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  store ptr %ssl, ptr %ssl.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %ssl.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %ssl.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %ssl.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %ssl.addr, align 8
  %call = call i32 @ossl_quic_conn_stream_conclude(ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare i32 @ossl_quic_conn_stream_conclude(ptr noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_new_stream(ptr noundef %s, i64 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i64, ptr %flags.addr, align 8
  %call = call ptr @ossl_quic_conn_stream_new(ptr noundef %5, i64 noundef %6)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

declare ptr @ossl_quic_conn_stream_new(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_get0_connection(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load ptr, ptr %s.addr, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %6 = load ptr, ptr %s.addr, align 8
  %call = call ptr @ossl_quic_get0_connection(ptr noundef %6)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

declare ptr @ossl_quic_get0_connection(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_is_connection(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get0_connection(ptr noundef %0)
  %1 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %call, %1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_stream_type(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 3, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_get_stream_type(ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare i32 @ossl_quic_get_stream_type(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i64 @SSL_get_stream_id(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 -1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i64 @ossl_quic_get_stream_id(ptr noundef %5)
  store i64 %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i64, ptr %retval, align 8
  ret i64 %6
}

declare i64 @ossl_quic_get_stream_id(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_is_stream_local(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_is_stream_local(ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare i32 @ossl_quic_is_stream_local(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set_default_stream_mode(ptr noundef %s, i32 noundef %mode) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %mode.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %mode, ptr %mode.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i32, ptr %mode.addr, align 4
  %call = call i32 @ossl_quic_set_default_stream_mode(ptr noundef %5, i32 noundef %6)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i32 @ossl_quic_set_default_stream_mode(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_set_incoming_stream_policy(ptr noundef %s, i32 noundef %policy, i64 noundef %aec) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %policy.addr = alloca i32, align 4
  %aec.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %policy, ptr %policy.addr, align 4
  store i64 %aec, ptr %aec.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i32, ptr %policy.addr, align 4
  %7 = load i64, ptr %aec.addr, align 8
  %call = call i32 @ossl_quic_set_incoming_stream_policy(ptr noundef %5, i32 noundef %6, i64 noundef %7)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

declare i32 @ossl_quic_set_incoming_stream_policy(ptr noundef, i32 noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_accept_stream(ptr noundef %s, i64 noundef %flags) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %flags.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i64, ptr %flags.addr, align 8
  %call = call ptr @ossl_quic_accept_stream(ptr noundef %5, i64 noundef %6)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load ptr, ptr %retval, align 8
  ret ptr %7
}

declare ptr @ossl_quic_accept_stream(ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define i64 @SSL_get_accept_stream_queue_len(ptr noundef %s) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 0, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i64 @ossl_quic_get_accept_stream_queue_len(ptr noundef %5)
  store i64 %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i64, ptr %retval, align 8
  ret i64 %6
}

declare i64 @ossl_quic_get_accept_stream_queue_len(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_stream_reset(ptr noundef %s, ptr noundef %args, i64 noundef %args_len) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %args_len.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i64 %args_len, ptr %args_len.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %args.addr, align 8
  %7 = load i64, ptr %args_len.addr, align 8
  %call = call i32 @ossl_quic_stream_reset(ptr noundef %5, ptr noundef %6, i64 noundef %7)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

declare i32 @ossl_quic_stream_reset(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_stream_read_state(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_get_stream_read_state(ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare i32 @ossl_quic_get_stream_read_state(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_stream_write_state(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %call = call i32 @ossl_quic_get_stream_write_state(ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

declare i32 @ossl_quic_get_stream_write_state(ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_stream_read_error_code(ptr noundef %s, ptr noundef %app_error_code) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %app_error_code.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %app_error_code, ptr %app_error_code.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %app_error_code.addr, align 8
  %call = call i32 @ossl_quic_get_stream_read_error_code(ptr noundef %5, ptr noundef %6)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i32 @ossl_quic_get_stream_read_error_code(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_stream_write_error_code(ptr noundef %s, ptr noundef %app_error_code) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %app_error_code.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %app_error_code, ptr %app_error_code.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %app_error_code.addr, align 8
  %call = call i32 @ossl_quic_get_stream_write_error_code(ptr noundef %5, ptr noundef %6)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

declare i32 @ossl_quic_get_stream_write_error_code(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_get_conn_close_info(ptr noundef %s, ptr noundef %info, i64 noundef %info_len) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %info.addr = alloca ptr, align 8
  %info_len.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %info, ptr %info.addr, align 8
  store i64 %info_len, ptr %info_len.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load ptr, ptr %s.addr, align 8
  %type2 = getelementptr inbounds %struct.ssl_st, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %type2, align 8
  %cmp3 = icmp eq i32 %4, 2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %info.addr, align 8
  %7 = load i64, ptr %info_len.addr, align 8
  %call = call i32 @ossl_quic_get_conn_close_info(ptr noundef %5, ptr noundef %6, i64 noundef %7)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

declare i32 @ossl_quic_get_conn_close_info(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define i32 @SSL_add_expected_rpk(ptr noundef %s, ptr noundef %rpk) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %rpk.addr = alloca ptr, align 8
  %data = alloca ptr, align 8
  %dane = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %rpk, ptr %rpk.addr, align 8
  store ptr null, ptr %data, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @SSL_get0_dane(ptr noundef %0)
  store ptr %call, ptr %dane, align 8
  %1 = load ptr, ptr %dane, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load ptr, ptr %dane, align 8
  %dctx = getelementptr inbounds %struct.ssl_dane_st, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %dctx, align 8
  %cmp1 = icmp eq ptr %3, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %rpk.addr, align 8
  %call2 = call i32 @i2d_PUBKEY(ptr noundef %4, ptr noundef %data)
  store i32 %call2, ptr %ret, align 4
  %cmp3 = icmp sle i32 %call2, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %data, align 8
  %7 = load i32, ptr %ret, align 4
  %conv = sext i32 %7 to i64
  %call6 = call i32 @SSL_dane_tlsa_add(ptr noundef %5, i8 noundef zeroext 3, i8 noundef zeroext 1, i8 noundef zeroext 0, ptr noundef %6, i64 noundef %conv)
  %cmp7 = icmp sgt i32 %call6, 0
  %conv8 = zext i1 %cmp7 to i32
  store i32 %conv8, ptr %ret, align 4
  %8 = load ptr, ptr %data, align 8
  call void @CRYPTO_free(ptr noundef %8, ptr noundef @.str, i32 noundef 7662)
  %9 = load i32, ptr %ret, align 4
  store i32 %9, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then4, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

declare i32 @i2d_PUBKEY(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define ptr @SSL_get0_peer_rpk(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %session = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 50
  %10 = load ptr, ptr %session, align 8
  %cmp13 = icmp eq ptr %10, null
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %11 = load ptr, ptr %sc, align 8
  %session14 = getelementptr inbounds %struct.ssl_connection_st, ptr %11, i32 0, i32 50
  %12 = load ptr, ptr %session14, align 8
  %peer_rpk = getelementptr inbounds %struct.ssl_session_st, ptr %12, i32 0, i32 11
  %13 = load ptr, ptr %peer_rpk, align 8
  store ptr %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_negotiated_client_cert_type(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 80
  %client_cert_type = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 39
  %10 = load i8, ptr %client_cert_type, align 8
  %conv = zext i8 %10 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get_negotiated_server_cert_type(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %9 = load ptr, ptr %sc, align 8
  %ext = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 80
  %server_cert_type = getelementptr inbounds %struct.anon.1, ptr %ext, i32 0, i32 41
  %10 = load i8, ptr %server_cert_type, align 2
  %conv = zext i8 %10 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set1_client_cert_type(ptr noundef %s, ptr noundef %val, i64 noundef %len) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %client_cert_type = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 118
  %9 = load ptr, ptr %sc, align 8
  %client_cert_type_len = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 119
  %10 = load ptr, ptr %val.addr, align 8
  %11 = load i64, ptr %len.addr, align 8
  %call = call i32 @set_cert_type(ptr noundef %client_cert_type, ptr noundef %client_cert_type_len, ptr noundef %10, i64 noundef %11)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @set_cert_type(ptr noundef %cert_type, ptr noundef %cert_type_len, ptr noundef %val, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %cert_type.addr = alloca ptr, align 8
  %cert_type_len.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %tmp = alloca ptr, align 8
  store ptr %cert_type, ptr %cert_type.addr, align 8
  store ptr %cert_type_len, ptr %cert_type_len.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr null, ptr %tmp, align 8
  %0 = load ptr, ptr %val.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %call = call i32 @validate_cert_type(ptr noundef %0, i64 noundef %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %val.addr, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %3 = load ptr, ptr %val.addr, align 8
  %4 = load i64, ptr %len.addr, align 8
  %call1 = call noalias ptr @CRYPTO_memdup(ptr noundef %3, i64 noundef %4, ptr noundef @.str, i32 noundef 7738)
  store ptr %call1, ptr %tmp, align 8
  %cmp2 = icmp eq ptr %call1, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %if.end
  %5 = load ptr, ptr %cert_type.addr, align 8
  %6 = load ptr, ptr %5, align 8
  call void @CRYPTO_free(ptr noundef %6, ptr noundef @.str, i32 noundef 7741)
  %7 = load ptr, ptr %tmp, align 8
  %8 = load ptr, ptr %cert_type.addr, align 8
  store ptr %7, ptr %8, align 8
  %9 = load i64, ptr %len.addr, align 8
  %10 = load ptr, ptr %cert_type_len.addr, align 8
  store i64 %9, ptr %10, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind uwtable
define i32 @SSL_set1_server_cert_type(ptr noundef %s, ptr noundef %val, i64 noundef %len) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %sc, align 8
  %server_cert_type = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 120
  %9 = load ptr, ptr %sc, align 8
  %server_cert_type_len = getelementptr inbounds %struct.ssl_connection_st, ptr %9, i32 0, i32 121
  %10 = load ptr, ptr %val.addr, align 8
  %11 = load i64, ptr %len.addr, align 8
  %call = call i32 @set_cert_type(ptr noundef %server_cert_type, ptr noundef %server_cert_type_len, ptr noundef %10, i64 noundef %11)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set1_client_cert_type(ptr noundef %ctx, ptr noundef %val, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %client_cert_type = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 104
  %1 = load ptr, ptr %ctx.addr, align 8
  %client_cert_type_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 105
  %2 = load ptr, ptr %val.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %call = call i32 @set_cert_type(ptr noundef %client_cert_type, ptr noundef %client_cert_type_len, ptr noundef %2, i64 noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_set1_server_cert_type(ptr noundef %ctx, ptr noundef %val, i64 noundef %len) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  %val.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %val, ptr %val.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %ctx.addr, align 8
  %server_cert_type = getelementptr inbounds %struct.ssl_ctx_st, ptr %0, i32 0, i32 106
  %1 = load ptr, ptr %ctx.addr, align 8
  %server_cert_type_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %1, i32 0, i32 107
  %2 = load ptr, ptr %val.addr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %call = call i32 @set_cert_type(ptr noundef %server_cert_type, ptr noundef %server_cert_type_len, ptr noundef %2, i64 noundef %3)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get0_client_cert_type(ptr noundef %s, ptr noundef %t, ptr noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %t.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %t, ptr %t.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %t.addr, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %len.addr, align 8
  %cmp13 = icmp eq ptr %9, null
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %10 = load ptr, ptr %sc, align 8
  %client_cert_type = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 118
  %11 = load ptr, ptr %client_cert_type, align 8
  %12 = load ptr, ptr %t.addr, align 8
  store ptr %11, ptr %12, align 8
  %13 = load ptr, ptr %sc, align 8
  %client_cert_type_len = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 119
  %14 = load i64, ptr %client_cert_type_len, align 8
  %15 = load ptr, ptr %len.addr, align 8
  store i64 %14, ptr %15, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define i32 @SSL_get0_server_cert_type(ptr noundef %s, ptr noundef %t, ptr noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %t.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %t, ptr %t.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %1, i32 0, i32 0
  %2 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %2, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %3 = load ptr, ptr %s.addr, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %4 = load ptr, ptr %s.addr, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %5, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %6 = load ptr, ptr %s.addr, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %7, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %3, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %8 = load ptr, ptr %t.addr, align 8
  %cmp12 = icmp eq ptr %8, null
  br i1 %cmp12, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end10
  %9 = load ptr, ptr %len.addr, align 8
  %cmp13 = icmp eq ptr %9, null
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %10 = load ptr, ptr %sc, align 8
  %server_cert_type = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 120
  %11 = load ptr, ptr %server_cert_type, align 8
  %12 = load ptr, ptr %t.addr, align 8
  store ptr %11, ptr %12, align 8
  %13 = load ptr, ptr %sc, align 8
  %server_cert_type_len = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 121
  %14 = load i64, ptr %server_cert_type_len, align 8
  %15 = load ptr, ptr %len.addr, align 8
  store i64 %14, ptr %15, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load i32, ptr %retval, align 4
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_get0_client_cert_type(ptr noundef %ctx, ptr noundef %t, ptr noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %t.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %t, ptr %t.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %t.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %len.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %ctx.addr, align 8
  %client_cert_type = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 104
  %3 = load ptr, ptr %client_cert_type, align 8
  %4 = load ptr, ptr %t.addr, align 8
  store ptr %3, ptr %4, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %client_cert_type_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 105
  %6 = load i64, ptr %client_cert_type_len, align 8
  %7 = load ptr, ptr %len.addr, align 8
  store i64 %6, ptr %7, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define i32 @SSL_CTX_get0_server_cert_type(ptr noundef %ctx, ptr noundef %t, ptr noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %ctx.addr = alloca ptr, align 8
  %t.addr = alloca ptr, align 8
  %len.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %t, ptr %t.addr, align 8
  store ptr %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %t.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %len.addr, align 8
  %cmp1 = icmp eq ptr %1, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load ptr, ptr %ctx.addr, align 8
  %server_cert_type = getelementptr inbounds %struct.ssl_ctx_st, ptr %2, i32 0, i32 106
  %3 = load ptr, ptr %server_cert_type, align 8
  %4 = load ptr, ptr %t.addr, align 8
  store ptr %3, ptr %4, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %server_cert_type_len = getelementptr inbounds %struct.ssl_ctx_st, ptr %5, i32 0, i32 107
  %6 = load i64, ptr %server_cert_type_len, align 8
  %7 = load ptr, ptr %len.addr, align 8
  store i64 %6, ptr %7, align 8
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

declare i32 @ssl_set_new_record_layer(ptr noundef, i32 noundef, i32 noundef, i32 noundef, ptr noundef, i64 noundef, ptr noundef, i64 noundef, ptr noundef, i64 noundef, ptr noundef, i64 noundef, ptr noundef, i64 noundef, i32 noundef, ptr noundef, ptr noundef, ptr noundef) #1

declare ptr @OPENSSL_LH_retrieve(ptr noundef, ptr noundef) #1

declare ptr @EVP_get_digestbyname(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @tlsa_md_get(ptr noundef %dane, i8 noundef zeroext %mtype) #0 {
entry:
  %retval = alloca ptr, align 8
  %dane.addr = alloca ptr, align 8
  %mtype.addr = alloca i8, align 1
  store ptr %dane, ptr %dane.addr, align 8
  store i8 %mtype, ptr %mtype.addr, align 1
  %0 = load i8, ptr %mtype.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load ptr, ptr %dane.addr, align 8
  %dctx = getelementptr inbounds %struct.ssl_dane_st, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %dctx, align 8
  %mdmax = getelementptr inbounds %struct.dane_ctx_st, ptr %2, i32 0, i32 2
  %3 = load i8, ptr %mdmax, align 8
  %conv1 = zext i8 %3 to i32
  %cmp = icmp sgt i32 %conv, %conv1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %dane.addr, align 8
  %dctx3 = getelementptr inbounds %struct.ssl_dane_st, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %dctx3, align 8
  %mdevp = getelementptr inbounds %struct.dane_ctx_st, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %mdevp, align 8
  %7 = load i8, ptr %mtype.addr, align 1
  %idxprom = zext i8 %7 to i64
  %arrayidx = getelementptr inbounds ptr, ptr %6, i64 %idxprom
  %8 = load ptr, ptr %arrayidx, align 8
  store ptr %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind uwtable
define internal void @tlsa_free(ptr noundef %t) #0 {
entry:
  %t.addr = alloca ptr, align 8
  store ptr %t, ptr %t.addr, align 8
  %0 = load ptr, ptr %t.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %t.addr, align 8
  %data = getelementptr inbounds %struct.danetls_record_st, ptr %1, i32 0, i32 3
  %2 = load ptr, ptr %data, align 8
  call void @CRYPTO_free(ptr noundef %2, ptr noundef @.str, i32 noundef 158)
  %3 = load ptr, ptr %t.addr, align 8
  %spki = getelementptr inbounds %struct.danetls_record_st, ptr %3, i32 0, i32 5
  %4 = load ptr, ptr %spki, align 8
  call void @EVP_PKEY_free(ptr noundef %4)
  %5 = load ptr, ptr %t.addr, align 8
  call void @CRYPTO_free(ptr noundef %5, ptr noundef @.str, i32 noundef 160)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare ptr @d2i_X509(ptr noundef, ptr noundef, i64 noundef) #1

declare ptr @X509_get0_pubkey(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_X509_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_X509_type(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  ret ptr %0
}

declare ptr @d2i_PUBKEY(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @sk_danetls_record_value(ptr noundef %sk, i32 noundef %idx) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  store ptr %sk, ptr %sk.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  %0 = load ptr, ptr %sk.addr, align 8
  %1 = load i32, ptr %idx.addr, align 4
  %call = call ptr @OPENSSL_sk_value(ptr noundef %0, i32 noundef %1)
  ret ptr %call
}

; Function Attrs: nounwind uwtable
define internal i32 @sk_danetls_record_insert(ptr noundef %sk, ptr noundef %ptr, i32 noundef %idx) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  %ptr.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  store ptr %sk, ptr %sk.addr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  %0 = load ptr, ptr %sk.addr, align 8
  %1 = load ptr, ptr %ptr.addr, align 8
  %2 = load i32, ptr %idx.addr, align 4
  %call = call i32 @OPENSSL_sk_insert(ptr noundef %0, ptr noundef %1, i32 noundef %2)
  ret i32 %call
}

declare i32 @OPENSSL_sk_insert(ptr noundef, ptr noundef, i32 noundef) #1

declare ptr @CRYPTO_realloc(ptr noundef, i64 noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal void @sk_danetls_record_pop_free(ptr noundef %sk, ptr noundef %freefunc) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  %freefunc.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  store ptr %freefunc, ptr %freefunc.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  %1 = load ptr, ptr %freefunc.addr, align 8
  call void @OPENSSL_sk_pop_free(ptr noundef %0, ptr noundef %1)
  ret void
}

declare ptr @BIO_s_datagram() #1

declare ptr @BIO_s_socket() #1

declare ptr @ASYNC_WAIT_CTX_new() #1

declare i32 @ASYNC_WAIT_CTX_set_callback(ptr noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @ssl_async_wait_ctx_cb(ptr noundef %arg) #0 {
entry:
  %retval = alloca i32, align 4
  %arg.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %sc = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  store ptr %0, ptr %s, align 8
  %1 = load ptr, ptr %s, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end10

cond.false:                                       ; preds = %entry
  %2 = load ptr, ptr %s, align 8
  %type = getelementptr inbounds %struct.ssl_st, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %type, align 8
  %cmp1 = icmp eq i32 %3, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.false
  %4 = load ptr, ptr %s, align 8
  br label %cond.end8

cond.false3:                                      ; preds = %cond.false
  %5 = load ptr, ptr %s, align 8
  %type4 = getelementptr inbounds %struct.ssl_st, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %6, 1
  br i1 %cmp5, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.false3
  %7 = load ptr, ptr %s, align 8
  %tls = getelementptr inbounds %struct.quic_conn_st, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %tls, align 8
  br label %cond.end

cond.false7:                                      ; preds = %cond.false3
  br label %cond.end

cond.end:                                         ; preds = %cond.false7, %cond.true6
  %cond = phi ptr [ %8, %cond.true6 ], [ null, %cond.false7 ]
  br label %cond.end8

cond.end8:                                        ; preds = %cond.end, %cond.true2
  %cond9 = phi ptr [ %4, %cond.true2 ], [ %cond, %cond.end ]
  br label %cond.end10

cond.end10:                                       ; preds = %cond.end8, %cond.true
  %cond11 = phi ptr [ null, %cond.true ], [ %cond9, %cond.end8 ]
  store ptr %cond11, ptr %sc, align 8
  %9 = load ptr, ptr %sc, align 8
  %cmp12 = icmp eq ptr %9, null
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end10
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.end10
  %10 = load ptr, ptr %sc, align 8
  %async_cb = getelementptr inbounds %struct.ssl_connection_st, ptr %10, i32 0, i32 114
  %11 = load ptr, ptr %async_cb, align 8
  %12 = load ptr, ptr %s, align 8
  %13 = load ptr, ptr %sc, align 8
  %async_cb_arg = getelementptr inbounds %struct.ssl_connection_st, ptr %13, i32 0, i32 115
  %14 = load ptr, ptr %async_cb_arg, align 8
  %call = call i32 %11(ptr noundef %12, ptr noundef %14)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

declare i32 @ASYNC_start_job(ptr noundef, ptr noundef, ptr noundef, ptr noundef, ptr noundef, i64 noundef) #1

declare i64 @OPENSSL_LH_num_items(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @ssl_tsan_lock(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @ssl_tsan_unlock(ptr noundef %ctx) #0 {
entry:
  %ctx.addr = alloca ptr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  ret void
}

declare ptr @OPENSSL_LH_new(ptr noundef, ptr noundef) #1

declare void @OPENSSL_LH_free(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @ssl_has_cert_type(ptr noundef %sc, i8 noundef zeroext %ct) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca ptr, align 8
  %ct.addr = alloca i8, align 1
  %ptr = alloca ptr, align 8
  %len = alloca i64, align 8
  store ptr %sc, ptr %sc.addr, align 8
  store i8 %ct, ptr %ct.addr, align 1
  %0 = load ptr, ptr %sc.addr, align 8
  %server = getelementptr inbounds %struct.ssl_connection_st, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %server, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %sc.addr, align 8
  %server_cert_type = getelementptr inbounds %struct.ssl_connection_st, ptr %2, i32 0, i32 120
  %3 = load ptr, ptr %server_cert_type, align 8
  store ptr %3, ptr %ptr, align 8
  %4 = load ptr, ptr %sc.addr, align 8
  %server_cert_type_len = getelementptr inbounds %struct.ssl_connection_st, ptr %4, i32 0, i32 121
  %5 = load i64, ptr %server_cert_type_len, align 8
  store i64 %5, ptr %len, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load ptr, ptr %sc.addr, align 8
  %client_cert_type = getelementptr inbounds %struct.ssl_connection_st, ptr %6, i32 0, i32 118
  %7 = load ptr, ptr %client_cert_type, align 8
  store ptr %7, ptr %ptr, align 8
  %8 = load ptr, ptr %sc.addr, align 8
  %client_cert_type_len = getelementptr inbounds %struct.ssl_connection_st, ptr %8, i32 0, i32 119
  %9 = load i64, ptr %client_cert_type_len, align 8
  store i64 %9, ptr %len, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load ptr, ptr %ptr, align 8
  %cmp = icmp eq ptr %10, null
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %if.end
  %11 = load ptr, ptr %ptr, align 8
  %12 = load i8, ptr %ct.addr, align 1
  %conv = zext i8 %12 to i32
  %13 = load i64, ptr %len, align 8
  %call = call ptr @memchr(ptr noundef %11, i32 noundef %conv, i64 noundef %13) #6
  %cmp3 = icmp ne ptr %call, null
  %conv4 = zext i1 %cmp3 to i32
  store i32 %conv4, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end2, %if.then1
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind willreturn memory(read)
declare ptr @memchr(ptr noundef, i32 noundef, i64 noundef) #4

; Function Attrs: nounwind uwtable
define internal i64 @safe_sub_time(i64 noundef %a, i64 noundef %b, ptr noundef %err) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %err.addr = alloca ptr, align 8
  store i64 %a, ptr %a.addr, align 8
  store i64 %b, ptr %b.addr, align 8
  store ptr %err, ptr %err.addr, align 8
  %0 = load i64, ptr %b.addr, align 8
  %1 = load i64, ptr %a.addr, align 8
  %cmp = icmp ugt i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %err.addr, align 8
  %3 = load i32, ptr %2, align 4
  %or = or i32 %3, 1
  store i32 %or, ptr %2, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i64, ptr %a.addr, align 8
  %5 = load i64, ptr %b.addr, align 8
  %sub = sub i64 %4, %5
  ret i64 %sub
}

; Function Attrs: nounwind uwtable
define internal i64 @ossl_time_zero() #0 {
entry:
  %retval = alloca %struct.OSSL_TIME, align 8
  %call = call i64 @ossl_ticks2time(i64 noundef 0)
  %coerce.dive = getelementptr inbounds %struct.OSSL_TIME, ptr %retval, i32 0, i32 0
  store i64 %call, ptr %coerce.dive, align 8
  %coerce.dive1 = getelementptr inbounds %struct.OSSL_TIME, ptr %retval, i32 0, i32 0
  %0 = load i64, ptr %coerce.dive1, align 8
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define internal i64 @ossl_ticks2time(i64 noundef %ticks) #0 {
entry:
  %retval = alloca %struct.OSSL_TIME, align 8
  %ticks.addr = alloca i64, align 8
  store i64 %ticks, ptr %ticks.addr, align 8
  %0 = load i64, ptr %ticks.addr, align 8
  %t = getelementptr inbounds %struct.OSSL_TIME, ptr %retval, i32 0, i32 0
  store i64 %0, ptr %t, align 8
  %coerce.dive = getelementptr inbounds %struct.OSSL_TIME, ptr %retval, i32 0, i32 0
  %1 = load i64, ptr %coerce.dive, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define internal ptr @sk_danetls_record_new_reserve(ptr noundef %compare, i32 noundef %n) #0 {
entry:
  %compare.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  store ptr %compare, ptr %compare.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load ptr, ptr %compare.addr, align 8
  %1 = load i32, ptr %n.addr, align 4
  %call = call ptr @OPENSSL_sk_new_reserve(ptr noundef %0, i32 noundef %1)
  ret ptr %call
}

declare ptr @OPENSSL_sk_new_reserve(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_const_X509_NAME_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

declare ptr @X509_NAME_dup(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_X509_NAME_type(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  ret ptr %0
}

declare ptr @o2i_SCT_LIST(ptr noundef, ptr noundef, i64 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @ct_move_scts(ptr noundef %dst, ptr noundef %src, i32 noundef %origin) #0 {
entry:
  %retval = alloca i32, align 4
  %dst.addr = alloca ptr, align 8
  %src.addr = alloca ptr, align 8
  %origin.addr = alloca i32, align 4
  %scts_moved = alloca i32, align 4
  %sct = alloca ptr, align 8
  store ptr %dst, ptr %dst.addr, align 8
  store ptr %src, ptr %src.addr, align 8
  store i32 %origin, ptr %origin.addr, align 4
  store i32 0, ptr %scts_moved, align 4
  store ptr null, ptr %sct, align 8
  %0 = load ptr, ptr %dst.addr, align 8
  %1 = load ptr, ptr %0, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  %call = call ptr @OPENSSL_sk_new_null()
  %2 = load ptr, ptr %dst.addr, align 8
  store ptr %call, ptr %2, align 8
  %3 = load ptr, ptr %dst.addr, align 8
  %4 = load ptr, ptr %3, align 8
  %cmp1 = icmp eq ptr %4, null
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  call void @ERR_new()
  call void @ERR_set_debug(ptr noundef @.str, i32 noundef 6082, ptr noundef @__func__.ct_move_scts)
  call void (i32, i32, ptr, ...) @ERR_set_error(i32 noundef 20, i32 noundef 524303, ptr noundef null)
  br label %err

if.end:                                           ; preds = %if.then
  br label %if.end3

if.end3:                                          ; preds = %if.end, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end15, %if.end3
  %5 = load ptr, ptr %src.addr, align 8
  %call4 = call ptr @ossl_check_SCT_sk_type(ptr noundef %5)
  %call5 = call ptr @OPENSSL_sk_pop(ptr noundef %call4)
  store ptr %call5, ptr %sct, align 8
  %cmp6 = icmp ne ptr %call5, null
  br i1 %cmp6, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load ptr, ptr %sct, align 8
  %7 = load i32, ptr %origin.addr, align 4
  %call7 = call i32 @SCT_set_source(ptr noundef %6, i32 noundef %7)
  %cmp8 = icmp ne i32 %call7, 1
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %while.body
  br label %err

if.end10:                                         ; preds = %while.body
  %8 = load ptr, ptr %dst.addr, align 8
  %9 = load ptr, ptr %8, align 8
  %call11 = call ptr @ossl_check_SCT_sk_type(ptr noundef %9)
  %10 = load ptr, ptr %sct, align 8
  %call12 = call ptr @ossl_check_SCT_type(ptr noundef %10)
  %call13 = call i32 @OPENSSL_sk_push(ptr noundef %call11, ptr noundef %call12)
  %tobool = icmp ne i32 %call13, 0
  br i1 %tobool, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end10
  br label %err

if.end15:                                         ; preds = %if.end10
  %11 = load i32, ptr %scts_moved, align 4
  %add = add nsw i32 %11, 1
  store i32 %add, ptr %scts_moved, align 4
  br label %while.cond, !llvm.loop !32

while.end:                                        ; preds = %while.cond
  %12 = load i32, ptr %scts_moved, align 4
  store i32 %12, ptr %retval, align 4
  br label %return

err:                                              ; preds = %if.then14, %if.then9, %if.then2
  %13 = load ptr, ptr %sct, align 8
  call void @SCT_free(ptr noundef %13)
  store i32 -1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %err, %while.end
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

declare ptr @OPENSSL_sk_pop(ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_SCT_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

declare i32 @SCT_set_source(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_SCT_type(ptr noundef %ptr) #0 {
entry:
  %ptr.addr = alloca ptr, align 8
  store ptr %ptr, ptr %ptr.addr, align 8
  %0 = load ptr, ptr %ptr.addr, align 8
  ret ptr %0
}

declare void @SCT_free(ptr noundef) #1

declare ptr @d2i_OCSP_RESPONSE(ptr noundef, ptr noundef, i64 noundef) #1

declare ptr @OCSP_response_get1_basic(ptr noundef) #1

declare i32 @OCSP_resp_count(ptr noundef) #1

declare ptr @OCSP_resp_get0(ptr noundef, i32 noundef) #1

declare ptr @OCSP_SINGLERESP_get1_ext_d2i(ptr noundef, i32 noundef, ptr noundef, ptr noundef) #1

declare void @OCSP_BASICRESP_free(ptr noundef) #1

declare void @OCSP_RESPONSE_free(ptr noundef) #1

declare ptr @X509_get_ext_d2i(ptr noundef, i32 noundef, ptr noundef, ptr noundef) #1

; Function Attrs: nounwind uwtable
define internal ptr @ossl_check_const_SCT_sk_type(ptr noundef %sk) #0 {
entry:
  %sk.addr = alloca ptr, align 8
  store ptr %sk, ptr %sk.addr, align 8
  %0 = load ptr, ptr %sk.addr, align 8
  ret ptr %0
}

declare i32 @SCT_get_validation_status(ptr noundef) #1

; Function Attrs: nounwind
declare ptr @strcpy(ptr noundef, ptr noundef) #5

; Function Attrs: nounwind
declare i32 @sprintf(ptr noundef, ptr noundef, ...) #5

declare void @CRYPTO_clear_free(ptr noundef, i64 noundef, ptr noundef, i32 noundef) #1

; Function Attrs: nounwind uwtable
define internal i32 @PACKET_peek_1(ptr noundef %pkt, ptr noundef %data) #0 {
entry:
  %retval = alloca i32, align 4
  %pkt.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  store ptr %pkt, ptr %pkt.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr %pkt.addr, align 8
  %call = call i64 @PACKET_remaining(ptr noundef %0)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %pkt.addr, align 8
  %curr = getelementptr inbounds %struct.PACKET, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %curr, align 8
  %3 = load i8, ptr %2, align 1
  %conv = zext i8 %3 to i32
  %4 = load ptr, ptr %data.addr, align 8
  store i32 %conv, ptr %4, align 4
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind uwtable
define internal void @packet_forward(ptr noundef %pkt, i64 noundef %len) #0 {
entry:
  %pkt.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %pkt, ptr %pkt.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %len.addr, align 8
  %1 = load ptr, ptr %pkt.addr, align 8
  %curr = getelementptr inbounds %struct.PACKET, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %curr, align 8
  %add.ptr = getelementptr inbounds i8, ptr %2, i64 %0
  store ptr %add.ptr, ptr %curr, align 8
  %3 = load i64, ptr %len.addr, align 8
  %4 = load ptr, ptr %pkt.addr, align 8
  %remaining = getelementptr inbounds %struct.PACKET, ptr %4, i32 0, i32 1
  %5 = load i64, ptr %remaining, align 8
  %sub = sub i64 %5, %3
  store i64 %sub, ptr %remaining, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @PACKET_peek_copy_bytes(ptr noundef %pkt, ptr noundef %data, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %pkt.addr = alloca ptr, align 8
  %data.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  store ptr %pkt, ptr %pkt.addr, align 8
  store ptr %data, ptr %data.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load ptr, ptr %pkt.addr, align 8
  %call = call i64 @PACKET_remaining(ptr noundef %0)
  %1 = load i64, ptr %len.addr, align 8
  %cmp = icmp ult i64 %call, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %data.addr, align 8
  %3 = load ptr, ptr %pkt.addr, align 8
  %curr = getelementptr inbounds %struct.PACKET, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %curr, align 8
  %5 = load i64, ptr %len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %2, ptr align 1 %4, i64 %5, i1 false)
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @validate_cert_type(ptr noundef %val, i64 noundef %len) #0 {
entry:
  %retval = alloca i32, align 4
  %val.addr = alloca ptr, align 8
  %len.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %saw_rpk = alloca i32, align 4
  %saw_x509 = alloca i32, align 4
  store ptr %val, ptr %val.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store i32 0, ptr %saw_rpk, align 4
  store i32 0, ptr %saw_x509, align 4
  %0 = load ptr, ptr %val.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, ptr %len.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %2 = load ptr, ptr %val.addr, align 8
  %cmp2 = icmp eq ptr %2, null
  br i1 %cmp2, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load i64, ptr %len.addr, align 8
  %cmp3 = icmp eq i64 %3, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %lor.lhs.false, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %lor.lhs.false
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %4 = load i64, ptr %i, align 8
  %5 = load i64, ptr %len.addr, align 8
  %cmp6 = icmp ult i64 %4, %5
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %val.addr, align 8
  %7 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds i8, ptr %6, i64 %7
  %8 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %8 to i32
  switch i32 %conv, label %sw.default [
    i32 2, label %sw.bb
    i32 0, label %sw.bb9
    i32 1, label %sw.bb13
    i32 3, label %sw.bb13
  ]

sw.bb:                                            ; preds = %for.body
  %9 = load i32, ptr %saw_rpk, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then7, label %if.end8

if.then7:                                         ; preds = %sw.bb
  store i32 0, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %sw.bb
  store i32 1, ptr %saw_rpk, align 4
  br label %sw.epilog

sw.bb9:                                           ; preds = %for.body
  %10 = load i32, ptr %saw_x509, align 4
  %tobool10 = icmp ne i32 %10, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %sw.bb9
  store i32 0, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %sw.bb9
  store i32 1, ptr %saw_x509, align 4
  br label %sw.epilog

sw.bb13:                                          ; preds = %for.body, %for.body
  br label %sw.default

sw.default:                                       ; preds = %sw.bb13, %for.body
  store i32 0, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %if.end12, %if.end8
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %11 = load i64, ptr %i, align 8
  %inc = add i64 %11, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !33

for.end:                                          ; preds = %for.cond
  store i32 1, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %sw.default, %if.then11, %if.then7, %if.then4, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #3 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { nounwind willreturn memory(read) }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"uwtable", i32 2}
!3 = !{i32 7, !"frame-pointer", i32 2}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.mustprogress"}
!6 = distinct !{!6, !5}
!7 = distinct !{!7, !5}
!8 = distinct !{!8, !5}
!9 = distinct !{!9, !5}
!10 = distinct !{!10, !5}
!11 = distinct !{!11, !5}
!12 = distinct !{!12, !5}
!13 = distinct !{!13, !5}
!14 = distinct !{!14, !5}
!15 = distinct !{!15, !5}
!16 = distinct !{!16, !5}
!17 = distinct !{!17, !5}
!18 = distinct !{!18, !5}
!19 = distinct !{!19, !5}
!20 = distinct !{!20, !5}
!21 = distinct !{!21, !5}
!22 = distinct !{!22, !5}
!23 = distinct !{!23, !5}
!24 = distinct !{!24, !5}
!25 = distinct !{!25, !5}
!26 = distinct !{!26, !5}
!27 = distinct !{!27, !5}
!28 = distinct !{!28, !5}
!29 = distinct !{!29, !5}
!30 = distinct !{!30, !5}
!31 = distinct !{!31, !5}
!32 = distinct !{!32, !5}
!33 = distinct !{!33, !5}
