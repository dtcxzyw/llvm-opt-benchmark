target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.BrotliPrefixCodeRange = type { i16, i8 }
%struct.HuffmanTree = type { i32, i16, i16 }
%struct.Command = type { i32, i32, i32, i16, i16 }
%struct.BrotliEncoderParams = type { i32, i32, i32, i32, i64, i64, i32, i32, %struct.BrotliHasherParams, %struct.BrotliDistanceParams, %struct.SharedEncoderDictionary }
%struct.BrotliHasherParams = type { i32, i32, i32, i32 }
%struct.BrotliDistanceParams = type { i32, i32, i32, i32, i64 }
%struct.SharedEncoderDictionary = type { i32, %struct.CompoundDictionary, %struct.ContextualEncoderDictionary, i32 }
%struct.CompoundDictionary = type { i64, i64, [16 x ptr], [16 x ptr], [16 x i64], i64, [16 x ptr] }
%struct.ContextualEncoderDictionary = type { i32, i8, [64 x i8], [64 x ptr], i64, %struct.BrotliEncoderDictionary, ptr }
%struct.BrotliEncoderDictionary = type { ptr, i32, i32, i64, ptr, ptr, ptr, ptr, %struct.BrotliTrie, i32, ptr, ptr, ptr, i64, ptr, i64, ptr, ptr }
%struct.BrotliTrie = type { ptr, i64, i64, %struct.BrotliTrieNode }
%struct.BrotliTrieNode = type { i8, i8, i8, i32, i32 }
%struct.StoreMetablockArena = type { %struct.BlockEncoder, %struct.BlockEncoder, %struct.BlockEncoder, %struct.EncodeContextMapArena }
%struct.BlockEncoder = type { i64, i64, ptr, ptr, i64, %struct.BlockSplitCode, i64, i64, i64, ptr, ptr }
%struct.BlockSplitCode = type { %struct.BlockTypeCodeCalculator, [258 x i8], [258 x i16], [26 x i8], [26 x i16] }
%struct.BlockTypeCodeCalculator = type { i64, i64 }
%struct.EncodeContextMapArena = type { [272 x i32], [272 x i8], [272 x i16] }
%struct.MetaBlockSplit = type { %struct.BlockSplit, %struct.BlockSplit, %struct.BlockSplit, ptr, i64, ptr, i64, ptr, i64, ptr, i64, ptr, i64 }
%struct.BlockSplit = type { i64, i64, ptr, ptr, i64, i64 }
%struct.HistogramLiteral = type { [256 x i32], i64, double }
%struct.HistogramCommand = type { [704 x i32], i64, double }
%struct.HistogramDistance = type { [544 x i32], i64, double }
%struct.MetablockArena = type { %struct.HistogramLiteral, %struct.HistogramCommand, %struct.HistogramDistance, [256 x i8], [256 x i16], [704 x i8], [704 x i16], [140 x i8], [140 x i16], [1409 x %struct.HuffmanTree] }

@kZeroRepsDepth = internal constant [704 x i32] [i32 0, i32 4, i32 8, i32 7, i32 7, i32 7, i32 7, i32 7, i32 7, i32 7, i32 7, i32 11, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 14, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 21, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28, i32 28], align 16
@kZeroRepsBits = internal constant [704 x i64] [i64 0, i64 0, i64 0, i64 7, i64 23, i64 39, i64 55, i64 71, i64 87, i64 103, i64 119, i64 1904, i64 2951, i64 4999, i64 7047, i64 9095, i64 11143, i64 13191, i64 15239, i64 919, i64 2967, i64 5015, i64 7063, i64 9111, i64 11159, i64 13207, i64 15255, i64 935, i64 2983, i64 5031, i64 7079, i64 9127, i64 11175, i64 13223, i64 15271, i64 951, i64 2999, i64 5047, i64 7095, i64 9143, i64 11191, i64 13239, i64 15287, i64 967, i64 3015, i64 5063, i64 7111, i64 9159, i64 11207, i64 13255, i64 15303, i64 983, i64 3031, i64 5079, i64 7127, i64 9175, i64 11223, i64 13271, i64 15319, i64 999, i64 3047, i64 5095, i64 7143, i64 9191, i64 11239, i64 13287, i64 15335, i64 1015, i64 3063, i64 5111, i64 7159, i64 9207, i64 11255, i64 13303, i64 15351, i64 115591, i64 377735, i64 639879, i64 902023, i64 1164167, i64 1426311, i64 1688455, i64 1950599, i64 117639, i64 379783, i64 641927, i64 904071, i64 1166215, i64 1428359, i64 1690503, i64 1952647, i64 119687, i64 381831, i64 643975, i64 906119, i64 1168263, i64 1430407, i64 1692551, i64 1954695, i64 121735, i64 383879, i64 646023, i64 908167, i64 1170311, i64 1432455, i64 1694599, i64 1956743, i64 123783, i64 385927, i64 648071, i64 910215, i64 1172359, i64 1434503, i64 1696647, i64 1958791, i64 125831, i64 387975, i64 650119, i64 912263, i64 1174407, i64 1436551, i64 1698695, i64 1960839, i64 127879, i64 390023, i64 652167, i64 914311, i64 1176455, i64 1438599, i64 1700743, i64 1962887, i64 129927, i64 392071, i64 654215, i64 916359, i64 1178503, i64 1440647, i64 1702791, i64 1964935, i64 115607, i64 377751, i64 639895, i64 902039, i64 1164183, i64 1426327, i64 1688471, i64 1950615, i64 117655, i64 379799, i64 641943, i64 904087, i64 1166231, i64 1428375, i64 1690519, i64 1952663, i64 119703, i64 381847, i64 643991, i64 906135, i64 1168279, i64 1430423, i64 1692567, i64 1954711, i64 121751, i64 383895, i64 646039, i64 908183, i64 1170327, i64 1432471, i64 1694615, i64 1956759, i64 123799, i64 385943, i64 648087, i64 910231, i64 1172375, i64 1434519, i64 1696663, i64 1958807, i64 125847, i64 387991, i64 650135, i64 912279, i64 1174423, i64 1436567, i64 1698711, i64 1960855, i64 127895, i64 390039, i64 652183, i64 914327, i64 1176471, i64 1438615, i64 1700759, i64 1962903, i64 129943, i64 392087, i64 654231, i64 916375, i64 1178519, i64 1440663, i64 1702807, i64 1964951, i64 115623, i64 377767, i64 639911, i64 902055, i64 1164199, i64 1426343, i64 1688487, i64 1950631, i64 117671, i64 379815, i64 641959, i64 904103, i64 1166247, i64 1428391, i64 1690535, i64 1952679, i64 119719, i64 381863, i64 644007, i64 906151, i64 1168295, i64 1430439, i64 1692583, i64 1954727, i64 121767, i64 383911, i64 646055, i64 908199, i64 1170343, i64 1432487, i64 1694631, i64 1956775, i64 123815, i64 385959, i64 648103, i64 910247, i64 1172391, i64 1434535, i64 1696679, i64 1958823, i64 125863, i64 388007, i64 650151, i64 912295, i64 1174439, i64 1436583, i64 1698727, i64 1960871, i64 127911, i64 390055, i64 652199, i64 914343, i64 1176487, i64 1438631, i64 1700775, i64 1962919, i64 129959, i64 392103, i64 654247, i64 916391, i64 1178535, i64 1440679, i64 1702823, i64 1964967, i64 115639, i64 377783, i64 639927, i64 902071, i64 1164215, i64 1426359, i64 1688503, i64 1950647, i64 117687, i64 379831, i64 641975, i64 904119, i64 1166263, i64 1428407, i64 1690551, i64 1952695, i64 119735, i64 381879, i64 644023, i64 906167, i64 1168311, i64 1430455, i64 1692599, i64 1954743, i64 121783, i64 383927, i64 646071, i64 908215, i64 1170359, i64 1432503, i64 1694647, i64 1956791, i64 123831, i64 385975, i64 648119, i64 910263, i64 1172407, i64 1434551, i64 1696695, i64 1958839, i64 125879, i64 388023, i64 650167, i64 912311, i64 1174455, i64 1436599, i64 1698743, i64 1960887, i64 127927, i64 390071, i64 652215, i64 914359, i64 1176503, i64 1438647, i64 1700791, i64 1962935, i64 129975, i64 392119, i64 654263, i64 916407, i64 1178551, i64 1440695, i64 1702839, i64 1964983, i64 115655, i64 377799, i64 639943, i64 902087, i64 1164231, i64 1426375, i64 1688519, i64 1950663, i64 117703, i64 379847, i64 641991, i64 904135, i64 1166279, i64 1428423, i64 1690567, i64 1952711, i64 119751, i64 381895, i64 644039, i64 906183, i64 1168327, i64 1430471, i64 1692615, i64 1954759, i64 121799, i64 383943, i64 646087, i64 908231, i64 1170375, i64 1432519, i64 1694663, i64 1956807, i64 123847, i64 385991, i64 648135, i64 910279, i64 1172423, i64 1434567, i64 1696711, i64 1958855, i64 125895, i64 388039, i64 650183, i64 912327, i64 1174471, i64 1436615, i64 1698759, i64 1960903, i64 127943, i64 390087, i64 652231, i64 914375, i64 1176519, i64 1438663, i64 1700807, i64 1962951, i64 129991, i64 392135, i64 654279, i64 916423, i64 1178567, i64 1440711, i64 1702855, i64 1964999, i64 115671, i64 377815, i64 639959, i64 902103, i64 1164247, i64 1426391, i64 1688535, i64 1950679, i64 117719, i64 379863, i64 642007, i64 904151, i64 1166295, i64 1428439, i64 1690583, i64 1952727, i64 119767, i64 381911, i64 644055, i64 906199, i64 1168343, i64 1430487, i64 1692631, i64 1954775, i64 121815, i64 383959, i64 646103, i64 908247, i64 1170391, i64 1432535, i64 1694679, i64 1956823, i64 123863, i64 386007, i64 648151, i64 910295, i64 1172439, i64 1434583, i64 1696727, i64 1958871, i64 125911, i64 388055, i64 650199, i64 912343, i64 1174487, i64 1436631, i64 1698775, i64 1960919, i64 127959, i64 390103, i64 652247, i64 914391, i64 1176535, i64 1438679, i64 1700823, i64 1962967, i64 130007, i64 392151, i64 654295, i64 916439, i64 1178583, i64 1440727, i64 1702871, i64 1965015, i64 115687, i64 377831, i64 639975, i64 902119, i64 1164263, i64 1426407, i64 1688551, i64 1950695, i64 117735, i64 379879, i64 642023, i64 904167, i64 1166311, i64 1428455, i64 1690599, i64 1952743, i64 119783, i64 381927, i64 644071, i64 906215, i64 1168359, i64 1430503, i64 1692647, i64 1954791, i64 121831, i64 383975, i64 646119, i64 908263, i64 1170407, i64 1432551, i64 1694695, i64 1956839, i64 123879, i64 386023, i64 648167, i64 910311, i64 1172455, i64 1434599, i64 1696743, i64 1958887, i64 125927, i64 388071, i64 650215, i64 912359, i64 1174503, i64 1436647, i64 1698791, i64 1960935, i64 127975, i64 390119, i64 652263, i64 914407, i64 1176551, i64 1438695, i64 1700839, i64 1962983, i64 130023, i64 392167, i64 654311, i64 916455, i64 1178599, i64 1440743, i64 1702887, i64 1965031, i64 115703, i64 377847, i64 639991, i64 902135, i64 1164279, i64 1426423, i64 1688567, i64 1950711, i64 117751, i64 379895, i64 642039, i64 904183, i64 1166327, i64 1428471, i64 1690615, i64 1952759, i64 119799, i64 381943, i64 644087, i64 906231, i64 1168375, i64 1430519, i64 1692663, i64 1954807, i64 121847, i64 383991, i64 646135, i64 908279, i64 1170423, i64 1432567, i64 1694711, i64 1956855, i64 123895, i64 386039, i64 648183, i64 910327, i64 1172471, i64 1434615, i64 1696759, i64 1958903, i64 125943, i64 388087, i64 650231, i64 912375, i64 1174519, i64 1436663, i64 1698807, i64 1960951, i64 127991, i64 390135, i64 652279, i64 914423, i64 1176567, i64 1438711, i64 1700855, i64 1962999, i64 130039, i64 392183, i64 654327, i64 916471, i64 1178615, i64 1440759, i64 1702903, i64 1965047, i64 14795655, i64 48350087, i64 81904519, i64 115458951, i64 149013383, i64 182567815, i64 216122247, i64 249676679, i64 15057799, i64 48612231, i64 82166663, i64 115721095, i64 149275527, i64 182829959, i64 216384391, i64 249938823, i64 15319943, i64 48874375, i64 82428807, i64 115983239, i64 149537671, i64 183092103, i64 216646535, i64 250200967, i64 15582087, i64 49136519, i64 82690951, i64 116245383, i64 149799815, i64 183354247, i64 216908679, i64 250463111, i64 15844231, i64 49398663, i64 82953095, i64 116507527, i64 150061959, i64 183616391, i64 217170823, i64 250725255, i64 16106375, i64 49660807, i64 83215239, i64 116769671, i64 150324103, i64 183878535, i64 217432967, i64 250987399, i64 16368519, i64 49922951, i64 83477383, i64 117031815, i64 150586247, i64 184140679, i64 217695111, i64 251249543, i64 16630663, i64 50185095, i64 83739527, i64 117293959, i64 150848391, i64 184402823, i64 217957255, i64 251511687, i64 14797703, i64 48352135, i64 81906567, i64 115460999, i64 149015431, i64 182569863, i64 216124295, i64 249678727, i64 15059847, i64 48614279, i64 82168711, i64 115723143, i64 149277575, i64 182832007, i64 216386439, i64 249940871, i64 15321991, i64 48876423, i64 82430855, i64 115985287, i64 149539719, i64 183094151, i64 216648583, i64 250203015, i64 15584135, i64 49138567, i64 82692999, i64 116247431, i64 149801863, i64 183356295, i64 216910727, i64 250465159, i64 15846279, i64 49400711, i64 82955143, i64 116509575, i64 150064007, i64 183618439, i64 217172871, i64 250727303, i64 16108423, i64 49662855, i64 83217287, i64 116771719, i64 150326151, i64 183880583, i64 217435015, i64 250989447, i64 16370567, i64 49924999, i64 83479431, i64 117033863, i64 150588295], align 16
@kCodeLengthDepth = internal constant [18 x i8] c"\04\04\04\04\04\04\04\04\04\04\04\04\04\05\05\00\04\04", align 16
@kCodeLengthBits = internal constant [18 x i32] [i32 0, i32 8, i32 4, i32 12, i32 2, i32 10, i32 6, i32 14, i32 1, i32 9, i32 5, i32 13, i32 3, i32 15, i32 31, i32 0, i32 11, i32 7], align 16
@kNonZeroRepsDepth = internal constant [704 x i32] [i32 6, i32 6, i32 6, i32 6, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 12, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 18, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 24, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30, i32 30], align 16
@kNonZeroRepsBits = internal constant [704 x i64] [i64 11, i64 27, i64 43, i64 59, i64 715, i64 1739, i64 2763, i64 3787, i64 731, i64 1755, i64 2779, i64 3803, i64 747, i64 1771, i64 2795, i64 3819, i64 763, i64 1787, i64 2811, i64 3835, i64 45771, i64 111307, i64 176843, i64 242379, i64 46795, i64 112331, i64 177867, i64 243403, i64 47819, i64 113355, i64 178891, i64 244427, i64 48843, i64 114379, i64 179915, i64 245451, i64 45787, i64 111323, i64 176859, i64 242395, i64 46811, i64 112347, i64 177883, i64 243419, i64 47835, i64 113371, i64 178907, i64 244443, i64 48859, i64 114395, i64 179931, i64 245467, i64 45803, i64 111339, i64 176875, i64 242411, i64 46827, i64 112363, i64 177899, i64 243435, i64 47851, i64 113387, i64 178923, i64 244459, i64 48875, i64 114411, i64 179947, i64 245483, i64 45819, i64 111355, i64 176891, i64 242427, i64 46843, i64 112379, i64 177915, i64 243451, i64 47867, i64 113403, i64 178939, i64 244475, i64 48891, i64 114427, i64 179963, i64 245499, i64 2929355, i64 7123659, i64 11317963, i64 15512267, i64 2994891, i64 7189195, i64 11383499, i64 15577803, i64 3060427, i64 7254731, i64 11449035, i64 15643339, i64 3125963, i64 7320267, i64 11514571, i64 15708875, i64 2930379, i64 7124683, i64 11318987, i64 15513291, i64 2995915, i64 7190219, i64 11384523, i64 15578827, i64 3061451, i64 7255755, i64 11450059, i64 15644363, i64 3126987, i64 7321291, i64 11515595, i64 15709899, i64 2931403, i64 7125707, i64 11320011, i64 15514315, i64 2996939, i64 7191243, i64 11385547, i64 15579851, i64 3062475, i64 7256779, i64 11451083, i64 15645387, i64 3128011, i64 7322315, i64 11516619, i64 15710923, i64 2932427, i64 7126731, i64 11321035, i64 15515339, i64 2997963, i64 7192267, i64 11386571, i64 15580875, i64 3063499, i64 7257803, i64 11452107, i64 15646411, i64 3129035, i64 7323339, i64 11517643, i64 15711947, i64 2929371, i64 7123675, i64 11317979, i64 15512283, i64 2994907, i64 7189211, i64 11383515, i64 15577819, i64 3060443, i64 7254747, i64 11449051, i64 15643355, i64 3125979, i64 7320283, i64 11514587, i64 15708891, i64 2930395, i64 7124699, i64 11319003, i64 15513307, i64 2995931, i64 7190235, i64 11384539, i64 15578843, i64 3061467, i64 7255771, i64 11450075, i64 15644379, i64 3127003, i64 7321307, i64 11515611, i64 15709915, i64 2931419, i64 7125723, i64 11320027, i64 15514331, i64 2996955, i64 7191259, i64 11385563, i64 15579867, i64 3062491, i64 7256795, i64 11451099, i64 15645403, i64 3128027, i64 7322331, i64 11516635, i64 15710939, i64 2932443, i64 7126747, i64 11321051, i64 15515355, i64 2997979, i64 7192283, i64 11386587, i64 15580891, i64 3063515, i64 7257819, i64 11452123, i64 15646427, i64 3129051, i64 7323355, i64 11517659, i64 15711963, i64 2929387, i64 7123691, i64 11317995, i64 15512299, i64 2994923, i64 7189227, i64 11383531, i64 15577835, i64 3060459, i64 7254763, i64 11449067, i64 15643371, i64 3125995, i64 7320299, i64 11514603, i64 15708907, i64 2930411, i64 7124715, i64 11319019, i64 15513323, i64 2995947, i64 7190251, i64 11384555, i64 15578859, i64 3061483, i64 7255787, i64 11450091, i64 15644395, i64 3127019, i64 7321323, i64 11515627, i64 15709931, i64 2931435, i64 7125739, i64 11320043, i64 15514347, i64 2996971, i64 7191275, i64 11385579, i64 15579883, i64 3062507, i64 7256811, i64 11451115, i64 15645419, i64 3128043, i64 7322347, i64 11516651, i64 15710955, i64 2932459, i64 7126763, i64 11321067, i64 15515371, i64 2997995, i64 7192299, i64 11386603, i64 15580907, i64 3063531, i64 7257835, i64 11452139, i64 15646443, i64 3129067, i64 7323371, i64 11517675, i64 15711979, i64 2929403, i64 7123707, i64 11318011, i64 15512315, i64 2994939, i64 7189243, i64 11383547, i64 15577851, i64 3060475, i64 7254779, i64 11449083, i64 15643387, i64 3126011, i64 7320315, i64 11514619, i64 15708923, i64 2930427, i64 7124731, i64 11319035, i64 15513339, i64 2995963, i64 7190267, i64 11384571, i64 15578875, i64 3061499, i64 7255803, i64 11450107, i64 15644411, i64 3127035, i64 7321339, i64 11515643, i64 15709947, i64 2931451, i64 7125755, i64 11320059, i64 15514363, i64 2996987, i64 7191291, i64 11385595, i64 15579899, i64 3062523, i64 7256827, i64 11451131, i64 15645435, i64 3128059, i64 7322363, i64 11516667, i64 15710971, i64 2932475, i64 7126779, i64 11321083, i64 15515387, i64 2998011, i64 7192315, i64 11386619, i64 15580923, i64 3063547, i64 7257851, i64 11452155, i64 15646459, i64 3129083, i64 7323387, i64 11517691, i64 15711995, i64 187478731, i64 455914187, i64 724349643, i64 992785099, i64 191673035, i64 460108491, i64 728543947, i64 996979403, i64 195867339, i64 464302795, i64 732738251, i64 1001173707, i64 200061643, i64 468497099, i64 736932555, i64 1005368011, i64 187544267, i64 455979723, i64 724415179, i64 992850635, i64 191738571, i64 460174027, i64 728609483, i64 997044939, i64 195932875, i64 464368331, i64 732803787, i64 1001239243, i64 200127179, i64 468562635, i64 736998091, i64 1005433547, i64 187609803, i64 456045259, i64 724480715, i64 992916171, i64 191804107, i64 460239563, i64 728675019, i64 997110475, i64 195998411, i64 464433867, i64 732869323, i64 1001304779, i64 200192715, i64 468628171, i64 737063627, i64 1005499083, i64 187675339, i64 456110795, i64 724546251, i64 992981707, i64 191869643, i64 460305099, i64 728740555, i64 997176011, i64 196063947, i64 464499403, i64 732934859, i64 1001370315, i64 200258251, i64 468693707, i64 737129163, i64 1005564619, i64 187479755, i64 455915211, i64 724350667, i64 992786123, i64 191674059, i64 460109515, i64 728544971, i64 996980427, i64 195868363, i64 464303819, i64 732739275, i64 1001174731, i64 200062667, i64 468498123, i64 736933579, i64 1005369035, i64 187545291, i64 455980747, i64 724416203, i64 992851659, i64 191739595, i64 460175051, i64 728610507, i64 997045963, i64 195933899, i64 464369355, i64 732804811, i64 1001240267, i64 200128203, i64 468563659, i64 736999115, i64 1005434571, i64 187610827, i64 456046283, i64 724481739, i64 992917195, i64 191805131, i64 460240587, i64 728676043, i64 997111499, i64 195999435, i64 464434891, i64 732870347, i64 1001305803, i64 200193739, i64 468629195, i64 737064651, i64 1005500107, i64 187676363, i64 456111819, i64 724547275, i64 992982731, i64 191870667, i64 460306123, i64 728741579, i64 997177035, i64 196064971, i64 464500427, i64 732935883, i64 1001371339, i64 200259275, i64 468694731, i64 737130187, i64 1005565643, i64 187480779, i64 455916235, i64 724351691, i64 992787147, i64 191675083, i64 460110539, i64 728545995, i64 996981451, i64 195869387, i64 464304843, i64 732740299, i64 1001175755, i64 200063691, i64 468499147, i64 736934603, i64 1005370059, i64 187546315, i64 455981771, i64 724417227, i64 992852683, i64 191740619, i64 460176075, i64 728611531, i64 997046987, i64 195934923, i64 464370379, i64 732805835, i64 1001241291, i64 200129227, i64 468564683, i64 737000139, i64 1005435595, i64 187611851, i64 456047307, i64 724482763, i64 992918219, i64 191806155, i64 460241611, i64 728677067, i64 997112523, i64 196000459, i64 464435915, i64 732871371, i64 1001306827, i64 200194763, i64 468630219, i64 737065675, i64 1005501131, i64 187677387, i64 456112843, i64 724548299, i64 992983755, i64 191871691, i64 460307147, i64 728742603, i64 997178059, i64 196065995, i64 464501451, i64 732936907, i64 1001372363, i64 200260299, i64 468695755, i64 737131211, i64 1005566667, i64 187481803, i64 455917259, i64 724352715, i64 992788171, i64 191676107, i64 460111563, i64 728547019, i64 996982475, i64 195870411, i64 464305867, i64 732741323, i64 1001176779, i64 200064715, i64 468500171, i64 736935627, i64 1005371083, i64 187547339, i64 455982795, i64 724418251, i64 992853707, i64 191741643, i64 460177099, i64 728612555, i64 997048011, i64 195935947, i64 464371403, i64 732806859, i64 1001242315, i64 200130251, i64 468565707, i64 737001163, i64 1005436619, i64 187612875, i64 456048331, i64 724483787, i64 992919243, i64 191807179, i64 460242635, i64 728678091, i64 997113547, i64 196001483, i64 464436939, i64 732872395, i64 1001307851, i64 200195787, i64 468631243, i64 737066699, i64 1005502155, i64 187678411, i64 456113867, i64 724549323, i64 992984779, i64 191872715, i64 460308171, i64 728743627, i64 997179083, i64 196067019, i64 464502475, i64 732937931, i64 1001373387, i64 200261323, i64 468696779, i64 737132235, i64 1005567691, i64 187478747, i64 455914203, i64 724349659, i64 992785115, i64 191673051, i64 460108507, i64 728543963, i64 996979419, i64 195867355, i64 464302811, i64 732738267, i64 1001173723, i64 200061659, i64 468497115, i64 736932571, i64 1005368027, i64 187544283, i64 455979739, i64 724415195, i64 992850651, i64 191738587, i64 460174043, i64 728609499, i64 997044955, i64 195932891, i64 464368347, i64 732803803, i64 1001239259, i64 200127195, i64 468562651, i64 736998107, i64 1005433563, i64 187609819, i64 456045275, i64 724480731, i64 992916187, i64 191804123, i64 460239579, i64 728675035, i64 997110491, i64 195998427, i64 464433883, i64 732869339, i64 1001304795, i64 200192731, i64 468628187, i64 737063643, i64 1005499099, i64 187675355, i64 456110811, i64 724546267, i64 992981723, i64 191869659, i64 460305115, i64 728740571, i64 997176027, i64 196063963, i64 464499419, i64 732934875, i64 1001370331, i64 200258267, i64 468693723, i64 737129179, i64 1005564635, i64 187479771, i64 455915227, i64 724350683, i64 992786139, i64 191674075, i64 460109531, i64 728544987, i64 996980443, i64 195868379, i64 464303835, i64 732739291, i64 1001174747, i64 200062683, i64 468498139, i64 736933595, i64 1005369051, i64 187545307, i64 455980763, i64 724416219, i64 992851675, i64 191739611, i64 460175067, i64 728610523, i64 997045979, i64 195933915, i64 464369371, i64 732804827, i64 1001240283, i64 200128219, i64 468563675, i64 736999131, i64 1005434587, i64 187610843, i64 456046299, i64 724481755, i64 992917211, i64 191805147, i64 460240603, i64 728676059, i64 997111515, i64 195999451, i64 464434907, i64 732870363, i64 1001305819], align 16
@_kBrotliContextLookupTable = external constant [2048 x i8], align 16
@kStaticCommandCodeDepth = internal constant [704 x i8] c"\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\09\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B\0B", align 16
@kStaticCommandCodeBits = internal constant [704 x i16] [i16 0, i16 256, i16 128, i16 384, i16 64, i16 320, i16 192, i16 448, i16 32, i16 288, i16 160, i16 416, i16 96, i16 352, i16 224, i16 480, i16 16, i16 272, i16 144, i16 400, i16 80, i16 336, i16 208, i16 464, i16 48, i16 304, i16 176, i16 432, i16 112, i16 368, i16 240, i16 496, i16 8, i16 264, i16 136, i16 392, i16 72, i16 328, i16 200, i16 456, i16 40, i16 296, i16 168, i16 424, i16 104, i16 360, i16 232, i16 488, i16 24, i16 280, i16 152, i16 408, i16 88, i16 344, i16 216, i16 472, i16 56, i16 312, i16 184, i16 440, i16 120, i16 376, i16 248, i16 504, i16 4, i16 260, i16 132, i16 388, i16 68, i16 324, i16 196, i16 452, i16 36, i16 292, i16 164, i16 420, i16 100, i16 356, i16 228, i16 484, i16 20, i16 276, i16 148, i16 404, i16 84, i16 340, i16 212, i16 468, i16 52, i16 308, i16 180, i16 436, i16 116, i16 372, i16 244, i16 500, i16 12, i16 268, i16 140, i16 396, i16 76, i16 332, i16 204, i16 460, i16 44, i16 300, i16 172, i16 428, i16 108, i16 364, i16 236, i16 492, i16 28, i16 284, i16 156, i16 412, i16 92, i16 348, i16 220, i16 476, i16 60, i16 316, i16 188, i16 444, i16 124, i16 380, i16 252, i16 508, i16 2, i16 258, i16 130, i16 386, i16 66, i16 322, i16 194, i16 450, i16 34, i16 290, i16 162, i16 418, i16 98, i16 354, i16 226, i16 482, i16 18, i16 274, i16 146, i16 402, i16 82, i16 338, i16 210, i16 466, i16 50, i16 306, i16 178, i16 434, i16 114, i16 370, i16 242, i16 498, i16 10, i16 266, i16 138, i16 394, i16 74, i16 330, i16 202, i16 458, i16 42, i16 298, i16 170, i16 426, i16 106, i16 362, i16 234, i16 490, i16 26, i16 282, i16 154, i16 410, i16 90, i16 346, i16 218, i16 474, i16 58, i16 314, i16 186, i16 442, i16 122, i16 378, i16 250, i16 506, i16 6, i16 262, i16 134, i16 390, i16 70, i16 326, i16 198, i16 454, i16 38, i16 294, i16 166, i16 422, i16 102, i16 358, i16 230, i16 486, i16 22, i16 278, i16 150, i16 406, i16 86, i16 342, i16 214, i16 470, i16 54, i16 310, i16 182, i16 438, i16 118, i16 374, i16 246, i16 502, i16 14, i16 270, i16 142, i16 398, i16 78, i16 334, i16 206, i16 462, i16 46, i16 302, i16 174, i16 430, i16 110, i16 366, i16 238, i16 494, i16 30, i16 286, i16 158, i16 414, i16 94, i16 350, i16 222, i16 478, i16 62, i16 318, i16 190, i16 446, i16 126, i16 382, i16 254, i16 510, i16 1, i16 257, i16 129, i16 385, i16 65, i16 321, i16 193, i16 449, i16 33, i16 289, i16 161, i16 417, i16 97, i16 353, i16 225, i16 481, i16 17, i16 273, i16 145, i16 401, i16 81, i16 337, i16 209, i16 465, i16 49, i16 305, i16 177, i16 433, i16 113, i16 369, i16 241, i16 497, i16 9, i16 265, i16 137, i16 393, i16 73, i16 329, i16 201, i16 457, i16 41, i16 297, i16 169, i16 425, i16 105, i16 361, i16 233, i16 489, i16 25, i16 281, i16 153, i16 409, i16 89, i16 345, i16 217, i16 473, i16 57, i16 313, i16 185, i16 441, i16 121, i16 377, i16 249, i16 505, i16 5, i16 261, i16 133, i16 389, i16 69, i16 325, i16 197, i16 453, i16 37, i16 293, i16 165, i16 421, i16 101, i16 357, i16 229, i16 485, i16 21, i16 277, i16 149, i16 405, i16 85, i16 341, i16 213, i16 469, i16 53, i16 309, i16 181, i16 437, i16 117, i16 373, i16 245, i16 501, i16 13, i16 269, i16 141, i16 397, i16 77, i16 333, i16 205, i16 461, i16 45, i16 301, i16 173, i16 429, i16 109, i16 365, i16 237, i16 493, i16 29, i16 285, i16 157, i16 413, i16 93, i16 349, i16 221, i16 477, i16 61, i16 317, i16 189, i16 445, i16 125, i16 381, i16 253, i16 509, i16 3, i16 259, i16 131, i16 387, i16 67, i16 323, i16 195, i16 451, i16 35, i16 291, i16 163, i16 419, i16 99, i16 355, i16 227, i16 483, i16 19, i16 275, i16 147, i16 403, i16 83, i16 339, i16 211, i16 467, i16 51, i16 307, i16 179, i16 435, i16 115, i16 371, i16 243, i16 499, i16 11, i16 267, i16 139, i16 395, i16 75, i16 331, i16 203, i16 459, i16 43, i16 299, i16 171, i16 427, i16 107, i16 363, i16 235, i16 491, i16 27, i16 283, i16 155, i16 411, i16 91, i16 347, i16 219, i16 475, i16 59, i16 315, i16 187, i16 443, i16 123, i16 379, i16 251, i16 507, i16 7, i16 1031, i16 519, i16 1543, i16 263, i16 1287, i16 775, i16 1799, i16 135, i16 1159, i16 647, i16 1671, i16 391, i16 1415, i16 903, i16 1927, i16 71, i16 1095, i16 583, i16 1607, i16 327, i16 1351, i16 839, i16 1863, i16 199, i16 1223, i16 711, i16 1735, i16 455, i16 1479, i16 967, i16 1991, i16 39, i16 1063, i16 551, i16 1575, i16 295, i16 1319, i16 807, i16 1831, i16 167, i16 1191, i16 679, i16 1703, i16 423, i16 1447, i16 935, i16 1959, i16 103, i16 1127, i16 615, i16 1639, i16 359, i16 1383, i16 871, i16 1895, i16 231, i16 1255, i16 743, i16 1767, i16 487, i16 1511, i16 999, i16 2023, i16 23, i16 1047, i16 535, i16 1559, i16 279, i16 1303, i16 791, i16 1815, i16 151, i16 1175, i16 663, i16 1687, i16 407, i16 1431, i16 919, i16 1943, i16 87, i16 1111, i16 599, i16 1623, i16 343, i16 1367, i16 855, i16 1879, i16 215, i16 1239, i16 727, i16 1751, i16 471, i16 1495, i16 983, i16 2007, i16 55, i16 1079, i16 567, i16 1591, i16 311, i16 1335, i16 823, i16 1847, i16 183, i16 1207, i16 695, i16 1719, i16 439, i16 1463, i16 951, i16 1975, i16 119, i16 1143, i16 631, i16 1655, i16 375, i16 1399, i16 887, i16 1911, i16 247, i16 1271, i16 759, i16 1783, i16 503, i16 1527, i16 1015, i16 2039, i16 15, i16 1039, i16 527, i16 1551, i16 271, i16 1295, i16 783, i16 1807, i16 143, i16 1167, i16 655, i16 1679, i16 399, i16 1423, i16 911, i16 1935, i16 79, i16 1103, i16 591, i16 1615, i16 335, i16 1359, i16 847, i16 1871, i16 207, i16 1231, i16 719, i16 1743, i16 463, i16 1487, i16 975, i16 1999, i16 47, i16 1071, i16 559, i16 1583, i16 303, i16 1327, i16 815, i16 1839, i16 175, i16 1199, i16 687, i16 1711, i16 431, i16 1455, i16 943, i16 1967, i16 111, i16 1135, i16 623, i16 1647, i16 367, i16 1391, i16 879, i16 1903, i16 239, i16 1263, i16 751, i16 1775, i16 495, i16 1519, i16 1007, i16 2031, i16 31, i16 1055, i16 543, i16 1567, i16 287, i16 1311, i16 799, i16 1823, i16 159, i16 1183, i16 671, i16 1695, i16 415, i16 1439, i16 927, i16 1951, i16 95, i16 1119, i16 607, i16 1631, i16 351, i16 1375, i16 863, i16 1887, i16 223, i16 1247, i16 735, i16 1759, i16 479, i16 1503, i16 991, i16 2015, i16 63, i16 1087, i16 575, i16 1599, i16 319, i16 1343, i16 831, i16 1855, i16 191, i16 1215, i16 703, i16 1727, i16 447, i16 1471, i16 959, i16 1983, i16 127, i16 1151, i16 639, i16 1663, i16 383, i16 1407, i16 895, i16 1919, i16 255, i16 1279, i16 767, i16 1791, i16 511, i16 1535, i16 1023, i16 2047], align 16
@kStaticDistanceCodeDepth = internal constant [64 x i8] c"\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06\06", align 16
@kStaticDistanceCodeBits = internal constant [64 x i16] [i16 0, i16 32, i16 16, i16 48, i16 8, i16 40, i16 24, i16 56, i16 4, i16 36, i16 20, i16 52, i16 12, i16 44, i16 28, i16 60, i16 2, i16 34, i16 18, i16 50, i16 10, i16 42, i16 26, i16 58, i16 6, i16 38, i16 22, i16 54, i16 14, i16 46, i16 30, i16 62, i16 1, i16 33, i16 17, i16 49, i16 9, i16 41, i16 25, i16 57, i16 5, i16 37, i16 21, i16 53, i16 13, i16 45, i16 29, i16 61, i16 3, i16 35, i16 19, i16 51, i16 11, i16 43, i16 27, i16 59, i16 7, i16 39, i16 23, i16 55, i16 15, i16 47, i16 31, i16 63], align 16
@BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask.kStorageOrder = internal constant [18 x i8] c"\01\02\03\04\00\05\11\06\10\07\08\09\0A\0B\0C\0D\0E\0F", align 16
@BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask.kHuffmanBitLengthHuffmanCodeSymbols = internal constant [6 x i8] c"\00\07\03\02\01\0F", align 1
@BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask.kHuffmanBitLengthHuffmanCodeBitLengths = internal constant [6 x i8] c"\02\04\03\02\02\04", align 1
@kBrotliShellGaps = external hidden constant [6 x i64], align 16
@_kBrotliPrefixCodeRanges = external constant [26 x %struct.BrotliPrefixCodeRange], align 16
@EncodeContextMap.kSymbolMask = internal constant i32 511, align 4
@kBrotliInsExtra = external hidden constant [24 x i32], align 16
@kBrotliInsBase = external hidden constant [24 x i32], align 16
@kBrotliCopyBase = external hidden constant [24 x i32], align 16
@kBrotliCopyExtra = external hidden constant [24 x i32], align 16

; Function Attrs: nounwind uwtable
define hidden void @BrotliStoreHuffmanTree(ptr noundef %depths, i64 noundef %num, ptr noundef %tree, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %depths.addr = alloca ptr, align 8
  %num.addr = alloca i64, align 8
  %tree.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %huffman_tree = alloca [704 x i8], align 16
  %huffman_tree_extra_bits = alloca [704 x i8], align 16
  %huffman_tree_size = alloca i64, align 8
  %code_length_bitdepth = alloca [18 x i8], align 16
  %code_length_bitdepth_symbols = alloca [18 x i16], align 16
  %huffman_tree_histogram = alloca [18 x i32], align 16
  %i = alloca i64, align 8
  %num_codes = alloca i32, align 4
  %code = alloca i64, align 8
  store ptr %depths, ptr %depths.addr, align 8
  store i64 %num, ptr %num.addr, align 8
  store ptr %tree, ptr %tree.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  store i64 0, ptr %huffman_tree_size, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %code_length_bitdepth, i8 0, i64 18, i1 false)
  call void @llvm.memset.p0.i64(ptr align 16 %huffman_tree_histogram, i8 0, i64 72, i1 false)
  store i32 0, ptr %num_codes, align 4
  store i64 0, ptr %code, align 8
  %0 = load ptr, ptr %depths.addr, align 8
  %1 = load i64, ptr %num.addr, align 8
  %arraydecay = getelementptr inbounds [704 x i8], ptr %huffman_tree, i64 0, i64 0
  %arraydecay1 = getelementptr inbounds [704 x i8], ptr %huffman_tree_extra_bits, i64 0, i64 0
  call void @BrotliWriteHuffmanTree(ptr noundef %0, i64 noundef %1, ptr noundef %huffman_tree_size, ptr noundef %arraydecay, ptr noundef %arraydecay1)
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, ptr %i, align 8
  %3 = load i64, ptr %huffman_tree_size, align 8
  %cmp = icmp ult i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds [704 x i8], ptr %huffman_tree, i64 0, i64 %4
  %5 = load i8, ptr %arrayidx, align 1
  %idxprom = zext i8 %5 to i64
  %arrayidx2 = getelementptr inbounds [18 x i32], ptr %huffman_tree_histogram, i64 0, i64 %idxprom
  %6 = load i32, ptr %arrayidx2, align 4
  %inc = add i32 %6, 1
  store i32 %inc, ptr %arrayidx2, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i64, ptr %i, align 8
  %inc3 = add i64 %7, 1
  store i64 %inc3, ptr %i, align 8
  br label %for.cond, !llvm.loop !4

for.end:                                          ; preds = %for.cond
  store i64 0, ptr %i, align 8
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc14, %for.end
  %8 = load i64, ptr %i, align 8
  %cmp5 = icmp ult i64 %8, 18
  br i1 %cmp5, label %for.body6, label %for.end16

for.body6:                                        ; preds = %for.cond4
  %9 = load i64, ptr %i, align 8
  %arrayidx7 = getelementptr inbounds [18 x i32], ptr %huffman_tree_histogram, i64 0, i64 %9
  %10 = load i32, ptr %arrayidx7, align 4
  %tobool = icmp ne i32 %10, 0
  br i1 %tobool, label %if.then, label %if.end13

if.then:                                          ; preds = %for.body6
  %11 = load i32, ptr %num_codes, align 4
  %cmp8 = icmp eq i32 %11, 0
  br i1 %cmp8, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then
  %12 = load i64, ptr %i, align 8
  store i64 %12, ptr %code, align 8
  store i32 1, ptr %num_codes, align 4
  br label %if.end12

if.else:                                          ; preds = %if.then
  %13 = load i32, ptr %num_codes, align 4
  %cmp10 = icmp eq i32 %13, 1
  br i1 %cmp10, label %if.then11, label %if.end

if.then11:                                        ; preds = %if.else
  store i32 2, ptr %num_codes, align 4
  br label %for.end16

if.end:                                           ; preds = %if.else
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then9
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %for.body6
  br label %for.inc14

for.inc14:                                        ; preds = %if.end13
  %14 = load i64, ptr %i, align 8
  %inc15 = add i64 %14, 1
  store i64 %inc15, ptr %i, align 8
  br label %for.cond4, !llvm.loop !6

for.end16:                                        ; preds = %if.then11, %for.cond4
  %arraydecay17 = getelementptr inbounds [18 x i32], ptr %huffman_tree_histogram, i64 0, i64 0
  %15 = load ptr, ptr %tree.addr, align 8
  %arraydecay18 = getelementptr inbounds [18 x i8], ptr %code_length_bitdepth, i64 0, i64 0
  call void @BrotliCreateHuffmanTree(ptr noundef %arraydecay17, i64 noundef 18, i32 noundef 5, ptr noundef %15, ptr noundef %arraydecay18)
  %arraydecay19 = getelementptr inbounds [18 x i8], ptr %code_length_bitdepth, i64 0, i64 0
  %arraydecay20 = getelementptr inbounds [18 x i16], ptr %code_length_bitdepth_symbols, i64 0, i64 0
  call void @BrotliConvertBitDepthsToSymbols(ptr noundef %arraydecay19, i64 noundef 18, ptr noundef %arraydecay20)
  %16 = load i32, ptr %num_codes, align 4
  %arraydecay21 = getelementptr inbounds [18 x i8], ptr %code_length_bitdepth, i64 0, i64 0
  %17 = load ptr, ptr %storage_ix.addr, align 8
  %18 = load ptr, ptr %storage.addr, align 8
  call void @BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask(i32 noundef %16, ptr noundef %arraydecay21, ptr noundef %17, ptr noundef %18)
  %19 = load i32, ptr %num_codes, align 4
  %cmp22 = icmp eq i32 %19, 1
  br i1 %cmp22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %for.end16
  %20 = load i64, ptr %code, align 8
  %arrayidx24 = getelementptr inbounds [18 x i8], ptr %code_length_bitdepth, i64 0, i64 %20
  store i8 0, ptr %arrayidx24, align 1
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %for.end16
  %21 = load i64, ptr %huffman_tree_size, align 8
  %arraydecay26 = getelementptr inbounds [704 x i8], ptr %huffman_tree, i64 0, i64 0
  %arraydecay27 = getelementptr inbounds [704 x i8], ptr %huffman_tree_extra_bits, i64 0, i64 0
  %arraydecay28 = getelementptr inbounds [18 x i8], ptr %code_length_bitdepth, i64 0, i64 0
  %arraydecay29 = getelementptr inbounds [18 x i16], ptr %code_length_bitdepth_symbols, i64 0, i64 0
  %22 = load ptr, ptr %storage_ix.addr, align 8
  %23 = load ptr, ptr %storage.addr, align 8
  call void @BrotliStoreHuffmanTreeToBitMask(i64 noundef %21, ptr noundef %arraydecay26, ptr noundef %arraydecay27, ptr noundef %arraydecay28, ptr noundef %arraydecay29, ptr noundef %22, ptr noundef %23)
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #1

declare hidden void @BrotliWriteHuffmanTree(ptr noundef, i64 noundef, ptr noundef, ptr noundef, ptr noundef) #2

declare hidden void @BrotliCreateHuffmanTree(ptr noundef, i64 noundef, i32 noundef, ptr noundef, ptr noundef) #2

declare hidden void @BrotliConvertBitDepthsToSymbols(ptr noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask(i32 noundef %num_codes, ptr noundef %code_length_bitdepth, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i53 = alloca ptr, align 8
  %v.addr.i54 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i40 = alloca i64, align 8
  %bits.addr.i41 = alloca i64, align 8
  %pos.addr.i42 = alloca ptr, align 8
  %array.addr.i43 = alloca ptr, align 8
  %p.i44 = alloca ptr, align 8
  %v.i45 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %num_codes.addr = alloca i32, align 4
  %code_length_bitdepth.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %skip_some = alloca i64, align 8
  %codes_to_store = alloca i64, align 8
  %i = alloca i64, align 8
  %l = alloca i64, align 8
  store i32 %num_codes, ptr %num_codes.addr, align 4
  store ptr %code_length_bitdepth, ptr %code_length_bitdepth.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  store i64 0, ptr %skip_some, align 8
  store i64 18, ptr %codes_to_store, align 8
  %0 = load i32, ptr %num_codes.addr, align 4
  %cmp = icmp sgt i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %1 = load i64, ptr %codes_to_store, align 8
  %cmp1 = icmp ugt i64 %1, 0
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %code_length_bitdepth.addr, align 8
  %3 = load i64, ptr %codes_to_store, align 8
  %sub = sub i64 %3, 1
  %arrayidx = getelementptr inbounds [18 x i8], ptr @BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask.kStorageOrder, i64 0, i64 %sub
  %4 = load i8, ptr %arrayidx, align 1
  %idxprom = zext i8 %4 to i64
  %arrayidx2 = getelementptr inbounds i8, ptr %2, i64 %idxprom
  %5 = load i8, ptr %arrayidx2, align 1
  %conv = zext i8 %5 to i32
  %cmp3 = icmp ne i32 %conv, 0
  br i1 %cmp3, label %if.then5, label %if.end

if.then5:                                         ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %6 = load i64, ptr %codes_to_store, align 8
  %dec = add i64 %6, -1
  store i64 %dec, ptr %codes_to_store, align 8
  br label %for.cond, !llvm.loop !7

for.end:                                          ; preds = %if.then5, %for.cond
  br label %if.end6

if.end6:                                          ; preds = %for.end, %entry
  %7 = load ptr, ptr %code_length_bitdepth.addr, align 8
  %8 = load i8, ptr @BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask.kStorageOrder, align 16
  %idxprom7 = zext i8 %8 to i64
  %arrayidx8 = getelementptr inbounds i8, ptr %7, i64 %idxprom7
  %9 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %9 to i32
  %cmp10 = icmp eq i32 %conv9, 0
  br i1 %cmp10, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %if.end6
  %10 = load ptr, ptr %code_length_bitdepth.addr, align 8
  %11 = load i8, ptr getelementptr inbounds ([18 x i8], ptr @BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask.kStorageOrder, i64 0, i64 1), align 1
  %idxprom12 = zext i8 %11 to i64
  %arrayidx13 = getelementptr inbounds i8, ptr %10, i64 %idxprom12
  %12 = load i8, ptr %arrayidx13, align 1
  %conv14 = zext i8 %12 to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then17, label %if.end25

if.then17:                                        ; preds = %land.lhs.true
  store i64 2, ptr %skip_some, align 8
  %13 = load ptr, ptr %code_length_bitdepth.addr, align 8
  %14 = load i8, ptr getelementptr inbounds ([18 x i8], ptr @BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask.kStorageOrder, i64 0, i64 2), align 2
  %idxprom18 = zext i8 %14 to i64
  %arrayidx19 = getelementptr inbounds i8, ptr %13, i64 %idxprom18
  %15 = load i8, ptr %arrayidx19, align 1
  %conv20 = zext i8 %15 to i32
  %cmp21 = icmp eq i32 %conv20, 0
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then17
  store i64 3, ptr %skip_some, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.then17
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %land.lhs.true, %if.end6
  %16 = load i64, ptr %skip_some, align 8
  %17 = load ptr, ptr %storage_ix.addr, align 8
  %18 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  call void @llvm.experimental.noalias.scope.decl(metadata !11)
  store i64 2, ptr %n_bits.addr.i40, align 8, !noalias !13
  store i64 %16, ptr %bits.addr.i41, align 8, !noalias !13
  store ptr %17, ptr %pos.addr.i42, align 8, !noalias !13
  store ptr %18, ptr %array.addr.i43, align 8, !noalias !13
  %19 = load ptr, ptr %array.addr.i43, align 8, !noalias !13
  %20 = load ptr, ptr %pos.addr.i42, align 8, !noalias !13
  %21 = load i64, ptr %20, align 8
  %shr.i46 = lshr i64 %21, 3
  %arrayidx.i47 = getelementptr inbounds i8, ptr %19, i64 %shr.i46
  store ptr %arrayidx.i47, ptr %p.i44, align 8, !noalias !13
  %22 = load ptr, ptr %p.i44, align 8, !noalias !13
  %23 = load i8, ptr %22, align 1
  %conv.i48 = zext i8 %23 to i64
  store i64 %conv.i48, ptr %v.i45, align 8, !noalias !13
  %24 = load i64, ptr %bits.addr.i41, align 8, !noalias !13
  %25 = load ptr, ptr %pos.addr.i42, align 8, !noalias !13
  %26 = load i64, ptr %25, align 8
  %and.i49 = and i64 %26, 7
  %shl.i50 = shl i64 %24, %and.i49
  %27 = load i64, ptr %v.i45, align 8, !noalias !13
  %or.i51 = or i64 %27, %shl.i50
  store i64 %or.i51, ptr %v.i45, align 8, !noalias !13
  %28 = load ptr, ptr %p.i44, align 8, !noalias !13
  %29 = load i64, ptr %v.i45, align 8, !noalias !13
  store ptr %28, ptr %p.addr.i, align 8
  store i64 %29, ptr %v.addr.i, align 8
  %30 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %30, ptr align 8 %v.addr.i, i64 8, i1 false)
  %31 = load i64, ptr %n_bits.addr.i40, align 8, !noalias !13
  %32 = load ptr, ptr %pos.addr.i42, align 8, !noalias !13
  %33 = load i64, ptr %32, align 8
  %add.i52 = add i64 %33, %31
  store i64 %add.i52, ptr %32, align 8
  %34 = load i64, ptr %skip_some, align 8
  store i64 %34, ptr %i, align 8
  br label %for.cond26

for.cond26:                                       ; preds = %for.inc38, %if.end25
  %35 = load i64, ptr %i, align 8
  %36 = load i64, ptr %codes_to_store, align 8
  %cmp27 = icmp ult i64 %35, %36
  br i1 %cmp27, label %for.body29, label %for.end39

for.body29:                                       ; preds = %for.cond26
  %37 = load ptr, ptr %code_length_bitdepth.addr, align 8
  %38 = load i64, ptr %i, align 8
  %arrayidx30 = getelementptr inbounds [18 x i8], ptr @BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask.kStorageOrder, i64 0, i64 %38
  %39 = load i8, ptr %arrayidx30, align 1
  %idxprom31 = zext i8 %39 to i64
  %arrayidx32 = getelementptr inbounds i8, ptr %37, i64 %idxprom31
  %40 = load i8, ptr %arrayidx32, align 1
  %conv33 = zext i8 %40 to i64
  store i64 %conv33, ptr %l, align 8
  %41 = load i64, ptr %l, align 8
  %arrayidx34 = getelementptr inbounds [6 x i8], ptr @BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask.kHuffmanBitLengthHuffmanCodeBitLengths, i64 0, i64 %41
  %42 = load i8, ptr %arrayidx34, align 1
  %conv35 = zext i8 %42 to i64
  %43 = load i64, ptr %l, align 8
  %arrayidx36 = getelementptr inbounds [6 x i8], ptr @BrotliStoreHuffmanTreeOfHuffmanTreeToBitMask.kHuffmanBitLengthHuffmanCodeSymbols, i64 0, i64 %43
  %44 = load i8, ptr %arrayidx36, align 1
  %conv37 = zext i8 %44 to i64
  %45 = load ptr, ptr %storage_ix.addr, align 8
  %46 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !14)
  call void @llvm.experimental.noalias.scope.decl(metadata !17)
  store i64 %conv35, ptr %n_bits.addr.i, align 8, !noalias !19
  store i64 %conv37, ptr %bits.addr.i, align 8, !noalias !19
  store ptr %45, ptr %pos.addr.i, align 8, !noalias !19
  store ptr %46, ptr %array.addr.i, align 8, !noalias !19
  %47 = load ptr, ptr %array.addr.i, align 8, !noalias !19
  %48 = load ptr, ptr %pos.addr.i, align 8, !noalias !19
  %49 = load i64, ptr %48, align 8
  %shr.i = lshr i64 %49, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %47, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !19
  %50 = load ptr, ptr %p.i, align 8, !noalias !19
  %51 = load i8, ptr %50, align 1
  %conv.i = zext i8 %51 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !19
  %52 = load i64, ptr %bits.addr.i, align 8, !noalias !19
  %53 = load ptr, ptr %pos.addr.i, align 8, !noalias !19
  %54 = load i64, ptr %53, align 8
  %and.i = and i64 %54, 7
  %shl.i = shl i64 %52, %and.i
  %55 = load i64, ptr %v.i, align 8, !noalias !19
  %or.i = or i64 %55, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !19
  %56 = load ptr, ptr %p.i, align 8, !noalias !19
  %57 = load i64, ptr %v.i, align 8, !noalias !19
  store ptr %56, ptr %p.addr.i53, align 8
  store i64 %57, ptr %v.addr.i54, align 8
  %58 = load ptr, ptr %p.addr.i53, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %58, ptr align 8 %v.addr.i54, i64 8, i1 false)
  %59 = load i64, ptr %n_bits.addr.i, align 8, !noalias !19
  %60 = load ptr, ptr %pos.addr.i, align 8, !noalias !19
  %61 = load i64, ptr %60, align 8
  %add.i = add i64 %61, %59
  store i64 %add.i, ptr %60, align 8
  br label %for.inc38

for.inc38:                                        ; preds = %for.body29
  %62 = load i64, ptr %i, align 8
  %inc = add i64 %62, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond26, !llvm.loop !20

for.end39:                                        ; preds = %for.cond26
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @BrotliStoreHuffmanTreeToBitMask(i64 noundef %huffman_tree_size, ptr noundef %huffman_tree, ptr noundef %huffman_tree_extra_bits, ptr noundef %code_length_bitdepth, ptr noundef %code_length_bitdepth_symbols, ptr noalias noundef %storage_ix, ptr noalias noundef %storage) #0 {
entry:
  %p.addr.i38 = alloca ptr, align 8
  %v.addr.i39 = alloca i64, align 8
  %p.addr.i36 = alloca ptr, align 8
  %v.addr.i37 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i23 = alloca i64, align 8
  %bits.addr.i24 = alloca i64, align 8
  %pos.addr.i25 = alloca ptr, align 8
  %array.addr.i26 = alloca ptr, align 8
  %p.i27 = alloca ptr, align 8
  %v.i28 = alloca i64, align 8
  %n_bits.addr.i10 = alloca i64, align 8
  %bits.addr.i11 = alloca i64, align 8
  %pos.addr.i12 = alloca ptr, align 8
  %array.addr.i13 = alloca ptr, align 8
  %p.i14 = alloca ptr, align 8
  %v.i15 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %huffman_tree_size.addr = alloca i64, align 8
  %huffman_tree.addr = alloca ptr, align 8
  %huffman_tree_extra_bits.addr = alloca ptr, align 8
  %code_length_bitdepth.addr = alloca ptr, align 8
  %code_length_bitdepth_symbols.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %ix = alloca i64, align 8
  store i64 %huffman_tree_size, ptr %huffman_tree_size.addr, align 8
  store ptr %huffman_tree, ptr %huffman_tree.addr, align 8
  store ptr %huffman_tree_extra_bits, ptr %huffman_tree_extra_bits.addr, align 8
  store ptr %code_length_bitdepth, ptr %code_length_bitdepth.addr, align 8
  store ptr %code_length_bitdepth_symbols, ptr %code_length_bitdepth_symbols.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %1 = load i64, ptr %huffman_tree_size.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %huffman_tree.addr, align 8
  %3 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds i8, ptr %2, i64 %3
  %4 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %4 to i64
  store i64 %conv, ptr %ix, align 8
  %5 = load ptr, ptr %code_length_bitdepth.addr, align 8
  %6 = load i64, ptr %ix, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %5, i64 %6
  %7 = load i8, ptr %arrayidx1, align 1
  %conv2 = zext i8 %7 to i64
  %8 = load ptr, ptr %code_length_bitdepth_symbols.addr, align 8
  %9 = load i64, ptr %ix, align 8
  %arrayidx3 = getelementptr inbounds i16, ptr %8, i64 %9
  %10 = load i16, ptr %arrayidx3, align 2
  %conv4 = zext i16 %10 to i64
  %11 = load ptr, ptr %storage_ix.addr, align 8
  %12 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !21)
  call void @llvm.experimental.noalias.scope.decl(metadata !24)
  store i64 %conv2, ptr %n_bits.addr.i23, align 8, !noalias !26
  store i64 %conv4, ptr %bits.addr.i24, align 8, !noalias !26
  store ptr %11, ptr %pos.addr.i25, align 8, !noalias !26
  store ptr %12, ptr %array.addr.i26, align 8, !noalias !26
  %13 = load ptr, ptr %array.addr.i26, align 8, !noalias !26
  %14 = load ptr, ptr %pos.addr.i25, align 8, !noalias !26
  %15 = load i64, ptr %14, align 8
  %shr.i29 = lshr i64 %15, 3
  %arrayidx.i30 = getelementptr inbounds i8, ptr %13, i64 %shr.i29
  store ptr %arrayidx.i30, ptr %p.i27, align 8, !noalias !26
  %16 = load ptr, ptr %p.i27, align 8, !noalias !26
  %17 = load i8, ptr %16, align 1
  %conv.i31 = zext i8 %17 to i64
  store i64 %conv.i31, ptr %v.i28, align 8, !noalias !26
  %18 = load i64, ptr %bits.addr.i24, align 8, !noalias !26
  %19 = load ptr, ptr %pos.addr.i25, align 8, !noalias !26
  %20 = load i64, ptr %19, align 8
  %and.i32 = and i64 %20, 7
  %shl.i33 = shl i64 %18, %and.i32
  %21 = load i64, ptr %v.i28, align 8, !noalias !26
  %or.i34 = or i64 %21, %shl.i33
  store i64 %or.i34, ptr %v.i28, align 8, !noalias !26
  %22 = load ptr, ptr %p.i27, align 8, !noalias !26
  %23 = load i64, ptr %v.i28, align 8, !noalias !26
  store ptr %22, ptr %p.addr.i, align 8
  store i64 %23, ptr %v.addr.i, align 8
  %24 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %24, ptr align 8 %v.addr.i, i64 8, i1 false)
  %25 = load i64, ptr %n_bits.addr.i23, align 8, !noalias !26
  %26 = load ptr, ptr %pos.addr.i25, align 8, !noalias !26
  %27 = load i64, ptr %26, align 8
  %add.i35 = add i64 %27, %25
  store i64 %add.i35, ptr %26, align 8
  %28 = load i64, ptr %ix, align 8
  switch i64 %28, label %sw.epilog [
    i64 16, label %sw.bb
    i64 17, label %sw.bb7
  ]

sw.bb:                                            ; preds = %for.body
  %29 = load ptr, ptr %huffman_tree_extra_bits.addr, align 8
  %30 = load i64, ptr %i, align 8
  %arrayidx5 = getelementptr inbounds i8, ptr %29, i64 %30
  %31 = load i8, ptr %arrayidx5, align 1
  %conv6 = zext i8 %31 to i64
  %32 = load ptr, ptr %storage_ix.addr, align 8
  %33 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !27)
  call void @llvm.experimental.noalias.scope.decl(metadata !30)
  store i64 2, ptr %n_bits.addr.i10, align 8, !noalias !32
  store i64 %conv6, ptr %bits.addr.i11, align 8, !noalias !32
  store ptr %32, ptr %pos.addr.i12, align 8, !noalias !32
  store ptr %33, ptr %array.addr.i13, align 8, !noalias !32
  %34 = load ptr, ptr %array.addr.i13, align 8, !noalias !32
  %35 = load ptr, ptr %pos.addr.i12, align 8, !noalias !32
  %36 = load i64, ptr %35, align 8
  %shr.i16 = lshr i64 %36, 3
  %arrayidx.i17 = getelementptr inbounds i8, ptr %34, i64 %shr.i16
  store ptr %arrayidx.i17, ptr %p.i14, align 8, !noalias !32
  %37 = load ptr, ptr %p.i14, align 8, !noalias !32
  %38 = load i8, ptr %37, align 1
  %conv.i18 = zext i8 %38 to i64
  store i64 %conv.i18, ptr %v.i15, align 8, !noalias !32
  %39 = load i64, ptr %bits.addr.i11, align 8, !noalias !32
  %40 = load ptr, ptr %pos.addr.i12, align 8, !noalias !32
  %41 = load i64, ptr %40, align 8
  %and.i19 = and i64 %41, 7
  %shl.i20 = shl i64 %39, %and.i19
  %42 = load i64, ptr %v.i15, align 8, !noalias !32
  %or.i21 = or i64 %42, %shl.i20
  store i64 %or.i21, ptr %v.i15, align 8, !noalias !32
  %43 = load ptr, ptr %p.i14, align 8, !noalias !32
  %44 = load i64, ptr %v.i15, align 8, !noalias !32
  store ptr %43, ptr %p.addr.i36, align 8
  store i64 %44, ptr %v.addr.i37, align 8
  %45 = load ptr, ptr %p.addr.i36, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %45, ptr align 8 %v.addr.i37, i64 8, i1 false)
  %46 = load i64, ptr %n_bits.addr.i10, align 8, !noalias !32
  %47 = load ptr, ptr %pos.addr.i12, align 8, !noalias !32
  %48 = load i64, ptr %47, align 8
  %add.i22 = add i64 %48, %46
  store i64 %add.i22, ptr %47, align 8
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.body
  %49 = load ptr, ptr %huffman_tree_extra_bits.addr, align 8
  %50 = load i64, ptr %i, align 8
  %arrayidx8 = getelementptr inbounds i8, ptr %49, i64 %50
  %51 = load i8, ptr %arrayidx8, align 1
  %conv9 = zext i8 %51 to i64
  %52 = load ptr, ptr %storage_ix.addr, align 8
  %53 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !33)
  call void @llvm.experimental.noalias.scope.decl(metadata !36)
  store i64 3, ptr %n_bits.addr.i, align 8, !noalias !38
  store i64 %conv9, ptr %bits.addr.i, align 8, !noalias !38
  store ptr %52, ptr %pos.addr.i, align 8, !noalias !38
  store ptr %53, ptr %array.addr.i, align 8, !noalias !38
  %54 = load ptr, ptr %array.addr.i, align 8, !noalias !38
  %55 = load ptr, ptr %pos.addr.i, align 8, !noalias !38
  %56 = load i64, ptr %55, align 8
  %shr.i = lshr i64 %56, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %54, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !38
  %57 = load ptr, ptr %p.i, align 8, !noalias !38
  %58 = load i8, ptr %57, align 1
  %conv.i = zext i8 %58 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !38
  %59 = load i64, ptr %bits.addr.i, align 8, !noalias !38
  %60 = load ptr, ptr %pos.addr.i, align 8, !noalias !38
  %61 = load i64, ptr %60, align 8
  %and.i = and i64 %61, 7
  %shl.i = shl i64 %59, %and.i
  %62 = load i64, ptr %v.i, align 8, !noalias !38
  %or.i = or i64 %62, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !38
  %63 = load ptr, ptr %p.i, align 8, !noalias !38
  %64 = load i64, ptr %v.i, align 8, !noalias !38
  store ptr %63, ptr %p.addr.i38, align 8
  store i64 %64, ptr %v.addr.i39, align 8
  %65 = load ptr, ptr %p.addr.i38, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %65, ptr align 8 %v.addr.i39, i64 8, i1 false)
  %66 = load i64, ptr %n_bits.addr.i, align 8, !noalias !38
  %67 = load ptr, ptr %pos.addr.i, align 8, !noalias !38
  %68 = load i64, ptr %67, align 8
  %add.i = add i64 %68, %66
  store i64 %add.i, ptr %67, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb7, %sw.bb, %for.body
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %69 = load i64, ptr %i, align 8
  %inc = add i64 %69, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !39

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @BrotliBuildAndStoreHuffmanTreeFast(ptr noundef %tree, ptr noundef %histogram, i64 noundef %histogram_total, i64 noundef %max_bits, ptr noundef %depth, ptr noundef %bits, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i487 = alloca ptr, align 8
  %v.addr.i488 = alloca i64, align 8
  %p.addr.i485 = alloca ptr, align 8
  %v.addr.i486 = alloca i64, align 8
  %p.addr.i483 = alloca ptr, align 8
  %v.addr.i484 = alloca i64, align 8
  %p.addr.i481 = alloca ptr, align 8
  %v.addr.i482 = alloca i64, align 8
  %p.addr.i479 = alloca ptr, align 8
  %v.addr.i480 = alloca i64, align 8
  %p.addr.i477 = alloca ptr, align 8
  %v.addr.i478 = alloca i64, align 8
  %p.addr.i475 = alloca ptr, align 8
  %v.addr.i476 = alloca i64, align 8
  %p.addr.i473 = alloca ptr, align 8
  %v.addr.i474 = alloca i64, align 8
  %p.addr.i471 = alloca ptr, align 8
  %v.addr.i472 = alloca i64, align 8
  %p.addr.i469 = alloca ptr, align 8
  %v.addr.i470 = alloca i64, align 8
  %p.addr.i467 = alloca ptr, align 8
  %v.addr.i468 = alloca i64, align 8
  %p.addr.i465 = alloca ptr, align 8
  %v.addr.i466 = alloca i64, align 8
  %p.addr.i463 = alloca ptr, align 8
  %v.addr.i464 = alloca i64, align 8
  %p.addr.i461 = alloca ptr, align 8
  %v.addr.i462 = alloca i64, align 8
  %p.addr.i459 = alloca ptr, align 8
  %v.addr.i460 = alloca i64, align 8
  %p.addr.i457 = alloca ptr, align 8
  %v.addr.i458 = alloca i64, align 8
  %p.addr.i455 = alloca ptr, align 8
  %v.addr.i456 = alloca i64, align 8
  %p.addr.i453 = alloca ptr, align 8
  %v.addr.i454 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i.i = alloca i64, align 8
  %bits.addr.i.i = alloca i64, align 8
  %pos.addr.i.i = alloca ptr, align 8
  %array.addr.i.i = alloca ptr, align 8
  %p.i.i = alloca ptr, align 8
  %v.i.i = alloca i64, align 8
  %storage_ix.addr.i = alloca ptr, align 8
  %storage.addr.i = alloca ptr, align 8
  %items.addr.i = alloca ptr, align 8
  %n.addr.i = alloca i64, align 8
  %comparator.addr.i = alloca ptr, align 8
  %i.i = alloca i64, align 8
  %tmp.i = alloca %struct.HuffmanTree, align 4
  %k.i = alloca i64, align 8
  %j.i = alloca i64, align 8
  %g.i = alloca i32, align 4
  %gap.i = alloca i64, align 8
  %i13.i = alloca i64, align 8
  %j17.i = alloca i64, align 8
  %tmp18.i = alloca %struct.HuffmanTree, align 4
  %self.addr.i446 = alloca ptr, align 8
  %count.addr.i447 = alloca i32, align 4
  %left.addr.i448 = alloca i16, align 2
  %right.addr.i449 = alloca i16, align 2
  %self.addr.i440 = alloca ptr, align 8
  %count.addr.i441 = alloca i32, align 4
  %left.addr.i442 = alloca i16, align 2
  %right.addr.i443 = alloca i16, align 2
  %self.addr.i = alloca ptr, align 8
  %count.addr.i = alloca i32, align 4
  %left.addr.i = alloca i16, align 2
  %right.addr.i = alloca i16, align 2
  %n_bits.addr.i427 = alloca i64, align 8
  %bits.addr.i428 = alloca i64, align 8
  %pos.addr.i429 = alloca ptr, align 8
  %array.addr.i430 = alloca ptr, align 8
  %p.i431 = alloca ptr, align 8
  %v.i432 = alloca i64, align 8
  %n_bits.addr.i414 = alloca i64, align 8
  %bits.addr.i415 = alloca i64, align 8
  %pos.addr.i416 = alloca ptr, align 8
  %array.addr.i417 = alloca ptr, align 8
  %p.i418 = alloca ptr, align 8
  %v.i419 = alloca i64, align 8
  %n_bits.addr.i401 = alloca i64, align 8
  %bits.addr.i402 = alloca i64, align 8
  %pos.addr.i403 = alloca ptr, align 8
  %array.addr.i404 = alloca ptr, align 8
  %p.i405 = alloca ptr, align 8
  %v.i406 = alloca i64, align 8
  %n_bits.addr.i388 = alloca i64, align 8
  %bits.addr.i389 = alloca i64, align 8
  %pos.addr.i390 = alloca ptr, align 8
  %array.addr.i391 = alloca ptr, align 8
  %p.i392 = alloca ptr, align 8
  %v.i393 = alloca i64, align 8
  %n_bits.addr.i375 = alloca i64, align 8
  %bits.addr.i376 = alloca i64, align 8
  %pos.addr.i377 = alloca ptr, align 8
  %array.addr.i378 = alloca ptr, align 8
  %p.i379 = alloca ptr, align 8
  %v.i380 = alloca i64, align 8
  %n_bits.addr.i362 = alloca i64, align 8
  %bits.addr.i363 = alloca i64, align 8
  %pos.addr.i364 = alloca ptr, align 8
  %array.addr.i365 = alloca ptr, align 8
  %p.i366 = alloca ptr, align 8
  %v.i367 = alloca i64, align 8
  %n_bits.addr.i349 = alloca i64, align 8
  %bits.addr.i350 = alloca i64, align 8
  %pos.addr.i351 = alloca ptr, align 8
  %array.addr.i352 = alloca ptr, align 8
  %p.i353 = alloca ptr, align 8
  %v.i354 = alloca i64, align 8
  %n_bits.addr.i336 = alloca i64, align 8
  %bits.addr.i337 = alloca i64, align 8
  %pos.addr.i338 = alloca ptr, align 8
  %array.addr.i339 = alloca ptr, align 8
  %p.i340 = alloca ptr, align 8
  %v.i341 = alloca i64, align 8
  %n_bits.addr.i323 = alloca i64, align 8
  %bits.addr.i324 = alloca i64, align 8
  %pos.addr.i325 = alloca ptr, align 8
  %array.addr.i326 = alloca ptr, align 8
  %p.i327 = alloca ptr, align 8
  %v.i328 = alloca i64, align 8
  %n_bits.addr.i310 = alloca i64, align 8
  %bits.addr.i311 = alloca i64, align 8
  %pos.addr.i312 = alloca ptr, align 8
  %array.addr.i313 = alloca ptr, align 8
  %p.i314 = alloca ptr, align 8
  %v.i315 = alloca i64, align 8
  %n_bits.addr.i297 = alloca i64, align 8
  %bits.addr.i298 = alloca i64, align 8
  %pos.addr.i299 = alloca ptr, align 8
  %array.addr.i300 = alloca ptr, align 8
  %p.i301 = alloca ptr, align 8
  %v.i302 = alloca i64, align 8
  %n_bits.addr.i284 = alloca i64, align 8
  %bits.addr.i285 = alloca i64, align 8
  %pos.addr.i286 = alloca ptr, align 8
  %array.addr.i287 = alloca ptr, align 8
  %p.i288 = alloca ptr, align 8
  %v.i289 = alloca i64, align 8
  %n_bits.addr.i271 = alloca i64, align 8
  %bits.addr.i272 = alloca i64, align 8
  %pos.addr.i273 = alloca ptr, align 8
  %array.addr.i274 = alloca ptr, align 8
  %p.i275 = alloca ptr, align 8
  %v.i276 = alloca i64, align 8
  %n_bits.addr.i258 = alloca i64, align 8
  %bits.addr.i259 = alloca i64, align 8
  %pos.addr.i260 = alloca ptr, align 8
  %array.addr.i261 = alloca ptr, align 8
  %p.i262 = alloca ptr, align 8
  %v.i263 = alloca i64, align 8
  %n_bits.addr.i245 = alloca i64, align 8
  %bits.addr.i246 = alloca i64, align 8
  %pos.addr.i247 = alloca ptr, align 8
  %array.addr.i248 = alloca ptr, align 8
  %p.i249 = alloca ptr, align 8
  %v.i250 = alloca i64, align 8
  %n_bits.addr.i232 = alloca i64, align 8
  %bits.addr.i233 = alloca i64, align 8
  %pos.addr.i234 = alloca ptr, align 8
  %array.addr.i235 = alloca ptr, align 8
  %p.i236 = alloca ptr, align 8
  %v.i237 = alloca i64, align 8
  %n_bits.addr.i219 = alloca i64, align 8
  %bits.addr.i220 = alloca i64, align 8
  %pos.addr.i221 = alloca ptr, align 8
  %array.addr.i222 = alloca ptr, align 8
  %p.i223 = alloca ptr, align 8
  %v.i224 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %tree.addr = alloca ptr, align 8
  %histogram.addr = alloca ptr, align 8
  %histogram_total.addr = alloca i64, align 8
  %max_bits.addr = alloca i64, align 8
  %depth.addr = alloca ptr, align 8
  %bits.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %count = alloca i64, align 8
  %symbols = alloca [4 x i64], align 16
  %length = alloca i64, align 8
  %total = alloca i64, align 8
  %count_limit = alloca i32, align 4
  %node = alloca ptr, align 8
  %l = alloca i64, align 8
  %n = alloca i32, align 4
  %sentinel = alloca %struct.HuffmanTree, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %left = alloca i32, align 4
  %right = alloca i32, align 4
  %i94 = alloca i64, align 8
  %j100 = alloca i64, align 8
  %__brotli_swap_tmp = alloca i64, align 8
  %previous_value = alloca i8, align 1
  %i152 = alloca i64, align 8
  %value = alloca i8, align 1
  %reps = alloca i64, align 8
  %k158 = alloca i64, align 8
  store ptr %tree, ptr %tree.addr, align 8
  store ptr %histogram, ptr %histogram.addr, align 8
  store i64 %histogram_total, ptr %histogram_total.addr, align 8
  store i64 %max_bits, ptr %max_bits.addr, align 8
  store ptr %depth, ptr %depth.addr, align 8
  store ptr %bits, ptr %bits.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  store i64 0, ptr %count, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %symbols, i8 0, i64 32, i1 false)
  store i64 0, ptr %length, align 8
  %0 = load i64, ptr %histogram_total.addr, align 8
  store i64 %0, ptr %total, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end5, %entry
  %1 = load i64, ptr %total, align 8
  %cmp = icmp ne i64 %1, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load ptr, ptr %histogram.addr, align 8
  %3 = load i64, ptr %length, align 8
  %arrayidx = getelementptr inbounds i32, ptr %2, i64 %3
  %4 = load i32, ptr %arrayidx, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end5

if.then:                                          ; preds = %while.body
  %5 = load i64, ptr %count, align 8
  %cmp1 = icmp ult i64 %5, 4
  br i1 %cmp1, label %if.then2, label %if.end

if.then2:                                         ; preds = %if.then
  %6 = load i64, ptr %length, align 8
  %7 = load i64, ptr %count, align 8
  %arrayidx3 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 %7
  store i64 %6, ptr %arrayidx3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %8 = load i64, ptr %count, align 8
  %inc = add i64 %8, 1
  store i64 %inc, ptr %count, align 8
  %9 = load ptr, ptr %histogram.addr, align 8
  %10 = load i64, ptr %length, align 8
  %arrayidx4 = getelementptr inbounds i32, ptr %9, i64 %10
  %11 = load i32, ptr %arrayidx4, align 4
  %conv = zext i32 %11 to i64
  %12 = load i64, ptr %total, align 8
  %sub = sub i64 %12, %conv
  store i64 %sub, ptr %total, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.end, %while.body
  %13 = load i64, ptr %length, align 8
  %inc6 = add i64 %13, 1
  store i64 %inc6, ptr %length, align 8
  br label %while.cond, !llvm.loop !40

while.end:                                        ; preds = %while.cond
  %14 = load i64, ptr %count, align 8
  %cmp7 = icmp ule i64 %14, 1
  br i1 %cmp7, label %if.then9, label %if.end15

if.then9:                                         ; preds = %while.end
  %15 = load ptr, ptr %storage_ix.addr, align 8
  %16 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !41)
  call void @llvm.experimental.noalias.scope.decl(metadata !44)
  store i64 4, ptr %n_bits.addr.i427, align 8, !noalias !46
  store i64 1, ptr %bits.addr.i428, align 8, !noalias !46
  store ptr %15, ptr %pos.addr.i429, align 8, !noalias !46
  store ptr %16, ptr %array.addr.i430, align 8, !noalias !46
  %17 = load ptr, ptr %array.addr.i430, align 8, !noalias !46
  %18 = load ptr, ptr %pos.addr.i429, align 8, !noalias !46
  %19 = load i64, ptr %18, align 8
  %shr.i433 = lshr i64 %19, 3
  %arrayidx.i434 = getelementptr inbounds i8, ptr %17, i64 %shr.i433
  store ptr %arrayidx.i434, ptr %p.i431, align 8, !noalias !46
  %20 = load ptr, ptr %p.i431, align 8, !noalias !46
  %21 = load i8, ptr %20, align 1
  %conv.i435 = zext i8 %21 to i64
  store i64 %conv.i435, ptr %v.i432, align 8, !noalias !46
  %22 = load i64, ptr %bits.addr.i428, align 8, !noalias !46
  %23 = load ptr, ptr %pos.addr.i429, align 8, !noalias !46
  %24 = load i64, ptr %23, align 8
  %and.i436 = and i64 %24, 7
  %shl.i437 = shl i64 %22, %and.i436
  %25 = load i64, ptr %v.i432, align 8, !noalias !46
  %or.i438 = or i64 %25, %shl.i437
  store i64 %or.i438, ptr %v.i432, align 8, !noalias !46
  %26 = load ptr, ptr %p.i431, align 8, !noalias !46
  %27 = load i64, ptr %v.i432, align 8, !noalias !46
  store ptr %26, ptr %p.addr.i453, align 8
  store i64 %27, ptr %v.addr.i454, align 8
  %28 = load ptr, ptr %p.addr.i453, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %28, ptr align 8 %v.addr.i454, i64 8, i1 false)
  %29 = load i64, ptr %n_bits.addr.i427, align 8, !noalias !46
  %30 = load ptr, ptr %pos.addr.i429, align 8, !noalias !46
  %31 = load i64, ptr %30, align 8
  %add.i439 = add i64 %31, %29
  store i64 %add.i439, ptr %30, align 8
  %32 = load i64, ptr %max_bits.addr, align 8
  %arrayidx10 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 0
  %33 = load i64, ptr %arrayidx10, align 16
  %34 = load ptr, ptr %storage_ix.addr, align 8
  %35 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !47)
  call void @llvm.experimental.noalias.scope.decl(metadata !50)
  store i64 %32, ptr %n_bits.addr.i414, align 8, !noalias !52
  store i64 %33, ptr %bits.addr.i415, align 8, !noalias !52
  store ptr %34, ptr %pos.addr.i416, align 8, !noalias !52
  store ptr %35, ptr %array.addr.i417, align 8, !noalias !52
  %36 = load ptr, ptr %array.addr.i417, align 8, !noalias !52
  %37 = load ptr, ptr %pos.addr.i416, align 8, !noalias !52
  %38 = load i64, ptr %37, align 8
  %shr.i420 = lshr i64 %38, 3
  %arrayidx.i421 = getelementptr inbounds i8, ptr %36, i64 %shr.i420
  store ptr %arrayidx.i421, ptr %p.i418, align 8, !noalias !52
  %39 = load ptr, ptr %p.i418, align 8, !noalias !52
  %40 = load i8, ptr %39, align 1
  %conv.i422 = zext i8 %40 to i64
  store i64 %conv.i422, ptr %v.i419, align 8, !noalias !52
  %41 = load i64, ptr %bits.addr.i415, align 8, !noalias !52
  %42 = load ptr, ptr %pos.addr.i416, align 8, !noalias !52
  %43 = load i64, ptr %42, align 8
  %and.i423 = and i64 %43, 7
  %shl.i424 = shl i64 %41, %and.i423
  %44 = load i64, ptr %v.i419, align 8, !noalias !52
  %or.i425 = or i64 %44, %shl.i424
  store i64 %or.i425, ptr %v.i419, align 8, !noalias !52
  %45 = load ptr, ptr %p.i418, align 8, !noalias !52
  %46 = load i64, ptr %v.i419, align 8, !noalias !52
  store ptr %45, ptr %p.addr.i455, align 8
  store i64 %46, ptr %v.addr.i456, align 8
  %47 = load ptr, ptr %p.addr.i455, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %47, ptr align 8 %v.addr.i456, i64 8, i1 false)
  %48 = load i64, ptr %n_bits.addr.i414, align 8, !noalias !52
  %49 = load ptr, ptr %pos.addr.i416, align 8, !noalias !52
  %50 = load i64, ptr %49, align 8
  %add.i426 = add i64 %50, %48
  store i64 %add.i426, ptr %49, align 8
  %51 = load ptr, ptr %depth.addr, align 8
  %arrayidx11 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 0
  %52 = load i64, ptr %arrayidx11, align 16
  %arrayidx12 = getelementptr inbounds i8, ptr %51, i64 %52
  store i8 0, ptr %arrayidx12, align 1
  %53 = load ptr, ptr %bits.addr, align 8
  %arrayidx13 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 0
  %54 = load i64, ptr %arrayidx13, align 16
  %arrayidx14 = getelementptr inbounds i16, ptr %53, i64 %54
  store i16 0, ptr %arrayidx14, align 2
  br label %if.end218

if.end15:                                         ; preds = %while.end
  %55 = load ptr, ptr %depth.addr, align 8
  %56 = load i64, ptr %length, align 8
  %mul = mul i64 %56, 1
  call void @llvm.memset.p0.i64(ptr align 1 %55, i8 0, i64 %mul, i1 false)
  store i32 1, ptr %count_limit, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc88, %if.end15
  %57 = load ptr, ptr %tree.addr, align 8
  store ptr %57, ptr %node, align 8
  %58 = load i64, ptr %length, align 8
  store i64 %58, ptr %l, align 8
  br label %for.cond16

for.cond16:                                       ; preds = %if.end33, %for.cond
  %59 = load i64, ptr %l, align 8
  %cmp17 = icmp ne i64 %59, 0
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond16
  %60 = load i64, ptr %l, align 8
  %dec = add i64 %60, -1
  store i64 %dec, ptr %l, align 8
  %61 = load ptr, ptr %histogram.addr, align 8
  %62 = load i64, ptr %l, align 8
  %arrayidx19 = getelementptr inbounds i32, ptr %61, i64 %62
  %63 = load i32, ptr %arrayidx19, align 4
  %tobool20 = icmp ne i32 %63, 0
  br i1 %tobool20, label %if.then21, label %if.end33

if.then21:                                        ; preds = %for.body
  %64 = load ptr, ptr %histogram.addr, align 8
  %65 = load i64, ptr %l, align 8
  %arrayidx22 = getelementptr inbounds i32, ptr %64, i64 %65
  %66 = load i32, ptr %arrayidx22, align 4
  %67 = load i32, ptr %count_limit, align 4
  %cmp23 = icmp uge i32 %66, %67
  %lnot = xor i1 %cmp23, true
  %lnot25 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot25 to i32
  %conv26 = sext i32 %lnot.ext to i64
  %tobool27 = icmp ne i64 %conv26, 0
  br i1 %tobool27, label %if.then28, label %if.else

if.then28:                                        ; preds = %if.then21
  %68 = load ptr, ptr %node, align 8
  %69 = load ptr, ptr %histogram.addr, align 8
  %70 = load i64, ptr %l, align 8
  %arrayidx29 = getelementptr inbounds i32, ptr %69, i64 %70
  %71 = load i32, ptr %arrayidx29, align 4
  %72 = load i64, ptr %l, align 8
  %conv30 = trunc i64 %72 to i16
  store ptr %68, ptr %self.addr.i446, align 8
  store i32 %71, ptr %count.addr.i447, align 4
  store i16 -1, ptr %left.addr.i448, align 2
  store i16 %conv30, ptr %right.addr.i449, align 2
  %73 = load i32, ptr %count.addr.i447, align 4
  %74 = load ptr, ptr %self.addr.i446, align 8
  store i32 %73, ptr %74, align 4
  %75 = load i16, ptr %left.addr.i448, align 2
  %76 = load ptr, ptr %self.addr.i446, align 8
  %index_left_.i450 = getelementptr inbounds %struct.HuffmanTree, ptr %76, i32 0, i32 1
  store i16 %75, ptr %index_left_.i450, align 4
  %77 = load i16, ptr %right.addr.i449, align 2
  %78 = load ptr, ptr %self.addr.i446, align 8
  %index_right_or_value_.i451 = getelementptr inbounds %struct.HuffmanTree, ptr %78, i32 0, i32 2
  store i16 %77, ptr %index_right_or_value_.i451, align 2
  br label %if.end32

if.else:                                          ; preds = %if.then21
  %79 = load ptr, ptr %node, align 8
  %80 = load i32, ptr %count_limit, align 4
  %81 = load i64, ptr %l, align 8
  %conv31 = trunc i64 %81 to i16
  store ptr %79, ptr %self.addr.i440, align 8
  store i32 %80, ptr %count.addr.i441, align 4
  store i16 -1, ptr %left.addr.i442, align 2
  store i16 %conv31, ptr %right.addr.i443, align 2
  %82 = load i32, ptr %count.addr.i441, align 4
  %83 = load ptr, ptr %self.addr.i440, align 8
  store i32 %82, ptr %83, align 4
  %84 = load i16, ptr %left.addr.i442, align 2
  %85 = load ptr, ptr %self.addr.i440, align 8
  %index_left_.i444 = getelementptr inbounds %struct.HuffmanTree, ptr %85, i32 0, i32 1
  store i16 %84, ptr %index_left_.i444, align 4
  %86 = load i16, ptr %right.addr.i443, align 2
  %87 = load ptr, ptr %self.addr.i440, align 8
  %index_right_or_value_.i445 = getelementptr inbounds %struct.HuffmanTree, ptr %87, i32 0, i32 2
  store i16 %86, ptr %index_right_or_value_.i445, align 2
  br label %if.end32

if.end32:                                         ; preds = %if.else, %if.then28
  %88 = load ptr, ptr %node, align 8
  %incdec.ptr = getelementptr inbounds %struct.HuffmanTree, ptr %88, i32 1
  store ptr %incdec.ptr, ptr %node, align 8
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %for.body
  br label %for.cond16, !llvm.loop !53

for.end:                                          ; preds = %for.cond16
  %89 = load ptr, ptr %node, align 8
  %90 = load ptr, ptr %tree.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %89 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %90 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv34 = trunc i64 %sub.ptr.div to i32
  store i32 %conv34, ptr %n, align 4
  store i32 0, ptr %i, align 4
  %91 = load i32, ptr %n, align 4
  %add = add nsw i32 %91, 1
  store i32 %add, ptr %j, align 4
  %92 = load ptr, ptr %tree.addr, align 8
  %93 = load i32, ptr %n, align 4
  %conv35 = sext i32 %93 to i64
  store ptr %92, ptr %items.addr.i, align 8
  store i64 %conv35, ptr %n.addr.i, align 8
  store ptr @SortHuffmanTree, ptr %comparator.addr.i, align 8
  %94 = load i64, ptr %n.addr.i, align 8
  %cmp.i = icmp ult i64 %94, 13
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %for.end
  store i64 1, ptr %i.i, align 8
  br label %for.cond.i

for.cond.i:                                       ; preds = %while.end.i, %if.then.i
  %95 = load i64, ptr %i.i, align 8
  %96 = load i64, ptr %n.addr.i, align 8
  %cmp1.i = icmp ult i64 %95, %96
  br i1 %cmp1.i, label %for.body.i, label %for.end.i

for.body.i:                                       ; preds = %for.cond.i
  %97 = load ptr, ptr %items.addr.i, align 8
  %98 = load i64, ptr %i.i, align 8
  %arrayidx.i452 = getelementptr inbounds %struct.HuffmanTree, ptr %97, i64 %98
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %tmp.i, ptr align 4 %arrayidx.i452, i64 8, i1 false)
  %99 = load i64, ptr %i.i, align 8
  store i64 %99, ptr %k.i, align 8
  %100 = load i64, ptr %i.i, align 8
  %sub.i = sub i64 %100, 1
  store i64 %sub.i, ptr %j.i, align 8
  br label %while.cond.i

while.cond.i:                                     ; preds = %if.end.i, %for.body.i
  %101 = load ptr, ptr %comparator.addr.i, align 8
  %102 = load ptr, ptr %items.addr.i, align 8
  %103 = load i64, ptr %j.i, align 8
  %arrayidx2.i = getelementptr inbounds %struct.HuffmanTree, ptr %102, i64 %103
  %call.i = call i32 %101(ptr noundef %tmp.i, ptr noundef %arrayidx2.i) #7
  %tobool.i = icmp ne i32 %call.i, 0
  br i1 %tobool.i, label %while.body.i, label %while.end.i

while.body.i:                                     ; preds = %while.cond.i
  %104 = load ptr, ptr %items.addr.i, align 8
  %105 = load i64, ptr %k.i, align 8
  %arrayidx3.i = getelementptr inbounds %struct.HuffmanTree, ptr %104, i64 %105
  %106 = load ptr, ptr %items.addr.i, align 8
  %107 = load i64, ptr %j.i, align 8
  %arrayidx4.i = getelementptr inbounds %struct.HuffmanTree, ptr %106, i64 %107
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx3.i, ptr align 4 %arrayidx4.i, i64 8, i1 false)
  %108 = load i64, ptr %j.i, align 8
  store i64 %108, ptr %k.i, align 8
  %109 = load i64, ptr %j.i, align 8
  %dec.i = add i64 %109, -1
  store i64 %dec.i, ptr %j.i, align 8
  %tobool5.i = icmp ne i64 %109, 0
  br i1 %tobool5.i, label %if.end.i, label %if.then6.i

if.then6.i:                                       ; preds = %while.body.i
  br label %while.end.i

if.end.i:                                         ; preds = %while.body.i
  br label %while.cond.i, !llvm.loop !54

while.end.i:                                      ; preds = %if.then6.i, %while.cond.i
  %110 = load ptr, ptr %items.addr.i, align 8
  %111 = load i64, ptr %k.i, align 8
  %arrayidx7.i = getelementptr inbounds %struct.HuffmanTree, ptr %110, i64 %111
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx7.i, ptr align 4 %tmp.i, i64 8, i1 false)
  %112 = load i64, ptr %i.i, align 8
  %inc.i = add i64 %112, 1
  store i64 %inc.i, ptr %i.i, align 8
  br label %for.cond.i, !llvm.loop !55

for.end.i:                                        ; preds = %for.cond.i
  br label %SortHuffmanTreeItems.exit

if.else.i:                                        ; preds = %for.end
  %113 = load i64, ptr %n.addr.i, align 8
  %cmp8.i = icmp ult i64 %113, 57
  %cond.i = select i1 %cmp8.i, i32 2, i32 0
  store i32 %cond.i, ptr %g.i, align 4
  br label %for.cond9.i

for.cond9.i:                                      ; preds = %for.end36.i, %if.else.i
  %114 = load i32, ptr %g.i, align 4
  %cmp10.i = icmp slt i32 %114, 6
  br i1 %cmp10.i, label %for.body11.i, label %for.end39.i

for.body11.i:                                     ; preds = %for.cond9.i
  %115 = load i32, ptr %g.i, align 4
  %idxprom.i = sext i32 %115 to i64
  %arrayidx12.i = getelementptr inbounds [6 x i64], ptr @kBrotliShellGaps, i64 0, i64 %idxprom.i
  %116 = load i64, ptr %arrayidx12.i, align 8
  store i64 %116, ptr %gap.i, align 8
  %117 = load i64, ptr %gap.i, align 8
  store i64 %117, ptr %i13.i, align 8
  br label %for.cond14.i

for.cond14.i:                                     ; preds = %for.end32.i, %for.body11.i
  %118 = load i64, ptr %i13.i, align 8
  %119 = load i64, ptr %n.addr.i, align 8
  %cmp15.i = icmp ult i64 %118, %119
  br i1 %cmp15.i, label %for.body16.i, label %for.end36.i

for.body16.i:                                     ; preds = %for.cond14.i
  %120 = load i64, ptr %i13.i, align 8
  store i64 %120, ptr %j17.i, align 8
  %121 = load ptr, ptr %items.addr.i, align 8
  %122 = load i64, ptr %i13.i, align 8
  %arrayidx19.i = getelementptr inbounds %struct.HuffmanTree, ptr %121, i64 %122
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %tmp18.i, ptr align 4 %arrayidx19.i, i64 8, i1 false)
  br label %for.cond20.i

for.cond20.i:                                     ; preds = %for.body26.i, %for.body16.i
  %123 = load i64, ptr %j17.i, align 8
  %124 = load i64, ptr %gap.i, align 8
  %cmp21.i = icmp uge i64 %123, %124
  br i1 %cmp21.i, label %land.rhs.i, label %land.end.i

land.rhs.i:                                       ; preds = %for.cond20.i
  %125 = load ptr, ptr %comparator.addr.i, align 8
  %126 = load ptr, ptr %items.addr.i, align 8
  %127 = load i64, ptr %j17.i, align 8
  %128 = load i64, ptr %gap.i, align 8
  %sub22.i = sub i64 %127, %128
  %arrayidx23.i = getelementptr inbounds %struct.HuffmanTree, ptr %126, i64 %sub22.i
  %call24.i = call i32 %125(ptr noundef %tmp18.i, ptr noundef %arrayidx23.i) #7
  %tobool25.i = icmp ne i32 %call24.i, 0
  br label %land.end.i

land.end.i:                                       ; preds = %land.rhs.i, %for.cond20.i
  %129 = phi i1 [ false, %for.cond20.i ], [ %tobool25.i, %land.rhs.i ]
  br i1 %129, label %for.body26.i, label %for.end32.i

for.body26.i:                                     ; preds = %land.end.i
  %130 = load ptr, ptr %items.addr.i, align 8
  %131 = load i64, ptr %j17.i, align 8
  %arrayidx27.i = getelementptr inbounds %struct.HuffmanTree, ptr %130, i64 %131
  %132 = load ptr, ptr %items.addr.i, align 8
  %133 = load i64, ptr %j17.i, align 8
  %134 = load i64, ptr %gap.i, align 8
  %sub28.i = sub i64 %133, %134
  %arrayidx29.i = getelementptr inbounds %struct.HuffmanTree, ptr %132, i64 %sub28.i
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx27.i, ptr align 4 %arrayidx29.i, i64 8, i1 false)
  %135 = load i64, ptr %gap.i, align 8
  %136 = load i64, ptr %j17.i, align 8
  %sub31.i = sub i64 %136, %135
  store i64 %sub31.i, ptr %j17.i, align 8
  br label %for.cond20.i, !llvm.loop !56

for.end32.i:                                      ; preds = %land.end.i
  %137 = load ptr, ptr %items.addr.i, align 8
  %138 = load i64, ptr %j17.i, align 8
  %arrayidx33.i = getelementptr inbounds %struct.HuffmanTree, ptr %137, i64 %138
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx33.i, ptr align 4 %tmp18.i, i64 8, i1 false)
  %139 = load i64, ptr %i13.i, align 8
  %inc35.i = add i64 %139, 1
  store i64 %inc35.i, ptr %i13.i, align 8
  br label %for.cond14.i, !llvm.loop !57

for.end36.i:                                      ; preds = %for.cond14.i
  %140 = load i32, ptr %g.i, align 4
  %inc38.i = add nsw i32 %140, 1
  store i32 %inc38.i, ptr %g.i, align 4
  br label %for.cond9.i, !llvm.loop !58

for.end39.i:                                      ; preds = %for.cond9.i
  br label %SortHuffmanTreeItems.exit

SortHuffmanTreeItems.exit:                        ; preds = %for.end39.i, %for.end.i
  store ptr %sentinel, ptr %self.addr.i, align 8
  store i32 -1, ptr %count.addr.i, align 4
  store i16 -1, ptr %left.addr.i, align 2
  store i16 -1, ptr %right.addr.i, align 2
  %141 = load i32, ptr %count.addr.i, align 4
  %142 = load ptr, ptr %self.addr.i, align 8
  store i32 %141, ptr %142, align 4
  %143 = load i16, ptr %left.addr.i, align 2
  %144 = load ptr, ptr %self.addr.i, align 8
  %index_left_.i = getelementptr inbounds %struct.HuffmanTree, ptr %144, i32 0, i32 1
  store i16 %143, ptr %index_left_.i, align 4
  %145 = load i16, ptr %right.addr.i, align 2
  %146 = load ptr, ptr %self.addr.i, align 8
  %index_right_or_value_.i = getelementptr inbounds %struct.HuffmanTree, ptr %146, i32 0, i32 2
  store i16 %145, ptr %index_right_or_value_.i, align 2
  %147 = load ptr, ptr %node, align 8
  %incdec.ptr36 = getelementptr inbounds %struct.HuffmanTree, ptr %147, i32 1
  store ptr %incdec.ptr36, ptr %node, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %147, ptr align 4 %sentinel, i64 8, i1 false)
  %148 = load ptr, ptr %node, align 8
  %incdec.ptr37 = getelementptr inbounds %struct.HuffmanTree, ptr %148, i32 1
  store ptr %incdec.ptr37, ptr %node, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %148, ptr align 4 %sentinel, i64 8, i1 false)
  %149 = load i32, ptr %n, align 4
  %sub38 = sub nsw i32 %149, 1
  store i32 %sub38, ptr %k, align 4
  br label %for.cond39

for.cond39:                                       ; preds = %for.inc, %SortHuffmanTreeItems.exit
  %150 = load i32, ptr %k, align 4
  %cmp40 = icmp sgt i32 %150, 0
  br i1 %cmp40, label %for.body42, label %for.end82

for.body42:                                       ; preds = %for.cond39
  %151 = load ptr, ptr %tree.addr, align 8
  %152 = load i32, ptr %i, align 4
  %idxprom = sext i32 %152 to i64
  %arrayidx43 = getelementptr inbounds %struct.HuffmanTree, ptr %151, i64 %idxprom
  %total_count_ = getelementptr inbounds %struct.HuffmanTree, ptr %arrayidx43, i32 0, i32 0
  %153 = load i32, ptr %total_count_, align 4
  %154 = load ptr, ptr %tree.addr, align 8
  %155 = load i32, ptr %j, align 4
  %idxprom44 = sext i32 %155 to i64
  %arrayidx45 = getelementptr inbounds %struct.HuffmanTree, ptr %154, i64 %idxprom44
  %total_count_46 = getelementptr inbounds %struct.HuffmanTree, ptr %arrayidx45, i32 0, i32 0
  %156 = load i32, ptr %total_count_46, align 4
  %cmp47 = icmp ule i32 %153, %156
  br i1 %cmp47, label %if.then49, label %if.else51

if.then49:                                        ; preds = %for.body42
  %157 = load i32, ptr %i, align 4
  store i32 %157, ptr %left, align 4
  %158 = load i32, ptr %i, align 4
  %inc50 = add nsw i32 %158, 1
  store i32 %inc50, ptr %i, align 4
  br label %if.end53

if.else51:                                        ; preds = %for.body42
  %159 = load i32, ptr %j, align 4
  store i32 %159, ptr %left, align 4
  %160 = load i32, ptr %j, align 4
  %inc52 = add nsw i32 %160, 1
  store i32 %inc52, ptr %j, align 4
  br label %if.end53

if.end53:                                         ; preds = %if.else51, %if.then49
  %161 = load ptr, ptr %tree.addr, align 8
  %162 = load i32, ptr %i, align 4
  %idxprom54 = sext i32 %162 to i64
  %arrayidx55 = getelementptr inbounds %struct.HuffmanTree, ptr %161, i64 %idxprom54
  %total_count_56 = getelementptr inbounds %struct.HuffmanTree, ptr %arrayidx55, i32 0, i32 0
  %163 = load i32, ptr %total_count_56, align 4
  %164 = load ptr, ptr %tree.addr, align 8
  %165 = load i32, ptr %j, align 4
  %idxprom57 = sext i32 %165 to i64
  %arrayidx58 = getelementptr inbounds %struct.HuffmanTree, ptr %164, i64 %idxprom57
  %total_count_59 = getelementptr inbounds %struct.HuffmanTree, ptr %arrayidx58, i32 0, i32 0
  %166 = load i32, ptr %total_count_59, align 4
  %cmp60 = icmp ule i32 %163, %166
  br i1 %cmp60, label %if.then62, label %if.else64

if.then62:                                        ; preds = %if.end53
  %167 = load i32, ptr %i, align 4
  store i32 %167, ptr %right, align 4
  %168 = load i32, ptr %i, align 4
  %inc63 = add nsw i32 %168, 1
  store i32 %inc63, ptr %i, align 4
  br label %if.end66

if.else64:                                        ; preds = %if.end53
  %169 = load i32, ptr %j, align 4
  store i32 %169, ptr %right, align 4
  %170 = load i32, ptr %j, align 4
  %inc65 = add nsw i32 %170, 1
  store i32 %inc65, ptr %j, align 4
  br label %if.end66

if.end66:                                         ; preds = %if.else64, %if.then62
  %171 = load ptr, ptr %tree.addr, align 8
  %172 = load i32, ptr %left, align 4
  %idxprom67 = sext i32 %172 to i64
  %arrayidx68 = getelementptr inbounds %struct.HuffmanTree, ptr %171, i64 %idxprom67
  %total_count_69 = getelementptr inbounds %struct.HuffmanTree, ptr %arrayidx68, i32 0, i32 0
  %173 = load i32, ptr %total_count_69, align 4
  %174 = load ptr, ptr %tree.addr, align 8
  %175 = load i32, ptr %right, align 4
  %idxprom70 = sext i32 %175 to i64
  %arrayidx71 = getelementptr inbounds %struct.HuffmanTree, ptr %174, i64 %idxprom70
  %total_count_72 = getelementptr inbounds %struct.HuffmanTree, ptr %arrayidx71, i32 0, i32 0
  %176 = load i32, ptr %total_count_72, align 4
  %add73 = add i32 %173, %176
  %177 = load ptr, ptr %node, align 8
  %arrayidx74 = getelementptr inbounds %struct.HuffmanTree, ptr %177, i64 -1
  %total_count_75 = getelementptr inbounds %struct.HuffmanTree, ptr %arrayidx74, i32 0, i32 0
  store i32 %add73, ptr %total_count_75, align 4
  %178 = load i32, ptr %left, align 4
  %conv76 = trunc i32 %178 to i16
  %179 = load ptr, ptr %node, align 8
  %arrayidx77 = getelementptr inbounds %struct.HuffmanTree, ptr %179, i64 -1
  %index_left_ = getelementptr inbounds %struct.HuffmanTree, ptr %arrayidx77, i32 0, i32 1
  store i16 %conv76, ptr %index_left_, align 4
  %180 = load i32, ptr %right, align 4
  %conv78 = trunc i32 %180 to i16
  %181 = load ptr, ptr %node, align 8
  %arrayidx79 = getelementptr inbounds %struct.HuffmanTree, ptr %181, i64 -1
  %index_right_or_value_ = getelementptr inbounds %struct.HuffmanTree, ptr %arrayidx79, i32 0, i32 2
  store i16 %conv78, ptr %index_right_or_value_, align 2
  %182 = load ptr, ptr %node, align 8
  %incdec.ptr80 = getelementptr inbounds %struct.HuffmanTree, ptr %182, i32 1
  store ptr %incdec.ptr80, ptr %node, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %182, ptr align 4 %sentinel, i64 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end66
  %183 = load i32, ptr %k, align 4
  %dec81 = add nsw i32 %183, -1
  store i32 %dec81, ptr %k, align 4
  br label %for.cond39, !llvm.loop !59

for.end82:                                        ; preds = %for.cond39
  %184 = load i32, ptr %n, align 4
  %mul83 = mul nsw i32 2, %184
  %sub84 = sub nsw i32 %mul83, 1
  %185 = load ptr, ptr %tree.addr, align 8
  %186 = load ptr, ptr %depth.addr, align 8
  %call = call i32 @BrotliSetDepth(i32 noundef %sub84, ptr noundef %185, ptr noundef %186, i32 noundef 14)
  %tobool85 = icmp ne i32 %call, 0
  br i1 %tobool85, label %if.then86, label %if.end87

if.then86:                                        ; preds = %for.end82
  br label %for.end90

if.end87:                                         ; preds = %for.end82
  br label %for.inc88

for.inc88:                                        ; preds = %if.end87
  %187 = load i32, ptr %count_limit, align 4
  %mul89 = mul i32 %187, 2
  store i32 %mul89, ptr %count_limit, align 4
  br label %for.cond

for.end90:                                        ; preds = %if.then86
  %188 = load ptr, ptr %depth.addr, align 8
  %189 = load i64, ptr %length, align 8
  %190 = load ptr, ptr %bits.addr, align 8
  call void @BrotliConvertBitDepthsToSymbols(ptr noundef %188, i64 noundef %189, ptr noundef %190)
  %191 = load i64, ptr %count, align 8
  %cmp91 = icmp ule i64 %191, 4
  br i1 %cmp91, label %if.then93, label %if.else151

if.then93:                                        ; preds = %for.end90
  %192 = load ptr, ptr %storage_ix.addr, align 8
  %193 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !60)
  call void @llvm.experimental.noalias.scope.decl(metadata !63)
  store i64 2, ptr %n_bits.addr.i401, align 8, !noalias !65
  store i64 1, ptr %bits.addr.i402, align 8, !noalias !65
  store ptr %192, ptr %pos.addr.i403, align 8, !noalias !65
  store ptr %193, ptr %array.addr.i404, align 8, !noalias !65
  %194 = load ptr, ptr %array.addr.i404, align 8, !noalias !65
  %195 = load ptr, ptr %pos.addr.i403, align 8, !noalias !65
  %196 = load i64, ptr %195, align 8
  %shr.i407 = lshr i64 %196, 3
  %arrayidx.i408 = getelementptr inbounds i8, ptr %194, i64 %shr.i407
  store ptr %arrayidx.i408, ptr %p.i405, align 8, !noalias !65
  %197 = load ptr, ptr %p.i405, align 8, !noalias !65
  %198 = load i8, ptr %197, align 1
  %conv.i409 = zext i8 %198 to i64
  store i64 %conv.i409, ptr %v.i406, align 8, !noalias !65
  %199 = load i64, ptr %bits.addr.i402, align 8, !noalias !65
  %200 = load ptr, ptr %pos.addr.i403, align 8, !noalias !65
  %201 = load i64, ptr %200, align 8
  %and.i410 = and i64 %201, 7
  %shl.i411 = shl i64 %199, %and.i410
  %202 = load i64, ptr %v.i406, align 8, !noalias !65
  %or.i412 = or i64 %202, %shl.i411
  store i64 %or.i412, ptr %v.i406, align 8, !noalias !65
  %203 = load ptr, ptr %p.i405, align 8, !noalias !65
  %204 = load i64, ptr %v.i406, align 8, !noalias !65
  store ptr %203, ptr %p.addr.i457, align 8
  store i64 %204, ptr %v.addr.i458, align 8
  %205 = load ptr, ptr %p.addr.i457, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %205, ptr align 8 %v.addr.i458, i64 8, i1 false)
  %206 = load i64, ptr %n_bits.addr.i401, align 8, !noalias !65
  %207 = load ptr, ptr %pos.addr.i403, align 8, !noalias !65
  %208 = load i64, ptr %207, align 8
  %add.i413 = add i64 %208, %206
  store i64 %add.i413, ptr %207, align 8
  %209 = load i64, ptr %count, align 8
  %sub95 = sub i64 %209, 1
  %210 = load ptr, ptr %storage_ix.addr, align 8
  %211 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !66)
  call void @llvm.experimental.noalias.scope.decl(metadata !69)
  store i64 2, ptr %n_bits.addr.i388, align 8, !noalias !71
  store i64 %sub95, ptr %bits.addr.i389, align 8, !noalias !71
  store ptr %210, ptr %pos.addr.i390, align 8, !noalias !71
  store ptr %211, ptr %array.addr.i391, align 8, !noalias !71
  %212 = load ptr, ptr %array.addr.i391, align 8, !noalias !71
  %213 = load ptr, ptr %pos.addr.i390, align 8, !noalias !71
  %214 = load i64, ptr %213, align 8
  %shr.i394 = lshr i64 %214, 3
  %arrayidx.i395 = getelementptr inbounds i8, ptr %212, i64 %shr.i394
  store ptr %arrayidx.i395, ptr %p.i392, align 8, !noalias !71
  %215 = load ptr, ptr %p.i392, align 8, !noalias !71
  %216 = load i8, ptr %215, align 1
  %conv.i396 = zext i8 %216 to i64
  store i64 %conv.i396, ptr %v.i393, align 8, !noalias !71
  %217 = load i64, ptr %bits.addr.i389, align 8, !noalias !71
  %218 = load ptr, ptr %pos.addr.i390, align 8, !noalias !71
  %219 = load i64, ptr %218, align 8
  %and.i397 = and i64 %219, 7
  %shl.i398 = shl i64 %217, %and.i397
  %220 = load i64, ptr %v.i393, align 8, !noalias !71
  %or.i399 = or i64 %220, %shl.i398
  store i64 %or.i399, ptr %v.i393, align 8, !noalias !71
  %221 = load ptr, ptr %p.i392, align 8, !noalias !71
  %222 = load i64, ptr %v.i393, align 8, !noalias !71
  store ptr %221, ptr %p.addr.i459, align 8
  store i64 %222, ptr %v.addr.i460, align 8
  %223 = load ptr, ptr %p.addr.i459, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %223, ptr align 8 %v.addr.i460, i64 8, i1 false)
  %224 = load i64, ptr %n_bits.addr.i388, align 8, !noalias !71
  %225 = load ptr, ptr %pos.addr.i390, align 8, !noalias !71
  %226 = load i64, ptr %225, align 8
  %add.i400 = add i64 %226, %224
  store i64 %add.i400, ptr %225, align 8
  store i64 0, ptr %i94, align 8
  br label %for.cond96

for.cond96:                                       ; preds = %for.inc123, %if.then93
  %227 = load i64, ptr %i94, align 8
  %228 = load i64, ptr %count, align 8
  %cmp97 = icmp ult i64 %227, %228
  br i1 %cmp97, label %for.body99, label %for.end125

for.body99:                                       ; preds = %for.cond96
  %229 = load i64, ptr %i94, align 8
  %add101 = add i64 %229, 1
  store i64 %add101, ptr %j100, align 8
  br label %for.cond102

for.cond102:                                      ; preds = %for.inc120, %for.body99
  %230 = load i64, ptr %j100, align 8
  %231 = load i64, ptr %count, align 8
  %cmp103 = icmp ult i64 %230, %231
  br i1 %cmp103, label %for.body105, label %for.end122

for.body105:                                      ; preds = %for.cond102
  %232 = load ptr, ptr %depth.addr, align 8
  %233 = load i64, ptr %j100, align 8
  %arrayidx106 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 %233
  %234 = load i64, ptr %arrayidx106, align 8
  %arrayidx107 = getelementptr inbounds i8, ptr %232, i64 %234
  %235 = load i8, ptr %arrayidx107, align 1
  %conv108 = zext i8 %235 to i32
  %236 = load ptr, ptr %depth.addr, align 8
  %237 = load i64, ptr %i94, align 8
  %arrayidx109 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 %237
  %238 = load i64, ptr %arrayidx109, align 8
  %arrayidx110 = getelementptr inbounds i8, ptr %236, i64 %238
  %239 = load i8, ptr %arrayidx110, align 1
  %conv111 = zext i8 %239 to i32
  %cmp112 = icmp slt i32 %conv108, %conv111
  br i1 %cmp112, label %if.then114, label %if.end119

if.then114:                                       ; preds = %for.body105
  %240 = load i64, ptr %j100, align 8
  %arrayidx115 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 %240
  %241 = load i64, ptr %arrayidx115, align 8
  store i64 %241, ptr %__brotli_swap_tmp, align 8
  %242 = load i64, ptr %i94, align 8
  %arrayidx116 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 %242
  %243 = load i64, ptr %arrayidx116, align 8
  %244 = load i64, ptr %j100, align 8
  %arrayidx117 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 %244
  store i64 %243, ptr %arrayidx117, align 8
  %245 = load i64, ptr %__brotli_swap_tmp, align 8
  %246 = load i64, ptr %i94, align 8
  %arrayidx118 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 %246
  store i64 %245, ptr %arrayidx118, align 8
  br label %if.end119

if.end119:                                        ; preds = %if.then114, %for.body105
  br label %for.inc120

for.inc120:                                       ; preds = %if.end119
  %247 = load i64, ptr %j100, align 8
  %inc121 = add i64 %247, 1
  store i64 %inc121, ptr %j100, align 8
  br label %for.cond102, !llvm.loop !72

for.end122:                                       ; preds = %for.cond102
  br label %for.inc123

for.inc123:                                       ; preds = %for.end122
  %248 = load i64, ptr %i94, align 8
  %inc124 = add i64 %248, 1
  store i64 %inc124, ptr %i94, align 8
  br label %for.cond96, !llvm.loop !73

for.end125:                                       ; preds = %for.cond96
  %249 = load i64, ptr %count, align 8
  %cmp126 = icmp eq i64 %249, 2
  br i1 %cmp126, label %if.then128, label %if.else131

if.then128:                                       ; preds = %for.end125
  %250 = load i64, ptr %max_bits.addr, align 8
  %arrayidx129 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 0
  %251 = load i64, ptr %arrayidx129, align 16
  %252 = load ptr, ptr %storage_ix.addr, align 8
  %253 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !74)
  call void @llvm.experimental.noalias.scope.decl(metadata !77)
  store i64 %250, ptr %n_bits.addr.i375, align 8, !noalias !79
  store i64 %251, ptr %bits.addr.i376, align 8, !noalias !79
  store ptr %252, ptr %pos.addr.i377, align 8, !noalias !79
  store ptr %253, ptr %array.addr.i378, align 8, !noalias !79
  %254 = load ptr, ptr %array.addr.i378, align 8, !noalias !79
  %255 = load ptr, ptr %pos.addr.i377, align 8, !noalias !79
  %256 = load i64, ptr %255, align 8
  %shr.i381 = lshr i64 %256, 3
  %arrayidx.i382 = getelementptr inbounds i8, ptr %254, i64 %shr.i381
  store ptr %arrayidx.i382, ptr %p.i379, align 8, !noalias !79
  %257 = load ptr, ptr %p.i379, align 8, !noalias !79
  %258 = load i8, ptr %257, align 1
  %conv.i383 = zext i8 %258 to i64
  store i64 %conv.i383, ptr %v.i380, align 8, !noalias !79
  %259 = load i64, ptr %bits.addr.i376, align 8, !noalias !79
  %260 = load ptr, ptr %pos.addr.i377, align 8, !noalias !79
  %261 = load i64, ptr %260, align 8
  %and.i384 = and i64 %261, 7
  %shl.i385 = shl i64 %259, %and.i384
  %262 = load i64, ptr %v.i380, align 8, !noalias !79
  %or.i386 = or i64 %262, %shl.i385
  store i64 %or.i386, ptr %v.i380, align 8, !noalias !79
  %263 = load ptr, ptr %p.i379, align 8, !noalias !79
  %264 = load i64, ptr %v.i380, align 8, !noalias !79
  store ptr %263, ptr %p.addr.i461, align 8
  store i64 %264, ptr %v.addr.i462, align 8
  %265 = load ptr, ptr %p.addr.i461, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %265, ptr align 8 %v.addr.i462, i64 8, i1 false)
  %266 = load i64, ptr %n_bits.addr.i375, align 8, !noalias !79
  %267 = load ptr, ptr %pos.addr.i377, align 8, !noalias !79
  %268 = load i64, ptr %267, align 8
  %add.i387 = add i64 %268, %266
  store i64 %add.i387, ptr %267, align 8
  %269 = load i64, ptr %max_bits.addr, align 8
  %arrayidx130 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 1
  %270 = load i64, ptr %arrayidx130, align 8
  %271 = load ptr, ptr %storage_ix.addr, align 8
  %272 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !80)
  call void @llvm.experimental.noalias.scope.decl(metadata !83)
  store i64 %269, ptr %n_bits.addr.i362, align 8, !noalias !85
  store i64 %270, ptr %bits.addr.i363, align 8, !noalias !85
  store ptr %271, ptr %pos.addr.i364, align 8, !noalias !85
  store ptr %272, ptr %array.addr.i365, align 8, !noalias !85
  %273 = load ptr, ptr %array.addr.i365, align 8, !noalias !85
  %274 = load ptr, ptr %pos.addr.i364, align 8, !noalias !85
  %275 = load i64, ptr %274, align 8
  %shr.i368 = lshr i64 %275, 3
  %arrayidx.i369 = getelementptr inbounds i8, ptr %273, i64 %shr.i368
  store ptr %arrayidx.i369, ptr %p.i366, align 8, !noalias !85
  %276 = load ptr, ptr %p.i366, align 8, !noalias !85
  %277 = load i8, ptr %276, align 1
  %conv.i370 = zext i8 %277 to i64
  store i64 %conv.i370, ptr %v.i367, align 8, !noalias !85
  %278 = load i64, ptr %bits.addr.i363, align 8, !noalias !85
  %279 = load ptr, ptr %pos.addr.i364, align 8, !noalias !85
  %280 = load i64, ptr %279, align 8
  %and.i371 = and i64 %280, 7
  %shl.i372 = shl i64 %278, %and.i371
  %281 = load i64, ptr %v.i367, align 8, !noalias !85
  %or.i373 = or i64 %281, %shl.i372
  store i64 %or.i373, ptr %v.i367, align 8, !noalias !85
  %282 = load ptr, ptr %p.i366, align 8, !noalias !85
  %283 = load i64, ptr %v.i367, align 8, !noalias !85
  store ptr %282, ptr %p.addr.i463, align 8
  store i64 %283, ptr %v.addr.i464, align 8
  %284 = load ptr, ptr %p.addr.i463, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %284, ptr align 8 %v.addr.i464, i64 8, i1 false)
  %285 = load i64, ptr %n_bits.addr.i362, align 8, !noalias !85
  %286 = load ptr, ptr %pos.addr.i364, align 8, !noalias !85
  %287 = load i64, ptr %286, align 8
  %add.i374 = add i64 %287, %285
  store i64 %add.i374, ptr %286, align 8
  br label %if.end150

if.else131:                                       ; preds = %for.end125
  %288 = load i64, ptr %count, align 8
  %cmp132 = icmp eq i64 %288, 3
  br i1 %cmp132, label %if.then134, label %if.else138

if.then134:                                       ; preds = %if.else131
  %289 = load i64, ptr %max_bits.addr, align 8
  %arrayidx135 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 0
  %290 = load i64, ptr %arrayidx135, align 16
  %291 = load ptr, ptr %storage_ix.addr, align 8
  %292 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !86)
  call void @llvm.experimental.noalias.scope.decl(metadata !89)
  store i64 %289, ptr %n_bits.addr.i349, align 8, !noalias !91
  store i64 %290, ptr %bits.addr.i350, align 8, !noalias !91
  store ptr %291, ptr %pos.addr.i351, align 8, !noalias !91
  store ptr %292, ptr %array.addr.i352, align 8, !noalias !91
  %293 = load ptr, ptr %array.addr.i352, align 8, !noalias !91
  %294 = load ptr, ptr %pos.addr.i351, align 8, !noalias !91
  %295 = load i64, ptr %294, align 8
  %shr.i355 = lshr i64 %295, 3
  %arrayidx.i356 = getelementptr inbounds i8, ptr %293, i64 %shr.i355
  store ptr %arrayidx.i356, ptr %p.i353, align 8, !noalias !91
  %296 = load ptr, ptr %p.i353, align 8, !noalias !91
  %297 = load i8, ptr %296, align 1
  %conv.i357 = zext i8 %297 to i64
  store i64 %conv.i357, ptr %v.i354, align 8, !noalias !91
  %298 = load i64, ptr %bits.addr.i350, align 8, !noalias !91
  %299 = load ptr, ptr %pos.addr.i351, align 8, !noalias !91
  %300 = load i64, ptr %299, align 8
  %and.i358 = and i64 %300, 7
  %shl.i359 = shl i64 %298, %and.i358
  %301 = load i64, ptr %v.i354, align 8, !noalias !91
  %or.i360 = or i64 %301, %shl.i359
  store i64 %or.i360, ptr %v.i354, align 8, !noalias !91
  %302 = load ptr, ptr %p.i353, align 8, !noalias !91
  %303 = load i64, ptr %v.i354, align 8, !noalias !91
  store ptr %302, ptr %p.addr.i465, align 8
  store i64 %303, ptr %v.addr.i466, align 8
  %304 = load ptr, ptr %p.addr.i465, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %304, ptr align 8 %v.addr.i466, i64 8, i1 false)
  %305 = load i64, ptr %n_bits.addr.i349, align 8, !noalias !91
  %306 = load ptr, ptr %pos.addr.i351, align 8, !noalias !91
  %307 = load i64, ptr %306, align 8
  %add.i361 = add i64 %307, %305
  store i64 %add.i361, ptr %306, align 8
  %308 = load i64, ptr %max_bits.addr, align 8
  %arrayidx136 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 1
  %309 = load i64, ptr %arrayidx136, align 8
  %310 = load ptr, ptr %storage_ix.addr, align 8
  %311 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !92)
  call void @llvm.experimental.noalias.scope.decl(metadata !95)
  store i64 %308, ptr %n_bits.addr.i336, align 8, !noalias !97
  store i64 %309, ptr %bits.addr.i337, align 8, !noalias !97
  store ptr %310, ptr %pos.addr.i338, align 8, !noalias !97
  store ptr %311, ptr %array.addr.i339, align 8, !noalias !97
  %312 = load ptr, ptr %array.addr.i339, align 8, !noalias !97
  %313 = load ptr, ptr %pos.addr.i338, align 8, !noalias !97
  %314 = load i64, ptr %313, align 8
  %shr.i342 = lshr i64 %314, 3
  %arrayidx.i343 = getelementptr inbounds i8, ptr %312, i64 %shr.i342
  store ptr %arrayidx.i343, ptr %p.i340, align 8, !noalias !97
  %315 = load ptr, ptr %p.i340, align 8, !noalias !97
  %316 = load i8, ptr %315, align 1
  %conv.i344 = zext i8 %316 to i64
  store i64 %conv.i344, ptr %v.i341, align 8, !noalias !97
  %317 = load i64, ptr %bits.addr.i337, align 8, !noalias !97
  %318 = load ptr, ptr %pos.addr.i338, align 8, !noalias !97
  %319 = load i64, ptr %318, align 8
  %and.i345 = and i64 %319, 7
  %shl.i346 = shl i64 %317, %and.i345
  %320 = load i64, ptr %v.i341, align 8, !noalias !97
  %or.i347 = or i64 %320, %shl.i346
  store i64 %or.i347, ptr %v.i341, align 8, !noalias !97
  %321 = load ptr, ptr %p.i340, align 8, !noalias !97
  %322 = load i64, ptr %v.i341, align 8, !noalias !97
  store ptr %321, ptr %p.addr.i467, align 8
  store i64 %322, ptr %v.addr.i468, align 8
  %323 = load ptr, ptr %p.addr.i467, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %323, ptr align 8 %v.addr.i468, i64 8, i1 false)
  %324 = load i64, ptr %n_bits.addr.i336, align 8, !noalias !97
  %325 = load ptr, ptr %pos.addr.i338, align 8, !noalias !97
  %326 = load i64, ptr %325, align 8
  %add.i348 = add i64 %326, %324
  store i64 %add.i348, ptr %325, align 8
  %327 = load i64, ptr %max_bits.addr, align 8
  %arrayidx137 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 2
  %328 = load i64, ptr %arrayidx137, align 16
  %329 = load ptr, ptr %storage_ix.addr, align 8
  %330 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !98)
  call void @llvm.experimental.noalias.scope.decl(metadata !101)
  store i64 %327, ptr %n_bits.addr.i323, align 8, !noalias !103
  store i64 %328, ptr %bits.addr.i324, align 8, !noalias !103
  store ptr %329, ptr %pos.addr.i325, align 8, !noalias !103
  store ptr %330, ptr %array.addr.i326, align 8, !noalias !103
  %331 = load ptr, ptr %array.addr.i326, align 8, !noalias !103
  %332 = load ptr, ptr %pos.addr.i325, align 8, !noalias !103
  %333 = load i64, ptr %332, align 8
  %shr.i329 = lshr i64 %333, 3
  %arrayidx.i330 = getelementptr inbounds i8, ptr %331, i64 %shr.i329
  store ptr %arrayidx.i330, ptr %p.i327, align 8, !noalias !103
  %334 = load ptr, ptr %p.i327, align 8, !noalias !103
  %335 = load i8, ptr %334, align 1
  %conv.i331 = zext i8 %335 to i64
  store i64 %conv.i331, ptr %v.i328, align 8, !noalias !103
  %336 = load i64, ptr %bits.addr.i324, align 8, !noalias !103
  %337 = load ptr, ptr %pos.addr.i325, align 8, !noalias !103
  %338 = load i64, ptr %337, align 8
  %and.i332 = and i64 %338, 7
  %shl.i333 = shl i64 %336, %and.i332
  %339 = load i64, ptr %v.i328, align 8, !noalias !103
  %or.i334 = or i64 %339, %shl.i333
  store i64 %or.i334, ptr %v.i328, align 8, !noalias !103
  %340 = load ptr, ptr %p.i327, align 8, !noalias !103
  %341 = load i64, ptr %v.i328, align 8, !noalias !103
  store ptr %340, ptr %p.addr.i469, align 8
  store i64 %341, ptr %v.addr.i470, align 8
  %342 = load ptr, ptr %p.addr.i469, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %342, ptr align 8 %v.addr.i470, i64 8, i1 false)
  %343 = load i64, ptr %n_bits.addr.i323, align 8, !noalias !103
  %344 = load ptr, ptr %pos.addr.i325, align 8, !noalias !103
  %345 = load i64, ptr %344, align 8
  %add.i335 = add i64 %345, %343
  store i64 %add.i335, ptr %344, align 8
  br label %if.end149

if.else138:                                       ; preds = %if.else131
  %346 = load i64, ptr %max_bits.addr, align 8
  %arrayidx139 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 0
  %347 = load i64, ptr %arrayidx139, align 16
  %348 = load ptr, ptr %storage_ix.addr, align 8
  %349 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !104)
  call void @llvm.experimental.noalias.scope.decl(metadata !107)
  store i64 %346, ptr %n_bits.addr.i310, align 8, !noalias !109
  store i64 %347, ptr %bits.addr.i311, align 8, !noalias !109
  store ptr %348, ptr %pos.addr.i312, align 8, !noalias !109
  store ptr %349, ptr %array.addr.i313, align 8, !noalias !109
  %350 = load ptr, ptr %array.addr.i313, align 8, !noalias !109
  %351 = load ptr, ptr %pos.addr.i312, align 8, !noalias !109
  %352 = load i64, ptr %351, align 8
  %shr.i316 = lshr i64 %352, 3
  %arrayidx.i317 = getelementptr inbounds i8, ptr %350, i64 %shr.i316
  store ptr %arrayidx.i317, ptr %p.i314, align 8, !noalias !109
  %353 = load ptr, ptr %p.i314, align 8, !noalias !109
  %354 = load i8, ptr %353, align 1
  %conv.i318 = zext i8 %354 to i64
  store i64 %conv.i318, ptr %v.i315, align 8, !noalias !109
  %355 = load i64, ptr %bits.addr.i311, align 8, !noalias !109
  %356 = load ptr, ptr %pos.addr.i312, align 8, !noalias !109
  %357 = load i64, ptr %356, align 8
  %and.i319 = and i64 %357, 7
  %shl.i320 = shl i64 %355, %and.i319
  %358 = load i64, ptr %v.i315, align 8, !noalias !109
  %or.i321 = or i64 %358, %shl.i320
  store i64 %or.i321, ptr %v.i315, align 8, !noalias !109
  %359 = load ptr, ptr %p.i314, align 8, !noalias !109
  %360 = load i64, ptr %v.i315, align 8, !noalias !109
  store ptr %359, ptr %p.addr.i471, align 8
  store i64 %360, ptr %v.addr.i472, align 8
  %361 = load ptr, ptr %p.addr.i471, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %361, ptr align 8 %v.addr.i472, i64 8, i1 false)
  %362 = load i64, ptr %n_bits.addr.i310, align 8, !noalias !109
  %363 = load ptr, ptr %pos.addr.i312, align 8, !noalias !109
  %364 = load i64, ptr %363, align 8
  %add.i322 = add i64 %364, %362
  store i64 %add.i322, ptr %363, align 8
  %365 = load i64, ptr %max_bits.addr, align 8
  %arrayidx140 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 1
  %366 = load i64, ptr %arrayidx140, align 8
  %367 = load ptr, ptr %storage_ix.addr, align 8
  %368 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !110)
  call void @llvm.experimental.noalias.scope.decl(metadata !113)
  store i64 %365, ptr %n_bits.addr.i297, align 8, !noalias !115
  store i64 %366, ptr %bits.addr.i298, align 8, !noalias !115
  store ptr %367, ptr %pos.addr.i299, align 8, !noalias !115
  store ptr %368, ptr %array.addr.i300, align 8, !noalias !115
  %369 = load ptr, ptr %array.addr.i300, align 8, !noalias !115
  %370 = load ptr, ptr %pos.addr.i299, align 8, !noalias !115
  %371 = load i64, ptr %370, align 8
  %shr.i303 = lshr i64 %371, 3
  %arrayidx.i304 = getelementptr inbounds i8, ptr %369, i64 %shr.i303
  store ptr %arrayidx.i304, ptr %p.i301, align 8, !noalias !115
  %372 = load ptr, ptr %p.i301, align 8, !noalias !115
  %373 = load i8, ptr %372, align 1
  %conv.i305 = zext i8 %373 to i64
  store i64 %conv.i305, ptr %v.i302, align 8, !noalias !115
  %374 = load i64, ptr %bits.addr.i298, align 8, !noalias !115
  %375 = load ptr, ptr %pos.addr.i299, align 8, !noalias !115
  %376 = load i64, ptr %375, align 8
  %and.i306 = and i64 %376, 7
  %shl.i307 = shl i64 %374, %and.i306
  %377 = load i64, ptr %v.i302, align 8, !noalias !115
  %or.i308 = or i64 %377, %shl.i307
  store i64 %or.i308, ptr %v.i302, align 8, !noalias !115
  %378 = load ptr, ptr %p.i301, align 8, !noalias !115
  %379 = load i64, ptr %v.i302, align 8, !noalias !115
  store ptr %378, ptr %p.addr.i473, align 8
  store i64 %379, ptr %v.addr.i474, align 8
  %380 = load ptr, ptr %p.addr.i473, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %380, ptr align 8 %v.addr.i474, i64 8, i1 false)
  %381 = load i64, ptr %n_bits.addr.i297, align 8, !noalias !115
  %382 = load ptr, ptr %pos.addr.i299, align 8, !noalias !115
  %383 = load i64, ptr %382, align 8
  %add.i309 = add i64 %383, %381
  store i64 %add.i309, ptr %382, align 8
  %384 = load i64, ptr %max_bits.addr, align 8
  %arrayidx141 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 2
  %385 = load i64, ptr %arrayidx141, align 16
  %386 = load ptr, ptr %storage_ix.addr, align 8
  %387 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !116)
  call void @llvm.experimental.noalias.scope.decl(metadata !119)
  store i64 %384, ptr %n_bits.addr.i284, align 8, !noalias !121
  store i64 %385, ptr %bits.addr.i285, align 8, !noalias !121
  store ptr %386, ptr %pos.addr.i286, align 8, !noalias !121
  store ptr %387, ptr %array.addr.i287, align 8, !noalias !121
  %388 = load ptr, ptr %array.addr.i287, align 8, !noalias !121
  %389 = load ptr, ptr %pos.addr.i286, align 8, !noalias !121
  %390 = load i64, ptr %389, align 8
  %shr.i290 = lshr i64 %390, 3
  %arrayidx.i291 = getelementptr inbounds i8, ptr %388, i64 %shr.i290
  store ptr %arrayidx.i291, ptr %p.i288, align 8, !noalias !121
  %391 = load ptr, ptr %p.i288, align 8, !noalias !121
  %392 = load i8, ptr %391, align 1
  %conv.i292 = zext i8 %392 to i64
  store i64 %conv.i292, ptr %v.i289, align 8, !noalias !121
  %393 = load i64, ptr %bits.addr.i285, align 8, !noalias !121
  %394 = load ptr, ptr %pos.addr.i286, align 8, !noalias !121
  %395 = load i64, ptr %394, align 8
  %and.i293 = and i64 %395, 7
  %shl.i294 = shl i64 %393, %and.i293
  %396 = load i64, ptr %v.i289, align 8, !noalias !121
  %or.i295 = or i64 %396, %shl.i294
  store i64 %or.i295, ptr %v.i289, align 8, !noalias !121
  %397 = load ptr, ptr %p.i288, align 8, !noalias !121
  %398 = load i64, ptr %v.i289, align 8, !noalias !121
  store ptr %397, ptr %p.addr.i475, align 8
  store i64 %398, ptr %v.addr.i476, align 8
  %399 = load ptr, ptr %p.addr.i475, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %399, ptr align 8 %v.addr.i476, i64 8, i1 false)
  %400 = load i64, ptr %n_bits.addr.i284, align 8, !noalias !121
  %401 = load ptr, ptr %pos.addr.i286, align 8, !noalias !121
  %402 = load i64, ptr %401, align 8
  %add.i296 = add i64 %402, %400
  store i64 %add.i296, ptr %401, align 8
  %403 = load i64, ptr %max_bits.addr, align 8
  %arrayidx142 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 3
  %404 = load i64, ptr %arrayidx142, align 8
  %405 = load ptr, ptr %storage_ix.addr, align 8
  %406 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !122)
  call void @llvm.experimental.noalias.scope.decl(metadata !125)
  store i64 %403, ptr %n_bits.addr.i271, align 8, !noalias !127
  store i64 %404, ptr %bits.addr.i272, align 8, !noalias !127
  store ptr %405, ptr %pos.addr.i273, align 8, !noalias !127
  store ptr %406, ptr %array.addr.i274, align 8, !noalias !127
  %407 = load ptr, ptr %array.addr.i274, align 8, !noalias !127
  %408 = load ptr, ptr %pos.addr.i273, align 8, !noalias !127
  %409 = load i64, ptr %408, align 8
  %shr.i277 = lshr i64 %409, 3
  %arrayidx.i278 = getelementptr inbounds i8, ptr %407, i64 %shr.i277
  store ptr %arrayidx.i278, ptr %p.i275, align 8, !noalias !127
  %410 = load ptr, ptr %p.i275, align 8, !noalias !127
  %411 = load i8, ptr %410, align 1
  %conv.i279 = zext i8 %411 to i64
  store i64 %conv.i279, ptr %v.i276, align 8, !noalias !127
  %412 = load i64, ptr %bits.addr.i272, align 8, !noalias !127
  %413 = load ptr, ptr %pos.addr.i273, align 8, !noalias !127
  %414 = load i64, ptr %413, align 8
  %and.i280 = and i64 %414, 7
  %shl.i281 = shl i64 %412, %and.i280
  %415 = load i64, ptr %v.i276, align 8, !noalias !127
  %or.i282 = or i64 %415, %shl.i281
  store i64 %or.i282, ptr %v.i276, align 8, !noalias !127
  %416 = load ptr, ptr %p.i275, align 8, !noalias !127
  %417 = load i64, ptr %v.i276, align 8, !noalias !127
  store ptr %416, ptr %p.addr.i477, align 8
  store i64 %417, ptr %v.addr.i478, align 8
  %418 = load ptr, ptr %p.addr.i477, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %418, ptr align 8 %v.addr.i478, i64 8, i1 false)
  %419 = load i64, ptr %n_bits.addr.i271, align 8, !noalias !127
  %420 = load ptr, ptr %pos.addr.i273, align 8, !noalias !127
  %421 = load i64, ptr %420, align 8
  %add.i283 = add i64 %421, %419
  store i64 %add.i283, ptr %420, align 8
  %422 = load ptr, ptr %depth.addr, align 8
  %arrayidx143 = getelementptr inbounds [4 x i64], ptr %symbols, i64 0, i64 0
  %423 = load i64, ptr %arrayidx143, align 16
  %arrayidx144 = getelementptr inbounds i8, ptr %422, i64 %423
  %424 = load i8, ptr %arrayidx144, align 1
  %conv145 = zext i8 %424 to i32
  %cmp146 = icmp eq i32 %conv145, 1
  %cond = select i1 %cmp146, i32 1, i32 0
  %conv148 = sext i32 %cond to i64
  %425 = load ptr, ptr %storage_ix.addr, align 8
  %426 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !128)
  call void @llvm.experimental.noalias.scope.decl(metadata !131)
  store i64 1, ptr %n_bits.addr.i258, align 8, !noalias !133
  store i64 %conv148, ptr %bits.addr.i259, align 8, !noalias !133
  store ptr %425, ptr %pos.addr.i260, align 8, !noalias !133
  store ptr %426, ptr %array.addr.i261, align 8, !noalias !133
  %427 = load ptr, ptr %array.addr.i261, align 8, !noalias !133
  %428 = load ptr, ptr %pos.addr.i260, align 8, !noalias !133
  %429 = load i64, ptr %428, align 8
  %shr.i264 = lshr i64 %429, 3
  %arrayidx.i265 = getelementptr inbounds i8, ptr %427, i64 %shr.i264
  store ptr %arrayidx.i265, ptr %p.i262, align 8, !noalias !133
  %430 = load ptr, ptr %p.i262, align 8, !noalias !133
  %431 = load i8, ptr %430, align 1
  %conv.i266 = zext i8 %431 to i64
  store i64 %conv.i266, ptr %v.i263, align 8, !noalias !133
  %432 = load i64, ptr %bits.addr.i259, align 8, !noalias !133
  %433 = load ptr, ptr %pos.addr.i260, align 8, !noalias !133
  %434 = load i64, ptr %433, align 8
  %and.i267 = and i64 %434, 7
  %shl.i268 = shl i64 %432, %and.i267
  %435 = load i64, ptr %v.i263, align 8, !noalias !133
  %or.i269 = or i64 %435, %shl.i268
  store i64 %or.i269, ptr %v.i263, align 8, !noalias !133
  %436 = load ptr, ptr %p.i262, align 8, !noalias !133
  %437 = load i64, ptr %v.i263, align 8, !noalias !133
  store ptr %436, ptr %p.addr.i479, align 8
  store i64 %437, ptr %v.addr.i480, align 8
  %438 = load ptr, ptr %p.addr.i479, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %438, ptr align 8 %v.addr.i480, i64 8, i1 false)
  %439 = load i64, ptr %n_bits.addr.i258, align 8, !noalias !133
  %440 = load ptr, ptr %pos.addr.i260, align 8, !noalias !133
  %441 = load i64, ptr %440, align 8
  %add.i270 = add i64 %441, %439
  store i64 %add.i270, ptr %440, align 8
  br label %if.end149

if.end149:                                        ; preds = %if.else138, %if.then134
  br label %if.end150

if.end150:                                        ; preds = %if.end149, %if.then128
  br label %if.end218

if.else151:                                       ; preds = %for.end90
  store i8 8, ptr %previous_value, align 1
  %442 = load ptr, ptr %storage_ix.addr, align 8
  %443 = load ptr, ptr %storage.addr, align 8
  store ptr %442, ptr %storage_ix.addr.i, align 8
  store ptr %443, ptr %storage.addr.i, align 8
  %444 = load ptr, ptr %storage_ix.addr.i, align 8
  %445 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !134)
  call void @llvm.experimental.noalias.scope.decl(metadata !137)
  store i64 40, ptr %n_bits.addr.i.i, align 8, !noalias !139
  store i64 1096648316244, ptr %bits.addr.i.i, align 8, !noalias !139
  store ptr %444, ptr %pos.addr.i.i, align 8, !noalias !139
  store ptr %445, ptr %array.addr.i.i, align 8, !noalias !139
  %446 = load ptr, ptr %array.addr.i.i, align 8, !noalias !139
  %447 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !139
  %448 = load i64, ptr %447, align 8
  %shr.i.i = lshr i64 %448, 3
  %arrayidx.i.i = getelementptr inbounds i8, ptr %446, i64 %shr.i.i
  store ptr %arrayidx.i.i, ptr %p.i.i, align 8, !noalias !139
  %449 = load ptr, ptr %p.i.i, align 8, !noalias !139
  %450 = load i8, ptr %449, align 1
  %conv.i.i = zext i8 %450 to i64
  store i64 %conv.i.i, ptr %v.i.i, align 8, !noalias !139
  %451 = load i64, ptr %bits.addr.i.i, align 8, !noalias !139
  %452 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !139
  %453 = load i64, ptr %452, align 8
  %and.i.i = and i64 %453, 7
  %shl.i.i = shl i64 %451, %and.i.i
  %454 = load i64, ptr %v.i.i, align 8, !noalias !139
  %or.i.i = or i64 %454, %shl.i.i
  store i64 %or.i.i, ptr %v.i.i, align 8, !noalias !139
  %455 = load ptr, ptr %p.i.i, align 8, !noalias !139
  %456 = load i64, ptr %v.i.i, align 8, !noalias !139
  store ptr %455, ptr %p.addr.i, align 8
  store i64 %456, ptr %v.addr.i, align 8
  %457 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %457, ptr align 8 %v.addr.i, i64 8, i1 false)
  %458 = load i64, ptr %n_bits.addr.i.i, align 8, !noalias !139
  %459 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !139
  %460 = load i64, ptr %459, align 8
  %add.i.i = add i64 %460, %458
  store i64 %add.i.i, ptr %459, align 8
  store i64 0, ptr %i152, align 8
  br label %for.cond153

for.cond153:                                      ; preds = %if.end216, %if.else151
  %461 = load i64, ptr %i152, align 8
  %462 = load i64, ptr %length, align 8
  %cmp154 = icmp ult i64 %461, %462
  br i1 %cmp154, label %for.body156, label %for.end217

for.body156:                                      ; preds = %for.cond153
  %463 = load ptr, ptr %depth.addr, align 8
  %464 = load i64, ptr %i152, align 8
  %arrayidx157 = getelementptr inbounds i8, ptr %463, i64 %464
  %465 = load i8, ptr %arrayidx157, align 1
  store i8 %465, ptr %value, align 1
  store i64 1, ptr %reps, align 8
  %466 = load i64, ptr %i152, align 8
  %add159 = add i64 %466, 1
  store i64 %add159, ptr %k158, align 8
  br label %for.cond160

for.cond160:                                      ; preds = %for.inc170, %for.body156
  %467 = load i64, ptr %k158, align 8
  %468 = load i64, ptr %length, align 8
  %cmp161 = icmp ult i64 %467, %468
  br i1 %cmp161, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond160
  %469 = load ptr, ptr %depth.addr, align 8
  %470 = load i64, ptr %k158, align 8
  %arrayidx163 = getelementptr inbounds i8, ptr %469, i64 %470
  %471 = load i8, ptr %arrayidx163, align 1
  %conv164 = zext i8 %471 to i32
  %472 = load i8, ptr %value, align 1
  %conv165 = zext i8 %472 to i32
  %cmp166 = icmp eq i32 %conv164, %conv165
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond160
  %473 = phi i1 [ false, %for.cond160 ], [ %cmp166, %land.rhs ]
  br i1 %473, label %for.body168, label %for.end172

for.body168:                                      ; preds = %land.end
  %474 = load i64, ptr %reps, align 8
  %inc169 = add i64 %474, 1
  store i64 %inc169, ptr %reps, align 8
  br label %for.inc170

for.inc170:                                       ; preds = %for.body168
  %475 = load i64, ptr %k158, align 8
  %inc171 = add i64 %475, 1
  store i64 %inc171, ptr %k158, align 8
  br label %for.cond160, !llvm.loop !140

for.end172:                                       ; preds = %land.end
  %476 = load i64, ptr %reps, align 8
  %477 = load i64, ptr %i152, align 8
  %add173 = add i64 %477, %476
  store i64 %add173, ptr %i152, align 8
  %478 = load i8, ptr %value, align 1
  %conv174 = zext i8 %478 to i32
  %cmp175 = icmp eq i32 %conv174, 0
  br i1 %cmp175, label %if.then177, label %if.else181

if.then177:                                       ; preds = %for.end172
  %479 = load i64, ptr %reps, align 8
  %arrayidx178 = getelementptr inbounds [704 x i32], ptr @kZeroRepsDepth, i64 0, i64 %479
  %480 = load i32, ptr %arrayidx178, align 4
  %conv179 = zext i32 %480 to i64
  %481 = load i64, ptr %reps, align 8
  %arrayidx180 = getelementptr inbounds [704 x i64], ptr @kZeroRepsBits, i64 0, i64 %481
  %482 = load i64, ptr %arrayidx180, align 8
  %483 = load ptr, ptr %storage_ix.addr, align 8
  %484 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !141)
  call void @llvm.experimental.noalias.scope.decl(metadata !144)
  store i64 %conv179, ptr %n_bits.addr.i245, align 8, !noalias !146
  store i64 %482, ptr %bits.addr.i246, align 8, !noalias !146
  store ptr %483, ptr %pos.addr.i247, align 8, !noalias !146
  store ptr %484, ptr %array.addr.i248, align 8, !noalias !146
  %485 = load ptr, ptr %array.addr.i248, align 8, !noalias !146
  %486 = load ptr, ptr %pos.addr.i247, align 8, !noalias !146
  %487 = load i64, ptr %486, align 8
  %shr.i251 = lshr i64 %487, 3
  %arrayidx.i252 = getelementptr inbounds i8, ptr %485, i64 %shr.i251
  store ptr %arrayidx.i252, ptr %p.i249, align 8, !noalias !146
  %488 = load ptr, ptr %p.i249, align 8, !noalias !146
  %489 = load i8, ptr %488, align 1
  %conv.i253 = zext i8 %489 to i64
  store i64 %conv.i253, ptr %v.i250, align 8, !noalias !146
  %490 = load i64, ptr %bits.addr.i246, align 8, !noalias !146
  %491 = load ptr, ptr %pos.addr.i247, align 8, !noalias !146
  %492 = load i64, ptr %491, align 8
  %and.i254 = and i64 %492, 7
  %shl.i255 = shl i64 %490, %and.i254
  %493 = load i64, ptr %v.i250, align 8, !noalias !146
  %or.i256 = or i64 %493, %shl.i255
  store i64 %or.i256, ptr %v.i250, align 8, !noalias !146
  %494 = load ptr, ptr %p.i249, align 8, !noalias !146
  %495 = load i64, ptr %v.i250, align 8, !noalias !146
  store ptr %494, ptr %p.addr.i481, align 8
  store i64 %495, ptr %v.addr.i482, align 8
  %496 = load ptr, ptr %p.addr.i481, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %496, ptr align 8 %v.addr.i482, i64 8, i1 false)
  %497 = load i64, ptr %n_bits.addr.i245, align 8, !noalias !146
  %498 = load ptr, ptr %pos.addr.i247, align 8, !noalias !146
  %499 = load i64, ptr %498, align 8
  %add.i257 = add i64 %499, %497
  store i64 %add.i257, ptr %498, align 8
  br label %if.end216

if.else181:                                       ; preds = %for.end172
  %500 = load i8, ptr %previous_value, align 1
  %conv182 = zext i8 %500 to i32
  %501 = load i8, ptr %value, align 1
  %conv183 = zext i8 %501 to i32
  %cmp184 = icmp ne i32 %conv182, %conv183
  br i1 %cmp184, label %if.then186, label %if.end194

if.then186:                                       ; preds = %if.else181
  %502 = load i8, ptr %value, align 1
  %idxprom187 = zext i8 %502 to i64
  %arrayidx188 = getelementptr inbounds [18 x i8], ptr @kCodeLengthDepth, i64 0, i64 %idxprom187
  %503 = load i8, ptr %arrayidx188, align 1
  %conv189 = zext i8 %503 to i64
  %504 = load i8, ptr %value, align 1
  %idxprom190 = zext i8 %504 to i64
  %arrayidx191 = getelementptr inbounds [18 x i32], ptr @kCodeLengthBits, i64 0, i64 %idxprom190
  %505 = load i32, ptr %arrayidx191, align 4
  %conv192 = zext i32 %505 to i64
  %506 = load ptr, ptr %storage_ix.addr, align 8
  %507 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !147)
  call void @llvm.experimental.noalias.scope.decl(metadata !150)
  store i64 %conv189, ptr %n_bits.addr.i232, align 8, !noalias !152
  store i64 %conv192, ptr %bits.addr.i233, align 8, !noalias !152
  store ptr %506, ptr %pos.addr.i234, align 8, !noalias !152
  store ptr %507, ptr %array.addr.i235, align 8, !noalias !152
  %508 = load ptr, ptr %array.addr.i235, align 8, !noalias !152
  %509 = load ptr, ptr %pos.addr.i234, align 8, !noalias !152
  %510 = load i64, ptr %509, align 8
  %shr.i238 = lshr i64 %510, 3
  %arrayidx.i239 = getelementptr inbounds i8, ptr %508, i64 %shr.i238
  store ptr %arrayidx.i239, ptr %p.i236, align 8, !noalias !152
  %511 = load ptr, ptr %p.i236, align 8, !noalias !152
  %512 = load i8, ptr %511, align 1
  %conv.i240 = zext i8 %512 to i64
  store i64 %conv.i240, ptr %v.i237, align 8, !noalias !152
  %513 = load i64, ptr %bits.addr.i233, align 8, !noalias !152
  %514 = load ptr, ptr %pos.addr.i234, align 8, !noalias !152
  %515 = load i64, ptr %514, align 8
  %and.i241 = and i64 %515, 7
  %shl.i242 = shl i64 %513, %and.i241
  %516 = load i64, ptr %v.i237, align 8, !noalias !152
  %or.i243 = or i64 %516, %shl.i242
  store i64 %or.i243, ptr %v.i237, align 8, !noalias !152
  %517 = load ptr, ptr %p.i236, align 8, !noalias !152
  %518 = load i64, ptr %v.i237, align 8, !noalias !152
  store ptr %517, ptr %p.addr.i483, align 8
  store i64 %518, ptr %v.addr.i484, align 8
  %519 = load ptr, ptr %p.addr.i483, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %519, ptr align 8 %v.addr.i484, i64 8, i1 false)
  %520 = load i64, ptr %n_bits.addr.i232, align 8, !noalias !152
  %521 = load ptr, ptr %pos.addr.i234, align 8, !noalias !152
  %522 = load i64, ptr %521, align 8
  %add.i244 = add i64 %522, %520
  store i64 %add.i244, ptr %521, align 8
  %523 = load i64, ptr %reps, align 8
  %dec193 = add i64 %523, -1
  store i64 %dec193, ptr %reps, align 8
  br label %if.end194

if.end194:                                        ; preds = %if.then186, %if.else181
  %524 = load i64, ptr %reps, align 8
  %cmp195 = icmp ult i64 %524, 3
  br i1 %cmp195, label %if.then197, label %if.else210

if.then197:                                       ; preds = %if.end194
  br label %while.cond198

while.cond198:                                    ; preds = %while.body201, %if.then197
  %525 = load i64, ptr %reps, align 8
  %cmp199 = icmp ne i64 %525, 0
  br i1 %cmp199, label %while.body201, label %while.end209

while.body201:                                    ; preds = %while.cond198
  %526 = load i64, ptr %reps, align 8
  %dec202 = add i64 %526, -1
  store i64 %dec202, ptr %reps, align 8
  %527 = load i8, ptr %value, align 1
  %idxprom203 = zext i8 %527 to i64
  %arrayidx204 = getelementptr inbounds [18 x i8], ptr @kCodeLengthDepth, i64 0, i64 %idxprom203
  %528 = load i8, ptr %arrayidx204, align 1
  %conv205 = zext i8 %528 to i64
  %529 = load i8, ptr %value, align 1
  %idxprom206 = zext i8 %529 to i64
  %arrayidx207 = getelementptr inbounds [18 x i32], ptr @kCodeLengthBits, i64 0, i64 %idxprom206
  %530 = load i32, ptr %arrayidx207, align 4
  %conv208 = zext i32 %530 to i64
  %531 = load ptr, ptr %storage_ix.addr, align 8
  %532 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !153)
  call void @llvm.experimental.noalias.scope.decl(metadata !156)
  store i64 %conv205, ptr %n_bits.addr.i219, align 8, !noalias !158
  store i64 %conv208, ptr %bits.addr.i220, align 8, !noalias !158
  store ptr %531, ptr %pos.addr.i221, align 8, !noalias !158
  store ptr %532, ptr %array.addr.i222, align 8, !noalias !158
  %533 = load ptr, ptr %array.addr.i222, align 8, !noalias !158
  %534 = load ptr, ptr %pos.addr.i221, align 8, !noalias !158
  %535 = load i64, ptr %534, align 8
  %shr.i225 = lshr i64 %535, 3
  %arrayidx.i226 = getelementptr inbounds i8, ptr %533, i64 %shr.i225
  store ptr %arrayidx.i226, ptr %p.i223, align 8, !noalias !158
  %536 = load ptr, ptr %p.i223, align 8, !noalias !158
  %537 = load i8, ptr %536, align 1
  %conv.i227 = zext i8 %537 to i64
  store i64 %conv.i227, ptr %v.i224, align 8, !noalias !158
  %538 = load i64, ptr %bits.addr.i220, align 8, !noalias !158
  %539 = load ptr, ptr %pos.addr.i221, align 8, !noalias !158
  %540 = load i64, ptr %539, align 8
  %and.i228 = and i64 %540, 7
  %shl.i229 = shl i64 %538, %and.i228
  %541 = load i64, ptr %v.i224, align 8, !noalias !158
  %or.i230 = or i64 %541, %shl.i229
  store i64 %or.i230, ptr %v.i224, align 8, !noalias !158
  %542 = load ptr, ptr %p.i223, align 8, !noalias !158
  %543 = load i64, ptr %v.i224, align 8, !noalias !158
  store ptr %542, ptr %p.addr.i485, align 8
  store i64 %543, ptr %v.addr.i486, align 8
  %544 = load ptr, ptr %p.addr.i485, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %544, ptr align 8 %v.addr.i486, i64 8, i1 false)
  %545 = load i64, ptr %n_bits.addr.i219, align 8, !noalias !158
  %546 = load ptr, ptr %pos.addr.i221, align 8, !noalias !158
  %547 = load i64, ptr %546, align 8
  %add.i231 = add i64 %547, %545
  store i64 %add.i231, ptr %546, align 8
  br label %while.cond198, !llvm.loop !159

while.end209:                                     ; preds = %while.cond198
  br label %if.end215

if.else210:                                       ; preds = %if.end194
  %548 = load i64, ptr %reps, align 8
  %sub211 = sub i64 %548, 3
  store i64 %sub211, ptr %reps, align 8
  %549 = load i64, ptr %reps, align 8
  %arrayidx212 = getelementptr inbounds [704 x i32], ptr @kNonZeroRepsDepth, i64 0, i64 %549
  %550 = load i32, ptr %arrayidx212, align 4
  %conv213 = zext i32 %550 to i64
  %551 = load i64, ptr %reps, align 8
  %arrayidx214 = getelementptr inbounds [704 x i64], ptr @kNonZeroRepsBits, i64 0, i64 %551
  %552 = load i64, ptr %arrayidx214, align 8
  %553 = load ptr, ptr %storage_ix.addr, align 8
  %554 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !160)
  call void @llvm.experimental.noalias.scope.decl(metadata !163)
  store i64 %conv213, ptr %n_bits.addr.i, align 8, !noalias !165
  store i64 %552, ptr %bits.addr.i, align 8, !noalias !165
  store ptr %553, ptr %pos.addr.i, align 8, !noalias !165
  store ptr %554, ptr %array.addr.i, align 8, !noalias !165
  %555 = load ptr, ptr %array.addr.i, align 8, !noalias !165
  %556 = load ptr, ptr %pos.addr.i, align 8, !noalias !165
  %557 = load i64, ptr %556, align 8
  %shr.i = lshr i64 %557, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %555, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !165
  %558 = load ptr, ptr %p.i, align 8, !noalias !165
  %559 = load i8, ptr %558, align 1
  %conv.i = zext i8 %559 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !165
  %560 = load i64, ptr %bits.addr.i, align 8, !noalias !165
  %561 = load ptr, ptr %pos.addr.i, align 8, !noalias !165
  %562 = load i64, ptr %561, align 8
  %and.i = and i64 %562, 7
  %shl.i = shl i64 %560, %and.i
  %563 = load i64, ptr %v.i, align 8, !noalias !165
  %or.i = or i64 %563, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !165
  %564 = load ptr, ptr %p.i, align 8, !noalias !165
  %565 = load i64, ptr %v.i, align 8, !noalias !165
  store ptr %564, ptr %p.addr.i487, align 8
  store i64 %565, ptr %v.addr.i488, align 8
  %566 = load ptr, ptr %p.addr.i487, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %566, ptr align 8 %v.addr.i488, i64 8, i1 false)
  %567 = load i64, ptr %n_bits.addr.i, align 8, !noalias !165
  %568 = load ptr, ptr %pos.addr.i, align 8, !noalias !165
  %569 = load i64, ptr %568, align 8
  %add.i = add i64 %569, %567
  store i64 %add.i, ptr %568, align 8
  br label %if.end215

if.end215:                                        ; preds = %if.else210, %while.end209
  %570 = load i8, ptr %value, align 1
  store i8 %570, ptr %previous_value, align 1
  br label %if.end216

if.end216:                                        ; preds = %if.end215, %if.then177
  br label %for.cond153, !llvm.loop !166

for.end217:                                       ; preds = %for.cond153
  br label %if.end218

if.end218:                                        ; preds = %for.end217, %if.end150, %if.then9
  ret void
}

; Function Attrs: alwaysinline nounwind uwtable
define internal i32 @SortHuffmanTree(ptr noundef %v0, ptr noundef %v1) #3 {
entry:
  %v0.addr = alloca ptr, align 8
  %v1.addr = alloca ptr, align 8
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  %0 = load ptr, ptr %v0.addr, align 8
  %total_count_ = getelementptr inbounds %struct.HuffmanTree, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %total_count_, align 4
  %2 = load ptr, ptr %v1.addr, align 8
  %total_count_1 = getelementptr inbounds %struct.HuffmanTree, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %total_count_1, align 4
  %cmp = icmp ult i32 %1, %3
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %cond = select i1 %lnot2, i32 1, i32 0
  ret i32 %cond
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #4

declare hidden i32 @BrotliSetDepth(i32 noundef, ptr noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind uwtable
define hidden void @BrotliStoreMetaBlock(ptr noundef %m, ptr noundef %input, i64 noundef %start_pos, i64 noundef %length, i64 noundef %mask, i8 noundef zeroext %prev_byte, i8 noundef zeroext %prev_byte2, i32 noundef %is_last, ptr noundef %params, i32 noundef %literal_context_mode, ptr noundef %commands, i64 noundef %n_commands, ptr noundef %mb, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %copycode.addr.i235 = alloca i16, align 2
  %copycode.addr.i = alloca i16, align 2
  %inscode.addr.i230 = alloca i16, align 2
  %inscode.addr.i = alloca i16, align 2
  %n.addr.i19.i = alloca i64, align 8
  %n.addr.i.i212 = alloca i64, align 8
  %retval.i213 = alloca i16, align 2
  %copylen.addr.i = alloca i64, align 8
  %nbits.i214 = alloca i32, align 4
  %n.addr.i26.i = alloca i64, align 8
  %n.addr.i.i = alloca i64, align 8
  %retval.i201 = alloca i16, align 2
  %insertlen.addr.i = alloca i64, align 8
  %nbits.i = alloca i32, align 4
  %self.addr.i193 = alloca ptr, align 8
  %modifier.i = alloca i32, align 4
  %delta.i = alloca i32, align 4
  %p.addr.i191 = alloca ptr, align 8
  %v.addr.i192 = alloca i64, align 8
  %p.addr.i189 = alloca ptr, align 8
  %v.addr.i190 = alloca i64, align 8
  %p.addr.i187 = alloca ptr, align 8
  %v.addr.i188 = alloca i64, align 8
  %p.addr.i185 = alloca ptr, align 8
  %v.addr.i186 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %retval.i = alloca i32, align 4
  %self.addr.i180 = alloca ptr, align 8
  %r.i = alloca i32, align 4
  %c.i = alloca i32, align 4
  %self.addr.i177 = alloca ptr, align 8
  %self.addr.i = alloca ptr, align 8
  %n_bits.addr.i.i = alloca i64, align 8
  %bits.addr.i.i = alloca i64, align 8
  %pos.addr.i.i = alloca ptr, align 8
  %array.addr.i.i = alloca ptr, align 8
  %p.i.i = alloca ptr, align 8
  %v.i.i = alloca i64, align 8
  %cmd.addr.i = alloca ptr, align 8
  %storage_ix.addr.i = alloca ptr, align 8
  %storage.addr.i = alloca ptr, align 8
  %copylen_code.i = alloca i32, align 4
  %inscode.i = alloca i16, align 2
  %copycode.i = alloca i16, align 2
  %insnumextra.i = alloca i32, align 4
  %insextraval.i = alloca i64, align 8
  %copyextraval.i = alloca i64, align 8
  %bits.i = alloca i64, align 8
  %n_bits.addr.i159 = alloca i64, align 8
  %bits.addr.i160 = alloca i64, align 8
  %pos.addr.i161 = alloca ptr, align 8
  %array.addr.i162 = alloca ptr, align 8
  %p.i163 = alloca ptr, align 8
  %v.i164 = alloca i64, align 8
  %n_bits.addr.i146 = alloca i64, align 8
  %bits.addr.i147 = alloca i64, align 8
  %pos.addr.i148 = alloca ptr, align 8
  %array.addr.i149 = alloca ptr, align 8
  %p.i150 = alloca ptr, align 8
  %v.i151 = alloca i64, align 8
  %n_bits.addr.i133 = alloca i64, align 8
  %bits.addr.i134 = alloca i64, align 8
  %pos.addr.i135 = alloca ptr, align 8
  %array.addr.i136 = alloca ptr, align 8
  %p.i137 = alloca ptr, align 8
  %v.i138 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %m.addr = alloca ptr, align 8
  %input.addr = alloca ptr, align 8
  %start_pos.addr = alloca i64, align 8
  %length.addr = alloca i64, align 8
  %mask.addr = alloca i64, align 8
  %prev_byte.addr = alloca i8, align 1
  %prev_byte2.addr = alloca i8, align 1
  %is_last.addr = alloca i32, align 4
  %params.addr = alloca ptr, align 8
  %literal_context_mode.addr = alloca i32, align 4
  %commands.addr = alloca ptr, align 8
  %n_commands.addr = alloca i64, align 8
  %mb.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %pos = alloca i64, align 8
  %i = alloca i64, align 8
  %num_distance_symbols = alloca i32, align 4
  %num_effective_distance_symbols = alloca i32, align 4
  %tree = alloca ptr, align 8
  %literal_context_lut = alloca ptr, align 8
  %arena = alloca ptr, align 8
  %literal_enc = alloca ptr, align 8
  %command_enc = alloca ptr, align 8
  %distance_enc = alloca ptr, align 8
  %dist2 = alloca ptr, align 8
  %cmd = alloca %struct.Command, align 4
  %cmd_code = alloca i64, align 8
  %j = alloca i64, align 8
  %j70 = alloca i64, align 8
  %context = alloca i64, align 8
  %literal = alloca i8, align 1
  %dist_code = alloca i64, align 8
  %distnumextra = alloca i32, align 4
  %distextra = alloca i64, align 8
  %context119 = alloca i64, align 8
  store ptr %m, ptr %m.addr, align 8
  store ptr %input, ptr %input.addr, align 8
  store i64 %start_pos, ptr %start_pos.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store i64 %mask, ptr %mask.addr, align 8
  store i8 %prev_byte, ptr %prev_byte.addr, align 1
  store i8 %prev_byte2, ptr %prev_byte2.addr, align 1
  store i32 %is_last, ptr %is_last.addr, align 4
  store ptr %params, ptr %params.addr, align 8
  store i32 %literal_context_mode, ptr %literal_context_mode.addr, align 4
  store ptr %commands, ptr %commands.addr, align 8
  store i64 %n_commands, ptr %n_commands.addr, align 8
  store ptr %mb, ptr %mb.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load i64, ptr %start_pos.addr, align 8
  store i64 %0, ptr %pos, align 8
  %1 = load ptr, ptr %params.addr, align 8
  %dist = getelementptr inbounds %struct.BrotliEncoderParams, ptr %1, i32 0, i32 9
  %alphabet_size_max = getelementptr inbounds %struct.BrotliDistanceParams, ptr %dist, i32 0, i32 2
  %2 = load i32, ptr %alphabet_size_max, align 8
  store i32 %2, ptr %num_distance_symbols, align 4
  %3 = load ptr, ptr %params.addr, align 8
  %dist1 = getelementptr inbounds %struct.BrotliEncoderParams, ptr %3, i32 0, i32 9
  %alphabet_size_limit = getelementptr inbounds %struct.BrotliDistanceParams, ptr %dist1, i32 0, i32 3
  %4 = load i32, ptr %alphabet_size_limit, align 4
  store i32 %4, ptr %num_effective_distance_symbols, align 4
  %5 = load i32, ptr %literal_context_mode.addr, align 4
  %shl = shl i32 %5, 9
  %idxprom = zext i32 %shl to i64
  %arrayidx = getelementptr inbounds [2048 x i8], ptr @_kBrotliContextLookupTable, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %literal_context_lut, align 8
  store ptr null, ptr %arena, align 8
  store ptr null, ptr %literal_enc, align 8
  store ptr null, ptr %command_enc, align 8
  store ptr null, ptr %distance_enc, align 8
  %6 = load ptr, ptr %params.addr, align 8
  %dist3 = getelementptr inbounds %struct.BrotliEncoderParams, ptr %6, i32 0, i32 9
  store ptr %dist3, ptr %dist2, align 8
  %7 = load i32, ptr %is_last.addr, align 4
  %8 = load i64, ptr %length.addr, align 8
  %9 = load ptr, ptr %storage_ix.addr, align 8
  %10 = load ptr, ptr %storage.addr, align 8
  call void @StoreCompressedMetaBlockHeader(i32 noundef %7, i64 noundef %8, ptr noundef %9, ptr noundef %10)
  %11 = load ptr, ptr %m.addr, align 8
  %call = call ptr @BrotliAllocate(ptr noundef %11, i64 noundef 11272)
  store ptr %call, ptr %tree, align 8
  %12 = load ptr, ptr %m.addr, align 8
  %call4 = call ptr @BrotliAllocate(ptr noundef %12, i64 noundef 4760)
  store ptr %call4, ptr %arena, align 8
  %13 = load ptr, ptr %arena, align 8
  %literal_enc5 = getelementptr inbounds %struct.StoreMetablockArena, ptr %13, i32 0, i32 0
  store ptr %literal_enc5, ptr %literal_enc, align 8
  %14 = load ptr, ptr %arena, align 8
  %command_enc6 = getelementptr inbounds %struct.StoreMetablockArena, ptr %14, i32 0, i32 1
  store ptr %command_enc6, ptr %command_enc, align 8
  %15 = load ptr, ptr %arena, align 8
  %distance_enc7 = getelementptr inbounds %struct.StoreMetablockArena, ptr %15, i32 0, i32 2
  store ptr %distance_enc7, ptr %distance_enc, align 8
  %16 = load ptr, ptr %literal_enc, align 8
  %17 = load ptr, ptr %mb.addr, align 8
  %literal_split = getelementptr inbounds %struct.MetaBlockSplit, ptr %17, i32 0, i32 0
  %num_types = getelementptr inbounds %struct.BlockSplit, ptr %literal_split, i32 0, i32 0
  %18 = load i64, ptr %num_types, align 8
  %19 = load ptr, ptr %mb.addr, align 8
  %literal_split8 = getelementptr inbounds %struct.MetaBlockSplit, ptr %19, i32 0, i32 0
  %types = getelementptr inbounds %struct.BlockSplit, ptr %literal_split8, i32 0, i32 2
  %20 = load ptr, ptr %types, align 8
  %21 = load ptr, ptr %mb.addr, align 8
  %literal_split9 = getelementptr inbounds %struct.MetaBlockSplit, ptr %21, i32 0, i32 0
  %lengths = getelementptr inbounds %struct.BlockSplit, ptr %literal_split9, i32 0, i32 3
  %22 = load ptr, ptr %lengths, align 8
  %23 = load ptr, ptr %mb.addr, align 8
  %literal_split10 = getelementptr inbounds %struct.MetaBlockSplit, ptr %23, i32 0, i32 0
  %num_blocks = getelementptr inbounds %struct.BlockSplit, ptr %literal_split10, i32 0, i32 1
  %24 = load i64, ptr %num_blocks, align 8
  call void @InitBlockEncoder(ptr noundef %16, i64 noundef 256, i64 noundef %18, ptr noundef %20, ptr noundef %22, i64 noundef %24)
  %25 = load ptr, ptr %command_enc, align 8
  %26 = load ptr, ptr %mb.addr, align 8
  %command_split = getelementptr inbounds %struct.MetaBlockSplit, ptr %26, i32 0, i32 1
  %num_types11 = getelementptr inbounds %struct.BlockSplit, ptr %command_split, i32 0, i32 0
  %27 = load i64, ptr %num_types11, align 8
  %28 = load ptr, ptr %mb.addr, align 8
  %command_split12 = getelementptr inbounds %struct.MetaBlockSplit, ptr %28, i32 0, i32 1
  %types13 = getelementptr inbounds %struct.BlockSplit, ptr %command_split12, i32 0, i32 2
  %29 = load ptr, ptr %types13, align 8
  %30 = load ptr, ptr %mb.addr, align 8
  %command_split14 = getelementptr inbounds %struct.MetaBlockSplit, ptr %30, i32 0, i32 1
  %lengths15 = getelementptr inbounds %struct.BlockSplit, ptr %command_split14, i32 0, i32 3
  %31 = load ptr, ptr %lengths15, align 8
  %32 = load ptr, ptr %mb.addr, align 8
  %command_split16 = getelementptr inbounds %struct.MetaBlockSplit, ptr %32, i32 0, i32 1
  %num_blocks17 = getelementptr inbounds %struct.BlockSplit, ptr %command_split16, i32 0, i32 1
  %33 = load i64, ptr %num_blocks17, align 8
  call void @InitBlockEncoder(ptr noundef %25, i64 noundef 704, i64 noundef %27, ptr noundef %29, ptr noundef %31, i64 noundef %33)
  %34 = load ptr, ptr %distance_enc, align 8
  %35 = load i32, ptr %num_effective_distance_symbols, align 4
  %conv = zext i32 %35 to i64
  %36 = load ptr, ptr %mb.addr, align 8
  %distance_split = getelementptr inbounds %struct.MetaBlockSplit, ptr %36, i32 0, i32 2
  %num_types18 = getelementptr inbounds %struct.BlockSplit, ptr %distance_split, i32 0, i32 0
  %37 = load i64, ptr %num_types18, align 8
  %38 = load ptr, ptr %mb.addr, align 8
  %distance_split19 = getelementptr inbounds %struct.MetaBlockSplit, ptr %38, i32 0, i32 2
  %types20 = getelementptr inbounds %struct.BlockSplit, ptr %distance_split19, i32 0, i32 2
  %39 = load ptr, ptr %types20, align 8
  %40 = load ptr, ptr %mb.addr, align 8
  %distance_split21 = getelementptr inbounds %struct.MetaBlockSplit, ptr %40, i32 0, i32 2
  %lengths22 = getelementptr inbounds %struct.BlockSplit, ptr %distance_split21, i32 0, i32 3
  %41 = load ptr, ptr %lengths22, align 8
  %42 = load ptr, ptr %mb.addr, align 8
  %distance_split23 = getelementptr inbounds %struct.MetaBlockSplit, ptr %42, i32 0, i32 2
  %num_blocks24 = getelementptr inbounds %struct.BlockSplit, ptr %distance_split23, i32 0, i32 1
  %43 = load i64, ptr %num_blocks24, align 8
  call void @InitBlockEncoder(ptr noundef %34, i64 noundef %conv, i64 noundef %37, ptr noundef %39, ptr noundef %41, i64 noundef %43)
  %44 = load ptr, ptr %literal_enc, align 8
  %45 = load ptr, ptr %tree, align 8
  %46 = load ptr, ptr %storage_ix.addr, align 8
  %47 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreBlockSwitchEntropyCodes(ptr noundef %44, ptr noundef %45, ptr noundef %46, ptr noundef %47)
  %48 = load ptr, ptr %command_enc, align 8
  %49 = load ptr, ptr %tree, align 8
  %50 = load ptr, ptr %storage_ix.addr, align 8
  %51 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreBlockSwitchEntropyCodes(ptr noundef %48, ptr noundef %49, ptr noundef %50, ptr noundef %51)
  %52 = load ptr, ptr %distance_enc, align 8
  %53 = load ptr, ptr %tree, align 8
  %54 = load ptr, ptr %storage_ix.addr, align 8
  %55 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreBlockSwitchEntropyCodes(ptr noundef %52, ptr noundef %53, ptr noundef %54, ptr noundef %55)
  %56 = load ptr, ptr %dist2, align 8
  %distance_postfix_bits = getelementptr inbounds %struct.BrotliDistanceParams, ptr %56, i32 0, i32 0
  %57 = load i32, ptr %distance_postfix_bits, align 8
  %conv25 = zext i32 %57 to i64
  %58 = load ptr, ptr %storage_ix.addr, align 8
  %59 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !167)
  call void @llvm.experimental.noalias.scope.decl(metadata !170)
  store i64 2, ptr %n_bits.addr.i159, align 8, !noalias !172
  store i64 %conv25, ptr %bits.addr.i160, align 8, !noalias !172
  store ptr %58, ptr %pos.addr.i161, align 8, !noalias !172
  store ptr %59, ptr %array.addr.i162, align 8, !noalias !172
  %60 = load ptr, ptr %array.addr.i162, align 8, !noalias !172
  %61 = load ptr, ptr %pos.addr.i161, align 8, !noalias !172
  %62 = load i64, ptr %61, align 8
  %shr.i165 = lshr i64 %62, 3
  %arrayidx.i166 = getelementptr inbounds i8, ptr %60, i64 %shr.i165
  store ptr %arrayidx.i166, ptr %p.i163, align 8, !noalias !172
  %63 = load ptr, ptr %p.i163, align 8, !noalias !172
  %64 = load i8, ptr %63, align 1
  %conv.i167 = zext i8 %64 to i64
  store i64 %conv.i167, ptr %v.i164, align 8, !noalias !172
  %65 = load i64, ptr %bits.addr.i160, align 8, !noalias !172
  %66 = load ptr, ptr %pos.addr.i161, align 8, !noalias !172
  %67 = load i64, ptr %66, align 8
  %and.i168 = and i64 %67, 7
  %shl.i169 = shl i64 %65, %and.i168
  %68 = load i64, ptr %v.i164, align 8, !noalias !172
  %or.i170 = or i64 %68, %shl.i169
  store i64 %or.i170, ptr %v.i164, align 8, !noalias !172
  %69 = load ptr, ptr %p.i163, align 8, !noalias !172
  %70 = load i64, ptr %v.i164, align 8, !noalias !172
  store ptr %69, ptr %p.addr.i185, align 8
  store i64 %70, ptr %v.addr.i186, align 8
  %71 = load ptr, ptr %p.addr.i185, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %71, ptr align 8 %v.addr.i186, i64 8, i1 false)
  %72 = load i64, ptr %n_bits.addr.i159, align 8, !noalias !172
  %73 = load ptr, ptr %pos.addr.i161, align 8, !noalias !172
  %74 = load i64, ptr %73, align 8
  %add.i171 = add i64 %74, %72
  store i64 %add.i171, ptr %73, align 8
  %75 = load ptr, ptr %dist2, align 8
  %num_direct_distance_codes = getelementptr inbounds %struct.BrotliDistanceParams, ptr %75, i32 0, i32 1
  %76 = load i32, ptr %num_direct_distance_codes, align 4
  %77 = load ptr, ptr %dist2, align 8
  %distance_postfix_bits26 = getelementptr inbounds %struct.BrotliDistanceParams, ptr %77, i32 0, i32 0
  %78 = load i32, ptr %distance_postfix_bits26, align 8
  %shr = lshr i32 %76, %78
  %conv27 = zext i32 %shr to i64
  %79 = load ptr, ptr %storage_ix.addr, align 8
  %80 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !173)
  call void @llvm.experimental.noalias.scope.decl(metadata !176)
  store i64 4, ptr %n_bits.addr.i146, align 8, !noalias !178
  store i64 %conv27, ptr %bits.addr.i147, align 8, !noalias !178
  store ptr %79, ptr %pos.addr.i148, align 8, !noalias !178
  store ptr %80, ptr %array.addr.i149, align 8, !noalias !178
  %81 = load ptr, ptr %array.addr.i149, align 8, !noalias !178
  %82 = load ptr, ptr %pos.addr.i148, align 8, !noalias !178
  %83 = load i64, ptr %82, align 8
  %shr.i152 = lshr i64 %83, 3
  %arrayidx.i153 = getelementptr inbounds i8, ptr %81, i64 %shr.i152
  store ptr %arrayidx.i153, ptr %p.i150, align 8, !noalias !178
  %84 = load ptr, ptr %p.i150, align 8, !noalias !178
  %85 = load i8, ptr %84, align 1
  %conv.i154 = zext i8 %85 to i64
  store i64 %conv.i154, ptr %v.i151, align 8, !noalias !178
  %86 = load i64, ptr %bits.addr.i147, align 8, !noalias !178
  %87 = load ptr, ptr %pos.addr.i148, align 8, !noalias !178
  %88 = load i64, ptr %87, align 8
  %and.i155 = and i64 %88, 7
  %shl.i156 = shl i64 %86, %and.i155
  %89 = load i64, ptr %v.i151, align 8, !noalias !178
  %or.i157 = or i64 %89, %shl.i156
  store i64 %or.i157, ptr %v.i151, align 8, !noalias !178
  %90 = load ptr, ptr %p.i150, align 8, !noalias !178
  %91 = load i64, ptr %v.i151, align 8, !noalias !178
  store ptr %90, ptr %p.addr.i187, align 8
  store i64 %91, ptr %v.addr.i188, align 8
  %92 = load ptr, ptr %p.addr.i187, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %92, ptr align 8 %v.addr.i188, i64 8, i1 false)
  %93 = load i64, ptr %n_bits.addr.i146, align 8, !noalias !178
  %94 = load ptr, ptr %pos.addr.i148, align 8, !noalias !178
  %95 = load i64, ptr %94, align 8
  %add.i158 = add i64 %95, %93
  store i64 %add.i158, ptr %94, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %96 = load i64, ptr %i, align 8
  %97 = load ptr, ptr %mb.addr, align 8
  %literal_split28 = getelementptr inbounds %struct.MetaBlockSplit, ptr %97, i32 0, i32 0
  %num_types29 = getelementptr inbounds %struct.BlockSplit, ptr %literal_split28, i32 0, i32 0
  %98 = load i64, ptr %num_types29, align 8
  %cmp = icmp ult i64 %96, %98
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %99 = load i32, ptr %literal_context_mode.addr, align 4
  %conv31 = zext i32 %99 to i64
  %100 = load ptr, ptr %storage_ix.addr, align 8
  %101 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !179)
  call void @llvm.experimental.noalias.scope.decl(metadata !182)
  store i64 2, ptr %n_bits.addr.i133, align 8, !noalias !184
  store i64 %conv31, ptr %bits.addr.i134, align 8, !noalias !184
  store ptr %100, ptr %pos.addr.i135, align 8, !noalias !184
  store ptr %101, ptr %array.addr.i136, align 8, !noalias !184
  %102 = load ptr, ptr %array.addr.i136, align 8, !noalias !184
  %103 = load ptr, ptr %pos.addr.i135, align 8, !noalias !184
  %104 = load i64, ptr %103, align 8
  %shr.i139 = lshr i64 %104, 3
  %arrayidx.i140 = getelementptr inbounds i8, ptr %102, i64 %shr.i139
  store ptr %arrayidx.i140, ptr %p.i137, align 8, !noalias !184
  %105 = load ptr, ptr %p.i137, align 8, !noalias !184
  %106 = load i8, ptr %105, align 1
  %conv.i141 = zext i8 %106 to i64
  store i64 %conv.i141, ptr %v.i138, align 8, !noalias !184
  %107 = load i64, ptr %bits.addr.i134, align 8, !noalias !184
  %108 = load ptr, ptr %pos.addr.i135, align 8, !noalias !184
  %109 = load i64, ptr %108, align 8
  %and.i142 = and i64 %109, 7
  %shl.i143 = shl i64 %107, %and.i142
  %110 = load i64, ptr %v.i138, align 8, !noalias !184
  %or.i144 = or i64 %110, %shl.i143
  store i64 %or.i144, ptr %v.i138, align 8, !noalias !184
  %111 = load ptr, ptr %p.i137, align 8, !noalias !184
  %112 = load i64, ptr %v.i138, align 8, !noalias !184
  store ptr %111, ptr %p.addr.i189, align 8
  store i64 %112, ptr %v.addr.i190, align 8
  %113 = load ptr, ptr %p.addr.i189, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %113, ptr align 8 %v.addr.i190, i64 8, i1 false)
  %114 = load i64, ptr %n_bits.addr.i133, align 8, !noalias !184
  %115 = load ptr, ptr %pos.addr.i135, align 8, !noalias !184
  %116 = load i64, ptr %115, align 8
  %add.i145 = add i64 %116, %114
  store i64 %add.i145, ptr %115, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %117 = load i64, ptr %i, align 8
  %inc = add i64 %117, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !185

for.end:                                          ; preds = %for.cond
  %118 = load ptr, ptr %mb.addr, align 8
  %literal_context_map_size = getelementptr inbounds %struct.MetaBlockSplit, ptr %118, i32 0, i32 4
  %119 = load i64, ptr %literal_context_map_size, align 8
  %cmp32 = icmp eq i64 %119, 0
  br i1 %cmp32, label %if.then, label %if.else

if.then:                                          ; preds = %for.end
  %120 = load ptr, ptr %arena, align 8
  %context_map_arena = getelementptr inbounds %struct.StoreMetablockArena, ptr %120, i32 0, i32 3
  %121 = load ptr, ptr %mb.addr, align 8
  %literal_histograms_size = getelementptr inbounds %struct.MetaBlockSplit, ptr %121, i32 0, i32 8
  %122 = load i64, ptr %literal_histograms_size, align 8
  %123 = load ptr, ptr %tree, align 8
  %124 = load ptr, ptr %storage_ix.addr, align 8
  %125 = load ptr, ptr %storage.addr, align 8
  call void @StoreTrivialContextMap(ptr noundef %context_map_arena, i64 noundef %122, i64 noundef 6, ptr noundef %123, ptr noundef %124, ptr noundef %125)
  br label %if.end

if.else:                                          ; preds = %for.end
  %126 = load ptr, ptr %m.addr, align 8
  %127 = load ptr, ptr %arena, align 8
  %context_map_arena34 = getelementptr inbounds %struct.StoreMetablockArena, ptr %127, i32 0, i32 3
  %128 = load ptr, ptr %mb.addr, align 8
  %literal_context_map = getelementptr inbounds %struct.MetaBlockSplit, ptr %128, i32 0, i32 3
  %129 = load ptr, ptr %literal_context_map, align 8
  %130 = load ptr, ptr %mb.addr, align 8
  %literal_context_map_size35 = getelementptr inbounds %struct.MetaBlockSplit, ptr %130, i32 0, i32 4
  %131 = load i64, ptr %literal_context_map_size35, align 8
  %132 = load ptr, ptr %mb.addr, align 8
  %literal_histograms_size36 = getelementptr inbounds %struct.MetaBlockSplit, ptr %132, i32 0, i32 8
  %133 = load i64, ptr %literal_histograms_size36, align 8
  %134 = load ptr, ptr %tree, align 8
  %135 = load ptr, ptr %storage_ix.addr, align 8
  %136 = load ptr, ptr %storage.addr, align 8
  call void @EncodeContextMap(ptr noundef %126, ptr noundef %context_map_arena34, ptr noundef %129, i64 noundef %131, i64 noundef %133, ptr noundef %134, ptr noundef %135, ptr noundef %136)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %137 = load ptr, ptr %mb.addr, align 8
  %distance_context_map_size = getelementptr inbounds %struct.MetaBlockSplit, ptr %137, i32 0, i32 6
  %138 = load i64, ptr %distance_context_map_size, align 8
  %cmp37 = icmp eq i64 %138, 0
  br i1 %cmp37, label %if.then39, label %if.else41

if.then39:                                        ; preds = %if.end
  %139 = load ptr, ptr %arena, align 8
  %context_map_arena40 = getelementptr inbounds %struct.StoreMetablockArena, ptr %139, i32 0, i32 3
  %140 = load ptr, ptr %mb.addr, align 8
  %distance_histograms_size = getelementptr inbounds %struct.MetaBlockSplit, ptr %140, i32 0, i32 12
  %141 = load i64, ptr %distance_histograms_size, align 8
  %142 = load ptr, ptr %tree, align 8
  %143 = load ptr, ptr %storage_ix.addr, align 8
  %144 = load ptr, ptr %storage.addr, align 8
  call void @StoreTrivialContextMap(ptr noundef %context_map_arena40, i64 noundef %141, i64 noundef 2, ptr noundef %142, ptr noundef %143, ptr noundef %144)
  br label %if.end45

if.else41:                                        ; preds = %if.end
  %145 = load ptr, ptr %m.addr, align 8
  %146 = load ptr, ptr %arena, align 8
  %context_map_arena42 = getelementptr inbounds %struct.StoreMetablockArena, ptr %146, i32 0, i32 3
  %147 = load ptr, ptr %mb.addr, align 8
  %distance_context_map = getelementptr inbounds %struct.MetaBlockSplit, ptr %147, i32 0, i32 5
  %148 = load ptr, ptr %distance_context_map, align 8
  %149 = load ptr, ptr %mb.addr, align 8
  %distance_context_map_size43 = getelementptr inbounds %struct.MetaBlockSplit, ptr %149, i32 0, i32 6
  %150 = load i64, ptr %distance_context_map_size43, align 8
  %151 = load ptr, ptr %mb.addr, align 8
  %distance_histograms_size44 = getelementptr inbounds %struct.MetaBlockSplit, ptr %151, i32 0, i32 12
  %152 = load i64, ptr %distance_histograms_size44, align 8
  %153 = load ptr, ptr %tree, align 8
  %154 = load ptr, ptr %storage_ix.addr, align 8
  %155 = load ptr, ptr %storage.addr, align 8
  call void @EncodeContextMap(ptr noundef %145, ptr noundef %context_map_arena42, ptr noundef %148, i64 noundef %150, i64 noundef %152, ptr noundef %153, ptr noundef %154, ptr noundef %155)
  br label %if.end45

if.end45:                                         ; preds = %if.else41, %if.then39
  %156 = load ptr, ptr %m.addr, align 8
  %157 = load ptr, ptr %literal_enc, align 8
  %158 = load ptr, ptr %mb.addr, align 8
  %literal_histograms = getelementptr inbounds %struct.MetaBlockSplit, ptr %158, i32 0, i32 7
  %159 = load ptr, ptr %literal_histograms, align 8
  %160 = load ptr, ptr %mb.addr, align 8
  %literal_histograms_size46 = getelementptr inbounds %struct.MetaBlockSplit, ptr %160, i32 0, i32 8
  %161 = load i64, ptr %literal_histograms_size46, align 8
  %162 = load ptr, ptr %tree, align 8
  %163 = load ptr, ptr %storage_ix.addr, align 8
  %164 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreEntropyCodesLiteral(ptr noundef %156, ptr noundef %157, ptr noundef %159, i64 noundef %161, i64 noundef 256, ptr noundef %162, ptr noundef %163, ptr noundef %164)
  %165 = load ptr, ptr %m.addr, align 8
  %166 = load ptr, ptr %command_enc, align 8
  %167 = load ptr, ptr %mb.addr, align 8
  %command_histograms = getelementptr inbounds %struct.MetaBlockSplit, ptr %167, i32 0, i32 9
  %168 = load ptr, ptr %command_histograms, align 8
  %169 = load ptr, ptr %mb.addr, align 8
  %command_histograms_size = getelementptr inbounds %struct.MetaBlockSplit, ptr %169, i32 0, i32 10
  %170 = load i64, ptr %command_histograms_size, align 8
  %171 = load ptr, ptr %tree, align 8
  %172 = load ptr, ptr %storage_ix.addr, align 8
  %173 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreEntropyCodesCommand(ptr noundef %165, ptr noundef %166, ptr noundef %168, i64 noundef %170, i64 noundef 704, ptr noundef %171, ptr noundef %172, ptr noundef %173)
  %174 = load ptr, ptr %m.addr, align 8
  %175 = load ptr, ptr %distance_enc, align 8
  %176 = load ptr, ptr %mb.addr, align 8
  %distance_histograms = getelementptr inbounds %struct.MetaBlockSplit, ptr %176, i32 0, i32 11
  %177 = load ptr, ptr %distance_histograms, align 8
  %178 = load ptr, ptr %mb.addr, align 8
  %distance_histograms_size47 = getelementptr inbounds %struct.MetaBlockSplit, ptr %178, i32 0, i32 12
  %179 = load i64, ptr %distance_histograms_size47, align 8
  %180 = load i32, ptr %num_distance_symbols, align 4
  %conv48 = zext i32 %180 to i64
  %181 = load ptr, ptr %tree, align 8
  %182 = load ptr, ptr %storage_ix.addr, align 8
  %183 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreEntropyCodesDistance(ptr noundef %174, ptr noundef %175, ptr noundef %177, i64 noundef %179, i64 noundef %conv48, ptr noundef %181, ptr noundef %182, ptr noundef %183)
  %184 = load ptr, ptr %m.addr, align 8
  %185 = load ptr, ptr %tree, align 8
  call void @BrotliFree(ptr noundef %184, ptr noundef %185)
  store ptr null, ptr %tree, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond49

for.cond49:                                       ; preds = %for.inc127, %if.end45
  %186 = load i64, ptr %i, align 8
  %187 = load i64, ptr %n_commands.addr, align 8
  %cmp50 = icmp ult i64 %186, %187
  br i1 %cmp50, label %for.body52, label %for.end129

for.body52:                                       ; preds = %for.cond49
  %188 = load ptr, ptr %commands.addr, align 8
  %189 = load i64, ptr %i, align 8
  %arrayidx53 = getelementptr inbounds %struct.Command, ptr %188, i64 %189
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %cmd, ptr align 4 %arrayidx53, i64 16, i1 false)
  %cmd_prefix_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 3
  %190 = load i16, ptr %cmd_prefix_, align 4
  %conv54 = zext i16 %190 to i64
  store i64 %conv54, ptr %cmd_code, align 8
  %191 = load ptr, ptr %command_enc, align 8
  %192 = load i64, ptr %cmd_code, align 8
  %193 = load ptr, ptr %storage_ix.addr, align 8
  %194 = load ptr, ptr %storage.addr, align 8
  call void @StoreSymbol(ptr noundef %191, i64 noundef %192, ptr noundef %193, ptr noundef %194)
  %195 = load ptr, ptr %storage_ix.addr, align 8
  %196 = load ptr, ptr %storage.addr, align 8
  store ptr %cmd, ptr %cmd.addr.i, align 8
  store ptr %195, ptr %storage_ix.addr.i, align 8
  store ptr %196, ptr %storage.addr.i, align 8
  %197 = load ptr, ptr %cmd.addr.i, align 8
  store ptr %197, ptr %self.addr.i193, align 8
  %198 = load ptr, ptr %self.addr.i193, align 8
  %copy_len_.i194 = getelementptr inbounds %struct.Command, ptr %198, i32 0, i32 1
  %199 = load i32, ptr %copy_len_.i194, align 4
  %shr.i195 = lshr i32 %199, 25
  store i32 %shr.i195, ptr %modifier.i, align 4
  %200 = load i32, ptr %modifier.i, align 4
  %201 = load i32, ptr %modifier.i, align 4
  %and.i196 = and i32 %201, 64
  %shl.i197 = shl i32 %and.i196, 1
  %or.i198 = or i32 %200, %shl.i197
  %conv.i199 = trunc i32 %or.i198 to i8
  %conv1.i = sext i8 %conv.i199 to i32
  store i32 %conv1.i, ptr %delta.i, align 4
  %202 = load ptr, ptr %self.addr.i193, align 8
  %copy_len_2.i = getelementptr inbounds %struct.Command, ptr %202, i32 0, i32 1
  %203 = load i32, ptr %copy_len_2.i, align 4
  %and3.i = and i32 %203, 33554431
  %204 = load i32, ptr %delta.i, align 4
  %add.i200 = add nsw i32 %and3.i, %204
  store i32 %add.i200, ptr %copylen_code.i, align 4
  %205 = load ptr, ptr %cmd.addr.i, align 8
  %206 = load i32, ptr %205, align 4
  %conv.i172 = zext i32 %206 to i64
  store i64 %conv.i172, ptr %insertlen.addr.i, align 8
  %207 = load i64, ptr %insertlen.addr.i, align 8
  %cmp.i202 = icmp ult i64 %207, 6
  br i1 %cmp.i202, label %if.then.i210, label %if.else.i

if.then.i210:                                     ; preds = %for.body52
  %208 = load i64, ptr %insertlen.addr.i, align 8
  %conv.i211 = trunc i64 %208 to i16
  store i16 %conv.i211, ptr %retval.i201, align 2
  br label %GetInsertLengthCode.exit

if.else.i:                                        ; preds = %for.body52
  %209 = load i64, ptr %insertlen.addr.i, align 8
  %cmp1.i = icmp ult i64 %209, 130
  br i1 %cmp1.i, label %if.then3.i, label %if.else9.i

if.then3.i:                                       ; preds = %if.else.i
  %210 = load i64, ptr %insertlen.addr.i, align 8
  %sub.i205 = sub i64 %210, 2
  store i64 %sub.i205, ptr %n.addr.i26.i, align 8
  %211 = load i64, ptr %n.addr.i26.i, align 8
  %conv.i27.i = trunc i64 %211 to i32
  %212 = call i32 @llvm.ctlz.i32(i32 %conv.i27.i, i1 true)
  %xor.i28.i = xor i32 31, %212
  %sub4.i = sub i32 %xor.i28.i, 1
  store i32 %sub4.i, ptr %nbits.i, align 4
  %213 = load i32, ptr %nbits.i, align 4
  %shl.i206 = shl i32 %213, 1
  %conv5.i = zext i32 %shl.i206 to i64
  %214 = load i64, ptr %insertlen.addr.i, align 8
  %sub6.i = sub i64 %214, 2
  %215 = load i32, ptr %nbits.i, align 4
  %sh_prom.i207 = zext i32 %215 to i64
  %shr.i208 = lshr i64 %sub6.i, %sh_prom.i207
  %add.i209 = add i64 %conv5.i, %shr.i208
  %add7.i = add i64 %add.i209, 2
  %conv8.i = trunc i64 %add7.i to i16
  store i16 %conv8.i, ptr %retval.i201, align 2
  br label %GetInsertLengthCode.exit

if.else9.i:                                       ; preds = %if.else.i
  %216 = load i64, ptr %insertlen.addr.i, align 8
  %cmp10.i203 = icmp ult i64 %216, 2114
  br i1 %cmp10.i203, label %if.then12.i, label %if.else17.i

if.then12.i:                                      ; preds = %if.else9.i
  %217 = load i64, ptr %insertlen.addr.i, align 8
  %sub13.i = sub i64 %217, 66
  store i64 %sub13.i, ptr %n.addr.i.i, align 8
  %218 = load i64, ptr %n.addr.i.i, align 8
  %conv.i.i204 = trunc i64 %218 to i32
  %219 = call i32 @llvm.ctlz.i32(i32 %conv.i.i204, i1 true)
  %xor.i.i = xor i32 31, %219
  %add15.i = add i32 %xor.i.i, 10
  %conv16.i = trunc i32 %add15.i to i16
  store i16 %conv16.i, ptr %retval.i201, align 2
  br label %GetInsertLengthCode.exit

if.else17.i:                                      ; preds = %if.else9.i
  %220 = load i64, ptr %insertlen.addr.i, align 8
  %cmp18.i = icmp ult i64 %220, 6210
  br i1 %cmp18.i, label %if.then20.i, label %if.else21.i

if.then20.i:                                      ; preds = %if.else17.i
  store i16 21, ptr %retval.i201, align 2
  br label %GetInsertLengthCode.exit

if.else21.i:                                      ; preds = %if.else17.i
  %221 = load i64, ptr %insertlen.addr.i, align 8
  %cmp22.i = icmp ult i64 %221, 22594
  br i1 %cmp22.i, label %if.then24.i, label %if.else25.i

if.then24.i:                                      ; preds = %if.else21.i
  store i16 22, ptr %retval.i201, align 2
  br label %GetInsertLengthCode.exit

if.else25.i:                                      ; preds = %if.else21.i
  store i16 23, ptr %retval.i201, align 2
  br label %GetInsertLengthCode.exit

GetInsertLengthCode.exit:                         ; preds = %if.else25.i, %if.then24.i, %if.then20.i, %if.then12.i, %if.then3.i, %if.then.i210
  %222 = load i16, ptr %retval.i201, align 2
  store i16 %222, ptr %inscode.i, align 2
  %223 = load i32, ptr %copylen_code.i, align 4
  %conv2.i = zext i32 %223 to i64
  store i64 %conv2.i, ptr %copylen.addr.i, align 8
  %224 = load i64, ptr %copylen.addr.i, align 8
  %cmp.i215 = icmp ult i64 %224, 10
  br i1 %cmp.i215, label %if.then.i226, label %if.else.i216

if.then.i226:                                     ; preds = %GetInsertLengthCode.exit
  %225 = load i64, ptr %copylen.addr.i, align 8
  %sub.i227 = sub i64 %225, 2
  %conv.i228 = trunc i64 %sub.i227 to i16
  store i16 %conv.i228, ptr %retval.i213, align 2
  br label %GetCopyLengthCode.exit

if.else.i216:                                     ; preds = %GetInsertLengthCode.exit
  %226 = load i64, ptr %copylen.addr.i, align 8
  %cmp1.i217 = icmp ult i64 %226, 134
  br i1 %cmp1.i217, label %if.then3.i220, label %if.else10.i

if.then3.i220:                                    ; preds = %if.else.i216
  %227 = load i64, ptr %copylen.addr.i, align 8
  %sub4.i221 = sub i64 %227, 6
  store i64 %sub4.i221, ptr %n.addr.i19.i, align 8
  %228 = load i64, ptr %n.addr.i19.i, align 8
  %conv.i20.i = trunc i64 %228 to i32
  %229 = call i32 @llvm.ctlz.i32(i32 %conv.i20.i, i1 true)
  %xor.i21.i = xor i32 31, %229
  %sub5.i = sub i32 %xor.i21.i, 1
  store i32 %sub5.i, ptr %nbits.i214, align 4
  %230 = load i32, ptr %nbits.i214, align 4
  %shl.i222 = shl i32 %230, 1
  %conv6.i = zext i32 %shl.i222 to i64
  %231 = load i64, ptr %copylen.addr.i, align 8
  %sub7.i = sub i64 %231, 6
  %232 = load i32, ptr %nbits.i214, align 4
  %sh_prom.i223 = zext i32 %232 to i64
  %shr.i224 = lshr i64 %sub7.i, %sh_prom.i223
  %add.i225 = add i64 %conv6.i, %shr.i224
  %add8.i = add i64 %add.i225, 4
  %conv9.i = trunc i64 %add8.i to i16
  store i16 %conv9.i, ptr %retval.i213, align 2
  br label %GetCopyLengthCode.exit

if.else10.i:                                      ; preds = %if.else.i216
  %233 = load i64, ptr %copylen.addr.i, align 8
  %cmp11.i = icmp ult i64 %233, 2118
  br i1 %cmp11.i, label %if.then13.i, label %if.else18.i

if.then13.i:                                      ; preds = %if.else10.i
  %234 = load i64, ptr %copylen.addr.i, align 8
  %sub14.i = sub i64 %234, 70
  store i64 %sub14.i, ptr %n.addr.i.i212, align 8
  %235 = load i64, ptr %n.addr.i.i212, align 8
  %conv.i.i218 = trunc i64 %235 to i32
  %236 = call i32 @llvm.ctlz.i32(i32 %conv.i.i218, i1 true)
  %xor.i.i219 = xor i32 31, %236
  %add16.i = add i32 %xor.i.i219, 12
  %conv17.i = trunc i32 %add16.i to i16
  store i16 %conv17.i, ptr %retval.i213, align 2
  br label %GetCopyLengthCode.exit

if.else18.i:                                      ; preds = %if.else10.i
  store i16 23, ptr %retval.i213, align 2
  br label %GetCopyLengthCode.exit

GetCopyLengthCode.exit:                           ; preds = %if.else18.i, %if.then13.i, %if.then3.i220, %if.then.i226
  %237 = load i16, ptr %retval.i213, align 2
  store i16 %237, ptr %copycode.i, align 2
  %238 = load i16, ptr %inscode.i, align 2
  store i16 %238, ptr %inscode.addr.i, align 2
  %239 = load i16, ptr %inscode.addr.i, align 2
  %idxprom.i = zext i16 %239 to i64
  %arrayidx.i229 = getelementptr inbounds [24 x i32], ptr @kBrotliInsExtra, i64 0, i64 %idxprom.i
  %240 = load i32, ptr %arrayidx.i229, align 4
  store i32 %240, ptr %insnumextra.i, align 4
  %241 = load ptr, ptr %cmd.addr.i, align 8
  %242 = load i32, ptr %241, align 4
  %243 = load i16, ptr %inscode.i, align 2
  store i16 %243, ptr %inscode.addr.i230, align 2
  %244 = load i16, ptr %inscode.addr.i230, align 2
  %idxprom.i231 = zext i16 %244 to i64
  %arrayidx.i232 = getelementptr inbounds [24 x i32], ptr @kBrotliInsBase, i64 0, i64 %idxprom.i231
  %245 = load i32, ptr %arrayidx.i232, align 4
  %sub.i = sub i32 %242, %245
  %conv7.i = zext i32 %sub.i to i64
  store i64 %conv7.i, ptr %insextraval.i, align 8
  %246 = load i32, ptr %copylen_code.i, align 4
  %247 = load i16, ptr %copycode.i, align 2
  store i16 %247, ptr %copycode.addr.i, align 2
  %248 = load i16, ptr %copycode.addr.i, align 2
  %idxprom.i233 = zext i16 %248 to i64
  %arrayidx.i234 = getelementptr inbounds [24 x i32], ptr @kBrotliCopyBase, i64 0, i64 %idxprom.i233
  %249 = load i32, ptr %arrayidx.i234, align 4
  %sub9.i = sub i32 %246, %249
  %conv10.i = zext i32 %sub9.i to i64
  store i64 %conv10.i, ptr %copyextraval.i, align 8
  %250 = load i64, ptr %copyextraval.i, align 8
  %251 = load i32, ptr %insnumextra.i, align 4
  %sh_prom.i = zext i32 %251 to i64
  %shl.i173 = shl i64 %250, %sh_prom.i
  %252 = load i64, ptr %insextraval.i, align 8
  %or.i174 = or i64 %shl.i173, %252
  store i64 %or.i174, ptr %bits.i, align 8
  %253 = load i32, ptr %insnumextra.i, align 4
  %254 = load i16, ptr %copycode.i, align 2
  store i16 %254, ptr %copycode.addr.i235, align 2
  %255 = load i16, ptr %copycode.addr.i235, align 2
  %idxprom.i236 = zext i16 %255 to i64
  %arrayidx.i237 = getelementptr inbounds [24 x i32], ptr @kBrotliCopyExtra, i64 0, i64 %idxprom.i236
  %256 = load i32, ptr %arrayidx.i237, align 4
  %add.i175 = add i32 %253, %256
  %conv12.i = zext i32 %add.i175 to i64
  %257 = load i64, ptr %bits.i, align 8
  %258 = load ptr, ptr %storage_ix.addr.i, align 8
  %259 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !186)
  call void @llvm.experimental.noalias.scope.decl(metadata !189)
  store i64 %conv12.i, ptr %n_bits.addr.i.i, align 8, !noalias !191
  store i64 %257, ptr %bits.addr.i.i, align 8, !noalias !191
  store ptr %258, ptr %pos.addr.i.i, align 8, !noalias !191
  store ptr %259, ptr %array.addr.i.i, align 8, !noalias !191
  %260 = load ptr, ptr %array.addr.i.i, align 8, !noalias !191
  %261 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !191
  %262 = load i64, ptr %261, align 8
  %shr.i.i = lshr i64 %262, 3
  %arrayidx.i.i = getelementptr inbounds i8, ptr %260, i64 %shr.i.i
  store ptr %arrayidx.i.i, ptr %p.i.i, align 8, !noalias !191
  %263 = load ptr, ptr %p.i.i, align 8, !noalias !191
  %264 = load i8, ptr %263, align 1
  %conv.i.i = zext i8 %264 to i64
  store i64 %conv.i.i, ptr %v.i.i, align 8, !noalias !191
  %265 = load i64, ptr %bits.addr.i.i, align 8, !noalias !191
  %266 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !191
  %267 = load i64, ptr %266, align 8
  %and.i.i = and i64 %267, 7
  %shl.i.i = shl i64 %265, %and.i.i
  %268 = load i64, ptr %v.i.i, align 8, !noalias !191
  %or.i.i = or i64 %268, %shl.i.i
  store i64 %or.i.i, ptr %v.i.i, align 8, !noalias !191
  %269 = load ptr, ptr %p.i.i, align 8, !noalias !191
  %270 = load i64, ptr %v.i.i, align 8, !noalias !191
  store ptr %269, ptr %p.addr.i, align 8
  store i64 %270, ptr %v.addr.i, align 8
  %271 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %271, ptr align 8 %v.addr.i, i64 8, i1 false)
  %272 = load i64, ptr %n_bits.addr.i.i, align 8, !noalias !191
  %273 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !191
  %274 = load i64, ptr %273, align 8
  %add.i.i = add i64 %274, %272
  store i64 %add.i.i, ptr %273, align 8
  %275 = load ptr, ptr %mb.addr, align 8
  %literal_context_map_size55 = getelementptr inbounds %struct.MetaBlockSplit, ptr %275, i32 0, i32 4
  %276 = load i64, ptr %literal_context_map_size55, align 8
  %cmp56 = icmp eq i64 %276, 0
  br i1 %cmp56, label %if.then58, label %if.else69

if.then58:                                        ; preds = %GetCopyLengthCode.exit
  %insert_len_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 0
  %277 = load i32, ptr %insert_len_, align 4
  %conv59 = zext i32 %277 to i64
  store i64 %conv59, ptr %j, align 8
  br label %for.cond60

for.cond60:                                       ; preds = %for.inc67, %if.then58
  %278 = load i64, ptr %j, align 8
  %cmp61 = icmp ne i64 %278, 0
  br i1 %cmp61, label %for.body63, label %for.end68

for.body63:                                       ; preds = %for.cond60
  %279 = load ptr, ptr %literal_enc, align 8
  %280 = load ptr, ptr %input.addr, align 8
  %281 = load i64, ptr %pos, align 8
  %282 = load i64, ptr %mask.addr, align 8
  %and = and i64 %281, %282
  %arrayidx64 = getelementptr inbounds i8, ptr %280, i64 %and
  %283 = load i8, ptr %arrayidx64, align 1
  %conv65 = zext i8 %283 to i64
  %284 = load ptr, ptr %storage_ix.addr, align 8
  %285 = load ptr, ptr %storage.addr, align 8
  call void @StoreSymbol(ptr noundef %279, i64 noundef %conv65, ptr noundef %284, ptr noundef %285)
  %286 = load i64, ptr %pos, align 8
  %inc66 = add i64 %286, 1
  store i64 %inc66, ptr %pos, align 8
  br label %for.inc67

for.inc67:                                        ; preds = %for.body63
  %287 = load i64, ptr %j, align 8
  %dec = add i64 %287, -1
  store i64 %dec, ptr %j, align 8
  br label %for.cond60, !llvm.loop !192

for.end68:                                        ; preds = %for.cond60
  br label %if.end92

if.else69:                                        ; preds = %GetCopyLengthCode.exit
  %insert_len_71 = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 0
  %288 = load i32, ptr %insert_len_71, align 4
  %conv72 = zext i32 %288 to i64
  store i64 %conv72, ptr %j70, align 8
  br label %for.cond73

for.cond73:                                       ; preds = %for.inc89, %if.else69
  %289 = load i64, ptr %j70, align 8
  %cmp74 = icmp ne i64 %289, 0
  br i1 %cmp74, label %for.body76, label %for.end91

for.body76:                                       ; preds = %for.cond73
  %290 = load ptr, ptr %literal_context_lut, align 8
  %291 = load i8, ptr %prev_byte.addr, align 1
  %idxprom77 = zext i8 %291 to i64
  %arrayidx78 = getelementptr inbounds i8, ptr %290, i64 %idxprom77
  %292 = load i8, ptr %arrayidx78, align 1
  %conv79 = zext i8 %292 to i32
  %293 = load ptr, ptr %literal_context_lut, align 8
  %add.ptr = getelementptr inbounds i8, ptr %293, i64 256
  %294 = load i8, ptr %prev_byte2.addr, align 1
  %idxprom80 = zext i8 %294 to i64
  %arrayidx81 = getelementptr inbounds i8, ptr %add.ptr, i64 %idxprom80
  %295 = load i8, ptr %arrayidx81, align 1
  %conv82 = zext i8 %295 to i32
  %or = or i32 %conv79, %conv82
  %conv83 = sext i32 %or to i64
  store i64 %conv83, ptr %context, align 8
  %296 = load ptr, ptr %input.addr, align 8
  %297 = load i64, ptr %pos, align 8
  %298 = load i64, ptr %mask.addr, align 8
  %and84 = and i64 %297, %298
  %arrayidx85 = getelementptr inbounds i8, ptr %296, i64 %and84
  %299 = load i8, ptr %arrayidx85, align 1
  store i8 %299, ptr %literal, align 1
  %300 = load ptr, ptr %literal_enc, align 8
  %301 = load i8, ptr %literal, align 1
  %conv86 = zext i8 %301 to i64
  %302 = load i64, ptr %context, align 8
  %303 = load ptr, ptr %mb.addr, align 8
  %literal_context_map87 = getelementptr inbounds %struct.MetaBlockSplit, ptr %303, i32 0, i32 3
  %304 = load ptr, ptr %literal_context_map87, align 8
  %305 = load ptr, ptr %storage_ix.addr, align 8
  %306 = load ptr, ptr %storage.addr, align 8
  call void @StoreSymbolWithContext(ptr noundef %300, i64 noundef %conv86, i64 noundef %302, ptr noundef %304, ptr noundef %305, ptr noundef %306, i64 noundef 6)
  %307 = load i8, ptr %prev_byte.addr, align 1
  store i8 %307, ptr %prev_byte2.addr, align 1
  %308 = load i8, ptr %literal, align 1
  store i8 %308, ptr %prev_byte.addr, align 1
  %309 = load i64, ptr %pos, align 8
  %inc88 = add i64 %309, 1
  store i64 %inc88, ptr %pos, align 8
  br label %for.inc89

for.inc89:                                        ; preds = %for.body76
  %310 = load i64, ptr %j70, align 8
  %dec90 = add i64 %310, -1
  store i64 %dec90, ptr %j70, align 8
  br label %for.cond73, !llvm.loop !193

for.end91:                                        ; preds = %for.cond73
  br label %if.end92

if.end92:                                         ; preds = %for.end91, %for.end68
  store ptr %cmd, ptr %self.addr.i177, align 8
  %311 = load ptr, ptr %self.addr.i177, align 8
  %copy_len_.i178 = getelementptr inbounds %struct.Command, ptr %311, i32 0, i32 1
  %312 = load i32, ptr %copy_len_.i178, align 4
  %and.i179 = and i32 %312, 33554431
  %conv94 = zext i32 %and.i179 to i64
  %313 = load i64, ptr %pos, align 8
  %add = add i64 %313, %conv94
  store i64 %add, ptr %pos, align 8
  store ptr %cmd, ptr %self.addr.i, align 8
  %314 = load ptr, ptr %self.addr.i, align 8
  %copy_len_.i = getelementptr inbounds %struct.Command, ptr %314, i32 0, i32 1
  %315 = load i32, ptr %copy_len_.i, align 4
  %and.i176 = and i32 %315, 33554431
  %tobool = icmp ne i32 %and.i176, 0
  br i1 %tobool, label %if.then96, label %if.end126

if.then96:                                        ; preds = %if.end92
  %316 = load ptr, ptr %input.addr, align 8
  %317 = load i64, ptr %pos, align 8
  %sub = sub i64 %317, 2
  %318 = load i64, ptr %mask.addr, align 8
  %and97 = and i64 %sub, %318
  %arrayidx98 = getelementptr inbounds i8, ptr %316, i64 %and97
  %319 = load i8, ptr %arrayidx98, align 1
  store i8 %319, ptr %prev_byte2.addr, align 1
  %320 = load ptr, ptr %input.addr, align 8
  %321 = load i64, ptr %pos, align 8
  %sub99 = sub i64 %321, 1
  %322 = load i64, ptr %mask.addr, align 8
  %and100 = and i64 %sub99, %322
  %arrayidx101 = getelementptr inbounds i8, ptr %320, i64 %and100
  %323 = load i8, ptr %arrayidx101, align 1
  store i8 %323, ptr %prev_byte.addr, align 1
  %cmd_prefix_102 = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 3
  %324 = load i16, ptr %cmd_prefix_102, align 4
  %conv103 = zext i16 %324 to i32
  %cmp104 = icmp sge i32 %conv103, 128
  br i1 %cmp104, label %if.then106, label %if.end125

if.then106:                                       ; preds = %if.then96
  %dist_prefix_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 4
  %325 = load i16, ptr %dist_prefix_, align 2
  %conv107 = zext i16 %325 to i32
  %and108 = and i32 %conv107, 1023
  %conv109 = sext i32 %and108 to i64
  store i64 %conv109, ptr %dist_code, align 8
  %dist_prefix_110 = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 4
  %326 = load i16, ptr %dist_prefix_110, align 2
  %conv111 = zext i16 %326 to i32
  %shr112 = ashr i32 %conv111, 10
  store i32 %shr112, ptr %distnumextra, align 4
  %dist_extra_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 2
  %327 = load i32, ptr %dist_extra_, align 4
  %conv113 = zext i32 %327 to i64
  store i64 %conv113, ptr %distextra, align 8
  %328 = load ptr, ptr %mb.addr, align 8
  %distance_context_map_size114 = getelementptr inbounds %struct.MetaBlockSplit, ptr %328, i32 0, i32 6
  %329 = load i64, ptr %distance_context_map_size114, align 8
  %cmp115 = icmp eq i64 %329, 0
  br i1 %cmp115, label %if.then117, label %if.else118

if.then117:                                       ; preds = %if.then106
  %330 = load ptr, ptr %distance_enc, align 8
  %331 = load i64, ptr %dist_code, align 8
  %332 = load ptr, ptr %storage_ix.addr, align 8
  %333 = load ptr, ptr %storage.addr, align 8
  call void @StoreSymbol(ptr noundef %330, i64 noundef %331, ptr noundef %332, ptr noundef %333)
  br label %if.end123

if.else118:                                       ; preds = %if.then106
  store ptr %cmd, ptr %self.addr.i180, align 8
  %334 = load ptr, ptr %self.addr.i180, align 8
  %cmd_prefix_.i = getelementptr inbounds %struct.Command, ptr %334, i32 0, i32 3
  %335 = load i16, ptr %cmd_prefix_.i, align 4
  %conv.i181 = zext i16 %335 to i32
  %shr.i182 = ashr i32 %conv.i181, 6
  store i32 %shr.i182, ptr %r.i, align 4
  %336 = load ptr, ptr %self.addr.i180, align 8
  %cmd_prefix_1.i = getelementptr inbounds %struct.Command, ptr %336, i32 0, i32 3
  %337 = load i16, ptr %cmd_prefix_1.i, align 4
  %conv2.i183 = zext i16 %337 to i32
  %and.i184 = and i32 %conv2.i183, 7
  store i32 %and.i184, ptr %c.i, align 4
  %338 = load i32, ptr %r.i, align 4
  %cmp.i = icmp eq i32 %338, 0
  br i1 %cmp.i, label %land.lhs.true.i, label %lor.lhs.false.i

lor.lhs.false.i:                                  ; preds = %if.else118
  %339 = load i32, ptr %r.i, align 4
  %cmp4.i = icmp eq i32 %339, 2
  br i1 %cmp4.i, label %land.lhs.true.i, label %lor.lhs.false6.i

lor.lhs.false6.i:                                 ; preds = %lor.lhs.false.i
  %340 = load i32, ptr %r.i, align 4
  %cmp7.i = icmp eq i32 %340, 4
  br i1 %cmp7.i, label %land.lhs.true.i, label %lor.lhs.false9.i

lor.lhs.false9.i:                                 ; preds = %lor.lhs.false6.i
  %341 = load i32, ptr %r.i, align 4
  %cmp10.i = icmp eq i32 %341, 7
  br i1 %cmp10.i, label %land.lhs.true.i, label %if.end.i

land.lhs.true.i:                                  ; preds = %lor.lhs.false9.i, %lor.lhs.false6.i, %lor.lhs.false.i, %if.else118
  %342 = load i32, ptr %c.i, align 4
  %cmp12.i = icmp ule i32 %342, 2
  br i1 %cmp12.i, label %if.then.i, label %if.end.i

if.then.i:                                        ; preds = %land.lhs.true.i
  %343 = load i32, ptr %c.i, align 4
  store i32 %343, ptr %retval.i, align 4
  br label %CommandDistanceContext.exit

if.end.i:                                         ; preds = %land.lhs.true.i, %lor.lhs.false9.i
  store i32 3, ptr %retval.i, align 4
  br label %CommandDistanceContext.exit

CommandDistanceContext.exit:                      ; preds = %if.end.i, %if.then.i
  %344 = load i32, ptr %retval.i, align 4
  %conv121 = zext i32 %344 to i64
  store i64 %conv121, ptr %context119, align 8
  %345 = load ptr, ptr %distance_enc, align 8
  %346 = load i64, ptr %dist_code, align 8
  %347 = load i64, ptr %context119, align 8
  %348 = load ptr, ptr %mb.addr, align 8
  %distance_context_map122 = getelementptr inbounds %struct.MetaBlockSplit, ptr %348, i32 0, i32 5
  %349 = load ptr, ptr %distance_context_map122, align 8
  %350 = load ptr, ptr %storage_ix.addr, align 8
  %351 = load ptr, ptr %storage.addr, align 8
  call void @StoreSymbolWithContext(ptr noundef %345, i64 noundef %346, i64 noundef %347, ptr noundef %349, ptr noundef %350, ptr noundef %351, i64 noundef 2)
  br label %if.end123

if.end123:                                        ; preds = %CommandDistanceContext.exit, %if.then117
  %352 = load i32, ptr %distnumextra, align 4
  %conv124 = zext i32 %352 to i64
  %353 = load i64, ptr %distextra, align 8
  %354 = load ptr, ptr %storage_ix.addr, align 8
  %355 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !194)
  call void @llvm.experimental.noalias.scope.decl(metadata !197)
  store i64 %conv124, ptr %n_bits.addr.i, align 8, !noalias !199
  store i64 %353, ptr %bits.addr.i, align 8, !noalias !199
  store ptr %354, ptr %pos.addr.i, align 8, !noalias !199
  store ptr %355, ptr %array.addr.i, align 8, !noalias !199
  %356 = load ptr, ptr %array.addr.i, align 8, !noalias !199
  %357 = load ptr, ptr %pos.addr.i, align 8, !noalias !199
  %358 = load i64, ptr %357, align 8
  %shr.i = lshr i64 %358, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %356, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !199
  %359 = load ptr, ptr %p.i, align 8, !noalias !199
  %360 = load i8, ptr %359, align 1
  %conv.i = zext i8 %360 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !199
  %361 = load i64, ptr %bits.addr.i, align 8, !noalias !199
  %362 = load ptr, ptr %pos.addr.i, align 8, !noalias !199
  %363 = load i64, ptr %362, align 8
  %and.i = and i64 %363, 7
  %shl.i = shl i64 %361, %and.i
  %364 = load i64, ptr %v.i, align 8, !noalias !199
  %or.i = or i64 %364, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !199
  %365 = load ptr, ptr %p.i, align 8, !noalias !199
  %366 = load i64, ptr %v.i, align 8, !noalias !199
  store ptr %365, ptr %p.addr.i191, align 8
  store i64 %366, ptr %v.addr.i192, align 8
  %367 = load ptr, ptr %p.addr.i191, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %367, ptr align 8 %v.addr.i192, i64 8, i1 false)
  %368 = load i64, ptr %n_bits.addr.i, align 8, !noalias !199
  %369 = load ptr, ptr %pos.addr.i, align 8, !noalias !199
  %370 = load i64, ptr %369, align 8
  %add.i = add i64 %370, %368
  store i64 %add.i, ptr %369, align 8
  br label %if.end125

if.end125:                                        ; preds = %if.end123, %if.then96
  br label %if.end126

if.end126:                                        ; preds = %if.end125, %if.end92
  br label %for.inc127

for.inc127:                                       ; preds = %if.end126
  %371 = load i64, ptr %i, align 8
  %inc128 = add i64 %371, 1
  store i64 %inc128, ptr %i, align 8
  br label %for.cond49, !llvm.loop !200

for.end129:                                       ; preds = %for.cond49
  %372 = load ptr, ptr %m.addr, align 8
  %373 = load ptr, ptr %distance_enc, align 8
  call void @CleanupBlockEncoder(ptr noundef %372, ptr noundef %373)
  %374 = load ptr, ptr %m.addr, align 8
  %375 = load ptr, ptr %command_enc, align 8
  call void @CleanupBlockEncoder(ptr noundef %374, ptr noundef %375)
  %376 = load ptr, ptr %m.addr, align 8
  %377 = load ptr, ptr %literal_enc, align 8
  call void @CleanupBlockEncoder(ptr noundef %376, ptr noundef %377)
  %378 = load ptr, ptr %m.addr, align 8
  %379 = load ptr, ptr %arena, align 8
  call void @BrotliFree(ptr noundef %378, ptr noundef %379)
  store ptr null, ptr %arena, align 8
  %380 = load i32, ptr %is_last.addr, align 4
  %tobool130 = icmp ne i32 %380, 0
  br i1 %tobool130, label %if.then131, label %if.end132

if.then131:                                       ; preds = %for.end129
  %381 = load ptr, ptr %storage_ix.addr, align 8
  %382 = load ptr, ptr %storage.addr, align 8
  call void @JumpToByteBoundary(ptr noundef %381, ptr noundef %382)
  br label %if.end132

if.end132:                                        ; preds = %if.then131, %for.end129
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @StoreCompressedMetaBlockHeader(i32 noundef %is_final_block, i64 noundef %length, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i62 = alloca ptr, align 8
  %v.addr.i63 = alloca i64, align 8
  %p.addr.i60 = alloca ptr, align 8
  %v.addr.i61 = alloca i64, align 8
  %p.addr.i58 = alloca ptr, align 8
  %v.addr.i59 = alloca i64, align 8
  %p.addr.i56 = alloca ptr, align 8
  %v.addr.i57 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i43 = alloca i64, align 8
  %bits.addr.i44 = alloca i64, align 8
  %pos.addr.i45 = alloca ptr, align 8
  %array.addr.i46 = alloca ptr, align 8
  %p.i47 = alloca ptr, align 8
  %v.i48 = alloca i64, align 8
  %n_bits.addr.i30 = alloca i64, align 8
  %bits.addr.i31 = alloca i64, align 8
  %pos.addr.i32 = alloca ptr, align 8
  %array.addr.i33 = alloca ptr, align 8
  %p.i34 = alloca ptr, align 8
  %v.i35 = alloca i64, align 8
  %n_bits.addr.i17 = alloca i64, align 8
  %bits.addr.i18 = alloca i64, align 8
  %pos.addr.i19 = alloca ptr, align 8
  %array.addr.i20 = alloca ptr, align 8
  %p.i21 = alloca ptr, align 8
  %v.i22 = alloca i64, align 8
  %n_bits.addr.i4 = alloca i64, align 8
  %bits.addr.i5 = alloca i64, align 8
  %pos.addr.i6 = alloca ptr, align 8
  %array.addr.i7 = alloca ptr, align 8
  %p.i8 = alloca ptr, align 8
  %v.i9 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %is_final_block.addr = alloca i32, align 4
  %length.addr = alloca i64, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %lenbits = alloca i64, align 8
  %nlenbits = alloca i64, align 8
  %nibblesbits = alloca i64, align 8
  store i32 %is_final_block, ptr %is_final_block.addr, align 4
  store i64 %length, ptr %length.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load i32, ptr %is_final_block.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = load ptr, ptr %storage_ix.addr, align 8
  %2 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !201)
  call void @llvm.experimental.noalias.scope.decl(metadata !204)
  store i64 1, ptr %n_bits.addr.i43, align 8, !noalias !206
  store i64 %conv, ptr %bits.addr.i44, align 8, !noalias !206
  store ptr %1, ptr %pos.addr.i45, align 8, !noalias !206
  store ptr %2, ptr %array.addr.i46, align 8, !noalias !206
  %3 = load ptr, ptr %array.addr.i46, align 8, !noalias !206
  %4 = load ptr, ptr %pos.addr.i45, align 8, !noalias !206
  %5 = load i64, ptr %4, align 8
  %shr.i49 = lshr i64 %5, 3
  %arrayidx.i50 = getelementptr inbounds i8, ptr %3, i64 %shr.i49
  store ptr %arrayidx.i50, ptr %p.i47, align 8, !noalias !206
  %6 = load ptr, ptr %p.i47, align 8, !noalias !206
  %7 = load i8, ptr %6, align 1
  %conv.i51 = zext i8 %7 to i64
  store i64 %conv.i51, ptr %v.i48, align 8, !noalias !206
  %8 = load i64, ptr %bits.addr.i44, align 8, !noalias !206
  %9 = load ptr, ptr %pos.addr.i45, align 8, !noalias !206
  %10 = load i64, ptr %9, align 8
  %and.i52 = and i64 %10, 7
  %shl.i53 = shl i64 %8, %and.i52
  %11 = load i64, ptr %v.i48, align 8, !noalias !206
  %or.i54 = or i64 %11, %shl.i53
  store i64 %or.i54, ptr %v.i48, align 8, !noalias !206
  %12 = load ptr, ptr %p.i47, align 8, !noalias !206
  %13 = load i64, ptr %v.i48, align 8, !noalias !206
  store ptr %12, ptr %p.addr.i, align 8
  store i64 %13, ptr %v.addr.i, align 8
  %14 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %14, ptr align 8 %v.addr.i, i64 8, i1 false)
  %15 = load i64, ptr %n_bits.addr.i43, align 8, !noalias !206
  %16 = load ptr, ptr %pos.addr.i45, align 8, !noalias !206
  %17 = load i64, ptr %16, align 8
  %add.i55 = add i64 %17, %15
  store i64 %add.i55, ptr %16, align 8
  %18 = load i32, ptr %is_final_block.addr, align 4
  %tobool = icmp ne i32 %18, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %19 = load ptr, ptr %storage_ix.addr, align 8
  %20 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !207)
  call void @llvm.experimental.noalias.scope.decl(metadata !210)
  store i64 1, ptr %n_bits.addr.i30, align 8, !noalias !212
  store i64 0, ptr %bits.addr.i31, align 8, !noalias !212
  store ptr %19, ptr %pos.addr.i32, align 8, !noalias !212
  store ptr %20, ptr %array.addr.i33, align 8, !noalias !212
  %21 = load ptr, ptr %array.addr.i33, align 8, !noalias !212
  %22 = load ptr, ptr %pos.addr.i32, align 8, !noalias !212
  %23 = load i64, ptr %22, align 8
  %shr.i36 = lshr i64 %23, 3
  %arrayidx.i37 = getelementptr inbounds i8, ptr %21, i64 %shr.i36
  store ptr %arrayidx.i37, ptr %p.i34, align 8, !noalias !212
  %24 = load ptr, ptr %p.i34, align 8, !noalias !212
  %25 = load i8, ptr %24, align 1
  %conv.i38 = zext i8 %25 to i64
  store i64 %conv.i38, ptr %v.i35, align 8, !noalias !212
  %26 = load i64, ptr %bits.addr.i31, align 8, !noalias !212
  %27 = load ptr, ptr %pos.addr.i32, align 8, !noalias !212
  %28 = load i64, ptr %27, align 8
  %and.i39 = and i64 %28, 7
  %shl.i40 = shl i64 %26, %and.i39
  %29 = load i64, ptr %v.i35, align 8, !noalias !212
  %or.i41 = or i64 %29, %shl.i40
  store i64 %or.i41, ptr %v.i35, align 8, !noalias !212
  %30 = load ptr, ptr %p.i34, align 8, !noalias !212
  %31 = load i64, ptr %v.i35, align 8, !noalias !212
  store ptr %30, ptr %p.addr.i56, align 8
  store i64 %31, ptr %v.addr.i57, align 8
  %32 = load ptr, ptr %p.addr.i56, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %32, ptr align 8 %v.addr.i57, i64 8, i1 false)
  %33 = load i64, ptr %n_bits.addr.i30, align 8, !noalias !212
  %34 = load ptr, ptr %pos.addr.i32, align 8, !noalias !212
  %35 = load i64, ptr %34, align 8
  %add.i42 = add i64 %35, %33
  store i64 %add.i42, ptr %34, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %36 = load i64, ptr %length.addr, align 8
  call void @BrotliEncodeMlen(i64 noundef %36, ptr noundef %lenbits, ptr noundef %nlenbits, ptr noundef %nibblesbits)
  %37 = load i64, ptr %nibblesbits, align 8
  %38 = load ptr, ptr %storage_ix.addr, align 8
  %39 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !213)
  call void @llvm.experimental.noalias.scope.decl(metadata !216)
  store i64 2, ptr %n_bits.addr.i17, align 8, !noalias !218
  store i64 %37, ptr %bits.addr.i18, align 8, !noalias !218
  store ptr %38, ptr %pos.addr.i19, align 8, !noalias !218
  store ptr %39, ptr %array.addr.i20, align 8, !noalias !218
  %40 = load ptr, ptr %array.addr.i20, align 8, !noalias !218
  %41 = load ptr, ptr %pos.addr.i19, align 8, !noalias !218
  %42 = load i64, ptr %41, align 8
  %shr.i23 = lshr i64 %42, 3
  %arrayidx.i24 = getelementptr inbounds i8, ptr %40, i64 %shr.i23
  store ptr %arrayidx.i24, ptr %p.i21, align 8, !noalias !218
  %43 = load ptr, ptr %p.i21, align 8, !noalias !218
  %44 = load i8, ptr %43, align 1
  %conv.i25 = zext i8 %44 to i64
  store i64 %conv.i25, ptr %v.i22, align 8, !noalias !218
  %45 = load i64, ptr %bits.addr.i18, align 8, !noalias !218
  %46 = load ptr, ptr %pos.addr.i19, align 8, !noalias !218
  %47 = load i64, ptr %46, align 8
  %and.i26 = and i64 %47, 7
  %shl.i27 = shl i64 %45, %and.i26
  %48 = load i64, ptr %v.i22, align 8, !noalias !218
  %or.i28 = or i64 %48, %shl.i27
  store i64 %or.i28, ptr %v.i22, align 8, !noalias !218
  %49 = load ptr, ptr %p.i21, align 8, !noalias !218
  %50 = load i64, ptr %v.i22, align 8, !noalias !218
  store ptr %49, ptr %p.addr.i58, align 8
  store i64 %50, ptr %v.addr.i59, align 8
  %51 = load ptr, ptr %p.addr.i58, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %51, ptr align 8 %v.addr.i59, i64 8, i1 false)
  %52 = load i64, ptr %n_bits.addr.i17, align 8, !noalias !218
  %53 = load ptr, ptr %pos.addr.i19, align 8, !noalias !218
  %54 = load i64, ptr %53, align 8
  %add.i29 = add i64 %54, %52
  store i64 %add.i29, ptr %53, align 8
  %55 = load i64, ptr %nlenbits, align 8
  %56 = load i64, ptr %lenbits, align 8
  %57 = load ptr, ptr %storage_ix.addr, align 8
  %58 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !219)
  call void @llvm.experimental.noalias.scope.decl(metadata !222)
  store i64 %55, ptr %n_bits.addr.i4, align 8, !noalias !224
  store i64 %56, ptr %bits.addr.i5, align 8, !noalias !224
  store ptr %57, ptr %pos.addr.i6, align 8, !noalias !224
  store ptr %58, ptr %array.addr.i7, align 8, !noalias !224
  %59 = load ptr, ptr %array.addr.i7, align 8, !noalias !224
  %60 = load ptr, ptr %pos.addr.i6, align 8, !noalias !224
  %61 = load i64, ptr %60, align 8
  %shr.i10 = lshr i64 %61, 3
  %arrayidx.i11 = getelementptr inbounds i8, ptr %59, i64 %shr.i10
  store ptr %arrayidx.i11, ptr %p.i8, align 8, !noalias !224
  %62 = load ptr, ptr %p.i8, align 8, !noalias !224
  %63 = load i8, ptr %62, align 1
  %conv.i12 = zext i8 %63 to i64
  store i64 %conv.i12, ptr %v.i9, align 8, !noalias !224
  %64 = load i64, ptr %bits.addr.i5, align 8, !noalias !224
  %65 = load ptr, ptr %pos.addr.i6, align 8, !noalias !224
  %66 = load i64, ptr %65, align 8
  %and.i13 = and i64 %66, 7
  %shl.i14 = shl i64 %64, %and.i13
  %67 = load i64, ptr %v.i9, align 8, !noalias !224
  %or.i15 = or i64 %67, %shl.i14
  store i64 %or.i15, ptr %v.i9, align 8, !noalias !224
  %68 = load ptr, ptr %p.i8, align 8, !noalias !224
  %69 = load i64, ptr %v.i9, align 8, !noalias !224
  store ptr %68, ptr %p.addr.i60, align 8
  store i64 %69, ptr %v.addr.i61, align 8
  %70 = load ptr, ptr %p.addr.i60, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %70, ptr align 8 %v.addr.i61, i64 8, i1 false)
  %71 = load i64, ptr %n_bits.addr.i4, align 8, !noalias !224
  %72 = load ptr, ptr %pos.addr.i6, align 8, !noalias !224
  %73 = load i64, ptr %72, align 8
  %add.i16 = add i64 %73, %71
  store i64 %add.i16, ptr %72, align 8
  %74 = load i32, ptr %is_final_block.addr, align 4
  %tobool1 = icmp ne i32 %74, 0
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  %75 = load ptr, ptr %storage_ix.addr, align 8
  %76 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !225)
  call void @llvm.experimental.noalias.scope.decl(metadata !228)
  store i64 1, ptr %n_bits.addr.i, align 8, !noalias !230
  store i64 0, ptr %bits.addr.i, align 8, !noalias !230
  store ptr %75, ptr %pos.addr.i, align 8, !noalias !230
  store ptr %76, ptr %array.addr.i, align 8, !noalias !230
  %77 = load ptr, ptr %array.addr.i, align 8, !noalias !230
  %78 = load ptr, ptr %pos.addr.i, align 8, !noalias !230
  %79 = load i64, ptr %78, align 8
  %shr.i = lshr i64 %79, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %77, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !230
  %80 = load ptr, ptr %p.i, align 8, !noalias !230
  %81 = load i8, ptr %80, align 1
  %conv.i = zext i8 %81 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !230
  %82 = load i64, ptr %bits.addr.i, align 8, !noalias !230
  %83 = load ptr, ptr %pos.addr.i, align 8, !noalias !230
  %84 = load i64, ptr %83, align 8
  %and.i = and i64 %84, 7
  %shl.i = shl i64 %82, %and.i
  %85 = load i64, ptr %v.i, align 8, !noalias !230
  %or.i = or i64 %85, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !230
  %86 = load ptr, ptr %p.i, align 8, !noalias !230
  %87 = load i64, ptr %v.i, align 8, !noalias !230
  store ptr %86, ptr %p.addr.i62, align 8
  store i64 %87, ptr %v.addr.i63, align 8
  %88 = load ptr, ptr %p.addr.i62, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %88, ptr align 8 %v.addr.i63, i64 8, i1 false)
  %89 = load i64, ptr %n_bits.addr.i, align 8, !noalias !230
  %90 = load ptr, ptr %pos.addr.i, align 8, !noalias !230
  %91 = load i64, ptr %90, align 8
  %add.i = add i64 %91, %89
  store i64 %add.i, ptr %90, align 8
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  ret void
}

declare hidden ptr @BrotliAllocate(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind uwtable
define internal void @InitBlockEncoder(ptr noundef %self, i64 noundef %histogram_length, i64 noundef %num_block_types, ptr noundef %block_types, ptr noundef %block_lengths, i64 noundef %num_blocks) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %histogram_length.addr = alloca i64, align 8
  %num_block_types.addr = alloca i64, align 8
  %block_types.addr = alloca ptr, align 8
  %block_lengths.addr = alloca ptr, align 8
  %num_blocks.addr = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store i64 %histogram_length, ptr %histogram_length.addr, align 8
  store i64 %num_block_types, ptr %num_block_types.addr, align 8
  store ptr %block_types, ptr %block_types.addr, align 8
  store ptr %block_lengths, ptr %block_lengths.addr, align 8
  store i64 %num_blocks, ptr %num_blocks.addr, align 8
  %0 = load i64, ptr %histogram_length.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %histogram_length_ = getelementptr inbounds %struct.BlockEncoder, ptr %1, i32 0, i32 0
  store i64 %0, ptr %histogram_length_, align 8
  %2 = load i64, ptr %num_block_types.addr, align 8
  %3 = load ptr, ptr %self.addr, align 8
  %num_block_types_ = getelementptr inbounds %struct.BlockEncoder, ptr %3, i32 0, i32 1
  store i64 %2, ptr %num_block_types_, align 8
  %4 = load ptr, ptr %block_types.addr, align 8
  %5 = load ptr, ptr %self.addr, align 8
  %block_types_ = getelementptr inbounds %struct.BlockEncoder, ptr %5, i32 0, i32 2
  store ptr %4, ptr %block_types_, align 8
  %6 = load ptr, ptr %block_lengths.addr, align 8
  %7 = load ptr, ptr %self.addr, align 8
  %block_lengths_ = getelementptr inbounds %struct.BlockEncoder, ptr %7, i32 0, i32 3
  store ptr %6, ptr %block_lengths_, align 8
  %8 = load i64, ptr %num_blocks.addr, align 8
  %9 = load ptr, ptr %self.addr, align 8
  %num_blocks_ = getelementptr inbounds %struct.BlockEncoder, ptr %9, i32 0, i32 4
  store i64 %8, ptr %num_blocks_, align 8
  %10 = load ptr, ptr %self.addr, align 8
  %block_split_code_ = getelementptr inbounds %struct.BlockEncoder, ptr %10, i32 0, i32 5
  %type_code_calculator = getelementptr inbounds %struct.BlockSplitCode, ptr %block_split_code_, i32 0, i32 0
  call void @InitBlockTypeCodeCalculator(ptr noundef %type_code_calculator)
  %11 = load ptr, ptr %self.addr, align 8
  %block_ix_ = getelementptr inbounds %struct.BlockEncoder, ptr %11, i32 0, i32 6
  store i64 0, ptr %block_ix_, align 8
  %12 = load i64, ptr %num_blocks.addr, align 8
  %cmp = icmp eq i64 %12, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %13 = load ptr, ptr %block_lengths.addr, align 8
  %arrayidx = getelementptr inbounds i32, ptr %13, i64 0
  %14 = load i32, ptr %arrayidx, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %14, %cond.false ]
  %conv = zext i32 %cond to i64
  %15 = load ptr, ptr %self.addr, align 8
  %block_len_ = getelementptr inbounds %struct.BlockEncoder, ptr %15, i32 0, i32 7
  store i64 %conv, ptr %block_len_, align 8
  %16 = load ptr, ptr %self.addr, align 8
  %entropy_ix_ = getelementptr inbounds %struct.BlockEncoder, ptr %16, i32 0, i32 8
  store i64 0, ptr %entropy_ix_, align 8
  %17 = load ptr, ptr %self.addr, align 8
  %depths_ = getelementptr inbounds %struct.BlockEncoder, ptr %17, i32 0, i32 9
  store ptr null, ptr %depths_, align 8
  %18 = load ptr, ptr %self.addr, align 8
  %bits_ = getelementptr inbounds %struct.BlockEncoder, ptr %18, i32 0, i32 10
  store ptr null, ptr %bits_, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @BuildAndStoreBlockSwitchEntropyCodes(ptr noundef %self, ptr noundef %tree, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %self.addr = alloca ptr, align 8
  %tree.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %tree, ptr %tree.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %block_types_ = getelementptr inbounds %struct.BlockEncoder, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %block_types_, align 8
  %2 = load ptr, ptr %self.addr, align 8
  %block_lengths_ = getelementptr inbounds %struct.BlockEncoder, ptr %2, i32 0, i32 3
  %3 = load ptr, ptr %block_lengths_, align 8
  %4 = load ptr, ptr %self.addr, align 8
  %num_blocks_ = getelementptr inbounds %struct.BlockEncoder, ptr %4, i32 0, i32 4
  %5 = load i64, ptr %num_blocks_, align 8
  %6 = load ptr, ptr %self.addr, align 8
  %num_block_types_ = getelementptr inbounds %struct.BlockEncoder, ptr %6, i32 0, i32 1
  %7 = load i64, ptr %num_block_types_, align 8
  %8 = load ptr, ptr %tree.addr, align 8
  %9 = load ptr, ptr %self.addr, align 8
  %block_split_code_ = getelementptr inbounds %struct.BlockEncoder, ptr %9, i32 0, i32 5
  %10 = load ptr, ptr %storage_ix.addr, align 8
  %11 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreBlockSplitCode(ptr noundef %1, ptr noundef %3, i64 noundef %5, i64 noundef %7, ptr noundef %8, ptr noundef %block_split_code_, ptr noundef %10, ptr noundef %11)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @StoreTrivialContextMap(ptr noundef %arena, i64 noundef %num_types, i64 noundef %context_bits, ptr noundef %tree, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i106 = alloca ptr, align 8
  %v.addr.i107 = alloca i64, align 8
  %p.addr.i104 = alloca ptr, align 8
  %v.addr.i105 = alloca i64, align 8
  %p.addr.i102 = alloca ptr, align 8
  %v.addr.i103 = alloca i64, align 8
  %p.addr.i100 = alloca ptr, align 8
  %v.addr.i101 = alloca i64, align 8
  %p.addr.i98 = alloca ptr, align 8
  %v.addr.i99 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i85 = alloca i64, align 8
  %bits.addr.i86 = alloca i64, align 8
  %pos.addr.i87 = alloca ptr, align 8
  %array.addr.i88 = alloca ptr, align 8
  %p.i89 = alloca ptr, align 8
  %v.i90 = alloca i64, align 8
  %n_bits.addr.i72 = alloca i64, align 8
  %bits.addr.i73 = alloca i64, align 8
  %pos.addr.i74 = alloca ptr, align 8
  %array.addr.i75 = alloca ptr, align 8
  %p.i76 = alloca ptr, align 8
  %v.i77 = alloca i64, align 8
  %n_bits.addr.i59 = alloca i64, align 8
  %bits.addr.i60 = alloca i64, align 8
  %pos.addr.i61 = alloca ptr, align 8
  %array.addr.i62 = alloca ptr, align 8
  %p.i63 = alloca ptr, align 8
  %v.i64 = alloca i64, align 8
  %n_bits.addr.i46 = alloca i64, align 8
  %bits.addr.i47 = alloca i64, align 8
  %pos.addr.i48 = alloca ptr, align 8
  %array.addr.i49 = alloca ptr, align 8
  %p.i50 = alloca ptr, align 8
  %v.i51 = alloca i64, align 8
  %n_bits.addr.i33 = alloca i64, align 8
  %bits.addr.i34 = alloca i64, align 8
  %pos.addr.i35 = alloca ptr, align 8
  %array.addr.i36 = alloca ptr, align 8
  %p.i37 = alloca ptr, align 8
  %v.i38 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %arena.addr = alloca ptr, align 8
  %num_types.addr = alloca i64, align 8
  %context_bits.addr = alloca i64, align 8
  %tree.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %repeat_code = alloca i64, align 8
  %repeat_bits = alloca i64, align 8
  %alphabet_size = alloca i64, align 8
  %histogram = alloca ptr, align 8
  %depths = alloca ptr, align 8
  %bits = alloca ptr, align 8
  %i = alloca i64, align 8
  %code = alloca i64, align 8
  store ptr %arena, ptr %arena.addr, align 8
  store i64 %num_types, ptr %num_types.addr, align 8
  store i64 %context_bits, ptr %context_bits.addr, align 8
  store ptr %tree, ptr %tree.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load i64, ptr %num_types.addr, align 8
  %sub = sub i64 %0, 1
  %1 = load ptr, ptr %storage_ix.addr, align 8
  %2 = load ptr, ptr %storage.addr, align 8
  call void @StoreVarLenUint8(i64 noundef %sub, ptr noundef %1, ptr noundef %2)
  %3 = load i64, ptr %num_types.addr, align 8
  %cmp = icmp ugt i64 %3, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i64, ptr %context_bits.addr, align 8
  %sub1 = sub i64 %4, 1
  store i64 %sub1, ptr %repeat_code, align 8
  %5 = load i64, ptr %repeat_code, align 8
  %sh_prom = trunc i64 %5 to i32
  %shl = shl i32 1, %sh_prom
  %sub2 = sub i32 %shl, 1
  %conv = zext i32 %sub2 to i64
  store i64 %conv, ptr %repeat_bits, align 8
  %6 = load i64, ptr %num_types.addr, align 8
  %7 = load i64, ptr %repeat_code, align 8
  %add = add i64 %6, %7
  store i64 %add, ptr %alphabet_size, align 8
  %8 = load ptr, ptr %arena.addr, align 8
  %histogram3 = getelementptr inbounds %struct.EncodeContextMapArena, ptr %8, i32 0, i32 0
  %arraydecay = getelementptr inbounds [272 x i32], ptr %histogram3, i64 0, i64 0
  store ptr %arraydecay, ptr %histogram, align 8
  %9 = load ptr, ptr %arena.addr, align 8
  %depths4 = getelementptr inbounds %struct.EncodeContextMapArena, ptr %9, i32 0, i32 1
  %arraydecay5 = getelementptr inbounds [272 x i8], ptr %depths4, i64 0, i64 0
  store ptr %arraydecay5, ptr %depths, align 8
  %10 = load ptr, ptr %arena.addr, align 8
  %bits6 = getelementptr inbounds %struct.EncodeContextMapArena, ptr %10, i32 0, i32 2
  %arraydecay7 = getelementptr inbounds [272 x i16], ptr %bits6, i64 0, i64 0
  store ptr %arraydecay7, ptr %bits, align 8
  %11 = load ptr, ptr %histogram, align 8
  %12 = load i64, ptr %alphabet_size, align 8
  %mul = mul i64 %12, 4
  call void @llvm.memset.p0.i64(ptr align 4 %11, i8 0, i64 %mul, i1 false)
  %13 = load ptr, ptr %storage_ix.addr, align 8
  %14 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !231)
  call void @llvm.experimental.noalias.scope.decl(metadata !234)
  store i64 1, ptr %n_bits.addr.i85, align 8, !noalias !236
  store i64 1, ptr %bits.addr.i86, align 8, !noalias !236
  store ptr %13, ptr %pos.addr.i87, align 8, !noalias !236
  store ptr %14, ptr %array.addr.i88, align 8, !noalias !236
  %15 = load ptr, ptr %array.addr.i88, align 8, !noalias !236
  %16 = load ptr, ptr %pos.addr.i87, align 8, !noalias !236
  %17 = load i64, ptr %16, align 8
  %shr.i91 = lshr i64 %17, 3
  %arrayidx.i92 = getelementptr inbounds i8, ptr %15, i64 %shr.i91
  store ptr %arrayidx.i92, ptr %p.i89, align 8, !noalias !236
  %18 = load ptr, ptr %p.i89, align 8, !noalias !236
  %19 = load i8, ptr %18, align 1
  %conv.i93 = zext i8 %19 to i64
  store i64 %conv.i93, ptr %v.i90, align 8, !noalias !236
  %20 = load i64, ptr %bits.addr.i86, align 8, !noalias !236
  %21 = load ptr, ptr %pos.addr.i87, align 8, !noalias !236
  %22 = load i64, ptr %21, align 8
  %and.i94 = and i64 %22, 7
  %shl.i95 = shl i64 %20, %and.i94
  %23 = load i64, ptr %v.i90, align 8, !noalias !236
  %or.i96 = or i64 %23, %shl.i95
  store i64 %or.i96, ptr %v.i90, align 8, !noalias !236
  %24 = load ptr, ptr %p.i89, align 8, !noalias !236
  %25 = load i64, ptr %v.i90, align 8, !noalias !236
  store ptr %24, ptr %p.addr.i, align 8
  store i64 %25, ptr %v.addr.i, align 8
  %26 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %26, ptr align 8 %v.addr.i, i64 8, i1 false)
  %27 = load i64, ptr %n_bits.addr.i85, align 8, !noalias !236
  %28 = load ptr, ptr %pos.addr.i87, align 8, !noalias !236
  %29 = load i64, ptr %28, align 8
  %add.i97 = add i64 %29, %27
  store i64 %add.i97, ptr %28, align 8
  %30 = load i64, ptr %repeat_code, align 8
  %sub8 = sub i64 %30, 1
  %31 = load ptr, ptr %storage_ix.addr, align 8
  %32 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !237)
  call void @llvm.experimental.noalias.scope.decl(metadata !240)
  store i64 4, ptr %n_bits.addr.i72, align 8, !noalias !242
  store i64 %sub8, ptr %bits.addr.i73, align 8, !noalias !242
  store ptr %31, ptr %pos.addr.i74, align 8, !noalias !242
  store ptr %32, ptr %array.addr.i75, align 8, !noalias !242
  %33 = load ptr, ptr %array.addr.i75, align 8, !noalias !242
  %34 = load ptr, ptr %pos.addr.i74, align 8, !noalias !242
  %35 = load i64, ptr %34, align 8
  %shr.i78 = lshr i64 %35, 3
  %arrayidx.i79 = getelementptr inbounds i8, ptr %33, i64 %shr.i78
  store ptr %arrayidx.i79, ptr %p.i76, align 8, !noalias !242
  %36 = load ptr, ptr %p.i76, align 8, !noalias !242
  %37 = load i8, ptr %36, align 1
  %conv.i80 = zext i8 %37 to i64
  store i64 %conv.i80, ptr %v.i77, align 8, !noalias !242
  %38 = load i64, ptr %bits.addr.i73, align 8, !noalias !242
  %39 = load ptr, ptr %pos.addr.i74, align 8, !noalias !242
  %40 = load i64, ptr %39, align 8
  %and.i81 = and i64 %40, 7
  %shl.i82 = shl i64 %38, %and.i81
  %41 = load i64, ptr %v.i77, align 8, !noalias !242
  %or.i83 = or i64 %41, %shl.i82
  store i64 %or.i83, ptr %v.i77, align 8, !noalias !242
  %42 = load ptr, ptr %p.i76, align 8, !noalias !242
  %43 = load i64, ptr %v.i77, align 8, !noalias !242
  store ptr %42, ptr %p.addr.i98, align 8
  store i64 %43, ptr %v.addr.i99, align 8
  %44 = load ptr, ptr %p.addr.i98, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %44, ptr align 8 %v.addr.i99, i64 8, i1 false)
  %45 = load i64, ptr %n_bits.addr.i72, align 8, !noalias !242
  %46 = load ptr, ptr %pos.addr.i74, align 8, !noalias !242
  %47 = load i64, ptr %46, align 8
  %add.i84 = add i64 %47, %45
  store i64 %add.i84, ptr %46, align 8
  %48 = load i64, ptr %num_types.addr, align 8
  %conv9 = trunc i64 %48 to i32
  %49 = load ptr, ptr %histogram, align 8
  %50 = load i64, ptr %repeat_code, align 8
  %arrayidx = getelementptr inbounds i32, ptr %49, i64 %50
  store i32 %conv9, ptr %arrayidx, align 4
  %51 = load ptr, ptr %histogram, align 8
  %arrayidx10 = getelementptr inbounds i32, ptr %51, i64 0
  store i32 1, ptr %arrayidx10, align 4
  %52 = load i64, ptr %context_bits.addr, align 8
  store i64 %52, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %53 = load i64, ptr %i, align 8
  %54 = load i64, ptr %alphabet_size, align 8
  %cmp11 = icmp ult i64 %53, %54
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %55 = load ptr, ptr %histogram, align 8
  %56 = load i64, ptr %i, align 8
  %arrayidx13 = getelementptr inbounds i32, ptr %55, i64 %56
  store i32 1, ptr %arrayidx13, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %57 = load i64, ptr %i, align 8
  %inc = add i64 %57, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !243

for.end:                                          ; preds = %for.cond
  %58 = load ptr, ptr %histogram, align 8
  %59 = load i64, ptr %alphabet_size, align 8
  %60 = load i64, ptr %alphabet_size, align 8
  %61 = load ptr, ptr %tree.addr, align 8
  %62 = load ptr, ptr %depths, align 8
  %63 = load ptr, ptr %bits, align 8
  %64 = load ptr, ptr %storage_ix.addr, align 8
  %65 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreHuffmanTree(ptr noundef %58, i64 noundef %59, i64 noundef %60, ptr noundef %61, ptr noundef %62, ptr noundef %63, ptr noundef %64, ptr noundef %65)
  store i64 0, ptr %i, align 8
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc30, %for.end
  %66 = load i64, ptr %i, align 8
  %67 = load i64, ptr %num_types.addr, align 8
  %cmp15 = icmp ult i64 %66, %67
  br i1 %cmp15, label %for.body17, label %for.end32

for.body17:                                       ; preds = %for.cond14
  %68 = load i64, ptr %i, align 8
  %cmp18 = icmp eq i64 %68, 0
  br i1 %cmp18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body17
  br label %cond.end

cond.false:                                       ; preds = %for.body17
  %69 = load i64, ptr %i, align 8
  %70 = load i64, ptr %context_bits.addr, align 8
  %add20 = add i64 %69, %70
  %sub21 = sub i64 %add20, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 0, %cond.true ], [ %sub21, %cond.false ]
  store i64 %cond, ptr %code, align 8
  %71 = load ptr, ptr %depths, align 8
  %72 = load i64, ptr %code, align 8
  %arrayidx22 = getelementptr inbounds i8, ptr %71, i64 %72
  %73 = load i8, ptr %arrayidx22, align 1
  %conv23 = zext i8 %73 to i64
  %74 = load ptr, ptr %bits, align 8
  %75 = load i64, ptr %code, align 8
  %arrayidx24 = getelementptr inbounds i16, ptr %74, i64 %75
  %76 = load i16, ptr %arrayidx24, align 2
  %conv25 = zext i16 %76 to i64
  %77 = load ptr, ptr %storage_ix.addr, align 8
  %78 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !244)
  call void @llvm.experimental.noalias.scope.decl(metadata !247)
  store i64 %conv23, ptr %n_bits.addr.i59, align 8, !noalias !249
  store i64 %conv25, ptr %bits.addr.i60, align 8, !noalias !249
  store ptr %77, ptr %pos.addr.i61, align 8, !noalias !249
  store ptr %78, ptr %array.addr.i62, align 8, !noalias !249
  %79 = load ptr, ptr %array.addr.i62, align 8, !noalias !249
  %80 = load ptr, ptr %pos.addr.i61, align 8, !noalias !249
  %81 = load i64, ptr %80, align 8
  %shr.i65 = lshr i64 %81, 3
  %arrayidx.i66 = getelementptr inbounds i8, ptr %79, i64 %shr.i65
  store ptr %arrayidx.i66, ptr %p.i63, align 8, !noalias !249
  %82 = load ptr, ptr %p.i63, align 8, !noalias !249
  %83 = load i8, ptr %82, align 1
  %conv.i67 = zext i8 %83 to i64
  store i64 %conv.i67, ptr %v.i64, align 8, !noalias !249
  %84 = load i64, ptr %bits.addr.i60, align 8, !noalias !249
  %85 = load ptr, ptr %pos.addr.i61, align 8, !noalias !249
  %86 = load i64, ptr %85, align 8
  %and.i68 = and i64 %86, 7
  %shl.i69 = shl i64 %84, %and.i68
  %87 = load i64, ptr %v.i64, align 8, !noalias !249
  %or.i70 = or i64 %87, %shl.i69
  store i64 %or.i70, ptr %v.i64, align 8, !noalias !249
  %88 = load ptr, ptr %p.i63, align 8, !noalias !249
  %89 = load i64, ptr %v.i64, align 8, !noalias !249
  store ptr %88, ptr %p.addr.i100, align 8
  store i64 %89, ptr %v.addr.i101, align 8
  %90 = load ptr, ptr %p.addr.i100, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %90, ptr align 8 %v.addr.i101, i64 8, i1 false)
  %91 = load i64, ptr %n_bits.addr.i59, align 8, !noalias !249
  %92 = load ptr, ptr %pos.addr.i61, align 8, !noalias !249
  %93 = load i64, ptr %92, align 8
  %add.i71 = add i64 %93, %91
  store i64 %add.i71, ptr %92, align 8
  %94 = load ptr, ptr %depths, align 8
  %95 = load i64, ptr %repeat_code, align 8
  %arrayidx26 = getelementptr inbounds i8, ptr %94, i64 %95
  %96 = load i8, ptr %arrayidx26, align 1
  %conv27 = zext i8 %96 to i64
  %97 = load ptr, ptr %bits, align 8
  %98 = load i64, ptr %repeat_code, align 8
  %arrayidx28 = getelementptr inbounds i16, ptr %97, i64 %98
  %99 = load i16, ptr %arrayidx28, align 2
  %conv29 = zext i16 %99 to i64
  %100 = load ptr, ptr %storage_ix.addr, align 8
  %101 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !250)
  call void @llvm.experimental.noalias.scope.decl(metadata !253)
  store i64 %conv27, ptr %n_bits.addr.i46, align 8, !noalias !255
  store i64 %conv29, ptr %bits.addr.i47, align 8, !noalias !255
  store ptr %100, ptr %pos.addr.i48, align 8, !noalias !255
  store ptr %101, ptr %array.addr.i49, align 8, !noalias !255
  %102 = load ptr, ptr %array.addr.i49, align 8, !noalias !255
  %103 = load ptr, ptr %pos.addr.i48, align 8, !noalias !255
  %104 = load i64, ptr %103, align 8
  %shr.i52 = lshr i64 %104, 3
  %arrayidx.i53 = getelementptr inbounds i8, ptr %102, i64 %shr.i52
  store ptr %arrayidx.i53, ptr %p.i50, align 8, !noalias !255
  %105 = load ptr, ptr %p.i50, align 8, !noalias !255
  %106 = load i8, ptr %105, align 1
  %conv.i54 = zext i8 %106 to i64
  store i64 %conv.i54, ptr %v.i51, align 8, !noalias !255
  %107 = load i64, ptr %bits.addr.i47, align 8, !noalias !255
  %108 = load ptr, ptr %pos.addr.i48, align 8, !noalias !255
  %109 = load i64, ptr %108, align 8
  %and.i55 = and i64 %109, 7
  %shl.i56 = shl i64 %107, %and.i55
  %110 = load i64, ptr %v.i51, align 8, !noalias !255
  %or.i57 = or i64 %110, %shl.i56
  store i64 %or.i57, ptr %v.i51, align 8, !noalias !255
  %111 = load ptr, ptr %p.i50, align 8, !noalias !255
  %112 = load i64, ptr %v.i51, align 8, !noalias !255
  store ptr %111, ptr %p.addr.i102, align 8
  store i64 %112, ptr %v.addr.i103, align 8
  %113 = load ptr, ptr %p.addr.i102, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %113, ptr align 8 %v.addr.i103, i64 8, i1 false)
  %114 = load i64, ptr %n_bits.addr.i46, align 8, !noalias !255
  %115 = load ptr, ptr %pos.addr.i48, align 8, !noalias !255
  %116 = load i64, ptr %115, align 8
  %add.i58 = add i64 %116, %114
  store i64 %add.i58, ptr %115, align 8
  %117 = load i64, ptr %repeat_code, align 8
  %118 = load i64, ptr %repeat_bits, align 8
  %119 = load ptr, ptr %storage_ix.addr, align 8
  %120 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !256)
  call void @llvm.experimental.noalias.scope.decl(metadata !259)
  store i64 %117, ptr %n_bits.addr.i33, align 8, !noalias !261
  store i64 %118, ptr %bits.addr.i34, align 8, !noalias !261
  store ptr %119, ptr %pos.addr.i35, align 8, !noalias !261
  store ptr %120, ptr %array.addr.i36, align 8, !noalias !261
  %121 = load ptr, ptr %array.addr.i36, align 8, !noalias !261
  %122 = load ptr, ptr %pos.addr.i35, align 8, !noalias !261
  %123 = load i64, ptr %122, align 8
  %shr.i39 = lshr i64 %123, 3
  %arrayidx.i40 = getelementptr inbounds i8, ptr %121, i64 %shr.i39
  store ptr %arrayidx.i40, ptr %p.i37, align 8, !noalias !261
  %124 = load ptr, ptr %p.i37, align 8, !noalias !261
  %125 = load i8, ptr %124, align 1
  %conv.i41 = zext i8 %125 to i64
  store i64 %conv.i41, ptr %v.i38, align 8, !noalias !261
  %126 = load i64, ptr %bits.addr.i34, align 8, !noalias !261
  %127 = load ptr, ptr %pos.addr.i35, align 8, !noalias !261
  %128 = load i64, ptr %127, align 8
  %and.i42 = and i64 %128, 7
  %shl.i43 = shl i64 %126, %and.i42
  %129 = load i64, ptr %v.i38, align 8, !noalias !261
  %or.i44 = or i64 %129, %shl.i43
  store i64 %or.i44, ptr %v.i38, align 8, !noalias !261
  %130 = load ptr, ptr %p.i37, align 8, !noalias !261
  %131 = load i64, ptr %v.i38, align 8, !noalias !261
  store ptr %130, ptr %p.addr.i104, align 8
  store i64 %131, ptr %v.addr.i105, align 8
  %132 = load ptr, ptr %p.addr.i104, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %132, ptr align 8 %v.addr.i105, i64 8, i1 false)
  %133 = load i64, ptr %n_bits.addr.i33, align 8, !noalias !261
  %134 = load ptr, ptr %pos.addr.i35, align 8, !noalias !261
  %135 = load i64, ptr %134, align 8
  %add.i45 = add i64 %135, %133
  store i64 %add.i45, ptr %134, align 8
  br label %for.inc30

for.inc30:                                        ; preds = %cond.end
  %136 = load i64, ptr %i, align 8
  %inc31 = add i64 %136, 1
  store i64 %inc31, ptr %i, align 8
  br label %for.cond14, !llvm.loop !262

for.end32:                                        ; preds = %for.cond14
  %137 = load ptr, ptr %storage_ix.addr, align 8
  %138 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !263)
  call void @llvm.experimental.noalias.scope.decl(metadata !266)
  store i64 1, ptr %n_bits.addr.i, align 8, !noalias !268
  store i64 1, ptr %bits.addr.i, align 8, !noalias !268
  store ptr %137, ptr %pos.addr.i, align 8, !noalias !268
  store ptr %138, ptr %array.addr.i, align 8, !noalias !268
  %139 = load ptr, ptr %array.addr.i, align 8, !noalias !268
  %140 = load ptr, ptr %pos.addr.i, align 8, !noalias !268
  %141 = load i64, ptr %140, align 8
  %shr.i = lshr i64 %141, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %139, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !268
  %142 = load ptr, ptr %p.i, align 8, !noalias !268
  %143 = load i8, ptr %142, align 1
  %conv.i = zext i8 %143 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !268
  %144 = load i64, ptr %bits.addr.i, align 8, !noalias !268
  %145 = load ptr, ptr %pos.addr.i, align 8, !noalias !268
  %146 = load i64, ptr %145, align 8
  %and.i = and i64 %146, 7
  %shl.i = shl i64 %144, %and.i
  %147 = load i64, ptr %v.i, align 8, !noalias !268
  %or.i = or i64 %147, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !268
  %148 = load ptr, ptr %p.i, align 8, !noalias !268
  %149 = load i64, ptr %v.i, align 8, !noalias !268
  store ptr %148, ptr %p.addr.i106, align 8
  store i64 %149, ptr %v.addr.i107, align 8
  %150 = load ptr, ptr %p.addr.i106, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %150, ptr align 8 %v.addr.i107, i64 8, i1 false)
  %151 = load i64, ptr %n_bits.addr.i, align 8, !noalias !268
  %152 = load ptr, ptr %pos.addr.i, align 8, !noalias !268
  %153 = load i64, ptr %152, align 8
  %add.i = add i64 %153, %151
  store i64 %add.i, ptr %152, align 8
  br label %if.end

if.end:                                           ; preds = %for.end32, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @EncodeContextMap(ptr noundef %m, ptr noundef %arena, ptr noundef %context_map, i64 noundef %context_map_size, i64 noundef %num_clusters, ptr noundef %tree, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i102 = alloca ptr, align 8
  %v.addr.i103 = alloca i64, align 8
  %p.addr.i100 = alloca ptr, align 8
  %v.addr.i101 = alloca i64, align 8
  %p.addr.i98 = alloca ptr, align 8
  %v.addr.i99 = alloca i64, align 8
  %p.addr.i96 = alloca ptr, align 8
  %v.addr.i97 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i83 = alloca i64, align 8
  %bits.addr.i84 = alloca i64, align 8
  %pos.addr.i85 = alloca ptr, align 8
  %array.addr.i86 = alloca ptr, align 8
  %p.i87 = alloca ptr, align 8
  %v.i88 = alloca i64, align 8
  %n_bits.addr.i70 = alloca i64, align 8
  %bits.addr.i71 = alloca i64, align 8
  %pos.addr.i72 = alloca ptr, align 8
  %array.addr.i73 = alloca ptr, align 8
  %p.i74 = alloca ptr, align 8
  %v.i75 = alloca i64, align 8
  %n_bits.addr.i57 = alloca i64, align 8
  %bits.addr.i58 = alloca i64, align 8
  %pos.addr.i59 = alloca ptr, align 8
  %array.addr.i60 = alloca ptr, align 8
  %p.i61 = alloca ptr, align 8
  %v.i62 = alloca i64, align 8
  %n_bits.addr.i44 = alloca i64, align 8
  %bits.addr.i45 = alloca i64, align 8
  %pos.addr.i46 = alloca ptr, align 8
  %array.addr.i47 = alloca ptr, align 8
  %p.i48 = alloca ptr, align 8
  %v.i49 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %m.addr = alloca ptr, align 8
  %arena.addr = alloca ptr, align 8
  %context_map.addr = alloca ptr, align 8
  %context_map_size.addr = alloca i64, align 8
  %num_clusters.addr = alloca i64, align 8
  %tree.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %rle_symbols = alloca ptr, align 8
  %max_run_length_prefix = alloca i32, align 4
  %num_rle_symbols = alloca i64, align 8
  %histogram = alloca ptr, align 8
  %depths = alloca ptr, align 8
  %bits = alloca ptr, align 8
  %use_rle = alloca i32, align 4
  %rle_symbol = alloca i32, align 4
  %extra_bits_val = alloca i32, align 4
  store ptr %m, ptr %m.addr, align 8
  store ptr %arena, ptr %arena.addr, align 8
  store ptr %context_map, ptr %context_map.addr, align 8
  store i64 %context_map_size, ptr %context_map_size.addr, align 8
  store i64 %num_clusters, ptr %num_clusters.addr, align 8
  store ptr %tree, ptr %tree.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  store i32 6, ptr %max_run_length_prefix, align 4
  store i64 0, ptr %num_rle_symbols, align 8
  %0 = load ptr, ptr %arena.addr, align 8
  %histogram1 = getelementptr inbounds %struct.EncodeContextMapArena, ptr %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [272 x i32], ptr %histogram1, i64 0, i64 0
  store ptr %arraydecay, ptr %histogram, align 8
  %1 = load ptr, ptr %arena.addr, align 8
  %depths2 = getelementptr inbounds %struct.EncodeContextMapArena, ptr %1, i32 0, i32 1
  %arraydecay3 = getelementptr inbounds [272 x i8], ptr %depths2, i64 0, i64 0
  store ptr %arraydecay3, ptr %depths, align 8
  %2 = load ptr, ptr %arena.addr, align 8
  %bits4 = getelementptr inbounds %struct.EncodeContextMapArena, ptr %2, i32 0, i32 2
  %arraydecay5 = getelementptr inbounds [272 x i16], ptr %bits4, i64 0, i64 0
  store ptr %arraydecay5, ptr %bits, align 8
  %3 = load i64, ptr %num_clusters.addr, align 8
  %sub = sub i64 %3, 1
  %4 = load ptr, ptr %storage_ix.addr, align 8
  %5 = load ptr, ptr %storage.addr, align 8
  call void @StoreVarLenUint8(i64 noundef %sub, ptr noundef %4, ptr noundef %5)
  %6 = load i64, ptr %num_clusters.addr, align 8
  %cmp = icmp eq i64 %6, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i64, ptr %context_map_size.addr, align 8
  %cmp6 = icmp ugt i64 %7, 0
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %8 = load ptr, ptr %m.addr, align 8
  %9 = load i64, ptr %context_map_size.addr, align 8
  %mul = mul i64 %9, 4
  %call = call ptr @BrotliAllocate(ptr noundef %8, i64 noundef %mul)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %rle_symbols, align 8
  %10 = load ptr, ptr %context_map.addr, align 8
  %11 = load i64, ptr %context_map_size.addr, align 8
  %12 = load ptr, ptr %rle_symbols, align 8
  call void @MoveToFrontTransform(ptr noundef %10, i64 noundef %11, ptr noundef %12)
  %13 = load i64, ptr %context_map_size.addr, align 8
  %14 = load ptr, ptr %rle_symbols, align 8
  call void @RunLengthCodeZeros(i64 noundef %13, ptr noundef %14, ptr noundef %num_rle_symbols, ptr noundef %max_run_length_prefix)
  %15 = load ptr, ptr %histogram, align 8
  call void @llvm.memset.p0.i64(ptr align 4 %15, i8 0, i64 1088, i1 false)
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %16 = load i64, ptr %i, align 8
  %17 = load i64, ptr %num_rle_symbols, align 8
  %cmp7 = icmp ult i64 %16, %17
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load ptr, ptr %histogram, align 8
  %19 = load ptr, ptr %rle_symbols, align 8
  %20 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds i32, ptr %19, i64 %20
  %21 = load i32, ptr %arrayidx, align 4
  %and = and i32 %21, 511
  %idxprom = zext i32 %and to i64
  %arrayidx8 = getelementptr inbounds i32, ptr %18, i64 %idxprom
  %22 = load i32, ptr %arrayidx8, align 4
  %inc = add i32 %22, 1
  store i32 %inc, ptr %arrayidx8, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i64, ptr %i, align 8
  %inc9 = add i64 %23, 1
  store i64 %inc9, ptr %i, align 8
  br label %for.cond, !llvm.loop !269

for.end:                                          ; preds = %for.cond
  %24 = load i32, ptr %max_run_length_prefix, align 4
  %cmp10 = icmp ugt i32 %24, 0
  %lnot = xor i1 %cmp10, true
  %lnot11 = xor i1 %lnot, true
  %cond12 = select i1 %lnot11, i32 1, i32 0
  store i32 %cond12, ptr %use_rle, align 4
  %25 = load i32, ptr %use_rle, align 4
  %conv = sext i32 %25 to i64
  %26 = load ptr, ptr %storage_ix.addr, align 8
  %27 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !270)
  call void @llvm.experimental.noalias.scope.decl(metadata !273)
  store i64 1, ptr %n_bits.addr.i83, align 8, !noalias !275
  store i64 %conv, ptr %bits.addr.i84, align 8, !noalias !275
  store ptr %26, ptr %pos.addr.i85, align 8, !noalias !275
  store ptr %27, ptr %array.addr.i86, align 8, !noalias !275
  %28 = load ptr, ptr %array.addr.i86, align 8, !noalias !275
  %29 = load ptr, ptr %pos.addr.i85, align 8, !noalias !275
  %30 = load i64, ptr %29, align 8
  %shr.i89 = lshr i64 %30, 3
  %arrayidx.i90 = getelementptr inbounds i8, ptr %28, i64 %shr.i89
  store ptr %arrayidx.i90, ptr %p.i87, align 8, !noalias !275
  %31 = load ptr, ptr %p.i87, align 8, !noalias !275
  %32 = load i8, ptr %31, align 1
  %conv.i91 = zext i8 %32 to i64
  store i64 %conv.i91, ptr %v.i88, align 8, !noalias !275
  %33 = load i64, ptr %bits.addr.i84, align 8, !noalias !275
  %34 = load ptr, ptr %pos.addr.i85, align 8, !noalias !275
  %35 = load i64, ptr %34, align 8
  %and.i92 = and i64 %35, 7
  %shl.i93 = shl i64 %33, %and.i92
  %36 = load i64, ptr %v.i88, align 8, !noalias !275
  %or.i94 = or i64 %36, %shl.i93
  store i64 %or.i94, ptr %v.i88, align 8, !noalias !275
  %37 = load ptr, ptr %p.i87, align 8, !noalias !275
  %38 = load i64, ptr %v.i88, align 8, !noalias !275
  store ptr %37, ptr %p.addr.i, align 8
  store i64 %38, ptr %v.addr.i, align 8
  %39 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %39, ptr align 8 %v.addr.i, i64 8, i1 false)
  %40 = load i64, ptr %n_bits.addr.i83, align 8, !noalias !275
  %41 = load ptr, ptr %pos.addr.i85, align 8, !noalias !275
  %42 = load i64, ptr %41, align 8
  %add.i95 = add i64 %42, %40
  store i64 %add.i95, ptr %41, align 8
  %43 = load i32, ptr %use_rle, align 4
  %tobool = icmp ne i32 %43, 0
  br i1 %tobool, label %if.then13, label %if.end16

if.then13:                                        ; preds = %for.end
  %44 = load i32, ptr %max_run_length_prefix, align 4
  %sub14 = sub i32 %44, 1
  %conv15 = zext i32 %sub14 to i64
  %45 = load ptr, ptr %storage_ix.addr, align 8
  %46 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !276)
  call void @llvm.experimental.noalias.scope.decl(metadata !279)
  store i64 4, ptr %n_bits.addr.i70, align 8, !noalias !281
  store i64 %conv15, ptr %bits.addr.i71, align 8, !noalias !281
  store ptr %45, ptr %pos.addr.i72, align 8, !noalias !281
  store ptr %46, ptr %array.addr.i73, align 8, !noalias !281
  %47 = load ptr, ptr %array.addr.i73, align 8, !noalias !281
  %48 = load ptr, ptr %pos.addr.i72, align 8, !noalias !281
  %49 = load i64, ptr %48, align 8
  %shr.i76 = lshr i64 %49, 3
  %arrayidx.i77 = getelementptr inbounds i8, ptr %47, i64 %shr.i76
  store ptr %arrayidx.i77, ptr %p.i74, align 8, !noalias !281
  %50 = load ptr, ptr %p.i74, align 8, !noalias !281
  %51 = load i8, ptr %50, align 1
  %conv.i78 = zext i8 %51 to i64
  store i64 %conv.i78, ptr %v.i75, align 8, !noalias !281
  %52 = load i64, ptr %bits.addr.i71, align 8, !noalias !281
  %53 = load ptr, ptr %pos.addr.i72, align 8, !noalias !281
  %54 = load i64, ptr %53, align 8
  %and.i79 = and i64 %54, 7
  %shl.i80 = shl i64 %52, %and.i79
  %55 = load i64, ptr %v.i75, align 8, !noalias !281
  %or.i81 = or i64 %55, %shl.i80
  store i64 %or.i81, ptr %v.i75, align 8, !noalias !281
  %56 = load ptr, ptr %p.i74, align 8, !noalias !281
  %57 = load i64, ptr %v.i75, align 8, !noalias !281
  store ptr %56, ptr %p.addr.i96, align 8
  store i64 %57, ptr %v.addr.i97, align 8
  %58 = load ptr, ptr %p.addr.i96, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %58, ptr align 8 %v.addr.i97, i64 8, i1 false)
  %59 = load i64, ptr %n_bits.addr.i70, align 8, !noalias !281
  %60 = load ptr, ptr %pos.addr.i72, align 8, !noalias !281
  %61 = load i64, ptr %60, align 8
  %add.i82 = add i64 %61, %59
  store i64 %add.i82, ptr %60, align 8
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %for.end
  %62 = load ptr, ptr %histogram, align 8
  %63 = load i64, ptr %num_clusters.addr, align 8
  %64 = load i32, ptr %max_run_length_prefix, align 4
  %conv17 = zext i32 %64 to i64
  %add = add i64 %63, %conv17
  %65 = load i64, ptr %num_clusters.addr, align 8
  %66 = load i32, ptr %max_run_length_prefix, align 4
  %conv18 = zext i32 %66 to i64
  %add19 = add i64 %65, %conv18
  %67 = load ptr, ptr %tree.addr, align 8
  %68 = load ptr, ptr %depths, align 8
  %69 = load ptr, ptr %bits, align 8
  %70 = load ptr, ptr %storage_ix.addr, align 8
  %71 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreHuffmanTree(ptr noundef %62, i64 noundef %add, i64 noundef %add19, ptr noundef %67, ptr noundef %68, ptr noundef %69, ptr noundef %70, ptr noundef %71)
  store i64 0, ptr %i, align 8
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc41, %if.end16
  %72 = load i64, ptr %i, align 8
  %73 = load i64, ptr %num_rle_symbols, align 8
  %cmp21 = icmp ult i64 %72, %73
  br i1 %cmp21, label %for.body23, label %for.end43

for.body23:                                       ; preds = %for.cond20
  %74 = load ptr, ptr %rle_symbols, align 8
  %75 = load i64, ptr %i, align 8
  %arrayidx24 = getelementptr inbounds i32, ptr %74, i64 %75
  %76 = load i32, ptr %arrayidx24, align 4
  %and25 = and i32 %76, 511
  store i32 %and25, ptr %rle_symbol, align 4
  %77 = load ptr, ptr %rle_symbols, align 8
  %78 = load i64, ptr %i, align 8
  %arrayidx26 = getelementptr inbounds i32, ptr %77, i64 %78
  %79 = load i32, ptr %arrayidx26, align 4
  %shr = lshr i32 %79, 9
  store i32 %shr, ptr %extra_bits_val, align 4
  %80 = load ptr, ptr %depths, align 8
  %81 = load i32, ptr %rle_symbol, align 4
  %idxprom27 = zext i32 %81 to i64
  %arrayidx28 = getelementptr inbounds i8, ptr %80, i64 %idxprom27
  %82 = load i8, ptr %arrayidx28, align 1
  %conv29 = zext i8 %82 to i64
  %83 = load ptr, ptr %bits, align 8
  %84 = load i32, ptr %rle_symbol, align 4
  %idxprom30 = zext i32 %84 to i64
  %arrayidx31 = getelementptr inbounds i16, ptr %83, i64 %idxprom30
  %85 = load i16, ptr %arrayidx31, align 2
  %conv32 = zext i16 %85 to i64
  %86 = load ptr, ptr %storage_ix.addr, align 8
  %87 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !282)
  call void @llvm.experimental.noalias.scope.decl(metadata !285)
  store i64 %conv29, ptr %n_bits.addr.i57, align 8, !noalias !287
  store i64 %conv32, ptr %bits.addr.i58, align 8, !noalias !287
  store ptr %86, ptr %pos.addr.i59, align 8, !noalias !287
  store ptr %87, ptr %array.addr.i60, align 8, !noalias !287
  %88 = load ptr, ptr %array.addr.i60, align 8, !noalias !287
  %89 = load ptr, ptr %pos.addr.i59, align 8, !noalias !287
  %90 = load i64, ptr %89, align 8
  %shr.i63 = lshr i64 %90, 3
  %arrayidx.i64 = getelementptr inbounds i8, ptr %88, i64 %shr.i63
  store ptr %arrayidx.i64, ptr %p.i61, align 8, !noalias !287
  %91 = load ptr, ptr %p.i61, align 8, !noalias !287
  %92 = load i8, ptr %91, align 1
  %conv.i65 = zext i8 %92 to i64
  store i64 %conv.i65, ptr %v.i62, align 8, !noalias !287
  %93 = load i64, ptr %bits.addr.i58, align 8, !noalias !287
  %94 = load ptr, ptr %pos.addr.i59, align 8, !noalias !287
  %95 = load i64, ptr %94, align 8
  %and.i66 = and i64 %95, 7
  %shl.i67 = shl i64 %93, %and.i66
  %96 = load i64, ptr %v.i62, align 8, !noalias !287
  %or.i68 = or i64 %96, %shl.i67
  store i64 %or.i68, ptr %v.i62, align 8, !noalias !287
  %97 = load ptr, ptr %p.i61, align 8, !noalias !287
  %98 = load i64, ptr %v.i62, align 8, !noalias !287
  store ptr %97, ptr %p.addr.i98, align 8
  store i64 %98, ptr %v.addr.i99, align 8
  %99 = load ptr, ptr %p.addr.i98, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %99, ptr align 8 %v.addr.i99, i64 8, i1 false)
  %100 = load i64, ptr %n_bits.addr.i57, align 8, !noalias !287
  %101 = load ptr, ptr %pos.addr.i59, align 8, !noalias !287
  %102 = load i64, ptr %101, align 8
  %add.i69 = add i64 %102, %100
  store i64 %add.i69, ptr %101, align 8
  %103 = load i32, ptr %rle_symbol, align 4
  %cmp33 = icmp ugt i32 %103, 0
  br i1 %cmp33, label %land.lhs.true, label %if.end40

land.lhs.true:                                    ; preds = %for.body23
  %104 = load i32, ptr %rle_symbol, align 4
  %105 = load i32, ptr %max_run_length_prefix, align 4
  %cmp35 = icmp ule i32 %104, %105
  br i1 %cmp35, label %if.then37, label %if.end40

if.then37:                                        ; preds = %land.lhs.true
  %106 = load i32, ptr %rle_symbol, align 4
  %conv38 = zext i32 %106 to i64
  %107 = load i32, ptr %extra_bits_val, align 4
  %conv39 = zext i32 %107 to i64
  %108 = load ptr, ptr %storage_ix.addr, align 8
  %109 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !288)
  call void @llvm.experimental.noalias.scope.decl(metadata !291)
  store i64 %conv38, ptr %n_bits.addr.i44, align 8, !noalias !293
  store i64 %conv39, ptr %bits.addr.i45, align 8, !noalias !293
  store ptr %108, ptr %pos.addr.i46, align 8, !noalias !293
  store ptr %109, ptr %array.addr.i47, align 8, !noalias !293
  %110 = load ptr, ptr %array.addr.i47, align 8, !noalias !293
  %111 = load ptr, ptr %pos.addr.i46, align 8, !noalias !293
  %112 = load i64, ptr %111, align 8
  %shr.i50 = lshr i64 %112, 3
  %arrayidx.i51 = getelementptr inbounds i8, ptr %110, i64 %shr.i50
  store ptr %arrayidx.i51, ptr %p.i48, align 8, !noalias !293
  %113 = load ptr, ptr %p.i48, align 8, !noalias !293
  %114 = load i8, ptr %113, align 1
  %conv.i52 = zext i8 %114 to i64
  store i64 %conv.i52, ptr %v.i49, align 8, !noalias !293
  %115 = load i64, ptr %bits.addr.i45, align 8, !noalias !293
  %116 = load ptr, ptr %pos.addr.i46, align 8, !noalias !293
  %117 = load i64, ptr %116, align 8
  %and.i53 = and i64 %117, 7
  %shl.i54 = shl i64 %115, %and.i53
  %118 = load i64, ptr %v.i49, align 8, !noalias !293
  %or.i55 = or i64 %118, %shl.i54
  store i64 %or.i55, ptr %v.i49, align 8, !noalias !293
  %119 = load ptr, ptr %p.i48, align 8, !noalias !293
  %120 = load i64, ptr %v.i49, align 8, !noalias !293
  store ptr %119, ptr %p.addr.i100, align 8
  store i64 %120, ptr %v.addr.i101, align 8
  %121 = load ptr, ptr %p.addr.i100, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %121, ptr align 8 %v.addr.i101, i64 8, i1 false)
  %122 = load i64, ptr %n_bits.addr.i44, align 8, !noalias !293
  %123 = load ptr, ptr %pos.addr.i46, align 8, !noalias !293
  %124 = load i64, ptr %123, align 8
  %add.i56 = add i64 %124, %122
  store i64 %add.i56, ptr %123, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.then37, %land.lhs.true, %for.body23
  br label %for.inc41

for.inc41:                                        ; preds = %if.end40
  %125 = load i64, ptr %i, align 8
  %inc42 = add i64 %125, 1
  store i64 %inc42, ptr %i, align 8
  br label %for.cond20, !llvm.loop !294

for.end43:                                        ; preds = %for.cond20
  %126 = load ptr, ptr %storage_ix.addr, align 8
  %127 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !295)
  call void @llvm.experimental.noalias.scope.decl(metadata !298)
  store i64 1, ptr %n_bits.addr.i, align 8, !noalias !300
  store i64 1, ptr %bits.addr.i, align 8, !noalias !300
  store ptr %126, ptr %pos.addr.i, align 8, !noalias !300
  store ptr %127, ptr %array.addr.i, align 8, !noalias !300
  %128 = load ptr, ptr %array.addr.i, align 8, !noalias !300
  %129 = load ptr, ptr %pos.addr.i, align 8, !noalias !300
  %130 = load i64, ptr %129, align 8
  %shr.i = lshr i64 %130, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %128, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !300
  %131 = load ptr, ptr %p.i, align 8, !noalias !300
  %132 = load i8, ptr %131, align 1
  %conv.i = zext i8 %132 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !300
  %133 = load i64, ptr %bits.addr.i, align 8, !noalias !300
  %134 = load ptr, ptr %pos.addr.i, align 8, !noalias !300
  %135 = load i64, ptr %134, align 8
  %and.i = and i64 %135, 7
  %shl.i = shl i64 %133, %and.i
  %136 = load i64, ptr %v.i, align 8, !noalias !300
  %or.i = or i64 %136, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !300
  %137 = load ptr, ptr %p.i, align 8, !noalias !300
  %138 = load i64, ptr %v.i, align 8, !noalias !300
  store ptr %137, ptr %p.addr.i102, align 8
  store i64 %138, ptr %v.addr.i103, align 8
  %139 = load ptr, ptr %p.addr.i102, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %139, ptr align 8 %v.addr.i103, i64 8, i1 false)
  %140 = load i64, ptr %n_bits.addr.i, align 8, !noalias !300
  %141 = load ptr, ptr %pos.addr.i, align 8, !noalias !300
  %142 = load i64, ptr %141, align 8
  %add.i = add i64 %142, %140
  store i64 %add.i, ptr %141, align 8
  %143 = load ptr, ptr %m.addr, align 8
  %144 = load ptr, ptr %rle_symbols, align 8
  call void @BrotliFree(ptr noundef %143, ptr noundef %144)
  store ptr null, ptr %rle_symbols, align 8
  br label %return

return:                                           ; preds = %for.end43, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @BuildAndStoreEntropyCodesLiteral(ptr noundef %m, ptr noundef %self, ptr noundef %histograms, i64 noundef %histograms_size, i64 noundef %alphabet_size, ptr noundef %tree, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %m.addr = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %histograms.addr = alloca ptr, align 8
  %histograms_size.addr = alloca i64, align 8
  %alphabet_size.addr = alloca i64, align 8
  %tree.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %table_size = alloca i64, align 8
  %i = alloca i64, align 8
  %ix = alloca i64, align 8
  store ptr %m, ptr %m.addr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %histograms, ptr %histograms.addr, align 8
  store i64 %histograms_size, ptr %histograms_size.addr, align 8
  store i64 %alphabet_size, ptr %alphabet_size.addr, align 8
  store ptr %tree, ptr %tree.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load i64, ptr %histograms_size.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %histogram_length_ = getelementptr inbounds %struct.BlockEncoder, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %histogram_length_, align 8
  %mul = mul i64 %0, %2
  store i64 %mul, ptr %table_size, align 8
  %3 = load i64, ptr %table_size, align 8
  %cmp = icmp ugt i64 %3, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %m.addr, align 8
  %5 = load i64, ptr %table_size, align 8
  %mul1 = mul i64 %5, 1
  %call = call ptr @BrotliAllocate(ptr noundef %4, i64 noundef %mul1)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call, %cond.true ], [ null, %cond.false ]
  %6 = load ptr, ptr %self.addr, align 8
  %depths_ = getelementptr inbounds %struct.BlockEncoder, ptr %6, i32 0, i32 9
  store ptr %cond, ptr %depths_, align 8
  %7 = load i64, ptr %table_size, align 8
  %cmp2 = icmp ugt i64 %7, 0
  br i1 %cmp2, label %cond.true3, label %cond.false6

cond.true3:                                       ; preds = %cond.end
  %8 = load ptr, ptr %m.addr, align 8
  %9 = load i64, ptr %table_size, align 8
  %mul4 = mul i64 %9, 2
  %call5 = call ptr @BrotliAllocate(ptr noundef %8, i64 noundef %mul4)
  br label %cond.end7

cond.false6:                                      ; preds = %cond.end
  br label %cond.end7

cond.end7:                                        ; preds = %cond.false6, %cond.true3
  %cond8 = phi ptr [ %call5, %cond.true3 ], [ null, %cond.false6 ]
  %10 = load ptr, ptr %self.addr, align 8
  %bits_ = getelementptr inbounds %struct.BlockEncoder, ptr %10, i32 0, i32 10
  store ptr %cond8, ptr %bits_, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end7
  %11 = load i64, ptr %i, align 8
  %12 = load i64, ptr %histograms_size.addr, align 8
  %cmp9 = icmp ult i64 %11, %12
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i64, ptr %i, align 8
  %14 = load ptr, ptr %self.addr, align 8
  %histogram_length_10 = getelementptr inbounds %struct.BlockEncoder, ptr %14, i32 0, i32 0
  %15 = load i64, ptr %histogram_length_10, align 8
  %mul11 = mul i64 %13, %15
  store i64 %mul11, ptr %ix, align 8
  %16 = load ptr, ptr %histograms.addr, align 8
  %17 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds %struct.HistogramLiteral, ptr %16, i64 %17
  %data_ = getelementptr inbounds %struct.HistogramLiteral, ptr %arrayidx, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [256 x i32], ptr %data_, i64 0, i64 0
  %18 = load ptr, ptr %self.addr, align 8
  %histogram_length_13 = getelementptr inbounds %struct.BlockEncoder, ptr %18, i32 0, i32 0
  %19 = load i64, ptr %histogram_length_13, align 8
  %20 = load i64, ptr %alphabet_size.addr, align 8
  %21 = load ptr, ptr %tree.addr, align 8
  %22 = load ptr, ptr %self.addr, align 8
  %depths_14 = getelementptr inbounds %struct.BlockEncoder, ptr %22, i32 0, i32 9
  %23 = load ptr, ptr %depths_14, align 8
  %24 = load i64, ptr %ix, align 8
  %arrayidx15 = getelementptr inbounds i8, ptr %23, i64 %24
  %25 = load ptr, ptr %self.addr, align 8
  %bits_16 = getelementptr inbounds %struct.BlockEncoder, ptr %25, i32 0, i32 10
  %26 = load ptr, ptr %bits_16, align 8
  %27 = load i64, ptr %ix, align 8
  %arrayidx17 = getelementptr inbounds i16, ptr %26, i64 %27
  %28 = load ptr, ptr %storage_ix.addr, align 8
  %29 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreHuffmanTree(ptr noundef %arrayidx12, i64 noundef %19, i64 noundef %20, ptr noundef %21, ptr noundef %arrayidx15, ptr noundef %arrayidx17, ptr noundef %28, ptr noundef %29)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %30 = load i64, ptr %i, align 8
  %inc = add i64 %30, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !301

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @BuildAndStoreEntropyCodesCommand(ptr noundef %m, ptr noundef %self, ptr noundef %histograms, i64 noundef %histograms_size, i64 noundef %alphabet_size, ptr noundef %tree, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %m.addr = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %histograms.addr = alloca ptr, align 8
  %histograms_size.addr = alloca i64, align 8
  %alphabet_size.addr = alloca i64, align 8
  %tree.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %table_size = alloca i64, align 8
  %i = alloca i64, align 8
  %ix = alloca i64, align 8
  store ptr %m, ptr %m.addr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %histograms, ptr %histograms.addr, align 8
  store i64 %histograms_size, ptr %histograms_size.addr, align 8
  store i64 %alphabet_size, ptr %alphabet_size.addr, align 8
  store ptr %tree, ptr %tree.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load i64, ptr %histograms_size.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %histogram_length_ = getelementptr inbounds %struct.BlockEncoder, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %histogram_length_, align 8
  %mul = mul i64 %0, %2
  store i64 %mul, ptr %table_size, align 8
  %3 = load i64, ptr %table_size, align 8
  %cmp = icmp ugt i64 %3, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %m.addr, align 8
  %5 = load i64, ptr %table_size, align 8
  %mul1 = mul i64 %5, 1
  %call = call ptr @BrotliAllocate(ptr noundef %4, i64 noundef %mul1)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call, %cond.true ], [ null, %cond.false ]
  %6 = load ptr, ptr %self.addr, align 8
  %depths_ = getelementptr inbounds %struct.BlockEncoder, ptr %6, i32 0, i32 9
  store ptr %cond, ptr %depths_, align 8
  %7 = load i64, ptr %table_size, align 8
  %cmp2 = icmp ugt i64 %7, 0
  br i1 %cmp2, label %cond.true3, label %cond.false6

cond.true3:                                       ; preds = %cond.end
  %8 = load ptr, ptr %m.addr, align 8
  %9 = load i64, ptr %table_size, align 8
  %mul4 = mul i64 %9, 2
  %call5 = call ptr @BrotliAllocate(ptr noundef %8, i64 noundef %mul4)
  br label %cond.end7

cond.false6:                                      ; preds = %cond.end
  br label %cond.end7

cond.end7:                                        ; preds = %cond.false6, %cond.true3
  %cond8 = phi ptr [ %call5, %cond.true3 ], [ null, %cond.false6 ]
  %10 = load ptr, ptr %self.addr, align 8
  %bits_ = getelementptr inbounds %struct.BlockEncoder, ptr %10, i32 0, i32 10
  store ptr %cond8, ptr %bits_, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end7
  %11 = load i64, ptr %i, align 8
  %12 = load i64, ptr %histograms_size.addr, align 8
  %cmp9 = icmp ult i64 %11, %12
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i64, ptr %i, align 8
  %14 = load ptr, ptr %self.addr, align 8
  %histogram_length_10 = getelementptr inbounds %struct.BlockEncoder, ptr %14, i32 0, i32 0
  %15 = load i64, ptr %histogram_length_10, align 8
  %mul11 = mul i64 %13, %15
  store i64 %mul11, ptr %ix, align 8
  %16 = load ptr, ptr %histograms.addr, align 8
  %17 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds %struct.HistogramCommand, ptr %16, i64 %17
  %data_ = getelementptr inbounds %struct.HistogramCommand, ptr %arrayidx, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [704 x i32], ptr %data_, i64 0, i64 0
  %18 = load ptr, ptr %self.addr, align 8
  %histogram_length_13 = getelementptr inbounds %struct.BlockEncoder, ptr %18, i32 0, i32 0
  %19 = load i64, ptr %histogram_length_13, align 8
  %20 = load i64, ptr %alphabet_size.addr, align 8
  %21 = load ptr, ptr %tree.addr, align 8
  %22 = load ptr, ptr %self.addr, align 8
  %depths_14 = getelementptr inbounds %struct.BlockEncoder, ptr %22, i32 0, i32 9
  %23 = load ptr, ptr %depths_14, align 8
  %24 = load i64, ptr %ix, align 8
  %arrayidx15 = getelementptr inbounds i8, ptr %23, i64 %24
  %25 = load ptr, ptr %self.addr, align 8
  %bits_16 = getelementptr inbounds %struct.BlockEncoder, ptr %25, i32 0, i32 10
  %26 = load ptr, ptr %bits_16, align 8
  %27 = load i64, ptr %ix, align 8
  %arrayidx17 = getelementptr inbounds i16, ptr %26, i64 %27
  %28 = load ptr, ptr %storage_ix.addr, align 8
  %29 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreHuffmanTree(ptr noundef %arrayidx12, i64 noundef %19, i64 noundef %20, ptr noundef %21, ptr noundef %arrayidx15, ptr noundef %arrayidx17, ptr noundef %28, ptr noundef %29)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %30 = load i64, ptr %i, align 8
  %inc = add i64 %30, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !302

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @BuildAndStoreEntropyCodesDistance(ptr noundef %m, ptr noundef %self, ptr noundef %histograms, i64 noundef %histograms_size, i64 noundef %alphabet_size, ptr noundef %tree, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %m.addr = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  %histograms.addr = alloca ptr, align 8
  %histograms_size.addr = alloca i64, align 8
  %alphabet_size.addr = alloca i64, align 8
  %tree.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %table_size = alloca i64, align 8
  %i = alloca i64, align 8
  %ix = alloca i64, align 8
  store ptr %m, ptr %m.addr, align 8
  store ptr %self, ptr %self.addr, align 8
  store ptr %histograms, ptr %histograms.addr, align 8
  store i64 %histograms_size, ptr %histograms_size.addr, align 8
  store i64 %alphabet_size, ptr %alphabet_size.addr, align 8
  store ptr %tree, ptr %tree.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load i64, ptr %histograms_size.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %histogram_length_ = getelementptr inbounds %struct.BlockEncoder, ptr %1, i32 0, i32 0
  %2 = load i64, ptr %histogram_length_, align 8
  %mul = mul i64 %0, %2
  store i64 %mul, ptr %table_size, align 8
  %3 = load i64, ptr %table_size, align 8
  %cmp = icmp ugt i64 %3, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load ptr, ptr %m.addr, align 8
  %5 = load i64, ptr %table_size, align 8
  %mul1 = mul i64 %5, 1
  %call = call ptr @BrotliAllocate(ptr noundef %4, i64 noundef %mul1)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call, %cond.true ], [ null, %cond.false ]
  %6 = load ptr, ptr %self.addr, align 8
  %depths_ = getelementptr inbounds %struct.BlockEncoder, ptr %6, i32 0, i32 9
  store ptr %cond, ptr %depths_, align 8
  %7 = load i64, ptr %table_size, align 8
  %cmp2 = icmp ugt i64 %7, 0
  br i1 %cmp2, label %cond.true3, label %cond.false6

cond.true3:                                       ; preds = %cond.end
  %8 = load ptr, ptr %m.addr, align 8
  %9 = load i64, ptr %table_size, align 8
  %mul4 = mul i64 %9, 2
  %call5 = call ptr @BrotliAllocate(ptr noundef %8, i64 noundef %mul4)
  br label %cond.end7

cond.false6:                                      ; preds = %cond.end
  br label %cond.end7

cond.end7:                                        ; preds = %cond.false6, %cond.true3
  %cond8 = phi ptr [ %call5, %cond.true3 ], [ null, %cond.false6 ]
  %10 = load ptr, ptr %self.addr, align 8
  %bits_ = getelementptr inbounds %struct.BlockEncoder, ptr %10, i32 0, i32 10
  store ptr %cond8, ptr %bits_, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end7
  %11 = load i64, ptr %i, align 8
  %12 = load i64, ptr %histograms_size.addr, align 8
  %cmp9 = icmp ult i64 %11, %12
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i64, ptr %i, align 8
  %14 = load ptr, ptr %self.addr, align 8
  %histogram_length_10 = getelementptr inbounds %struct.BlockEncoder, ptr %14, i32 0, i32 0
  %15 = load i64, ptr %histogram_length_10, align 8
  %mul11 = mul i64 %13, %15
  store i64 %mul11, ptr %ix, align 8
  %16 = load ptr, ptr %histograms.addr, align 8
  %17 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds %struct.HistogramDistance, ptr %16, i64 %17
  %data_ = getelementptr inbounds %struct.HistogramDistance, ptr %arrayidx, i32 0, i32 0
  %arrayidx12 = getelementptr inbounds [544 x i32], ptr %data_, i64 0, i64 0
  %18 = load ptr, ptr %self.addr, align 8
  %histogram_length_13 = getelementptr inbounds %struct.BlockEncoder, ptr %18, i32 0, i32 0
  %19 = load i64, ptr %histogram_length_13, align 8
  %20 = load i64, ptr %alphabet_size.addr, align 8
  %21 = load ptr, ptr %tree.addr, align 8
  %22 = load ptr, ptr %self.addr, align 8
  %depths_14 = getelementptr inbounds %struct.BlockEncoder, ptr %22, i32 0, i32 9
  %23 = load ptr, ptr %depths_14, align 8
  %24 = load i64, ptr %ix, align 8
  %arrayidx15 = getelementptr inbounds i8, ptr %23, i64 %24
  %25 = load ptr, ptr %self.addr, align 8
  %bits_16 = getelementptr inbounds %struct.BlockEncoder, ptr %25, i32 0, i32 10
  %26 = load ptr, ptr %bits_16, align 8
  %27 = load i64, ptr %ix, align 8
  %arrayidx17 = getelementptr inbounds i16, ptr %26, i64 %27
  %28 = load ptr, ptr %storage_ix.addr, align 8
  %29 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreHuffmanTree(ptr noundef %arrayidx12, i64 noundef %19, i64 noundef %20, ptr noundef %21, ptr noundef %arrayidx15, ptr noundef %arrayidx17, ptr noundef %28, ptr noundef %29)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %30 = load i64, ptr %i, align 8
  %inc = add i64 %30, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !303

for.end:                                          ; preds = %for.cond
  ret void
}

declare hidden void @BrotliFree(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind uwtable
define internal void @StoreSymbol(ptr noundef %self, i64 noundef %symbol, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %len.addr.i.i = alloca i32, align 4
  %code.i.i = alloca i32, align 4
  %len.addr.i = alloca i32, align 4
  %code.addr.i12 = alloca ptr, align 8
  %n_extra.addr.i = alloca ptr, align 8
  %extra.addr.i = alloca ptr, align 8
  %calculator.addr.i.i = alloca ptr, align 8
  %type.addr.i.i = alloca i8, align 1
  %type_code.i.i = alloca i64, align 8
  %p.addr.i37.i = alloca ptr, align 8
  %v.addr.i38.i = alloca i64, align 8
  %p.addr.i35.i = alloca ptr, align 8
  %v.addr.i36.i = alloca i64, align 8
  %p.addr.i.i = alloca ptr, align 8
  %v.addr.i.i = alloca i64, align 8
  %n_bits.addr.i22.i = alloca i64, align 8
  %bits.addr.i23.i = alloca i64, align 8
  %pos.addr.i24.i = alloca ptr, align 8
  %array.addr.i25.i = alloca ptr, align 8
  %p.i26.i = alloca ptr, align 8
  %v.i27.i = alloca i64, align 8
  %n_bits.addr.i9.i = alloca i64, align 8
  %bits.addr.i10.i = alloca i64, align 8
  %pos.addr.i11.i = alloca ptr, align 8
  %array.addr.i12.i = alloca ptr, align 8
  %p.i13.i = alloca ptr, align 8
  %v.i14.i = alloca i64, align 8
  %n_bits.addr.i.i = alloca i64, align 8
  %bits.addr.i.i = alloca i64, align 8
  %pos.addr.i.i = alloca ptr, align 8
  %array.addr.i.i = alloca ptr, align 8
  %p.i.i = alloca ptr, align 8
  %v.i.i = alloca i64, align 8
  %code.addr.i = alloca ptr, align 8
  %block_len.addr.i = alloca i32, align 4
  %block_type.addr.i = alloca i8, align 1
  %is_first_block.addr.i = alloca i32, align 4
  %storage_ix.addr.i = alloca ptr, align 8
  %storage.addr.i = alloca ptr, align 8
  %typecode.i = alloca i64, align 8
  %lencode.i = alloca i64, align 8
  %len_nextra.i = alloca i32, align 4
  %len_extra.i = alloca i32, align 4
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %self.addr = alloca ptr, align 8
  %symbol.addr = alloca i64, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %block_ix = alloca i64, align 8
  %block_len = alloca i32, align 4
  %block_type = alloca i8, align 1
  %ix = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store i64 %symbol, ptr %symbol.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %block_len_ = getelementptr inbounds %struct.BlockEncoder, ptr %0, i32 0, i32 7
  %1 = load i64, ptr %block_len_, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %block_ix_ = getelementptr inbounds %struct.BlockEncoder, ptr %2, i32 0, i32 6
  %3 = load i64, ptr %block_ix_, align 8
  %inc = add i64 %3, 1
  store i64 %inc, ptr %block_ix_, align 8
  store i64 %inc, ptr %block_ix, align 8
  %4 = load ptr, ptr %self.addr, align 8
  %block_lengths_ = getelementptr inbounds %struct.BlockEncoder, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %block_lengths_, align 8
  %6 = load i64, ptr %block_ix, align 8
  %arrayidx = getelementptr inbounds i32, ptr %5, i64 %6
  %7 = load i32, ptr %arrayidx, align 4
  store i32 %7, ptr %block_len, align 4
  %8 = load ptr, ptr %self.addr, align 8
  %block_types_ = getelementptr inbounds %struct.BlockEncoder, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %block_types_, align 8
  %10 = load i64, ptr %block_ix, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %9, i64 %10
  %11 = load i8, ptr %arrayidx1, align 1
  store i8 %11, ptr %block_type, align 1
  %12 = load i32, ptr %block_len, align 4
  %conv = zext i32 %12 to i64
  %13 = load ptr, ptr %self.addr, align 8
  %block_len_2 = getelementptr inbounds %struct.BlockEncoder, ptr %13, i32 0, i32 7
  store i64 %conv, ptr %block_len_2, align 8
  %14 = load i8, ptr %block_type, align 1
  %conv3 = zext i8 %14 to i64
  %15 = load ptr, ptr %self.addr, align 8
  %histogram_length_ = getelementptr inbounds %struct.BlockEncoder, ptr %15, i32 0, i32 0
  %16 = load i64, ptr %histogram_length_, align 8
  %mul = mul i64 %conv3, %16
  %17 = load ptr, ptr %self.addr, align 8
  %entropy_ix_ = getelementptr inbounds %struct.BlockEncoder, ptr %17, i32 0, i32 8
  store i64 %mul, ptr %entropy_ix_, align 8
  %18 = load ptr, ptr %self.addr, align 8
  %block_split_code_ = getelementptr inbounds %struct.BlockEncoder, ptr %18, i32 0, i32 5
  %19 = load i32, ptr %block_len, align 4
  %20 = load i8, ptr %block_type, align 1
  %21 = load ptr, ptr %storage_ix.addr, align 8
  %22 = load ptr, ptr %storage.addr, align 8
  store ptr %block_split_code_, ptr %code.addr.i, align 8
  store i32 %19, ptr %block_len.addr.i, align 4
  store i8 %20, ptr %block_type.addr.i, align 1
  store i32 0, ptr %is_first_block.addr.i, align 4
  store ptr %21, ptr %storage_ix.addr.i, align 8
  store ptr %22, ptr %storage.addr.i, align 8
  %23 = load ptr, ptr %code.addr.i, align 8
  %24 = load i8, ptr %block_type.addr.i, align 1
  store ptr %23, ptr %calculator.addr.i.i, align 8
  store i8 %24, ptr %type.addr.i.i, align 1
  %25 = load i8, ptr %type.addr.i.i, align 1
  %conv.i39.i = zext i8 %25 to i64
  %26 = load ptr, ptr %calculator.addr.i.i, align 8
  %27 = load i64, ptr %26, align 8
  %add.i40.i = add i64 %27, 1
  %cmp.i.i = icmp eq i64 %conv.i39.i, %add.i40.i
  br i1 %cmp.i.i, label %cond.true.i.i, label %cond.false.i.i

cond.true.i.i:                                    ; preds = %if.then
  br label %NextBlockTypeCode.exit.i

cond.false.i.i:                                   ; preds = %if.then
  %28 = load i8, ptr %type.addr.i.i, align 1
  %conv2.i.i = zext i8 %28 to i64
  %29 = load ptr, ptr %calculator.addr.i.i, align 8
  %second_last_type.i.i = getelementptr inbounds %struct.BlockTypeCodeCalculator, ptr %29, i32 0, i32 1
  %30 = load i64, ptr %second_last_type.i.i, align 8
  %cmp3.i.i = icmp eq i64 %conv2.i.i, %30
  br i1 %cmp3.i.i, label %cond.true5.i.i, label %cond.false6.i.i

cond.true5.i.i:                                   ; preds = %cond.false.i.i
  br label %cond.end.i.i

cond.false6.i.i:                                  ; preds = %cond.false.i.i
  %31 = load i8, ptr %type.addr.i.i, align 1
  %conv7.i.i = zext i8 %31 to i32
  %add8.i.i = add i32 %conv7.i.i, 2
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.false6.i.i, %cond.true5.i.i
  %cond.i.i = phi i32 [ 0, %cond.true5.i.i ], [ %add8.i.i, %cond.false6.i.i ]
  br label %NextBlockTypeCode.exit.i

NextBlockTypeCode.exit.i:                         ; preds = %cond.end.i.i, %cond.true.i.i
  %cond10.i.i = phi i32 [ 1, %cond.true.i.i ], [ %cond.i.i, %cond.end.i.i ]
  %conv11.i.i = zext i32 %cond10.i.i to i64
  store i64 %conv11.i.i, ptr %type_code.i.i, align 8
  %32 = load ptr, ptr %calculator.addr.i.i, align 8
  %33 = load i64, ptr %32, align 8
  %34 = load ptr, ptr %calculator.addr.i.i, align 8
  %second_last_type13.i.i = getelementptr inbounds %struct.BlockTypeCodeCalculator, ptr %34, i32 0, i32 1
  store i64 %33, ptr %second_last_type13.i.i, align 8
  %35 = load i8, ptr %type.addr.i.i, align 1
  %conv14.i.i = zext i8 %35 to i64
  %36 = load ptr, ptr %calculator.addr.i.i, align 8
  store i64 %conv14.i.i, ptr %36, align 8
  %37 = load i64, ptr %type_code.i.i, align 8
  store i64 %37, ptr %typecode.i, align 8
  %38 = load i32, ptr %is_first_block.addr.i, align 4
  %tobool.i = icmp ne i32 %38, 0
  br i1 %tobool.i, label %StoreBlockSwitch.exit, label %if.then.i

if.then.i:                                        ; preds = %NextBlockTypeCode.exit.i
  %39 = load ptr, ptr %code.addr.i, align 8
  %type_depths.i = getelementptr inbounds %struct.BlockSplitCode, ptr %39, i32 0, i32 1
  %40 = load i64, ptr %typecode.i, align 8
  %arrayidx.i10 = getelementptr inbounds [258 x i8], ptr %type_depths.i, i64 0, i64 %40
  %41 = load i8, ptr %arrayidx.i10, align 1
  %conv.i11 = zext i8 %41 to i64
  %42 = load ptr, ptr %code.addr.i, align 8
  %type_bits.i = getelementptr inbounds %struct.BlockSplitCode, ptr %42, i32 0, i32 2
  %43 = load i64, ptr %typecode.i, align 8
  %arrayidx1.i = getelementptr inbounds [258 x i16], ptr %type_bits.i, i64 0, i64 %43
  %44 = load i16, ptr %arrayidx1.i, align 2
  %conv2.i = zext i16 %44 to i64
  %45 = load ptr, ptr %storage_ix.addr.i, align 8
  %46 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !304)
  call void @llvm.experimental.noalias.scope.decl(metadata !307)
  store i64 %conv.i11, ptr %n_bits.addr.i22.i, align 8, !noalias !309
  store i64 %conv2.i, ptr %bits.addr.i23.i, align 8, !noalias !309
  store ptr %45, ptr %pos.addr.i24.i, align 8, !noalias !309
  store ptr %46, ptr %array.addr.i25.i, align 8, !noalias !309
  %47 = load ptr, ptr %array.addr.i25.i, align 8, !noalias !309
  %48 = load ptr, ptr %pos.addr.i24.i, align 8, !noalias !309
  %49 = load i64, ptr %48, align 8
  %shr.i28.i = lshr i64 %49, 3
  %arrayidx.i29.i = getelementptr inbounds i8, ptr %47, i64 %shr.i28.i
  store ptr %arrayidx.i29.i, ptr %p.i26.i, align 8, !noalias !309
  %50 = load ptr, ptr %p.i26.i, align 8, !noalias !309
  %51 = load i8, ptr %50, align 1
  %conv.i30.i = zext i8 %51 to i64
  store i64 %conv.i30.i, ptr %v.i27.i, align 8, !noalias !309
  %52 = load i64, ptr %bits.addr.i23.i, align 8, !noalias !309
  %53 = load ptr, ptr %pos.addr.i24.i, align 8, !noalias !309
  %54 = load i64, ptr %53, align 8
  %and.i31.i = and i64 %54, 7
  %shl.i32.i = shl i64 %52, %and.i31.i
  %55 = load i64, ptr %v.i27.i, align 8, !noalias !309
  %or.i33.i = or i64 %55, %shl.i32.i
  store i64 %or.i33.i, ptr %v.i27.i, align 8, !noalias !309
  %56 = load ptr, ptr %p.i26.i, align 8, !noalias !309
  %57 = load i64, ptr %v.i27.i, align 8, !noalias !309
  store ptr %56, ptr %p.addr.i.i, align 8
  store i64 %57, ptr %v.addr.i.i, align 8
  %58 = load ptr, ptr %p.addr.i.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %58, ptr align 8 %v.addr.i.i, i64 8, i1 false)
  %59 = load i64, ptr %n_bits.addr.i22.i, align 8, !noalias !309
  %60 = load ptr, ptr %pos.addr.i24.i, align 8, !noalias !309
  %61 = load i64, ptr %60, align 8
  %add.i34.i = add i64 %61, %59
  store i64 %add.i34.i, ptr %60, align 8
  br label %StoreBlockSwitch.exit

StoreBlockSwitch.exit:                            ; preds = %if.then.i, %NextBlockTypeCode.exit.i
  %62 = load i32, ptr %block_len.addr.i, align 4
  store i32 %62, ptr %len.addr.i, align 4
  store ptr %lencode.i, ptr %code.addr.i12, align 8
  store ptr %len_nextra.i, ptr %n_extra.addr.i, align 8
  store ptr %len_extra.i, ptr %extra.addr.i, align 8
  %63 = load i32, ptr %len.addr.i, align 4
  store i32 %63, ptr %len.addr.i.i, align 4
  %64 = load i32, ptr %len.addr.i.i, align 4
  %cmp.i.i13 = icmp uge i32 %64, 177
  br i1 %cmp.i.i13, label %cond.true.i.i21, label %cond.false.i.i14

cond.true.i.i21:                                  ; preds = %StoreBlockSwitch.exit
  %65 = load i32, ptr %len.addr.i.i, align 4
  %cmp1.i.i = icmp uge i32 %65, 753
  %cond.i.i22 = select i1 %cmp1.i.i, i32 20, i32 14
  br label %cond.end.i.i15

cond.false.i.i14:                                 ; preds = %StoreBlockSwitch.exit
  %66 = load i32, ptr %len.addr.i.i, align 4
  %cmp2.i.i = icmp uge i32 %66, 41
  %cond3.i.i = select i1 %cmp2.i.i, i32 7, i32 0
  br label %cond.end.i.i15

cond.end.i.i15:                                   ; preds = %cond.false.i.i14, %cond.true.i.i21
  %cond4.i.i = phi i32 [ %cond.i.i22, %cond.true.i.i21 ], [ %cond3.i.i, %cond.false.i.i14 ]
  store i32 %cond4.i.i, ptr %code.i.i, align 4
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.body.i.i, %cond.end.i.i15
  %67 = load i32, ptr %code.i.i, align 4
  %cmp5.i.i = icmp ult i32 %67, 25
  br i1 %cmp5.i.i, label %land.rhs.i.i, label %land.end.i.i

land.rhs.i.i:                                     ; preds = %while.cond.i.i
  %68 = load i32, ptr %len.addr.i.i, align 4
  %69 = load i32, ptr %code.i.i, align 4
  %add.i.i18 = add i32 %69, 1
  %idxprom.i.i = zext i32 %add.i.i18 to i64
  %arrayidx.i.i19 = getelementptr inbounds [26 x %struct.BrotliPrefixCodeRange], ptr @_kBrotliPrefixCodeRanges, i64 0, i64 %idxprom.i.i
  %70 = load i16, ptr %arrayidx.i.i19, align 4
  %conv.i.i20 = zext i16 %70 to i32
  %cmp6.i.i = icmp uge i32 %68, %conv.i.i20
  br label %land.end.i.i

land.end.i.i:                                     ; preds = %land.rhs.i.i, %while.cond.i.i
  %71 = phi i1 [ false, %while.cond.i.i ], [ %cmp6.i.i, %land.rhs.i.i ]
  br i1 %71, label %while.body.i.i, label %GetBlockLengthPrefixCode.exit

while.body.i.i:                                   ; preds = %land.end.i.i
  %72 = load i32, ptr %code.i.i, align 4
  %inc.i.i = add i32 %72, 1
  store i32 %inc.i.i, ptr %code.i.i, align 4
  br label %while.cond.i.i, !llvm.loop !310

GetBlockLengthPrefixCode.exit:                    ; preds = %land.end.i.i
  %73 = load i32, ptr %code.i.i, align 4
  %conv.i16 = zext i32 %73 to i64
  %74 = load ptr, ptr %code.addr.i12, align 8
  store i64 %conv.i16, ptr %74, align 8
  %75 = load ptr, ptr %code.addr.i12, align 8
  %76 = load i64, ptr %75, align 8
  %arrayidx.i17 = getelementptr inbounds [26 x %struct.BrotliPrefixCodeRange], ptr @_kBrotliPrefixCodeRanges, i64 0, i64 %76
  %nbits.i = getelementptr inbounds %struct.BrotliPrefixCodeRange, ptr %arrayidx.i17, i32 0, i32 1
  %77 = load i8, ptr %nbits.i, align 2
  %conv1.i = zext i8 %77 to i32
  %78 = load ptr, ptr %n_extra.addr.i, align 8
  store i32 %conv1.i, ptr %78, align 4
  %79 = load i32, ptr %len.addr.i, align 4
  %80 = load ptr, ptr %code.addr.i12, align 8
  %81 = load i64, ptr %80, align 8
  %arrayidx2.i = getelementptr inbounds [26 x %struct.BrotliPrefixCodeRange], ptr @_kBrotliPrefixCodeRanges, i64 0, i64 %81
  %82 = load i16, ptr %arrayidx2.i, align 4
  %conv3.i = zext i16 %82 to i32
  %sub.i = sub i32 %79, %conv3.i
  %83 = load ptr, ptr %extra.addr.i, align 8
  store i32 %sub.i, ptr %83, align 4
  %84 = load ptr, ptr %code.addr.i, align 8
  %length_depths.i = getelementptr inbounds %struct.BlockSplitCode, ptr %84, i32 0, i32 3
  %85 = load i64, ptr %lencode.i, align 8
  %arrayidx3.i = getelementptr inbounds [26 x i8], ptr %length_depths.i, i64 0, i64 %85
  %86 = load i8, ptr %arrayidx3.i, align 1
  %conv4.i = zext i8 %86 to i64
  %87 = load ptr, ptr %code.addr.i, align 8
  %length_bits.i = getelementptr inbounds %struct.BlockSplitCode, ptr %87, i32 0, i32 4
  %88 = load i64, ptr %lencode.i, align 8
  %arrayidx5.i = getelementptr inbounds [26 x i16], ptr %length_bits.i, i64 0, i64 %88
  %89 = load i16, ptr %arrayidx5.i, align 2
  %conv6.i = zext i16 %89 to i64
  %90 = load ptr, ptr %storage_ix.addr.i, align 8
  %91 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !311)
  call void @llvm.experimental.noalias.scope.decl(metadata !314)
  store i64 %conv4.i, ptr %n_bits.addr.i9.i, align 8, !noalias !316
  store i64 %conv6.i, ptr %bits.addr.i10.i, align 8, !noalias !316
  store ptr %90, ptr %pos.addr.i11.i, align 8, !noalias !316
  store ptr %91, ptr %array.addr.i12.i, align 8, !noalias !316
  %92 = load ptr, ptr %array.addr.i12.i, align 8, !noalias !316
  %93 = load ptr, ptr %pos.addr.i11.i, align 8, !noalias !316
  %94 = load i64, ptr %93, align 8
  %shr.i15.i = lshr i64 %94, 3
  %arrayidx.i16.i = getelementptr inbounds i8, ptr %92, i64 %shr.i15.i
  store ptr %arrayidx.i16.i, ptr %p.i13.i, align 8, !noalias !316
  %95 = load ptr, ptr %p.i13.i, align 8, !noalias !316
  %96 = load i8, ptr %95, align 1
  %conv.i17.i = zext i8 %96 to i64
  store i64 %conv.i17.i, ptr %v.i14.i, align 8, !noalias !316
  %97 = load i64, ptr %bits.addr.i10.i, align 8, !noalias !316
  %98 = load ptr, ptr %pos.addr.i11.i, align 8, !noalias !316
  %99 = load i64, ptr %98, align 8
  %and.i18.i = and i64 %99, 7
  %shl.i19.i = shl i64 %97, %and.i18.i
  %100 = load i64, ptr %v.i14.i, align 8, !noalias !316
  %or.i20.i = or i64 %100, %shl.i19.i
  store i64 %or.i20.i, ptr %v.i14.i, align 8, !noalias !316
  %101 = load ptr, ptr %p.i13.i, align 8, !noalias !316
  %102 = load i64, ptr %v.i14.i, align 8, !noalias !316
  store ptr %101, ptr %p.addr.i35.i, align 8
  store i64 %102, ptr %v.addr.i36.i, align 8
  %103 = load ptr, ptr %p.addr.i35.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %103, ptr align 8 %v.addr.i36.i, i64 8, i1 false)
  %104 = load i64, ptr %n_bits.addr.i9.i, align 8, !noalias !316
  %105 = load ptr, ptr %pos.addr.i11.i, align 8, !noalias !316
  %106 = load i64, ptr %105, align 8
  %add.i21.i = add i64 %106, %104
  store i64 %add.i21.i, ptr %105, align 8
  %107 = load i32, ptr %len_nextra.i, align 4
  %conv7.i = zext i32 %107 to i64
  %108 = load i32, ptr %len_extra.i, align 4
  %conv8.i = zext i32 %108 to i64
  %109 = load ptr, ptr %storage_ix.addr.i, align 8
  %110 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !317)
  call void @llvm.experimental.noalias.scope.decl(metadata !320)
  store i64 %conv7.i, ptr %n_bits.addr.i.i, align 8, !noalias !322
  store i64 %conv8.i, ptr %bits.addr.i.i, align 8, !noalias !322
  store ptr %109, ptr %pos.addr.i.i, align 8, !noalias !322
  store ptr %110, ptr %array.addr.i.i, align 8, !noalias !322
  %111 = load ptr, ptr %array.addr.i.i, align 8, !noalias !322
  %112 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !322
  %113 = load i64, ptr %112, align 8
  %shr.i.i = lshr i64 %113, 3
  %arrayidx.i.i = getelementptr inbounds i8, ptr %111, i64 %shr.i.i
  store ptr %arrayidx.i.i, ptr %p.i.i, align 8, !noalias !322
  %114 = load ptr, ptr %p.i.i, align 8, !noalias !322
  %115 = load i8, ptr %114, align 1
  %conv.i.i = zext i8 %115 to i64
  store i64 %conv.i.i, ptr %v.i.i, align 8, !noalias !322
  %116 = load i64, ptr %bits.addr.i.i, align 8, !noalias !322
  %117 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !322
  %118 = load i64, ptr %117, align 8
  %and.i.i = and i64 %118, 7
  %shl.i.i = shl i64 %116, %and.i.i
  %119 = load i64, ptr %v.i.i, align 8, !noalias !322
  %or.i.i = or i64 %119, %shl.i.i
  store i64 %or.i.i, ptr %v.i.i, align 8, !noalias !322
  %120 = load ptr, ptr %p.i.i, align 8, !noalias !322
  %121 = load i64, ptr %v.i.i, align 8, !noalias !322
  store ptr %120, ptr %p.addr.i37.i, align 8
  store i64 %121, ptr %v.addr.i38.i, align 8
  %122 = load ptr, ptr %p.addr.i37.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %122, ptr align 8 %v.addr.i38.i, i64 8, i1 false)
  %123 = load i64, ptr %n_bits.addr.i.i, align 8, !noalias !322
  %124 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !322
  %125 = load i64, ptr %124, align 8
  %add.i.i = add i64 %125, %123
  store i64 %add.i.i, ptr %124, align 8
  br label %if.end

if.end:                                           ; preds = %GetBlockLengthPrefixCode.exit, %entry
  %126 = load ptr, ptr %self.addr, align 8
  %block_len_4 = getelementptr inbounds %struct.BlockEncoder, ptr %126, i32 0, i32 7
  %127 = load i64, ptr %block_len_4, align 8
  %dec = add i64 %127, -1
  store i64 %dec, ptr %block_len_4, align 8
  %128 = load ptr, ptr %self.addr, align 8
  %entropy_ix_5 = getelementptr inbounds %struct.BlockEncoder, ptr %128, i32 0, i32 8
  %129 = load i64, ptr %entropy_ix_5, align 8
  %130 = load i64, ptr %symbol.addr, align 8
  %add = add i64 %129, %130
  store i64 %add, ptr %ix, align 8
  %131 = load ptr, ptr %self.addr, align 8
  %depths_ = getelementptr inbounds %struct.BlockEncoder, ptr %131, i32 0, i32 9
  %132 = load ptr, ptr %depths_, align 8
  %133 = load i64, ptr %ix, align 8
  %arrayidx6 = getelementptr inbounds i8, ptr %132, i64 %133
  %134 = load i8, ptr %arrayidx6, align 1
  %conv7 = zext i8 %134 to i64
  %135 = load ptr, ptr %self.addr, align 8
  %bits_ = getelementptr inbounds %struct.BlockEncoder, ptr %135, i32 0, i32 10
  %136 = load ptr, ptr %bits_, align 8
  %137 = load i64, ptr %ix, align 8
  %arrayidx8 = getelementptr inbounds i16, ptr %136, i64 %137
  %138 = load i16, ptr %arrayidx8, align 2
  %conv9 = zext i16 %138 to i64
  %139 = load ptr, ptr %storage_ix.addr, align 8
  %140 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !323)
  call void @llvm.experimental.noalias.scope.decl(metadata !326)
  store i64 %conv7, ptr %n_bits.addr.i, align 8, !noalias !328
  store i64 %conv9, ptr %bits.addr.i, align 8, !noalias !328
  store ptr %139, ptr %pos.addr.i, align 8, !noalias !328
  store ptr %140, ptr %array.addr.i, align 8, !noalias !328
  %141 = load ptr, ptr %array.addr.i, align 8, !noalias !328
  %142 = load ptr, ptr %pos.addr.i, align 8, !noalias !328
  %143 = load i64, ptr %142, align 8
  %shr.i = lshr i64 %143, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %141, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !328
  %144 = load ptr, ptr %p.i, align 8, !noalias !328
  %145 = load i8, ptr %144, align 1
  %conv.i = zext i8 %145 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !328
  %146 = load i64, ptr %bits.addr.i, align 8, !noalias !328
  %147 = load ptr, ptr %pos.addr.i, align 8, !noalias !328
  %148 = load i64, ptr %147, align 8
  %and.i = and i64 %148, 7
  %shl.i = shl i64 %146, %and.i
  %149 = load i64, ptr %v.i, align 8, !noalias !328
  %or.i = or i64 %149, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !328
  %150 = load ptr, ptr %p.i, align 8, !noalias !328
  %151 = load i64, ptr %v.i, align 8, !noalias !328
  store ptr %150, ptr %p.addr.i, align 8
  store i64 %151, ptr %v.addr.i, align 8
  %152 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %152, ptr align 8 %v.addr.i, i64 8, i1 false)
  %153 = load i64, ptr %n_bits.addr.i, align 8, !noalias !328
  %154 = load ptr, ptr %pos.addr.i, align 8, !noalias !328
  %155 = load i64, ptr %154, align 8
  %add.i = add i64 %155, %153
  store i64 %add.i, ptr %154, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @StoreSymbolWithContext(ptr noundef %self, i64 noundef %symbol, i64 noundef %context, ptr noundef %context_map, ptr noundef %storage_ix, ptr noundef %storage, i64 noundef %context_bits) #0 {
entry:
  %len.addr.i.i = alloca i32, align 4
  %code.i.i = alloca i32, align 4
  %len.addr.i = alloca i32, align 4
  %code.addr.i15 = alloca ptr, align 8
  %n_extra.addr.i = alloca ptr, align 8
  %extra.addr.i = alloca ptr, align 8
  %calculator.addr.i.i = alloca ptr, align 8
  %type.addr.i.i = alloca i8, align 1
  %type_code.i.i = alloca i64, align 8
  %p.addr.i37.i = alloca ptr, align 8
  %v.addr.i38.i = alloca i64, align 8
  %p.addr.i35.i = alloca ptr, align 8
  %v.addr.i36.i = alloca i64, align 8
  %p.addr.i.i = alloca ptr, align 8
  %v.addr.i.i = alloca i64, align 8
  %n_bits.addr.i22.i = alloca i64, align 8
  %bits.addr.i23.i = alloca i64, align 8
  %pos.addr.i24.i = alloca ptr, align 8
  %array.addr.i25.i = alloca ptr, align 8
  %p.i26.i = alloca ptr, align 8
  %v.i27.i = alloca i64, align 8
  %n_bits.addr.i9.i = alloca i64, align 8
  %bits.addr.i10.i = alloca i64, align 8
  %pos.addr.i11.i = alloca ptr, align 8
  %array.addr.i12.i = alloca ptr, align 8
  %p.i13.i = alloca ptr, align 8
  %v.i14.i = alloca i64, align 8
  %n_bits.addr.i.i = alloca i64, align 8
  %bits.addr.i.i = alloca i64, align 8
  %pos.addr.i.i = alloca ptr, align 8
  %array.addr.i.i = alloca ptr, align 8
  %p.i.i = alloca ptr, align 8
  %v.i.i = alloca i64, align 8
  %code.addr.i = alloca ptr, align 8
  %block_len.addr.i = alloca i32, align 4
  %block_type.addr.i = alloca i8, align 1
  %is_first_block.addr.i = alloca i32, align 4
  %storage_ix.addr.i = alloca ptr, align 8
  %storage.addr.i = alloca ptr, align 8
  %typecode.i = alloca i64, align 8
  %lencode.i = alloca i64, align 8
  %len_nextra.i = alloca i32, align 4
  %len_extra.i = alloca i32, align 4
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %self.addr = alloca ptr, align 8
  %symbol.addr = alloca i64, align 8
  %context.addr = alloca i64, align 8
  %context_map.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %context_bits.addr = alloca i64, align 8
  %block_ix = alloca i64, align 8
  %block_len = alloca i32, align 4
  %block_type = alloca i8, align 1
  %histo_ix = alloca i64, align 8
  %ix = alloca i64, align 8
  store ptr %self, ptr %self.addr, align 8
  store i64 %symbol, ptr %symbol.addr, align 8
  store i64 %context, ptr %context.addr, align 8
  store ptr %context_map, ptr %context_map.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  store i64 %context_bits, ptr %context_bits.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %block_len_ = getelementptr inbounds %struct.BlockEncoder, ptr %0, i32 0, i32 7
  %1 = load i64, ptr %block_len_, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %self.addr, align 8
  %block_ix_ = getelementptr inbounds %struct.BlockEncoder, ptr %2, i32 0, i32 6
  %3 = load i64, ptr %block_ix_, align 8
  %inc = add i64 %3, 1
  store i64 %inc, ptr %block_ix_, align 8
  store i64 %inc, ptr %block_ix, align 8
  %4 = load ptr, ptr %self.addr, align 8
  %block_lengths_ = getelementptr inbounds %struct.BlockEncoder, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %block_lengths_, align 8
  %6 = load i64, ptr %block_ix, align 8
  %arrayidx = getelementptr inbounds i32, ptr %5, i64 %6
  %7 = load i32, ptr %arrayidx, align 4
  store i32 %7, ptr %block_len, align 4
  %8 = load ptr, ptr %self.addr, align 8
  %block_types_ = getelementptr inbounds %struct.BlockEncoder, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %block_types_, align 8
  %10 = load i64, ptr %block_ix, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %9, i64 %10
  %11 = load i8, ptr %arrayidx1, align 1
  store i8 %11, ptr %block_type, align 1
  %12 = load i32, ptr %block_len, align 4
  %conv = zext i32 %12 to i64
  %13 = load ptr, ptr %self.addr, align 8
  %block_len_2 = getelementptr inbounds %struct.BlockEncoder, ptr %13, i32 0, i32 7
  store i64 %conv, ptr %block_len_2, align 8
  %14 = load i8, ptr %block_type, align 1
  %conv3 = zext i8 %14 to i64
  %15 = load i64, ptr %context_bits.addr, align 8
  %shl = shl i64 %conv3, %15
  %16 = load ptr, ptr %self.addr, align 8
  %entropy_ix_ = getelementptr inbounds %struct.BlockEncoder, ptr %16, i32 0, i32 8
  store i64 %shl, ptr %entropy_ix_, align 8
  %17 = load ptr, ptr %self.addr, align 8
  %block_split_code_ = getelementptr inbounds %struct.BlockEncoder, ptr %17, i32 0, i32 5
  %18 = load i32, ptr %block_len, align 4
  %19 = load i8, ptr %block_type, align 1
  %20 = load ptr, ptr %storage_ix.addr, align 8
  %21 = load ptr, ptr %storage.addr, align 8
  store ptr %block_split_code_, ptr %code.addr.i, align 8
  store i32 %18, ptr %block_len.addr.i, align 4
  store i8 %19, ptr %block_type.addr.i, align 1
  store i32 0, ptr %is_first_block.addr.i, align 4
  store ptr %20, ptr %storage_ix.addr.i, align 8
  store ptr %21, ptr %storage.addr.i, align 8
  %22 = load ptr, ptr %code.addr.i, align 8
  %23 = load i8, ptr %block_type.addr.i, align 1
  store ptr %22, ptr %calculator.addr.i.i, align 8
  store i8 %23, ptr %type.addr.i.i, align 1
  %24 = load i8, ptr %type.addr.i.i, align 1
  %conv.i39.i = zext i8 %24 to i64
  %25 = load ptr, ptr %calculator.addr.i.i, align 8
  %26 = load i64, ptr %25, align 8
  %add.i40.i = add i64 %26, 1
  %cmp.i.i = icmp eq i64 %conv.i39.i, %add.i40.i
  br i1 %cmp.i.i, label %cond.true.i.i, label %cond.false.i.i

cond.true.i.i:                                    ; preds = %if.then
  br label %NextBlockTypeCode.exit.i

cond.false.i.i:                                   ; preds = %if.then
  %27 = load i8, ptr %type.addr.i.i, align 1
  %conv2.i.i = zext i8 %27 to i64
  %28 = load ptr, ptr %calculator.addr.i.i, align 8
  %second_last_type.i.i = getelementptr inbounds %struct.BlockTypeCodeCalculator, ptr %28, i32 0, i32 1
  %29 = load i64, ptr %second_last_type.i.i, align 8
  %cmp3.i.i = icmp eq i64 %conv2.i.i, %29
  br i1 %cmp3.i.i, label %cond.true5.i.i, label %cond.false6.i.i

cond.true5.i.i:                                   ; preds = %cond.false.i.i
  br label %cond.end.i.i

cond.false6.i.i:                                  ; preds = %cond.false.i.i
  %30 = load i8, ptr %type.addr.i.i, align 1
  %conv7.i.i = zext i8 %30 to i32
  %add8.i.i = add i32 %conv7.i.i, 2
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.false6.i.i, %cond.true5.i.i
  %cond.i.i = phi i32 [ 0, %cond.true5.i.i ], [ %add8.i.i, %cond.false6.i.i ]
  br label %NextBlockTypeCode.exit.i

NextBlockTypeCode.exit.i:                         ; preds = %cond.end.i.i, %cond.true.i.i
  %cond10.i.i = phi i32 [ 1, %cond.true.i.i ], [ %cond.i.i, %cond.end.i.i ]
  %conv11.i.i = zext i32 %cond10.i.i to i64
  store i64 %conv11.i.i, ptr %type_code.i.i, align 8
  %31 = load ptr, ptr %calculator.addr.i.i, align 8
  %32 = load i64, ptr %31, align 8
  %33 = load ptr, ptr %calculator.addr.i.i, align 8
  %second_last_type13.i.i = getelementptr inbounds %struct.BlockTypeCodeCalculator, ptr %33, i32 0, i32 1
  store i64 %32, ptr %second_last_type13.i.i, align 8
  %34 = load i8, ptr %type.addr.i.i, align 1
  %conv14.i.i = zext i8 %34 to i64
  %35 = load ptr, ptr %calculator.addr.i.i, align 8
  store i64 %conv14.i.i, ptr %35, align 8
  %36 = load i64, ptr %type_code.i.i, align 8
  store i64 %36, ptr %typecode.i, align 8
  %37 = load i32, ptr %is_first_block.addr.i, align 4
  %tobool.i = icmp ne i32 %37, 0
  br i1 %tobool.i, label %StoreBlockSwitch.exit, label %if.then.i

if.then.i:                                        ; preds = %NextBlockTypeCode.exit.i
  %38 = load ptr, ptr %code.addr.i, align 8
  %type_depths.i = getelementptr inbounds %struct.BlockSplitCode, ptr %38, i32 0, i32 1
  %39 = load i64, ptr %typecode.i, align 8
  %arrayidx.i13 = getelementptr inbounds [258 x i8], ptr %type_depths.i, i64 0, i64 %39
  %40 = load i8, ptr %arrayidx.i13, align 1
  %conv.i14 = zext i8 %40 to i64
  %41 = load ptr, ptr %code.addr.i, align 8
  %type_bits.i = getelementptr inbounds %struct.BlockSplitCode, ptr %41, i32 0, i32 2
  %42 = load i64, ptr %typecode.i, align 8
  %arrayidx1.i = getelementptr inbounds [258 x i16], ptr %type_bits.i, i64 0, i64 %42
  %43 = load i16, ptr %arrayidx1.i, align 2
  %conv2.i = zext i16 %43 to i64
  %44 = load ptr, ptr %storage_ix.addr.i, align 8
  %45 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !329)
  call void @llvm.experimental.noalias.scope.decl(metadata !332)
  store i64 %conv.i14, ptr %n_bits.addr.i22.i, align 8, !noalias !334
  store i64 %conv2.i, ptr %bits.addr.i23.i, align 8, !noalias !334
  store ptr %44, ptr %pos.addr.i24.i, align 8, !noalias !334
  store ptr %45, ptr %array.addr.i25.i, align 8, !noalias !334
  %46 = load ptr, ptr %array.addr.i25.i, align 8, !noalias !334
  %47 = load ptr, ptr %pos.addr.i24.i, align 8, !noalias !334
  %48 = load i64, ptr %47, align 8
  %shr.i28.i = lshr i64 %48, 3
  %arrayidx.i29.i = getelementptr inbounds i8, ptr %46, i64 %shr.i28.i
  store ptr %arrayidx.i29.i, ptr %p.i26.i, align 8, !noalias !334
  %49 = load ptr, ptr %p.i26.i, align 8, !noalias !334
  %50 = load i8, ptr %49, align 1
  %conv.i30.i = zext i8 %50 to i64
  store i64 %conv.i30.i, ptr %v.i27.i, align 8, !noalias !334
  %51 = load i64, ptr %bits.addr.i23.i, align 8, !noalias !334
  %52 = load ptr, ptr %pos.addr.i24.i, align 8, !noalias !334
  %53 = load i64, ptr %52, align 8
  %and.i31.i = and i64 %53, 7
  %shl.i32.i = shl i64 %51, %and.i31.i
  %54 = load i64, ptr %v.i27.i, align 8, !noalias !334
  %or.i33.i = or i64 %54, %shl.i32.i
  store i64 %or.i33.i, ptr %v.i27.i, align 8, !noalias !334
  %55 = load ptr, ptr %p.i26.i, align 8, !noalias !334
  %56 = load i64, ptr %v.i27.i, align 8, !noalias !334
  store ptr %55, ptr %p.addr.i.i, align 8
  store i64 %56, ptr %v.addr.i.i, align 8
  %57 = load ptr, ptr %p.addr.i.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %57, ptr align 8 %v.addr.i.i, i64 8, i1 false)
  %58 = load i64, ptr %n_bits.addr.i22.i, align 8, !noalias !334
  %59 = load ptr, ptr %pos.addr.i24.i, align 8, !noalias !334
  %60 = load i64, ptr %59, align 8
  %add.i34.i = add i64 %60, %58
  store i64 %add.i34.i, ptr %59, align 8
  br label %StoreBlockSwitch.exit

StoreBlockSwitch.exit:                            ; preds = %if.then.i, %NextBlockTypeCode.exit.i
  %61 = load i32, ptr %block_len.addr.i, align 4
  store i32 %61, ptr %len.addr.i, align 4
  store ptr %lencode.i, ptr %code.addr.i15, align 8
  store ptr %len_nextra.i, ptr %n_extra.addr.i, align 8
  store ptr %len_extra.i, ptr %extra.addr.i, align 8
  %62 = load i32, ptr %len.addr.i, align 4
  store i32 %62, ptr %len.addr.i.i, align 4
  %63 = load i32, ptr %len.addr.i.i, align 4
  %cmp.i.i16 = icmp uge i32 %63, 177
  br i1 %cmp.i.i16, label %cond.true.i.i24, label %cond.false.i.i17

cond.true.i.i24:                                  ; preds = %StoreBlockSwitch.exit
  %64 = load i32, ptr %len.addr.i.i, align 4
  %cmp1.i.i = icmp uge i32 %64, 753
  %cond.i.i25 = select i1 %cmp1.i.i, i32 20, i32 14
  br label %cond.end.i.i18

cond.false.i.i17:                                 ; preds = %StoreBlockSwitch.exit
  %65 = load i32, ptr %len.addr.i.i, align 4
  %cmp2.i.i = icmp uge i32 %65, 41
  %cond3.i.i = select i1 %cmp2.i.i, i32 7, i32 0
  br label %cond.end.i.i18

cond.end.i.i18:                                   ; preds = %cond.false.i.i17, %cond.true.i.i24
  %cond4.i.i = phi i32 [ %cond.i.i25, %cond.true.i.i24 ], [ %cond3.i.i, %cond.false.i.i17 ]
  store i32 %cond4.i.i, ptr %code.i.i, align 4
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.body.i.i, %cond.end.i.i18
  %66 = load i32, ptr %code.i.i, align 4
  %cmp5.i.i = icmp ult i32 %66, 25
  br i1 %cmp5.i.i, label %land.rhs.i.i, label %land.end.i.i

land.rhs.i.i:                                     ; preds = %while.cond.i.i
  %67 = load i32, ptr %len.addr.i.i, align 4
  %68 = load i32, ptr %code.i.i, align 4
  %add.i.i21 = add i32 %68, 1
  %idxprom.i.i = zext i32 %add.i.i21 to i64
  %arrayidx.i.i22 = getelementptr inbounds [26 x %struct.BrotliPrefixCodeRange], ptr @_kBrotliPrefixCodeRanges, i64 0, i64 %idxprom.i.i
  %69 = load i16, ptr %arrayidx.i.i22, align 4
  %conv.i.i23 = zext i16 %69 to i32
  %cmp6.i.i = icmp uge i32 %67, %conv.i.i23
  br label %land.end.i.i

land.end.i.i:                                     ; preds = %land.rhs.i.i, %while.cond.i.i
  %70 = phi i1 [ false, %while.cond.i.i ], [ %cmp6.i.i, %land.rhs.i.i ]
  br i1 %70, label %while.body.i.i, label %GetBlockLengthPrefixCode.exit

while.body.i.i:                                   ; preds = %land.end.i.i
  %71 = load i32, ptr %code.i.i, align 4
  %inc.i.i = add i32 %71, 1
  store i32 %inc.i.i, ptr %code.i.i, align 4
  br label %while.cond.i.i, !llvm.loop !310

GetBlockLengthPrefixCode.exit:                    ; preds = %land.end.i.i
  %72 = load i32, ptr %code.i.i, align 4
  %conv.i19 = zext i32 %72 to i64
  %73 = load ptr, ptr %code.addr.i15, align 8
  store i64 %conv.i19, ptr %73, align 8
  %74 = load ptr, ptr %code.addr.i15, align 8
  %75 = load i64, ptr %74, align 8
  %arrayidx.i20 = getelementptr inbounds [26 x %struct.BrotliPrefixCodeRange], ptr @_kBrotliPrefixCodeRanges, i64 0, i64 %75
  %nbits.i = getelementptr inbounds %struct.BrotliPrefixCodeRange, ptr %arrayidx.i20, i32 0, i32 1
  %76 = load i8, ptr %nbits.i, align 2
  %conv1.i = zext i8 %76 to i32
  %77 = load ptr, ptr %n_extra.addr.i, align 8
  store i32 %conv1.i, ptr %77, align 4
  %78 = load i32, ptr %len.addr.i, align 4
  %79 = load ptr, ptr %code.addr.i15, align 8
  %80 = load i64, ptr %79, align 8
  %arrayidx2.i = getelementptr inbounds [26 x %struct.BrotliPrefixCodeRange], ptr @_kBrotliPrefixCodeRanges, i64 0, i64 %80
  %81 = load i16, ptr %arrayidx2.i, align 4
  %conv3.i = zext i16 %81 to i32
  %sub.i = sub i32 %78, %conv3.i
  %82 = load ptr, ptr %extra.addr.i, align 8
  store i32 %sub.i, ptr %82, align 4
  %83 = load ptr, ptr %code.addr.i, align 8
  %length_depths.i = getelementptr inbounds %struct.BlockSplitCode, ptr %83, i32 0, i32 3
  %84 = load i64, ptr %lencode.i, align 8
  %arrayidx3.i = getelementptr inbounds [26 x i8], ptr %length_depths.i, i64 0, i64 %84
  %85 = load i8, ptr %arrayidx3.i, align 1
  %conv4.i = zext i8 %85 to i64
  %86 = load ptr, ptr %code.addr.i, align 8
  %length_bits.i = getelementptr inbounds %struct.BlockSplitCode, ptr %86, i32 0, i32 4
  %87 = load i64, ptr %lencode.i, align 8
  %arrayidx5.i = getelementptr inbounds [26 x i16], ptr %length_bits.i, i64 0, i64 %87
  %88 = load i16, ptr %arrayidx5.i, align 2
  %conv6.i = zext i16 %88 to i64
  %89 = load ptr, ptr %storage_ix.addr.i, align 8
  %90 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !335)
  call void @llvm.experimental.noalias.scope.decl(metadata !338)
  store i64 %conv4.i, ptr %n_bits.addr.i9.i, align 8, !noalias !340
  store i64 %conv6.i, ptr %bits.addr.i10.i, align 8, !noalias !340
  store ptr %89, ptr %pos.addr.i11.i, align 8, !noalias !340
  store ptr %90, ptr %array.addr.i12.i, align 8, !noalias !340
  %91 = load ptr, ptr %array.addr.i12.i, align 8, !noalias !340
  %92 = load ptr, ptr %pos.addr.i11.i, align 8, !noalias !340
  %93 = load i64, ptr %92, align 8
  %shr.i15.i = lshr i64 %93, 3
  %arrayidx.i16.i = getelementptr inbounds i8, ptr %91, i64 %shr.i15.i
  store ptr %arrayidx.i16.i, ptr %p.i13.i, align 8, !noalias !340
  %94 = load ptr, ptr %p.i13.i, align 8, !noalias !340
  %95 = load i8, ptr %94, align 1
  %conv.i17.i = zext i8 %95 to i64
  store i64 %conv.i17.i, ptr %v.i14.i, align 8, !noalias !340
  %96 = load i64, ptr %bits.addr.i10.i, align 8, !noalias !340
  %97 = load ptr, ptr %pos.addr.i11.i, align 8, !noalias !340
  %98 = load i64, ptr %97, align 8
  %and.i18.i = and i64 %98, 7
  %shl.i19.i = shl i64 %96, %and.i18.i
  %99 = load i64, ptr %v.i14.i, align 8, !noalias !340
  %or.i20.i = or i64 %99, %shl.i19.i
  store i64 %or.i20.i, ptr %v.i14.i, align 8, !noalias !340
  %100 = load ptr, ptr %p.i13.i, align 8, !noalias !340
  %101 = load i64, ptr %v.i14.i, align 8, !noalias !340
  store ptr %100, ptr %p.addr.i35.i, align 8
  store i64 %101, ptr %v.addr.i36.i, align 8
  %102 = load ptr, ptr %p.addr.i35.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %102, ptr align 8 %v.addr.i36.i, i64 8, i1 false)
  %103 = load i64, ptr %n_bits.addr.i9.i, align 8, !noalias !340
  %104 = load ptr, ptr %pos.addr.i11.i, align 8, !noalias !340
  %105 = load i64, ptr %104, align 8
  %add.i21.i = add i64 %105, %103
  store i64 %add.i21.i, ptr %104, align 8
  %106 = load i32, ptr %len_nextra.i, align 4
  %conv7.i = zext i32 %106 to i64
  %107 = load i32, ptr %len_extra.i, align 4
  %conv8.i = zext i32 %107 to i64
  %108 = load ptr, ptr %storage_ix.addr.i, align 8
  %109 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !341)
  call void @llvm.experimental.noalias.scope.decl(metadata !344)
  store i64 %conv7.i, ptr %n_bits.addr.i.i, align 8, !noalias !346
  store i64 %conv8.i, ptr %bits.addr.i.i, align 8, !noalias !346
  store ptr %108, ptr %pos.addr.i.i, align 8, !noalias !346
  store ptr %109, ptr %array.addr.i.i, align 8, !noalias !346
  %110 = load ptr, ptr %array.addr.i.i, align 8, !noalias !346
  %111 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !346
  %112 = load i64, ptr %111, align 8
  %shr.i.i = lshr i64 %112, 3
  %arrayidx.i.i = getelementptr inbounds i8, ptr %110, i64 %shr.i.i
  store ptr %arrayidx.i.i, ptr %p.i.i, align 8, !noalias !346
  %113 = load ptr, ptr %p.i.i, align 8, !noalias !346
  %114 = load i8, ptr %113, align 1
  %conv.i.i = zext i8 %114 to i64
  store i64 %conv.i.i, ptr %v.i.i, align 8, !noalias !346
  %115 = load i64, ptr %bits.addr.i.i, align 8, !noalias !346
  %116 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !346
  %117 = load i64, ptr %116, align 8
  %and.i.i = and i64 %117, 7
  %shl.i.i = shl i64 %115, %and.i.i
  %118 = load i64, ptr %v.i.i, align 8, !noalias !346
  %or.i.i = or i64 %118, %shl.i.i
  store i64 %or.i.i, ptr %v.i.i, align 8, !noalias !346
  %119 = load ptr, ptr %p.i.i, align 8, !noalias !346
  %120 = load i64, ptr %v.i.i, align 8, !noalias !346
  store ptr %119, ptr %p.addr.i37.i, align 8
  store i64 %120, ptr %v.addr.i38.i, align 8
  %121 = load ptr, ptr %p.addr.i37.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %121, ptr align 8 %v.addr.i38.i, i64 8, i1 false)
  %122 = load i64, ptr %n_bits.addr.i.i, align 8, !noalias !346
  %123 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !346
  %124 = load i64, ptr %123, align 8
  %add.i.i = add i64 %124, %122
  store i64 %add.i.i, ptr %123, align 8
  br label %if.end

if.end:                                           ; preds = %GetBlockLengthPrefixCode.exit, %entry
  %125 = load ptr, ptr %self.addr, align 8
  %block_len_4 = getelementptr inbounds %struct.BlockEncoder, ptr %125, i32 0, i32 7
  %126 = load i64, ptr %block_len_4, align 8
  %dec = add i64 %126, -1
  store i64 %dec, ptr %block_len_4, align 8
  %127 = load ptr, ptr %context_map.addr, align 8
  %128 = load ptr, ptr %self.addr, align 8
  %entropy_ix_5 = getelementptr inbounds %struct.BlockEncoder, ptr %128, i32 0, i32 8
  %129 = load i64, ptr %entropy_ix_5, align 8
  %130 = load i64, ptr %context.addr, align 8
  %add = add i64 %129, %130
  %arrayidx6 = getelementptr inbounds i32, ptr %127, i64 %add
  %131 = load i32, ptr %arrayidx6, align 4
  %conv7 = zext i32 %131 to i64
  store i64 %conv7, ptr %histo_ix, align 8
  %132 = load i64, ptr %histo_ix, align 8
  %133 = load ptr, ptr %self.addr, align 8
  %histogram_length_ = getelementptr inbounds %struct.BlockEncoder, ptr %133, i32 0, i32 0
  %134 = load i64, ptr %histogram_length_, align 8
  %mul = mul i64 %132, %134
  %135 = load i64, ptr %symbol.addr, align 8
  %add8 = add i64 %mul, %135
  store i64 %add8, ptr %ix, align 8
  %136 = load ptr, ptr %self.addr, align 8
  %depths_ = getelementptr inbounds %struct.BlockEncoder, ptr %136, i32 0, i32 9
  %137 = load ptr, ptr %depths_, align 8
  %138 = load i64, ptr %ix, align 8
  %arrayidx9 = getelementptr inbounds i8, ptr %137, i64 %138
  %139 = load i8, ptr %arrayidx9, align 1
  %conv10 = zext i8 %139 to i64
  %140 = load ptr, ptr %self.addr, align 8
  %bits_ = getelementptr inbounds %struct.BlockEncoder, ptr %140, i32 0, i32 10
  %141 = load ptr, ptr %bits_, align 8
  %142 = load i64, ptr %ix, align 8
  %arrayidx11 = getelementptr inbounds i16, ptr %141, i64 %142
  %143 = load i16, ptr %arrayidx11, align 2
  %conv12 = zext i16 %143 to i64
  %144 = load ptr, ptr %storage_ix.addr, align 8
  %145 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !347)
  call void @llvm.experimental.noalias.scope.decl(metadata !350)
  store i64 %conv10, ptr %n_bits.addr.i, align 8, !noalias !352
  store i64 %conv12, ptr %bits.addr.i, align 8, !noalias !352
  store ptr %144, ptr %pos.addr.i, align 8, !noalias !352
  store ptr %145, ptr %array.addr.i, align 8, !noalias !352
  %146 = load ptr, ptr %array.addr.i, align 8, !noalias !352
  %147 = load ptr, ptr %pos.addr.i, align 8, !noalias !352
  %148 = load i64, ptr %147, align 8
  %shr.i = lshr i64 %148, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %146, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !352
  %149 = load ptr, ptr %p.i, align 8, !noalias !352
  %150 = load i8, ptr %149, align 1
  %conv.i = zext i8 %150 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !352
  %151 = load i64, ptr %bits.addr.i, align 8, !noalias !352
  %152 = load ptr, ptr %pos.addr.i, align 8, !noalias !352
  %153 = load i64, ptr %152, align 8
  %and.i = and i64 %153, 7
  %shl.i = shl i64 %151, %and.i
  %154 = load i64, ptr %v.i, align 8, !noalias !352
  %or.i = or i64 %154, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !352
  %155 = load ptr, ptr %p.i, align 8, !noalias !352
  %156 = load i64, ptr %v.i, align 8, !noalias !352
  store ptr %155, ptr %p.addr.i, align 8
  store i64 %156, ptr %v.addr.i, align 8
  %157 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %157, ptr align 8 %v.addr.i, i64 8, i1 false)
  %158 = load i64, ptr %n_bits.addr.i, align 8, !noalias !352
  %159 = load ptr, ptr %pos.addr.i, align 8, !noalias !352
  %160 = load i64, ptr %159, align 8
  %add.i = add i64 %160, %158
  store i64 %add.i, ptr %159, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @CleanupBlockEncoder(ptr noundef %m, ptr noundef %self) #0 {
entry:
  %m.addr = alloca ptr, align 8
  %self.addr = alloca ptr, align 8
  store ptr %m, ptr %m.addr, align 8
  store ptr %self, ptr %self.addr, align 8
  %0 = load ptr, ptr %m.addr, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %depths_ = getelementptr inbounds %struct.BlockEncoder, ptr %1, i32 0, i32 9
  %2 = load ptr, ptr %depths_, align 8
  call void @BrotliFree(ptr noundef %0, ptr noundef %2)
  %3 = load ptr, ptr %self.addr, align 8
  %depths_1 = getelementptr inbounds %struct.BlockEncoder, ptr %3, i32 0, i32 9
  store ptr null, ptr %depths_1, align 8
  %4 = load ptr, ptr %m.addr, align 8
  %5 = load ptr, ptr %self.addr, align 8
  %bits_ = getelementptr inbounds %struct.BlockEncoder, ptr %5, i32 0, i32 10
  %6 = load ptr, ptr %bits_, align 8
  call void @BrotliFree(ptr noundef %4, ptr noundef %6)
  %7 = load ptr, ptr %self.addr, align 8
  %bits_2 = getelementptr inbounds %struct.BlockEncoder, ptr %7, i32 0, i32 10
  store ptr null, ptr %bits_2, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @JumpToByteBoundary(ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load ptr, ptr %storage_ix.addr, align 8
  %1 = load i64, ptr %0, align 8
  %add = add i64 %1, 7
  %and = and i64 %add, 4294967288
  %2 = load ptr, ptr %storage_ix.addr, align 8
  store i64 %and, ptr %2, align 8
  %3 = load ptr, ptr %storage.addr, align 8
  %4 = load ptr, ptr %storage_ix.addr, align 8
  %5 = load i64, ptr %4, align 8
  %shr = lshr i64 %5, 3
  %arrayidx = getelementptr inbounds i8, ptr %3, i64 %shr
  store i8 0, ptr %arrayidx, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @BrotliStoreMetaBlockTrivial(ptr noundef %m, ptr noundef %input, i64 noundef %start_pos, i64 noundef %length, i64 noundef %mask, i32 noundef %is_last, ptr noundef %params, ptr noundef %commands, i64 noundef %n_commands, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %self.addr.i37 = alloca ptr, align 8
  %self.addr.i34 = alloca ptr, align 8
  %self.addr.i = alloca ptr, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %m.addr = alloca ptr, align 8
  %input.addr = alloca ptr, align 8
  %start_pos.addr = alloca i64, align 8
  %length.addr = alloca i64, align 8
  %mask.addr = alloca i64, align 8
  %is_last.addr = alloca i32, align 4
  %params.addr = alloca ptr, align 8
  %commands.addr = alloca ptr, align 8
  %n_commands.addr = alloca i64, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %arena = alloca ptr, align 8
  %num_distance_symbols = alloca i32, align 4
  store ptr %m, ptr %m.addr, align 8
  store ptr %input, ptr %input.addr, align 8
  store i64 %start_pos, ptr %start_pos.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store i64 %mask, ptr %mask.addr, align 8
  store i32 %is_last, ptr %is_last.addr, align 4
  store ptr %params, ptr %params.addr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  store i64 %n_commands, ptr %n_commands.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load ptr, ptr %m.addr, align 8
  %call = call ptr @BrotliAllocate(ptr noundef %0, i64 noundef 20640)
  store ptr %call, ptr %arena, align 8
  %1 = load ptr, ptr %params.addr, align 8
  %dist = getelementptr inbounds %struct.BrotliEncoderParams, ptr %1, i32 0, i32 9
  %alphabet_size_max = getelementptr inbounds %struct.BrotliDistanceParams, ptr %dist, i32 0, i32 2
  %2 = load i32, ptr %alphabet_size_max, align 8
  store i32 %2, ptr %num_distance_symbols, align 4
  %3 = load i32, ptr %is_last.addr, align 4
  %4 = load i64, ptr %length.addr, align 8
  %5 = load ptr, ptr %storage_ix.addr, align 8
  %6 = load ptr, ptr %storage.addr, align 8
  call void @StoreCompressedMetaBlockHeader(i32 noundef %3, i64 noundef %4, ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr %arena, align 8
  %lit_histo = getelementptr inbounds %struct.MetablockArena, ptr %7, i32 0, i32 0
  store ptr %lit_histo, ptr %self.addr.i, align 8
  %8 = load ptr, ptr %self.addr.i, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %8, i8 0, i64 1024, i1 false)
  %9 = load ptr, ptr %self.addr.i, align 8
  %total_count_.i = getelementptr inbounds %struct.HistogramLiteral, ptr %9, i32 0, i32 1
  store i64 0, ptr %total_count_.i, align 8
  %10 = load ptr, ptr %self.addr.i, align 8
  %bit_cost_.i = getelementptr inbounds %struct.HistogramLiteral, ptr %10, i32 0, i32 2
  store double 0x7FF0000000000000, ptr %bit_cost_.i, align 8
  %11 = load ptr, ptr %arena, align 8
  %cmd_histo = getelementptr inbounds %struct.MetablockArena, ptr %11, i32 0, i32 1
  store ptr %cmd_histo, ptr %self.addr.i34, align 8
  %12 = load ptr, ptr %self.addr.i34, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %12, i8 0, i64 2816, i1 false)
  %13 = load ptr, ptr %self.addr.i34, align 8
  %total_count_.i35 = getelementptr inbounds %struct.HistogramCommand, ptr %13, i32 0, i32 1
  store i64 0, ptr %total_count_.i35, align 8
  %14 = load ptr, ptr %self.addr.i34, align 8
  %bit_cost_.i36 = getelementptr inbounds %struct.HistogramCommand, ptr %14, i32 0, i32 2
  store double 0x7FF0000000000000, ptr %bit_cost_.i36, align 8
  %15 = load ptr, ptr %arena, align 8
  %dist_histo = getelementptr inbounds %struct.MetablockArena, ptr %15, i32 0, i32 2
  store ptr %dist_histo, ptr %self.addr.i37, align 8
  %16 = load ptr, ptr %self.addr.i37, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %16, i8 0, i64 2176, i1 false)
  %17 = load ptr, ptr %self.addr.i37, align 8
  %total_count_.i38 = getelementptr inbounds %struct.HistogramDistance, ptr %17, i32 0, i32 1
  store i64 0, ptr %total_count_.i38, align 8
  %18 = load ptr, ptr %self.addr.i37, align 8
  %bit_cost_.i39 = getelementptr inbounds %struct.HistogramDistance, ptr %18, i32 0, i32 2
  store double 0x7FF0000000000000, ptr %bit_cost_.i39, align 8
  %19 = load ptr, ptr %input.addr, align 8
  %20 = load i64, ptr %start_pos.addr, align 8
  %21 = load i64, ptr %mask.addr, align 8
  %22 = load ptr, ptr %commands.addr, align 8
  %23 = load i64, ptr %n_commands.addr, align 8
  %24 = load ptr, ptr %arena, align 8
  %lit_histo1 = getelementptr inbounds %struct.MetablockArena, ptr %24, i32 0, i32 0
  %25 = load ptr, ptr %arena, align 8
  %cmd_histo2 = getelementptr inbounds %struct.MetablockArena, ptr %25, i32 0, i32 1
  %26 = load ptr, ptr %arena, align 8
  %dist_histo3 = getelementptr inbounds %struct.MetablockArena, ptr %26, i32 0, i32 2
  call void @BuildHistograms(ptr noundef %19, i64 noundef %20, i64 noundef %21, ptr noundef %22, i64 noundef %23, ptr noundef %lit_histo1, ptr noundef %cmd_histo2, ptr noundef %dist_histo3)
  %27 = load ptr, ptr %storage_ix.addr, align 8
  %28 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !353)
  call void @llvm.experimental.noalias.scope.decl(metadata !356)
  store i64 13, ptr %n_bits.addr.i, align 8, !noalias !358
  store i64 0, ptr %bits.addr.i, align 8, !noalias !358
  store ptr %27, ptr %pos.addr.i, align 8, !noalias !358
  store ptr %28, ptr %array.addr.i, align 8, !noalias !358
  %29 = load ptr, ptr %array.addr.i, align 8, !noalias !358
  %30 = load ptr, ptr %pos.addr.i, align 8, !noalias !358
  %31 = load i64, ptr %30, align 8
  %shr.i = lshr i64 %31, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %29, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !358
  %32 = load ptr, ptr %p.i, align 8, !noalias !358
  %33 = load i8, ptr %32, align 1
  %conv.i = zext i8 %33 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !358
  %34 = load i64, ptr %bits.addr.i, align 8, !noalias !358
  %35 = load ptr, ptr %pos.addr.i, align 8, !noalias !358
  %36 = load i64, ptr %35, align 8
  %and.i = and i64 %36, 7
  %shl.i = shl i64 %34, %and.i
  %37 = load i64, ptr %v.i, align 8, !noalias !358
  %or.i = or i64 %37, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !358
  %38 = load ptr, ptr %p.i, align 8, !noalias !358
  %39 = load i64, ptr %v.i, align 8, !noalias !358
  store ptr %38, ptr %p.addr.i, align 8
  store i64 %39, ptr %v.addr.i, align 8
  %40 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %40, ptr align 8 %v.addr.i, i64 8, i1 false)
  %41 = load i64, ptr %n_bits.addr.i, align 8, !noalias !358
  %42 = load ptr, ptr %pos.addr.i, align 8, !noalias !358
  %43 = load i64, ptr %42, align 8
  %add.i = add i64 %43, %41
  store i64 %add.i, ptr %42, align 8
  %44 = load ptr, ptr %arena, align 8
  %lit_histo4 = getelementptr inbounds %struct.MetablockArena, ptr %44, i32 0, i32 0
  %data_ = getelementptr inbounds %struct.HistogramLiteral, ptr %lit_histo4, i32 0, i32 0
  %arraydecay = getelementptr inbounds [256 x i32], ptr %data_, i64 0, i64 0
  %45 = load ptr, ptr %arena, align 8
  %tree = getelementptr inbounds %struct.MetablockArena, ptr %45, i32 0, i32 9
  %arraydecay5 = getelementptr inbounds [1409 x %struct.HuffmanTree], ptr %tree, i64 0, i64 0
  %46 = load ptr, ptr %arena, align 8
  %lit_depth = getelementptr inbounds %struct.MetablockArena, ptr %46, i32 0, i32 3
  %arraydecay6 = getelementptr inbounds [256 x i8], ptr %lit_depth, i64 0, i64 0
  %47 = load ptr, ptr %arena, align 8
  %lit_bits = getelementptr inbounds %struct.MetablockArena, ptr %47, i32 0, i32 4
  %arraydecay7 = getelementptr inbounds [256 x i16], ptr %lit_bits, i64 0, i64 0
  %48 = load ptr, ptr %storage_ix.addr, align 8
  %49 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreHuffmanTree(ptr noundef %arraydecay, i64 noundef 256, i64 noundef 256, ptr noundef %arraydecay5, ptr noundef %arraydecay6, ptr noundef %arraydecay7, ptr noundef %48, ptr noundef %49)
  %50 = load ptr, ptr %arena, align 8
  %cmd_histo8 = getelementptr inbounds %struct.MetablockArena, ptr %50, i32 0, i32 1
  %data_9 = getelementptr inbounds %struct.HistogramCommand, ptr %cmd_histo8, i32 0, i32 0
  %arraydecay10 = getelementptr inbounds [704 x i32], ptr %data_9, i64 0, i64 0
  %51 = load ptr, ptr %arena, align 8
  %tree11 = getelementptr inbounds %struct.MetablockArena, ptr %51, i32 0, i32 9
  %arraydecay12 = getelementptr inbounds [1409 x %struct.HuffmanTree], ptr %tree11, i64 0, i64 0
  %52 = load ptr, ptr %arena, align 8
  %cmd_depth = getelementptr inbounds %struct.MetablockArena, ptr %52, i32 0, i32 5
  %arraydecay13 = getelementptr inbounds [704 x i8], ptr %cmd_depth, i64 0, i64 0
  %53 = load ptr, ptr %arena, align 8
  %cmd_bits = getelementptr inbounds %struct.MetablockArena, ptr %53, i32 0, i32 6
  %arraydecay14 = getelementptr inbounds [704 x i16], ptr %cmd_bits, i64 0, i64 0
  %54 = load ptr, ptr %storage_ix.addr, align 8
  %55 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreHuffmanTree(ptr noundef %arraydecay10, i64 noundef 704, i64 noundef 704, ptr noundef %arraydecay12, ptr noundef %arraydecay13, ptr noundef %arraydecay14, ptr noundef %54, ptr noundef %55)
  %56 = load ptr, ptr %arena, align 8
  %dist_histo15 = getelementptr inbounds %struct.MetablockArena, ptr %56, i32 0, i32 2
  %data_16 = getelementptr inbounds %struct.HistogramDistance, ptr %dist_histo15, i32 0, i32 0
  %arraydecay17 = getelementptr inbounds [544 x i32], ptr %data_16, i64 0, i64 0
  %57 = load i32, ptr %num_distance_symbols, align 4
  %conv = zext i32 %57 to i64
  %58 = load ptr, ptr %arena, align 8
  %tree18 = getelementptr inbounds %struct.MetablockArena, ptr %58, i32 0, i32 9
  %arraydecay19 = getelementptr inbounds [1409 x %struct.HuffmanTree], ptr %tree18, i64 0, i64 0
  %59 = load ptr, ptr %arena, align 8
  %dist_depth = getelementptr inbounds %struct.MetablockArena, ptr %59, i32 0, i32 7
  %arraydecay20 = getelementptr inbounds [140 x i8], ptr %dist_depth, i64 0, i64 0
  %60 = load ptr, ptr %arena, align 8
  %dist_bits = getelementptr inbounds %struct.MetablockArena, ptr %60, i32 0, i32 8
  %arraydecay21 = getelementptr inbounds [140 x i16], ptr %dist_bits, i64 0, i64 0
  %61 = load ptr, ptr %storage_ix.addr, align 8
  %62 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreHuffmanTree(ptr noundef %arraydecay17, i64 noundef 140, i64 noundef %conv, ptr noundef %arraydecay19, ptr noundef %arraydecay20, ptr noundef %arraydecay21, ptr noundef %61, ptr noundef %62)
  %63 = load ptr, ptr %input.addr, align 8
  %64 = load i64, ptr %start_pos.addr, align 8
  %65 = load i64, ptr %mask.addr, align 8
  %66 = load ptr, ptr %commands.addr, align 8
  %67 = load i64, ptr %n_commands.addr, align 8
  %68 = load ptr, ptr %arena, align 8
  %lit_depth22 = getelementptr inbounds %struct.MetablockArena, ptr %68, i32 0, i32 3
  %arraydecay23 = getelementptr inbounds [256 x i8], ptr %lit_depth22, i64 0, i64 0
  %69 = load ptr, ptr %arena, align 8
  %lit_bits24 = getelementptr inbounds %struct.MetablockArena, ptr %69, i32 0, i32 4
  %arraydecay25 = getelementptr inbounds [256 x i16], ptr %lit_bits24, i64 0, i64 0
  %70 = load ptr, ptr %arena, align 8
  %cmd_depth26 = getelementptr inbounds %struct.MetablockArena, ptr %70, i32 0, i32 5
  %arraydecay27 = getelementptr inbounds [704 x i8], ptr %cmd_depth26, i64 0, i64 0
  %71 = load ptr, ptr %arena, align 8
  %cmd_bits28 = getelementptr inbounds %struct.MetablockArena, ptr %71, i32 0, i32 6
  %arraydecay29 = getelementptr inbounds [704 x i16], ptr %cmd_bits28, i64 0, i64 0
  %72 = load ptr, ptr %arena, align 8
  %dist_depth30 = getelementptr inbounds %struct.MetablockArena, ptr %72, i32 0, i32 7
  %arraydecay31 = getelementptr inbounds [140 x i8], ptr %dist_depth30, i64 0, i64 0
  %73 = load ptr, ptr %arena, align 8
  %dist_bits32 = getelementptr inbounds %struct.MetablockArena, ptr %73, i32 0, i32 8
  %arraydecay33 = getelementptr inbounds [140 x i16], ptr %dist_bits32, i64 0, i64 0
  %74 = load ptr, ptr %storage_ix.addr, align 8
  %75 = load ptr, ptr %storage.addr, align 8
  call void @StoreDataWithHuffmanCodes(ptr noundef %63, i64 noundef %64, i64 noundef %65, ptr noundef %66, i64 noundef %67, ptr noundef %arraydecay23, ptr noundef %arraydecay25, ptr noundef %arraydecay27, ptr noundef %arraydecay29, ptr noundef %arraydecay31, ptr noundef %arraydecay33, ptr noundef %74, ptr noundef %75)
  %76 = load ptr, ptr %m.addr, align 8
  %77 = load ptr, ptr %arena, align 8
  call void @BrotliFree(ptr noundef %76, ptr noundef %77)
  store ptr null, ptr %arena, align 8
  %78 = load i32, ptr %is_last.addr, align 4
  %tobool = icmp ne i32 %78, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %79 = load ptr, ptr %storage_ix.addr, align 8
  %80 = load ptr, ptr %storage.addr, align 8
  call void @JumpToByteBoundary(ptr noundef %79, ptr noundef %80)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @BuildHistograms(ptr noundef %input, i64 noundef %start_pos, i64 noundef %mask, ptr noundef %commands, i64 noundef %n_commands, ptr noundef %lit_histo, ptr noundef %cmd_histo, ptr noundef %dist_histo) #0 {
entry:
  %self.addr.i30 = alloca ptr, align 8
  %val.addr.i31 = alloca i64, align 8
  %self.addr.i24 = alloca ptr, align 8
  %val.addr.i25 = alloca i64, align 8
  %self.addr.i23 = alloca ptr, align 8
  %val.addr.i = alloca i64, align 8
  %self.addr.i20 = alloca ptr, align 8
  %self.addr.i = alloca ptr, align 8
  %input.addr = alloca ptr, align 8
  %start_pos.addr = alloca i64, align 8
  %mask.addr = alloca i64, align 8
  %commands.addr = alloca ptr, align 8
  %n_commands.addr = alloca i64, align 8
  %lit_histo.addr = alloca ptr, align 8
  %cmd_histo.addr = alloca ptr, align 8
  %dist_histo.addr = alloca ptr, align 8
  %pos = alloca i64, align 8
  %i = alloca i64, align 8
  %cmd = alloca %struct.Command, align 4
  %j = alloca i64, align 8
  store ptr %input, ptr %input.addr, align 8
  store i64 %start_pos, ptr %start_pos.addr, align 8
  store i64 %mask, ptr %mask.addr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  store i64 %n_commands, ptr %n_commands.addr, align 8
  store ptr %lit_histo, ptr %lit_histo.addr, align 8
  store ptr %cmd_histo, ptr %cmd_histo.addr, align 8
  store ptr %dist_histo, ptr %dist_histo.addr, align 8
  %0 = load i64, ptr %start_pos.addr, align 8
  store i64 %0, ptr %pos, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc17, %entry
  %1 = load i64, ptr %i, align 8
  %2 = load i64, ptr %n_commands.addr, align 8
  %cmp = icmp ult i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end19

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %commands.addr, align 8
  %4 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds %struct.Command, ptr %3, i64 %4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %cmd, ptr align 4 %arrayidx, i64 16, i1 false)
  %5 = load ptr, ptr %cmd_histo.addr, align 8
  %cmd_prefix_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 3
  %6 = load i16, ptr %cmd_prefix_, align 4
  %conv = zext i16 %6 to i64
  store ptr %5, ptr %self.addr.i23, align 8
  store i64 %conv, ptr %val.addr.i, align 8
  %7 = load ptr, ptr %self.addr.i23, align 8
  %8 = load i64, ptr %val.addr.i, align 8
  %arrayidx.i = getelementptr inbounds [704 x i32], ptr %7, i64 0, i64 %8
  %9 = load i32, ptr %arrayidx.i, align 4
  %inc.i = add i32 %9, 1
  store i32 %inc.i, ptr %arrayidx.i, align 4
  %10 = load ptr, ptr %self.addr.i23, align 8
  %total_count_.i = getelementptr inbounds %struct.HistogramCommand, ptr %10, i32 0, i32 1
  %11 = load i64, ptr %total_count_.i, align 8
  %inc1.i = add i64 %11, 1
  store i64 %inc1.i, ptr %total_count_.i, align 8
  %insert_len_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 0
  %12 = load i32, ptr %insert_len_, align 4
  %conv1 = zext i32 %12 to i64
  store i64 %conv1, ptr %j, align 8
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %13 = load i64, ptr %j, align 8
  %cmp3 = icmp ne i64 %13, 0
  br i1 %cmp3, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond2
  %14 = load ptr, ptr %lit_histo.addr, align 8
  %15 = load ptr, ptr %input.addr, align 8
  %16 = load i64, ptr %pos, align 8
  %17 = load i64, ptr %mask.addr, align 8
  %and = and i64 %16, %17
  %arrayidx6 = getelementptr inbounds i8, ptr %15, i64 %and
  %18 = load i8, ptr %arrayidx6, align 1
  %conv7 = zext i8 %18 to i64
  store ptr %14, ptr %self.addr.i24, align 8
  store i64 %conv7, ptr %val.addr.i25, align 8
  %19 = load ptr, ptr %self.addr.i24, align 8
  %20 = load i64, ptr %val.addr.i25, align 8
  %arrayidx.i26 = getelementptr inbounds [256 x i32], ptr %19, i64 0, i64 %20
  %21 = load i32, ptr %arrayidx.i26, align 4
  %inc.i27 = add i32 %21, 1
  store i32 %inc.i27, ptr %arrayidx.i26, align 4
  %22 = load ptr, ptr %self.addr.i24, align 8
  %total_count_.i28 = getelementptr inbounds %struct.HistogramLiteral, ptr %22, i32 0, i32 1
  %23 = load i64, ptr %total_count_.i28, align 8
  %inc1.i29 = add i64 %23, 1
  store i64 %inc1.i29, ptr %total_count_.i28, align 8
  %24 = load i64, ptr %pos, align 8
  %inc = add i64 %24, 1
  store i64 %inc, ptr %pos, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body5
  %25 = load i64, ptr %j, align 8
  %dec = add i64 %25, -1
  store i64 %dec, ptr %j, align 8
  br label %for.cond2, !llvm.loop !359

for.end:                                          ; preds = %for.cond2
  store ptr %cmd, ptr %self.addr.i20, align 8
  %26 = load ptr, ptr %self.addr.i20, align 8
  %copy_len_.i21 = getelementptr inbounds %struct.Command, ptr %26, i32 0, i32 1
  %27 = load i32, ptr %copy_len_.i21, align 4
  %and.i22 = and i32 %27, 33554431
  %conv8 = zext i32 %and.i22 to i64
  %28 = load i64, ptr %pos, align 8
  %add = add i64 %28, %conv8
  store i64 %add, ptr %pos, align 8
  store ptr %cmd, ptr %self.addr.i, align 8
  %29 = load ptr, ptr %self.addr.i, align 8
  %copy_len_.i = getelementptr inbounds %struct.Command, ptr %29, i32 0, i32 1
  %30 = load i32, ptr %copy_len_.i, align 4
  %and.i = and i32 %30, 33554431
  %tobool = icmp ne i32 %and.i, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.end
  %cmd_prefix_10 = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 3
  %31 = load i16, ptr %cmd_prefix_10, align 4
  %conv11 = zext i16 %31 to i32
  %cmp12 = icmp sge i32 %conv11, 128
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %32 = load ptr, ptr %dist_histo.addr, align 8
  %dist_prefix_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 4
  %33 = load i16, ptr %dist_prefix_, align 2
  %conv14 = zext i16 %33 to i32
  %and15 = and i32 %conv14, 1023
  %conv16 = sext i32 %and15 to i64
  store ptr %32, ptr %self.addr.i30, align 8
  store i64 %conv16, ptr %val.addr.i31, align 8
  %34 = load ptr, ptr %self.addr.i30, align 8
  %35 = load i64, ptr %val.addr.i31, align 8
  %arrayidx.i32 = getelementptr inbounds [544 x i32], ptr %34, i64 0, i64 %35
  %36 = load i32, ptr %arrayidx.i32, align 4
  %inc.i33 = add i32 %36, 1
  store i32 %inc.i33, ptr %arrayidx.i32, align 4
  %37 = load ptr, ptr %self.addr.i30, align 8
  %total_count_.i34 = getelementptr inbounds %struct.HistogramDistance, ptr %37, i32 0, i32 1
  %38 = load i64, ptr %total_count_.i34, align 8
  %inc1.i35 = add i64 %38, 1
  store i64 %inc1.i35, ptr %total_count_.i34, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.end
  br label %for.inc17

for.inc17:                                        ; preds = %if.end
  %39 = load i64, ptr %i, align 8
  %inc18 = add i64 %39, 1
  store i64 %inc18, ptr %i, align 8
  br label %for.cond, !llvm.loop !360

for.end19:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @BuildAndStoreHuffmanTree(ptr noundef %histogram, i64 noundef %histogram_length, i64 noundef %alphabet_size, ptr noundef %tree, ptr noundef %depth, ptr noundef %bits, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i36 = alloca ptr, align 8
  %v.addr.i37 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i23 = alloca i64, align 8
  %bits.addr.i24 = alloca i64, align 8
  %pos.addr.i25 = alloca ptr, align 8
  %array.addr.i26 = alloca ptr, align 8
  %p.i27 = alloca ptr, align 8
  %v.i28 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %histogram.addr = alloca ptr, align 8
  %histogram_length.addr = alloca i64, align 8
  %alphabet_size.addr = alloca i64, align 8
  %tree.addr = alloca ptr, align 8
  %depth.addr = alloca ptr, align 8
  %bits.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %count = alloca i64, align 8
  %s4 = alloca [4 x i64], align 16
  %i = alloca i64, align 8
  %max_bits = alloca i64, align 8
  %max_bits_counter = alloca i64, align 8
  store ptr %histogram, ptr %histogram.addr, align 8
  store i64 %histogram_length, ptr %histogram_length.addr, align 8
  store i64 %alphabet_size, ptr %alphabet_size.addr, align 8
  store ptr %tree, ptr %tree.addr, align 8
  store ptr %depth, ptr %depth.addr, align 8
  store ptr %bits, ptr %bits.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  store i64 0, ptr %count, align 8
  call void @llvm.memset.p0.i64(ptr align 16 %s4, i8 0, i64 32, i1 false)
  store i64 0, ptr %max_bits, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %1 = load i64, ptr %histogram_length.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %histogram.addr, align 8
  %3 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds i32, ptr %2, i64 %3
  %4 = load i32, ptr %arrayidx, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end7

if.then:                                          ; preds = %for.body
  %5 = load i64, ptr %count, align 8
  %cmp1 = icmp ult i64 %5, 4
  br i1 %cmp1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  %6 = load i64, ptr %i, align 8
  %7 = load i64, ptr %count, align 8
  %arrayidx3 = getelementptr inbounds [4 x i64], ptr %s4, i64 0, i64 %7
  store i64 %6, ptr %arrayidx3, align 8
  br label %if.end6

if.else:                                          ; preds = %if.then
  %8 = load i64, ptr %count, align 8
  %cmp4 = icmp ugt i64 %8, 4
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.else
  br label %for.end

if.end:                                           ; preds = %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then2
  %9 = load i64, ptr %count, align 8
  %inc = add i64 %9, 1
  store i64 %inc, ptr %count, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %10 = load i64, ptr %i, align 8
  %inc8 = add i64 %10, 1
  store i64 %inc8, ptr %i, align 8
  br label %for.cond, !llvm.loop !361

for.end:                                          ; preds = %if.then5, %for.cond
  %11 = load i64, ptr %alphabet_size.addr, align 8
  %sub = sub i64 %11, 1
  store i64 %sub, ptr %max_bits_counter, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %for.end
  %12 = load i64, ptr %max_bits_counter, align 8
  %tobool9 = icmp ne i64 %12, 0
  br i1 %tobool9, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %13 = load i64, ptr %max_bits_counter, align 8
  %shr = lshr i64 %13, 1
  store i64 %shr, ptr %max_bits_counter, align 8
  %14 = load i64, ptr %max_bits, align 8
  %inc10 = add i64 %14, 1
  store i64 %inc10, ptr %max_bits, align 8
  br label %while.cond, !llvm.loop !362

while.end:                                        ; preds = %while.cond
  %15 = load i64, ptr %count, align 8
  %cmp11 = icmp ule i64 %15, 1
  br i1 %cmp11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %while.end
  %16 = load ptr, ptr %storage_ix.addr, align 8
  %17 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !363)
  call void @llvm.experimental.noalias.scope.decl(metadata !366)
  store i64 4, ptr %n_bits.addr.i23, align 8, !noalias !368
  store i64 1, ptr %bits.addr.i24, align 8, !noalias !368
  store ptr %16, ptr %pos.addr.i25, align 8, !noalias !368
  store ptr %17, ptr %array.addr.i26, align 8, !noalias !368
  %18 = load ptr, ptr %array.addr.i26, align 8, !noalias !368
  %19 = load ptr, ptr %pos.addr.i25, align 8, !noalias !368
  %20 = load i64, ptr %19, align 8
  %shr.i29 = lshr i64 %20, 3
  %arrayidx.i30 = getelementptr inbounds i8, ptr %18, i64 %shr.i29
  store ptr %arrayidx.i30, ptr %p.i27, align 8, !noalias !368
  %21 = load ptr, ptr %p.i27, align 8, !noalias !368
  %22 = load i8, ptr %21, align 1
  %conv.i31 = zext i8 %22 to i64
  store i64 %conv.i31, ptr %v.i28, align 8, !noalias !368
  %23 = load i64, ptr %bits.addr.i24, align 8, !noalias !368
  %24 = load ptr, ptr %pos.addr.i25, align 8, !noalias !368
  %25 = load i64, ptr %24, align 8
  %and.i32 = and i64 %25, 7
  %shl.i33 = shl i64 %23, %and.i32
  %26 = load i64, ptr %v.i28, align 8, !noalias !368
  %or.i34 = or i64 %26, %shl.i33
  store i64 %or.i34, ptr %v.i28, align 8, !noalias !368
  %27 = load ptr, ptr %p.i27, align 8, !noalias !368
  %28 = load i64, ptr %v.i28, align 8, !noalias !368
  store ptr %27, ptr %p.addr.i, align 8
  store i64 %28, ptr %v.addr.i, align 8
  %29 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %29, ptr align 8 %v.addr.i, i64 8, i1 false)
  %30 = load i64, ptr %n_bits.addr.i23, align 8, !noalias !368
  %31 = load ptr, ptr %pos.addr.i25, align 8, !noalias !368
  %32 = load i64, ptr %31, align 8
  %add.i35 = add i64 %32, %30
  store i64 %add.i35, ptr %31, align 8
  %33 = load i64, ptr %max_bits, align 8
  %arrayidx13 = getelementptr inbounds [4 x i64], ptr %s4, i64 0, i64 0
  %34 = load i64, ptr %arrayidx13, align 16
  %35 = load ptr, ptr %storage_ix.addr, align 8
  %36 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !369)
  call void @llvm.experimental.noalias.scope.decl(metadata !372)
  store i64 %33, ptr %n_bits.addr.i, align 8, !noalias !374
  store i64 %34, ptr %bits.addr.i, align 8, !noalias !374
  store ptr %35, ptr %pos.addr.i, align 8, !noalias !374
  store ptr %36, ptr %array.addr.i, align 8, !noalias !374
  %37 = load ptr, ptr %array.addr.i, align 8, !noalias !374
  %38 = load ptr, ptr %pos.addr.i, align 8, !noalias !374
  %39 = load i64, ptr %38, align 8
  %shr.i = lshr i64 %39, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %37, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !374
  %40 = load ptr, ptr %p.i, align 8, !noalias !374
  %41 = load i8, ptr %40, align 1
  %conv.i = zext i8 %41 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !374
  %42 = load i64, ptr %bits.addr.i, align 8, !noalias !374
  %43 = load ptr, ptr %pos.addr.i, align 8, !noalias !374
  %44 = load i64, ptr %43, align 8
  %and.i = and i64 %44, 7
  %shl.i = shl i64 %42, %and.i
  %45 = load i64, ptr %v.i, align 8, !noalias !374
  %or.i = or i64 %45, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !374
  %46 = load ptr, ptr %p.i, align 8, !noalias !374
  %47 = load i64, ptr %v.i, align 8, !noalias !374
  store ptr %46, ptr %p.addr.i36, align 8
  store i64 %47, ptr %v.addr.i37, align 8
  %48 = load ptr, ptr %p.addr.i36, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %48, ptr align 8 %v.addr.i37, i64 8, i1 false)
  %49 = load i64, ptr %n_bits.addr.i, align 8, !noalias !374
  %50 = load ptr, ptr %pos.addr.i, align 8, !noalias !374
  %51 = load i64, ptr %50, align 8
  %add.i = add i64 %51, %49
  store i64 %add.i, ptr %50, align 8
  %52 = load ptr, ptr %depth.addr, align 8
  %arrayidx14 = getelementptr inbounds [4 x i64], ptr %s4, i64 0, i64 0
  %53 = load i64, ptr %arrayidx14, align 16
  %arrayidx15 = getelementptr inbounds i8, ptr %52, i64 %53
  store i8 0, ptr %arrayidx15, align 1
  %54 = load ptr, ptr %bits.addr, align 8
  %arrayidx16 = getelementptr inbounds [4 x i64], ptr %s4, i64 0, i64 0
  %55 = load i64, ptr %arrayidx16, align 16
  %arrayidx17 = getelementptr inbounds i16, ptr %54, i64 %55
  store i16 0, ptr %arrayidx17, align 2
  br label %if.end22

if.end18:                                         ; preds = %while.end
  %56 = load ptr, ptr %depth.addr, align 8
  %57 = load i64, ptr %histogram_length.addr, align 8
  %mul = mul i64 %57, 1
  call void @llvm.memset.p0.i64(ptr align 1 %56, i8 0, i64 %mul, i1 false)
  %58 = load ptr, ptr %histogram.addr, align 8
  %59 = load i64, ptr %histogram_length.addr, align 8
  %60 = load ptr, ptr %tree.addr, align 8
  %61 = load ptr, ptr %depth.addr, align 8
  call void @BrotliCreateHuffmanTree(ptr noundef %58, i64 noundef %59, i32 noundef 15, ptr noundef %60, ptr noundef %61)
  %62 = load ptr, ptr %depth.addr, align 8
  %63 = load i64, ptr %histogram_length.addr, align 8
  %64 = load ptr, ptr %bits.addr, align 8
  call void @BrotliConvertBitDepthsToSymbols(ptr noundef %62, i64 noundef %63, ptr noundef %64)
  %65 = load i64, ptr %count, align 8
  %cmp19 = icmp ule i64 %65, 4
  br i1 %cmp19, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.end18
  %66 = load ptr, ptr %depth.addr, align 8
  %arraydecay = getelementptr inbounds [4 x i64], ptr %s4, i64 0, i64 0
  %67 = load i64, ptr %count, align 8
  %68 = load i64, ptr %max_bits, align 8
  %69 = load ptr, ptr %storage_ix.addr, align 8
  %70 = load ptr, ptr %storage.addr, align 8
  call void @StoreSimpleHuffmanTree(ptr noundef %66, ptr noundef %arraydecay, i64 noundef %67, i64 noundef %68, ptr noundef %69, ptr noundef %70)
  br label %if.end22

if.else21:                                        ; preds = %if.end18
  %71 = load ptr, ptr %depth.addr, align 8
  %72 = load i64, ptr %histogram_length.addr, align 8
  %73 = load ptr, ptr %tree.addr, align 8
  %74 = load ptr, ptr %storage_ix.addr, align 8
  %75 = load ptr, ptr %storage.addr, align 8
  call void @BrotliStoreHuffmanTree(ptr noundef %71, i64 noundef %72, ptr noundef %73, ptr noundef %74, ptr noundef %75)
  br label %if.end22

if.end22:                                         ; preds = %if.else21, %if.then20, %if.then12
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @StoreDataWithHuffmanCodes(ptr noundef %input, i64 noundef %start_pos, i64 noundef %mask, ptr noundef %commands, i64 noundef %n_commands, ptr noundef %lit_depth, ptr noundef %lit_bits, ptr noundef %cmd_depth, ptr noundef %cmd_bits, ptr noundef %dist_depth, ptr noundef %dist_bits, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %copycode.addr.i129 = alloca i16, align 2
  %copycode.addr.i = alloca i16, align 2
  %inscode.addr.i124 = alloca i16, align 2
  %inscode.addr.i = alloca i16, align 2
  %n.addr.i19.i = alloca i64, align 8
  %n.addr.i.i106 = alloca i64, align 8
  %retval.i107 = alloca i16, align 2
  %copylen.addr.i = alloca i64, align 8
  %nbits.i108 = alloca i32, align 4
  %n.addr.i26.i = alloca i64, align 8
  %n.addr.i.i = alloca i64, align 8
  %retval.i = alloca i16, align 2
  %insertlen.addr.i = alloca i64, align 8
  %nbits.i = alloca i32, align 4
  %self.addr.i91 = alloca ptr, align 8
  %modifier.i = alloca i32, align 4
  %delta.i = alloca i32, align 4
  %p.addr.i89 = alloca ptr, align 8
  %v.addr.i90 = alloca i64, align 8
  %p.addr.i87 = alloca ptr, align 8
  %v.addr.i88 = alloca i64, align 8
  %p.addr.i85 = alloca ptr, align 8
  %v.addr.i86 = alloca i64, align 8
  %p.addr.i83 = alloca ptr, align 8
  %v.addr.i84 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %self.addr.i80 = alloca ptr, align 8
  %self.addr.i = alloca ptr, align 8
  %n_bits.addr.i.i = alloca i64, align 8
  %bits.addr.i.i = alloca i64, align 8
  %pos.addr.i.i = alloca ptr, align 8
  %array.addr.i.i = alloca ptr, align 8
  %p.i.i = alloca ptr, align 8
  %v.i.i = alloca i64, align 8
  %cmd.addr.i = alloca ptr, align 8
  %storage_ix.addr.i = alloca ptr, align 8
  %storage.addr.i = alloca ptr, align 8
  %copylen_code.i = alloca i32, align 4
  %inscode.i = alloca i16, align 2
  %copycode.i = alloca i16, align 2
  %insnumextra.i = alloca i32, align 4
  %insextraval.i = alloca i64, align 8
  %copyextraval.i = alloca i64, align 8
  %bits.i = alloca i64, align 8
  %n_bits.addr.i62 = alloca i64, align 8
  %bits.addr.i63 = alloca i64, align 8
  %pos.addr.i64 = alloca ptr, align 8
  %array.addr.i65 = alloca ptr, align 8
  %p.i66 = alloca ptr, align 8
  %v.i67 = alloca i64, align 8
  %n_bits.addr.i49 = alloca i64, align 8
  %bits.addr.i50 = alloca i64, align 8
  %pos.addr.i51 = alloca ptr, align 8
  %array.addr.i52 = alloca ptr, align 8
  %p.i53 = alloca ptr, align 8
  %v.i54 = alloca i64, align 8
  %n_bits.addr.i36 = alloca i64, align 8
  %bits.addr.i37 = alloca i64, align 8
  %pos.addr.i38 = alloca ptr, align 8
  %array.addr.i39 = alloca ptr, align 8
  %p.i40 = alloca ptr, align 8
  %v.i41 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %input.addr = alloca ptr, align 8
  %start_pos.addr = alloca i64, align 8
  %mask.addr = alloca i64, align 8
  %commands.addr = alloca ptr, align 8
  %n_commands.addr = alloca i64, align 8
  %lit_depth.addr = alloca ptr, align 8
  %lit_bits.addr = alloca ptr, align 8
  %cmd_depth.addr = alloca ptr, align 8
  %cmd_bits.addr = alloca ptr, align 8
  %dist_depth.addr = alloca ptr, align 8
  %dist_bits.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %pos = alloca i64, align 8
  %i = alloca i64, align 8
  %cmd = alloca %struct.Command, align 4
  %cmd_code = alloca i64, align 8
  %j = alloca i64, align 8
  %literal = alloca i8, align 1
  %dist_code = alloca i64, align 8
  %distnumextra = alloca i32, align 4
  %distextra = alloca i32, align 4
  store ptr %input, ptr %input.addr, align 8
  store i64 %start_pos, ptr %start_pos.addr, align 8
  store i64 %mask, ptr %mask.addr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  store i64 %n_commands, ptr %n_commands.addr, align 8
  store ptr %lit_depth, ptr %lit_depth.addr, align 8
  store ptr %lit_bits, ptr %lit_bits.addr, align 8
  store ptr %cmd_depth, ptr %cmd_depth.addr, align 8
  store ptr %cmd_bits, ptr %cmd_bits.addr, align 8
  store ptr %dist_depth, ptr %dist_depth.addr, align 8
  store ptr %dist_bits, ptr %dist_bits.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load i64, ptr %start_pos.addr, align 8
  store i64 %0, ptr %pos, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc33, %entry
  %1 = load i64, ptr %i, align 8
  %2 = load i64, ptr %n_commands.addr, align 8
  %cmp = icmp ult i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end35

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %commands.addr, align 8
  %4 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds %struct.Command, ptr %3, i64 %4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %cmd, ptr align 4 %arrayidx, i64 16, i1 false)
  %cmd_prefix_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 3
  %5 = load i16, ptr %cmd_prefix_, align 4
  %conv = zext i16 %5 to i64
  store i64 %conv, ptr %cmd_code, align 8
  %6 = load ptr, ptr %cmd_depth.addr, align 8
  %7 = load i64, ptr %cmd_code, align 8
  %arrayidx1 = getelementptr inbounds i8, ptr %6, i64 %7
  %8 = load i8, ptr %arrayidx1, align 1
  %conv2 = zext i8 %8 to i64
  %9 = load ptr, ptr %cmd_bits.addr, align 8
  %10 = load i64, ptr %cmd_code, align 8
  %arrayidx3 = getelementptr inbounds i16, ptr %9, i64 %10
  %11 = load i16, ptr %arrayidx3, align 2
  %conv4 = zext i16 %11 to i64
  %12 = load ptr, ptr %storage_ix.addr, align 8
  %13 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !375)
  call void @llvm.experimental.noalias.scope.decl(metadata !378)
  store i64 %conv2, ptr %n_bits.addr.i62, align 8, !noalias !380
  store i64 %conv4, ptr %bits.addr.i63, align 8, !noalias !380
  store ptr %12, ptr %pos.addr.i64, align 8, !noalias !380
  store ptr %13, ptr %array.addr.i65, align 8, !noalias !380
  %14 = load ptr, ptr %array.addr.i65, align 8, !noalias !380
  %15 = load ptr, ptr %pos.addr.i64, align 8, !noalias !380
  %16 = load i64, ptr %15, align 8
  %shr.i68 = lshr i64 %16, 3
  %arrayidx.i69 = getelementptr inbounds i8, ptr %14, i64 %shr.i68
  store ptr %arrayidx.i69, ptr %p.i66, align 8, !noalias !380
  %17 = load ptr, ptr %p.i66, align 8, !noalias !380
  %18 = load i8, ptr %17, align 1
  %conv.i70 = zext i8 %18 to i64
  store i64 %conv.i70, ptr %v.i67, align 8, !noalias !380
  %19 = load i64, ptr %bits.addr.i63, align 8, !noalias !380
  %20 = load ptr, ptr %pos.addr.i64, align 8, !noalias !380
  %21 = load i64, ptr %20, align 8
  %and.i71 = and i64 %21, 7
  %shl.i72 = shl i64 %19, %and.i71
  %22 = load i64, ptr %v.i67, align 8, !noalias !380
  %or.i73 = or i64 %22, %shl.i72
  store i64 %or.i73, ptr %v.i67, align 8, !noalias !380
  %23 = load ptr, ptr %p.i66, align 8, !noalias !380
  %24 = load i64, ptr %v.i67, align 8, !noalias !380
  store ptr %23, ptr %p.addr.i83, align 8
  store i64 %24, ptr %v.addr.i84, align 8
  %25 = load ptr, ptr %p.addr.i83, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %25, ptr align 8 %v.addr.i84, i64 8, i1 false)
  %26 = load i64, ptr %n_bits.addr.i62, align 8, !noalias !380
  %27 = load ptr, ptr %pos.addr.i64, align 8, !noalias !380
  %28 = load i64, ptr %27, align 8
  %add.i74 = add i64 %28, %26
  store i64 %add.i74, ptr %27, align 8
  %29 = load ptr, ptr %storage_ix.addr, align 8
  %30 = load ptr, ptr %storage.addr, align 8
  store ptr %cmd, ptr %cmd.addr.i, align 8
  store ptr %29, ptr %storage_ix.addr.i, align 8
  store ptr %30, ptr %storage.addr.i, align 8
  %31 = load ptr, ptr %cmd.addr.i, align 8
  store ptr %31, ptr %self.addr.i91, align 8
  %32 = load ptr, ptr %self.addr.i91, align 8
  %copy_len_.i92 = getelementptr inbounds %struct.Command, ptr %32, i32 0, i32 1
  %33 = load i32, ptr %copy_len_.i92, align 4
  %shr.i93 = lshr i32 %33, 25
  store i32 %shr.i93, ptr %modifier.i, align 4
  %34 = load i32, ptr %modifier.i, align 4
  %35 = load i32, ptr %modifier.i, align 4
  %and.i94 = and i32 %35, 64
  %shl.i95 = shl i32 %and.i94, 1
  %or.i96 = or i32 %34, %shl.i95
  %conv.i97 = trunc i32 %or.i96 to i8
  %conv1.i = sext i8 %conv.i97 to i32
  store i32 %conv1.i, ptr %delta.i, align 4
  %36 = load ptr, ptr %self.addr.i91, align 8
  %copy_len_2.i = getelementptr inbounds %struct.Command, ptr %36, i32 0, i32 1
  %37 = load i32, ptr %copy_len_2.i, align 4
  %and3.i = and i32 %37, 33554431
  %38 = load i32, ptr %delta.i, align 4
  %add.i98 = add nsw i32 %and3.i, %38
  store i32 %add.i98, ptr %copylen_code.i, align 4
  %39 = load ptr, ptr %cmd.addr.i, align 8
  %40 = load i32, ptr %39, align 4
  %conv.i75 = zext i32 %40 to i64
  store i64 %conv.i75, ptr %insertlen.addr.i, align 8
  %41 = load i64, ptr %insertlen.addr.i, align 8
  %cmp.i = icmp ult i64 %41, 6
  br i1 %cmp.i, label %if.then.i, label %if.else.i

if.then.i:                                        ; preds = %for.body
  %42 = load i64, ptr %insertlen.addr.i, align 8
  %conv.i105 = trunc i64 %42 to i16
  store i16 %conv.i105, ptr %retval.i, align 2
  br label %GetInsertLengthCode.exit

if.else.i:                                        ; preds = %for.body
  %43 = load i64, ptr %insertlen.addr.i, align 8
  %cmp1.i = icmp ult i64 %43, 130
  br i1 %cmp1.i, label %if.then3.i, label %if.else9.i

if.then3.i:                                       ; preds = %if.else.i
  %44 = load i64, ptr %insertlen.addr.i, align 8
  %sub.i100 = sub i64 %44, 2
  store i64 %sub.i100, ptr %n.addr.i26.i, align 8
  %45 = load i64, ptr %n.addr.i26.i, align 8
  %conv.i27.i = trunc i64 %45 to i32
  %46 = call i32 @llvm.ctlz.i32(i32 %conv.i27.i, i1 true)
  %xor.i28.i = xor i32 31, %46
  %sub4.i = sub i32 %xor.i28.i, 1
  store i32 %sub4.i, ptr %nbits.i, align 4
  %47 = load i32, ptr %nbits.i, align 4
  %shl.i101 = shl i32 %47, 1
  %conv5.i = zext i32 %shl.i101 to i64
  %48 = load i64, ptr %insertlen.addr.i, align 8
  %sub6.i = sub i64 %48, 2
  %49 = load i32, ptr %nbits.i, align 4
  %sh_prom.i102 = zext i32 %49 to i64
  %shr.i103 = lshr i64 %sub6.i, %sh_prom.i102
  %add.i104 = add i64 %conv5.i, %shr.i103
  %add7.i = add i64 %add.i104, 2
  %conv8.i = trunc i64 %add7.i to i16
  store i16 %conv8.i, ptr %retval.i, align 2
  br label %GetInsertLengthCode.exit

if.else9.i:                                       ; preds = %if.else.i
  %50 = load i64, ptr %insertlen.addr.i, align 8
  %cmp10.i = icmp ult i64 %50, 2114
  br i1 %cmp10.i, label %if.then12.i, label %if.else17.i

if.then12.i:                                      ; preds = %if.else9.i
  %51 = load i64, ptr %insertlen.addr.i, align 8
  %sub13.i = sub i64 %51, 66
  store i64 %sub13.i, ptr %n.addr.i.i, align 8
  %52 = load i64, ptr %n.addr.i.i, align 8
  %conv.i.i99 = trunc i64 %52 to i32
  %53 = call i32 @llvm.ctlz.i32(i32 %conv.i.i99, i1 true)
  %xor.i.i = xor i32 31, %53
  %add15.i = add i32 %xor.i.i, 10
  %conv16.i = trunc i32 %add15.i to i16
  store i16 %conv16.i, ptr %retval.i, align 2
  br label %GetInsertLengthCode.exit

if.else17.i:                                      ; preds = %if.else9.i
  %54 = load i64, ptr %insertlen.addr.i, align 8
  %cmp18.i = icmp ult i64 %54, 6210
  br i1 %cmp18.i, label %if.then20.i, label %if.else21.i

if.then20.i:                                      ; preds = %if.else17.i
  store i16 21, ptr %retval.i, align 2
  br label %GetInsertLengthCode.exit

if.else21.i:                                      ; preds = %if.else17.i
  %55 = load i64, ptr %insertlen.addr.i, align 8
  %cmp22.i = icmp ult i64 %55, 22594
  br i1 %cmp22.i, label %if.then24.i, label %if.else25.i

if.then24.i:                                      ; preds = %if.else21.i
  store i16 22, ptr %retval.i, align 2
  br label %GetInsertLengthCode.exit

if.else25.i:                                      ; preds = %if.else21.i
  store i16 23, ptr %retval.i, align 2
  br label %GetInsertLengthCode.exit

GetInsertLengthCode.exit:                         ; preds = %if.else25.i, %if.then24.i, %if.then20.i, %if.then12.i, %if.then3.i, %if.then.i
  %56 = load i16, ptr %retval.i, align 2
  store i16 %56, ptr %inscode.i, align 2
  %57 = load i32, ptr %copylen_code.i, align 4
  %conv2.i = zext i32 %57 to i64
  store i64 %conv2.i, ptr %copylen.addr.i, align 8
  %58 = load i64, ptr %copylen.addr.i, align 8
  %cmp.i109 = icmp ult i64 %58, 10
  br i1 %cmp.i109, label %if.then.i120, label %if.else.i110

if.then.i120:                                     ; preds = %GetInsertLengthCode.exit
  %59 = load i64, ptr %copylen.addr.i, align 8
  %sub.i121 = sub i64 %59, 2
  %conv.i122 = trunc i64 %sub.i121 to i16
  store i16 %conv.i122, ptr %retval.i107, align 2
  br label %GetCopyLengthCode.exit

if.else.i110:                                     ; preds = %GetInsertLengthCode.exit
  %60 = load i64, ptr %copylen.addr.i, align 8
  %cmp1.i111 = icmp ult i64 %60, 134
  br i1 %cmp1.i111, label %if.then3.i114, label %if.else10.i

if.then3.i114:                                    ; preds = %if.else.i110
  %61 = load i64, ptr %copylen.addr.i, align 8
  %sub4.i115 = sub i64 %61, 6
  store i64 %sub4.i115, ptr %n.addr.i19.i, align 8
  %62 = load i64, ptr %n.addr.i19.i, align 8
  %conv.i20.i = trunc i64 %62 to i32
  %63 = call i32 @llvm.ctlz.i32(i32 %conv.i20.i, i1 true)
  %xor.i21.i = xor i32 31, %63
  %sub5.i = sub i32 %xor.i21.i, 1
  store i32 %sub5.i, ptr %nbits.i108, align 4
  %64 = load i32, ptr %nbits.i108, align 4
  %shl.i116 = shl i32 %64, 1
  %conv6.i = zext i32 %shl.i116 to i64
  %65 = load i64, ptr %copylen.addr.i, align 8
  %sub7.i = sub i64 %65, 6
  %66 = load i32, ptr %nbits.i108, align 4
  %sh_prom.i117 = zext i32 %66 to i64
  %shr.i118 = lshr i64 %sub7.i, %sh_prom.i117
  %add.i119 = add i64 %conv6.i, %shr.i118
  %add8.i = add i64 %add.i119, 4
  %conv9.i = trunc i64 %add8.i to i16
  store i16 %conv9.i, ptr %retval.i107, align 2
  br label %GetCopyLengthCode.exit

if.else10.i:                                      ; preds = %if.else.i110
  %67 = load i64, ptr %copylen.addr.i, align 8
  %cmp11.i = icmp ult i64 %67, 2118
  br i1 %cmp11.i, label %if.then13.i, label %if.else18.i

if.then13.i:                                      ; preds = %if.else10.i
  %68 = load i64, ptr %copylen.addr.i, align 8
  %sub14.i = sub i64 %68, 70
  store i64 %sub14.i, ptr %n.addr.i.i106, align 8
  %69 = load i64, ptr %n.addr.i.i106, align 8
  %conv.i.i112 = trunc i64 %69 to i32
  %70 = call i32 @llvm.ctlz.i32(i32 %conv.i.i112, i1 true)
  %xor.i.i113 = xor i32 31, %70
  %add16.i = add i32 %xor.i.i113, 12
  %conv17.i = trunc i32 %add16.i to i16
  store i16 %conv17.i, ptr %retval.i107, align 2
  br label %GetCopyLengthCode.exit

if.else18.i:                                      ; preds = %if.else10.i
  store i16 23, ptr %retval.i107, align 2
  br label %GetCopyLengthCode.exit

GetCopyLengthCode.exit:                           ; preds = %if.else18.i, %if.then13.i, %if.then3.i114, %if.then.i120
  %71 = load i16, ptr %retval.i107, align 2
  store i16 %71, ptr %copycode.i, align 2
  %72 = load i16, ptr %inscode.i, align 2
  store i16 %72, ptr %inscode.addr.i, align 2
  %73 = load i16, ptr %inscode.addr.i, align 2
  %idxprom.i = zext i16 %73 to i64
  %arrayidx.i123 = getelementptr inbounds [24 x i32], ptr @kBrotliInsExtra, i64 0, i64 %idxprom.i
  %74 = load i32, ptr %arrayidx.i123, align 4
  store i32 %74, ptr %insnumextra.i, align 4
  %75 = load ptr, ptr %cmd.addr.i, align 8
  %76 = load i32, ptr %75, align 4
  %77 = load i16, ptr %inscode.i, align 2
  store i16 %77, ptr %inscode.addr.i124, align 2
  %78 = load i16, ptr %inscode.addr.i124, align 2
  %idxprom.i125 = zext i16 %78 to i64
  %arrayidx.i126 = getelementptr inbounds [24 x i32], ptr @kBrotliInsBase, i64 0, i64 %idxprom.i125
  %79 = load i32, ptr %arrayidx.i126, align 4
  %sub.i = sub i32 %76, %79
  %conv7.i = zext i32 %sub.i to i64
  store i64 %conv7.i, ptr %insextraval.i, align 8
  %80 = load i32, ptr %copylen_code.i, align 4
  %81 = load i16, ptr %copycode.i, align 2
  store i16 %81, ptr %copycode.addr.i, align 2
  %82 = load i16, ptr %copycode.addr.i, align 2
  %idxprom.i127 = zext i16 %82 to i64
  %arrayidx.i128 = getelementptr inbounds [24 x i32], ptr @kBrotliCopyBase, i64 0, i64 %idxprom.i127
  %83 = load i32, ptr %arrayidx.i128, align 4
  %sub9.i = sub i32 %80, %83
  %conv10.i = zext i32 %sub9.i to i64
  store i64 %conv10.i, ptr %copyextraval.i, align 8
  %84 = load i64, ptr %copyextraval.i, align 8
  %85 = load i32, ptr %insnumextra.i, align 4
  %sh_prom.i = zext i32 %85 to i64
  %shl.i76 = shl i64 %84, %sh_prom.i
  %86 = load i64, ptr %insextraval.i, align 8
  %or.i77 = or i64 %shl.i76, %86
  store i64 %or.i77, ptr %bits.i, align 8
  %87 = load i32, ptr %insnumextra.i, align 4
  %88 = load i16, ptr %copycode.i, align 2
  store i16 %88, ptr %copycode.addr.i129, align 2
  %89 = load i16, ptr %copycode.addr.i129, align 2
  %idxprom.i130 = zext i16 %89 to i64
  %arrayidx.i131 = getelementptr inbounds [24 x i32], ptr @kBrotliCopyExtra, i64 0, i64 %idxprom.i130
  %90 = load i32, ptr %arrayidx.i131, align 4
  %add.i78 = add i32 %87, %90
  %conv12.i = zext i32 %add.i78 to i64
  %91 = load i64, ptr %bits.i, align 8
  %92 = load ptr, ptr %storage_ix.addr.i, align 8
  %93 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !381)
  call void @llvm.experimental.noalias.scope.decl(metadata !384)
  store i64 %conv12.i, ptr %n_bits.addr.i.i, align 8, !noalias !386
  store i64 %91, ptr %bits.addr.i.i, align 8, !noalias !386
  store ptr %92, ptr %pos.addr.i.i, align 8, !noalias !386
  store ptr %93, ptr %array.addr.i.i, align 8, !noalias !386
  %94 = load ptr, ptr %array.addr.i.i, align 8, !noalias !386
  %95 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !386
  %96 = load i64, ptr %95, align 8
  %shr.i.i = lshr i64 %96, 3
  %arrayidx.i.i = getelementptr inbounds i8, ptr %94, i64 %shr.i.i
  store ptr %arrayidx.i.i, ptr %p.i.i, align 8, !noalias !386
  %97 = load ptr, ptr %p.i.i, align 8, !noalias !386
  %98 = load i8, ptr %97, align 1
  %conv.i.i = zext i8 %98 to i64
  store i64 %conv.i.i, ptr %v.i.i, align 8, !noalias !386
  %99 = load i64, ptr %bits.addr.i.i, align 8, !noalias !386
  %100 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !386
  %101 = load i64, ptr %100, align 8
  %and.i.i = and i64 %101, 7
  %shl.i.i = shl i64 %99, %and.i.i
  %102 = load i64, ptr %v.i.i, align 8, !noalias !386
  %or.i.i = or i64 %102, %shl.i.i
  store i64 %or.i.i, ptr %v.i.i, align 8, !noalias !386
  %103 = load ptr, ptr %p.i.i, align 8, !noalias !386
  %104 = load i64, ptr %v.i.i, align 8, !noalias !386
  store ptr %103, ptr %p.addr.i, align 8
  store i64 %104, ptr %v.addr.i, align 8
  %105 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %105, ptr align 8 %v.addr.i, i64 8, i1 false)
  %106 = load i64, ptr %n_bits.addr.i.i, align 8, !noalias !386
  %107 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !386
  %108 = load i64, ptr %107, align 8
  %add.i.i = add i64 %108, %106
  store i64 %add.i.i, ptr %107, align 8
  %insert_len_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 0
  %109 = load i32, ptr %insert_len_, align 4
  %conv5 = zext i32 %109 to i64
  store i64 %conv5, ptr %j, align 8
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %GetCopyLengthCode.exit
  %110 = load i64, ptr %j, align 8
  %cmp7 = icmp ne i64 %110, 0
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %111 = load ptr, ptr %input.addr, align 8
  %112 = load i64, ptr %pos, align 8
  %113 = load i64, ptr %mask.addr, align 8
  %and = and i64 %112, %113
  %arrayidx10 = getelementptr inbounds i8, ptr %111, i64 %and
  %114 = load i8, ptr %arrayidx10, align 1
  store i8 %114, ptr %literal, align 1
  %115 = load ptr, ptr %lit_depth.addr, align 8
  %116 = load i8, ptr %literal, align 1
  %idxprom = zext i8 %116 to i64
  %arrayidx11 = getelementptr inbounds i8, ptr %115, i64 %idxprom
  %117 = load i8, ptr %arrayidx11, align 1
  %conv12 = zext i8 %117 to i64
  %118 = load ptr, ptr %lit_bits.addr, align 8
  %119 = load i8, ptr %literal, align 1
  %idxprom13 = zext i8 %119 to i64
  %arrayidx14 = getelementptr inbounds i16, ptr %118, i64 %idxprom13
  %120 = load i16, ptr %arrayidx14, align 2
  %conv15 = zext i16 %120 to i64
  %121 = load ptr, ptr %storage_ix.addr, align 8
  %122 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !387)
  call void @llvm.experimental.noalias.scope.decl(metadata !390)
  store i64 %conv12, ptr %n_bits.addr.i49, align 8, !noalias !392
  store i64 %conv15, ptr %bits.addr.i50, align 8, !noalias !392
  store ptr %121, ptr %pos.addr.i51, align 8, !noalias !392
  store ptr %122, ptr %array.addr.i52, align 8, !noalias !392
  %123 = load ptr, ptr %array.addr.i52, align 8, !noalias !392
  %124 = load ptr, ptr %pos.addr.i51, align 8, !noalias !392
  %125 = load i64, ptr %124, align 8
  %shr.i55 = lshr i64 %125, 3
  %arrayidx.i56 = getelementptr inbounds i8, ptr %123, i64 %shr.i55
  store ptr %arrayidx.i56, ptr %p.i53, align 8, !noalias !392
  %126 = load ptr, ptr %p.i53, align 8, !noalias !392
  %127 = load i8, ptr %126, align 1
  %conv.i57 = zext i8 %127 to i64
  store i64 %conv.i57, ptr %v.i54, align 8, !noalias !392
  %128 = load i64, ptr %bits.addr.i50, align 8, !noalias !392
  %129 = load ptr, ptr %pos.addr.i51, align 8, !noalias !392
  %130 = load i64, ptr %129, align 8
  %and.i58 = and i64 %130, 7
  %shl.i59 = shl i64 %128, %and.i58
  %131 = load i64, ptr %v.i54, align 8, !noalias !392
  %or.i60 = or i64 %131, %shl.i59
  store i64 %or.i60, ptr %v.i54, align 8, !noalias !392
  %132 = load ptr, ptr %p.i53, align 8, !noalias !392
  %133 = load i64, ptr %v.i54, align 8, !noalias !392
  store ptr %132, ptr %p.addr.i85, align 8
  store i64 %133, ptr %v.addr.i86, align 8
  %134 = load ptr, ptr %p.addr.i85, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %134, ptr align 8 %v.addr.i86, i64 8, i1 false)
  %135 = load i64, ptr %n_bits.addr.i49, align 8, !noalias !392
  %136 = load ptr, ptr %pos.addr.i51, align 8, !noalias !392
  %137 = load i64, ptr %136, align 8
  %add.i61 = add i64 %137, %135
  store i64 %add.i61, ptr %136, align 8
  %138 = load i64, ptr %pos, align 8
  %inc = add i64 %138, 1
  store i64 %inc, ptr %pos, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %139 = load i64, ptr %j, align 8
  %dec = add i64 %139, -1
  store i64 %dec, ptr %j, align 8
  br label %for.cond6, !llvm.loop !393

for.end:                                          ; preds = %for.cond6
  store ptr %cmd, ptr %self.addr.i80, align 8
  %140 = load ptr, ptr %self.addr.i80, align 8
  %copy_len_.i81 = getelementptr inbounds %struct.Command, ptr %140, i32 0, i32 1
  %141 = load i32, ptr %copy_len_.i81, align 4
  %and.i82 = and i32 %141, 33554431
  %conv16 = zext i32 %and.i82 to i64
  %142 = load i64, ptr %pos, align 8
  %add = add i64 %142, %conv16
  store i64 %add, ptr %pos, align 8
  store ptr %cmd, ptr %self.addr.i, align 8
  %143 = load ptr, ptr %self.addr.i, align 8
  %copy_len_.i = getelementptr inbounds %struct.Command, ptr %143, i32 0, i32 1
  %144 = load i32, ptr %copy_len_.i, align 4
  %and.i79 = and i32 %144, 33554431
  %tobool = icmp ne i32 %and.i79, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.end
  %cmd_prefix_18 = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 3
  %145 = load i16, ptr %cmd_prefix_18, align 4
  %conv19 = zext i16 %145 to i32
  %cmp20 = icmp sge i32 %conv19, 128
  br i1 %cmp20, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %dist_prefix_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 4
  %146 = load i16, ptr %dist_prefix_, align 2
  %conv22 = zext i16 %146 to i32
  %and23 = and i32 %conv22, 1023
  %conv24 = sext i32 %and23 to i64
  store i64 %conv24, ptr %dist_code, align 8
  %dist_prefix_25 = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 4
  %147 = load i16, ptr %dist_prefix_25, align 2
  %conv26 = zext i16 %147 to i32
  %shr = ashr i32 %conv26, 10
  store i32 %shr, ptr %distnumextra, align 4
  %dist_extra_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 2
  %148 = load i32, ptr %dist_extra_, align 4
  store i32 %148, ptr %distextra, align 4
  %149 = load ptr, ptr %dist_depth.addr, align 8
  %150 = load i64, ptr %dist_code, align 8
  %arrayidx27 = getelementptr inbounds i8, ptr %149, i64 %150
  %151 = load i8, ptr %arrayidx27, align 1
  %conv28 = zext i8 %151 to i64
  %152 = load ptr, ptr %dist_bits.addr, align 8
  %153 = load i64, ptr %dist_code, align 8
  %arrayidx29 = getelementptr inbounds i16, ptr %152, i64 %153
  %154 = load i16, ptr %arrayidx29, align 2
  %conv30 = zext i16 %154 to i64
  %155 = load ptr, ptr %storage_ix.addr, align 8
  %156 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !394)
  call void @llvm.experimental.noalias.scope.decl(metadata !397)
  store i64 %conv28, ptr %n_bits.addr.i36, align 8, !noalias !399
  store i64 %conv30, ptr %bits.addr.i37, align 8, !noalias !399
  store ptr %155, ptr %pos.addr.i38, align 8, !noalias !399
  store ptr %156, ptr %array.addr.i39, align 8, !noalias !399
  %157 = load ptr, ptr %array.addr.i39, align 8, !noalias !399
  %158 = load ptr, ptr %pos.addr.i38, align 8, !noalias !399
  %159 = load i64, ptr %158, align 8
  %shr.i42 = lshr i64 %159, 3
  %arrayidx.i43 = getelementptr inbounds i8, ptr %157, i64 %shr.i42
  store ptr %arrayidx.i43, ptr %p.i40, align 8, !noalias !399
  %160 = load ptr, ptr %p.i40, align 8, !noalias !399
  %161 = load i8, ptr %160, align 1
  %conv.i44 = zext i8 %161 to i64
  store i64 %conv.i44, ptr %v.i41, align 8, !noalias !399
  %162 = load i64, ptr %bits.addr.i37, align 8, !noalias !399
  %163 = load ptr, ptr %pos.addr.i38, align 8, !noalias !399
  %164 = load i64, ptr %163, align 8
  %and.i45 = and i64 %164, 7
  %shl.i46 = shl i64 %162, %and.i45
  %165 = load i64, ptr %v.i41, align 8, !noalias !399
  %or.i47 = or i64 %165, %shl.i46
  store i64 %or.i47, ptr %v.i41, align 8, !noalias !399
  %166 = load ptr, ptr %p.i40, align 8, !noalias !399
  %167 = load i64, ptr %v.i41, align 8, !noalias !399
  store ptr %166, ptr %p.addr.i87, align 8
  store i64 %167, ptr %v.addr.i88, align 8
  %168 = load ptr, ptr %p.addr.i87, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %168, ptr align 8 %v.addr.i88, i64 8, i1 false)
  %169 = load i64, ptr %n_bits.addr.i36, align 8, !noalias !399
  %170 = load ptr, ptr %pos.addr.i38, align 8, !noalias !399
  %171 = load i64, ptr %170, align 8
  %add.i48 = add i64 %171, %169
  store i64 %add.i48, ptr %170, align 8
  %172 = load i32, ptr %distnumextra, align 4
  %conv31 = zext i32 %172 to i64
  %173 = load i32, ptr %distextra, align 4
  %conv32 = zext i32 %173 to i64
  %174 = load ptr, ptr %storage_ix.addr, align 8
  %175 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !400)
  call void @llvm.experimental.noalias.scope.decl(metadata !403)
  store i64 %conv31, ptr %n_bits.addr.i, align 8, !noalias !405
  store i64 %conv32, ptr %bits.addr.i, align 8, !noalias !405
  store ptr %174, ptr %pos.addr.i, align 8, !noalias !405
  store ptr %175, ptr %array.addr.i, align 8, !noalias !405
  %176 = load ptr, ptr %array.addr.i, align 8, !noalias !405
  %177 = load ptr, ptr %pos.addr.i, align 8, !noalias !405
  %178 = load i64, ptr %177, align 8
  %shr.i = lshr i64 %178, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %176, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !405
  %179 = load ptr, ptr %p.i, align 8, !noalias !405
  %180 = load i8, ptr %179, align 1
  %conv.i = zext i8 %180 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !405
  %181 = load i64, ptr %bits.addr.i, align 8, !noalias !405
  %182 = load ptr, ptr %pos.addr.i, align 8, !noalias !405
  %183 = load i64, ptr %182, align 8
  %and.i = and i64 %183, 7
  %shl.i = shl i64 %181, %and.i
  %184 = load i64, ptr %v.i, align 8, !noalias !405
  %or.i = or i64 %184, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !405
  %185 = load ptr, ptr %p.i, align 8, !noalias !405
  %186 = load i64, ptr %v.i, align 8, !noalias !405
  store ptr %185, ptr %p.addr.i89, align 8
  store i64 %186, ptr %v.addr.i90, align 8
  %187 = load ptr, ptr %p.addr.i89, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %187, ptr align 8 %v.addr.i90, i64 8, i1 false)
  %188 = load i64, ptr %n_bits.addr.i, align 8, !noalias !405
  %189 = load ptr, ptr %pos.addr.i, align 8, !noalias !405
  %190 = load i64, ptr %189, align 8
  %add.i = add i64 %190, %188
  store i64 %add.i, ptr %189, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.end
  br label %for.inc33

for.inc33:                                        ; preds = %if.end
  %191 = load i64, ptr %i, align 8
  %inc34 = add i64 %191, 1
  store i64 %inc34, ptr %i, align 8
  br label %for.cond, !llvm.loop !406

for.end35:                                        ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @BrotliStoreMetaBlockFast(ptr noundef %m, ptr noundef %input, i64 noundef %start_pos, i64 noundef %length, i64 noundef %mask, i32 noundef %is_last, ptr noundef %params, ptr noundef %commands, i64 noundef %n_commands, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i102 = alloca ptr, align 8
  %v.addr.i103 = alloca i64, align 8
  %p.addr.i100 = alloca ptr, align 8
  %v.addr.i101 = alloca i64, align 8
  %p.addr.i98 = alloca ptr, align 8
  %v.addr.i99 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i.i83 = alloca i64, align 8
  %bits.addr.i.i84 = alloca i64, align 8
  %pos.addr.i.i85 = alloca ptr, align 8
  %array.addr.i.i86 = alloca ptr, align 8
  %p.i.i87 = alloca ptr, align 8
  %v.i.i88 = alloca i64, align 8
  %storage_ix.addr.i89 = alloca ptr, align 8
  %storage.addr.i90 = alloca ptr, align 8
  %n_bits.addr.i1.i = alloca i64, align 8
  %bits.addr.i2.i = alloca i64, align 8
  %pos.addr.i3.i = alloca ptr, align 8
  %array.addr.i4.i = alloca ptr, align 8
  %p.i5.i = alloca ptr, align 8
  %v.i6.i = alloca i64, align 8
  %n_bits.addr.i.i = alloca i64, align 8
  %bits.addr.i.i = alloca i64, align 8
  %pos.addr.i.i = alloca ptr, align 8
  %array.addr.i.i = alloca ptr, align 8
  %p.i.i = alloca ptr, align 8
  %v.i.i = alloca i64, align 8
  %storage_ix.addr.i = alloca ptr, align 8
  %storage.addr.i = alloca ptr, align 8
  %n.addr.i = alloca i64, align 8
  %self.addr.i79 = alloca ptr, align 8
  %self.addr.i76 = alloca ptr, align 8
  %self.addr.i75 = alloca ptr, align 8
  %self.addr.i = alloca ptr, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %m.addr = alloca ptr, align 8
  %input.addr = alloca ptr, align 8
  %start_pos.addr = alloca i64, align 8
  %length.addr = alloca i64, align 8
  %mask.addr = alloca i64, align 8
  %is_last.addr = alloca i32, align 4
  %params.addr = alloca ptr, align 8
  %commands.addr = alloca ptr, align 8
  %n_commands.addr = alloca i64, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %arena = alloca ptr, align 8
  %num_distance_symbols = alloca i32, align 4
  %distance_alphabet_bits = alloca i32, align 4
  %histogram = alloca [256 x i32], align 16
  %pos = alloca i64, align 8
  %num_literals = alloca i64, align 8
  %i = alloca i64, align 8
  %cmd = alloca %struct.Command, align 4
  %j = alloca i64, align 8
  store ptr %m, ptr %m.addr, align 8
  store ptr %input, ptr %input.addr, align 8
  store i64 %start_pos, ptr %start_pos.addr, align 8
  store i64 %length, ptr %length.addr, align 8
  store i64 %mask, ptr %mask.addr, align 8
  store i32 %is_last, ptr %is_last.addr, align 4
  store ptr %params, ptr %params.addr, align 8
  store ptr %commands, ptr %commands.addr, align 8
  store i64 %n_commands, ptr %n_commands.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load ptr, ptr %m.addr, align 8
  %call = call ptr @BrotliAllocate(ptr noundef %0, i64 noundef 20640)
  store ptr %call, ptr %arena, align 8
  %1 = load ptr, ptr %params.addr, align 8
  %dist = getelementptr inbounds %struct.BrotliEncoderParams, ptr %1, i32 0, i32 9
  %alphabet_size_max = getelementptr inbounds %struct.BrotliDistanceParams, ptr %dist, i32 0, i32 2
  %2 = load i32, ptr %alphabet_size_max, align 8
  store i32 %2, ptr %num_distance_symbols, align 4
  %3 = load i32, ptr %num_distance_symbols, align 4
  %sub = sub i32 %3, 1
  %conv = zext i32 %sub to i64
  store i64 %conv, ptr %n.addr.i, align 8
  %4 = load i64, ptr %n.addr.i, align 8
  %conv.i82 = trunc i64 %4 to i32
  %5 = call i32 @llvm.ctlz.i32(i32 %conv.i82, i1 true)
  %xor.i = xor i32 31, %5
  %add = add i32 %xor.i, 1
  store i32 %add, ptr %distance_alphabet_bits, align 4
  %6 = load i32, ptr %is_last.addr, align 4
  %7 = load i64, ptr %length.addr, align 8
  %8 = load ptr, ptr %storage_ix.addr, align 8
  %9 = load ptr, ptr %storage.addr, align 8
  call void @StoreCompressedMetaBlockHeader(i32 noundef %6, i64 noundef %7, ptr noundef %8, ptr noundef %9)
  %10 = load ptr, ptr %storage_ix.addr, align 8
  %11 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !407)
  call void @llvm.experimental.noalias.scope.decl(metadata !410)
  store i64 13, ptr %n_bits.addr.i, align 8, !noalias !412
  store i64 0, ptr %bits.addr.i, align 8, !noalias !412
  store ptr %10, ptr %pos.addr.i, align 8, !noalias !412
  store ptr %11, ptr %array.addr.i, align 8, !noalias !412
  %12 = load ptr, ptr %array.addr.i, align 8, !noalias !412
  %13 = load ptr, ptr %pos.addr.i, align 8, !noalias !412
  %14 = load i64, ptr %13, align 8
  %shr.i = lshr i64 %14, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %12, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !412
  %15 = load ptr, ptr %p.i, align 8, !noalias !412
  %16 = load i8, ptr %15, align 1
  %conv.i = zext i8 %16 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !412
  %17 = load i64, ptr %bits.addr.i, align 8, !noalias !412
  %18 = load ptr, ptr %pos.addr.i, align 8, !noalias !412
  %19 = load i64, ptr %18, align 8
  %and.i = and i64 %19, 7
  %shl.i = shl i64 %17, %and.i
  %20 = load i64, ptr %v.i, align 8, !noalias !412
  %or.i = or i64 %20, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !412
  %21 = load ptr, ptr %p.i, align 8, !noalias !412
  %22 = load i64, ptr %v.i, align 8, !noalias !412
  store ptr %21, ptr %p.addr.i102, align 8
  store i64 %22, ptr %v.addr.i103, align 8
  %23 = load ptr, ptr %p.addr.i102, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %23, ptr align 8 %v.addr.i103, i64 8, i1 false)
  %24 = load i64, ptr %n_bits.addr.i, align 8, !noalias !412
  %25 = load ptr, ptr %pos.addr.i, align 8, !noalias !412
  %26 = load i64, ptr %25, align 8
  %add.i = add i64 %26, %24
  store i64 %add.i, ptr %25, align 8
  %27 = load i64, ptr %n_commands.addr, align 8
  %cmp = icmp ule i64 %27, 128
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @llvm.memset.p0.i64(ptr align 16 %histogram, i8 0, i64 1024, i1 false)
  %28 = load i64, ptr %start_pos.addr, align 8
  store i64 %28, ptr %pos, align 8
  store i64 0, ptr %num_literals, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc19, %if.then
  %29 = load i64, ptr %i, align 8
  %30 = load i64, ptr %n_commands.addr, align 8
  %cmp3 = icmp ult i64 %29, %30
  br i1 %cmp3, label %for.body, label %for.end21

for.body:                                         ; preds = %for.cond
  %31 = load ptr, ptr %commands.addr, align 8
  %32 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds %struct.Command, ptr %31, i64 %32
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %cmd, ptr align 4 %arrayidx, i64 16, i1 false)
  %insert_len_ = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 0
  %33 = load i32, ptr %insert_len_, align 4
  %conv5 = zext i32 %33 to i64
  store i64 %conv5, ptr %j, align 8
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc, %for.body
  %34 = load i64, ptr %j, align 8
  %cmp7 = icmp ne i64 %34, 0
  br i1 %cmp7, label %for.body9, label %for.end

for.body9:                                        ; preds = %for.cond6
  %35 = load ptr, ptr %input.addr, align 8
  %36 = load i64, ptr %pos, align 8
  %37 = load i64, ptr %mask.addr, align 8
  %and = and i64 %36, %37
  %arrayidx10 = getelementptr inbounds i8, ptr %35, i64 %and
  %38 = load i8, ptr %arrayidx10, align 1
  %idxprom = zext i8 %38 to i64
  %arrayidx11 = getelementptr inbounds [256 x i32], ptr %histogram, i64 0, i64 %idxprom
  %39 = load i32, ptr %arrayidx11, align 4
  %inc = add i32 %39, 1
  store i32 %inc, ptr %arrayidx11, align 4
  %40 = load i64, ptr %pos, align 8
  %inc12 = add i64 %40, 1
  store i64 %inc12, ptr %pos, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body9
  %41 = load i64, ptr %j, align 8
  %dec = add i64 %41, -1
  store i64 %dec, ptr %j, align 8
  br label %for.cond6, !llvm.loop !413

for.end:                                          ; preds = %for.cond6
  %insert_len_13 = getelementptr inbounds %struct.Command, ptr %cmd, i32 0, i32 0
  %42 = load i32, ptr %insert_len_13, align 4
  %conv14 = zext i32 %42 to i64
  %43 = load i64, ptr %num_literals, align 8
  %add15 = add i64 %43, %conv14
  store i64 %add15, ptr %num_literals, align 8
  store ptr %cmd, ptr %self.addr.i, align 8
  %44 = load ptr, ptr %self.addr.i, align 8
  %copy_len_.i = getelementptr inbounds %struct.Command, ptr %44, i32 0, i32 1
  %45 = load i32, ptr %copy_len_.i, align 4
  %and.i74 = and i32 %45, 33554431
  %conv17 = zext i32 %and.i74 to i64
  %46 = load i64, ptr %pos, align 8
  %add18 = add i64 %46, %conv17
  store i64 %add18, ptr %pos, align 8
  br label %for.inc19

for.inc19:                                        ; preds = %for.end
  %47 = load i64, ptr %i, align 8
  %inc20 = add i64 %47, 1
  store i64 %inc20, ptr %i, align 8
  br label %for.cond, !llvm.loop !414

for.end21:                                        ; preds = %for.cond
  %48 = load ptr, ptr %arena, align 8
  %tree = getelementptr inbounds %struct.MetablockArena, ptr %48, i32 0, i32 9
  %arraydecay = getelementptr inbounds [1409 x %struct.HuffmanTree], ptr %tree, i64 0, i64 0
  %arraydecay22 = getelementptr inbounds [256 x i32], ptr %histogram, i64 0, i64 0
  %49 = load i64, ptr %num_literals, align 8
  %50 = load ptr, ptr %arena, align 8
  %lit_depth = getelementptr inbounds %struct.MetablockArena, ptr %50, i32 0, i32 3
  %arraydecay23 = getelementptr inbounds [256 x i8], ptr %lit_depth, i64 0, i64 0
  %51 = load ptr, ptr %arena, align 8
  %lit_bits = getelementptr inbounds %struct.MetablockArena, ptr %51, i32 0, i32 4
  %arraydecay24 = getelementptr inbounds [256 x i16], ptr %lit_bits, i64 0, i64 0
  %52 = load ptr, ptr %storage_ix.addr, align 8
  %53 = load ptr, ptr %storage.addr, align 8
  call void @BrotliBuildAndStoreHuffmanTreeFast(ptr noundef %arraydecay, ptr noundef %arraydecay22, i64 noundef %49, i64 noundef 8, ptr noundef %arraydecay23, ptr noundef %arraydecay24, ptr noundef %52, ptr noundef %53)
  %54 = load ptr, ptr %storage_ix.addr, align 8
  %55 = load ptr, ptr %storage.addr, align 8
  store ptr %54, ptr %storage_ix.addr.i, align 8
  store ptr %55, ptr %storage.addr.i, align 8
  %56 = load ptr, ptr %storage_ix.addr.i, align 8
  %57 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !415)
  call void @llvm.experimental.noalias.scope.decl(metadata !418)
  store i64 56, ptr %n_bits.addr.i1.i, align 8, !noalias !420
  store i64 41203391169327107, ptr %bits.addr.i2.i, align 8, !noalias !420
  store ptr %56, ptr %pos.addr.i3.i, align 8, !noalias !420
  store ptr %57, ptr %array.addr.i4.i, align 8, !noalias !420
  %58 = load ptr, ptr %array.addr.i4.i, align 8, !noalias !420
  %59 = load ptr, ptr %pos.addr.i3.i, align 8, !noalias !420
  %60 = load i64, ptr %59, align 8
  %shr.i7.i = lshr i64 %60, 3
  %arrayidx.i8.i = getelementptr inbounds i8, ptr %58, i64 %shr.i7.i
  store ptr %arrayidx.i8.i, ptr %p.i5.i, align 8, !noalias !420
  %61 = load ptr, ptr %p.i5.i, align 8, !noalias !420
  %62 = load i8, ptr %61, align 1
  %conv.i9.i = zext i8 %62 to i64
  store i64 %conv.i9.i, ptr %v.i6.i, align 8, !noalias !420
  %63 = load i64, ptr %bits.addr.i2.i, align 8, !noalias !420
  %64 = load ptr, ptr %pos.addr.i3.i, align 8, !noalias !420
  %65 = load i64, ptr %64, align 8
  %and.i10.i = and i64 %65, 7
  %shl.i11.i = shl i64 %63, %and.i10.i
  %66 = load i64, ptr %v.i6.i, align 8, !noalias !420
  %or.i12.i = or i64 %66, %shl.i11.i
  store i64 %or.i12.i, ptr %v.i6.i, align 8, !noalias !420
  %67 = load ptr, ptr %p.i5.i, align 8, !noalias !420
  %68 = load i64, ptr %v.i6.i, align 8, !noalias !420
  store ptr %67, ptr %p.addr.i100, align 8
  store i64 %68, ptr %v.addr.i101, align 8
  %69 = load ptr, ptr %p.addr.i100, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %69, ptr align 8 %v.addr.i101, i64 8, i1 false)
  %70 = load i64, ptr %n_bits.addr.i1.i, align 8, !noalias !420
  %71 = load ptr, ptr %pos.addr.i3.i, align 8, !noalias !420
  %72 = load i64, ptr %71, align 8
  %add.i13.i = add i64 %72, %70
  store i64 %add.i13.i, ptr %71, align 8
  %73 = load ptr, ptr %storage_ix.addr.i, align 8
  %74 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !421)
  call void @llvm.experimental.noalias.scope.decl(metadata !424)
  store i64 3, ptr %n_bits.addr.i.i, align 8, !noalias !426
  store i64 0, ptr %bits.addr.i.i, align 8, !noalias !426
  store ptr %73, ptr %pos.addr.i.i, align 8, !noalias !426
  store ptr %74, ptr %array.addr.i.i, align 8, !noalias !426
  %75 = load ptr, ptr %array.addr.i.i, align 8, !noalias !426
  %76 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !426
  %77 = load i64, ptr %76, align 8
  %shr.i.i = lshr i64 %77, 3
  %arrayidx.i.i = getelementptr inbounds i8, ptr %75, i64 %shr.i.i
  store ptr %arrayidx.i.i, ptr %p.i.i, align 8, !noalias !426
  %78 = load ptr, ptr %p.i.i, align 8, !noalias !426
  %79 = load i8, ptr %78, align 1
  %conv.i.i = zext i8 %79 to i64
  store i64 %conv.i.i, ptr %v.i.i, align 8, !noalias !426
  %80 = load i64, ptr %bits.addr.i.i, align 8, !noalias !426
  %81 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !426
  %82 = load i64, ptr %81, align 8
  %and.i.i = and i64 %82, 7
  %shl.i.i = shl i64 %80, %and.i.i
  %83 = load i64, ptr %v.i.i, align 8, !noalias !426
  %or.i.i = or i64 %83, %shl.i.i
  store i64 %or.i.i, ptr %v.i.i, align 8, !noalias !426
  %84 = load ptr, ptr %p.i.i, align 8, !noalias !426
  %85 = load i64, ptr %v.i.i, align 8, !noalias !426
  store ptr %84, ptr %p.addr.i98, align 8
  store i64 %85, ptr %v.addr.i99, align 8
  %86 = load ptr, ptr %p.addr.i98, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %86, ptr align 8 %v.addr.i99, i64 8, i1 false)
  %87 = load i64, ptr %n_bits.addr.i.i, align 8, !noalias !426
  %88 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !426
  %89 = load i64, ptr %88, align 8
  %add.i.i = add i64 %89, %87
  store i64 %add.i.i, ptr %88, align 8
  %90 = load ptr, ptr %storage_ix.addr, align 8
  %91 = load ptr, ptr %storage.addr, align 8
  store ptr %90, ptr %storage_ix.addr.i89, align 8
  store ptr %91, ptr %storage.addr.i90, align 8
  %92 = load ptr, ptr %storage_ix.addr.i89, align 8
  %93 = load ptr, ptr %storage.addr.i90, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !427)
  call void @llvm.experimental.noalias.scope.decl(metadata !430)
  store i64 28, ptr %n_bits.addr.i.i83, align 8, !noalias !432
  store i64 57269251, ptr %bits.addr.i.i84, align 8, !noalias !432
  store ptr %92, ptr %pos.addr.i.i85, align 8, !noalias !432
  store ptr %93, ptr %array.addr.i.i86, align 8, !noalias !432
  %94 = load ptr, ptr %array.addr.i.i86, align 8, !noalias !432
  %95 = load ptr, ptr %pos.addr.i.i85, align 8, !noalias !432
  %96 = load i64, ptr %95, align 8
  %shr.i.i91 = lshr i64 %96, 3
  %arrayidx.i.i92 = getelementptr inbounds i8, ptr %94, i64 %shr.i.i91
  store ptr %arrayidx.i.i92, ptr %p.i.i87, align 8, !noalias !432
  %97 = load ptr, ptr %p.i.i87, align 8, !noalias !432
  %98 = load i8, ptr %97, align 1
  %conv.i.i93 = zext i8 %98 to i64
  store i64 %conv.i.i93, ptr %v.i.i88, align 8, !noalias !432
  %99 = load i64, ptr %bits.addr.i.i84, align 8, !noalias !432
  %100 = load ptr, ptr %pos.addr.i.i85, align 8, !noalias !432
  %101 = load i64, ptr %100, align 8
  %and.i.i94 = and i64 %101, 7
  %shl.i.i95 = shl i64 %99, %and.i.i94
  %102 = load i64, ptr %v.i.i88, align 8, !noalias !432
  %or.i.i96 = or i64 %102, %shl.i.i95
  store i64 %or.i.i96, ptr %v.i.i88, align 8, !noalias !432
  %103 = load ptr, ptr %p.i.i87, align 8, !noalias !432
  %104 = load i64, ptr %v.i.i88, align 8, !noalias !432
  store ptr %103, ptr %p.addr.i, align 8
  store i64 %104, ptr %v.addr.i, align 8
  %105 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %105, ptr align 8 %v.addr.i, i64 8, i1 false)
  %106 = load i64, ptr %n_bits.addr.i.i83, align 8, !noalias !432
  %107 = load ptr, ptr %pos.addr.i.i85, align 8, !noalias !432
  %108 = load i64, ptr %107, align 8
  %add.i.i97 = add i64 %108, %106
  store i64 %add.i.i97, ptr %107, align 8
  %109 = load ptr, ptr %input.addr, align 8
  %110 = load i64, ptr %start_pos.addr, align 8
  %111 = load i64, ptr %mask.addr, align 8
  %112 = load ptr, ptr %commands.addr, align 8
  %113 = load i64, ptr %n_commands.addr, align 8
  %114 = load ptr, ptr %arena, align 8
  %lit_depth25 = getelementptr inbounds %struct.MetablockArena, ptr %114, i32 0, i32 3
  %arraydecay26 = getelementptr inbounds [256 x i8], ptr %lit_depth25, i64 0, i64 0
  %115 = load ptr, ptr %arena, align 8
  %lit_bits27 = getelementptr inbounds %struct.MetablockArena, ptr %115, i32 0, i32 4
  %arraydecay28 = getelementptr inbounds [256 x i16], ptr %lit_bits27, i64 0, i64 0
  %116 = load ptr, ptr %storage_ix.addr, align 8
  %117 = load ptr, ptr %storage.addr, align 8
  call void @StoreDataWithHuffmanCodes(ptr noundef %109, i64 noundef %110, i64 noundef %111, ptr noundef %112, i64 noundef %113, ptr noundef %arraydecay26, ptr noundef %arraydecay28, ptr noundef @kStaticCommandCodeDepth, ptr noundef @kStaticCommandCodeBits, ptr noundef @kStaticDistanceCodeDepth, ptr noundef @kStaticDistanceCodeBits, ptr noundef %116, ptr noundef %117)
  br label %if.end

if.else:                                          ; preds = %entry
  %118 = load ptr, ptr %arena, align 8
  %lit_histo = getelementptr inbounds %struct.MetablockArena, ptr %118, i32 0, i32 0
  store ptr %lit_histo, ptr %self.addr.i75, align 8
  %119 = load ptr, ptr %self.addr.i75, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %119, i8 0, i64 1024, i1 false)
  %120 = load ptr, ptr %self.addr.i75, align 8
  %total_count_.i = getelementptr inbounds %struct.HistogramLiteral, ptr %120, i32 0, i32 1
  store i64 0, ptr %total_count_.i, align 8
  %121 = load ptr, ptr %self.addr.i75, align 8
  %bit_cost_.i = getelementptr inbounds %struct.HistogramLiteral, ptr %121, i32 0, i32 2
  store double 0x7FF0000000000000, ptr %bit_cost_.i, align 8
  %122 = load ptr, ptr %arena, align 8
  %cmd_histo = getelementptr inbounds %struct.MetablockArena, ptr %122, i32 0, i32 1
  store ptr %cmd_histo, ptr %self.addr.i76, align 8
  %123 = load ptr, ptr %self.addr.i76, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %123, i8 0, i64 2816, i1 false)
  %124 = load ptr, ptr %self.addr.i76, align 8
  %total_count_.i77 = getelementptr inbounds %struct.HistogramCommand, ptr %124, i32 0, i32 1
  store i64 0, ptr %total_count_.i77, align 8
  %125 = load ptr, ptr %self.addr.i76, align 8
  %bit_cost_.i78 = getelementptr inbounds %struct.HistogramCommand, ptr %125, i32 0, i32 2
  store double 0x7FF0000000000000, ptr %bit_cost_.i78, align 8
  %126 = load ptr, ptr %arena, align 8
  %dist_histo = getelementptr inbounds %struct.MetablockArena, ptr %126, i32 0, i32 2
  store ptr %dist_histo, ptr %self.addr.i79, align 8
  %127 = load ptr, ptr %self.addr.i79, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %127, i8 0, i64 2176, i1 false)
  %128 = load ptr, ptr %self.addr.i79, align 8
  %total_count_.i80 = getelementptr inbounds %struct.HistogramDistance, ptr %128, i32 0, i32 1
  store i64 0, ptr %total_count_.i80, align 8
  %129 = load ptr, ptr %self.addr.i79, align 8
  %bit_cost_.i81 = getelementptr inbounds %struct.HistogramDistance, ptr %129, i32 0, i32 2
  store double 0x7FF0000000000000, ptr %bit_cost_.i81, align 8
  %130 = load ptr, ptr %input.addr, align 8
  %131 = load i64, ptr %start_pos.addr, align 8
  %132 = load i64, ptr %mask.addr, align 8
  %133 = load ptr, ptr %commands.addr, align 8
  %134 = load i64, ptr %n_commands.addr, align 8
  %135 = load ptr, ptr %arena, align 8
  %lit_histo29 = getelementptr inbounds %struct.MetablockArena, ptr %135, i32 0, i32 0
  %136 = load ptr, ptr %arena, align 8
  %cmd_histo30 = getelementptr inbounds %struct.MetablockArena, ptr %136, i32 0, i32 1
  %137 = load ptr, ptr %arena, align 8
  %dist_histo31 = getelementptr inbounds %struct.MetablockArena, ptr %137, i32 0, i32 2
  call void @BuildHistograms(ptr noundef %130, i64 noundef %131, i64 noundef %132, ptr noundef %133, i64 noundef %134, ptr noundef %lit_histo29, ptr noundef %cmd_histo30, ptr noundef %dist_histo31)
  %138 = load ptr, ptr %arena, align 8
  %tree32 = getelementptr inbounds %struct.MetablockArena, ptr %138, i32 0, i32 9
  %arraydecay33 = getelementptr inbounds [1409 x %struct.HuffmanTree], ptr %tree32, i64 0, i64 0
  %139 = load ptr, ptr %arena, align 8
  %lit_histo34 = getelementptr inbounds %struct.MetablockArena, ptr %139, i32 0, i32 0
  %data_ = getelementptr inbounds %struct.HistogramLiteral, ptr %lit_histo34, i32 0, i32 0
  %arraydecay35 = getelementptr inbounds [256 x i32], ptr %data_, i64 0, i64 0
  %140 = load ptr, ptr %arena, align 8
  %lit_histo36 = getelementptr inbounds %struct.MetablockArena, ptr %140, i32 0, i32 0
  %total_count_ = getelementptr inbounds %struct.HistogramLiteral, ptr %lit_histo36, i32 0, i32 1
  %141 = load i64, ptr %total_count_, align 8
  %142 = load ptr, ptr %arena, align 8
  %lit_depth37 = getelementptr inbounds %struct.MetablockArena, ptr %142, i32 0, i32 3
  %arraydecay38 = getelementptr inbounds [256 x i8], ptr %lit_depth37, i64 0, i64 0
  %143 = load ptr, ptr %arena, align 8
  %lit_bits39 = getelementptr inbounds %struct.MetablockArena, ptr %143, i32 0, i32 4
  %arraydecay40 = getelementptr inbounds [256 x i16], ptr %lit_bits39, i64 0, i64 0
  %144 = load ptr, ptr %storage_ix.addr, align 8
  %145 = load ptr, ptr %storage.addr, align 8
  call void @BrotliBuildAndStoreHuffmanTreeFast(ptr noundef %arraydecay33, ptr noundef %arraydecay35, i64 noundef %141, i64 noundef 8, ptr noundef %arraydecay38, ptr noundef %arraydecay40, ptr noundef %144, ptr noundef %145)
  %146 = load ptr, ptr %arena, align 8
  %tree41 = getelementptr inbounds %struct.MetablockArena, ptr %146, i32 0, i32 9
  %arraydecay42 = getelementptr inbounds [1409 x %struct.HuffmanTree], ptr %tree41, i64 0, i64 0
  %147 = load ptr, ptr %arena, align 8
  %cmd_histo43 = getelementptr inbounds %struct.MetablockArena, ptr %147, i32 0, i32 1
  %data_44 = getelementptr inbounds %struct.HistogramCommand, ptr %cmd_histo43, i32 0, i32 0
  %arraydecay45 = getelementptr inbounds [704 x i32], ptr %data_44, i64 0, i64 0
  %148 = load ptr, ptr %arena, align 8
  %cmd_histo46 = getelementptr inbounds %struct.MetablockArena, ptr %148, i32 0, i32 1
  %total_count_47 = getelementptr inbounds %struct.HistogramCommand, ptr %cmd_histo46, i32 0, i32 1
  %149 = load i64, ptr %total_count_47, align 8
  %150 = load ptr, ptr %arena, align 8
  %cmd_depth = getelementptr inbounds %struct.MetablockArena, ptr %150, i32 0, i32 5
  %arraydecay48 = getelementptr inbounds [704 x i8], ptr %cmd_depth, i64 0, i64 0
  %151 = load ptr, ptr %arena, align 8
  %cmd_bits = getelementptr inbounds %struct.MetablockArena, ptr %151, i32 0, i32 6
  %arraydecay49 = getelementptr inbounds [704 x i16], ptr %cmd_bits, i64 0, i64 0
  %152 = load ptr, ptr %storage_ix.addr, align 8
  %153 = load ptr, ptr %storage.addr, align 8
  call void @BrotliBuildAndStoreHuffmanTreeFast(ptr noundef %arraydecay42, ptr noundef %arraydecay45, i64 noundef %149, i64 noundef 10, ptr noundef %arraydecay48, ptr noundef %arraydecay49, ptr noundef %152, ptr noundef %153)
  %154 = load ptr, ptr %arena, align 8
  %tree50 = getelementptr inbounds %struct.MetablockArena, ptr %154, i32 0, i32 9
  %arraydecay51 = getelementptr inbounds [1409 x %struct.HuffmanTree], ptr %tree50, i64 0, i64 0
  %155 = load ptr, ptr %arena, align 8
  %dist_histo52 = getelementptr inbounds %struct.MetablockArena, ptr %155, i32 0, i32 2
  %data_53 = getelementptr inbounds %struct.HistogramDistance, ptr %dist_histo52, i32 0, i32 0
  %arraydecay54 = getelementptr inbounds [544 x i32], ptr %data_53, i64 0, i64 0
  %156 = load ptr, ptr %arena, align 8
  %dist_histo55 = getelementptr inbounds %struct.MetablockArena, ptr %156, i32 0, i32 2
  %total_count_56 = getelementptr inbounds %struct.HistogramDistance, ptr %dist_histo55, i32 0, i32 1
  %157 = load i64, ptr %total_count_56, align 8
  %158 = load i32, ptr %distance_alphabet_bits, align 4
  %conv57 = zext i32 %158 to i64
  %159 = load ptr, ptr %arena, align 8
  %dist_depth = getelementptr inbounds %struct.MetablockArena, ptr %159, i32 0, i32 7
  %arraydecay58 = getelementptr inbounds [140 x i8], ptr %dist_depth, i64 0, i64 0
  %160 = load ptr, ptr %arena, align 8
  %dist_bits = getelementptr inbounds %struct.MetablockArena, ptr %160, i32 0, i32 8
  %arraydecay59 = getelementptr inbounds [140 x i16], ptr %dist_bits, i64 0, i64 0
  %161 = load ptr, ptr %storage_ix.addr, align 8
  %162 = load ptr, ptr %storage.addr, align 8
  call void @BrotliBuildAndStoreHuffmanTreeFast(ptr noundef %arraydecay51, ptr noundef %arraydecay54, i64 noundef %157, i64 noundef %conv57, ptr noundef %arraydecay58, ptr noundef %arraydecay59, ptr noundef %161, ptr noundef %162)
  %163 = load ptr, ptr %input.addr, align 8
  %164 = load i64, ptr %start_pos.addr, align 8
  %165 = load i64, ptr %mask.addr, align 8
  %166 = load ptr, ptr %commands.addr, align 8
  %167 = load i64, ptr %n_commands.addr, align 8
  %168 = load ptr, ptr %arena, align 8
  %lit_depth60 = getelementptr inbounds %struct.MetablockArena, ptr %168, i32 0, i32 3
  %arraydecay61 = getelementptr inbounds [256 x i8], ptr %lit_depth60, i64 0, i64 0
  %169 = load ptr, ptr %arena, align 8
  %lit_bits62 = getelementptr inbounds %struct.MetablockArena, ptr %169, i32 0, i32 4
  %arraydecay63 = getelementptr inbounds [256 x i16], ptr %lit_bits62, i64 0, i64 0
  %170 = load ptr, ptr %arena, align 8
  %cmd_depth64 = getelementptr inbounds %struct.MetablockArena, ptr %170, i32 0, i32 5
  %arraydecay65 = getelementptr inbounds [704 x i8], ptr %cmd_depth64, i64 0, i64 0
  %171 = load ptr, ptr %arena, align 8
  %cmd_bits66 = getelementptr inbounds %struct.MetablockArena, ptr %171, i32 0, i32 6
  %arraydecay67 = getelementptr inbounds [704 x i16], ptr %cmd_bits66, i64 0, i64 0
  %172 = load ptr, ptr %arena, align 8
  %dist_depth68 = getelementptr inbounds %struct.MetablockArena, ptr %172, i32 0, i32 7
  %arraydecay69 = getelementptr inbounds [140 x i8], ptr %dist_depth68, i64 0, i64 0
  %173 = load ptr, ptr %arena, align 8
  %dist_bits70 = getelementptr inbounds %struct.MetablockArena, ptr %173, i32 0, i32 8
  %arraydecay71 = getelementptr inbounds [140 x i16], ptr %dist_bits70, i64 0, i64 0
  %174 = load ptr, ptr %storage_ix.addr, align 8
  %175 = load ptr, ptr %storage.addr, align 8
  call void @StoreDataWithHuffmanCodes(ptr noundef %163, i64 noundef %164, i64 noundef %165, ptr noundef %166, i64 noundef %167, ptr noundef %arraydecay61, ptr noundef %arraydecay63, ptr noundef %arraydecay65, ptr noundef %arraydecay67, ptr noundef %arraydecay69, ptr noundef %arraydecay71, ptr noundef %174, ptr noundef %175)
  br label %if.end

if.end:                                           ; preds = %if.else, %for.end21
  %176 = load ptr, ptr %m.addr, align 8
  %177 = load ptr, ptr %arena, align 8
  call void @BrotliFree(ptr noundef %176, ptr noundef %177)
  store ptr null, ptr %arena, align 8
  %178 = load i32, ptr %is_last.addr, align 4
  %tobool = icmp ne i32 %178, 0
  br i1 %tobool, label %if.then72, label %if.end73

if.then72:                                        ; preds = %if.end
  %179 = load ptr, ptr %storage_ix.addr, align 8
  %180 = load ptr, ptr %storage.addr, align 8
  call void @JumpToByteBoundary(ptr noundef %179, ptr noundef %180)
  br label %if.end73

if.end73:                                         ; preds = %if.then72, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define hidden void @BrotliStoreUncompressedMetaBlock(i32 noundef %is_final_block, ptr noalias noundef %input, i64 noundef %position, i64 noundef %mask, i64 noundef %len, ptr noalias noundef %storage_ix, ptr noalias noundef %storage) #0 {
entry:
  %p.addr.i30 = alloca ptr, align 8
  %v.addr.i31 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %pos.addr.i26 = alloca i64, align 8
  %array.addr.i27 = alloca ptr, align 8
  %n_bits.addr.i13 = alloca i64, align 8
  %bits.addr.i14 = alloca i64, align 8
  %pos.addr.i15 = alloca ptr, align 8
  %array.addr.i16 = alloca ptr, align 8
  %p.i17 = alloca ptr, align 8
  %v.i18 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %is_final_block.addr = alloca i32, align 4
  %input.addr = alloca ptr, align 8
  %position.addr = alloca i64, align 8
  %mask.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %masked_pos = alloca i64, align 8
  %len1 = alloca i64, align 8
  store i32 %is_final_block, ptr %is_final_block.addr, align 4
  store ptr %input, ptr %input.addr, align 8
  store i64 %position, ptr %position.addr, align 8
  store i64 %mask, ptr %mask.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load i64, ptr %position.addr, align 8
  %1 = load i64, ptr %mask.addr, align 8
  %and = and i64 %0, %1
  store i64 %and, ptr %masked_pos, align 8
  %2 = load i64, ptr %len.addr, align 8
  %3 = load ptr, ptr %storage_ix.addr, align 8
  %4 = load ptr, ptr %storage.addr, align 8
  call void @BrotliStoreUncompressedMetaBlockHeader(i64 noundef %2, ptr noundef %3, ptr noundef %4)
  %5 = load ptr, ptr %storage_ix.addr, align 8
  %6 = load ptr, ptr %storage.addr, align 8
  call void @JumpToByteBoundary(ptr noundef %5, ptr noundef %6)
  %7 = load i64, ptr %masked_pos, align 8
  %8 = load i64, ptr %len.addr, align 8
  %add = add i64 %7, %8
  %9 = load i64, ptr %mask.addr, align 8
  %add1 = add i64 %9, 1
  %cmp = icmp ugt i64 %add, %add1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i64, ptr %mask.addr, align 8
  %add2 = add i64 %10, 1
  %11 = load i64, ptr %masked_pos, align 8
  %sub = sub i64 %add2, %11
  store i64 %sub, ptr %len1, align 8
  %12 = load ptr, ptr %storage.addr, align 8
  %13 = load ptr, ptr %storage_ix.addr, align 8
  %14 = load i64, ptr %13, align 8
  %shr = lshr i64 %14, 3
  %arrayidx = getelementptr inbounds i8, ptr %12, i64 %shr
  %15 = load ptr, ptr %input.addr, align 8
  %16 = load i64, ptr %masked_pos, align 8
  %arrayidx3 = getelementptr inbounds i8, ptr %15, i64 %16
  %17 = load i64, ptr %len1, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arrayidx, ptr align 1 %arrayidx3, i64 %17, i1 false)
  %18 = load i64, ptr %len1, align 8
  %shl = shl i64 %18, 3
  %19 = load ptr, ptr %storage_ix.addr, align 8
  %20 = load i64, ptr %19, align 8
  %add4 = add i64 %20, %shl
  store i64 %add4, ptr %19, align 8
  %21 = load i64, ptr %len1, align 8
  %22 = load i64, ptr %len.addr, align 8
  %sub5 = sub i64 %22, %21
  store i64 %sub5, ptr %len.addr, align 8
  store i64 0, ptr %masked_pos, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %23 = load ptr, ptr %storage.addr, align 8
  %24 = load ptr, ptr %storage_ix.addr, align 8
  %25 = load i64, ptr %24, align 8
  %shr6 = lshr i64 %25, 3
  %arrayidx7 = getelementptr inbounds i8, ptr %23, i64 %shr6
  %26 = load ptr, ptr %input.addr, align 8
  %27 = load i64, ptr %masked_pos, align 8
  %arrayidx8 = getelementptr inbounds i8, ptr %26, i64 %27
  %28 = load i64, ptr %len.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %arrayidx7, ptr align 1 %arrayidx8, i64 %28, i1 false)
  %29 = load i64, ptr %len.addr, align 8
  %shl9 = shl i64 %29, 3
  %30 = load ptr, ptr %storage_ix.addr, align 8
  %31 = load i64, ptr %30, align 8
  %add10 = add i64 %31, %shl9
  store i64 %add10, ptr %30, align 8
  %32 = load ptr, ptr %storage_ix.addr, align 8
  %33 = load i64, ptr %32, align 8
  %34 = load ptr, ptr %storage.addr, align 8
  store i64 %33, ptr %pos.addr.i26, align 8
  store ptr %34, ptr %array.addr.i27, align 8
  %35 = load ptr, ptr %array.addr.i27, align 8
  %36 = load i64, ptr %pos.addr.i26, align 8
  %shr.i28 = lshr i64 %36, 3
  %arrayidx.i29 = getelementptr inbounds i8, ptr %35, i64 %shr.i28
  store i8 0, ptr %arrayidx.i29, align 1
  %37 = load i32, ptr %is_final_block.addr, align 4
  %tobool = icmp ne i32 %37, 0
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end
  %38 = load ptr, ptr %storage_ix.addr, align 8
  %39 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !433)
  call void @llvm.experimental.noalias.scope.decl(metadata !436)
  store i64 1, ptr %n_bits.addr.i13, align 8, !noalias !438
  store i64 1, ptr %bits.addr.i14, align 8, !noalias !438
  store ptr %38, ptr %pos.addr.i15, align 8, !noalias !438
  store ptr %39, ptr %array.addr.i16, align 8, !noalias !438
  %40 = load ptr, ptr %array.addr.i16, align 8, !noalias !438
  %41 = load ptr, ptr %pos.addr.i15, align 8, !noalias !438
  %42 = load i64, ptr %41, align 8
  %shr.i19 = lshr i64 %42, 3
  %arrayidx.i20 = getelementptr inbounds i8, ptr %40, i64 %shr.i19
  store ptr %arrayidx.i20, ptr %p.i17, align 8, !noalias !438
  %43 = load ptr, ptr %p.i17, align 8, !noalias !438
  %44 = load i8, ptr %43, align 1
  %conv.i21 = zext i8 %44 to i64
  store i64 %conv.i21, ptr %v.i18, align 8, !noalias !438
  %45 = load i64, ptr %bits.addr.i14, align 8, !noalias !438
  %46 = load ptr, ptr %pos.addr.i15, align 8, !noalias !438
  %47 = load i64, ptr %46, align 8
  %and.i22 = and i64 %47, 7
  %shl.i23 = shl i64 %45, %and.i22
  %48 = load i64, ptr %v.i18, align 8, !noalias !438
  %or.i24 = or i64 %48, %shl.i23
  store i64 %or.i24, ptr %v.i18, align 8, !noalias !438
  %49 = load ptr, ptr %p.i17, align 8, !noalias !438
  %50 = load i64, ptr %v.i18, align 8, !noalias !438
  store ptr %49, ptr %p.addr.i, align 8
  store i64 %50, ptr %v.addr.i, align 8
  %51 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %51, ptr align 8 %v.addr.i, i64 8, i1 false)
  %52 = load i64, ptr %n_bits.addr.i13, align 8, !noalias !438
  %53 = load ptr, ptr %pos.addr.i15, align 8, !noalias !438
  %54 = load i64, ptr %53, align 8
  %add.i25 = add i64 %54, %52
  store i64 %add.i25, ptr %53, align 8
  %55 = load ptr, ptr %storage_ix.addr, align 8
  %56 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !439)
  call void @llvm.experimental.noalias.scope.decl(metadata !442)
  store i64 1, ptr %n_bits.addr.i, align 8, !noalias !444
  store i64 1, ptr %bits.addr.i, align 8, !noalias !444
  store ptr %55, ptr %pos.addr.i, align 8, !noalias !444
  store ptr %56, ptr %array.addr.i, align 8, !noalias !444
  %57 = load ptr, ptr %array.addr.i, align 8, !noalias !444
  %58 = load ptr, ptr %pos.addr.i, align 8, !noalias !444
  %59 = load i64, ptr %58, align 8
  %shr.i = lshr i64 %59, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %57, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !444
  %60 = load ptr, ptr %p.i, align 8, !noalias !444
  %61 = load i8, ptr %60, align 1
  %conv.i = zext i8 %61 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !444
  %62 = load i64, ptr %bits.addr.i, align 8, !noalias !444
  %63 = load ptr, ptr %pos.addr.i, align 8, !noalias !444
  %64 = load i64, ptr %63, align 8
  %and.i = and i64 %64, 7
  %shl.i = shl i64 %62, %and.i
  %65 = load i64, ptr %v.i, align 8, !noalias !444
  %or.i = or i64 %65, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !444
  %66 = load ptr, ptr %p.i, align 8, !noalias !444
  %67 = load i64, ptr %v.i, align 8, !noalias !444
  store ptr %66, ptr %p.addr.i30, align 8
  store i64 %67, ptr %v.addr.i31, align 8
  %68 = load ptr, ptr %p.addr.i30, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %68, ptr align 8 %v.addr.i31, i64 8, i1 false)
  %69 = load i64, ptr %n_bits.addr.i, align 8, !noalias !444
  %70 = load ptr, ptr %pos.addr.i, align 8, !noalias !444
  %71 = load i64, ptr %70, align 8
  %add.i = add i64 %71, %69
  store i64 %add.i, ptr %70, align 8
  %72 = load ptr, ptr %storage_ix.addr, align 8
  %73 = load ptr, ptr %storage.addr, align 8
  call void @JumpToByteBoundary(ptr noundef %72, ptr noundef %73)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @BrotliStoreUncompressedMetaBlockHeader(i64 noundef %length, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i44 = alloca ptr, align 8
  %v.addr.i45 = alloca i64, align 8
  %p.addr.i42 = alloca ptr, align 8
  %v.addr.i43 = alloca i64, align 8
  %p.addr.i40 = alloca ptr, align 8
  %v.addr.i41 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i27 = alloca i64, align 8
  %bits.addr.i28 = alloca i64, align 8
  %pos.addr.i29 = alloca ptr, align 8
  %array.addr.i30 = alloca ptr, align 8
  %p.i31 = alloca ptr, align 8
  %v.i32 = alloca i64, align 8
  %n_bits.addr.i14 = alloca i64, align 8
  %bits.addr.i15 = alloca i64, align 8
  %pos.addr.i16 = alloca ptr, align 8
  %array.addr.i17 = alloca ptr, align 8
  %p.i18 = alloca ptr, align 8
  %v.i19 = alloca i64, align 8
  %n_bits.addr.i1 = alloca i64, align 8
  %bits.addr.i2 = alloca i64, align 8
  %pos.addr.i3 = alloca ptr, align 8
  %array.addr.i4 = alloca ptr, align 8
  %p.i5 = alloca ptr, align 8
  %v.i6 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %length.addr = alloca i64, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %lenbits = alloca i64, align 8
  %nlenbits = alloca i64, align 8
  %nibblesbits = alloca i64, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load ptr, ptr %storage_ix.addr, align 8
  %1 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !445)
  call void @llvm.experimental.noalias.scope.decl(metadata !448)
  store i64 1, ptr %n_bits.addr.i27, align 8, !noalias !450
  store i64 0, ptr %bits.addr.i28, align 8, !noalias !450
  store ptr %0, ptr %pos.addr.i29, align 8, !noalias !450
  store ptr %1, ptr %array.addr.i30, align 8, !noalias !450
  %2 = load ptr, ptr %array.addr.i30, align 8, !noalias !450
  %3 = load ptr, ptr %pos.addr.i29, align 8, !noalias !450
  %4 = load i64, ptr %3, align 8
  %shr.i33 = lshr i64 %4, 3
  %arrayidx.i34 = getelementptr inbounds i8, ptr %2, i64 %shr.i33
  store ptr %arrayidx.i34, ptr %p.i31, align 8, !noalias !450
  %5 = load ptr, ptr %p.i31, align 8, !noalias !450
  %6 = load i8, ptr %5, align 1
  %conv.i35 = zext i8 %6 to i64
  store i64 %conv.i35, ptr %v.i32, align 8, !noalias !450
  %7 = load i64, ptr %bits.addr.i28, align 8, !noalias !450
  %8 = load ptr, ptr %pos.addr.i29, align 8, !noalias !450
  %9 = load i64, ptr %8, align 8
  %and.i36 = and i64 %9, 7
  %shl.i37 = shl i64 %7, %and.i36
  %10 = load i64, ptr %v.i32, align 8, !noalias !450
  %or.i38 = or i64 %10, %shl.i37
  store i64 %or.i38, ptr %v.i32, align 8, !noalias !450
  %11 = load ptr, ptr %p.i31, align 8, !noalias !450
  %12 = load i64, ptr %v.i32, align 8, !noalias !450
  store ptr %11, ptr %p.addr.i, align 8
  store i64 %12, ptr %v.addr.i, align 8
  %13 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %13, ptr align 8 %v.addr.i, i64 8, i1 false)
  %14 = load i64, ptr %n_bits.addr.i27, align 8, !noalias !450
  %15 = load ptr, ptr %pos.addr.i29, align 8, !noalias !450
  %16 = load i64, ptr %15, align 8
  %add.i39 = add i64 %16, %14
  store i64 %add.i39, ptr %15, align 8
  %17 = load i64, ptr %length.addr, align 8
  call void @BrotliEncodeMlen(i64 noundef %17, ptr noundef %lenbits, ptr noundef %nlenbits, ptr noundef %nibblesbits)
  %18 = load i64, ptr %nibblesbits, align 8
  %19 = load ptr, ptr %storage_ix.addr, align 8
  %20 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !451)
  call void @llvm.experimental.noalias.scope.decl(metadata !454)
  store i64 2, ptr %n_bits.addr.i14, align 8, !noalias !456
  store i64 %18, ptr %bits.addr.i15, align 8, !noalias !456
  store ptr %19, ptr %pos.addr.i16, align 8, !noalias !456
  store ptr %20, ptr %array.addr.i17, align 8, !noalias !456
  %21 = load ptr, ptr %array.addr.i17, align 8, !noalias !456
  %22 = load ptr, ptr %pos.addr.i16, align 8, !noalias !456
  %23 = load i64, ptr %22, align 8
  %shr.i20 = lshr i64 %23, 3
  %arrayidx.i21 = getelementptr inbounds i8, ptr %21, i64 %shr.i20
  store ptr %arrayidx.i21, ptr %p.i18, align 8, !noalias !456
  %24 = load ptr, ptr %p.i18, align 8, !noalias !456
  %25 = load i8, ptr %24, align 1
  %conv.i22 = zext i8 %25 to i64
  store i64 %conv.i22, ptr %v.i19, align 8, !noalias !456
  %26 = load i64, ptr %bits.addr.i15, align 8, !noalias !456
  %27 = load ptr, ptr %pos.addr.i16, align 8, !noalias !456
  %28 = load i64, ptr %27, align 8
  %and.i23 = and i64 %28, 7
  %shl.i24 = shl i64 %26, %and.i23
  %29 = load i64, ptr %v.i19, align 8, !noalias !456
  %or.i25 = or i64 %29, %shl.i24
  store i64 %or.i25, ptr %v.i19, align 8, !noalias !456
  %30 = load ptr, ptr %p.i18, align 8, !noalias !456
  %31 = load i64, ptr %v.i19, align 8, !noalias !456
  store ptr %30, ptr %p.addr.i40, align 8
  store i64 %31, ptr %v.addr.i41, align 8
  %32 = load ptr, ptr %p.addr.i40, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %32, ptr align 8 %v.addr.i41, i64 8, i1 false)
  %33 = load i64, ptr %n_bits.addr.i14, align 8, !noalias !456
  %34 = load ptr, ptr %pos.addr.i16, align 8, !noalias !456
  %35 = load i64, ptr %34, align 8
  %add.i26 = add i64 %35, %33
  store i64 %add.i26, ptr %34, align 8
  %36 = load i64, ptr %nlenbits, align 8
  %37 = load i64, ptr %lenbits, align 8
  %38 = load ptr, ptr %storage_ix.addr, align 8
  %39 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !457)
  call void @llvm.experimental.noalias.scope.decl(metadata !460)
  store i64 %36, ptr %n_bits.addr.i1, align 8, !noalias !462
  store i64 %37, ptr %bits.addr.i2, align 8, !noalias !462
  store ptr %38, ptr %pos.addr.i3, align 8, !noalias !462
  store ptr %39, ptr %array.addr.i4, align 8, !noalias !462
  %40 = load ptr, ptr %array.addr.i4, align 8, !noalias !462
  %41 = load ptr, ptr %pos.addr.i3, align 8, !noalias !462
  %42 = load i64, ptr %41, align 8
  %shr.i7 = lshr i64 %42, 3
  %arrayidx.i8 = getelementptr inbounds i8, ptr %40, i64 %shr.i7
  store ptr %arrayidx.i8, ptr %p.i5, align 8, !noalias !462
  %43 = load ptr, ptr %p.i5, align 8, !noalias !462
  %44 = load i8, ptr %43, align 1
  %conv.i9 = zext i8 %44 to i64
  store i64 %conv.i9, ptr %v.i6, align 8, !noalias !462
  %45 = load i64, ptr %bits.addr.i2, align 8, !noalias !462
  %46 = load ptr, ptr %pos.addr.i3, align 8, !noalias !462
  %47 = load i64, ptr %46, align 8
  %and.i10 = and i64 %47, 7
  %shl.i11 = shl i64 %45, %and.i10
  %48 = load i64, ptr %v.i6, align 8, !noalias !462
  %or.i12 = or i64 %48, %shl.i11
  store i64 %or.i12, ptr %v.i6, align 8, !noalias !462
  %49 = load ptr, ptr %p.i5, align 8, !noalias !462
  %50 = load i64, ptr %v.i6, align 8, !noalias !462
  store ptr %49, ptr %p.addr.i42, align 8
  store i64 %50, ptr %v.addr.i43, align 8
  %51 = load ptr, ptr %p.addr.i42, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %51, ptr align 8 %v.addr.i43, i64 8, i1 false)
  %52 = load i64, ptr %n_bits.addr.i1, align 8, !noalias !462
  %53 = load ptr, ptr %pos.addr.i3, align 8, !noalias !462
  %54 = load i64, ptr %53, align 8
  %add.i13 = add i64 %54, %52
  store i64 %add.i13, ptr %53, align 8
  %55 = load ptr, ptr %storage_ix.addr, align 8
  %56 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !463)
  call void @llvm.experimental.noalias.scope.decl(metadata !466)
  store i64 1, ptr %n_bits.addr.i, align 8, !noalias !468
  store i64 1, ptr %bits.addr.i, align 8, !noalias !468
  store ptr %55, ptr %pos.addr.i, align 8, !noalias !468
  store ptr %56, ptr %array.addr.i, align 8, !noalias !468
  %57 = load ptr, ptr %array.addr.i, align 8, !noalias !468
  %58 = load ptr, ptr %pos.addr.i, align 8, !noalias !468
  %59 = load i64, ptr %58, align 8
  %shr.i = lshr i64 %59, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %57, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !468
  %60 = load ptr, ptr %p.i, align 8, !noalias !468
  %61 = load i8, ptr %60, align 1
  %conv.i = zext i8 %61 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !468
  %62 = load i64, ptr %bits.addr.i, align 8, !noalias !468
  %63 = load ptr, ptr %pos.addr.i, align 8, !noalias !468
  %64 = load i64, ptr %63, align 8
  %and.i = and i64 %64, 7
  %shl.i = shl i64 %62, %and.i
  %65 = load i64, ptr %v.i, align 8, !noalias !468
  %or.i = or i64 %65, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !468
  %66 = load ptr, ptr %p.i, align 8, !noalias !468
  %67 = load i64, ptr %v.i, align 8, !noalias !468
  store ptr %66, ptr %p.addr.i44, align 8
  store i64 %67, ptr %v.addr.i45, align 8
  %68 = load ptr, ptr %p.addr.i44, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %68, ptr align 8 %v.addr.i45, i64 8, i1 false)
  %69 = load i64, ptr %n_bits.addr.i, align 8, !noalias !468
  %70 = load ptr, ptr %pos.addr.i, align 8, !noalias !468
  %71 = load i64, ptr %70, align 8
  %add.i = add i64 %71, %69
  store i64 %add.i, ptr %70, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @BrotliEncodeMlen(i64 noundef %length, ptr noundef %bits, ptr noundef %numbits, ptr noundef %nibblesbits) #0 {
entry:
  %n.addr.i = alloca i64, align 8
  %length.addr = alloca i64, align 8
  %bits.addr = alloca ptr, align 8
  %numbits.addr = alloca ptr, align 8
  %nibblesbits.addr = alloca ptr, align 8
  %lg = alloca i64, align 8
  %mnibbles = alloca i64, align 8
  store i64 %length, ptr %length.addr, align 8
  store ptr %bits, ptr %bits.addr, align 8
  store ptr %numbits, ptr %numbits.addr, align 8
  store ptr %nibblesbits, ptr %nibblesbits.addr, align 8
  %0 = load i64, ptr %length.addr, align 8
  %cmp = icmp eq i64 %0, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, ptr %length.addr, align 8
  %sub = sub i64 %1, 1
  %conv = trunc i64 %sub to i32
  %conv1 = zext i32 %conv to i64
  store i64 %conv1, ptr %n.addr.i, align 8
  %2 = load i64, ptr %n.addr.i, align 8
  %conv.i = trunc i64 %2 to i32
  %3 = call i32 @llvm.ctlz.i32(i32 %conv.i, i1 true)
  %xor.i = xor i32 31, %3
  %add = add i32 %xor.i, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 1, %cond.true ], [ %add, %cond.false ]
  %conv2 = zext i32 %cond to i64
  store i64 %conv2, ptr %lg, align 8
  %4 = load i64, ptr %lg, align 8
  %cmp3 = icmp ult i64 %4, 16
  br i1 %cmp3, label %cond.true5, label %cond.false6

cond.true5:                                       ; preds = %cond.end
  br label %cond.end8

cond.false6:                                      ; preds = %cond.end
  %5 = load i64, ptr %lg, align 8
  %add7 = add i64 %5, 3
  br label %cond.end8

cond.end8:                                        ; preds = %cond.false6, %cond.true5
  %cond9 = phi i64 [ 16, %cond.true5 ], [ %add7, %cond.false6 ]
  %div = udiv i64 %cond9, 4
  store i64 %div, ptr %mnibbles, align 8
  %6 = load i64, ptr %mnibbles, align 8
  %sub10 = sub i64 %6, 4
  %7 = load ptr, ptr %nibblesbits.addr, align 8
  store i64 %sub10, ptr %7, align 8
  %8 = load i64, ptr %mnibbles, align 8
  %mul = mul i64 %8, 4
  %9 = load ptr, ptr %numbits.addr, align 8
  store i64 %mul, ptr %9, align 8
  %10 = load i64, ptr %length.addr, align 8
  %sub11 = sub i64 %10, 1
  %11 = load ptr, ptr %bits.addr, align 8
  store i64 %sub11, ptr %11, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @InitBlockTypeCodeCalculator(ptr noundef %self) #0 {
entry:
  %self.addr = alloca ptr, align 8
  store ptr %self, ptr %self.addr, align 8
  %0 = load ptr, ptr %self.addr, align 8
  %last_type = getelementptr inbounds %struct.BlockTypeCodeCalculator, ptr %0, i32 0, i32 0
  store i64 1, ptr %last_type, align 8
  %1 = load ptr, ptr %self.addr, align 8
  %second_last_type = getelementptr inbounds %struct.BlockTypeCodeCalculator, ptr %1, i32 0, i32 1
  store i64 0, ptr %second_last_type, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @BuildAndStoreBlockSplitCode(ptr noundef %types, ptr noundef %lengths, i64 noundef %num_blocks, i64 noundef %num_types, ptr noundef %tree, ptr noundef %code, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %len.addr.i.i = alloca i32, align 4
  %code.i.i = alloca i32, align 4
  %len.addr.i33 = alloca i32, align 4
  %code.addr.i34 = alloca ptr, align 8
  %n_extra.addr.i = alloca ptr, align 8
  %extra.addr.i = alloca ptr, align 8
  %calculator.addr.i.i = alloca ptr, align 8
  %type.addr.i.i = alloca i8, align 1
  %type_code.i.i = alloca i64, align 8
  %p.addr.i37.i = alloca ptr, align 8
  %v.addr.i38.i = alloca i64, align 8
  %p.addr.i35.i = alloca ptr, align 8
  %v.addr.i36.i = alloca i64, align 8
  %p.addr.i.i = alloca ptr, align 8
  %v.addr.i.i = alloca i64, align 8
  %n_bits.addr.i22.i = alloca i64, align 8
  %bits.addr.i23.i = alloca i64, align 8
  %pos.addr.i24.i = alloca ptr, align 8
  %array.addr.i25.i = alloca ptr, align 8
  %p.i26.i = alloca ptr, align 8
  %v.i27.i = alloca i64, align 8
  %n_bits.addr.i9.i = alloca i64, align 8
  %bits.addr.i10.i = alloca i64, align 8
  %pos.addr.i11.i = alloca ptr, align 8
  %array.addr.i12.i = alloca ptr, align 8
  %p.i13.i = alloca ptr, align 8
  %v.i14.i = alloca i64, align 8
  %n_bits.addr.i.i = alloca i64, align 8
  %bits.addr.i.i = alloca i64, align 8
  %pos.addr.i.i = alloca ptr, align 8
  %array.addr.i.i = alloca ptr, align 8
  %p.i.i = alloca ptr, align 8
  %v.i.i = alloca i64, align 8
  %code.addr.i = alloca ptr, align 8
  %block_len.addr.i = alloca i32, align 4
  %block_type.addr.i = alloca i8, align 1
  %is_first_block.addr.i = alloca i32, align 4
  %storage_ix.addr.i = alloca ptr, align 8
  %storage.addr.i = alloca ptr, align 8
  %typecode.i = alloca i64, align 8
  %lencode.i = alloca i64, align 8
  %len_nextra.i = alloca i32, align 4
  %len_extra.i = alloca i32, align 4
  %len.addr.i = alloca i32, align 4
  %code.i = alloca i32, align 4
  %calculator.addr.i = alloca ptr, align 8
  %type.addr.i = alloca i8, align 1
  %type_code.i = alloca i64, align 8
  %types.addr = alloca ptr, align 8
  %lengths.addr = alloca ptr, align 8
  %num_blocks.addr = alloca i64, align 8
  %num_types.addr = alloca i64, align 8
  %tree.addr = alloca ptr, align 8
  %code.addr = alloca ptr, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %type_histo = alloca [258 x i32], align 16
  %length_histo = alloca [26 x i32], align 16
  %i = alloca i64, align 8
  %type_code_calculator = alloca %struct.BlockTypeCodeCalculator, align 8
  %type_code = alloca i64, align 8
  store ptr %types, ptr %types.addr, align 8
  store ptr %lengths, ptr %lengths.addr, align 8
  store i64 %num_blocks, ptr %num_blocks.addr, align 8
  store i64 %num_types, ptr %num_types.addr, align 8
  store ptr %tree, ptr %tree.addr, align 8
  store ptr %code, ptr %code.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %arraydecay = getelementptr inbounds [258 x i32], ptr %type_histo, i64 0, i64 0
  %0 = load i64, ptr %num_types.addr, align 8
  %add = add i64 %0, 2
  %mul = mul i64 %add, 4
  call void @llvm.memset.p0.i64(ptr align 16 %arraydecay, i8 0, i64 %mul, i1 false)
  %arraydecay1 = getelementptr inbounds [26 x i32], ptr %length_histo, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 16 %arraydecay1, i8 0, i64 104, i1 false)
  call void @InitBlockTypeCodeCalculator(ptr noundef %type_code_calculator)
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, ptr %i, align 8
  %2 = load i64, ptr %num_blocks.addr, align 8
  %cmp = icmp ult i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %types.addr, align 8
  %4 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds i8, ptr %3, i64 %4
  %5 = load i8, ptr %arrayidx, align 1
  store ptr %type_code_calculator, ptr %calculator.addr.i, align 8
  store i8 %5, ptr %type.addr.i, align 1
  %6 = load i8, ptr %type.addr.i, align 1
  %conv.i = zext i8 %6 to i64
  %7 = load ptr, ptr %calculator.addr.i, align 8
  %8 = load i64, ptr %7, align 8
  %add.i = add i64 %8, 1
  %cmp.i = icmp eq i64 %conv.i, %add.i
  br i1 %cmp.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %for.body
  br label %NextBlockTypeCode.exit

cond.false.i:                                     ; preds = %for.body
  %9 = load i8, ptr %type.addr.i, align 1
  %conv2.i = zext i8 %9 to i64
  %10 = load ptr, ptr %calculator.addr.i, align 8
  %second_last_type.i = getelementptr inbounds %struct.BlockTypeCodeCalculator, ptr %10, i32 0, i32 1
  %11 = load i64, ptr %second_last_type.i, align 8
  %cmp3.i = icmp eq i64 %conv2.i, %11
  br i1 %cmp3.i, label %cond.true5.i, label %cond.false6.i

cond.true5.i:                                     ; preds = %cond.false.i
  br label %cond.end.i

cond.false6.i:                                    ; preds = %cond.false.i
  %12 = load i8, ptr %type.addr.i, align 1
  %conv7.i = zext i8 %12 to i32
  %add8.i = add i32 %conv7.i, 2
  br label %cond.end.i

cond.end.i:                                       ; preds = %cond.false6.i, %cond.true5.i
  %cond.i = phi i32 [ 0, %cond.true5.i ], [ %add8.i, %cond.false6.i ]
  br label %NextBlockTypeCode.exit

NextBlockTypeCode.exit:                           ; preds = %cond.end.i, %cond.true.i
  %cond10.i = phi i32 [ 1, %cond.true.i ], [ %cond.i, %cond.end.i ]
  %conv11.i = zext i32 %cond10.i to i64
  store i64 %conv11.i, ptr %type_code.i, align 8
  %13 = load ptr, ptr %calculator.addr.i, align 8
  %14 = load i64, ptr %13, align 8
  %15 = load ptr, ptr %calculator.addr.i, align 8
  %second_last_type13.i = getelementptr inbounds %struct.BlockTypeCodeCalculator, ptr %15, i32 0, i32 1
  store i64 %14, ptr %second_last_type13.i, align 8
  %16 = load i8, ptr %type.addr.i, align 1
  %conv14.i = zext i8 %16 to i64
  %17 = load ptr, ptr %calculator.addr.i, align 8
  store i64 %conv14.i, ptr %17, align 8
  %18 = load i64, ptr %type_code.i, align 8
  store i64 %18, ptr %type_code, align 8
  %19 = load i64, ptr %i, align 8
  %cmp2 = icmp ne i64 %19, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %NextBlockTypeCode.exit
  %20 = load i64, ptr %type_code, align 8
  %arrayidx3 = getelementptr inbounds [258 x i32], ptr %type_histo, i64 0, i64 %20
  %21 = load i32, ptr %arrayidx3, align 4
  %inc = add i32 %21, 1
  store i32 %inc, ptr %arrayidx3, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %NextBlockTypeCode.exit
  %22 = load ptr, ptr %lengths.addr, align 8
  %23 = load i64, ptr %i, align 8
  %arrayidx4 = getelementptr inbounds i32, ptr %22, i64 %23
  %24 = load i32, ptr %arrayidx4, align 4
  store i32 %24, ptr %len.addr.i, align 4
  %25 = load i32, ptr %len.addr.i, align 4
  %cmp.i22 = icmp uge i32 %25, 177
  br i1 %cmp.i22, label %cond.true.i27, label %cond.false.i23

cond.true.i27:                                    ; preds = %if.end
  %26 = load i32, ptr %len.addr.i, align 4
  %cmp1.i = icmp uge i32 %26, 753
  %cond.i28 = select i1 %cmp1.i, i32 20, i32 14
  br label %cond.end.i24

cond.false.i23:                                   ; preds = %if.end
  %27 = load i32, ptr %len.addr.i, align 4
  %cmp2.i = icmp uge i32 %27, 41
  %cond3.i = select i1 %cmp2.i, i32 7, i32 0
  br label %cond.end.i24

cond.end.i24:                                     ; preds = %cond.false.i23, %cond.true.i27
  %cond4.i = phi i32 [ %cond.i28, %cond.true.i27 ], [ %cond3.i, %cond.false.i23 ]
  store i32 %cond4.i, ptr %code.i, align 4
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.body.i, %cond.end.i24
  %28 = load i32, ptr %code.i, align 4
  %cmp5.i = icmp ult i32 %28, 25
  br i1 %cmp5.i, label %land.rhs.i, label %land.end.i

land.rhs.i:                                       ; preds = %while.cond.i
  %29 = load i32, ptr %len.addr.i, align 4
  %30 = load i32, ptr %code.i, align 4
  %add.i25 = add i32 %30, 1
  %idxprom.i = zext i32 %add.i25 to i64
  %arrayidx.i = getelementptr inbounds [26 x %struct.BrotliPrefixCodeRange], ptr @_kBrotliPrefixCodeRanges, i64 0, i64 %idxprom.i
  %31 = load i16, ptr %arrayidx.i, align 4
  %conv.i26 = zext i16 %31 to i32
  %cmp6.i = icmp uge i32 %29, %conv.i26
  br label %land.end.i

land.end.i:                                       ; preds = %land.rhs.i, %while.cond.i
  %32 = phi i1 [ false, %while.cond.i ], [ %cmp6.i, %land.rhs.i ]
  br i1 %32, label %while.body.i, label %BlockLengthPrefixCode.exit

while.body.i:                                     ; preds = %land.end.i
  %33 = load i32, ptr %code.i, align 4
  %inc.i = add i32 %33, 1
  store i32 %inc.i, ptr %code.i, align 4
  br label %while.cond.i, !llvm.loop !310

BlockLengthPrefixCode.exit:                       ; preds = %land.end.i
  %34 = load i32, ptr %code.i, align 4
  %idxprom = zext i32 %34 to i64
  %arrayidx6 = getelementptr inbounds [26 x i32], ptr %length_histo, i64 0, i64 %idxprom
  %35 = load i32, ptr %arrayidx6, align 4
  %inc7 = add i32 %35, 1
  store i32 %inc7, ptr %arrayidx6, align 4
  br label %for.inc

for.inc:                                          ; preds = %BlockLengthPrefixCode.exit
  %36 = load i64, ptr %i, align 8
  %inc8 = add i64 %36, 1
  store i64 %inc8, ptr %i, align 8
  br label %for.cond, !llvm.loop !469

for.end:                                          ; preds = %for.cond
  %37 = load i64, ptr %num_types.addr, align 8
  %sub = sub i64 %37, 1
  %38 = load ptr, ptr %storage_ix.addr, align 8
  %39 = load ptr, ptr %storage.addr, align 8
  call void @StoreVarLenUint8(i64 noundef %sub, ptr noundef %38, ptr noundef %39)
  %40 = load i64, ptr %num_types.addr, align 8
  %cmp9 = icmp ugt i64 %40, 1
  br i1 %cmp9, label %if.then10, label %if.end21

if.then10:                                        ; preds = %for.end
  %arrayidx11 = getelementptr inbounds [258 x i32], ptr %type_histo, i64 0, i64 0
  %41 = load i64, ptr %num_types.addr, align 8
  %add12 = add i64 %41, 2
  %42 = load i64, ptr %num_types.addr, align 8
  %add13 = add i64 %42, 2
  %43 = load ptr, ptr %tree.addr, align 8
  %44 = load ptr, ptr %code.addr, align 8
  %type_depths = getelementptr inbounds %struct.BlockSplitCode, ptr %44, i32 0, i32 1
  %arrayidx14 = getelementptr inbounds [258 x i8], ptr %type_depths, i64 0, i64 0
  %45 = load ptr, ptr %code.addr, align 8
  %type_bits = getelementptr inbounds %struct.BlockSplitCode, ptr %45, i32 0, i32 2
  %arrayidx15 = getelementptr inbounds [258 x i16], ptr %type_bits, i64 0, i64 0
  %46 = load ptr, ptr %storage_ix.addr, align 8
  %47 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreHuffmanTree(ptr noundef %arrayidx11, i64 noundef %add12, i64 noundef %add13, ptr noundef %43, ptr noundef %arrayidx14, ptr noundef %arrayidx15, ptr noundef %46, ptr noundef %47)
  %arrayidx16 = getelementptr inbounds [26 x i32], ptr %length_histo, i64 0, i64 0
  %48 = load ptr, ptr %tree.addr, align 8
  %49 = load ptr, ptr %code.addr, align 8
  %length_depths = getelementptr inbounds %struct.BlockSplitCode, ptr %49, i32 0, i32 3
  %arrayidx17 = getelementptr inbounds [26 x i8], ptr %length_depths, i64 0, i64 0
  %50 = load ptr, ptr %code.addr, align 8
  %length_bits = getelementptr inbounds %struct.BlockSplitCode, ptr %50, i32 0, i32 4
  %arrayidx18 = getelementptr inbounds [26 x i16], ptr %length_bits, i64 0, i64 0
  %51 = load ptr, ptr %storage_ix.addr, align 8
  %52 = load ptr, ptr %storage.addr, align 8
  call void @BuildAndStoreHuffmanTree(ptr noundef %arrayidx16, i64 noundef 26, i64 noundef 26, ptr noundef %48, ptr noundef %arrayidx17, ptr noundef %arrayidx18, ptr noundef %51, ptr noundef %52)
  %53 = load ptr, ptr %code.addr, align 8
  %54 = load ptr, ptr %lengths.addr, align 8
  %arrayidx19 = getelementptr inbounds i32, ptr %54, i64 0
  %55 = load i32, ptr %arrayidx19, align 4
  %56 = load ptr, ptr %types.addr, align 8
  %arrayidx20 = getelementptr inbounds i8, ptr %56, i64 0
  %57 = load i8, ptr %arrayidx20, align 1
  %58 = load ptr, ptr %storage_ix.addr, align 8
  %59 = load ptr, ptr %storage.addr, align 8
  store ptr %53, ptr %code.addr.i, align 8
  store i32 %55, ptr %block_len.addr.i, align 4
  store i8 %57, ptr %block_type.addr.i, align 1
  store i32 1, ptr %is_first_block.addr.i, align 4
  store ptr %58, ptr %storage_ix.addr.i, align 8
  store ptr %59, ptr %storage.addr.i, align 8
  %60 = load ptr, ptr %code.addr.i, align 8
  %61 = load i8, ptr %block_type.addr.i, align 1
  store ptr %60, ptr %calculator.addr.i.i, align 8
  store i8 %61, ptr %type.addr.i.i, align 1
  %62 = load i8, ptr %type.addr.i.i, align 1
  %conv.i39.i = zext i8 %62 to i64
  %63 = load ptr, ptr %calculator.addr.i.i, align 8
  %64 = load i64, ptr %63, align 8
  %add.i40.i = add i64 %64, 1
  %cmp.i.i = icmp eq i64 %conv.i39.i, %add.i40.i
  br i1 %cmp.i.i, label %cond.true.i.i, label %cond.false.i.i

cond.true.i.i:                                    ; preds = %if.then10
  br label %NextBlockTypeCode.exit.i

cond.false.i.i:                                   ; preds = %if.then10
  %65 = load i8, ptr %type.addr.i.i, align 1
  %conv2.i.i = zext i8 %65 to i64
  %66 = load ptr, ptr %calculator.addr.i.i, align 8
  %second_last_type.i.i = getelementptr inbounds %struct.BlockTypeCodeCalculator, ptr %66, i32 0, i32 1
  %67 = load i64, ptr %second_last_type.i.i, align 8
  %cmp3.i.i = icmp eq i64 %conv2.i.i, %67
  br i1 %cmp3.i.i, label %cond.true5.i.i, label %cond.false6.i.i

cond.true5.i.i:                                   ; preds = %cond.false.i.i
  br label %cond.end.i.i

cond.false6.i.i:                                  ; preds = %cond.false.i.i
  %68 = load i8, ptr %type.addr.i.i, align 1
  %conv7.i.i = zext i8 %68 to i32
  %add8.i.i = add i32 %conv7.i.i, 2
  br label %cond.end.i.i

cond.end.i.i:                                     ; preds = %cond.false6.i.i, %cond.true5.i.i
  %cond.i.i = phi i32 [ 0, %cond.true5.i.i ], [ %add8.i.i, %cond.false6.i.i ]
  br label %NextBlockTypeCode.exit.i

NextBlockTypeCode.exit.i:                         ; preds = %cond.end.i.i, %cond.true.i.i
  %cond10.i.i = phi i32 [ 1, %cond.true.i.i ], [ %cond.i.i, %cond.end.i.i ]
  %conv11.i.i = zext i32 %cond10.i.i to i64
  store i64 %conv11.i.i, ptr %type_code.i.i, align 8
  %69 = load ptr, ptr %calculator.addr.i.i, align 8
  %70 = load i64, ptr %69, align 8
  %71 = load ptr, ptr %calculator.addr.i.i, align 8
  %second_last_type13.i.i = getelementptr inbounds %struct.BlockTypeCodeCalculator, ptr %71, i32 0, i32 1
  store i64 %70, ptr %second_last_type13.i.i, align 8
  %72 = load i8, ptr %type.addr.i.i, align 1
  %conv14.i.i = zext i8 %72 to i64
  %73 = load ptr, ptr %calculator.addr.i.i, align 8
  store i64 %conv14.i.i, ptr %73, align 8
  %74 = load i64, ptr %type_code.i.i, align 8
  store i64 %74, ptr %typecode.i, align 8
  %75 = load i32, ptr %is_first_block.addr.i, align 4
  %tobool.i = icmp ne i32 %75, 0
  br i1 %tobool.i, label %StoreBlockSwitch.exit, label %if.then.i

if.then.i:                                        ; preds = %NextBlockTypeCode.exit.i
  %76 = load ptr, ptr %code.addr.i, align 8
  %type_depths.i = getelementptr inbounds %struct.BlockSplitCode, ptr %76, i32 0, i32 1
  %77 = load i64, ptr %typecode.i, align 8
  %arrayidx.i29 = getelementptr inbounds [258 x i8], ptr %type_depths.i, i64 0, i64 %77
  %78 = load i8, ptr %arrayidx.i29, align 1
  %conv.i30 = zext i8 %78 to i64
  %79 = load ptr, ptr %code.addr.i, align 8
  %type_bits.i = getelementptr inbounds %struct.BlockSplitCode, ptr %79, i32 0, i32 2
  %80 = load i64, ptr %typecode.i, align 8
  %arrayidx1.i = getelementptr inbounds [258 x i16], ptr %type_bits.i, i64 0, i64 %80
  %81 = load i16, ptr %arrayidx1.i, align 2
  %conv2.i31 = zext i16 %81 to i64
  %82 = load ptr, ptr %storage_ix.addr.i, align 8
  %83 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !470)
  call void @llvm.experimental.noalias.scope.decl(metadata !473)
  store i64 %conv.i30, ptr %n_bits.addr.i22.i, align 8, !noalias !475
  store i64 %conv2.i31, ptr %bits.addr.i23.i, align 8, !noalias !475
  store ptr %82, ptr %pos.addr.i24.i, align 8, !noalias !475
  store ptr %83, ptr %array.addr.i25.i, align 8, !noalias !475
  %84 = load ptr, ptr %array.addr.i25.i, align 8, !noalias !475
  %85 = load ptr, ptr %pos.addr.i24.i, align 8, !noalias !475
  %86 = load i64, ptr %85, align 8
  %shr.i28.i = lshr i64 %86, 3
  %arrayidx.i29.i = getelementptr inbounds i8, ptr %84, i64 %shr.i28.i
  store ptr %arrayidx.i29.i, ptr %p.i26.i, align 8, !noalias !475
  %87 = load ptr, ptr %p.i26.i, align 8, !noalias !475
  %88 = load i8, ptr %87, align 1
  %conv.i30.i = zext i8 %88 to i64
  store i64 %conv.i30.i, ptr %v.i27.i, align 8, !noalias !475
  %89 = load i64, ptr %bits.addr.i23.i, align 8, !noalias !475
  %90 = load ptr, ptr %pos.addr.i24.i, align 8, !noalias !475
  %91 = load i64, ptr %90, align 8
  %and.i31.i = and i64 %91, 7
  %shl.i32.i = shl i64 %89, %and.i31.i
  %92 = load i64, ptr %v.i27.i, align 8, !noalias !475
  %or.i33.i = or i64 %92, %shl.i32.i
  store i64 %or.i33.i, ptr %v.i27.i, align 8, !noalias !475
  %93 = load ptr, ptr %p.i26.i, align 8, !noalias !475
  %94 = load i64, ptr %v.i27.i, align 8, !noalias !475
  store ptr %93, ptr %p.addr.i.i, align 8
  store i64 %94, ptr %v.addr.i.i, align 8
  %95 = load ptr, ptr %p.addr.i.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %95, ptr align 8 %v.addr.i.i, i64 8, i1 false)
  %96 = load i64, ptr %n_bits.addr.i22.i, align 8, !noalias !475
  %97 = load ptr, ptr %pos.addr.i24.i, align 8, !noalias !475
  %98 = load i64, ptr %97, align 8
  %add.i34.i = add i64 %98, %96
  store i64 %add.i34.i, ptr %97, align 8
  br label %StoreBlockSwitch.exit

StoreBlockSwitch.exit:                            ; preds = %if.then.i, %NextBlockTypeCode.exit.i
  %99 = load i32, ptr %block_len.addr.i, align 4
  store i32 %99, ptr %len.addr.i33, align 4
  store ptr %lencode.i, ptr %code.addr.i34, align 8
  store ptr %len_nextra.i, ptr %n_extra.addr.i, align 8
  store ptr %len_extra.i, ptr %extra.addr.i, align 8
  %100 = load i32, ptr %len.addr.i33, align 4
  store i32 %100, ptr %len.addr.i.i, align 4
  %101 = load i32, ptr %len.addr.i.i, align 4
  %cmp.i.i35 = icmp uge i32 %101, 177
  br i1 %cmp.i.i35, label %cond.true.i.i43, label %cond.false.i.i36

cond.true.i.i43:                                  ; preds = %StoreBlockSwitch.exit
  %102 = load i32, ptr %len.addr.i.i, align 4
  %cmp1.i.i = icmp uge i32 %102, 753
  %cond.i.i44 = select i1 %cmp1.i.i, i32 20, i32 14
  br label %cond.end.i.i37

cond.false.i.i36:                                 ; preds = %StoreBlockSwitch.exit
  %103 = load i32, ptr %len.addr.i.i, align 4
  %cmp2.i.i = icmp uge i32 %103, 41
  %cond3.i.i = select i1 %cmp2.i.i, i32 7, i32 0
  br label %cond.end.i.i37

cond.end.i.i37:                                   ; preds = %cond.false.i.i36, %cond.true.i.i43
  %cond4.i.i = phi i32 [ %cond.i.i44, %cond.true.i.i43 ], [ %cond3.i.i, %cond.false.i.i36 ]
  store i32 %cond4.i.i, ptr %code.i.i, align 4
  br label %while.cond.i.i

while.cond.i.i:                                   ; preds = %while.body.i.i, %cond.end.i.i37
  %104 = load i32, ptr %code.i.i, align 4
  %cmp5.i.i = icmp ult i32 %104, 25
  br i1 %cmp5.i.i, label %land.rhs.i.i, label %land.end.i.i

land.rhs.i.i:                                     ; preds = %while.cond.i.i
  %105 = load i32, ptr %len.addr.i.i, align 4
  %106 = load i32, ptr %code.i.i, align 4
  %add.i.i40 = add i32 %106, 1
  %idxprom.i.i = zext i32 %add.i.i40 to i64
  %arrayidx.i.i41 = getelementptr inbounds [26 x %struct.BrotliPrefixCodeRange], ptr @_kBrotliPrefixCodeRanges, i64 0, i64 %idxprom.i.i
  %107 = load i16, ptr %arrayidx.i.i41, align 4
  %conv.i.i42 = zext i16 %107 to i32
  %cmp6.i.i = icmp uge i32 %105, %conv.i.i42
  br label %land.end.i.i

land.end.i.i:                                     ; preds = %land.rhs.i.i, %while.cond.i.i
  %108 = phi i1 [ false, %while.cond.i.i ], [ %cmp6.i.i, %land.rhs.i.i ]
  br i1 %108, label %while.body.i.i, label %GetBlockLengthPrefixCode.exit

while.body.i.i:                                   ; preds = %land.end.i.i
  %109 = load i32, ptr %code.i.i, align 4
  %inc.i.i = add i32 %109, 1
  store i32 %inc.i.i, ptr %code.i.i, align 4
  br label %while.cond.i.i, !llvm.loop !310

GetBlockLengthPrefixCode.exit:                    ; preds = %land.end.i.i
  %110 = load i32, ptr %code.i.i, align 4
  %conv.i38 = zext i32 %110 to i64
  %111 = load ptr, ptr %code.addr.i34, align 8
  store i64 %conv.i38, ptr %111, align 8
  %112 = load ptr, ptr %code.addr.i34, align 8
  %113 = load i64, ptr %112, align 8
  %arrayidx.i39 = getelementptr inbounds [26 x %struct.BrotliPrefixCodeRange], ptr @_kBrotliPrefixCodeRanges, i64 0, i64 %113
  %nbits.i = getelementptr inbounds %struct.BrotliPrefixCodeRange, ptr %arrayidx.i39, i32 0, i32 1
  %114 = load i8, ptr %nbits.i, align 2
  %conv1.i = zext i8 %114 to i32
  %115 = load ptr, ptr %n_extra.addr.i, align 8
  store i32 %conv1.i, ptr %115, align 4
  %116 = load i32, ptr %len.addr.i33, align 4
  %117 = load ptr, ptr %code.addr.i34, align 8
  %118 = load i64, ptr %117, align 8
  %arrayidx2.i = getelementptr inbounds [26 x %struct.BrotliPrefixCodeRange], ptr @_kBrotliPrefixCodeRanges, i64 0, i64 %118
  %119 = load i16, ptr %arrayidx2.i, align 4
  %conv3.i = zext i16 %119 to i32
  %sub.i = sub i32 %116, %conv3.i
  %120 = load ptr, ptr %extra.addr.i, align 8
  store i32 %sub.i, ptr %120, align 4
  %121 = load ptr, ptr %code.addr.i, align 8
  %length_depths.i = getelementptr inbounds %struct.BlockSplitCode, ptr %121, i32 0, i32 3
  %122 = load i64, ptr %lencode.i, align 8
  %arrayidx3.i = getelementptr inbounds [26 x i8], ptr %length_depths.i, i64 0, i64 %122
  %123 = load i8, ptr %arrayidx3.i, align 1
  %conv4.i = zext i8 %123 to i64
  %124 = load ptr, ptr %code.addr.i, align 8
  %length_bits.i = getelementptr inbounds %struct.BlockSplitCode, ptr %124, i32 0, i32 4
  %125 = load i64, ptr %lencode.i, align 8
  %arrayidx5.i = getelementptr inbounds [26 x i16], ptr %length_bits.i, i64 0, i64 %125
  %126 = load i16, ptr %arrayidx5.i, align 2
  %conv6.i = zext i16 %126 to i64
  %127 = load ptr, ptr %storage_ix.addr.i, align 8
  %128 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !476)
  call void @llvm.experimental.noalias.scope.decl(metadata !479)
  store i64 %conv4.i, ptr %n_bits.addr.i9.i, align 8, !noalias !481
  store i64 %conv6.i, ptr %bits.addr.i10.i, align 8, !noalias !481
  store ptr %127, ptr %pos.addr.i11.i, align 8, !noalias !481
  store ptr %128, ptr %array.addr.i12.i, align 8, !noalias !481
  %129 = load ptr, ptr %array.addr.i12.i, align 8, !noalias !481
  %130 = load ptr, ptr %pos.addr.i11.i, align 8, !noalias !481
  %131 = load i64, ptr %130, align 8
  %shr.i15.i = lshr i64 %131, 3
  %arrayidx.i16.i = getelementptr inbounds i8, ptr %129, i64 %shr.i15.i
  store ptr %arrayidx.i16.i, ptr %p.i13.i, align 8, !noalias !481
  %132 = load ptr, ptr %p.i13.i, align 8, !noalias !481
  %133 = load i8, ptr %132, align 1
  %conv.i17.i = zext i8 %133 to i64
  store i64 %conv.i17.i, ptr %v.i14.i, align 8, !noalias !481
  %134 = load i64, ptr %bits.addr.i10.i, align 8, !noalias !481
  %135 = load ptr, ptr %pos.addr.i11.i, align 8, !noalias !481
  %136 = load i64, ptr %135, align 8
  %and.i18.i = and i64 %136, 7
  %shl.i19.i = shl i64 %134, %and.i18.i
  %137 = load i64, ptr %v.i14.i, align 8, !noalias !481
  %or.i20.i = or i64 %137, %shl.i19.i
  store i64 %or.i20.i, ptr %v.i14.i, align 8, !noalias !481
  %138 = load ptr, ptr %p.i13.i, align 8, !noalias !481
  %139 = load i64, ptr %v.i14.i, align 8, !noalias !481
  store ptr %138, ptr %p.addr.i35.i, align 8
  store i64 %139, ptr %v.addr.i36.i, align 8
  %140 = load ptr, ptr %p.addr.i35.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %140, ptr align 8 %v.addr.i36.i, i64 8, i1 false)
  %141 = load i64, ptr %n_bits.addr.i9.i, align 8, !noalias !481
  %142 = load ptr, ptr %pos.addr.i11.i, align 8, !noalias !481
  %143 = load i64, ptr %142, align 8
  %add.i21.i = add i64 %143, %141
  store i64 %add.i21.i, ptr %142, align 8
  %144 = load i32, ptr %len_nextra.i, align 4
  %conv7.i32 = zext i32 %144 to i64
  %145 = load i32, ptr %len_extra.i, align 4
  %conv8.i = zext i32 %145 to i64
  %146 = load ptr, ptr %storage_ix.addr.i, align 8
  %147 = load ptr, ptr %storage.addr.i, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !482)
  call void @llvm.experimental.noalias.scope.decl(metadata !485)
  store i64 %conv7.i32, ptr %n_bits.addr.i.i, align 8, !noalias !487
  store i64 %conv8.i, ptr %bits.addr.i.i, align 8, !noalias !487
  store ptr %146, ptr %pos.addr.i.i, align 8, !noalias !487
  store ptr %147, ptr %array.addr.i.i, align 8, !noalias !487
  %148 = load ptr, ptr %array.addr.i.i, align 8, !noalias !487
  %149 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !487
  %150 = load i64, ptr %149, align 8
  %shr.i.i = lshr i64 %150, 3
  %arrayidx.i.i = getelementptr inbounds i8, ptr %148, i64 %shr.i.i
  store ptr %arrayidx.i.i, ptr %p.i.i, align 8, !noalias !487
  %151 = load ptr, ptr %p.i.i, align 8, !noalias !487
  %152 = load i8, ptr %151, align 1
  %conv.i.i = zext i8 %152 to i64
  store i64 %conv.i.i, ptr %v.i.i, align 8, !noalias !487
  %153 = load i64, ptr %bits.addr.i.i, align 8, !noalias !487
  %154 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !487
  %155 = load i64, ptr %154, align 8
  %and.i.i = and i64 %155, 7
  %shl.i.i = shl i64 %153, %and.i.i
  %156 = load i64, ptr %v.i.i, align 8, !noalias !487
  %or.i.i = or i64 %156, %shl.i.i
  store i64 %or.i.i, ptr %v.i.i, align 8, !noalias !487
  %157 = load ptr, ptr %p.i.i, align 8, !noalias !487
  %158 = load i64, ptr %v.i.i, align 8, !noalias !487
  store ptr %157, ptr %p.addr.i37.i, align 8
  store i64 %158, ptr %v.addr.i38.i, align 8
  %159 = load ptr, ptr %p.addr.i37.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %159, ptr align 8 %v.addr.i38.i, i64 8, i1 false)
  %160 = load i64, ptr %n_bits.addr.i.i, align 8, !noalias !487
  %161 = load ptr, ptr %pos.addr.i.i, align 8, !noalias !487
  %162 = load i64, ptr %161, align 8
  %add.i.i = add i64 %162, %160
  store i64 %add.i.i, ptr %161, align 8
  br label %if.end21

if.end21:                                         ; preds = %GetBlockLengthPrefixCode.exit, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @StoreVarLenUint8(i64 noundef %n, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i45 = alloca ptr, align 8
  %v.addr.i46 = alloca i64, align 8
  %p.addr.i43 = alloca ptr, align 8
  %v.addr.i44 = alloca i64, align 8
  %p.addr.i41 = alloca ptr, align 8
  %v.addr.i42 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n.addr.i = alloca i64, align 8
  %n_bits.addr.i27 = alloca i64, align 8
  %bits.addr.i28 = alloca i64, align 8
  %pos.addr.i29 = alloca ptr, align 8
  %array.addr.i30 = alloca ptr, align 8
  %p.i31 = alloca ptr, align 8
  %v.i32 = alloca i64, align 8
  %n_bits.addr.i14 = alloca i64, align 8
  %bits.addr.i15 = alloca i64, align 8
  %pos.addr.i16 = alloca ptr, align 8
  %array.addr.i17 = alloca ptr, align 8
  %p.i18 = alloca ptr, align 8
  %v.i19 = alloca i64, align 8
  %n_bits.addr.i1 = alloca i64, align 8
  %bits.addr.i2 = alloca i64, align 8
  %pos.addr.i3 = alloca ptr, align 8
  %array.addr.i4 = alloca ptr, align 8
  %p.i5 = alloca ptr, align 8
  %v.i6 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %n.addr = alloca i64, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %nbits = alloca i64, align 8
  store i64 %n, ptr %n.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load i64, ptr %n.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %storage_ix.addr, align 8
  %2 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !488)
  call void @llvm.experimental.noalias.scope.decl(metadata !491)
  store i64 1, ptr %n_bits.addr.i27, align 8, !noalias !493
  store i64 0, ptr %bits.addr.i28, align 8, !noalias !493
  store ptr %1, ptr %pos.addr.i29, align 8, !noalias !493
  store ptr %2, ptr %array.addr.i30, align 8, !noalias !493
  %3 = load ptr, ptr %array.addr.i30, align 8, !noalias !493
  %4 = load ptr, ptr %pos.addr.i29, align 8, !noalias !493
  %5 = load i64, ptr %4, align 8
  %shr.i33 = lshr i64 %5, 3
  %arrayidx.i34 = getelementptr inbounds i8, ptr %3, i64 %shr.i33
  store ptr %arrayidx.i34, ptr %p.i31, align 8, !noalias !493
  %6 = load ptr, ptr %p.i31, align 8, !noalias !493
  %7 = load i8, ptr %6, align 1
  %conv.i35 = zext i8 %7 to i64
  store i64 %conv.i35, ptr %v.i32, align 8, !noalias !493
  %8 = load i64, ptr %bits.addr.i28, align 8, !noalias !493
  %9 = load ptr, ptr %pos.addr.i29, align 8, !noalias !493
  %10 = load i64, ptr %9, align 8
  %and.i36 = and i64 %10, 7
  %shl.i37 = shl i64 %8, %and.i36
  %11 = load i64, ptr %v.i32, align 8, !noalias !493
  %or.i38 = or i64 %11, %shl.i37
  store i64 %or.i38, ptr %v.i32, align 8, !noalias !493
  %12 = load ptr, ptr %p.i31, align 8, !noalias !493
  %13 = load i64, ptr %v.i32, align 8, !noalias !493
  store ptr %12, ptr %p.addr.i, align 8
  store i64 %13, ptr %v.addr.i, align 8
  %14 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %14, ptr align 8 %v.addr.i, i64 8, i1 false)
  %15 = load i64, ptr %n_bits.addr.i27, align 8, !noalias !493
  %16 = load ptr, ptr %pos.addr.i29, align 8, !noalias !493
  %17 = load i64, ptr %16, align 8
  %add.i39 = add i64 %17, %15
  store i64 %add.i39, ptr %16, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %18 = load i64, ptr %n.addr, align 8
  store i64 %18, ptr %n.addr.i, align 8
  %19 = load i64, ptr %n.addr.i, align 8
  %conv.i40 = trunc i64 %19 to i32
  %20 = call i32 @llvm.ctlz.i32(i32 %conv.i40, i1 true)
  %xor.i = xor i32 31, %20
  %conv = zext i32 %xor.i to i64
  store i64 %conv, ptr %nbits, align 8
  %21 = load ptr, ptr %storage_ix.addr, align 8
  %22 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !494)
  call void @llvm.experimental.noalias.scope.decl(metadata !497)
  store i64 1, ptr %n_bits.addr.i14, align 8, !noalias !499
  store i64 1, ptr %bits.addr.i15, align 8, !noalias !499
  store ptr %21, ptr %pos.addr.i16, align 8, !noalias !499
  store ptr %22, ptr %array.addr.i17, align 8, !noalias !499
  %23 = load ptr, ptr %array.addr.i17, align 8, !noalias !499
  %24 = load ptr, ptr %pos.addr.i16, align 8, !noalias !499
  %25 = load i64, ptr %24, align 8
  %shr.i20 = lshr i64 %25, 3
  %arrayidx.i21 = getelementptr inbounds i8, ptr %23, i64 %shr.i20
  store ptr %arrayidx.i21, ptr %p.i18, align 8, !noalias !499
  %26 = load ptr, ptr %p.i18, align 8, !noalias !499
  %27 = load i8, ptr %26, align 1
  %conv.i22 = zext i8 %27 to i64
  store i64 %conv.i22, ptr %v.i19, align 8, !noalias !499
  %28 = load i64, ptr %bits.addr.i15, align 8, !noalias !499
  %29 = load ptr, ptr %pos.addr.i16, align 8, !noalias !499
  %30 = load i64, ptr %29, align 8
  %and.i23 = and i64 %30, 7
  %shl.i24 = shl i64 %28, %and.i23
  %31 = load i64, ptr %v.i19, align 8, !noalias !499
  %or.i25 = or i64 %31, %shl.i24
  store i64 %or.i25, ptr %v.i19, align 8, !noalias !499
  %32 = load ptr, ptr %p.i18, align 8, !noalias !499
  %33 = load i64, ptr %v.i19, align 8, !noalias !499
  store ptr %32, ptr %p.addr.i41, align 8
  store i64 %33, ptr %v.addr.i42, align 8
  %34 = load ptr, ptr %p.addr.i41, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %34, ptr align 8 %v.addr.i42, i64 8, i1 false)
  %35 = load i64, ptr %n_bits.addr.i14, align 8, !noalias !499
  %36 = load ptr, ptr %pos.addr.i16, align 8, !noalias !499
  %37 = load i64, ptr %36, align 8
  %add.i26 = add i64 %37, %35
  store i64 %add.i26, ptr %36, align 8
  %38 = load i64, ptr %nbits, align 8
  %39 = load ptr, ptr %storage_ix.addr, align 8
  %40 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !500)
  call void @llvm.experimental.noalias.scope.decl(metadata !503)
  store i64 3, ptr %n_bits.addr.i1, align 8, !noalias !505
  store i64 %38, ptr %bits.addr.i2, align 8, !noalias !505
  store ptr %39, ptr %pos.addr.i3, align 8, !noalias !505
  store ptr %40, ptr %array.addr.i4, align 8, !noalias !505
  %41 = load ptr, ptr %array.addr.i4, align 8, !noalias !505
  %42 = load ptr, ptr %pos.addr.i3, align 8, !noalias !505
  %43 = load i64, ptr %42, align 8
  %shr.i7 = lshr i64 %43, 3
  %arrayidx.i8 = getelementptr inbounds i8, ptr %41, i64 %shr.i7
  store ptr %arrayidx.i8, ptr %p.i5, align 8, !noalias !505
  %44 = load ptr, ptr %p.i5, align 8, !noalias !505
  %45 = load i8, ptr %44, align 1
  %conv.i9 = zext i8 %45 to i64
  store i64 %conv.i9, ptr %v.i6, align 8, !noalias !505
  %46 = load i64, ptr %bits.addr.i2, align 8, !noalias !505
  %47 = load ptr, ptr %pos.addr.i3, align 8, !noalias !505
  %48 = load i64, ptr %47, align 8
  %and.i10 = and i64 %48, 7
  %shl.i11 = shl i64 %46, %and.i10
  %49 = load i64, ptr %v.i6, align 8, !noalias !505
  %or.i12 = or i64 %49, %shl.i11
  store i64 %or.i12, ptr %v.i6, align 8, !noalias !505
  %50 = load ptr, ptr %p.i5, align 8, !noalias !505
  %51 = load i64, ptr %v.i6, align 8, !noalias !505
  store ptr %50, ptr %p.addr.i43, align 8
  store i64 %51, ptr %v.addr.i44, align 8
  %52 = load ptr, ptr %p.addr.i43, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %52, ptr align 8 %v.addr.i44, i64 8, i1 false)
  %53 = load i64, ptr %n_bits.addr.i1, align 8, !noalias !505
  %54 = load ptr, ptr %pos.addr.i3, align 8, !noalias !505
  %55 = load i64, ptr %54, align 8
  %add.i13 = add i64 %55, %53
  store i64 %add.i13, ptr %54, align 8
  %56 = load i64, ptr %nbits, align 8
  %57 = load i64, ptr %n.addr, align 8
  %58 = load i64, ptr %nbits, align 8
  %shl = shl i64 1, %58
  %sub = sub i64 %57, %shl
  %59 = load ptr, ptr %storage_ix.addr, align 8
  %60 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !506)
  call void @llvm.experimental.noalias.scope.decl(metadata !509)
  store i64 %56, ptr %n_bits.addr.i, align 8, !noalias !511
  store i64 %sub, ptr %bits.addr.i, align 8, !noalias !511
  store ptr %59, ptr %pos.addr.i, align 8, !noalias !511
  store ptr %60, ptr %array.addr.i, align 8, !noalias !511
  %61 = load ptr, ptr %array.addr.i, align 8, !noalias !511
  %62 = load ptr, ptr %pos.addr.i, align 8, !noalias !511
  %63 = load i64, ptr %62, align 8
  %shr.i = lshr i64 %63, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %61, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !511
  %64 = load ptr, ptr %p.i, align 8, !noalias !511
  %65 = load i8, ptr %64, align 1
  %conv.i = zext i8 %65 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !511
  %66 = load i64, ptr %bits.addr.i, align 8, !noalias !511
  %67 = load ptr, ptr %pos.addr.i, align 8, !noalias !511
  %68 = load i64, ptr %67, align 8
  %and.i = and i64 %68, 7
  %shl.i = shl i64 %66, %and.i
  %69 = load i64, ptr %v.i, align 8, !noalias !511
  %or.i = or i64 %69, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !511
  %70 = load ptr, ptr %p.i, align 8, !noalias !511
  %71 = load i64, ptr %v.i, align 8, !noalias !511
  store ptr %70, ptr %p.addr.i45, align 8
  store i64 %71, ptr %v.addr.i46, align 8
  %72 = load ptr, ptr %p.addr.i45, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %72, ptr align 8 %v.addr.i46, i64 8, i1 false)
  %73 = load i64, ptr %n_bits.addr.i, align 8, !noalias !511
  %74 = load ptr, ptr %pos.addr.i, align 8, !noalias !511
  %75 = load i64, ptr %74, align 8
  %add.i = add i64 %75, %73
  store i64 %add.i, ptr %74, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @MoveToFrontTransform(ptr noalias noundef %v_in, i64 noundef %v_size, ptr noundef %v_out) #0 {
entry:
  %v_in.addr = alloca ptr, align 8
  %v_size.addr = alloca i64, align 8
  %v_out.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %mtf = alloca [256 x i8], align 16
  %max_value = alloca i32, align 4
  %mtf_size = alloca i64, align 8
  %index = alloca i64, align 8
  store ptr %v_in, ptr %v_in.addr, align 8
  store i64 %v_size, ptr %v_size.addr, align 8
  store ptr %v_out, ptr %v_out.addr, align 8
  %0 = load i64, ptr %v_size.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end28

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %v_in.addr, align 8
  %arrayidx = getelementptr inbounds i32, ptr %1, i64 0
  %2 = load i32, ptr %arrayidx, align 4
  store i32 %2, ptr %max_value, align 4
  store i64 1, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i64, ptr %i, align 8
  %4 = load i64, ptr %v_size.addr, align 8
  %cmp1 = icmp ult i64 %3, %4
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %v_in.addr, align 8
  %6 = load i64, ptr %i, align 8
  %arrayidx2 = getelementptr inbounds i32, ptr %5, i64 %6
  %7 = load i32, ptr %arrayidx2, align 4
  %8 = load i32, ptr %max_value, align 4
  %cmp3 = icmp ugt i32 %7, %8
  br i1 %cmp3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %for.body
  %9 = load ptr, ptr %v_in.addr, align 8
  %10 = load i64, ptr %i, align 8
  %arrayidx5 = getelementptr inbounds i32, ptr %9, i64 %10
  %11 = load i32, ptr %arrayidx5, align 4
  store i32 %11, ptr %max_value, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %12 = load i64, ptr %i, align 8
  %inc = add i64 %12, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !512

for.end:                                          ; preds = %for.cond
  store i64 0, ptr %i, align 8
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc13, %for.end
  %13 = load i64, ptr %i, align 8
  %14 = load i32, ptr %max_value, align 4
  %conv = zext i32 %14 to i64
  %cmp8 = icmp ule i64 %13, %conv
  br i1 %cmp8, label %for.body10, label %for.end15

for.body10:                                       ; preds = %for.cond7
  %15 = load i64, ptr %i, align 8
  %conv11 = trunc i64 %15 to i8
  %16 = load i64, ptr %i, align 8
  %arrayidx12 = getelementptr inbounds [256 x i8], ptr %mtf, i64 0, i64 %16
  store i8 %conv11, ptr %arrayidx12, align 1
  br label %for.inc13

for.inc13:                                        ; preds = %for.body10
  %17 = load i64, ptr %i, align 8
  %inc14 = add i64 %17, 1
  store i64 %inc14, ptr %i, align 8
  br label %for.cond7, !llvm.loop !513

for.end15:                                        ; preds = %for.cond7
  %18 = load i32, ptr %max_value, align 4
  %add = add i32 %18, 1
  %conv16 = zext i32 %add to i64
  store i64 %conv16, ptr %mtf_size, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc26, %for.end15
  %19 = load i64, ptr %i, align 8
  %20 = load i64, ptr %v_size.addr, align 8
  %cmp18 = icmp ult i64 %19, %20
  br i1 %cmp18, label %for.body20, label %for.end28

for.body20:                                       ; preds = %for.cond17
  %arraydecay = getelementptr inbounds [256 x i8], ptr %mtf, i64 0, i64 0
  %21 = load i64, ptr %mtf_size, align 8
  %22 = load ptr, ptr %v_in.addr, align 8
  %23 = load i64, ptr %i, align 8
  %arrayidx21 = getelementptr inbounds i32, ptr %22, i64 %23
  %24 = load i32, ptr %arrayidx21, align 4
  %conv22 = trunc i32 %24 to i8
  %call = call i64 @IndexOf(ptr noundef %arraydecay, i64 noundef %21, i8 noundef zeroext %conv22)
  store i64 %call, ptr %index, align 8
  %25 = load i64, ptr %index, align 8
  %conv23 = trunc i64 %25 to i32
  %26 = load ptr, ptr %v_out.addr, align 8
  %27 = load i64, ptr %i, align 8
  %arrayidx24 = getelementptr inbounds i32, ptr %26, i64 %27
  store i32 %conv23, ptr %arrayidx24, align 4
  %arraydecay25 = getelementptr inbounds [256 x i8], ptr %mtf, i64 0, i64 0
  %28 = load i64, ptr %index, align 8
  call void @MoveToFront(ptr noundef %arraydecay25, i64 noundef %28)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body20
  %29 = load i64, ptr %i, align 8
  %inc27 = add i64 %29, 1
  store i64 %inc27, ptr %i, align 8
  br label %for.cond17, !llvm.loop !514

for.end28:                                        ; preds = %for.cond17, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @RunLengthCodeZeros(i64 noundef %in_size, ptr noalias noundef %v, ptr noalias noundef %out_size, ptr noalias noundef %max_run_length_prefix) #0 {
entry:
  %a.addr.i76 = alloca i32, align 4
  %b.addr.i77 = alloca i32, align 4
  %a.addr.i = alloca i32, align 4
  %b.addr.i = alloca i32, align 4
  %n.addr.i73 = alloca i64, align 8
  %n.addr.i = alloca i64, align 8
  %in_size.addr = alloca i64, align 8
  %v.addr = alloca ptr, align 8
  %out_size.addr = alloca ptr, align 8
  %max_run_length_prefix.addr = alloca ptr, align 8
  %max_reps = alloca i32, align 4
  %i = alloca i64, align 8
  %max_prefix = alloca i32, align 4
  %reps = alloca i32, align 4
  %reps31 = alloca i32, align 4
  %k = alloca i64, align 8
  %run_length_prefix = alloca i32, align 4
  %extra_bits = alloca i32, align 4
  %extra_bits61 = alloca i32, align 4
  store i64 %in_size, ptr %in_size.addr, align 8
  store ptr %v, ptr %v.addr, align 8
  store ptr %out_size, ptr %out_size.addr, align 8
  store ptr %max_run_length_prefix, ptr %max_run_length_prefix.addr, align 8
  store i32 0, ptr %max_reps, align 4
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %brotli_max_uint32_t.exit, %entry
  %0 = load i64, ptr %i, align 8
  %1 = load i64, ptr %in_size.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end16

for.body:                                         ; preds = %for.cond
  store i32 0, ptr %reps, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i64, ptr %i, align 8
  %3 = load i64, ptr %in_size.addr, align 8
  %cmp2 = icmp ult i64 %2, %3
  br i1 %cmp2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond1
  %4 = load ptr, ptr %v.addr, align 8
  %5 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds i32, ptr %4, i64 %5
  %6 = load i32, ptr %arrayidx, align 4
  %cmp3 = icmp ne i32 %6, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond1
  %7 = phi i1 [ false, %for.cond1 ], [ %cmp3, %land.rhs ]
  br i1 %7, label %for.body4, label %for.end

for.body4:                                        ; preds = %land.end
  br label %for.inc

for.inc:                                          ; preds = %for.body4
  %8 = load i64, ptr %i, align 8
  %inc = add i64 %8, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond1, !llvm.loop !515

for.end:                                          ; preds = %land.end
  br label %for.cond5

for.cond5:                                        ; preds = %for.inc13, %for.end
  %9 = load i64, ptr %i, align 8
  %10 = load i64, ptr %in_size.addr, align 8
  %cmp6 = icmp ult i64 %9, %10
  br i1 %cmp6, label %land.rhs7, label %land.end10

land.rhs7:                                        ; preds = %for.cond5
  %11 = load ptr, ptr %v.addr, align 8
  %12 = load i64, ptr %i, align 8
  %arrayidx8 = getelementptr inbounds i32, ptr %11, i64 %12
  %13 = load i32, ptr %arrayidx8, align 4
  %cmp9 = icmp eq i32 %13, 0
  br label %land.end10

land.end10:                                       ; preds = %land.rhs7, %for.cond5
  %14 = phi i1 [ false, %for.cond5 ], [ %cmp9, %land.rhs7 ]
  br i1 %14, label %for.body11, label %for.end15

for.body11:                                       ; preds = %land.end10
  %15 = load i32, ptr %reps, align 4
  %inc12 = add i32 %15, 1
  store i32 %inc12, ptr %reps, align 4
  br label %for.inc13

for.inc13:                                        ; preds = %for.body11
  %16 = load i64, ptr %i, align 8
  %inc14 = add i64 %16, 1
  store i64 %inc14, ptr %i, align 8
  br label %for.cond5, !llvm.loop !516

for.end15:                                        ; preds = %land.end10
  %17 = load i32, ptr %reps, align 4
  %18 = load i32, ptr %max_reps, align 4
  store i32 %17, ptr %a.addr.i, align 4
  store i32 %18, ptr %b.addr.i, align 4
  %19 = load i32, ptr %a.addr.i, align 4
  %20 = load i32, ptr %b.addr.i, align 4
  %cmp.i = icmp ugt i32 %19, %20
  br i1 %cmp.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %for.end15
  %21 = load i32, ptr %a.addr.i, align 4
  br label %brotli_max_uint32_t.exit

cond.false.i:                                     ; preds = %for.end15
  %22 = load i32, ptr %b.addr.i, align 4
  br label %brotli_max_uint32_t.exit

brotli_max_uint32_t.exit:                         ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi i32 [ %21, %cond.true.i ], [ %22, %cond.false.i ]
  store i32 %cond.i, ptr %max_reps, align 4
  br label %for.cond, !llvm.loop !517

for.end16:                                        ; preds = %for.cond
  %23 = load i32, ptr %max_reps, align 4
  %cmp17 = icmp ugt i32 %23, 0
  br i1 %cmp17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end16
  %24 = load i32, ptr %max_reps, align 4
  %conv = zext i32 %24 to i64
  store i64 %conv, ptr %n.addr.i73, align 8
  %25 = load i64, ptr %n.addr.i73, align 8
  %conv.i74 = trunc i64 %25 to i32
  %26 = call i32 @llvm.ctlz.i32(i32 %conv.i74, i1 true)
  %xor.i75 = xor i32 31, %26
  br label %cond.end

cond.false:                                       ; preds = %for.end16
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %xor.i75, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, ptr %max_prefix, align 4
  %27 = load i32, ptr %max_prefix, align 4
  %28 = load ptr, ptr %max_run_length_prefix.addr, align 8
  %29 = load i32, ptr %28, align 4
  store i32 %27, ptr %a.addr.i76, align 4
  store i32 %29, ptr %b.addr.i77, align 4
  %30 = load i32, ptr %a.addr.i76, align 4
  %31 = load i32, ptr %b.addr.i77, align 4
  %cmp.i78 = icmp ult i32 %30, %31
  br i1 %cmp.i78, label %cond.true.i81, label %cond.false.i79

cond.true.i81:                                    ; preds = %cond.end
  %32 = load i32, ptr %a.addr.i76, align 4
  br label %brotli_min_uint32_t.exit

cond.false.i79:                                   ; preds = %cond.end
  %33 = load i32, ptr %b.addr.i77, align 4
  br label %brotli_min_uint32_t.exit

brotli_min_uint32_t.exit:                         ; preds = %cond.false.i79, %cond.true.i81
  %cond.i80 = phi i32 [ %32, %cond.true.i81 ], [ %33, %cond.false.i79 ]
  store i32 %cond.i80, ptr %max_prefix, align 4
  %34 = load i32, ptr %max_prefix, align 4
  %35 = load ptr, ptr %max_run_length_prefix.addr, align 8
  store i32 %34, ptr %35, align 4
  %36 = load ptr, ptr %out_size.addr, align 8
  store i64 0, ptr %36, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond20

for.cond20:                                       ; preds = %if.end71, %brotli_min_uint32_t.exit
  %37 = load i64, ptr %i, align 8
  %38 = load i64, ptr %in_size.addr, align 8
  %cmp21 = icmp ult i64 %37, %38
  br i1 %cmp21, label %for.body23, label %for.end72

for.body23:                                       ; preds = %for.cond20
  %39 = load ptr, ptr %v.addr, align 8
  %40 = load i64, ptr %i, align 8
  %arrayidx24 = getelementptr inbounds i32, ptr %39, i64 %40
  %41 = load i32, ptr %arrayidx24, align 4
  %cmp25 = icmp ne i32 %41, 0
  br i1 %cmp25, label %if.then, label %if.else

if.then:                                          ; preds = %for.body23
  %42 = load ptr, ptr %v.addr, align 8
  %43 = load i64, ptr %i, align 8
  %arrayidx27 = getelementptr inbounds i32, ptr %42, i64 %43
  %44 = load i32, ptr %arrayidx27, align 4
  %45 = load ptr, ptr %max_run_length_prefix.addr, align 8
  %46 = load i32, ptr %45, align 4
  %add = add i32 %44, %46
  %47 = load ptr, ptr %v.addr, align 8
  %48 = load ptr, ptr %out_size.addr, align 8
  %49 = load i64, ptr %48, align 8
  %arrayidx28 = getelementptr inbounds i32, ptr %47, i64 %49
  store i32 %add, ptr %arrayidx28, align 4
  %50 = load i64, ptr %i, align 8
  %inc29 = add i64 %50, 1
  store i64 %inc29, ptr %i, align 8
  %51 = load ptr, ptr %out_size.addr, align 8
  %52 = load i64, ptr %51, align 8
  %inc30 = add i64 %52, 1
  store i64 %inc30, ptr %51, align 8
  br label %if.end71

if.else:                                          ; preds = %for.body23
  store i32 1, ptr %reps31, align 4
  %53 = load i64, ptr %i, align 8
  %add32 = add i64 %53, 1
  store i64 %add32, ptr %k, align 8
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc43, %if.else
  %54 = load i64, ptr %k, align 8
  %55 = load i64, ptr %in_size.addr, align 8
  %cmp34 = icmp ult i64 %54, %55
  br i1 %cmp34, label %land.rhs36, label %land.end40

land.rhs36:                                       ; preds = %for.cond33
  %56 = load ptr, ptr %v.addr, align 8
  %57 = load i64, ptr %k, align 8
  %arrayidx37 = getelementptr inbounds i32, ptr %56, i64 %57
  %58 = load i32, ptr %arrayidx37, align 4
  %cmp38 = icmp eq i32 %58, 0
  br label %land.end40

land.end40:                                       ; preds = %land.rhs36, %for.cond33
  %59 = phi i1 [ false, %for.cond33 ], [ %cmp38, %land.rhs36 ]
  br i1 %59, label %for.body41, label %for.end45

for.body41:                                       ; preds = %land.end40
  %60 = load i32, ptr %reps31, align 4
  %inc42 = add i32 %60, 1
  store i32 %inc42, ptr %reps31, align 4
  br label %for.inc43

for.inc43:                                        ; preds = %for.body41
  %61 = load i64, ptr %k, align 8
  %inc44 = add i64 %61, 1
  store i64 %inc44, ptr %k, align 8
  br label %for.cond33, !llvm.loop !518

for.end45:                                        ; preds = %land.end40
  %62 = load i32, ptr %reps31, align 4
  %conv46 = zext i32 %62 to i64
  %63 = load i64, ptr %i, align 8
  %add47 = add i64 %63, %conv46
  store i64 %add47, ptr %i, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %for.end45
  %64 = load i32, ptr %reps31, align 4
  %cmp48 = icmp ne i32 %64, 0
  br i1 %cmp48, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %65 = load i32, ptr %reps31, align 4
  %66 = load i32, ptr %max_prefix, align 4
  %shl = shl i32 2, %66
  %cmp50 = icmp ult i32 %65, %shl
  br i1 %cmp50, label %if.then52, label %if.else60

if.then52:                                        ; preds = %while.body
  %67 = load i32, ptr %reps31, align 4
  %conv53 = zext i32 %67 to i64
  store i64 %conv53, ptr %n.addr.i, align 8
  %68 = load i64, ptr %n.addr.i, align 8
  %conv.i = trunc i64 %68 to i32
  %69 = call i32 @llvm.ctlz.i32(i32 %conv.i, i1 true)
  %xor.i = xor i32 31, %69
  store i32 %xor.i, ptr %run_length_prefix, align 4
  %70 = load i32, ptr %reps31, align 4
  %71 = load i32, ptr %run_length_prefix, align 4
  %shl55 = shl i32 1, %71
  %sub = sub i32 %70, %shl55
  store i32 %sub, ptr %extra_bits, align 4
  %72 = load i32, ptr %run_length_prefix, align 4
  %73 = load i32, ptr %extra_bits, align 4
  %shl56 = shl i32 %73, 9
  %add57 = add i32 %72, %shl56
  %74 = load ptr, ptr %v.addr, align 8
  %75 = load ptr, ptr %out_size.addr, align 8
  %76 = load i64, ptr %75, align 8
  %arrayidx58 = getelementptr inbounds i32, ptr %74, i64 %76
  store i32 %add57, ptr %arrayidx58, align 4
  %77 = load ptr, ptr %out_size.addr, align 8
  %78 = load i64, ptr %77, align 8
  %inc59 = add i64 %78, 1
  store i64 %inc59, ptr %77, align 8
  br label %while.end

if.else60:                                        ; preds = %while.body
  %79 = load i32, ptr %max_prefix, align 4
  %shl62 = shl i32 1, %79
  %sub63 = sub i32 %shl62, 1
  store i32 %sub63, ptr %extra_bits61, align 4
  %80 = load i32, ptr %max_prefix, align 4
  %81 = load i32, ptr %extra_bits61, align 4
  %shl64 = shl i32 %81, 9
  %add65 = add i32 %80, %shl64
  %82 = load ptr, ptr %v.addr, align 8
  %83 = load ptr, ptr %out_size.addr, align 8
  %84 = load i64, ptr %83, align 8
  %arrayidx66 = getelementptr inbounds i32, ptr %82, i64 %84
  store i32 %add65, ptr %arrayidx66, align 4
  %85 = load i32, ptr %max_prefix, align 4
  %shl67 = shl i32 2, %85
  %sub68 = sub i32 %shl67, 1
  %86 = load i32, ptr %reps31, align 4
  %sub69 = sub i32 %86, %sub68
  store i32 %sub69, ptr %reps31, align 4
  %87 = load ptr, ptr %out_size.addr, align 8
  %88 = load i64, ptr %87, align 8
  %inc70 = add i64 %88, 1
  store i64 %inc70, ptr %87, align 8
  br label %if.end

if.end:                                           ; preds = %if.else60
  br label %while.cond, !llvm.loop !519

while.end:                                        ; preds = %if.then52, %while.cond
  br label %if.end71

if.end71:                                         ; preds = %while.end, %if.then
  br label %for.cond20, !llvm.loop !520

for.end72:                                        ; preds = %for.cond20
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @IndexOf(ptr noundef %v, i64 noundef %v_size, i8 noundef zeroext %value) #0 {
entry:
  %retval = alloca i64, align 8
  %v.addr = alloca ptr, align 8
  %v_size.addr = alloca i64, align 8
  %value.addr = alloca i8, align 1
  %i = alloca i64, align 8
  store ptr %v, ptr %v.addr, align 8
  store i64 %v_size, ptr %v_size.addr, align 8
  store i8 %value, ptr %value.addr, align 1
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %i, align 8
  %1 = load i64, ptr %v_size.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %v.addr, align 8
  %3 = load i64, ptr %i, align 8
  %arrayidx = getelementptr inbounds i8, ptr %2, i64 %3
  %4 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %4 to i32
  %5 = load i8, ptr %value.addr, align 1
  %conv1 = zext i8 %5 to i32
  %cmp2 = icmp eq i32 %conv, %conv1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i64, ptr %i, align 8
  store i64 %6, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i64, ptr %i, align 8
  %inc = add i64 %7, 1
  store i64 %inc, ptr %i, align 8
  br label %for.cond, !llvm.loop !521

for.end:                                          ; preds = %for.cond
  %8 = load i64, ptr %i, align 8
  store i64 %8, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i64, ptr %retval, align 8
  ret i64 %9
}

; Function Attrs: nounwind uwtable
define internal void @MoveToFront(ptr noundef %v, i64 noundef %index) #0 {
entry:
  %v.addr = alloca ptr, align 8
  %index.addr = alloca i64, align 8
  %value = alloca i8, align 1
  %i = alloca i64, align 8
  store ptr %v, ptr %v.addr, align 8
  store i64 %index, ptr %index.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %1 = load i64, ptr %index.addr, align 8
  %arrayidx = getelementptr inbounds i8, ptr %0, i64 %1
  %2 = load i8, ptr %arrayidx, align 1
  store i8 %2, ptr %value, align 1
  %3 = load i64, ptr %index.addr, align 8
  store i64 %3, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i64, ptr %i, align 8
  %cmp = icmp ne i64 %4, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %v.addr, align 8
  %6 = load i64, ptr %i, align 8
  %sub = sub i64 %6, 1
  %arrayidx1 = getelementptr inbounds i8, ptr %5, i64 %sub
  %7 = load i8, ptr %arrayidx1, align 1
  %8 = load ptr, ptr %v.addr, align 8
  %9 = load i64, ptr %i, align 8
  %arrayidx2 = getelementptr inbounds i8, ptr %8, i64 %9
  store i8 %7, ptr %arrayidx2, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i64, ptr %i, align 8
  %dec = add i64 %10, -1
  store i64 %dec, ptr %i, align 8
  br label %for.cond, !llvm.loop !522

for.end:                                          ; preds = %for.cond
  %11 = load i8, ptr %value, align 1
  %12 = load ptr, ptr %v.addr, align 8
  %arrayidx3 = getelementptr inbounds i8, ptr %12, i64 0
  store i8 %11, ptr %arrayidx3, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @StoreSimpleHuffmanTree(ptr noundef %depths, ptr noundef %symbols, i64 noundef %num_symbols, i64 noundef %max_bits, ptr noundef %storage_ix, ptr noundef %storage) #0 {
entry:
  %p.addr.i204 = alloca ptr, align 8
  %v.addr.i205 = alloca i64, align 8
  %p.addr.i202 = alloca ptr, align 8
  %v.addr.i203 = alloca i64, align 8
  %p.addr.i200 = alloca ptr, align 8
  %v.addr.i201 = alloca i64, align 8
  %p.addr.i198 = alloca ptr, align 8
  %v.addr.i199 = alloca i64, align 8
  %p.addr.i196 = alloca ptr, align 8
  %v.addr.i197 = alloca i64, align 8
  %p.addr.i194 = alloca ptr, align 8
  %v.addr.i195 = alloca i64, align 8
  %p.addr.i192 = alloca ptr, align 8
  %v.addr.i193 = alloca i64, align 8
  %p.addr.i190 = alloca ptr, align 8
  %v.addr.i191 = alloca i64, align 8
  %p.addr.i188 = alloca ptr, align 8
  %v.addr.i189 = alloca i64, align 8
  %p.addr.i186 = alloca ptr, align 8
  %v.addr.i187 = alloca i64, align 8
  %p.addr.i184 = alloca ptr, align 8
  %v.addr.i185 = alloca i64, align 8
  %p.addr.i = alloca ptr, align 8
  %v.addr.i = alloca i64, align 8
  %n_bits.addr.i171 = alloca i64, align 8
  %bits.addr.i172 = alloca i64, align 8
  %pos.addr.i173 = alloca ptr, align 8
  %array.addr.i174 = alloca ptr, align 8
  %p.i175 = alloca ptr, align 8
  %v.i176 = alloca i64, align 8
  %n_bits.addr.i158 = alloca i64, align 8
  %bits.addr.i159 = alloca i64, align 8
  %pos.addr.i160 = alloca ptr, align 8
  %array.addr.i161 = alloca ptr, align 8
  %p.i162 = alloca ptr, align 8
  %v.i163 = alloca i64, align 8
  %n_bits.addr.i145 = alloca i64, align 8
  %bits.addr.i146 = alloca i64, align 8
  %pos.addr.i147 = alloca ptr, align 8
  %array.addr.i148 = alloca ptr, align 8
  %p.i149 = alloca ptr, align 8
  %v.i150 = alloca i64, align 8
  %n_bits.addr.i132 = alloca i64, align 8
  %bits.addr.i133 = alloca i64, align 8
  %pos.addr.i134 = alloca ptr, align 8
  %array.addr.i135 = alloca ptr, align 8
  %p.i136 = alloca ptr, align 8
  %v.i137 = alloca i64, align 8
  %n_bits.addr.i119 = alloca i64, align 8
  %bits.addr.i120 = alloca i64, align 8
  %pos.addr.i121 = alloca ptr, align 8
  %array.addr.i122 = alloca ptr, align 8
  %p.i123 = alloca ptr, align 8
  %v.i124 = alloca i64, align 8
  %n_bits.addr.i106 = alloca i64, align 8
  %bits.addr.i107 = alloca i64, align 8
  %pos.addr.i108 = alloca ptr, align 8
  %array.addr.i109 = alloca ptr, align 8
  %p.i110 = alloca ptr, align 8
  %v.i111 = alloca i64, align 8
  %n_bits.addr.i93 = alloca i64, align 8
  %bits.addr.i94 = alloca i64, align 8
  %pos.addr.i95 = alloca ptr, align 8
  %array.addr.i96 = alloca ptr, align 8
  %p.i97 = alloca ptr, align 8
  %v.i98 = alloca i64, align 8
  %n_bits.addr.i80 = alloca i64, align 8
  %bits.addr.i81 = alloca i64, align 8
  %pos.addr.i82 = alloca ptr, align 8
  %array.addr.i83 = alloca ptr, align 8
  %p.i84 = alloca ptr, align 8
  %v.i85 = alloca i64, align 8
  %n_bits.addr.i67 = alloca i64, align 8
  %bits.addr.i68 = alloca i64, align 8
  %pos.addr.i69 = alloca ptr, align 8
  %array.addr.i70 = alloca ptr, align 8
  %p.i71 = alloca ptr, align 8
  %v.i72 = alloca i64, align 8
  %n_bits.addr.i54 = alloca i64, align 8
  %bits.addr.i55 = alloca i64, align 8
  %pos.addr.i56 = alloca ptr, align 8
  %array.addr.i57 = alloca ptr, align 8
  %p.i58 = alloca ptr, align 8
  %v.i59 = alloca i64, align 8
  %n_bits.addr.i41 = alloca i64, align 8
  %bits.addr.i42 = alloca i64, align 8
  %pos.addr.i43 = alloca ptr, align 8
  %array.addr.i44 = alloca ptr, align 8
  %p.i45 = alloca ptr, align 8
  %v.i46 = alloca i64, align 8
  %n_bits.addr.i = alloca i64, align 8
  %bits.addr.i = alloca i64, align 8
  %pos.addr.i = alloca ptr, align 8
  %array.addr.i = alloca ptr, align 8
  %p.i = alloca ptr, align 8
  %v.i = alloca i64, align 8
  %depths.addr = alloca ptr, align 8
  %symbols.addr = alloca ptr, align 8
  %num_symbols.addr = alloca i64, align 8
  %max_bits.addr = alloca i64, align 8
  %storage_ix.addr = alloca ptr, align 8
  %storage.addr = alloca ptr, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  %__brotli_swap_tmp = alloca i64, align 8
  store ptr %depths, ptr %depths.addr, align 8
  store ptr %symbols, ptr %symbols.addr, align 8
  store i64 %num_symbols, ptr %num_symbols.addr, align 8
  store i64 %max_bits, ptr %max_bits.addr, align 8
  store ptr %storage_ix, ptr %storage_ix.addr, align 8
  store ptr %storage, ptr %storage.addr, align 8
  %0 = load ptr, ptr %storage_ix.addr, align 8
  %1 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !523)
  call void @llvm.experimental.noalias.scope.decl(metadata !526)
  store i64 2, ptr %n_bits.addr.i171, align 8, !noalias !528
  store i64 1, ptr %bits.addr.i172, align 8, !noalias !528
  store ptr %0, ptr %pos.addr.i173, align 8, !noalias !528
  store ptr %1, ptr %array.addr.i174, align 8, !noalias !528
  %2 = load ptr, ptr %array.addr.i174, align 8, !noalias !528
  %3 = load ptr, ptr %pos.addr.i173, align 8, !noalias !528
  %4 = load i64, ptr %3, align 8
  %shr.i177 = lshr i64 %4, 3
  %arrayidx.i178 = getelementptr inbounds i8, ptr %2, i64 %shr.i177
  store ptr %arrayidx.i178, ptr %p.i175, align 8, !noalias !528
  %5 = load ptr, ptr %p.i175, align 8, !noalias !528
  %6 = load i8, ptr %5, align 1
  %conv.i179 = zext i8 %6 to i64
  store i64 %conv.i179, ptr %v.i176, align 8, !noalias !528
  %7 = load i64, ptr %bits.addr.i172, align 8, !noalias !528
  %8 = load ptr, ptr %pos.addr.i173, align 8, !noalias !528
  %9 = load i64, ptr %8, align 8
  %and.i180 = and i64 %9, 7
  %shl.i181 = shl i64 %7, %and.i180
  %10 = load i64, ptr %v.i176, align 8, !noalias !528
  %or.i182 = or i64 %10, %shl.i181
  store i64 %or.i182, ptr %v.i176, align 8, !noalias !528
  %11 = load ptr, ptr %p.i175, align 8, !noalias !528
  %12 = load i64, ptr %v.i176, align 8, !noalias !528
  store ptr %11, ptr %p.addr.i, align 8
  store i64 %12, ptr %v.addr.i, align 8
  %13 = load ptr, ptr %p.addr.i, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %13, ptr align 8 %v.addr.i, i64 8, i1 false)
  %14 = load i64, ptr %n_bits.addr.i171, align 8, !noalias !528
  %15 = load ptr, ptr %pos.addr.i173, align 8, !noalias !528
  %16 = load i64, ptr %15, align 8
  %add.i183 = add i64 %16, %14
  store i64 %add.i183, ptr %15, align 8
  %17 = load i64, ptr %num_symbols.addr, align 8
  %sub = sub i64 %17, 1
  %18 = load ptr, ptr %storage_ix.addr, align 8
  %19 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !529)
  call void @llvm.experimental.noalias.scope.decl(metadata !532)
  store i64 2, ptr %n_bits.addr.i158, align 8, !noalias !534
  store i64 %sub, ptr %bits.addr.i159, align 8, !noalias !534
  store ptr %18, ptr %pos.addr.i160, align 8, !noalias !534
  store ptr %19, ptr %array.addr.i161, align 8, !noalias !534
  %20 = load ptr, ptr %array.addr.i161, align 8, !noalias !534
  %21 = load ptr, ptr %pos.addr.i160, align 8, !noalias !534
  %22 = load i64, ptr %21, align 8
  %shr.i164 = lshr i64 %22, 3
  %arrayidx.i165 = getelementptr inbounds i8, ptr %20, i64 %shr.i164
  store ptr %arrayidx.i165, ptr %p.i162, align 8, !noalias !534
  %23 = load ptr, ptr %p.i162, align 8, !noalias !534
  %24 = load i8, ptr %23, align 1
  %conv.i166 = zext i8 %24 to i64
  store i64 %conv.i166, ptr %v.i163, align 8, !noalias !534
  %25 = load i64, ptr %bits.addr.i159, align 8, !noalias !534
  %26 = load ptr, ptr %pos.addr.i160, align 8, !noalias !534
  %27 = load i64, ptr %26, align 8
  %and.i167 = and i64 %27, 7
  %shl.i168 = shl i64 %25, %and.i167
  %28 = load i64, ptr %v.i163, align 8, !noalias !534
  %or.i169 = or i64 %28, %shl.i168
  store i64 %or.i169, ptr %v.i163, align 8, !noalias !534
  %29 = load ptr, ptr %p.i162, align 8, !noalias !534
  %30 = load i64, ptr %v.i163, align 8, !noalias !534
  store ptr %29, ptr %p.addr.i184, align 8
  store i64 %30, ptr %v.addr.i185, align 8
  %31 = load ptr, ptr %p.addr.i184, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %31, ptr align 8 %v.addr.i185, i64 8, i1 false)
  %32 = load i64, ptr %n_bits.addr.i158, align 8, !noalias !534
  %33 = load ptr, ptr %pos.addr.i160, align 8, !noalias !534
  %34 = load i64, ptr %33, align 8
  %add.i170 = add i64 %34, %32
  store i64 %add.i170, ptr %33, align 8
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc14, %entry
  %35 = load i64, ptr %i, align 8
  %36 = load i64, ptr %num_symbols.addr, align 8
  %cmp = icmp ult i64 %35, %36
  br i1 %cmp, label %for.body, label %for.end16

for.body:                                         ; preds = %for.cond
  %37 = load i64, ptr %i, align 8
  %add = add i64 %37, 1
  store i64 %add, ptr %j, align 8
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %38 = load i64, ptr %j, align 8
  %39 = load i64, ptr %num_symbols.addr, align 8
  %cmp2 = icmp ult i64 %38, %39
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %40 = load ptr, ptr %depths.addr, align 8
  %41 = load ptr, ptr %symbols.addr, align 8
  %42 = load i64, ptr %j, align 8
  %arrayidx = getelementptr inbounds i64, ptr %41, i64 %42
  %43 = load i64, ptr %arrayidx, align 8
  %arrayidx4 = getelementptr inbounds i8, ptr %40, i64 %43
  %44 = load i8, ptr %arrayidx4, align 1
  %conv = zext i8 %44 to i32
  %45 = load ptr, ptr %depths.addr, align 8
  %46 = load ptr, ptr %symbols.addr, align 8
  %47 = load i64, ptr %i, align 8
  %arrayidx5 = getelementptr inbounds i64, ptr %46, i64 %47
  %48 = load i64, ptr %arrayidx5, align 8
  %arrayidx6 = getelementptr inbounds i8, ptr %45, i64 %48
  %49 = load i8, ptr %arrayidx6, align 1
  %conv7 = zext i8 %49 to i32
  %cmp8 = icmp slt i32 %conv, %conv7
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %for.body3
  %50 = load ptr, ptr %symbols.addr, align 8
  %51 = load i64, ptr %j, align 8
  %arrayidx10 = getelementptr inbounds i64, ptr %50, i64 %51
  %52 = load i64, ptr %arrayidx10, align 8
  store i64 %52, ptr %__brotli_swap_tmp, align 8
  %53 = load ptr, ptr %symbols.addr, align 8
  %54 = load i64, ptr %i, align 8
  %arrayidx11 = getelementptr inbounds i64, ptr %53, i64 %54
  %55 = load i64, ptr %arrayidx11, align 8
  %56 = load ptr, ptr %symbols.addr, align 8
  %57 = load i64, ptr %j, align 8
  %arrayidx12 = getelementptr inbounds i64, ptr %56, i64 %57
  store i64 %55, ptr %arrayidx12, align 8
  %58 = load i64, ptr %__brotli_swap_tmp, align 8
  %59 = load ptr, ptr %symbols.addr, align 8
  %60 = load i64, ptr %i, align 8
  %arrayidx13 = getelementptr inbounds i64, ptr %59, i64 %60
  store i64 %58, ptr %arrayidx13, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body3
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %61 = load i64, ptr %j, align 8
  %inc = add i64 %61, 1
  store i64 %inc, ptr %j, align 8
  br label %for.cond1, !llvm.loop !535

for.end:                                          ; preds = %for.cond1
  br label %for.inc14

for.inc14:                                        ; preds = %for.end
  %62 = load i64, ptr %i, align 8
  %inc15 = add i64 %62, 1
  store i64 %inc15, ptr %i, align 8
  br label %for.cond, !llvm.loop !536

for.end16:                                        ; preds = %for.cond
  %63 = load i64, ptr %num_symbols.addr, align 8
  %cmp17 = icmp eq i64 %63, 2
  br i1 %cmp17, label %if.then19, label %if.else

if.then19:                                        ; preds = %for.end16
  %64 = load i64, ptr %max_bits.addr, align 8
  %65 = load ptr, ptr %symbols.addr, align 8
  %arrayidx20 = getelementptr inbounds i64, ptr %65, i64 0
  %66 = load i64, ptr %arrayidx20, align 8
  %67 = load ptr, ptr %storage_ix.addr, align 8
  %68 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !537)
  call void @llvm.experimental.noalias.scope.decl(metadata !540)
  store i64 %64, ptr %n_bits.addr.i145, align 8, !noalias !542
  store i64 %66, ptr %bits.addr.i146, align 8, !noalias !542
  store ptr %67, ptr %pos.addr.i147, align 8, !noalias !542
  store ptr %68, ptr %array.addr.i148, align 8, !noalias !542
  %69 = load ptr, ptr %array.addr.i148, align 8, !noalias !542
  %70 = load ptr, ptr %pos.addr.i147, align 8, !noalias !542
  %71 = load i64, ptr %70, align 8
  %shr.i151 = lshr i64 %71, 3
  %arrayidx.i152 = getelementptr inbounds i8, ptr %69, i64 %shr.i151
  store ptr %arrayidx.i152, ptr %p.i149, align 8, !noalias !542
  %72 = load ptr, ptr %p.i149, align 8, !noalias !542
  %73 = load i8, ptr %72, align 1
  %conv.i153 = zext i8 %73 to i64
  store i64 %conv.i153, ptr %v.i150, align 8, !noalias !542
  %74 = load i64, ptr %bits.addr.i146, align 8, !noalias !542
  %75 = load ptr, ptr %pos.addr.i147, align 8, !noalias !542
  %76 = load i64, ptr %75, align 8
  %and.i154 = and i64 %76, 7
  %shl.i155 = shl i64 %74, %and.i154
  %77 = load i64, ptr %v.i150, align 8, !noalias !542
  %or.i156 = or i64 %77, %shl.i155
  store i64 %or.i156, ptr %v.i150, align 8, !noalias !542
  %78 = load ptr, ptr %p.i149, align 8, !noalias !542
  %79 = load i64, ptr %v.i150, align 8, !noalias !542
  store ptr %78, ptr %p.addr.i186, align 8
  store i64 %79, ptr %v.addr.i187, align 8
  %80 = load ptr, ptr %p.addr.i186, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %80, ptr align 8 %v.addr.i187, i64 8, i1 false)
  %81 = load i64, ptr %n_bits.addr.i145, align 8, !noalias !542
  %82 = load ptr, ptr %pos.addr.i147, align 8, !noalias !542
  %83 = load i64, ptr %82, align 8
  %add.i157 = add i64 %83, %81
  store i64 %add.i157, ptr %82, align 8
  %84 = load i64, ptr %max_bits.addr, align 8
  %85 = load ptr, ptr %symbols.addr, align 8
  %arrayidx21 = getelementptr inbounds i64, ptr %85, i64 1
  %86 = load i64, ptr %arrayidx21, align 8
  %87 = load ptr, ptr %storage_ix.addr, align 8
  %88 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !543)
  call void @llvm.experimental.noalias.scope.decl(metadata !546)
  store i64 %84, ptr %n_bits.addr.i132, align 8, !noalias !548
  store i64 %86, ptr %bits.addr.i133, align 8, !noalias !548
  store ptr %87, ptr %pos.addr.i134, align 8, !noalias !548
  store ptr %88, ptr %array.addr.i135, align 8, !noalias !548
  %89 = load ptr, ptr %array.addr.i135, align 8, !noalias !548
  %90 = load ptr, ptr %pos.addr.i134, align 8, !noalias !548
  %91 = load i64, ptr %90, align 8
  %shr.i138 = lshr i64 %91, 3
  %arrayidx.i139 = getelementptr inbounds i8, ptr %89, i64 %shr.i138
  store ptr %arrayidx.i139, ptr %p.i136, align 8, !noalias !548
  %92 = load ptr, ptr %p.i136, align 8, !noalias !548
  %93 = load i8, ptr %92, align 1
  %conv.i140 = zext i8 %93 to i64
  store i64 %conv.i140, ptr %v.i137, align 8, !noalias !548
  %94 = load i64, ptr %bits.addr.i133, align 8, !noalias !548
  %95 = load ptr, ptr %pos.addr.i134, align 8, !noalias !548
  %96 = load i64, ptr %95, align 8
  %and.i141 = and i64 %96, 7
  %shl.i142 = shl i64 %94, %and.i141
  %97 = load i64, ptr %v.i137, align 8, !noalias !548
  %or.i143 = or i64 %97, %shl.i142
  store i64 %or.i143, ptr %v.i137, align 8, !noalias !548
  %98 = load ptr, ptr %p.i136, align 8, !noalias !548
  %99 = load i64, ptr %v.i137, align 8, !noalias !548
  store ptr %98, ptr %p.addr.i188, align 8
  store i64 %99, ptr %v.addr.i189, align 8
  %100 = load ptr, ptr %p.addr.i188, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %100, ptr align 8 %v.addr.i189, i64 8, i1 false)
  %101 = load i64, ptr %n_bits.addr.i132, align 8, !noalias !548
  %102 = load ptr, ptr %pos.addr.i134, align 8, !noalias !548
  %103 = load i64, ptr %102, align 8
  %add.i144 = add i64 %103, %101
  store i64 %add.i144, ptr %102, align 8
  br label %if.end40

if.else:                                          ; preds = %for.end16
  %104 = load i64, ptr %num_symbols.addr, align 8
  %cmp22 = icmp eq i64 %104, 3
  br i1 %cmp22, label %if.then24, label %if.else28

if.then24:                                        ; preds = %if.else
  %105 = load i64, ptr %max_bits.addr, align 8
  %106 = load ptr, ptr %symbols.addr, align 8
  %arrayidx25 = getelementptr inbounds i64, ptr %106, i64 0
  %107 = load i64, ptr %arrayidx25, align 8
  %108 = load ptr, ptr %storage_ix.addr, align 8
  %109 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !549)
  call void @llvm.experimental.noalias.scope.decl(metadata !552)
  store i64 %105, ptr %n_bits.addr.i119, align 8, !noalias !554
  store i64 %107, ptr %bits.addr.i120, align 8, !noalias !554
  store ptr %108, ptr %pos.addr.i121, align 8, !noalias !554
  store ptr %109, ptr %array.addr.i122, align 8, !noalias !554
  %110 = load ptr, ptr %array.addr.i122, align 8, !noalias !554
  %111 = load ptr, ptr %pos.addr.i121, align 8, !noalias !554
  %112 = load i64, ptr %111, align 8
  %shr.i125 = lshr i64 %112, 3
  %arrayidx.i126 = getelementptr inbounds i8, ptr %110, i64 %shr.i125
  store ptr %arrayidx.i126, ptr %p.i123, align 8, !noalias !554
  %113 = load ptr, ptr %p.i123, align 8, !noalias !554
  %114 = load i8, ptr %113, align 1
  %conv.i127 = zext i8 %114 to i64
  store i64 %conv.i127, ptr %v.i124, align 8, !noalias !554
  %115 = load i64, ptr %bits.addr.i120, align 8, !noalias !554
  %116 = load ptr, ptr %pos.addr.i121, align 8, !noalias !554
  %117 = load i64, ptr %116, align 8
  %and.i128 = and i64 %117, 7
  %shl.i129 = shl i64 %115, %and.i128
  %118 = load i64, ptr %v.i124, align 8, !noalias !554
  %or.i130 = or i64 %118, %shl.i129
  store i64 %or.i130, ptr %v.i124, align 8, !noalias !554
  %119 = load ptr, ptr %p.i123, align 8, !noalias !554
  %120 = load i64, ptr %v.i124, align 8, !noalias !554
  store ptr %119, ptr %p.addr.i190, align 8
  store i64 %120, ptr %v.addr.i191, align 8
  %121 = load ptr, ptr %p.addr.i190, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %121, ptr align 8 %v.addr.i191, i64 8, i1 false)
  %122 = load i64, ptr %n_bits.addr.i119, align 8, !noalias !554
  %123 = load ptr, ptr %pos.addr.i121, align 8, !noalias !554
  %124 = load i64, ptr %123, align 8
  %add.i131 = add i64 %124, %122
  store i64 %add.i131, ptr %123, align 8
  %125 = load i64, ptr %max_bits.addr, align 8
  %126 = load ptr, ptr %symbols.addr, align 8
  %arrayidx26 = getelementptr inbounds i64, ptr %126, i64 1
  %127 = load i64, ptr %arrayidx26, align 8
  %128 = load ptr, ptr %storage_ix.addr, align 8
  %129 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !555)
  call void @llvm.experimental.noalias.scope.decl(metadata !558)
  store i64 %125, ptr %n_bits.addr.i106, align 8, !noalias !560
  store i64 %127, ptr %bits.addr.i107, align 8, !noalias !560
  store ptr %128, ptr %pos.addr.i108, align 8, !noalias !560
  store ptr %129, ptr %array.addr.i109, align 8, !noalias !560
  %130 = load ptr, ptr %array.addr.i109, align 8, !noalias !560
  %131 = load ptr, ptr %pos.addr.i108, align 8, !noalias !560
  %132 = load i64, ptr %131, align 8
  %shr.i112 = lshr i64 %132, 3
  %arrayidx.i113 = getelementptr inbounds i8, ptr %130, i64 %shr.i112
  store ptr %arrayidx.i113, ptr %p.i110, align 8, !noalias !560
  %133 = load ptr, ptr %p.i110, align 8, !noalias !560
  %134 = load i8, ptr %133, align 1
  %conv.i114 = zext i8 %134 to i64
  store i64 %conv.i114, ptr %v.i111, align 8, !noalias !560
  %135 = load i64, ptr %bits.addr.i107, align 8, !noalias !560
  %136 = load ptr, ptr %pos.addr.i108, align 8, !noalias !560
  %137 = load i64, ptr %136, align 8
  %and.i115 = and i64 %137, 7
  %shl.i116 = shl i64 %135, %and.i115
  %138 = load i64, ptr %v.i111, align 8, !noalias !560
  %or.i117 = or i64 %138, %shl.i116
  store i64 %or.i117, ptr %v.i111, align 8, !noalias !560
  %139 = load ptr, ptr %p.i110, align 8, !noalias !560
  %140 = load i64, ptr %v.i111, align 8, !noalias !560
  store ptr %139, ptr %p.addr.i192, align 8
  store i64 %140, ptr %v.addr.i193, align 8
  %141 = load ptr, ptr %p.addr.i192, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %141, ptr align 8 %v.addr.i193, i64 8, i1 false)
  %142 = load i64, ptr %n_bits.addr.i106, align 8, !noalias !560
  %143 = load ptr, ptr %pos.addr.i108, align 8, !noalias !560
  %144 = load i64, ptr %143, align 8
  %add.i118 = add i64 %144, %142
  store i64 %add.i118, ptr %143, align 8
  %145 = load i64, ptr %max_bits.addr, align 8
  %146 = load ptr, ptr %symbols.addr, align 8
  %arrayidx27 = getelementptr inbounds i64, ptr %146, i64 2
  %147 = load i64, ptr %arrayidx27, align 8
  %148 = load ptr, ptr %storage_ix.addr, align 8
  %149 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !561)
  call void @llvm.experimental.noalias.scope.decl(metadata !564)
  store i64 %145, ptr %n_bits.addr.i93, align 8, !noalias !566
  store i64 %147, ptr %bits.addr.i94, align 8, !noalias !566
  store ptr %148, ptr %pos.addr.i95, align 8, !noalias !566
  store ptr %149, ptr %array.addr.i96, align 8, !noalias !566
  %150 = load ptr, ptr %array.addr.i96, align 8, !noalias !566
  %151 = load ptr, ptr %pos.addr.i95, align 8, !noalias !566
  %152 = load i64, ptr %151, align 8
  %shr.i99 = lshr i64 %152, 3
  %arrayidx.i100 = getelementptr inbounds i8, ptr %150, i64 %shr.i99
  store ptr %arrayidx.i100, ptr %p.i97, align 8, !noalias !566
  %153 = load ptr, ptr %p.i97, align 8, !noalias !566
  %154 = load i8, ptr %153, align 1
  %conv.i101 = zext i8 %154 to i64
  store i64 %conv.i101, ptr %v.i98, align 8, !noalias !566
  %155 = load i64, ptr %bits.addr.i94, align 8, !noalias !566
  %156 = load ptr, ptr %pos.addr.i95, align 8, !noalias !566
  %157 = load i64, ptr %156, align 8
  %and.i102 = and i64 %157, 7
  %shl.i103 = shl i64 %155, %and.i102
  %158 = load i64, ptr %v.i98, align 8, !noalias !566
  %or.i104 = or i64 %158, %shl.i103
  store i64 %or.i104, ptr %v.i98, align 8, !noalias !566
  %159 = load ptr, ptr %p.i97, align 8, !noalias !566
  %160 = load i64, ptr %v.i98, align 8, !noalias !566
  store ptr %159, ptr %p.addr.i194, align 8
  store i64 %160, ptr %v.addr.i195, align 8
  %161 = load ptr, ptr %p.addr.i194, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %161, ptr align 8 %v.addr.i195, i64 8, i1 false)
  %162 = load i64, ptr %n_bits.addr.i93, align 8, !noalias !566
  %163 = load ptr, ptr %pos.addr.i95, align 8, !noalias !566
  %164 = load i64, ptr %163, align 8
  %add.i105 = add i64 %164, %162
  store i64 %add.i105, ptr %163, align 8
  br label %if.end39

if.else28:                                        ; preds = %if.else
  %165 = load i64, ptr %max_bits.addr, align 8
  %166 = load ptr, ptr %symbols.addr, align 8
  %arrayidx29 = getelementptr inbounds i64, ptr %166, i64 0
  %167 = load i64, ptr %arrayidx29, align 8
  %168 = load ptr, ptr %storage_ix.addr, align 8
  %169 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !567)
  call void @llvm.experimental.noalias.scope.decl(metadata !570)
  store i64 %165, ptr %n_bits.addr.i80, align 8, !noalias !572
  store i64 %167, ptr %bits.addr.i81, align 8, !noalias !572
  store ptr %168, ptr %pos.addr.i82, align 8, !noalias !572
  store ptr %169, ptr %array.addr.i83, align 8, !noalias !572
  %170 = load ptr, ptr %array.addr.i83, align 8, !noalias !572
  %171 = load ptr, ptr %pos.addr.i82, align 8, !noalias !572
  %172 = load i64, ptr %171, align 8
  %shr.i86 = lshr i64 %172, 3
  %arrayidx.i87 = getelementptr inbounds i8, ptr %170, i64 %shr.i86
  store ptr %arrayidx.i87, ptr %p.i84, align 8, !noalias !572
  %173 = load ptr, ptr %p.i84, align 8, !noalias !572
  %174 = load i8, ptr %173, align 1
  %conv.i88 = zext i8 %174 to i64
  store i64 %conv.i88, ptr %v.i85, align 8, !noalias !572
  %175 = load i64, ptr %bits.addr.i81, align 8, !noalias !572
  %176 = load ptr, ptr %pos.addr.i82, align 8, !noalias !572
  %177 = load i64, ptr %176, align 8
  %and.i89 = and i64 %177, 7
  %shl.i90 = shl i64 %175, %and.i89
  %178 = load i64, ptr %v.i85, align 8, !noalias !572
  %or.i91 = or i64 %178, %shl.i90
  store i64 %or.i91, ptr %v.i85, align 8, !noalias !572
  %179 = load ptr, ptr %p.i84, align 8, !noalias !572
  %180 = load i64, ptr %v.i85, align 8, !noalias !572
  store ptr %179, ptr %p.addr.i196, align 8
  store i64 %180, ptr %v.addr.i197, align 8
  %181 = load ptr, ptr %p.addr.i196, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %181, ptr align 8 %v.addr.i197, i64 8, i1 false)
  %182 = load i64, ptr %n_bits.addr.i80, align 8, !noalias !572
  %183 = load ptr, ptr %pos.addr.i82, align 8, !noalias !572
  %184 = load i64, ptr %183, align 8
  %add.i92 = add i64 %184, %182
  store i64 %add.i92, ptr %183, align 8
  %185 = load i64, ptr %max_bits.addr, align 8
  %186 = load ptr, ptr %symbols.addr, align 8
  %arrayidx30 = getelementptr inbounds i64, ptr %186, i64 1
  %187 = load i64, ptr %arrayidx30, align 8
  %188 = load ptr, ptr %storage_ix.addr, align 8
  %189 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !573)
  call void @llvm.experimental.noalias.scope.decl(metadata !576)
  store i64 %185, ptr %n_bits.addr.i67, align 8, !noalias !578
  store i64 %187, ptr %bits.addr.i68, align 8, !noalias !578
  store ptr %188, ptr %pos.addr.i69, align 8, !noalias !578
  store ptr %189, ptr %array.addr.i70, align 8, !noalias !578
  %190 = load ptr, ptr %array.addr.i70, align 8, !noalias !578
  %191 = load ptr, ptr %pos.addr.i69, align 8, !noalias !578
  %192 = load i64, ptr %191, align 8
  %shr.i73 = lshr i64 %192, 3
  %arrayidx.i74 = getelementptr inbounds i8, ptr %190, i64 %shr.i73
  store ptr %arrayidx.i74, ptr %p.i71, align 8, !noalias !578
  %193 = load ptr, ptr %p.i71, align 8, !noalias !578
  %194 = load i8, ptr %193, align 1
  %conv.i75 = zext i8 %194 to i64
  store i64 %conv.i75, ptr %v.i72, align 8, !noalias !578
  %195 = load i64, ptr %bits.addr.i68, align 8, !noalias !578
  %196 = load ptr, ptr %pos.addr.i69, align 8, !noalias !578
  %197 = load i64, ptr %196, align 8
  %and.i76 = and i64 %197, 7
  %shl.i77 = shl i64 %195, %and.i76
  %198 = load i64, ptr %v.i72, align 8, !noalias !578
  %or.i78 = or i64 %198, %shl.i77
  store i64 %or.i78, ptr %v.i72, align 8, !noalias !578
  %199 = load ptr, ptr %p.i71, align 8, !noalias !578
  %200 = load i64, ptr %v.i72, align 8, !noalias !578
  store ptr %199, ptr %p.addr.i198, align 8
  store i64 %200, ptr %v.addr.i199, align 8
  %201 = load ptr, ptr %p.addr.i198, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %201, ptr align 8 %v.addr.i199, i64 8, i1 false)
  %202 = load i64, ptr %n_bits.addr.i67, align 8, !noalias !578
  %203 = load ptr, ptr %pos.addr.i69, align 8, !noalias !578
  %204 = load i64, ptr %203, align 8
  %add.i79 = add i64 %204, %202
  store i64 %add.i79, ptr %203, align 8
  %205 = load i64, ptr %max_bits.addr, align 8
  %206 = load ptr, ptr %symbols.addr, align 8
  %arrayidx31 = getelementptr inbounds i64, ptr %206, i64 2
  %207 = load i64, ptr %arrayidx31, align 8
  %208 = load ptr, ptr %storage_ix.addr, align 8
  %209 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !579)
  call void @llvm.experimental.noalias.scope.decl(metadata !582)
  store i64 %205, ptr %n_bits.addr.i54, align 8, !noalias !584
  store i64 %207, ptr %bits.addr.i55, align 8, !noalias !584
  store ptr %208, ptr %pos.addr.i56, align 8, !noalias !584
  store ptr %209, ptr %array.addr.i57, align 8, !noalias !584
  %210 = load ptr, ptr %array.addr.i57, align 8, !noalias !584
  %211 = load ptr, ptr %pos.addr.i56, align 8, !noalias !584
  %212 = load i64, ptr %211, align 8
  %shr.i60 = lshr i64 %212, 3
  %arrayidx.i61 = getelementptr inbounds i8, ptr %210, i64 %shr.i60
  store ptr %arrayidx.i61, ptr %p.i58, align 8, !noalias !584
  %213 = load ptr, ptr %p.i58, align 8, !noalias !584
  %214 = load i8, ptr %213, align 1
  %conv.i62 = zext i8 %214 to i64
  store i64 %conv.i62, ptr %v.i59, align 8, !noalias !584
  %215 = load i64, ptr %bits.addr.i55, align 8, !noalias !584
  %216 = load ptr, ptr %pos.addr.i56, align 8, !noalias !584
  %217 = load i64, ptr %216, align 8
  %and.i63 = and i64 %217, 7
  %shl.i64 = shl i64 %215, %and.i63
  %218 = load i64, ptr %v.i59, align 8, !noalias !584
  %or.i65 = or i64 %218, %shl.i64
  store i64 %or.i65, ptr %v.i59, align 8, !noalias !584
  %219 = load ptr, ptr %p.i58, align 8, !noalias !584
  %220 = load i64, ptr %v.i59, align 8, !noalias !584
  store ptr %219, ptr %p.addr.i200, align 8
  store i64 %220, ptr %v.addr.i201, align 8
  %221 = load ptr, ptr %p.addr.i200, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %221, ptr align 8 %v.addr.i201, i64 8, i1 false)
  %222 = load i64, ptr %n_bits.addr.i54, align 8, !noalias !584
  %223 = load ptr, ptr %pos.addr.i56, align 8, !noalias !584
  %224 = load i64, ptr %223, align 8
  %add.i66 = add i64 %224, %222
  store i64 %add.i66, ptr %223, align 8
  %225 = load i64, ptr %max_bits.addr, align 8
  %226 = load ptr, ptr %symbols.addr, align 8
  %arrayidx32 = getelementptr inbounds i64, ptr %226, i64 3
  %227 = load i64, ptr %arrayidx32, align 8
  %228 = load ptr, ptr %storage_ix.addr, align 8
  %229 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !585)
  call void @llvm.experimental.noalias.scope.decl(metadata !588)
  store i64 %225, ptr %n_bits.addr.i41, align 8, !noalias !590
  store i64 %227, ptr %bits.addr.i42, align 8, !noalias !590
  store ptr %228, ptr %pos.addr.i43, align 8, !noalias !590
  store ptr %229, ptr %array.addr.i44, align 8, !noalias !590
  %230 = load ptr, ptr %array.addr.i44, align 8, !noalias !590
  %231 = load ptr, ptr %pos.addr.i43, align 8, !noalias !590
  %232 = load i64, ptr %231, align 8
  %shr.i47 = lshr i64 %232, 3
  %arrayidx.i48 = getelementptr inbounds i8, ptr %230, i64 %shr.i47
  store ptr %arrayidx.i48, ptr %p.i45, align 8, !noalias !590
  %233 = load ptr, ptr %p.i45, align 8, !noalias !590
  %234 = load i8, ptr %233, align 1
  %conv.i49 = zext i8 %234 to i64
  store i64 %conv.i49, ptr %v.i46, align 8, !noalias !590
  %235 = load i64, ptr %bits.addr.i42, align 8, !noalias !590
  %236 = load ptr, ptr %pos.addr.i43, align 8, !noalias !590
  %237 = load i64, ptr %236, align 8
  %and.i50 = and i64 %237, 7
  %shl.i51 = shl i64 %235, %and.i50
  %238 = load i64, ptr %v.i46, align 8, !noalias !590
  %or.i52 = or i64 %238, %shl.i51
  store i64 %or.i52, ptr %v.i46, align 8, !noalias !590
  %239 = load ptr, ptr %p.i45, align 8, !noalias !590
  %240 = load i64, ptr %v.i46, align 8, !noalias !590
  store ptr %239, ptr %p.addr.i202, align 8
  store i64 %240, ptr %v.addr.i203, align 8
  %241 = load ptr, ptr %p.addr.i202, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %241, ptr align 8 %v.addr.i203, i64 8, i1 false)
  %242 = load i64, ptr %n_bits.addr.i41, align 8, !noalias !590
  %243 = load ptr, ptr %pos.addr.i43, align 8, !noalias !590
  %244 = load i64, ptr %243, align 8
  %add.i53 = add i64 %244, %242
  store i64 %add.i53, ptr %243, align 8
  %245 = load ptr, ptr %depths.addr, align 8
  %246 = load ptr, ptr %symbols.addr, align 8
  %arrayidx33 = getelementptr inbounds i64, ptr %246, i64 0
  %247 = load i64, ptr %arrayidx33, align 8
  %arrayidx34 = getelementptr inbounds i8, ptr %245, i64 %247
  %248 = load i8, ptr %arrayidx34, align 1
  %conv35 = zext i8 %248 to i32
  %cmp36 = icmp eq i32 %conv35, 1
  %cond = select i1 %cmp36, i32 1, i32 0
  %conv38 = sext i32 %cond to i64
  %249 = load ptr, ptr %storage_ix.addr, align 8
  %250 = load ptr, ptr %storage.addr, align 8
  call void @llvm.experimental.noalias.scope.decl(metadata !591)
  call void @llvm.experimental.noalias.scope.decl(metadata !594)
  store i64 1, ptr %n_bits.addr.i, align 8, !noalias !596
  store i64 %conv38, ptr %bits.addr.i, align 8, !noalias !596
  store ptr %249, ptr %pos.addr.i, align 8, !noalias !596
  store ptr %250, ptr %array.addr.i, align 8, !noalias !596
  %251 = load ptr, ptr %array.addr.i, align 8, !noalias !596
  %252 = load ptr, ptr %pos.addr.i, align 8, !noalias !596
  %253 = load i64, ptr %252, align 8
  %shr.i = lshr i64 %253, 3
  %arrayidx.i = getelementptr inbounds i8, ptr %251, i64 %shr.i
  store ptr %arrayidx.i, ptr %p.i, align 8, !noalias !596
  %254 = load ptr, ptr %p.i, align 8, !noalias !596
  %255 = load i8, ptr %254, align 1
  %conv.i = zext i8 %255 to i64
  store i64 %conv.i, ptr %v.i, align 8, !noalias !596
  %256 = load i64, ptr %bits.addr.i, align 8, !noalias !596
  %257 = load ptr, ptr %pos.addr.i, align 8, !noalias !596
  %258 = load i64, ptr %257, align 8
  %and.i = and i64 %258, 7
  %shl.i = shl i64 %256, %and.i
  %259 = load i64, ptr %v.i, align 8, !noalias !596
  %or.i = or i64 %259, %shl.i
  store i64 %or.i, ptr %v.i, align 8, !noalias !596
  %260 = load ptr, ptr %p.i, align 8, !noalias !596
  %261 = load i64, ptr %v.i, align 8, !noalias !596
  store ptr %260, ptr %p.addr.i204, align 8
  store i64 %261, ptr %v.addr.i205, align 8
  %262 = load ptr, ptr %p.addr.i204, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %262, ptr align 8 %v.addr.i205, i64 8, i1 false)
  %263 = load i64, ptr %n_bits.addr.i, align 8, !noalias !596
  %264 = load ptr, ptr %pos.addr.i, align 8, !noalias !596
  %265 = load i64, ptr %264, align 8
  %add.i = add i64 %265, %263
  store i64 %add.i, ptr %264, align 8
  br label %if.end39

if.end39:                                         ; preds = %if.else28, %if.then24
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then19
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.ctlz.i32(i32, i1 immarg) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare void @llvm.experimental.noalias.scope.decl(metadata) #6

attributes #0 = { nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #2 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { alwaysinline nounwind uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #6 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #7 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"uwtable", i32 2}
!3 = !{i32 7, !"frame-pointer", i32 2}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.mustprogress"}
!6 = distinct !{!6, !5}
!7 = distinct !{!7, !5}
!8 = !{!9}
!9 = distinct !{!9, !10, !"BrotliWriteBits: %pos"}
!10 = distinct !{!10, !"BrotliWriteBits"}
!11 = !{!12}
!12 = distinct !{!12, !10, !"BrotliWriteBits: %array"}
!13 = !{!9, !12}
!14 = !{!15}
!15 = distinct !{!15, !16, !"BrotliWriteBits: %pos"}
!16 = distinct !{!16, !"BrotliWriteBits"}
!17 = !{!18}
!18 = distinct !{!18, !16, !"BrotliWriteBits: %array"}
!19 = !{!15, !18}
!20 = distinct !{!20, !5}
!21 = !{!22}
!22 = distinct !{!22, !23, !"BrotliWriteBits: %pos"}
!23 = distinct !{!23, !"BrotliWriteBits"}
!24 = !{!25}
!25 = distinct !{!25, !23, !"BrotliWriteBits: %array"}
!26 = !{!22, !25}
!27 = !{!28}
!28 = distinct !{!28, !29, !"BrotliWriteBits: %pos"}
!29 = distinct !{!29, !"BrotliWriteBits"}
!30 = !{!31}
!31 = distinct !{!31, !29, !"BrotliWriteBits: %array"}
!32 = !{!28, !31}
!33 = !{!34}
!34 = distinct !{!34, !35, !"BrotliWriteBits: %pos"}
!35 = distinct !{!35, !"BrotliWriteBits"}
!36 = !{!37}
!37 = distinct !{!37, !35, !"BrotliWriteBits: %array"}
!38 = !{!34, !37}
!39 = distinct !{!39, !5}
!40 = distinct !{!40, !5}
!41 = !{!42}
!42 = distinct !{!42, !43, !"BrotliWriteBits: %pos"}
!43 = distinct !{!43, !"BrotliWriteBits"}
!44 = !{!45}
!45 = distinct !{!45, !43, !"BrotliWriteBits: %array"}
!46 = !{!42, !45}
!47 = !{!48}
!48 = distinct !{!48, !49, !"BrotliWriteBits: %pos"}
!49 = distinct !{!49, !"BrotliWriteBits"}
!50 = !{!51}
!51 = distinct !{!51, !49, !"BrotliWriteBits: %array"}
!52 = !{!48, !51}
!53 = distinct !{!53, !5}
!54 = distinct !{!54, !5}
!55 = distinct !{!55, !5}
!56 = distinct !{!56, !5}
!57 = distinct !{!57, !5}
!58 = distinct !{!58, !5}
!59 = distinct !{!59, !5}
!60 = !{!61}
!61 = distinct !{!61, !62, !"BrotliWriteBits: %pos"}
!62 = distinct !{!62, !"BrotliWriteBits"}
!63 = !{!64}
!64 = distinct !{!64, !62, !"BrotliWriteBits: %array"}
!65 = !{!61, !64}
!66 = !{!67}
!67 = distinct !{!67, !68, !"BrotliWriteBits: %pos"}
!68 = distinct !{!68, !"BrotliWriteBits"}
!69 = !{!70}
!70 = distinct !{!70, !68, !"BrotliWriteBits: %array"}
!71 = !{!67, !70}
!72 = distinct !{!72, !5}
!73 = distinct !{!73, !5}
!74 = !{!75}
!75 = distinct !{!75, !76, !"BrotliWriteBits: %pos"}
!76 = distinct !{!76, !"BrotliWriteBits"}
!77 = !{!78}
!78 = distinct !{!78, !76, !"BrotliWriteBits: %array"}
!79 = !{!75, !78}
!80 = !{!81}
!81 = distinct !{!81, !82, !"BrotliWriteBits: %pos"}
!82 = distinct !{!82, !"BrotliWriteBits"}
!83 = !{!84}
!84 = distinct !{!84, !82, !"BrotliWriteBits: %array"}
!85 = !{!81, !84}
!86 = !{!87}
!87 = distinct !{!87, !88, !"BrotliWriteBits: %pos"}
!88 = distinct !{!88, !"BrotliWriteBits"}
!89 = !{!90}
!90 = distinct !{!90, !88, !"BrotliWriteBits: %array"}
!91 = !{!87, !90}
!92 = !{!93}
!93 = distinct !{!93, !94, !"BrotliWriteBits: %pos"}
!94 = distinct !{!94, !"BrotliWriteBits"}
!95 = !{!96}
!96 = distinct !{!96, !94, !"BrotliWriteBits: %array"}
!97 = !{!93, !96}
!98 = !{!99}
!99 = distinct !{!99, !100, !"BrotliWriteBits: %pos"}
!100 = distinct !{!100, !"BrotliWriteBits"}
!101 = !{!102}
!102 = distinct !{!102, !100, !"BrotliWriteBits: %array"}
!103 = !{!99, !102}
!104 = !{!105}
!105 = distinct !{!105, !106, !"BrotliWriteBits: %pos"}
!106 = distinct !{!106, !"BrotliWriteBits"}
!107 = !{!108}
!108 = distinct !{!108, !106, !"BrotliWriteBits: %array"}
!109 = !{!105, !108}
!110 = !{!111}
!111 = distinct !{!111, !112, !"BrotliWriteBits: %pos"}
!112 = distinct !{!112, !"BrotliWriteBits"}
!113 = !{!114}
!114 = distinct !{!114, !112, !"BrotliWriteBits: %array"}
!115 = !{!111, !114}
!116 = !{!117}
!117 = distinct !{!117, !118, !"BrotliWriteBits: %pos"}
!118 = distinct !{!118, !"BrotliWriteBits"}
!119 = !{!120}
!120 = distinct !{!120, !118, !"BrotliWriteBits: %array"}
!121 = !{!117, !120}
!122 = !{!123}
!123 = distinct !{!123, !124, !"BrotliWriteBits: %pos"}
!124 = distinct !{!124, !"BrotliWriteBits"}
!125 = !{!126}
!126 = distinct !{!126, !124, !"BrotliWriteBits: %array"}
!127 = !{!123, !126}
!128 = !{!129}
!129 = distinct !{!129, !130, !"BrotliWriteBits: %pos"}
!130 = distinct !{!130, !"BrotliWriteBits"}
!131 = !{!132}
!132 = distinct !{!132, !130, !"BrotliWriteBits: %array"}
!133 = !{!129, !132}
!134 = !{!135}
!135 = distinct !{!135, !136, !"BrotliWriteBits: %pos"}
!136 = distinct !{!136, !"BrotliWriteBits"}
!137 = !{!138}
!138 = distinct !{!138, !136, !"BrotliWriteBits: %array"}
!139 = !{!135, !138}
!140 = distinct !{!140, !5}
!141 = !{!142}
!142 = distinct !{!142, !143, !"BrotliWriteBits: %pos"}
!143 = distinct !{!143, !"BrotliWriteBits"}
!144 = !{!145}
!145 = distinct !{!145, !143, !"BrotliWriteBits: %array"}
!146 = !{!142, !145}
!147 = !{!148}
!148 = distinct !{!148, !149, !"BrotliWriteBits: %pos"}
!149 = distinct !{!149, !"BrotliWriteBits"}
!150 = !{!151}
!151 = distinct !{!151, !149, !"BrotliWriteBits: %array"}
!152 = !{!148, !151}
!153 = !{!154}
!154 = distinct !{!154, !155, !"BrotliWriteBits: %pos"}
!155 = distinct !{!155, !"BrotliWriteBits"}
!156 = !{!157}
!157 = distinct !{!157, !155, !"BrotliWriteBits: %array"}
!158 = !{!154, !157}
!159 = distinct !{!159, !5}
!160 = !{!161}
!161 = distinct !{!161, !162, !"BrotliWriteBits: %pos"}
!162 = distinct !{!162, !"BrotliWriteBits"}
!163 = !{!164}
!164 = distinct !{!164, !162, !"BrotliWriteBits: %array"}
!165 = !{!161, !164}
!166 = distinct !{!166, !5}
!167 = !{!168}
!168 = distinct !{!168, !169, !"BrotliWriteBits: %pos"}
!169 = distinct !{!169, !"BrotliWriteBits"}
!170 = !{!171}
!171 = distinct !{!171, !169, !"BrotliWriteBits: %array"}
!172 = !{!168, !171}
!173 = !{!174}
!174 = distinct !{!174, !175, !"BrotliWriteBits: %pos"}
!175 = distinct !{!175, !"BrotliWriteBits"}
!176 = !{!177}
!177 = distinct !{!177, !175, !"BrotliWriteBits: %array"}
!178 = !{!174, !177}
!179 = !{!180}
!180 = distinct !{!180, !181, !"BrotliWriteBits: %pos"}
!181 = distinct !{!181, !"BrotliWriteBits"}
!182 = !{!183}
!183 = distinct !{!183, !181, !"BrotliWriteBits: %array"}
!184 = !{!180, !183}
!185 = distinct !{!185, !5}
!186 = !{!187}
!187 = distinct !{!187, !188, !"BrotliWriteBits: %pos"}
!188 = distinct !{!188, !"BrotliWriteBits"}
!189 = !{!190}
!190 = distinct !{!190, !188, !"BrotliWriteBits: %array"}
!191 = !{!187, !190}
!192 = distinct !{!192, !5}
!193 = distinct !{!193, !5}
!194 = !{!195}
!195 = distinct !{!195, !196, !"BrotliWriteBits: %pos"}
!196 = distinct !{!196, !"BrotliWriteBits"}
!197 = !{!198}
!198 = distinct !{!198, !196, !"BrotliWriteBits: %array"}
!199 = !{!195, !198}
!200 = distinct !{!200, !5}
!201 = !{!202}
!202 = distinct !{!202, !203, !"BrotliWriteBits: %pos"}
!203 = distinct !{!203, !"BrotliWriteBits"}
!204 = !{!205}
!205 = distinct !{!205, !203, !"BrotliWriteBits: %array"}
!206 = !{!202, !205}
!207 = !{!208}
!208 = distinct !{!208, !209, !"BrotliWriteBits: %pos"}
!209 = distinct !{!209, !"BrotliWriteBits"}
!210 = !{!211}
!211 = distinct !{!211, !209, !"BrotliWriteBits: %array"}
!212 = !{!208, !211}
!213 = !{!214}
!214 = distinct !{!214, !215, !"BrotliWriteBits: %pos"}
!215 = distinct !{!215, !"BrotliWriteBits"}
!216 = !{!217}
!217 = distinct !{!217, !215, !"BrotliWriteBits: %array"}
!218 = !{!214, !217}
!219 = !{!220}
!220 = distinct !{!220, !221, !"BrotliWriteBits: %pos"}
!221 = distinct !{!221, !"BrotliWriteBits"}
!222 = !{!223}
!223 = distinct !{!223, !221, !"BrotliWriteBits: %array"}
!224 = !{!220, !223}
!225 = !{!226}
!226 = distinct !{!226, !227, !"BrotliWriteBits: %pos"}
!227 = distinct !{!227, !"BrotliWriteBits"}
!228 = !{!229}
!229 = distinct !{!229, !227, !"BrotliWriteBits: %array"}
!230 = !{!226, !229}
!231 = !{!232}
!232 = distinct !{!232, !233, !"BrotliWriteBits: %pos"}
!233 = distinct !{!233, !"BrotliWriteBits"}
!234 = !{!235}
!235 = distinct !{!235, !233, !"BrotliWriteBits: %array"}
!236 = !{!232, !235}
!237 = !{!238}
!238 = distinct !{!238, !239, !"BrotliWriteBits: %pos"}
!239 = distinct !{!239, !"BrotliWriteBits"}
!240 = !{!241}
!241 = distinct !{!241, !239, !"BrotliWriteBits: %array"}
!242 = !{!238, !241}
!243 = distinct !{!243, !5}
!244 = !{!245}
!245 = distinct !{!245, !246, !"BrotliWriteBits: %pos"}
!246 = distinct !{!246, !"BrotliWriteBits"}
!247 = !{!248}
!248 = distinct !{!248, !246, !"BrotliWriteBits: %array"}
!249 = !{!245, !248}
!250 = !{!251}
!251 = distinct !{!251, !252, !"BrotliWriteBits: %pos"}
!252 = distinct !{!252, !"BrotliWriteBits"}
!253 = !{!254}
!254 = distinct !{!254, !252, !"BrotliWriteBits: %array"}
!255 = !{!251, !254}
!256 = !{!257}
!257 = distinct !{!257, !258, !"BrotliWriteBits: %pos"}
!258 = distinct !{!258, !"BrotliWriteBits"}
!259 = !{!260}
!260 = distinct !{!260, !258, !"BrotliWriteBits: %array"}
!261 = !{!257, !260}
!262 = distinct !{!262, !5}
!263 = !{!264}
!264 = distinct !{!264, !265, !"BrotliWriteBits: %pos"}
!265 = distinct !{!265, !"BrotliWriteBits"}
!266 = !{!267}
!267 = distinct !{!267, !265, !"BrotliWriteBits: %array"}
!268 = !{!264, !267}
!269 = distinct !{!269, !5}
!270 = !{!271}
!271 = distinct !{!271, !272, !"BrotliWriteBits: %pos"}
!272 = distinct !{!272, !"BrotliWriteBits"}
!273 = !{!274}
!274 = distinct !{!274, !272, !"BrotliWriteBits: %array"}
!275 = !{!271, !274}
!276 = !{!277}
!277 = distinct !{!277, !278, !"BrotliWriteBits: %pos"}
!278 = distinct !{!278, !"BrotliWriteBits"}
!279 = !{!280}
!280 = distinct !{!280, !278, !"BrotliWriteBits: %array"}
!281 = !{!277, !280}
!282 = !{!283}
!283 = distinct !{!283, !284, !"BrotliWriteBits: %pos"}
!284 = distinct !{!284, !"BrotliWriteBits"}
!285 = !{!286}
!286 = distinct !{!286, !284, !"BrotliWriteBits: %array"}
!287 = !{!283, !286}
!288 = !{!289}
!289 = distinct !{!289, !290, !"BrotliWriteBits: %pos"}
!290 = distinct !{!290, !"BrotliWriteBits"}
!291 = !{!292}
!292 = distinct !{!292, !290, !"BrotliWriteBits: %array"}
!293 = !{!289, !292}
!294 = distinct !{!294, !5}
!295 = !{!296}
!296 = distinct !{!296, !297, !"BrotliWriteBits: %pos"}
!297 = distinct !{!297, !"BrotliWriteBits"}
!298 = !{!299}
!299 = distinct !{!299, !297, !"BrotliWriteBits: %array"}
!300 = !{!296, !299}
!301 = distinct !{!301, !5}
!302 = distinct !{!302, !5}
!303 = distinct !{!303, !5}
!304 = !{!305}
!305 = distinct !{!305, !306, !"BrotliWriteBits: %pos"}
!306 = distinct !{!306, !"BrotliWriteBits"}
!307 = !{!308}
!308 = distinct !{!308, !306, !"BrotliWriteBits: %array"}
!309 = !{!305, !308}
!310 = distinct !{!310, !5}
!311 = !{!312}
!312 = distinct !{!312, !313, !"BrotliWriteBits: %pos"}
!313 = distinct !{!313, !"BrotliWriteBits"}
!314 = !{!315}
!315 = distinct !{!315, !313, !"BrotliWriteBits: %array"}
!316 = !{!312, !315}
!317 = !{!318}
!318 = distinct !{!318, !319, !"BrotliWriteBits: %pos"}
!319 = distinct !{!319, !"BrotliWriteBits"}
!320 = !{!321}
!321 = distinct !{!321, !319, !"BrotliWriteBits: %array"}
!322 = !{!318, !321}
!323 = !{!324}
!324 = distinct !{!324, !325, !"BrotliWriteBits: %pos"}
!325 = distinct !{!325, !"BrotliWriteBits"}
!326 = !{!327}
!327 = distinct !{!327, !325, !"BrotliWriteBits: %array"}
!328 = !{!324, !327}
!329 = !{!330}
!330 = distinct !{!330, !331, !"BrotliWriteBits: %pos"}
!331 = distinct !{!331, !"BrotliWriteBits"}
!332 = !{!333}
!333 = distinct !{!333, !331, !"BrotliWriteBits: %array"}
!334 = !{!330, !333}
!335 = !{!336}
!336 = distinct !{!336, !337, !"BrotliWriteBits: %pos"}
!337 = distinct !{!337, !"BrotliWriteBits"}
!338 = !{!339}
!339 = distinct !{!339, !337, !"BrotliWriteBits: %array"}
!340 = !{!336, !339}
!341 = !{!342}
!342 = distinct !{!342, !343, !"BrotliWriteBits: %pos"}
!343 = distinct !{!343, !"BrotliWriteBits"}
!344 = !{!345}
!345 = distinct !{!345, !343, !"BrotliWriteBits: %array"}
!346 = !{!342, !345}
!347 = !{!348}
!348 = distinct !{!348, !349, !"BrotliWriteBits: %pos"}
!349 = distinct !{!349, !"BrotliWriteBits"}
!350 = !{!351}
!351 = distinct !{!351, !349, !"BrotliWriteBits: %array"}
!352 = !{!348, !351}
!353 = !{!354}
!354 = distinct !{!354, !355, !"BrotliWriteBits: %pos"}
!355 = distinct !{!355, !"BrotliWriteBits"}
!356 = !{!357}
!357 = distinct !{!357, !355, !"BrotliWriteBits: %array"}
!358 = !{!354, !357}
!359 = distinct !{!359, !5}
!360 = distinct !{!360, !5}
!361 = distinct !{!361, !5}
!362 = distinct !{!362, !5}
!363 = !{!364}
!364 = distinct !{!364, !365, !"BrotliWriteBits: %pos"}
!365 = distinct !{!365, !"BrotliWriteBits"}
!366 = !{!367}
!367 = distinct !{!367, !365, !"BrotliWriteBits: %array"}
!368 = !{!364, !367}
!369 = !{!370}
!370 = distinct !{!370, !371, !"BrotliWriteBits: %pos"}
!371 = distinct !{!371, !"BrotliWriteBits"}
!372 = !{!373}
!373 = distinct !{!373, !371, !"BrotliWriteBits: %array"}
!374 = !{!370, !373}
!375 = !{!376}
!376 = distinct !{!376, !377, !"BrotliWriteBits: %pos"}
!377 = distinct !{!377, !"BrotliWriteBits"}
!378 = !{!379}
!379 = distinct !{!379, !377, !"BrotliWriteBits: %array"}
!380 = !{!376, !379}
!381 = !{!382}
!382 = distinct !{!382, !383, !"BrotliWriteBits: %pos"}
!383 = distinct !{!383, !"BrotliWriteBits"}
!384 = !{!385}
!385 = distinct !{!385, !383, !"BrotliWriteBits: %array"}
!386 = !{!382, !385}
!387 = !{!388}
!388 = distinct !{!388, !389, !"BrotliWriteBits: %pos"}
!389 = distinct !{!389, !"BrotliWriteBits"}
!390 = !{!391}
!391 = distinct !{!391, !389, !"BrotliWriteBits: %array"}
!392 = !{!388, !391}
!393 = distinct !{!393, !5}
!394 = !{!395}
!395 = distinct !{!395, !396, !"BrotliWriteBits: %pos"}
!396 = distinct !{!396, !"BrotliWriteBits"}
!397 = !{!398}
!398 = distinct !{!398, !396, !"BrotliWriteBits: %array"}
!399 = !{!395, !398}
!400 = !{!401}
!401 = distinct !{!401, !402, !"BrotliWriteBits: %pos"}
!402 = distinct !{!402, !"BrotliWriteBits"}
!403 = !{!404}
!404 = distinct !{!404, !402, !"BrotliWriteBits: %array"}
!405 = !{!401, !404}
!406 = distinct !{!406, !5}
!407 = !{!408}
!408 = distinct !{!408, !409, !"BrotliWriteBits: %pos"}
!409 = distinct !{!409, !"BrotliWriteBits"}
!410 = !{!411}
!411 = distinct !{!411, !409, !"BrotliWriteBits: %array"}
!412 = !{!408, !411}
!413 = distinct !{!413, !5}
!414 = distinct !{!414, !5}
!415 = !{!416}
!416 = distinct !{!416, !417, !"BrotliWriteBits: %pos"}
!417 = distinct !{!417, !"BrotliWriteBits"}
!418 = !{!419}
!419 = distinct !{!419, !417, !"BrotliWriteBits: %array"}
!420 = !{!416, !419}
!421 = !{!422}
!422 = distinct !{!422, !423, !"BrotliWriteBits: %pos"}
!423 = distinct !{!423, !"BrotliWriteBits"}
!424 = !{!425}
!425 = distinct !{!425, !423, !"BrotliWriteBits: %array"}
!426 = !{!422, !425}
!427 = !{!428}
!428 = distinct !{!428, !429, !"BrotliWriteBits: %pos"}
!429 = distinct !{!429, !"BrotliWriteBits"}
!430 = !{!431}
!431 = distinct !{!431, !429, !"BrotliWriteBits: %array"}
!432 = !{!428, !431}
!433 = !{!434}
!434 = distinct !{!434, !435, !"BrotliWriteBits: %pos"}
!435 = distinct !{!435, !"BrotliWriteBits"}
!436 = !{!437}
!437 = distinct !{!437, !435, !"BrotliWriteBits: %array"}
!438 = !{!434, !437}
!439 = !{!440}
!440 = distinct !{!440, !441, !"BrotliWriteBits: %pos"}
!441 = distinct !{!441, !"BrotliWriteBits"}
!442 = !{!443}
!443 = distinct !{!443, !441, !"BrotliWriteBits: %array"}
!444 = !{!440, !443}
!445 = !{!446}
!446 = distinct !{!446, !447, !"BrotliWriteBits: %pos"}
!447 = distinct !{!447, !"BrotliWriteBits"}
!448 = !{!449}
!449 = distinct !{!449, !447, !"BrotliWriteBits: %array"}
!450 = !{!446, !449}
!451 = !{!452}
!452 = distinct !{!452, !453, !"BrotliWriteBits: %pos"}
!453 = distinct !{!453, !"BrotliWriteBits"}
!454 = !{!455}
!455 = distinct !{!455, !453, !"BrotliWriteBits: %array"}
!456 = !{!452, !455}
!457 = !{!458}
!458 = distinct !{!458, !459, !"BrotliWriteBits: %pos"}
!459 = distinct !{!459, !"BrotliWriteBits"}
!460 = !{!461}
!461 = distinct !{!461, !459, !"BrotliWriteBits: %array"}
!462 = !{!458, !461}
!463 = !{!464}
!464 = distinct !{!464, !465, !"BrotliWriteBits: %pos"}
!465 = distinct !{!465, !"BrotliWriteBits"}
!466 = !{!467}
!467 = distinct !{!467, !465, !"BrotliWriteBits: %array"}
!468 = !{!464, !467}
!469 = distinct !{!469, !5}
!470 = !{!471}
!471 = distinct !{!471, !472, !"BrotliWriteBits: %pos"}
!472 = distinct !{!472, !"BrotliWriteBits"}
!473 = !{!474}
!474 = distinct !{!474, !472, !"BrotliWriteBits: %array"}
!475 = !{!471, !474}
!476 = !{!477}
!477 = distinct !{!477, !478, !"BrotliWriteBits: %pos"}
!478 = distinct !{!478, !"BrotliWriteBits"}
!479 = !{!480}
!480 = distinct !{!480, !478, !"BrotliWriteBits: %array"}
!481 = !{!477, !480}
!482 = !{!483}
!483 = distinct !{!483, !484, !"BrotliWriteBits: %pos"}
!484 = distinct !{!484, !"BrotliWriteBits"}
!485 = !{!486}
!486 = distinct !{!486, !484, !"BrotliWriteBits: %array"}
!487 = !{!483, !486}
!488 = !{!489}
!489 = distinct !{!489, !490, !"BrotliWriteBits: %pos"}
!490 = distinct !{!490, !"BrotliWriteBits"}
!491 = !{!492}
!492 = distinct !{!492, !490, !"BrotliWriteBits: %array"}
!493 = !{!489, !492}
!494 = !{!495}
!495 = distinct !{!495, !496, !"BrotliWriteBits: %pos"}
!496 = distinct !{!496, !"BrotliWriteBits"}
!497 = !{!498}
!498 = distinct !{!498, !496, !"BrotliWriteBits: %array"}
!499 = !{!495, !498}
!500 = !{!501}
!501 = distinct !{!501, !502, !"BrotliWriteBits: %pos"}
!502 = distinct !{!502, !"BrotliWriteBits"}
!503 = !{!504}
!504 = distinct !{!504, !502, !"BrotliWriteBits: %array"}
!505 = !{!501, !504}
!506 = !{!507}
!507 = distinct !{!507, !508, !"BrotliWriteBits: %pos"}
!508 = distinct !{!508, !"BrotliWriteBits"}
!509 = !{!510}
!510 = distinct !{!510, !508, !"BrotliWriteBits: %array"}
!511 = !{!507, !510}
!512 = distinct !{!512, !5}
!513 = distinct !{!513, !5}
!514 = distinct !{!514, !5}
!515 = distinct !{!515, !5}
!516 = distinct !{!516, !5}
!517 = distinct !{!517, !5}
!518 = distinct !{!518, !5}
!519 = distinct !{!519, !5}
!520 = distinct !{!520, !5}
!521 = distinct !{!521, !5}
!522 = distinct !{!522, !5}
!523 = !{!524}
!524 = distinct !{!524, !525, !"BrotliWriteBits: %pos"}
!525 = distinct !{!525, !"BrotliWriteBits"}
!526 = !{!527}
!527 = distinct !{!527, !525, !"BrotliWriteBits: %array"}
!528 = !{!524, !527}
!529 = !{!530}
!530 = distinct !{!530, !531, !"BrotliWriteBits: %pos"}
!531 = distinct !{!531, !"BrotliWriteBits"}
!532 = !{!533}
!533 = distinct !{!533, !531, !"BrotliWriteBits: %array"}
!534 = !{!530, !533}
!535 = distinct !{!535, !5}
!536 = distinct !{!536, !5}
!537 = !{!538}
!538 = distinct !{!538, !539, !"BrotliWriteBits: %pos"}
!539 = distinct !{!539, !"BrotliWriteBits"}
!540 = !{!541}
!541 = distinct !{!541, !539, !"BrotliWriteBits: %array"}
!542 = !{!538, !541}
!543 = !{!544}
!544 = distinct !{!544, !545, !"BrotliWriteBits: %pos"}
!545 = distinct !{!545, !"BrotliWriteBits"}
!546 = !{!547}
!547 = distinct !{!547, !545, !"BrotliWriteBits: %array"}
!548 = !{!544, !547}
!549 = !{!550}
!550 = distinct !{!550, !551, !"BrotliWriteBits: %pos"}
!551 = distinct !{!551, !"BrotliWriteBits"}
!552 = !{!553}
!553 = distinct !{!553, !551, !"BrotliWriteBits: %array"}
!554 = !{!550, !553}
!555 = !{!556}
!556 = distinct !{!556, !557, !"BrotliWriteBits: %pos"}
!557 = distinct !{!557, !"BrotliWriteBits"}
!558 = !{!559}
!559 = distinct !{!559, !557, !"BrotliWriteBits: %array"}
!560 = !{!556, !559}
!561 = !{!562}
!562 = distinct !{!562, !563, !"BrotliWriteBits: %pos"}
!563 = distinct !{!563, !"BrotliWriteBits"}
!564 = !{!565}
!565 = distinct !{!565, !563, !"BrotliWriteBits: %array"}
!566 = !{!562, !565}
!567 = !{!568}
!568 = distinct !{!568, !569, !"BrotliWriteBits: %pos"}
!569 = distinct !{!569, !"BrotliWriteBits"}
!570 = !{!571}
!571 = distinct !{!571, !569, !"BrotliWriteBits: %array"}
!572 = !{!568, !571}
!573 = !{!574}
!574 = distinct !{!574, !575, !"BrotliWriteBits: %pos"}
!575 = distinct !{!575, !"BrotliWriteBits"}
!576 = !{!577}
!577 = distinct !{!577, !575, !"BrotliWriteBits: %array"}
!578 = !{!574, !577}
!579 = !{!580}
!580 = distinct !{!580, !581, !"BrotliWriteBits: %pos"}
!581 = distinct !{!581, !"BrotliWriteBits"}
!582 = !{!583}
!583 = distinct !{!583, !581, !"BrotliWriteBits: %array"}
!584 = !{!580, !583}
!585 = !{!586}
!586 = distinct !{!586, !587, !"BrotliWriteBits: %pos"}
!587 = distinct !{!587, !"BrotliWriteBits"}
!588 = !{!589}
!589 = distinct !{!589, !587, !"BrotliWriteBits: %array"}
!590 = !{!586, !589}
!591 = !{!592}
!592 = distinct !{!592, !593, !"BrotliWriteBits: %pos"}
!593 = distinct !{!593, !"BrotliWriteBits"}
!594 = !{!595}
!595 = distinct !{!595, !593, !"BrotliWriteBits: %array"}
!596 = !{!592, !595}
