target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.DebugFrame = type <{ %struct.DebugFrameHeader, [4 x i8], [14 x i8] }>
%struct.DebugFrameHeader = type { %struct.DebugFrameCIE, %struct.DebugFrameFDEHeader }
%struct.DebugFrameCIE = type { i32, i32, i8, [1 x i8], i8, i8, i8 }
%struct.DebugFrameFDEHeader = type { i32, i32, i64, i64 }
%struct.TCGContext = type { ptr, ptr, ptr, ptr, ptr, i32, i32, i32, i32, i32, i32, i32, i8, i8, i8, i32, i32, i64, i64, i64, ptr, ptr, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, %struct.anon.2, ptr, ptr, ptr, ptr, [6 x ptr], [6 x %struct.TCGTempSet], [512 x %struct.TCGTemp], %union.anon.3, %union.anon.3, %struct.anon.4, [32 x ptr], [512 x i16], ptr, [1 x %struct.__jmp_buf_tag] }
%struct.anon.2 = type { ptr, ptr }
%struct.TCGTempSet = type { [8 x i64] }
%struct.TCGTemp = type { i48, i64, ptr, i64, ptr, i64, ptr }
%union.anon.3 = type { %struct.QTailQLink }
%struct.QTailQLink = type { ptr, ptr }
%struct.anon.4 = type { ptr, ptr }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.__sigset_t = type { [16 x i64] }
%struct.jit_descriptor = type { i32, i32, ptr, ptr }
%struct.TCGOpDef = type { ptr, i8, i8, i8, i8, i8, ptr }
%struct.TCGCallArgumentLoc = type { i32 }
%struct.HostAddress = type { i32, i32, i32, i32, %struct.TCGAtomAlign }
%struct.TCGAtomAlign = type { i32, i32 }
%struct.TCGLdstHelperParam = type { ptr, i32, [3 x i32] }
%struct.TCGMovExtend = type { i32, i32, i32, i32, i32 }
%struct.elf64_phdr = type { i32, i32, i64, i64, i64, i64, i64, i64 }
%struct.elf64_shdr = type { i32, i32, i64, i64, i64, i64, i32, i32, i64, i64 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.DebugInfo = type <{ i32, i16, i32, i8, i8, i16, i64, i64, i8, [16 x i8], i64, i64, i8 }>
%struct.jit_code_entry = type { ptr, ptr, ptr, i64 }
%struct.TCGLabel = type { i8, i8, i16, %union.anon, %struct.anon, %struct.anon.0, %struct.anon.1 }
%union.anon = type { i64 }
%struct.anon = type { ptr, ptr }
%struct.anon.0 = type { ptr, ptr }
%struct.anon.1 = type { ptr }
%struct.TranslationBlock = type { i64, i64, i32, i32, i16, i16, %struct.tb_tc, %struct.IntervalTreeNode, %struct.QemuSpin, [2 x i16], [2 x i16], [2 x i64], i64, [2 x i64], [2 x i64] }
%struct.tb_tc = type { ptr, i64 }
%struct.IntervalTreeNode = type { %struct.RBNode, i64, i64, i64 }
%struct.RBNode = type { i64, ptr, ptr }
%struct.QemuSpin = type { i32 }
%struct.__va_list_tag = type { i32, i32, ptr, ptr }
%struct.ElfImage = type { %struct.elf64_hdr, %struct.elf64_phdr, [7 x %struct.elf64_shdr], [2 x %struct.elf64_sym], %struct.DebugInfo, [24 x i8], [80 x i8] }
%struct.elf64_hdr = type { [16 x i8], i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }
%struct.TCGPool = type { ptr, i32, [4 x i8], [0 x i8] }
%struct.TCGArgConstraint = type <{ i40, i32 }>
%struct.TCGLabelPoolData = type { ptr, ptr, i64, i32, i32, [0 x i64] }
%struct.TCGHelperInfo = type { ptr, ptr, i64, i64, [14 x %struct.TCGCallArgumentLoc] }
%struct.qemu_plugin_insn = type { ptr, i64, ptr, [2 x [2 x ptr]], i8, i8, i8 }
%struct.TCGOp = type { i32, i32, %union.anon.5, [2 x i32], [0 x i64] }
%union.anon.5 = type { %struct.QTailQLink }
%struct.TCGLabelUse = type { %struct.anon.6, ptr }
%struct.anon.6 = type { ptr }
%struct.TCGLabelQemuLdst = type { i8, i32, i32, i32, i32, i32, i32, ptr, [2 x ptr], %struct.anon.8 }
%struct.anon.8 = type { ptr }
%struct.TCGRelocation = type { %struct.anon.7, ptr, i64, i32 }
%struct.anon.7 = type { ptr }
%struct.TCGCumulativeArgs = type { i32, i32, i32, i32 }
%struct.TCGTargetOpDef = type { i32, [16 x ptr] }
%struct.qemu_plugin_tb = type { ptr, i64, i64, i64, ptr, ptr, i8, i8, [2 x ptr] }

@tcg_ctx = dso_local thread_local global ptr null, align 8
@cpuinfo = external global i32, align 4
@.str = private unnamed_addr constant [104 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/tcg/i386/tcg-target.c.inc\00", align 1
@__func__.tb_target_set_jmp_target = private unnamed_addr constant [25 x i8] c"tb_target_set_jmp_target\00", align 1
@debug_frame = internal constant %struct.DebugFrame <{ %struct.DebugFrameHeader { %struct.DebugFrameCIE { i32 12, i32 -1, i8 1, [1 x i8] zeroinitializer, i8 1, i8 120, i8 16 }, %struct.DebugFrameFDEHeader { i32 38, i32 0, i64 0, i64 0 } }, [4 x i8] c"\0C\07\C0\09", [14 x i8] c"\90\01\86\02\83\03\8C\04\8D\05\8E\06\8F\07" }>, align 1
@tcg_init_ctx = dso_local global %struct.TCGContext zeroinitializer, align 8
@qemu_icache_linesize = external global i32, align 4
@.str.1 = private unnamed_addr constant [18 x i8] c"../qemu/tcg/tcg.c\00", align 1
@__func__.tcg_tb_alloc = private unnamed_addr constant [13 x i8] c"tcg_tb_alloc\00", align 1
@tcg_qemu_tb_exec = dso_local global ptr null, align 8
@.str.2 = private unnamed_addr constant [22 x i8] c"PROLOGUE: [size=%zu]\0A\00", align 1
@.str.3 = private unnamed_addr constant [27 x i8] c"0x%08lx:  .quad  0x%016lx\0A\00", align 1
@.str.4 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@tcg_code_gen_epilogue = dso_local global ptr null, align 8
@.str.5 = private unnamed_addr constant [7 x i8] c"_frame\00", align 1
@__func__.tcg_temp_free_internal = private unnamed_addr constant [23 x i8] c"tcg_temp_free_internal\00", align 1
@.str.6 = private unnamed_addr constant [5 x i8] c"OP:\0A\00", align 1
@.str.7 = private unnamed_addr constant [30 x i8] c"OP before indirect lowering:\0A\00", align 1
@.str.8 = private unnamed_addr constant [46 x i8] c"OP after optimization and liveness analysis:\0A\00", align 1
@.str.9 = private unnamed_addr constant [38 x i8] c"s->gen_insn_end_off[num_insns] == off\00", align 1
@__PRETTY_FUNCTION__.tcg_gen_code = private unnamed_addr constant [61 x i8] c"int tcg_gen_code(TCGContext *, TranslationBlock *, uint64_t)\00", align 1
@__jit_debug_descriptor = dso_local global %struct.jit_descriptor { i32 1, i32 0, ptr null, ptr null }, align 8
@tcg_use_softmmu = dso_local global i8 0, align 1
@tcg_ctxs = dso_local global ptr null, align 8
@tcg_cur_ctxs = dso_local global i32 0, align 4
@tcg_max_ctxs = dso_local global i32 0, align 4
@tcg_env = dso_local global ptr null, align 8
@tcg_splitwx_diff = dso_local global i64 0, align 8
@__func__.expand_vec_sari = private unnamed_addr constant [16 x i8] c"expand_vec_sari\00", align 1
@__func__.expand_vec_mul = private unnamed_addr constant [15 x i8] c"expand_vec_mul\00", align 1
@__func__.expand_vec_cmp_noinv = private unnamed_addr constant [21 x i8] c"expand_vec_cmp_noinv\00", align 1
@tcg_op_defs = external global [0 x %struct.TCGOpDef], align 8
@tcg_target_reg_alloc_order = internal constant [31 x i32] [i32 5, i32 3, i32 12, i32 13, i32 14, i32 15, i32 10, i32 11, i32 9, i32 8, i32 1, i32 2, i32 6, i32 7, i32 0, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31], align 16
@tcg_target_call_clobber_regs = internal global i32 0, align 4
@indirect_reg_alloc_order = internal global [31 x i32] zeroinitializer, align 16
@.str.10 = private unnamed_addr constant [4 x i8] c"env\00", align 1
@__func__.init_call_layout = private unnamed_addr constant [17 x i8] c"init_call_layout\00", align 1
@.str.11 = private unnamed_addr constant [40 x i8] c"cum.info_in_idx <= ARRAY_SIZE(info->in)\00", align 1
@__PRETTY_FUNCTION__.init_call_layout = private unnamed_addr constant [39 x i8] c"void init_call_layout(TCGHelperInfo *)\00", align 1
@.str.12 = private unnamed_addr constant [46 x i8] c"cum.arg_slot <= max_reg_slots + max_stk_slots\00", align 1
@.str.13 = private unnamed_addr constant [41 x i8] c"ref_base + cum.ref_slot <= max_stk_slots\00", align 1
@__func__.tcg_target_call_oarg_reg = private unnamed_addr constant [25 x i8] c"tcg_target_call_oarg_reg\00", align 1
@info_helper_ld32_mmu = internal global { ptr, ptr, i64, i8, i8, i8, i8, i8, i8, i8, i8, [14 x %struct.TCGCallArgumentLoc] } { ptr null, ptr null, i64 0, i8 52, i8 101, i8 0, i8 0, i8 2, i8 0, i8 0, i8 0, [14 x %struct.TCGCallArgumentLoc] zeroinitializer }, align 8
@info_helper_ld64_mmu = internal global { ptr, ptr, i64, i8, i8, i8, i8, i8, i8, i8, i8, [14 x %struct.TCGCallArgumentLoc] } { ptr null, ptr null, i64 0, i8 52, i8 101, i8 0, i8 0, i8 2, i8 0, i8 0, i8 0, [14 x %struct.TCGCallArgumentLoc] zeroinitializer }, align 8
@info_helper_ld128_mmu = internal global { ptr, ptr, i64, i8, i8, i8, i8, i8, i8, i8, i8, [14 x %struct.TCGCallArgumentLoc] } { ptr null, ptr null, i64 0, i8 55, i8 101, i8 0, i8 0, i8 2, i8 0, i8 0, i8 0, [14 x %struct.TCGCallArgumentLoc] zeroinitializer }, align 8
@info_helper_st32_mmu = internal global { ptr, ptr, i64, i8, i8, i8, i8, i8, i8, i8, i8, [14 x %struct.TCGCallArgumentLoc] } { ptr null, ptr null, i64 0, i8 48, i8 37, i8 3, i8 0, i8 2, i8 0, i8 0, i8 0, [14 x %struct.TCGCallArgumentLoc] zeroinitializer }, align 8
@info_helper_st64_mmu = internal global { ptr, ptr, i64, i8, i8, i8, i8, i8, i8, i8, i8, [14 x %struct.TCGCallArgumentLoc] } { ptr null, ptr null, i64 0, i8 48, i8 41, i8 3, i8 0, i8 2, i8 0, i8 0, i8 0, [14 x %struct.TCGCallArgumentLoc] zeroinitializer }, align 8
@info_helper_st128_mmu = internal global { ptr, ptr, i64, i8, i8, i8, i8, i8, i8, i8, i8, [14 x %struct.TCGCallArgumentLoc] } { ptr null, ptr null, i64 0, i8 48, i8 47, i8 3, i8 0, i8 2, i8 0, i8 0, i8 0, [14 x %struct.TCGCallArgumentLoc] zeroinitializer }, align 8
@tcg_target_available_regs = internal global [6 x i32] zeroinitializer, align 16
@tcg_target_call_iarg_regs = internal constant [6 x i32] [i32 7, i32 6, i32 2, i32 1, i32 8, i32 9], align 16
@__func__.process_op_defs = private unnamed_addr constant [16 x i8] c"process_op_defs\00", align 1
@__func__.tcg_target_op_def = private unnamed_addr constant [18 x i8] c"tcg_target_op_def\00", align 1
@.str.20 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.21 = private unnamed_addr constant [2 x i8] c"L\00", align 1
@.str.22 = private unnamed_addr constant [3 x i8] c"qi\00", align 1
@.str.23 = private unnamed_addr constant [3 x i8] c"re\00", align 1
@.str.24 = private unnamed_addr constant [3 x i8] c"ri\00", align 1
@.str.25 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@.str.26 = private unnamed_addr constant [2 x i8] c"x\00", align 1
@.str.27 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.28 = private unnamed_addr constant [2 x i8] c"q\00", align 1
@.str.29 = private unnamed_addr constant [3 x i8] c"ci\00", align 1
@.str.30 = private unnamed_addr constant [4 x i8] c"reZ\00", align 1
@.str.31 = private unnamed_addr constant [3 x i8] c"rI\00", align 1
@.str.32 = private unnamed_addr constant [3 x i8] c"&r\00", align 1
@.str.33 = private unnamed_addr constant [3 x i8] c"rW\00", align 1
@.str.34 = private unnamed_addr constant [2 x i8] c"a\00", align 1
@.str.35 = private unnamed_addr constant [2 x i8] c"d\00", align 1
@.str.36 = private unnamed_addr constant [2 x i8] c"1\00", align 1
@constraint_sets = internal constant <{ { i32, [4 x i8], <{ ptr, [15 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, ptr, [11 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, ptr, [11 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, ptr, [11 x ptr] }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, ptr, ptr, [10 x ptr] }> } }> <{ { i32, [4 x i8], <{ ptr, [15 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, [15 x ptr] }> <{ ptr @.str.20, [15 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.21, ptr @.str.21, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.22, ptr @.str.20, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.23, ptr @.str.20, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.24, ptr @.str.20, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.20, ptr @.str.23, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.25, ptr @.str.21, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.26, ptr @.str.20, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.21, ptr @.str.21, ptr @.str.21, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.25, ptr @.str.21, ptr @.str.21, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, ptr, [12 x ptr] }> <{ ptr @.str.21, ptr @.str.21, ptr @.str.21, ptr @.str.21, [12 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, ptr, [12 x ptr] }> <{ ptr @.str.20, ptr @.str.20, ptr @.str.24, ptr @.str.24, [12 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.20, ptr @.str.27, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.20, ptr @.str.21, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.20, ptr @.str.28, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.20, ptr @.str.20, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.26, ptr @.str.20, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, [14 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, [14 x ptr] }> <{ ptr @.str.26, ptr @.str.26, [14 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.28, ptr @.str.27, ptr @.str.22, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.28, ptr @.str.20, ptr @.str.23, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.27, ptr @.str.29, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.27, ptr @.str.20, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.27, ptr @.str.23, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.27, ptr @.str.30, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.27, ptr @.str.24, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.27, ptr @.str.31, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.21, ptr @.str.21, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.20, ptr @.str.23, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.20, ptr @.str.24, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.20, ptr @.str.31, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.26, ptr @.str.26, ptr @.str.26, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.32, ptr @.str.20, ptr @.str.20, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.32, ptr @.str.20, ptr @.str.33, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, ptr, [12 x ptr] }> <{ ptr @.str.26, ptr @.str.27, ptr @.str.26, ptr @.str.26, [12 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, ptr, [12 x ptr] }> <{ ptr @.str.26, ptr @.str.26, ptr @.str.26, ptr @.str.26, [12 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, ptr, [11 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, ptr, ptr, [11 x ptr] }> <{ ptr @.str.20, ptr @.str.20, ptr @.str.23, ptr @.str.20, ptr @.str.27, [11 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, ptr, [11 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, ptr, ptr, [11 x ptr] }> <{ ptr @.str.20, ptr @.str.20, ptr @.str.20, ptr @.str.24, ptr @.str.24, [11 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, [13 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, [13 x ptr] }> <{ ptr @.str.20, ptr @.str.20, ptr @.str.21, [13 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, ptr, [12 x ptr] }> <{ ptr @.str.34, ptr @.str.35, ptr @.str.34, ptr @.str.20, [12 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, [12 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, ptr, [12 x ptr] }> <{ ptr @.str.20, ptr @.str.20, ptr @.str.21, ptr @.str.21, [12 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, ptr, [11 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, ptr, ptr, [11 x ptr] }> <{ ptr @.str.34, ptr @.str.35, ptr @.str.27, ptr @.str.36, ptr @.str.20, [11 x ptr] zeroinitializer }> }, { i32, [4 x i8], <{ ptr, ptr, ptr, ptr, ptr, ptr, [10 x ptr] }> } { i32 0, [4 x i8] undef, <{ ptr, ptr, ptr, ptr, ptr, ptr, [10 x ptr] }> <{ ptr @.str.32, ptr @.str.20, ptr @.str.27, ptr @.str.36, ptr @.str.23, ptr @.str.23, [10 x ptr] zeroinitializer }> } }>, align 16
@.str.38 = private unnamed_addr constant [6 x i8] c"n > 1\00", align 1
@__PRETTY_FUNCTION__.get_constraint_priority = private unnamed_addr constant [51 x i8] c"int get_constraint_priority(const TCGOpDef *, int)\00", align 1
@tcg_target_callee_save_regs = internal constant [6 x i32] [i32 5, i32 3, i32 12, i32 13, i32 14, i32 15], align 16
@guest_base = external global i64, align 8
@x86_guest_base = internal global %struct.HostAddress { i32 0, i32 -1, i32 0, i32 0, %struct.TCGAtomAlign zeroinitializer }, align 4
@tb_ret_addr = internal global ptr null, align 8
@__func__.tcg_out_movi = private unnamed_addr constant [13 x i8] c"tcg_out_movi\00", align 1
@__func__.tcg_out_evex_opc = private unnamed_addr constant [17 x i8] c"tcg_out_evex_opc\00", align 1
@.str.39 = private unnamed_addr constant [49 x i8] c"start >= 0 && length > 0 && length <= 32 - start\00", align 1
@.str.40 = private unnamed_addr constant [100 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/bitops.h\00", align 1
@__PRETTY_FUNCTION__.deposit32 = private unnamed_addr constant [49 x i8] c"uint32_t deposit32(uint32_t, int, int, uint32_t)\00", align 1
@__func__.tcg_out_mov = private unnamed_addr constant [12 x i8] c"tcg_out_mov\00", align 1
@__func__.tgen_arithi = private unnamed_addr constant [12 x i8] c"tgen_arithi\00", align 1
@__func__.tcg_out_vex_opc = private unnamed_addr constant [16 x i8] c"tcg_out_vex_opc\00", align 1
@__func__.patch_reloc = private unnamed_addr constant [12 x i8] c"patch_reloc\00", align 1
@qemu_loglevel = external global i32, align 4
@__func__.tcg_global_mem_new_internal = private unnamed_addr constant [28 x i8] c"tcg_global_mem_new_internal\00", align 1
@__func__.tcg_temp_new_internal = private unnamed_addr constant [22 x i8] c"tcg_temp_new_internal\00", align 1
@__func__.tcg_gen_callN = private unnamed_addr constant [14 x i8] c"tcg_gen_callN\00", align 1
@__func__.remove_label_use = private unnamed_addr constant [17 x i8] c"remove_label_use\00", align 1
@__func__.atom_and_align_for_opc = private unnamed_addr constant [23 x i8] c"atom_and_align_for_opc\00", align 1
@.str.41 = private unnamed_addr constant [7 x i8] c"\0A ----\00", align 1
@.str.42 = private unnamed_addr constant [8 x i8] c" %016lx\00", align 1
@.str.43 = private unnamed_addr constant [5 x i8] c" %s \00", align 1
@.str.44 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.45 = private unnamed_addr constant [11 x i8] c"plugin(%p)\00", align 1
@.str.46 = private unnamed_addr constant [11 x i8] c",$0x%x,$%d\00", align 1
@.str.47 = private unnamed_addr constant [4 x i8] c",%s\00", align 1
@.str.48 = private unnamed_addr constant [9 x i8] c"v%d,e%d,\00", align 1
@.str.49 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.50 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.51 = private unnamed_addr constant [5 x i8] c"%s%s\00", align 1
@cond_name = internal constant [14 x ptr] [ptr @.str.87, ptr @.str.88, ptr @.str.89, ptr @.str.90, ptr @.str.91, ptr @.str.92, ptr null, ptr null, ptr @.str.93, ptr @.str.94, ptr @.str.95, ptr @.str.96, ptr @.str.97, ptr @.str.98], align 16
@.str.52 = private unnamed_addr constant [8 x i8] c",$0x%lx\00", align 1
@alignment_name = internal constant [8 x ptr] [ptr @.str.99, ptr @.str.100, ptr @.str.101, ptr @.str.102, ptr @.str.103, ptr @.str.104, ptr @.str.105, ptr @.str.106], align 16
@ldst_name = internal constant [32 x ptr] [ptr @.str.107, ptr @.str.108, ptr @.str.109, ptr @.str.110, ptr @.str.111, ptr null, ptr null, ptr null, ptr @.str.112, ptr @.str.113, ptr @.str.114, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr @.str.115, ptr @.str.116, ptr @.str.117, ptr @.str.118, ptr null, ptr null, ptr null, ptr null, ptr @.str.119, ptr @.str.120, ptr null, ptr null, ptr null, ptr null, ptr null], align 16
@atom_name = internal constant [8 x ptr] [ptr @.str.50, ptr @.str.121, ptr @.str.122, ptr @.str.123, ptr @.str.124, ptr @.str.125, ptr null, ptr null], align 16
@.str.53 = private unnamed_addr constant [11 x i8] c",%s%s%s,%u\00", align 1
@.str.54 = private unnamed_addr constant [10 x i8] c",$0x%x,%u\00", align 1
@bswap_flag_name = internal constant [6 x [6 x i8]] [[6 x i8] zeroinitializer, [6 x i8] c"iz\00\00\00\00", [6 x i8] c"oz\00\00\00\00", [6 x i8] c"iz,oz\00", [6 x i8] c"os\00\00\00\00", [6 x i8] c"iz,os\00"], align 16
@.str.55 = private unnamed_addr constant [7 x i8] c"%s$L%d\00", align 1
@.str.56 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str.57 = private unnamed_addr constant [4 x i8] c"acq\00", align 1
@.str.58 = private unnamed_addr constant [4 x i8] c"rel\00", align 1
@.str.59 = private unnamed_addr constant [4 x i8] c"seq\00", align 1
@__func__.tcg_dump_ops = private unnamed_addr constant [13 x i8] c"tcg_dump_ops\00", align 1
@.str.60 = private unnamed_addr constant [3 x i8] c"rr\00", align 1
@.str.61 = private unnamed_addr constant [3 x i8] c"rw\00", align 1
@.str.62 = private unnamed_addr constant [3 x i8] c"wr\00", align 1
@.str.63 = private unnamed_addr constant [3 x i8] c"ww\00", align 1
@.str.64 = private unnamed_addr constant [6 x i8] c"rr+rw\00", align 1
@.str.65 = private unnamed_addr constant [6 x i8] c"rr+wr\00", align 1
@.str.66 = private unnamed_addr constant [6 x i8] c"rr+ww\00", align 1
@.str.67 = private unnamed_addr constant [6 x i8] c"rw+wr\00", align 1
@.str.68 = private unnamed_addr constant [6 x i8] c"rw+ww\00", align 1
@.str.69 = private unnamed_addr constant [6 x i8] c"wr+ww\00", align 1
@.str.70 = private unnamed_addr constant [9 x i8] c"rr+rw+wr\00", align 1
@.str.71 = private unnamed_addr constant [9 x i8] c"rr+rw+ww\00", align 1
@.str.72 = private unnamed_addr constant [9 x i8] c"rr+wr+ww\00", align 1
@.str.73 = private unnamed_addr constant [9 x i8] c"rw+wr+ww\00", align 1
@.str.74 = private unnamed_addr constant [4 x i8] c"all\00", align 1
@.str.75 = private unnamed_addr constant [8 x i8] c"%s%s:%s\00", align 1
@.str.76 = private unnamed_addr constant [9 x i8] c"%s$0x%lx\00", align 1
@.str.77 = private unnamed_addr constant [8 x i8] c"  sync:\00", align 1
@.str.78 = private unnamed_addr constant [4 x i8] c" %d\00", align 1
@.str.79 = private unnamed_addr constant [8 x i8] c"  dead:\00", align 1
@.str.80 = private unnamed_addr constant [8 x i8] c"  pref=\00", align 1
@.str.81 = private unnamed_addr constant [5 x i8] c"0x%x\00", align 1
@.str.82 = private unnamed_addr constant [6 x i8] c"loc%d\00", align 1
@.str.83 = private unnamed_addr constant [6 x i8] c"tmp%d\00", align 1
@.str.84 = private unnamed_addr constant [6 x i8] c"$0x%x\00", align 1
@.str.85 = private unnamed_addr constant [7 x i8] c"$0x%lx\00", align 1
@.str.86 = private unnamed_addr constant [10 x i8] c"v%d$0x%lx\00", align 1
@__func__.tcg_get_arg_str_ptr = private unnamed_addr constant [20 x i8] c"tcg_get_arg_str_ptr\00", align 1
@.str.87 = private unnamed_addr constant [6 x i8] c"never\00", align 1
@.str.88 = private unnamed_addr constant [7 x i8] c"always\00", align 1
@.str.89 = private unnamed_addr constant [3 x i8] c"lt\00", align 1
@.str.90 = private unnamed_addr constant [3 x i8] c"ge\00", align 1
@.str.91 = private unnamed_addr constant [4 x i8] c"ltu\00", align 1
@.str.92 = private unnamed_addr constant [4 x i8] c"geu\00", align 1
@.str.93 = private unnamed_addr constant [3 x i8] c"eq\00", align 1
@.str.94 = private unnamed_addr constant [3 x i8] c"ne\00", align 1
@.str.95 = private unnamed_addr constant [3 x i8] c"le\00", align 1
@.str.96 = private unnamed_addr constant [3 x i8] c"gt\00", align 1
@.str.97 = private unnamed_addr constant [4 x i8] c"leu\00", align 1
@.str.98 = private unnamed_addr constant [4 x i8] c"gtu\00", align 1
@.str.99 = private unnamed_addr constant [4 x i8] c"un+\00", align 1
@.str.100 = private unnamed_addr constant [5 x i8] c"al2+\00", align 1
@.str.101 = private unnamed_addr constant [5 x i8] c"al4+\00", align 1
@.str.102 = private unnamed_addr constant [5 x i8] c"al8+\00", align 1
@.str.103 = private unnamed_addr constant [6 x i8] c"al16+\00", align 1
@.str.104 = private unnamed_addr constant [6 x i8] c"al32+\00", align 1
@.str.105 = private unnamed_addr constant [6 x i8] c"al64+\00", align 1
@.str.106 = private unnamed_addr constant [4 x i8] c"al+\00", align 1
@.str.107 = private unnamed_addr constant [3 x i8] c"ub\00", align 1
@.str.108 = private unnamed_addr constant [5 x i8] c"leuw\00", align 1
@.str.109 = private unnamed_addr constant [5 x i8] c"leul\00", align 1
@.str.110 = private unnamed_addr constant [4 x i8] c"leq\00", align 1
@.str.111 = private unnamed_addr constant [4 x i8] c"leo\00", align 1
@.str.112 = private unnamed_addr constant [3 x i8] c"sb\00", align 1
@.str.113 = private unnamed_addr constant [5 x i8] c"lesw\00", align 1
@.str.114 = private unnamed_addr constant [5 x i8] c"lesl\00", align 1
@.str.115 = private unnamed_addr constant [5 x i8] c"beuw\00", align 1
@.str.116 = private unnamed_addr constant [5 x i8] c"beul\00", align 1
@.str.117 = private unnamed_addr constant [4 x i8] c"beq\00", align 1
@.str.118 = private unnamed_addr constant [4 x i8] c"beo\00", align 1
@.str.119 = private unnamed_addr constant [5 x i8] c"besw\00", align 1
@.str.120 = private unnamed_addr constant [5 x i8] c"besl\00", align 1
@.str.121 = private unnamed_addr constant [6 x i8] c"pair+\00", align 1
@.str.122 = private unnamed_addr constant [5 x i8] c"w16+\00", align 1
@.str.123 = private unnamed_addr constant [6 x i8] c"w16p+\00", align 1
@.str.124 = private unnamed_addr constant [5 x i8] c"sub+\00", align 1
@.str.125 = private unnamed_addr constant [6 x i8] c"noat+\00", align 1
@__func__.move_label_uses = private unnamed_addr constant [16 x i8] c"move_label_uses\00", align 1
@__func__.la_bb_sync = private unnamed_addr constant [11 x i8] c"la_bb_sync\00", align 1
@__func__.la_bb_end = private unnamed_addr constant [10 x i8] c"la_bb_end\00", align 1
@__func__.tcg_reg_alloc_start = private unnamed_addr constant [20 x i8] c"tcg_reg_alloc_start\00", align 1
@.str.126 = private unnamed_addr constant [20 x i8] c"!temp_readonly(ots)\00", align 1
@__PRETTY_FUNCTION__.tcg_reg_alloc_mov = private unnamed_addr constant [52 x i8] c"void tcg_reg_alloc_mov(TCGContext *, const TCGOp *)\00", align 1
@__func__.temp_load = private unnamed_addr constant [10 x i8] c"temp_load\00", align 1
@__func__.tcg_out_ld = private unnamed_addr constant [11 x i8] c"tcg_out_ld\00", align 1
@__func__.tcg_out_sib_offset = private unnamed_addr constant [19 x i8] c"tcg_out_sib_offset\00", align 1
@__func__.temp_allocate_frame = private unnamed_addr constant [20 x i8] c"temp_allocate_frame\00", align 1
@__func__.tcg_out_st = private unnamed_addr constant [11 x i8] c"tcg_out_st\00", align 1
@__func__.tcg_reg_alloc = private unnamed_addr constant [14 x i8] c"tcg_reg_alloc\00", align 1
@__func__.temp_sync = private unnamed_addr constant [10 x i8] c"temp_sync\00", align 1
@__func__.temp_free_or_dead = private unnamed_addr constant [18 x i8] c"temp_free_or_dead\00", align 1
@__func__.tcg_reg_alloc_dup = private unnamed_addr constant [18 x i8] c"tcg_reg_alloc_dup\00", align 1
@avx2_dup_insn = internal constant [4 x i32] [i32 1656, i32 1657, i32 1624, i32 1625], align 16
@__func__.tcg_out_dup_vec = private unnamed_addr constant [16 x i8] c"tcg_out_dup_vec\00", align 1
@__func__.tcg_out_dupm_vec = private unnamed_addr constant [17 x i8] c"tcg_out_dupm_vec\00", align 1
@__func__.tcg_reg_alloc_bb_end = private unnamed_addr constant [21 x i8] c"tcg_reg_alloc_bb_end\00", align 1
@__func__.tcg_reg_alloc_call = private unnamed_addr constant [19 x i8] c"tcg_reg_alloc_call\00", align 1
@.str.127 = private unnamed_addr constant [49 x i8] c"start >= 0 && length > 0 && length <= 64 - start\00", align 1
@__PRETTY_FUNCTION__.deposit64 = private unnamed_addr constant [49 x i8] c"uint64_t deposit64(uint64_t, int, int, uint64_t)\00", align 1
@__func__.tcg_reg_alloc_op = private unnamed_addr constant [17 x i8] c"tcg_reg_alloc_op\00", align 1
@__func__.tcg_reg_alloc_pair = private unnamed_addr constant [19 x i8] c"tcg_reg_alloc_pair\00", align 1
@__func__.tcg_reg_alloc_cbranch = private unnamed_addr constant [22 x i8] c"tcg_reg_alloc_cbranch\00", align 1
@tcg_out_vec_op.add_insn = internal constant [4 x i32] [i32 1532, i32 1533, i32 1534, i32 1492], align 16
@tcg_out_vec_op.ssadd_insn = internal constant [4 x i32] [i32 1516, i32 1517, i32 267, i32 267], align 16
@tcg_out_vec_op.usadd_insn = internal constant [4 x i32] [i32 1500, i32 1501, i32 267, i32 267], align 16
@tcg_out_vec_op.sub_insn = internal constant [4 x i32] [i32 1528, i32 1529, i32 1530, i32 1531], align 16
@tcg_out_vec_op.sssub_insn = internal constant [4 x i32] [i32 1512, i32 1513, i32 267, i32 267], align 16
@tcg_out_vec_op.ussub_insn = internal constant [4 x i32] [i32 1496, i32 1497, i32 267, i32 267], align 16
@tcg_out_vec_op.mul_insn = internal constant [4 x i32] [i32 267, i32 1493, i32 1600, i32 1054272], align 16
@tcg_out_vec_op.shift_imm_insn = internal constant [4 x i32] [i32 267, i32 1393, i32 1394, i32 1395], align 16
@tcg_out_vec_op.cmpeq_insn = internal constant [4 x i32] [i32 1396, i32 1397, i32 1398, i32 1577], align 16
@tcg_out_vec_op.cmpgt_insn = internal constant [4 x i32] [i32 1380, i32 1381, i32 1382, i32 1591], align 16
@tcg_out_vec_op.punpckl_insn = internal constant [4 x i32] [i32 1376, i32 1377, i32 1378, i32 1388], align 16
@tcg_out_vec_op.punpckh_insn = internal constant [4 x i32] [i32 1384, i32 1385, i32 1386, i32 1389], align 16
@tcg_out_vec_op.packss_insn = internal constant [4 x i32] [i32 1379, i32 1387, i32 267, i32 267], align 16
@tcg_out_vec_op.packus_insn = internal constant [4 x i32] [i32 1383, i32 1579, i32 267, i32 267], align 16
@tcg_out_vec_op.smin_insn = internal constant [4 x i32] [i32 1592, i32 1514, i32 1593, i32 1054265], align 16
@tcg_out_vec_op.smax_insn = internal constant [4 x i32] [i32 1596, i32 1518, i32 1597, i32 1054269], align 16
@tcg_out_vec_op.umin_insn = internal constant [4 x i32] [i32 1498, i32 1594, i32 1595, i32 1054267], align 16
@tcg_out_vec_op.umax_insn = internal constant [4 x i32] [i32 1502, i32 1598, i32 1599, i32 1054271], align 16
@tcg_out_vec_op.rotlv_insn = internal constant [4 x i32] [i32 267, i32 267, i32 1050133, i32 1054229], align 16
@tcg_out_vec_op.rotrv_insn = internal constant [4 x i32] [i32 267, i32 267, i32 1050132, i32 1054228], align 16
@tcg_out_vec_op.shlv_insn = internal constant [4 x i32] [i32 267, i32 1054226, i32 1607, i32 5703], align 16
@tcg_out_vec_op.shrv_insn = internal constant [4 x i32] [i32 267, i32 1054224, i32 1605, i32 5701], align 16
@tcg_out_vec_op.sarv_insn = internal constant [4 x i32] [i32 267, i32 1054225, i32 1606, i32 1054278], align 16
@tcg_out_vec_op.shls_insn = internal constant [4 x i32] [i32 267, i32 1521, i32 1522, i32 1523], align 16
@tcg_out_vec_op.shrs_insn = internal constant [4 x i32] [i32 267, i32 1489, i32 1490, i32 1491], align 16
@tcg_out_vec_op.sars_insn = internal constant [4 x i32] [i32 267, i32 1505, i32 1506, i32 1054178], align 16
@tcg_out_vec_op.vpshldi_insn = internal constant [4 x i32] [i32 267, i32 1119344, i32 1115249, i32 1119345], align 16
@tcg_out_vec_op.vpshldv_insn = internal constant [4 x i32] [i32 267, i32 1054320, i32 1050225, i32 1054321], align 16
@tcg_out_vec_op.vpshrdv_insn = internal constant [4 x i32] [i32 267, i32 1054322, i32 1050227, i32 1054323], align 16
@tcg_out_vec_op.abs_insn = internal constant [4 x i32] [i32 1564, i32 1565, i32 1566, i32 1054239], align 16
@__func__.tcg_out_vec_op = private unnamed_addr constant [15 x i8] c"tcg_out_vec_op\00", align 1
@__func__.tcg_out_op = private unnamed_addr constant [11 x i8] c"tcg_out_op\00", align 1
@tcg_cond_to_jcc = internal constant [14 x i8] c"\00\00\0C\0D\02\03\00\00\04\05\0E\0F\06\07", align 1
@__func__.tcg_out_qemu_ld_direct = private unnamed_addr constant [23 x i8] c"tcg_out_qemu_ld_direct\00", align 1
@__func__.tcg_out_qemu_st_direct = private unnamed_addr constant [23 x i8] c"tcg_out_qemu_st_direct\00", align 1
@ldst_helper_param = internal constant %struct.TCGLdstHelperParam { ptr @ldst_ra_gen, i32 0, [3 x i32] zeroinitializer }, align 8
@qemu_ld_helpers = internal constant [16 x ptr] [ptr @helper_ldub_mmu, ptr @helper_lduw_mmu, ptr @helper_ldul_mmu, ptr @helper_ldq_mmu, ptr @helper_ld16_mmu, ptr null, ptr null, ptr null, ptr @helper_ldsb_mmu, ptr @helper_ldsw_mmu, ptr @helper_ldsl_mmu, ptr null, ptr null, ptr null, ptr null, ptr null], align 16
@__func__.tcg_out_ld_helper_args = private unnamed_addr constant [23 x i8] c"tcg_out_ld_helper_args\00", align 1
@__func__.tcg_out_helper_add_mov = private unnamed_addr constant [23 x i8] c"tcg_out_helper_add_mov\00", align 1
@.str.128 = private unnamed_addr constant [26 x i8] c"dst_type == TCG_TYPE_I128\00", align 1
@__PRETTY_FUNCTION__.tcg_out_helper_add_mov = private unnamed_addr constant [114 x i8] c"unsigned int tcg_out_helper_add_mov(TCGMovExtend *, const TCGCallArgumentLoc *, TCGType, TCGType, TCGReg, TCGReg)\00", align 1
@__func__.tcg_out_helper_load_slots = private unnamed_addr constant [26 x i8] c"tcg_out_helper_load_slots\00", align 1
@__func__.tcg_out_movext3 = private unnamed_addr constant [16 x i8] c"tcg_out_movext3\00", align 1
@__func__.tcg_out_movext = private unnamed_addr constant [15 x i8] c"tcg_out_movext\00", align 1
@__const.tcg_out_helper_load_common_args.ptr_mov = private unnamed_addr constant %struct.TCGMovExtend { i32 0, i32 0, i32 1, i32 1, i32 3 }, align 4
@__func__.tcg_out_helper_load_common_args = private unnamed_addr constant [32 x i8] c"tcg_out_helper_load_common_args\00", align 1
@__func__.tcg_out_ld_helper_ret = private unnamed_addr constant [22 x i8] c"tcg_out_ld_helper_ret\00", align 1
@qemu_st_helpers = internal constant [8 x ptr] [ptr @helper_stb_mmu, ptr @helper_stw_mmu, ptr @helper_stl_mmu, ptr @helper_stq_mmu, ptr @helper_st16_mmu, ptr null, ptr null, ptr null], align 16
@__func__.tcg_out_st_helper_args = private unnamed_addr constant [23 x i8] c"tcg_out_st_helper_args\00", align 1
@tcg_register_jit_int.img_template = internal constant { { <{ i8, i8, i8, i8, i8, i8, i8, [9 x i8] }>, i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 }, %struct.elf64_phdr, [7 x %struct.elf64_shdr], [2 x %struct.elf64_sym], %struct.DebugInfo, [24 x i8], [80 x i8] } { { <{ i8, i8, i8, i8, i8, i8, i8, [9 x i8] }>, i16, i16, i32, i64, i64, i64, i32, i16, i16, i16, i16, i16, i16 } { <{ i8, i8, i8, i8, i8, i8, i8, [9 x i8] }> <{ i8 127, i8 69, i8 76, i8 70, i8 2, i8 1, i8 1, [9 x i8] zeroinitializer }>, i16 2, i16 62, i32 1, i64 0, i64 64, i64 120, i32 0, i16 64, i16 56, i16 1, i16 64, i16 7, i16 6 }, %struct.elf64_phdr { i32 1, i32 1, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0 }, [7 x %struct.elf64_shdr] [%struct.elf64_shdr zeroinitializer, %struct.elf64_shdr { i32 0, i32 8, i64 6, i64 0, i64 0, i64 0, i32 0, i32 0, i64 0, i64 0 }, %struct.elf64_shdr { i32 0, i32 1, i64 0, i64 0, i64 616, i64 64, i32 0, i32 0, i64 0, i64 0 }, %struct.elf64_shdr { i32 0, i32 1, i64 0, i64 0, i64 680, i64 24, i32 0, i32 0, i64 0, i64 0 }, %struct.elf64_shdr { i32 0, i32 1, i64 0, i64 0, i64 784, i64 0, i32 0, i32 0, i64 0, i64 0 }, %struct.elf64_shdr { i32 0, i32 2, i64 0, i64 0, i64 568, i64 48, i32 6, i32 1, i64 0, i64 24 }, %struct.elf64_shdr { i32 0, i32 3, i64 0, i64 0, i64 704, i64 80, i32 0, i32 0, i64 0, i64 0 }], [2 x %struct.elf64_sym] [%struct.elf64_sym zeroinitializer, %struct.elf64_sym { i32 0, i8 18, i8 0, i16 1, i64 0, i64 0 }], %struct.DebugInfo <{ i32 60, i16 2, i32 0, i8 8, i8 1, i16 -32767, i64 0, i64 0, i8 2, [16 x i8] c"code_gen_buffer\00", i64 0, i64 0, i8 0 }>, [24 x i8] c"\01\11\01\13\05\11\01\12\01\00\00\02.\00\03\08\11\01\12\01\00\00\00\00", [80 x i8] c"\00.text\00.debug_info\00.debug_abbrev\00.debug_frame\00.symtab\00.strtab\00code_gen_buffer\00\00\00" }, align 8
@tcg_register_jit_int.one_entry = internal global %struct.jit_code_entry zeroinitializer, align 8
@.str.129 = private unnamed_addr constant [6 x i8] c".text\00", align 1
@.str.130 = private unnamed_addr constant [12 x i8] c".debug_info\00", align 1
@.str.131 = private unnamed_addr constant [14 x i8] c".debug_abbrev\00", align 1
@.str.132 = private unnamed_addr constant [13 x i8] c".debug_frame\00", align 1
@.str.133 = private unnamed_addr constant [8 x i8] c".symtab\00", align 1
@.str.134 = private unnamed_addr constant [8 x i8] c".strtab\00", align 1
@.str.135 = private unnamed_addr constant [16 x i8] c"code_gen_buffer\00", align 1

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @gen_new_label() #0 {
entry:
  %s = alloca ptr, align 8
  %l = alloca ptr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %s, align 8
  %call = call ptr @tcg_malloc(i32 noundef 56)
  store ptr %call, ptr %l, align 8
  %2 = load ptr, ptr %l, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %2, i8 0, i64 56, i1 false)
  %3 = load ptr, ptr %s, align 8
  %nb_labels = getelementptr inbounds %struct.TCGContext, ptr %3, i32 0, i32 5
  %4 = load i32, ptr %nb_labels, align 8
  %inc = add i32 %4, 1
  store i32 %inc, ptr %nb_labels, align 8
  %conv = trunc i32 %4 to i16
  %5 = load ptr, ptr %l, align 8
  %id = getelementptr inbounds %struct.TCGLabel, ptr %5, i32 0, i32 2
  store i16 %conv, ptr %id, align 2
  br label %do.body

do.body:                                          ; preds = %entry
  %6 = load ptr, ptr %l, align 8
  %branches = getelementptr inbounds %struct.TCGLabel, ptr %6, i32 0, i32 4
  %sqh_first = getelementptr inbounds %struct.anon, ptr %branches, i32 0, i32 0
  store ptr null, ptr %sqh_first, align 8
  %7 = load ptr, ptr %l, align 8
  %branches1 = getelementptr inbounds %struct.TCGLabel, ptr %7, i32 0, i32 4
  %sqh_first2 = getelementptr inbounds %struct.anon, ptr %branches1, i32 0, i32 0
  %8 = load ptr, ptr %l, align 8
  %branches3 = getelementptr inbounds %struct.TCGLabel, ptr %8, i32 0, i32 4
  %sqh_last = getelementptr inbounds %struct.anon, ptr %branches3, i32 0, i32 1
  store ptr %sqh_first2, ptr %sqh_last, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body4

do.body4:                                         ; preds = %do.end
  %9 = load ptr, ptr %l, align 8
  %relocs = getelementptr inbounds %struct.TCGLabel, ptr %9, i32 0, i32 5
  %sqh_first5 = getelementptr inbounds %struct.anon.0, ptr %relocs, i32 0, i32 0
  store ptr null, ptr %sqh_first5, align 8
  %10 = load ptr, ptr %l, align 8
  %relocs6 = getelementptr inbounds %struct.TCGLabel, ptr %10, i32 0, i32 5
  %sqh_first7 = getelementptr inbounds %struct.anon.0, ptr %relocs6, i32 0, i32 0
  %11 = load ptr, ptr %l, align 8
  %relocs8 = getelementptr inbounds %struct.TCGLabel, ptr %11, i32 0, i32 5
  %sqh_last9 = getelementptr inbounds %struct.anon.0, ptr %relocs8, i32 0, i32 1
  store ptr %sqh_first7, ptr %sqh_last9, align 8
  br label %do.end10

do.end10:                                         ; preds = %do.body4
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %12 = load ptr, ptr %l, align 8
  %next = getelementptr inbounds %struct.TCGLabel, ptr %12, i32 0, i32 6
  %sqe_next = getelementptr inbounds %struct.anon.1, ptr %next, i32 0, i32 0
  store ptr null, ptr %sqe_next, align 8
  %13 = load ptr, ptr %l, align 8
  %14 = load ptr, ptr %s, align 8
  %labels = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 40
  %sqh_last12 = getelementptr inbounds %struct.anon.4, ptr %labels, i32 0, i32 1
  %15 = load ptr, ptr %sqh_last12, align 8
  store ptr %13, ptr %15, align 8
  %16 = load ptr, ptr %l, align 8
  %next13 = getelementptr inbounds %struct.TCGLabel, ptr %16, i32 0, i32 6
  %sqe_next14 = getelementptr inbounds %struct.anon.1, ptr %next13, i32 0, i32 0
  %17 = load ptr, ptr %s, align 8
  %labels15 = getelementptr inbounds %struct.TCGContext, ptr %17, i32 0, i32 40
  %sqh_last16 = getelementptr inbounds %struct.anon.4, ptr %labels15, i32 0, i32 1
  store ptr %sqe_next14, ptr %sqh_last16, align 8
  br label %do.end17

do.end17:                                         ; preds = %do.body11
  %18 = load ptr, ptr %l, align 8
  ret ptr %18
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare nonnull ptr @llvm.threadlocal.address.p0(ptr nonnull) #1

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_malloc(i32 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  %ptr = alloca ptr, align 8
  %ptr_end = alloca ptr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %s, align 8
  %2 = load i32, ptr %size.addr, align 4
  %add = add i32 %2, 8
  %sub = sub i32 %add, 1
  %div = sdiv i32 %sub, 8
  %mul = mul i32 %div, 8
  store i32 %mul, ptr %size.addr, align 4
  %3 = load ptr, ptr %s, align 8
  %pool_cur = getelementptr inbounds %struct.TCGContext, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %pool_cur, align 8
  store ptr %4, ptr %ptr, align 8
  %5 = load ptr, ptr %ptr, align 8
  %6 = load i32, ptr %size.addr, align 4
  %idx.ext = sext i32 %6 to i64
  %add.ptr = getelementptr i8, ptr %5, i64 %idx.ext
  store ptr %add.ptr, ptr %ptr_end, align 8
  %7 = load ptr, ptr %ptr_end, align 8
  %8 = load ptr, ptr %s, align 8
  %pool_end = getelementptr inbounds %struct.TCGContext, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %pool_end, align 8
  %cmp = icmp ugt ptr %7, %9
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %10 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %11 = load ptr, ptr %10, align 8
  %12 = load i32, ptr %size.addr, align 4
  %call = call ptr @tcg_malloc_internal(ptr noundef %11, i32 noundef %12)
  store ptr %call, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %13 = load ptr, ptr %ptr_end, align 8
  %14 = load ptr, ptr %s, align 8
  %pool_cur2 = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 0
  store ptr %13, ptr %pool_cur2, align 8
  %15 = load ptr, ptr %ptr, align 8
  store ptr %15, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %16 = load ptr, ptr %retval, align 8
  ret ptr %16
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @tcg_target_has_memory_bswap(i32 noundef %memop) #0 {
entry:
  %retval = alloca i1, align 1
  %memop.addr = alloca i32, align 4
  %aa = alloca %struct.TCGAtomAlign, align 4
  %tmp = alloca %struct.TCGAtomAlign, align 4
  store i32 %memop, ptr %memop.addr, align 4
  %0 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %0, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %memop.addr, align 4
  %and1 = and i32 %1, 7
  %cmp = icmp ult i32 %and1, 4
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %if.end
  %2 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %3 = load ptr, ptr %2, align 8
  %4 = load i32, ptr %memop.addr, align 4
  %call = call i64 @atom_and_align_for_opc(ptr noundef %3, i32 noundef %4, i32 noundef 0, i1 noundef zeroext true)
  store i64 %call, ptr %tmp, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %aa, ptr align 4 %tmp, i64 8, i1 false)
  %atom = getelementptr inbounds %struct.TCGAtomAlign, ptr %aa, i32 0, i32 0
  %5 = load i32, ptr %atom, align 4
  %cmp4 = icmp ult i32 %5, 4
  store i1 %cmp4, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %6 = load i1, ptr %retval, align 1
  ret i1 %6
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @atom_and_align_for_opc(ptr noundef %s, i32 noundef %opc, i32 noundef %host_atom, i1 noundef zeroext %allow_two_ops) #0 {
entry:
  %retval = alloca %struct.TCGAtomAlign, align 4
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %host_atom.addr = alloca i32, align 4
  %allow_two_ops.addr = alloca i8, align 1
  %align = alloca i32, align 4
  %size = alloca i32, align 4
  %half = alloca i32, align 4
  %atom = alloca i32, align 4
  %atmax = alloca i32, align 4
  %_a16 = alloca i32, align 4
  %_b17 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %_a18 = alloca i32, align 4
  %_b19 = alloca i32, align 4
  %tmp17 = alloca i32, align 4
  %_a20 = alloca i32, align 4
  %_b21 = alloca i32, align 4
  %tmp29 = alloca i32, align 4
  %_a22 = alloca i32, align 4
  %_b23 = alloca i32, align 4
  %tmp36 = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %host_atom, ptr %host_atom.addr, align 4
  %frombool = zext i1 %allow_two_ops to i8
  store i8 %frombool, ptr %allow_two_ops.addr, align 1
  %0 = load i32, ptr %opc.addr, align 4
  %call = call i32 @get_alignment_bits(i32 noundef %0)
  store i32 %call, ptr %align, align 4
  %1 = load i32, ptr %opc.addr, align 4
  %and = and i32 %1, 7
  store i32 %and, ptr %size, align 4
  %2 = load i32, ptr %size, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i32, ptr %size, align 4
  %sub = sub i32 %3, 1
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, ptr %half, align 4
  %4 = load i32, ptr %opc.addr, align 4
  %and1 = and i32 %4, 1792
  store i32 %and1, ptr %atom, align 4
  %5 = load i32, ptr %atom, align 4
  switch i32 %5, label %sw.default [
    i32 1280, label %sw.bb
    i32 0, label %sw.bb2
    i32 256, label %sw.bb3
    i32 512, label %sw.bb4
    i32 768, label %sw.bb13
    i32 1024, label %sw.bb24
  ]

sw.bb:                                            ; preds = %cond.end
  store i32 0, ptr %atmax, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %cond.end
  %6 = load i32, ptr %size, align 4
  store i32 %6, ptr %atmax, align 4
  br label %sw.epilog

sw.bb3:                                           ; preds = %cond.end
  %7 = load i32, ptr %half, align 4
  store i32 %7, ptr %atmax, align 4
  br label %sw.epilog

sw.bb4:                                           ; preds = %cond.end
  %8 = load i32, ptr %size, align 4
  store i32 %8, ptr %atmax, align 4
  %9 = load i32, ptr %size, align 4
  %cmp = icmp eq i32 %9, 4
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb4
  br label %if.end12

if.else:                                          ; preds = %sw.bb4
  %10 = load i32, ptr %host_atom.addr, align 4
  %cmp5 = icmp ne i32 %10, 512
  br i1 %cmp5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.else
  %11 = load i32, ptr %align, align 4
  store i32 %11, ptr %_a16, align 4
  %12 = load i32, ptr %size, align 4
  store i32 %12, ptr %_b17, align 4
  %13 = load i32, ptr %_a16, align 4
  %14 = load i32, ptr %_b17, align 4
  %cmp7 = icmp ugt i32 %13, %14
  br i1 %cmp7, label %cond.true8, label %cond.false9

cond.true8:                                       ; preds = %if.then6
  %15 = load i32, ptr %_a16, align 4
  br label %cond.end10

cond.false9:                                      ; preds = %if.then6
  %16 = load i32, ptr %_b17, align 4
  br label %cond.end10

cond.end10:                                       ; preds = %cond.false9, %cond.true8
  %cond11 = phi i32 [ %15, %cond.true8 ], [ %16, %cond.false9 ]
  store i32 %cond11, ptr %tmp, align 4
  %17 = load i32, ptr %tmp, align 4
  store i32 %17, ptr %align, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end10, %if.else
  br label %if.end12

if.end12:                                         ; preds = %if.end, %if.then
  br label %sw.epilog

sw.bb13:                                          ; preds = %cond.end
  %18 = load i32, ptr %size, align 4
  store i32 %18, ptr %atmax, align 4
  %19 = load i32, ptr %host_atom.addr, align 4
  %cmp14 = icmp ne i32 %19, 512
  br i1 %cmp14, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %sw.bb13
  %20 = load i8, ptr %allow_two_ops.addr, align 1
  %tobool15 = trunc i8 %20 to i1
  br i1 %tobool15, label %if.then16, label %if.end23

if.then16:                                        ; preds = %land.lhs.true
  %21 = load i32, ptr %align, align 4
  store i32 %21, ptr %_a18, align 4
  %22 = load i32, ptr %half, align 4
  store i32 %22, ptr %_b19, align 4
  %23 = load i32, ptr %_a18, align 4
  %24 = load i32, ptr %_b19, align 4
  %cmp18 = icmp ugt i32 %23, %24
  br i1 %cmp18, label %cond.true19, label %cond.false20

cond.true19:                                      ; preds = %if.then16
  %25 = load i32, ptr %_a18, align 4
  br label %cond.end21

cond.false20:                                     ; preds = %if.then16
  %26 = load i32, ptr %_b19, align 4
  br label %cond.end21

cond.end21:                                       ; preds = %cond.false20, %cond.true19
  %cond22 = phi i32 [ %25, %cond.true19 ], [ %26, %cond.false20 ]
  store i32 %cond22, ptr %tmp17, align 4
  %27 = load i32, ptr %tmp17, align 4
  store i32 %27, ptr %align, align 4
  br label %if.end23

if.end23:                                         ; preds = %cond.end21, %land.lhs.true, %sw.bb13
  br label %sw.epilog

sw.bb24:                                          ; preds = %cond.end
  %28 = load i32, ptr %size, align 4
  store i32 %28, ptr %atmax, align 4
  %29 = load i32, ptr %host_atom.addr, align 4
  %cmp25 = icmp ne i32 %29, 1024
  br i1 %cmp25, label %if.then26, label %if.end43

if.then26:                                        ; preds = %sw.bb24
  %30 = load i8, ptr %allow_two_ops.addr, align 1
  %tobool27 = trunc i8 %30 to i1
  br i1 %tobool27, label %if.then28, label %if.else35

if.then28:                                        ; preds = %if.then26
  %31 = load i32, ptr %align, align 4
  store i32 %31, ptr %_a20, align 4
  %32 = load i32, ptr %half, align 4
  store i32 %32, ptr %_b21, align 4
  %33 = load i32, ptr %_a20, align 4
  %34 = load i32, ptr %_b21, align 4
  %cmp30 = icmp ugt i32 %33, %34
  br i1 %cmp30, label %cond.true31, label %cond.false32

cond.true31:                                      ; preds = %if.then28
  %35 = load i32, ptr %_a20, align 4
  br label %cond.end33

cond.false32:                                     ; preds = %if.then28
  %36 = load i32, ptr %_b21, align 4
  br label %cond.end33

cond.end33:                                       ; preds = %cond.false32, %cond.true31
  %cond34 = phi i32 [ %35, %cond.true31 ], [ %36, %cond.false32 ]
  store i32 %cond34, ptr %tmp29, align 4
  %37 = load i32, ptr %tmp29, align 4
  store i32 %37, ptr %align, align 4
  br label %if.end42

if.else35:                                        ; preds = %if.then26
  %38 = load i32, ptr %align, align 4
  store i32 %38, ptr %_a22, align 4
  %39 = load i32, ptr %size, align 4
  store i32 %39, ptr %_b23, align 4
  %40 = load i32, ptr %_a22, align 4
  %41 = load i32, ptr %_b23, align 4
  %cmp37 = icmp ugt i32 %40, %41
  br i1 %cmp37, label %cond.true38, label %cond.false39

cond.true38:                                      ; preds = %if.else35
  %42 = load i32, ptr %_a22, align 4
  br label %cond.end40

cond.false39:                                     ; preds = %if.else35
  %43 = load i32, ptr %_b23, align 4
  br label %cond.end40

cond.end40:                                       ; preds = %cond.false39, %cond.true38
  %cond41 = phi i32 [ %42, %cond.true38 ], [ %43, %cond.false39 ]
  store i32 %cond41, ptr %tmp36, align 4
  %44 = load i32, ptr %tmp36, align 4
  store i32 %44, ptr %align, align 4
  br label %if.end42

if.end42:                                         ; preds = %cond.end40, %cond.end33
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %sw.bb24
  br label %sw.epilog

sw.default:                                       ; preds = %cond.end
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5495, ptr noundef @__func__.atom_and_align_for_opc, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %if.end43, %if.end23, %if.end12, %sw.bb3, %sw.bb2, %sw.bb
  %atom44 = getelementptr inbounds %struct.TCGAtomAlign, ptr %retval, i32 0, i32 0
  %45 = load i32, ptr %atmax, align 4
  store i32 %45, ptr %atom44, align 4
  %align45 = getelementptr inbounds %struct.TCGAtomAlign, ptr %retval, i32 0, i32 1
  %46 = load i32, ptr %align, align 4
  store i32 %46, ptr %align45, align 4
  %47 = load i64, ptr %retval, align 4
  ret i64 %47
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #3

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tb_target_set_jmp_target(ptr noundef %tb, i32 noundef %n, i64 noundef %jmp_rx, i64 noundef %jmp_rw) #0 {
entry:
  %tb.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %jmp_rx.addr = alloca i64, align 8
  %jmp_rw.addr = alloca i64, align 8
  %addr = alloca i64, align 8
  %.atomictmp = alloca i32, align 4
  store ptr %tb, ptr %tb.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  store i64 %jmp_rx, ptr %jmp_rx.addr, align 8
  store i64 %jmp_rw, ptr %jmp_rw.addr, align 8
  %0 = load ptr, ptr %tb.addr, align 8
  %jmp_target_addr = getelementptr inbounds %struct.TranslationBlock, ptr %0, i32 0, i32 11
  %1 = load i32, ptr %n.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr [2 x i64], ptr %jmp_target_addr, i64 0, i64 %idxprom
  %2 = load i64, ptr %arrayidx, align 8
  store i64 %2, ptr %addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %do.end, %do.body
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body1

do.body1:                                         ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 2429, ptr noundef @__func__.tb_target_set_jmp_target, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %3 = load i64, ptr %jmp_rw.addr, align 8
  %4 = inttoptr i64 %3 to ptr
  %5 = load i64, ptr %addr, align 8
  %6 = load i64, ptr %jmp_rx.addr, align 8
  %add = add i64 %6, 4
  %sub = sub i64 %5, %add
  %conv = trunc i64 %sub to i32
  store i32 %conv, ptr %.atomictmp, align 4
  %7 = load i32, ptr %.atomictmp, align 4
  store atomic i32 %7, ptr %4 monotonic, align 4
  br label %do.end2

do.end2:                                          ; preds = %while.end
  ret void
}

; Function Attrs: noreturn
declare void @g_assertion_message_expr(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) #4

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @tcg_can_emit_vec_op(i32 noundef %opc, i32 noundef %type, i32 noundef %vece) #0 {
entry:
  %retval = alloca i32, align 4
  %opc.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  %0 = load i32, ptr %opc.addr, align 4
  switch i32 %0, label %sw.default [
    i32 155, label %sw.bb
    i32 156, label %sw.bb
    i32 168, label %sw.bb
    i32 169, label %sw.bb
    i32 170, label %sw.bb
    i32 171, label %sw.bb
    i32 172, label %sw.bb
    i32 173, label %sw.bb
    i32 174, label %sw.bb
    i32 175, label %sw.bb
    i32 176, label %sw.bb
    i32 191, label %sw.bb
    i32 190, label %sw.bb1
    i32 192, label %sw.bb1
    i32 180, label %sw.bb2
    i32 177, label %sw.bb5
    i32 178, label %sw.bb5
    i32 179, label %sw.bb8
    i32 181, label %sw.bb19
    i32 182, label %sw.bb19
    i32 183, label %sw.bb21
    i32 184, label %sw.bb31
    i32 185, label %sw.bb35
    i32 186, label %sw.bb35
    i32 187, label %sw.bb52
    i32 188, label %sw.bb77
    i32 189, label %sw.bb77
    i32 157, label %sw.bb103
    i32 160, label %sw.bb119
    i32 161, label %sw.bb119
    i32 162, label %sw.bb119
    i32 163, label %sw.bb119
    i32 164, label %sw.bb122
    i32 166, label %sw.bb122
    i32 165, label %sw.bb122
    i32 167, label %sw.bb122
    i32 159, label %sw.bb122
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb1:                                           ; preds = %entry, %entry
  store i32 -1, ptr %retval, align 4
  br label %return

sw.bb2:                                           ; preds = %entry
  %1 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %1, 4096
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %sw.bb2
  %2 = load i32, ptr @cpuinfo, align 4
  %and3 = and i32 %2, 2048
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %3 = load i32, ptr %vece.addr, align 4
  %cmp = icmp uge i32 %3, 2
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %sw.bb2
  %4 = phi i1 [ false, %land.lhs.true ], [ false, %sw.bb2 ], [ %cmp, %land.rhs ]
  %cond = select i1 %4, i32 1, i32 -1
  store i32 %cond, ptr %retval, align 4
  br label %return

sw.bb5:                                           ; preds = %entry, %entry
  %5 = load i32, ptr %vece.addr, align 4
  %cmp6 = icmp eq i32 %5, 0
  %cond7 = select i1 %cmp6, i32 -1, i32 1
  store i32 %cond7, ptr %retval, align 4
  br label %return

sw.bb8:                                           ; preds = %entry
  %6 = load i32, ptr %vece.addr, align 4
  switch i32 %6, label %sw.epilog [
    i32 0, label %sw.bb9
    i32 1, label %sw.bb10
    i32 2, label %sw.bb10
    i32 3, label %sw.bb11
  ]

sw.bb9:                                           ; preds = %sw.bb8
  store i32 -1, ptr %retval, align 4
  br label %return

sw.bb10:                                          ; preds = %sw.bb8, %sw.bb8
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb11:                                          ; preds = %sw.bb8
  %7 = load i32, ptr @cpuinfo, align 4
  %and12 = and i32 %7, 4096
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %land.lhs.true14, label %if.end

land.lhs.true14:                                  ; preds = %sw.bb11
  %8 = load i32, ptr @cpuinfo, align 4
  %and15 = and i32 %8, 2048
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true14
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true14, %sw.bb11
  %9 = load i32, ptr %type.addr, align 4
  %cmp17 = icmp uge i32 %9, 5
  %cond18 = select i1 %cmp17, i32 -1, i32 0
  store i32 %cond18, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %sw.bb8
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb19:                                          ; preds = %entry, %entry
  %10 = load i32, ptr %vece.addr, align 4
  %cmp20 = icmp uge i32 %10, 1
  %conv = zext i1 %cmp20 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

sw.bb21:                                          ; preds = %entry
  %11 = load i32, ptr %vece.addr, align 4
  switch i32 %11, label %sw.epilog30 [
    i32 1, label %sw.bb22
    i32 2, label %sw.bb22
    i32 3, label %sw.bb23
  ]

sw.bb22:                                          ; preds = %sw.bb21, %sw.bb21
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb23:                                          ; preds = %sw.bb21
  %12 = load i32, ptr @cpuinfo, align 4
  %and24 = and i32 %12, 4096
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %land.rhs26, label %land.end29

land.rhs26:                                       ; preds = %sw.bb23
  %13 = load i32, ptr @cpuinfo, align 4
  %and27 = and i32 %13, 2048
  %tobool28 = icmp ne i32 %and27, 0
  br label %land.end29

land.end29:                                       ; preds = %land.rhs26, %sw.bb23
  %14 = phi i1 [ false, %sw.bb23 ], [ %tobool28, %land.rhs26 ]
  %land.ext = zext i1 %14 to i32
  store i32 %land.ext, ptr %retval, align 4
  br label %return

sw.epilog30:                                      ; preds = %sw.bb21
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb31:                                          ; preds = %entry
  %15 = load i32, ptr %vece.addr, align 4
  %cmp32 = icmp uge i32 %15, 1
  %cond34 = select i1 %cmp32, i32 -1, i32 0
  store i32 %cond34, ptr %retval, align 4
  br label %return

sw.bb35:                                          ; preds = %entry, %entry
  %16 = load i32, ptr %vece.addr, align 4
  switch i32 %16, label %sw.epilog51 [
    i32 1, label %sw.bb36
    i32 2, label %sw.bb49
    i32 3, label %sw.bb49
  ]

sw.bb36:                                          ; preds = %sw.bb35
  %17 = load i32, ptr @cpuinfo, align 4
  %and37 = and i32 %17, 8192
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %land.rhs39, label %land.end47

land.rhs39:                                       ; preds = %sw.bb36
  %18 = load i32, ptr @cpuinfo, align 4
  %and40 = and i32 %18, 4096
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %land.rhs42, label %land.end45

land.rhs42:                                       ; preds = %land.rhs39
  %19 = load i32, ptr @cpuinfo, align 4
  %and43 = and i32 %19, 2048
  %tobool44 = icmp ne i32 %and43, 0
  br label %land.end45

land.end45:                                       ; preds = %land.rhs42, %land.rhs39
  %20 = phi i1 [ false, %land.rhs39 ], [ %tobool44, %land.rhs42 ]
  br label %land.end47

land.end47:                                       ; preds = %land.end45, %sw.bb36
  %21 = phi i1 [ false, %sw.bb36 ], [ %20, %land.end45 ]
  %land.ext48 = zext i1 %21 to i32
  store i32 %land.ext48, ptr %retval, align 4
  br label %return

sw.bb49:                                          ; preds = %sw.bb35, %sw.bb35
  %22 = load i32, ptr @cpuinfo, align 4
  %and50 = and i32 %22, 1024
  store i32 %and50, ptr %retval, align 4
  br label %return

sw.epilog51:                                      ; preds = %sw.bb35
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb52:                                          ; preds = %entry
  %23 = load i32, ptr %vece.addr, align 4
  switch i32 %23, label %sw.epilog76 [
    i32 1, label %sw.bb53
    i32 2, label %sw.bb66
    i32 3, label %sw.bb68
  ]

sw.bb53:                                          ; preds = %sw.bb52
  %24 = load i32, ptr @cpuinfo, align 4
  %and54 = and i32 %24, 8192
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %land.rhs56, label %land.end64

land.rhs56:                                       ; preds = %sw.bb53
  %25 = load i32, ptr @cpuinfo, align 4
  %and57 = and i32 %25, 4096
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %land.rhs59, label %land.end62

land.rhs59:                                       ; preds = %land.rhs56
  %26 = load i32, ptr @cpuinfo, align 4
  %and60 = and i32 %26, 2048
  %tobool61 = icmp ne i32 %and60, 0
  br label %land.end62

land.end62:                                       ; preds = %land.rhs59, %land.rhs56
  %27 = phi i1 [ false, %land.rhs56 ], [ %tobool61, %land.rhs59 ]
  br label %land.end64

land.end64:                                       ; preds = %land.end62, %sw.bb53
  %28 = phi i1 [ false, %sw.bb53 ], [ %27, %land.end62 ]
  %land.ext65 = zext i1 %28 to i32
  store i32 %land.ext65, ptr %retval, align 4
  br label %return

sw.bb66:                                          ; preds = %sw.bb52
  %29 = load i32, ptr @cpuinfo, align 4
  %and67 = and i32 %29, 1024
  store i32 %and67, ptr %retval, align 4
  br label %return

sw.bb68:                                          ; preds = %sw.bb52
  %30 = load i32, ptr @cpuinfo, align 4
  %and69 = and i32 %30, 4096
  %tobool70 = icmp ne i32 %and69, 0
  br i1 %tobool70, label %land.rhs71, label %land.end74

land.rhs71:                                       ; preds = %sw.bb68
  %31 = load i32, ptr @cpuinfo, align 4
  %and72 = and i32 %31, 2048
  %tobool73 = icmp ne i32 %and72, 0
  br label %land.end74

land.end74:                                       ; preds = %land.rhs71, %sw.bb68
  %32 = phi i1 [ false, %sw.bb68 ], [ %tobool73, %land.rhs71 ]
  %land.ext75 = zext i1 %32 to i32
  store i32 %land.ext75, ptr %retval, align 4
  br label %return

sw.epilog76:                                      ; preds = %sw.bb52
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb77:                                          ; preds = %entry, %entry
  %33 = load i32, ptr %vece.addr, align 4
  switch i32 %33, label %sw.epilog102 [
    i32 1, label %sw.bb78
    i32 2, label %sw.bb92
    i32 3, label %sw.bb92
  ]

sw.bb78:                                          ; preds = %sw.bb77
  %34 = load i32, ptr @cpuinfo, align 4
  %and79 = and i32 %34, 32768
  %tobool80 = icmp ne i32 %and79, 0
  br i1 %tobool80, label %land.rhs81, label %land.end89

land.rhs81:                                       ; preds = %sw.bb78
  %35 = load i32, ptr @cpuinfo, align 4
  %and82 = and i32 %35, 4096
  %tobool83 = icmp ne i32 %and82, 0
  br i1 %tobool83, label %land.rhs84, label %land.end87

land.rhs84:                                       ; preds = %land.rhs81
  %36 = load i32, ptr @cpuinfo, align 4
  %and85 = and i32 %36, 2048
  %tobool86 = icmp ne i32 %and85, 0
  br label %land.end87

land.end87:                                       ; preds = %land.rhs84, %land.rhs81
  %37 = phi i1 [ false, %land.rhs81 ], [ %tobool86, %land.rhs84 ]
  br label %land.end89

land.end89:                                       ; preds = %land.end87, %sw.bb78
  %38 = phi i1 [ false, %sw.bb78 ], [ %37, %land.end87 ]
  %cond91 = select i1 %38, i32 -1, i32 0
  store i32 %cond91, ptr %retval, align 4
  br label %return

sw.bb92:                                          ; preds = %sw.bb77, %sw.bb77
  %39 = load i32, ptr @cpuinfo, align 4
  %and93 = and i32 %39, 4096
  %tobool94 = icmp ne i32 %and93, 0
  br i1 %tobool94, label %land.lhs.true95, label %cond.false

land.lhs.true95:                                  ; preds = %sw.bb92
  %40 = load i32, ptr @cpuinfo, align 4
  %and96 = and i32 %40, 2048
  %tobool97 = icmp ne i32 %and96, 0
  br i1 %tobool97, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true95
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true95, %sw.bb92
  %41 = load i32, ptr @cpuinfo, align 4
  %and98 = and i32 %41, 1024
  %tobool99 = icmp ne i32 %and98, 0
  %cond100 = select i1 %tobool99, i32 -1, i32 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond101 = phi i32 [ 1, %cond.true ], [ %cond100, %cond.false ]
  store i32 %cond101, ptr %retval, align 4
  br label %return

sw.epilog102:                                     ; preds = %sw.bb77
  store i32 0, ptr %retval, align 4
  br label %return

sw.bb103:                                         ; preds = %entry
  %42 = load i32, ptr %vece.addr, align 4
  switch i32 %42, label %sw.epilog118 [
    i32 0, label %sw.bb104
    i32 3, label %sw.bb105
  ]

sw.bb104:                                         ; preds = %sw.bb103
  store i32 -1, ptr %retval, align 4
  br label %return

sw.bb105:                                         ; preds = %sw.bb103
  %43 = load i32, ptr @cpuinfo, align 4
  %and106 = and i32 %43, 16384
  %tobool107 = icmp ne i32 %and106, 0
  br i1 %tobool107, label %land.rhs108, label %land.end116

land.rhs108:                                      ; preds = %sw.bb105
  %44 = load i32, ptr @cpuinfo, align 4
  %and109 = and i32 %44, 4096
  %tobool110 = icmp ne i32 %and109, 0
  br i1 %tobool110, label %land.rhs111, label %land.end114

land.rhs111:                                      ; preds = %land.rhs108
  %45 = load i32, ptr @cpuinfo, align 4
  %and112 = and i32 %45, 2048
  %tobool113 = icmp ne i32 %and112, 0
  br label %land.end114

land.end114:                                      ; preds = %land.rhs111, %land.rhs108
  %46 = phi i1 [ false, %land.rhs108 ], [ %tobool113, %land.rhs111 ]
  br label %land.end116

land.end116:                                      ; preds = %land.end114, %sw.bb105
  %47 = phi i1 [ false, %sw.bb105 ], [ %46, %land.end114 ]
  %land.ext117 = zext i1 %47 to i32
  store i32 %land.ext117, ptr %retval, align 4
  br label %return

sw.epilog118:                                     ; preds = %sw.bb103
  store i32 1, ptr %retval, align 4
  br label %return

sw.bb119:                                         ; preds = %entry, %entry, %entry, %entry
  %48 = load i32, ptr %vece.addr, align 4
  %cmp120 = icmp ule i32 %48, 1
  %conv121 = zext i1 %cmp120 to i32
  store i32 %conv121, ptr %retval, align 4
  br label %return

sw.bb122:                                         ; preds = %entry, %entry, %entry, %entry, %entry
  %49 = load i32, ptr %vece.addr, align 4
  %cmp123 = icmp ule i32 %49, 2
  br i1 %cmp123, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %sw.bb122
  %50 = load i32, ptr @cpuinfo, align 4
  %and125 = and i32 %50, 4096
  %tobool126 = icmp ne i32 %and125, 0
  br i1 %tobool126, label %land.rhs127, label %land.end130

land.rhs127:                                      ; preds = %lor.rhs
  %51 = load i32, ptr @cpuinfo, align 4
  %and128 = and i32 %51, 2048
  %tobool129 = icmp ne i32 %and128, 0
  br label %land.end130

land.end130:                                      ; preds = %land.rhs127, %lor.rhs
  %52 = phi i1 [ false, %lor.rhs ], [ %tobool129, %land.rhs127 ]
  br label %lor.end

lor.end:                                          ; preds = %land.end130, %sw.bb122
  %53 = phi i1 [ true, %sw.bb122 ], [ %52, %land.end130 ]
  %lor.ext = zext i1 %53 to i32
  store i32 %lor.ext, ptr %retval, align 4
  br label %return

sw.default:                                       ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %sw.default, %lor.end, %sw.bb119, %sw.epilog118, %land.end116, %sw.bb104, %sw.epilog102, %cond.end, %land.end89, %sw.epilog76, %land.end74, %sw.bb66, %land.end64, %sw.epilog51, %sw.bb49, %land.end47, %sw.bb31, %sw.epilog30, %land.end29, %sw.bb22, %sw.bb19, %sw.epilog, %if.end, %if.then, %sw.bb10, %sw.bb9, %sw.bb5, %land.end, %sw.bb1, %sw.bb
  %54 = load i32, ptr %retval, align 4
  ret i32 %54
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_expand_vec_op(i32 noundef %opc, i32 noundef %type, i32 noundef %vece, i64 noundef %a0, ...) #0 {
entry:
  %opc.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %a0.addr = alloca i64, align 8
  %va = alloca [1 x %struct.__va_list_tag], align 16
  %a2 = alloca i64, align 8
  %v0 = alloca ptr, align 8
  %v1 = alloca ptr, align 8
  %v2 = alloca ptr, align 8
  %v3 = alloca ptr, align 8
  %v4 = alloca ptr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store i64 %a0, ptr %a0.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %va, i64 0, i64 0
  call void @llvm.va_start(ptr %arraydecay)
  %0 = load i64, ptr %a0.addr, align 8
  %call = call ptr @arg_temp(i64 noundef %0)
  %call1 = call ptr @temp_tcgv_vec(ptr noundef %call)
  store ptr %call1, ptr %v0, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %va, i64 0, i64 0
  %gp_offset_p = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay2, i32 0, i32 0
  %gp_offset = load i32, ptr %gp_offset_p, align 16
  %fits_in_gp = icmp ule i32 %gp_offset, 40
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %entry
  %1 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay2, i32 0, i32 3
  %reg_save_area = load ptr, ptr %1, align 16
  %2 = getelementptr i8, ptr %reg_save_area, i32 %gp_offset
  %3 = add i32 %gp_offset, 8
  store i32 %3, ptr %gp_offset_p, align 16
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %entry
  %overflow_arg_area_p = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay2, i32 0, i32 2
  %overflow_arg_area = load ptr, ptr %overflow_arg_area_p, align 8
  %overflow_arg_area.next = getelementptr i8, ptr %overflow_arg_area, i32 8
  store ptr %overflow_arg_area.next, ptr %overflow_arg_area_p, align 8
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi ptr [ %2, %vaarg.in_reg ], [ %overflow_arg_area, %vaarg.in_mem ]
  %4 = load i64, ptr %vaarg.addr, align 8
  %call3 = call ptr @arg_temp(i64 noundef %4)
  %call4 = call ptr @temp_tcgv_vec(ptr noundef %call3)
  store ptr %call4, ptr %v1, align 8
  %arraydecay5 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %va, i64 0, i64 0
  %gp_offset_p6 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay5, i32 0, i32 0
  %gp_offset7 = load i32, ptr %gp_offset_p6, align 16
  %fits_in_gp8 = icmp ule i32 %gp_offset7, 40
  br i1 %fits_in_gp8, label %vaarg.in_reg9, label %vaarg.in_mem11

vaarg.in_reg9:                                    ; preds = %vaarg.end
  %5 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay5, i32 0, i32 3
  %reg_save_area10 = load ptr, ptr %5, align 16
  %6 = getelementptr i8, ptr %reg_save_area10, i32 %gp_offset7
  %7 = add i32 %gp_offset7, 8
  store i32 %7, ptr %gp_offset_p6, align 16
  br label %vaarg.end15

vaarg.in_mem11:                                   ; preds = %vaarg.end
  %overflow_arg_area_p12 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay5, i32 0, i32 2
  %overflow_arg_area13 = load ptr, ptr %overflow_arg_area_p12, align 8
  %overflow_arg_area.next14 = getelementptr i8, ptr %overflow_arg_area13, i32 8
  store ptr %overflow_arg_area.next14, ptr %overflow_arg_area_p12, align 8
  br label %vaarg.end15

vaarg.end15:                                      ; preds = %vaarg.in_mem11, %vaarg.in_reg9
  %vaarg.addr16 = phi ptr [ %6, %vaarg.in_reg9 ], [ %overflow_arg_area13, %vaarg.in_mem11 ]
  %8 = load i64, ptr %vaarg.addr16, align 8
  store i64 %8, ptr %a2, align 8
  %9 = load i32, ptr %opc.addr, align 4
  switch i32 %9, label %sw.default [
    i32 177, label %sw.bb
    i32 178, label %sw.bb
    i32 179, label %sw.bb17
    i32 180, label %sw.bb18
    i32 184, label %sw.bb19
    i32 188, label %sw.bb22
    i32 189, label %sw.bb25
    i32 157, label %sw.bb28
    i32 190, label %sw.bb31
    i32 192, label %sw.bb46
  ]

sw.bb:                                            ; preds = %vaarg.end15, %vaarg.end15
  %10 = load i32, ptr %type.addr, align 4
  %11 = load i32, ptr %vece.addr, align 4
  %12 = load i32, ptr %opc.addr, align 4
  %13 = load ptr, ptr %v0, align 8
  %14 = load ptr, ptr %v1, align 8
  %15 = load i64, ptr %a2, align 8
  call void @expand_vec_shi(i32 noundef %10, i32 noundef %11, i32 noundef %12, ptr noundef %13, ptr noundef %14, i64 noundef %15)
  br label %sw.epilog

sw.bb17:                                          ; preds = %vaarg.end15
  %16 = load i32, ptr %type.addr, align 4
  %17 = load i32, ptr %vece.addr, align 4
  %18 = load ptr, ptr %v0, align 8
  %19 = load ptr, ptr %v1, align 8
  %20 = load i64, ptr %a2, align 8
  call void @expand_vec_sari(i32 noundef %16, i32 noundef %17, ptr noundef %18, ptr noundef %19, i64 noundef %20)
  br label %sw.epilog

sw.bb18:                                          ; preds = %vaarg.end15
  %21 = load i32, ptr %type.addr, align 4
  %22 = load i32, ptr %vece.addr, align 4
  %23 = load ptr, ptr %v0, align 8
  %24 = load ptr, ptr %v1, align 8
  %25 = load i64, ptr %a2, align 8
  call void @expand_vec_rotli(i32 noundef %21, i32 noundef %22, ptr noundef %23, ptr noundef %24, i64 noundef %25)
  br label %sw.epilog

sw.bb19:                                          ; preds = %vaarg.end15
  %26 = load i32, ptr %type.addr, align 4
  %27 = load i32, ptr %vece.addr, align 4
  %28 = load ptr, ptr %v0, align 8
  %29 = load ptr, ptr %v1, align 8
  %30 = load i64, ptr %a2, align 8
  %call20 = call ptr @arg_temp(i64 noundef %30)
  %call21 = call ptr @temp_tcgv_i32(ptr noundef %call20)
  call void @expand_vec_rotls(i32 noundef %26, i32 noundef %27, ptr noundef %28, ptr noundef %29, ptr noundef %call21)
  br label %sw.epilog

sw.bb22:                                          ; preds = %vaarg.end15
  %31 = load i64, ptr %a2, align 8
  %call23 = call ptr @arg_temp(i64 noundef %31)
  %call24 = call ptr @temp_tcgv_vec(ptr noundef %call23)
  store ptr %call24, ptr %v2, align 8
  %32 = load i32, ptr %type.addr, align 4
  %33 = load i32, ptr %vece.addr, align 4
  %34 = load ptr, ptr %v0, align 8
  %35 = load ptr, ptr %v1, align 8
  %36 = load ptr, ptr %v2, align 8
  call void @expand_vec_rotv(i32 noundef %32, i32 noundef %33, ptr noundef %34, ptr noundef %35, ptr noundef %36, i1 noundef zeroext false)
  br label %sw.epilog

sw.bb25:                                          ; preds = %vaarg.end15
  %37 = load i64, ptr %a2, align 8
  %call26 = call ptr @arg_temp(i64 noundef %37)
  %call27 = call ptr @temp_tcgv_vec(ptr noundef %call26)
  store ptr %call27, ptr %v2, align 8
  %38 = load i32, ptr %type.addr, align 4
  %39 = load i32, ptr %vece.addr, align 4
  %40 = load ptr, ptr %v0, align 8
  %41 = load ptr, ptr %v1, align 8
  %42 = load ptr, ptr %v2, align 8
  call void @expand_vec_rotv(i32 noundef %38, i32 noundef %39, ptr noundef %40, ptr noundef %41, ptr noundef %42, i1 noundef zeroext true)
  br label %sw.epilog

sw.bb28:                                          ; preds = %vaarg.end15
  %43 = load i64, ptr %a2, align 8
  %call29 = call ptr @arg_temp(i64 noundef %43)
  %call30 = call ptr @temp_tcgv_vec(ptr noundef %call29)
  store ptr %call30, ptr %v2, align 8
  %44 = load i32, ptr %type.addr, align 4
  %45 = load i32, ptr %vece.addr, align 4
  %46 = load ptr, ptr %v0, align 8
  %47 = load ptr, ptr %v1, align 8
  %48 = load ptr, ptr %v2, align 8
  call void @expand_vec_mul(i32 noundef %44, i32 noundef %45, ptr noundef %46, ptr noundef %47, ptr noundef %48)
  br label %sw.epilog

sw.bb31:                                          ; preds = %vaarg.end15
  %49 = load i64, ptr %a2, align 8
  %call32 = call ptr @arg_temp(i64 noundef %49)
  %call33 = call ptr @temp_tcgv_vec(ptr noundef %call32)
  store ptr %call33, ptr %v2, align 8
  %50 = load i32, ptr %type.addr, align 4
  %51 = load i32, ptr %vece.addr, align 4
  %52 = load ptr, ptr %v0, align 8
  %53 = load ptr, ptr %v1, align 8
  %54 = load ptr, ptr %v2, align 8
  %arraydecay34 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %va, i64 0, i64 0
  %gp_offset_p35 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay34, i32 0, i32 0
  %gp_offset36 = load i32, ptr %gp_offset_p35, align 16
  %fits_in_gp37 = icmp ule i32 %gp_offset36, 40
  br i1 %fits_in_gp37, label %vaarg.in_reg38, label %vaarg.in_mem40

vaarg.in_reg38:                                   ; preds = %sw.bb31
  %55 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay34, i32 0, i32 3
  %reg_save_area39 = load ptr, ptr %55, align 16
  %56 = getelementptr i8, ptr %reg_save_area39, i32 %gp_offset36
  %57 = add i32 %gp_offset36, 8
  store i32 %57, ptr %gp_offset_p35, align 16
  br label %vaarg.end44

vaarg.in_mem40:                                   ; preds = %sw.bb31
  %overflow_arg_area_p41 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay34, i32 0, i32 2
  %overflow_arg_area42 = load ptr, ptr %overflow_arg_area_p41, align 8
  %overflow_arg_area.next43 = getelementptr i8, ptr %overflow_arg_area42, i32 8
  store ptr %overflow_arg_area.next43, ptr %overflow_arg_area_p41, align 8
  br label %vaarg.end44

vaarg.end44:                                      ; preds = %vaarg.in_mem40, %vaarg.in_reg38
  %vaarg.addr45 = phi ptr [ %56, %vaarg.in_reg38 ], [ %overflow_arg_area42, %vaarg.in_mem40 ]
  %58 = load i64, ptr %vaarg.addr45, align 8
  %conv = trunc i64 %58 to i32
  call void @expand_vec_cmp(i32 noundef %50, i32 noundef %51, ptr noundef %52, ptr noundef %53, ptr noundef %54, i32 noundef %conv)
  br label %sw.epilog

sw.bb46:                                          ; preds = %vaarg.end15
  %59 = load i64, ptr %a2, align 8
  %call47 = call ptr @arg_temp(i64 noundef %59)
  %call48 = call ptr @temp_tcgv_vec(ptr noundef %call47)
  store ptr %call48, ptr %v2, align 8
  %arraydecay49 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %va, i64 0, i64 0
  %gp_offset_p50 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay49, i32 0, i32 0
  %gp_offset51 = load i32, ptr %gp_offset_p50, align 16
  %fits_in_gp52 = icmp ule i32 %gp_offset51, 40
  br i1 %fits_in_gp52, label %vaarg.in_reg53, label %vaarg.in_mem55

vaarg.in_reg53:                                   ; preds = %sw.bb46
  %60 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay49, i32 0, i32 3
  %reg_save_area54 = load ptr, ptr %60, align 16
  %61 = getelementptr i8, ptr %reg_save_area54, i32 %gp_offset51
  %62 = add i32 %gp_offset51, 8
  store i32 %62, ptr %gp_offset_p50, align 16
  br label %vaarg.end59

vaarg.in_mem55:                                   ; preds = %sw.bb46
  %overflow_arg_area_p56 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay49, i32 0, i32 2
  %overflow_arg_area57 = load ptr, ptr %overflow_arg_area_p56, align 8
  %overflow_arg_area.next58 = getelementptr i8, ptr %overflow_arg_area57, i32 8
  store ptr %overflow_arg_area.next58, ptr %overflow_arg_area_p56, align 8
  br label %vaarg.end59

vaarg.end59:                                      ; preds = %vaarg.in_mem55, %vaarg.in_reg53
  %vaarg.addr60 = phi ptr [ %61, %vaarg.in_reg53 ], [ %overflow_arg_area57, %vaarg.in_mem55 ]
  %63 = load i64, ptr %vaarg.addr60, align 8
  %call61 = call ptr @arg_temp(i64 noundef %63)
  %call62 = call ptr @temp_tcgv_vec(ptr noundef %call61)
  store ptr %call62, ptr %v3, align 8
  %arraydecay63 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %va, i64 0, i64 0
  %gp_offset_p64 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay63, i32 0, i32 0
  %gp_offset65 = load i32, ptr %gp_offset_p64, align 16
  %fits_in_gp66 = icmp ule i32 %gp_offset65, 40
  br i1 %fits_in_gp66, label %vaarg.in_reg67, label %vaarg.in_mem69

vaarg.in_reg67:                                   ; preds = %vaarg.end59
  %64 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay63, i32 0, i32 3
  %reg_save_area68 = load ptr, ptr %64, align 16
  %65 = getelementptr i8, ptr %reg_save_area68, i32 %gp_offset65
  %66 = add i32 %gp_offset65, 8
  store i32 %66, ptr %gp_offset_p64, align 16
  br label %vaarg.end73

vaarg.in_mem69:                                   ; preds = %vaarg.end59
  %overflow_arg_area_p70 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay63, i32 0, i32 2
  %overflow_arg_area71 = load ptr, ptr %overflow_arg_area_p70, align 8
  %overflow_arg_area.next72 = getelementptr i8, ptr %overflow_arg_area71, i32 8
  store ptr %overflow_arg_area.next72, ptr %overflow_arg_area_p70, align 8
  br label %vaarg.end73

vaarg.end73:                                      ; preds = %vaarg.in_mem69, %vaarg.in_reg67
  %vaarg.addr74 = phi ptr [ %65, %vaarg.in_reg67 ], [ %overflow_arg_area71, %vaarg.in_mem69 ]
  %67 = load i64, ptr %vaarg.addr74, align 8
  %call75 = call ptr @arg_temp(i64 noundef %67)
  %call76 = call ptr @temp_tcgv_vec(ptr noundef %call75)
  store ptr %call76, ptr %v4, align 8
  %68 = load i32, ptr %type.addr, align 4
  %69 = load i32, ptr %vece.addr, align 4
  %70 = load ptr, ptr %v0, align 8
  %71 = load ptr, ptr %v1, align 8
  %72 = load ptr, ptr %v2, align 8
  %73 = load ptr, ptr %v3, align 8
  %74 = load ptr, ptr %v4, align 8
  %arraydecay77 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %va, i64 0, i64 0
  %gp_offset_p78 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay77, i32 0, i32 0
  %gp_offset79 = load i32, ptr %gp_offset_p78, align 16
  %fits_in_gp80 = icmp ule i32 %gp_offset79, 40
  br i1 %fits_in_gp80, label %vaarg.in_reg81, label %vaarg.in_mem83

vaarg.in_reg81:                                   ; preds = %vaarg.end73
  %75 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay77, i32 0, i32 3
  %reg_save_area82 = load ptr, ptr %75, align 16
  %76 = getelementptr i8, ptr %reg_save_area82, i32 %gp_offset79
  %77 = add i32 %gp_offset79, 8
  store i32 %77, ptr %gp_offset_p78, align 16
  br label %vaarg.end87

vaarg.in_mem83:                                   ; preds = %vaarg.end73
  %overflow_arg_area_p84 = getelementptr inbounds %struct.__va_list_tag, ptr %arraydecay77, i32 0, i32 2
  %overflow_arg_area85 = load ptr, ptr %overflow_arg_area_p84, align 8
  %overflow_arg_area.next86 = getelementptr i8, ptr %overflow_arg_area85, i32 8
  store ptr %overflow_arg_area.next86, ptr %overflow_arg_area_p84, align 8
  br label %vaarg.end87

vaarg.end87:                                      ; preds = %vaarg.in_mem83, %vaarg.in_reg81
  %vaarg.addr88 = phi ptr [ %76, %vaarg.in_reg81 ], [ %overflow_arg_area85, %vaarg.in_mem83 ]
  %78 = load i64, ptr %vaarg.addr88, align 8
  %conv89 = trunc i64 %78 to i32
  call void @expand_vec_cmpsel(i32 noundef %68, i32 noundef %69, ptr noundef %70, ptr noundef %71, ptr noundef %72, ptr noundef %73, ptr noundef %74, i32 noundef %conv89)
  br label %sw.epilog

sw.default:                                       ; preds = %vaarg.end15
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %vaarg.end87, %vaarg.end44, %sw.bb28, %sw.bb25, %sw.bb22, %sw.bb19, %sw.bb18, %sw.bb17, %sw.bb
  %arraydecay90 = getelementptr inbounds [1 x %struct.__va_list_tag], ptr %va, i64 0, i64 0
  call void @llvm.va_end(ptr %arraydecay90)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_start(ptr) #5

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @temp_tcgv_vec(ptr noundef %t) #0 {
entry:
  %t.addr = alloca ptr, align 8
  store ptr %t, ptr %t.addr, align 8
  %0 = load ptr, ptr %t.addr, align 8
  %call = call ptr @temp_tcgv_i32(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @arg_temp(i64 noundef %a) #0 {
entry:
  %a.addr = alloca i64, align 8
  store i64 %a, ptr %a.addr, align 8
  %0 = load i64, ptr %a.addr, align 8
  %1 = inttoptr i64 %0 to ptr
  ret ptr %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @expand_vec_shi(i32 noundef %type, i32 noundef %vece, i32 noundef %opc, ptr noundef %v0, ptr noundef %v1, i64 noundef %imm) #0 {
entry:
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %opc.addr = alloca i32, align 4
  %v0.addr = alloca ptr, align 8
  %v1.addr = alloca ptr, align 8
  %imm.addr = alloca i64, align 8
  %t1 = alloca ptr, align 8
  %t2 = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store i32 %opc, ptr %opc.addr, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store i64 %imm, ptr %imm.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i32, ptr %vece.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load i32, ptr %type.addr, align 4
  %call = call ptr @tcg_temp_new_vec(i32 noundef %1)
  store ptr %call, ptr %t1, align 8
  %2 = load i32, ptr %type.addr, align 4
  %call1 = call ptr @tcg_temp_new_vec(i32 noundef %2)
  store ptr %call1, ptr %t2, align 8
  %3 = load i32, ptr %type.addr, align 4
  %4 = load ptr, ptr %t1, align 8
  %call2 = call i64 @tcgv_vec_arg(ptr noundef %4)
  %5 = load ptr, ptr %v1.addr, align 8
  %call3 = call i64 @tcgv_vec_arg(ptr noundef %5)
  %6 = load ptr, ptr %v1.addr, align 8
  %call4 = call i64 @tcgv_vec_arg(ptr noundef %6)
  call void @vec_gen_3(i32 noundef 201, i32 noundef %3, i32 noundef 0, i64 noundef %call2, i64 noundef %call3, i64 noundef %call4)
  %7 = load i32, ptr %type.addr, align 4
  %8 = load ptr, ptr %t2, align 8
  %call5 = call i64 @tcgv_vec_arg(ptr noundef %8)
  %9 = load ptr, ptr %v1.addr, align 8
  %call6 = call i64 @tcgv_vec_arg(ptr noundef %9)
  %10 = load ptr, ptr %v1.addr, align 8
  %call7 = call i64 @tcgv_vec_arg(ptr noundef %10)
  call void @vec_gen_3(i32 noundef 202, i32 noundef %7, i32 noundef 0, i64 noundef %call5, i64 noundef %call6, i64 noundef %call7)
  %11 = load i32, ptr %opc.addr, align 4
  %cmp8 = icmp ne i32 %11, 180
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %do.end
  %12 = load i64, ptr %imm.addr, align 8
  %add = add i64 %12, 8
  store i64 %add, ptr %imm.addr, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %do.end
  %13 = load i32, ptr %opc.addr, align 4
  %cmp11 = icmp eq i32 %13, 178
  br i1 %cmp11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end10
  %14 = load ptr, ptr %t1, align 8
  %15 = load ptr, ptr %t1, align 8
  %16 = load i64, ptr %imm.addr, align 8
  call void @tcg_gen_shri_vec(i32 noundef 1, ptr noundef %14, ptr noundef %15, i64 noundef %16)
  %17 = load ptr, ptr %t2, align 8
  %18 = load ptr, ptr %t2, align 8
  %19 = load i64, ptr %imm.addr, align 8
  call void @tcg_gen_shri_vec(i32 noundef 1, ptr noundef %17, ptr noundef %18, i64 noundef %19)
  br label %if.end13

if.else:                                          ; preds = %if.end10
  %20 = load ptr, ptr %t1, align 8
  %21 = load ptr, ptr %t1, align 8
  %22 = load i64, ptr %imm.addr, align 8
  call void @tcg_gen_shli_vec(i32 noundef 1, ptr noundef %20, ptr noundef %21, i64 noundef %22)
  %23 = load ptr, ptr %t2, align 8
  %24 = load ptr, ptr %t2, align 8
  %25 = load i64, ptr %imm.addr, align 8
  call void @tcg_gen_shli_vec(i32 noundef 1, ptr noundef %23, ptr noundef %24, i64 noundef %25)
  %26 = load ptr, ptr %t1, align 8
  %27 = load ptr, ptr %t1, align 8
  call void @tcg_gen_shri_vec(i32 noundef 1, ptr noundef %26, ptr noundef %27, i64 noundef 8)
  %28 = load ptr, ptr %t2, align 8
  %29 = load ptr, ptr %t2, align 8
  call void @tcg_gen_shri_vec(i32 noundef 1, ptr noundef %28, ptr noundef %29, i64 noundef 8)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then12
  %30 = load i32, ptr %type.addr, align 4
  %31 = load ptr, ptr %v0.addr, align 8
  %call14 = call i64 @tcgv_vec_arg(ptr noundef %31)
  %32 = load ptr, ptr %t1, align 8
  %call15 = call i64 @tcgv_vec_arg(ptr noundef %32)
  %33 = load ptr, ptr %t2, align 8
  %call16 = call i64 @tcgv_vec_arg(ptr noundef %33)
  call void @vec_gen_3(i32 noundef 198, i32 noundef %30, i32 noundef 0, i64 noundef %call14, i64 noundef %call15, i64 noundef %call16)
  %34 = load ptr, ptr %t1, align 8
  call void @tcg_temp_free_vec(ptr noundef %34)
  %35 = load ptr, ptr %t2, align 8
  call void @tcg_temp_free_vec(ptr noundef %35)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @expand_vec_sari(i32 noundef %type, i32 noundef %vece, ptr noundef %v0, ptr noundef %v1, i64 noundef %imm) #0 {
entry:
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %v0.addr = alloca ptr, align 8
  %v1.addr = alloca ptr, align 8
  %imm.addr = alloca i64, align 8
  %t1 = alloca ptr, align 8
  %t2 = alloca ptr, align 8
  %_a10 = alloca i64, align 8
  %_b11 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store i64 %imm, ptr %imm.addr, align 8
  %0 = load i32, ptr %vece.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 3, label %sw.bb12
  ]

sw.bb:                                            ; preds = %entry
  %1 = load i32, ptr %type.addr, align 4
  %call = call ptr @tcg_temp_new_vec(i32 noundef %1)
  store ptr %call, ptr %t1, align 8
  %2 = load i32, ptr %type.addr, align 4
  %call1 = call ptr @tcg_temp_new_vec(i32 noundef %2)
  store ptr %call1, ptr %t2, align 8
  %3 = load i32, ptr %type.addr, align 4
  %4 = load ptr, ptr %t1, align 8
  %call2 = call i64 @tcgv_vec_arg(ptr noundef %4)
  %5 = load ptr, ptr %v1.addr, align 8
  %call3 = call i64 @tcgv_vec_arg(ptr noundef %5)
  %6 = load ptr, ptr %v1.addr, align 8
  %call4 = call i64 @tcgv_vec_arg(ptr noundef %6)
  call void @vec_gen_3(i32 noundef 201, i32 noundef %3, i32 noundef 0, i64 noundef %call2, i64 noundef %call3, i64 noundef %call4)
  %7 = load i32, ptr %type.addr, align 4
  %8 = load ptr, ptr %t2, align 8
  %call5 = call i64 @tcgv_vec_arg(ptr noundef %8)
  %9 = load ptr, ptr %v1.addr, align 8
  %call6 = call i64 @tcgv_vec_arg(ptr noundef %9)
  %10 = load ptr, ptr %v1.addr, align 8
  %call7 = call i64 @tcgv_vec_arg(ptr noundef %10)
  call void @vec_gen_3(i32 noundef 202, i32 noundef %7, i32 noundef 0, i64 noundef %call5, i64 noundef %call6, i64 noundef %call7)
  %11 = load ptr, ptr %t1, align 8
  %12 = load ptr, ptr %t1, align 8
  %13 = load i64, ptr %imm.addr, align 8
  %add = add i64 %13, 8
  call void @tcg_gen_sari_vec(i32 noundef 1, ptr noundef %11, ptr noundef %12, i64 noundef %add)
  %14 = load ptr, ptr %t2, align 8
  %15 = load ptr, ptr %t2, align 8
  %16 = load i64, ptr %imm.addr, align 8
  %add8 = add i64 %16, 8
  call void @tcg_gen_sari_vec(i32 noundef 1, ptr noundef %14, ptr noundef %15, i64 noundef %add8)
  %17 = load i32, ptr %type.addr, align 4
  %18 = load ptr, ptr %v0.addr, align 8
  %call9 = call i64 @tcgv_vec_arg(ptr noundef %18)
  %19 = load ptr, ptr %t1, align 8
  %call10 = call i64 @tcgv_vec_arg(ptr noundef %19)
  %20 = load ptr, ptr %t2, align 8
  %call11 = call i64 @tcgv_vec_arg(ptr noundef %20)
  call void @vec_gen_3(i32 noundef 197, i32 noundef %17, i32 noundef 0, i64 noundef %call9, i64 noundef %call10, i64 noundef %call11)
  %21 = load ptr, ptr %t1, align 8
  call void @tcg_temp_free_vec(ptr noundef %21)
  %22 = load ptr, ptr %t2, align 8
  call void @tcg_temp_free_vec(ptr noundef %22)
  br label %sw.epilog

sw.bb12:                                          ; preds = %entry
  %23 = load i32, ptr %type.addr, align 4
  %call13 = call ptr @tcg_temp_new_vec(i32 noundef %23)
  store ptr %call13, ptr %t1, align 8
  %24 = load i64, ptr %imm.addr, align 8
  %cmp = icmp ule i64 %24, 32
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb12
  %25 = load ptr, ptr %t1, align 8
  %26 = load ptr, ptr %v1.addr, align 8
  %27 = load i64, ptr %imm.addr, align 8
  store i64 %27, ptr %_a10, align 8
  store i64 31, ptr %_b11, align 8
  %28 = load i64, ptr %_a10, align 8
  %29 = load i64, ptr %_b11, align 8
  %cmp14 = icmp ult i64 %28, %29
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %30 = load i64, ptr %_a10, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %31 = load i64, ptr %_b11, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %30, %cond.true ], [ %31, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %32 = load i64, ptr %tmp, align 8
  call void @tcg_gen_sari_vec(i32 noundef 2, ptr noundef %25, ptr noundef %26, i64 noundef %32)
  %33 = load ptr, ptr %v0.addr, align 8
  %34 = load ptr, ptr %v1.addr, align 8
  %35 = load i64, ptr %imm.addr, align 8
  call void @tcg_gen_shri_vec(i32 noundef 3, ptr noundef %33, ptr noundef %34, i64 noundef %35)
  %36 = load i32, ptr %type.addr, align 4
  %37 = load ptr, ptr %v0.addr, align 8
  %call15 = call i64 @tcgv_vec_arg(ptr noundef %37)
  %38 = load ptr, ptr %v0.addr, align 8
  %call16 = call i64 @tcgv_vec_arg(ptr noundef %38)
  %39 = load ptr, ptr %t1, align 8
  %call17 = call i64 @tcgv_vec_arg(ptr noundef %39)
  call void @vec_gen_4(i32 noundef 196, i32 noundef %36, i32 noundef 2, i64 noundef %call15, i64 noundef %call16, i64 noundef %call17, i64 noundef 170)
  br label %if.end

if.else:                                          ; preds = %sw.bb12
  %40 = load ptr, ptr %t1, align 8
  %41 = load i32, ptr %type.addr, align 4
  %call18 = call ptr @tcg_constant_vec(i32 noundef %41, i32 noundef 3, i64 noundef 0)
  %42 = load ptr, ptr %v1.addr, align 8
  call void @tcg_gen_cmp_vec(i32 noundef 11, i32 noundef 3, ptr noundef %40, ptr noundef %call18, ptr noundef %42)
  %43 = load ptr, ptr %v0.addr, align 8
  %44 = load ptr, ptr %v1.addr, align 8
  %45 = load i64, ptr %imm.addr, align 8
  call void @tcg_gen_shri_vec(i32 noundef 3, ptr noundef %43, ptr noundef %44, i64 noundef %45)
  %46 = load ptr, ptr %t1, align 8
  %47 = load ptr, ptr %t1, align 8
  %48 = load i64, ptr %imm.addr, align 8
  %sub = sub i64 64, %48
  call void @tcg_gen_shli_vec(i32 noundef 3, ptr noundef %46, ptr noundef %47, i64 noundef %sub)
  %49 = load ptr, ptr %v0.addr, align 8
  %50 = load ptr, ptr %v0.addr, align 8
  %51 = load ptr, ptr %t1, align 8
  call void @tcg_gen_or_vec(i32 noundef 3, ptr noundef %49, ptr noundef %50, ptr noundef %51)
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end
  %52 = load ptr, ptr %t1, align 8
  call void @tcg_temp_free_vec(ptr noundef %52)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 3751, ptr noundef @__func__.expand_vec_sari, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %if.end, %sw.bb
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @expand_vec_rotli(i32 noundef %type, i32 noundef %vece, ptr noundef %v0, ptr noundef %v1, i64 noundef %imm) #0 {
entry:
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %v0.addr = alloca ptr, align 8
  %v1.addr = alloca ptr, align 8
  %imm.addr = alloca i64, align 8
  %t = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store i64 %imm, ptr %imm.addr, align 8
  %0 = load i32, ptr %vece.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %type.addr, align 4
  %2 = load i32, ptr %vece.addr, align 4
  %3 = load ptr, ptr %v0.addr, align 8
  %4 = load ptr, ptr %v1.addr, align 8
  %5 = load i64, ptr %imm.addr, align 8
  call void @expand_vec_shi(i32 noundef %1, i32 noundef %2, i32 noundef 180, ptr noundef %3, ptr noundef %4, i64 noundef %5)
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %6, 32768
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.end
  %7 = load i32, ptr @cpuinfo, align 4
  %and1 = and i32 %7, 4096
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %land.lhs.true3, label %if.end9

land.lhs.true3:                                   ; preds = %land.lhs.true
  %8 = load i32, ptr @cpuinfo, align 4
  %and4 = and i32 %8, 2048
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end9

if.then6:                                         ; preds = %land.lhs.true3
  %9 = load i32, ptr %type.addr, align 4
  %10 = load i32, ptr %vece.addr, align 4
  %11 = load ptr, ptr %v0.addr, align 8
  %call = call i64 @tcgv_vec_arg(ptr noundef %11)
  %12 = load ptr, ptr %v1.addr, align 8
  %call7 = call i64 @tcgv_vec_arg(ptr noundef %12)
  %13 = load ptr, ptr %v1.addr, align 8
  %call8 = call i64 @tcgv_vec_arg(ptr noundef %13)
  %14 = load i64, ptr %imm.addr, align 8
  call void @vec_gen_4(i32 noundef 203, i32 noundef %9, i32 noundef %10, i64 noundef %call, i64 noundef %call7, i64 noundef %call8, i64 noundef %14)
  br label %return

if.end9:                                          ; preds = %land.lhs.true3, %land.lhs.true, %if.end
  %15 = load i32, ptr %type.addr, align 4
  %call10 = call ptr @tcg_temp_new_vec(i32 noundef %15)
  store ptr %call10, ptr %t, align 8
  %16 = load i32, ptr %vece.addr, align 4
  %17 = load ptr, ptr %t, align 8
  %18 = load ptr, ptr %v1.addr, align 8
  %19 = load i64, ptr %imm.addr, align 8
  call void @tcg_gen_shli_vec(i32 noundef %16, ptr noundef %17, ptr noundef %18, i64 noundef %19)
  %20 = load i32, ptr %vece.addr, align 4
  %21 = load ptr, ptr %v0.addr, align 8
  %22 = load ptr, ptr %v1.addr, align 8
  %23 = load i32, ptr %vece.addr, align 4
  %shl = shl i32 8, %23
  %conv = sext i32 %shl to i64
  %24 = load i64, ptr %imm.addr, align 8
  %sub = sub i64 %conv, %24
  call void @tcg_gen_shri_vec(i32 noundef %20, ptr noundef %21, ptr noundef %22, i64 noundef %sub)
  %25 = load i32, ptr %vece.addr, align 4
  %26 = load ptr, ptr %v0.addr, align 8
  %27 = load ptr, ptr %v0.addr, align 8
  %28 = load ptr, ptr %t, align 8
  call void @tcg_gen_or_vec(i32 noundef %25, ptr noundef %26, ptr noundef %27, ptr noundef %28)
  %29 = load ptr, ptr %t, align 8
  call void @tcg_temp_free_vec(ptr noundef %29)
  br label %return

return:                                           ; preds = %if.end9, %if.then6, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @expand_vec_rotls(i32 noundef %type, i32 noundef %vece, ptr noundef %v0, ptr noundef %v1, ptr noundef %lsh) #0 {
entry:
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %v0.addr = alloca ptr, align 8
  %v1.addr = alloca ptr, align 8
  %lsh.addr = alloca ptr, align 8
  %t = alloca ptr, align 8
  %rsh = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %lsh, ptr %lsh.addr, align 8
  %0 = load i32, ptr %type.addr, align 4
  %call = call ptr @tcg_temp_new_vec(i32 noundef %0)
  store ptr %call, ptr %t, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32, ptr %vece.addr, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load i32, ptr %vece.addr, align 4
  %cmp1 = icmp uge i32 %2, 2
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  %3 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %3, 4096
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.else16

land.lhs.true:                                    ; preds = %cond.true
  %4 = load i32, ptr @cpuinfo, align 4
  %and2 = and i32 %4, 2048
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then12, label %if.else16

cond.false:                                       ; preds = %do.end
  %5 = load i32, ptr @cpuinfo, align 4
  %and4 = and i32 %5, 32768
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %land.lhs.true6, label %if.else16

land.lhs.true6:                                   ; preds = %cond.false
  %6 = load i32, ptr @cpuinfo, align 4
  %and7 = and i32 %6, 4096
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %land.lhs.true9, label %if.else16

land.lhs.true9:                                   ; preds = %land.lhs.true6
  %7 = load i32, ptr @cpuinfo, align 4
  %and10 = and i32 %7, 2048
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else16

if.then12:                                        ; preds = %land.lhs.true9, %land.lhs.true
  %8 = load i32, ptr %vece.addr, align 4
  %9 = load ptr, ptr %t, align 8
  %10 = load ptr, ptr %lsh.addr, align 8
  call void @tcg_gen_dup_i32_vec(i32 noundef %8, ptr noundef %9, ptr noundef %10)
  %11 = load i32, ptr %vece.addr, align 4
  %cmp13 = icmp uge i32 %11, 2
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.then12
  %12 = load i32, ptr %vece.addr, align 4
  %13 = load ptr, ptr %v0.addr, align 8
  %14 = load ptr, ptr %v1.addr, align 8
  %15 = load ptr, ptr %t, align 8
  call void @tcg_gen_rotlv_vec(i32 noundef %12, ptr noundef %13, ptr noundef %14, ptr noundef %15)
  br label %if.end15

if.else:                                          ; preds = %if.then12
  %16 = load i32, ptr %type.addr, align 4
  %17 = load i32, ptr %vece.addr, align 4
  %18 = load ptr, ptr %v0.addr, align 8
  %19 = load ptr, ptr %v1.addr, align 8
  %20 = load ptr, ptr %t, align 8
  call void @expand_vec_rotv(i32 noundef %16, i32 noundef %17, ptr noundef %18, ptr noundef %19, ptr noundef %20, i1 noundef zeroext false)
  br label %if.end15

if.end15:                                         ; preds = %if.else, %if.then14
  br label %if.end18

if.else16:                                        ; preds = %land.lhs.true9, %land.lhs.true6, %cond.false, %land.lhs.true, %cond.true
  %call17 = call ptr @tcg_temp_new_i32()
  store ptr %call17, ptr %rsh, align 8
  %21 = load ptr, ptr %rsh, align 8
  %22 = load ptr, ptr %lsh.addr, align 8
  call void @tcg_gen_neg_i32(ptr noundef %21, ptr noundef %22)
  %23 = load ptr, ptr %rsh, align 8
  %24 = load ptr, ptr %rsh, align 8
  %25 = load i32, ptr %vece.addr, align 4
  %shl = shl i32 8, %25
  %sub = sub i32 %shl, 1
  call void @tcg_gen_andi_i32(ptr noundef %23, ptr noundef %24, i32 noundef %sub)
  %26 = load i32, ptr %vece.addr, align 4
  %27 = load ptr, ptr %t, align 8
  %28 = load ptr, ptr %v1.addr, align 8
  %29 = load ptr, ptr %lsh.addr, align 8
  call void @tcg_gen_shls_vec(i32 noundef %26, ptr noundef %27, ptr noundef %28, ptr noundef %29)
  %30 = load i32, ptr %vece.addr, align 4
  %31 = load ptr, ptr %v0.addr, align 8
  %32 = load ptr, ptr %v1.addr, align 8
  %33 = load ptr, ptr %rsh, align 8
  call void @tcg_gen_shrs_vec(i32 noundef %30, ptr noundef %31, ptr noundef %32, ptr noundef %33)
  %34 = load i32, ptr %vece.addr, align 4
  %35 = load ptr, ptr %v0.addr, align 8
  %36 = load ptr, ptr %v0.addr, align 8
  %37 = load ptr, ptr %t, align 8
  call void @tcg_gen_or_vec(i32 noundef %34, ptr noundef %35, ptr noundef %36, ptr noundef %37)
  %38 = load ptr, ptr %rsh, align 8
  call void @tcg_temp_free_i32(ptr noundef %38)
  br label %if.end18

if.end18:                                         ; preds = %if.else16, %if.end15
  %39 = load ptr, ptr %t, align 8
  call void @tcg_temp_free_vec(ptr noundef %39)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @temp_tcgv_i32(ptr noundef %t) #0 {
entry:
  %t.addr = alloca ptr, align 8
  store ptr %t, ptr %t.addr, align 8
  %0 = load ptr, ptr %t.addr, align 8
  %call = call i64 @temp_idx(ptr noundef %0)
  %1 = load ptr, ptr %t.addr, align 8
  %2 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %3 = load ptr, ptr %2, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %4 = inttoptr i64 %sub.ptr.sub to ptr
  ret ptr %4
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @expand_vec_rotv(i32 noundef %type, i32 noundef %vece, ptr noundef %v0, ptr noundef %v1, ptr noundef %sh, i1 noundef zeroext %right) #0 {
entry:
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %v0.addr = alloca ptr, align 8
  %v1.addr = alloca ptr, align 8
  %sh.addr = alloca ptr, align 8
  %right.addr = alloca i8, align 1
  %t = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %sh, ptr %sh.addr, align 8
  %frombool = zext i1 %right to i8
  store i8 %frombool, ptr %right.addr, align 1
  %0 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %0, 32768
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr @cpuinfo, align 4
  %and1 = and i32 %1, 4096
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %2 = load i32, ptr @cpuinfo, align 4
  %and4 = and i32 %2, 2048
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true3
  %3 = load i8, ptr %right.addr, align 1
  %tobool6 = trunc i8 %3 to i1
  %cond = select i1 %tobool6, i32 205, i32 204
  %4 = load i32, ptr %type.addr, align 4
  %5 = load i32, ptr %vece.addr, align 4
  %6 = load ptr, ptr %v0.addr, align 8
  %call = call i64 @tcgv_vec_arg(ptr noundef %6)
  %7 = load ptr, ptr %v1.addr, align 8
  %call7 = call i64 @tcgv_vec_arg(ptr noundef %7)
  %8 = load ptr, ptr %v1.addr, align 8
  %call8 = call i64 @tcgv_vec_arg(ptr noundef %8)
  %9 = load ptr, ptr %sh.addr, align 8
  %call9 = call i64 @tcgv_vec_arg(ptr noundef %9)
  call void @vec_gen_4(i32 noundef %cond, i32 noundef %4, i32 noundef %5, i64 noundef %call, i64 noundef %call7, i64 noundef %call8, i64 noundef %call9)
  br label %return

if.end:                                           ; preds = %land.lhs.true3, %land.lhs.true, %entry
  %10 = load i32, ptr %type.addr, align 4
  %call10 = call ptr @tcg_temp_new_vec(i32 noundef %10)
  store ptr %call10, ptr %t, align 8
  %11 = load i32, ptr %vece.addr, align 4
  %12 = load ptr, ptr %t, align 8
  %13 = load i32, ptr %vece.addr, align 4
  %shl = shl i32 8, %13
  %conv = sext i32 %shl to i64
  call void @tcg_gen_dupi_vec(i32 noundef %11, ptr noundef %12, i64 noundef %conv)
  %14 = load i32, ptr %vece.addr, align 4
  %15 = load ptr, ptr %t, align 8
  %16 = load ptr, ptr %t, align 8
  %17 = load ptr, ptr %sh.addr, align 8
  call void @tcg_gen_sub_vec(i32 noundef %14, ptr noundef %15, ptr noundef %16, ptr noundef %17)
  %18 = load i8, ptr %right.addr, align 1
  %tobool11 = trunc i8 %18 to i1
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %if.end
  %19 = load i32, ptr %vece.addr, align 4
  %20 = load ptr, ptr %t, align 8
  %21 = load ptr, ptr %v1.addr, align 8
  %22 = load ptr, ptr %t, align 8
  call void @tcg_gen_shlv_vec(i32 noundef %19, ptr noundef %20, ptr noundef %21, ptr noundef %22)
  %23 = load i32, ptr %vece.addr, align 4
  %24 = load ptr, ptr %v0.addr, align 8
  %25 = load ptr, ptr %v1.addr, align 8
  %26 = load ptr, ptr %sh.addr, align 8
  call void @tcg_gen_shrv_vec(i32 noundef %23, ptr noundef %24, ptr noundef %25, ptr noundef %26)
  br label %if.end13

if.else:                                          ; preds = %if.end
  %27 = load i32, ptr %vece.addr, align 4
  %28 = load ptr, ptr %t, align 8
  %29 = load ptr, ptr %v1.addr, align 8
  %30 = load ptr, ptr %t, align 8
  call void @tcg_gen_shrv_vec(i32 noundef %27, ptr noundef %28, ptr noundef %29, ptr noundef %30)
  %31 = load i32, ptr %vece.addr, align 4
  %32 = load ptr, ptr %v0.addr, align 8
  %33 = load ptr, ptr %v1.addr, align 8
  %34 = load ptr, ptr %sh.addr, align 8
  call void @tcg_gen_shlv_vec(i32 noundef %31, ptr noundef %32, ptr noundef %33, ptr noundef %34)
  br label %if.end13

if.end13:                                         ; preds = %if.else, %if.then12
  %35 = load i32, ptr %vece.addr, align 4
  %36 = load ptr, ptr %v0.addr, align 8
  %37 = load ptr, ptr %v0.addr, align 8
  %38 = load ptr, ptr %t, align 8
  call void @tcg_gen_or_vec(i32 noundef %35, ptr noundef %36, ptr noundef %37, ptr noundef %38)
  %39 = load ptr, ptr %t, align 8
  call void @tcg_temp_free_vec(ptr noundef %39)
  br label %return

return:                                           ; preds = %if.end13, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @expand_vec_mul(i32 noundef %type, i32 noundef %vece, ptr noundef %v0, ptr noundef %v1, ptr noundef %v2) #0 {
entry:
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %v0.addr = alloca ptr, align 8
  %v1.addr = alloca ptr, align 8
  %v2.addr = alloca ptr, align 8
  %t1 = alloca ptr, align 8
  %t2 = alloca ptr, align 8
  %t3 = alloca ptr, align 8
  %t4 = alloca ptr, align 8
  %zero = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %v2, ptr %v2.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i32, ptr %vece.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load i32, ptr %type.addr, align 4
  switch i32 %1, label %sw.default [
    i32 3, label %sw.bb
    i32 4, label %sw.bb12
    i32 5, label %sw.bb12
  ]

sw.bb:                                            ; preds = %do.end
  %call = call ptr @tcg_temp_new_vec(i32 noundef 4)
  store ptr %call, ptr %t1, align 8
  %call1 = call ptr @tcg_temp_new_vec(i32 noundef 4)
  store ptr %call1, ptr %t2, align 8
  %call2 = call ptr @tcg_constant_vec(i32 noundef 4, i32 noundef 0, i64 noundef 0)
  store ptr %call2, ptr %zero, align 8
  %2 = load ptr, ptr %t1, align 8
  %call3 = call i64 @tcgv_vec_arg(ptr noundef %2)
  %3 = load ptr, ptr %v1.addr, align 8
  %call4 = call i64 @tcgv_vec_arg(ptr noundef %3)
  %4 = load ptr, ptr %zero, align 8
  %call5 = call i64 @tcgv_vec_arg(ptr noundef %4)
  call void @vec_gen_3(i32 noundef 201, i32 noundef 4, i32 noundef 0, i64 noundef %call3, i64 noundef %call4, i64 noundef %call5)
  %5 = load ptr, ptr %t2, align 8
  %call6 = call i64 @tcgv_vec_arg(ptr noundef %5)
  %6 = load ptr, ptr %zero, align 8
  %call7 = call i64 @tcgv_vec_arg(ptr noundef %6)
  %7 = load ptr, ptr %v2.addr, align 8
  %call8 = call i64 @tcgv_vec_arg(ptr noundef %7)
  call void @vec_gen_3(i32 noundef 201, i32 noundef 4, i32 noundef 0, i64 noundef %call6, i64 noundef %call7, i64 noundef %call8)
  %8 = load ptr, ptr %t1, align 8
  %9 = load ptr, ptr %t1, align 8
  %10 = load ptr, ptr %t2, align 8
  call void @tcg_gen_mul_vec(i32 noundef 1, ptr noundef %8, ptr noundef %9, ptr noundef %10)
  %11 = load ptr, ptr %t1, align 8
  %12 = load ptr, ptr %t1, align 8
  call void @tcg_gen_shri_vec(i32 noundef 1, ptr noundef %11, ptr noundef %12, i64 noundef 8)
  %13 = load ptr, ptr %v0.addr, align 8
  %call9 = call i64 @tcgv_vec_arg(ptr noundef %13)
  %14 = load ptr, ptr %t1, align 8
  %call10 = call i64 @tcgv_vec_arg(ptr noundef %14)
  %15 = load ptr, ptr %t1, align 8
  %call11 = call i64 @tcgv_vec_arg(ptr noundef %15)
  call void @vec_gen_3(i32 noundef 198, i32 noundef 4, i32 noundef 0, i64 noundef %call9, i64 noundef %call10, i64 noundef %call11)
  %16 = load ptr, ptr %t1, align 8
  call void @tcg_temp_free_vec(ptr noundef %16)
  %17 = load ptr, ptr %t2, align 8
  call void @tcg_temp_free_vec(ptr noundef %17)
  br label %sw.epilog

sw.bb12:                                          ; preds = %do.end, %do.end
  %18 = load i32, ptr %type.addr, align 4
  %call13 = call ptr @tcg_temp_new_vec(i32 noundef %18)
  store ptr %call13, ptr %t1, align 8
  %19 = load i32, ptr %type.addr, align 4
  %call14 = call ptr @tcg_temp_new_vec(i32 noundef %19)
  store ptr %call14, ptr %t2, align 8
  %20 = load i32, ptr %type.addr, align 4
  %call15 = call ptr @tcg_temp_new_vec(i32 noundef %20)
  store ptr %call15, ptr %t3, align 8
  %21 = load i32, ptr %type.addr, align 4
  %call16 = call ptr @tcg_temp_new_vec(i32 noundef %21)
  store ptr %call16, ptr %t4, align 8
  %call17 = call ptr @tcg_constant_vec(i32 noundef 4, i32 noundef 0, i64 noundef 0)
  store ptr %call17, ptr %zero, align 8
  %22 = load i32, ptr %type.addr, align 4
  %23 = load ptr, ptr %t1, align 8
  %call18 = call i64 @tcgv_vec_arg(ptr noundef %23)
  %24 = load ptr, ptr %v1.addr, align 8
  %call19 = call i64 @tcgv_vec_arg(ptr noundef %24)
  %25 = load ptr, ptr %zero, align 8
  %call20 = call i64 @tcgv_vec_arg(ptr noundef %25)
  call void @vec_gen_3(i32 noundef 201, i32 noundef %22, i32 noundef 0, i64 noundef %call18, i64 noundef %call19, i64 noundef %call20)
  %26 = load i32, ptr %type.addr, align 4
  %27 = load ptr, ptr %t2, align 8
  %call21 = call i64 @tcgv_vec_arg(ptr noundef %27)
  %28 = load ptr, ptr %zero, align 8
  %call22 = call i64 @tcgv_vec_arg(ptr noundef %28)
  %29 = load ptr, ptr %v2.addr, align 8
  %call23 = call i64 @tcgv_vec_arg(ptr noundef %29)
  call void @vec_gen_3(i32 noundef 201, i32 noundef %26, i32 noundef 0, i64 noundef %call21, i64 noundef %call22, i64 noundef %call23)
  %30 = load i32, ptr %type.addr, align 4
  %31 = load ptr, ptr %t3, align 8
  %call24 = call i64 @tcgv_vec_arg(ptr noundef %31)
  %32 = load ptr, ptr %v1.addr, align 8
  %call25 = call i64 @tcgv_vec_arg(ptr noundef %32)
  %33 = load ptr, ptr %zero, align 8
  %call26 = call i64 @tcgv_vec_arg(ptr noundef %33)
  call void @vec_gen_3(i32 noundef 202, i32 noundef %30, i32 noundef 0, i64 noundef %call24, i64 noundef %call25, i64 noundef %call26)
  %34 = load i32, ptr %type.addr, align 4
  %35 = load ptr, ptr %t4, align 8
  %call27 = call i64 @tcgv_vec_arg(ptr noundef %35)
  %36 = load ptr, ptr %zero, align 8
  %call28 = call i64 @tcgv_vec_arg(ptr noundef %36)
  %37 = load ptr, ptr %v2.addr, align 8
  %call29 = call i64 @tcgv_vec_arg(ptr noundef %37)
  call void @vec_gen_3(i32 noundef 202, i32 noundef %34, i32 noundef 0, i64 noundef %call27, i64 noundef %call28, i64 noundef %call29)
  %38 = load ptr, ptr %t1, align 8
  %39 = load ptr, ptr %t1, align 8
  %40 = load ptr, ptr %t2, align 8
  call void @tcg_gen_mul_vec(i32 noundef 1, ptr noundef %38, ptr noundef %39, ptr noundef %40)
  %41 = load ptr, ptr %t3, align 8
  %42 = load ptr, ptr %t3, align 8
  %43 = load ptr, ptr %t4, align 8
  call void @tcg_gen_mul_vec(i32 noundef 1, ptr noundef %41, ptr noundef %42, ptr noundef %43)
  %44 = load ptr, ptr %t1, align 8
  %45 = load ptr, ptr %t1, align 8
  call void @tcg_gen_shri_vec(i32 noundef 1, ptr noundef %44, ptr noundef %45, i64 noundef 8)
  %46 = load ptr, ptr %t3, align 8
  %47 = load ptr, ptr %t3, align 8
  call void @tcg_gen_shri_vec(i32 noundef 1, ptr noundef %46, ptr noundef %47, i64 noundef 8)
  %48 = load i32, ptr %type.addr, align 4
  %49 = load ptr, ptr %v0.addr, align 8
  %call30 = call i64 @tcgv_vec_arg(ptr noundef %49)
  %50 = load ptr, ptr %t1, align 8
  %call31 = call i64 @tcgv_vec_arg(ptr noundef %50)
  %51 = load ptr, ptr %t3, align 8
  %call32 = call i64 @tcgv_vec_arg(ptr noundef %51)
  call void @vec_gen_3(i32 noundef 198, i32 noundef %48, i32 noundef 0, i64 noundef %call30, i64 noundef %call31, i64 noundef %call32)
  %52 = load ptr, ptr %t1, align 8
  call void @tcg_temp_free_vec(ptr noundef %52)
  %53 = load ptr, ptr %t2, align 8
  call void @tcg_temp_free_vec(ptr noundef %53)
  %54 = load ptr, ptr %t3, align 8
  call void @tcg_temp_free_vec(ptr noundef %54)
  %55 = load ptr, ptr %t4, align 8
  call void @tcg_temp_free_vec(ptr noundef %55)
  br label %sw.epilog

sw.default:                                       ; preds = %do.end
  br label %do.body33

do.body33:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 3895, ptr noundef @__func__.expand_vec_mul, ptr noundef null) #15
  unreachable

do.end34:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end34, %sw.bb12, %sw.bb
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @expand_vec_cmp(i32 noundef %type, i32 noundef %vece, ptr noundef %v0, ptr noundef %v1, ptr noundef %v2, i32 noundef %cond) #0 {
entry:
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %v0.addr = alloca ptr, align 8
  %v1.addr = alloca ptr, align 8
  %v2.addr = alloca ptr, align 8
  %cond.addr = alloca i32, align 4
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %v2, ptr %v2.addr, align 8
  store i32 %cond, ptr %cond.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %1 = load i32, ptr %vece.addr, align 4
  %2 = load ptr, ptr %v0.addr, align 8
  %3 = load ptr, ptr %v1.addr, align 8
  %4 = load ptr, ptr %v2.addr, align 8
  %5 = load i32, ptr %cond.addr, align 4
  %call = call zeroext i1 @expand_vec_cmp_noinv(i32 noundef %0, i32 noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32, ptr %vece.addr, align 4
  %7 = load ptr, ptr %v0.addr, align 8
  %8 = load ptr, ptr %v0.addr, align 8
  call void @tcg_gen_not_vec(i32 noundef %6, ptr noundef %7, ptr noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @expand_vec_cmpsel(i32 noundef %type, i32 noundef %vece, ptr noundef %v0, ptr noundef %c1, ptr noundef %c2, ptr noundef %v3, ptr noundef %v4, i32 noundef %cond) #0 {
entry:
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %v0.addr = alloca ptr, align 8
  %c1.addr = alloca ptr, align 8
  %c2.addr = alloca ptr, align 8
  %v3.addr = alloca ptr, align 8
  %v4.addr = alloca ptr, align 8
  %cond.addr = alloca i32, align 4
  %t = alloca ptr, align 8
  %x = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %c1, ptr %c1.addr, align 8
  store ptr %c2, ptr %c2.addr, align 8
  store ptr %v3, ptr %v3.addr, align 8
  store ptr %v4, ptr %v4.addr, align 8
  store i32 %cond, ptr %cond.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %call = call ptr @tcg_temp_new_vec(i32 noundef %0)
  store ptr %call, ptr %t, align 8
  %1 = load i32, ptr %type.addr, align 4
  %2 = load i32, ptr %vece.addr, align 4
  %3 = load ptr, ptr %t, align 8
  %4 = load ptr, ptr %c1.addr, align 8
  %5 = load ptr, ptr %c2.addr, align 8
  %6 = load i32, ptr %cond.addr, align 4
  %call1 = call zeroext i1 @expand_vec_cmp_noinv(i32 noundef %1, i32 noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5, i32 noundef %6)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %v3.addr, align 8
  store ptr %7, ptr %x, align 8
  %8 = load ptr, ptr %v4.addr, align 8
  store ptr %8, ptr %v3.addr, align 8
  %9 = load ptr, ptr %x, align 8
  store ptr %9, ptr %v4.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load i32, ptr %type.addr, align 4
  %11 = load i32, ptr %vece.addr, align 4
  %12 = load ptr, ptr %v0.addr, align 8
  %call2 = call i64 @tcgv_vec_arg(ptr noundef %12)
  %13 = load ptr, ptr %v4.addr, align 8
  %call3 = call i64 @tcgv_vec_arg(ptr noundef %13)
  %14 = load ptr, ptr %v3.addr, align 8
  %call4 = call i64 @tcgv_vec_arg(ptr noundef %14)
  %15 = load ptr, ptr %t, align 8
  %call5 = call i64 @tcgv_vec_arg(ptr noundef %15)
  call void @vec_gen_4(i32 noundef 195, i32 noundef %10, i32 noundef %11, i64 noundef %call2, i64 noundef %call3, i64 noundef %call4, i64 noundef %call5)
  %16 = load ptr, ptr %t, align 8
  call void @tcg_temp_free_vec(ptr noundef %16)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.va_end(ptr) #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_register_jit(ptr noundef %buf, i64 noundef %buf_size) #0 {
entry:
  %buf.addr = alloca ptr, align 8
  %buf_size.addr = alloca i64, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i64 %buf_size, ptr %buf_size.addr, align 8
  %0 = load ptr, ptr %buf.addr, align 8
  %1 = load i64, ptr %buf_size.addr, align 8
  call void @tcg_register_jit_int(ptr noundef %0, i64 noundef %1, ptr noundef @debug_frame, i64 noundef 58)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_register_jit_int(ptr noundef %buf_ptr, i64 noundef %buf_size, ptr noundef %debug_frame, i64 noundef %debug_frame_size) #0 {
entry:
  %buf_ptr.addr = alloca ptr, align 8
  %buf_size.addr = alloca i64, align 8
  %debug_frame.addr = alloca ptr, align 8
  %debug_frame_size.addr = alloca i64, align 8
  %img = alloca ptr, align 8
  %buf = alloca i64, align 8
  %img_size = alloca i64, align 8
  %dfh = alloca ptr, align 8
  store ptr %buf_ptr, ptr %buf_ptr.addr, align 8
  store i64 %buf_size, ptr %buf_size.addr, align 8
  store ptr %debug_frame, ptr %debug_frame.addr, align 8
  store i64 %debug_frame_size, ptr %debug_frame_size.addr, align 8
  %0 = load ptr, ptr %buf_ptr.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  store i64 %1, ptr %buf, align 8
  %2 = load i64, ptr %debug_frame_size.addr, align 8
  %add = add i64 784, %2
  store i64 %add, ptr %img_size, align 8
  %3 = load i64, ptr %img_size, align 8
  %call = call noalias ptr @g_malloc(i64 noundef %3) #16
  store ptr %call, ptr %img, align 8
  %4 = load ptr, ptr %img, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %4, ptr align 8 @tcg_register_jit_int.img_template, i64 784, i1 false)
  %5 = load i64, ptr %buf, align 8
  %6 = load ptr, ptr %img, align 8
  %phdr = getelementptr inbounds %struct.ElfImage, ptr %6, i32 0, i32 1
  %p_vaddr = getelementptr inbounds %struct.elf64_phdr, ptr %phdr, i32 0, i32 3
  store i64 %5, ptr %p_vaddr, align 8
  %7 = load i64, ptr %buf, align 8
  %8 = load ptr, ptr %img, align 8
  %phdr1 = getelementptr inbounds %struct.ElfImage, ptr %8, i32 0, i32 1
  %p_paddr = getelementptr inbounds %struct.elf64_phdr, ptr %phdr1, i32 0, i32 4
  store i64 %7, ptr %p_paddr, align 8
  %9 = load i64, ptr %buf_size.addr, align 8
  %10 = load ptr, ptr %img, align 8
  %phdr2 = getelementptr inbounds %struct.ElfImage, ptr %10, i32 0, i32 1
  %p_memsz = getelementptr inbounds %struct.elf64_phdr, ptr %phdr2, i32 0, i32 6
  store i64 %9, ptr %p_memsz, align 8
  %11 = load ptr, ptr %img, align 8
  %str = getelementptr inbounds %struct.ElfImage, ptr %11, i32 0, i32 6
  %arraydecay = getelementptr inbounds [80 x i8], ptr %str, i64 0, i64 0
  %call3 = call i32 @find_string(ptr noundef %arraydecay, ptr noundef @.str.129)
  %12 = load ptr, ptr %img, align 8
  %shdr = getelementptr inbounds %struct.ElfImage, ptr %12, i32 0, i32 2
  %arrayidx = getelementptr [7 x %struct.elf64_shdr], ptr %shdr, i64 0, i64 1
  %sh_name = getelementptr inbounds %struct.elf64_shdr, ptr %arrayidx, i32 0, i32 0
  store i32 %call3, ptr %sh_name, align 8
  %13 = load i64, ptr %buf, align 8
  %14 = load ptr, ptr %img, align 8
  %shdr4 = getelementptr inbounds %struct.ElfImage, ptr %14, i32 0, i32 2
  %arrayidx5 = getelementptr [7 x %struct.elf64_shdr], ptr %shdr4, i64 0, i64 1
  %sh_addr = getelementptr inbounds %struct.elf64_shdr, ptr %arrayidx5, i32 0, i32 3
  store i64 %13, ptr %sh_addr, align 8
  %15 = load i64, ptr %buf_size.addr, align 8
  %16 = load ptr, ptr %img, align 8
  %shdr6 = getelementptr inbounds %struct.ElfImage, ptr %16, i32 0, i32 2
  %arrayidx7 = getelementptr [7 x %struct.elf64_shdr], ptr %shdr6, i64 0, i64 1
  %sh_size = getelementptr inbounds %struct.elf64_shdr, ptr %arrayidx7, i32 0, i32 5
  store i64 %15, ptr %sh_size, align 8
  %17 = load ptr, ptr %img, align 8
  %str8 = getelementptr inbounds %struct.ElfImage, ptr %17, i32 0, i32 6
  %arraydecay9 = getelementptr inbounds [80 x i8], ptr %str8, i64 0, i64 0
  %call10 = call i32 @find_string(ptr noundef %arraydecay9, ptr noundef @.str.130)
  %18 = load ptr, ptr %img, align 8
  %shdr11 = getelementptr inbounds %struct.ElfImage, ptr %18, i32 0, i32 2
  %arrayidx12 = getelementptr [7 x %struct.elf64_shdr], ptr %shdr11, i64 0, i64 2
  %sh_name13 = getelementptr inbounds %struct.elf64_shdr, ptr %arrayidx12, i32 0, i32 0
  store i32 %call10, ptr %sh_name13, align 8
  %19 = load ptr, ptr %img, align 8
  %str14 = getelementptr inbounds %struct.ElfImage, ptr %19, i32 0, i32 6
  %arraydecay15 = getelementptr inbounds [80 x i8], ptr %str14, i64 0, i64 0
  %call16 = call i32 @find_string(ptr noundef %arraydecay15, ptr noundef @.str.131)
  %20 = load ptr, ptr %img, align 8
  %shdr17 = getelementptr inbounds %struct.ElfImage, ptr %20, i32 0, i32 2
  %arrayidx18 = getelementptr [7 x %struct.elf64_shdr], ptr %shdr17, i64 0, i64 3
  %sh_name19 = getelementptr inbounds %struct.elf64_shdr, ptr %arrayidx18, i32 0, i32 0
  store i32 %call16, ptr %sh_name19, align 8
  %21 = load ptr, ptr %img, align 8
  %str20 = getelementptr inbounds %struct.ElfImage, ptr %21, i32 0, i32 6
  %arraydecay21 = getelementptr inbounds [80 x i8], ptr %str20, i64 0, i64 0
  %call22 = call i32 @find_string(ptr noundef %arraydecay21, ptr noundef @.str.132)
  %22 = load ptr, ptr %img, align 8
  %shdr23 = getelementptr inbounds %struct.ElfImage, ptr %22, i32 0, i32 2
  %arrayidx24 = getelementptr [7 x %struct.elf64_shdr], ptr %shdr23, i64 0, i64 4
  %sh_name25 = getelementptr inbounds %struct.elf64_shdr, ptr %arrayidx24, i32 0, i32 0
  store i32 %call22, ptr %sh_name25, align 8
  %23 = load i64, ptr %debug_frame_size.addr, align 8
  %24 = load ptr, ptr %img, align 8
  %shdr26 = getelementptr inbounds %struct.ElfImage, ptr %24, i32 0, i32 2
  %arrayidx27 = getelementptr [7 x %struct.elf64_shdr], ptr %shdr26, i64 0, i64 4
  %sh_size28 = getelementptr inbounds %struct.elf64_shdr, ptr %arrayidx27, i32 0, i32 5
  store i64 %23, ptr %sh_size28, align 8
  %25 = load ptr, ptr %img, align 8
  %str29 = getelementptr inbounds %struct.ElfImage, ptr %25, i32 0, i32 6
  %arraydecay30 = getelementptr inbounds [80 x i8], ptr %str29, i64 0, i64 0
  %call31 = call i32 @find_string(ptr noundef %arraydecay30, ptr noundef @.str.133)
  %26 = load ptr, ptr %img, align 8
  %shdr32 = getelementptr inbounds %struct.ElfImage, ptr %26, i32 0, i32 2
  %arrayidx33 = getelementptr [7 x %struct.elf64_shdr], ptr %shdr32, i64 0, i64 5
  %sh_name34 = getelementptr inbounds %struct.elf64_shdr, ptr %arrayidx33, i32 0, i32 0
  store i32 %call31, ptr %sh_name34, align 8
  %27 = load ptr, ptr %img, align 8
  %str35 = getelementptr inbounds %struct.ElfImage, ptr %27, i32 0, i32 6
  %arraydecay36 = getelementptr inbounds [80 x i8], ptr %str35, i64 0, i64 0
  %call37 = call i32 @find_string(ptr noundef %arraydecay36, ptr noundef @.str.134)
  %28 = load ptr, ptr %img, align 8
  %shdr38 = getelementptr inbounds %struct.ElfImage, ptr %28, i32 0, i32 2
  %arrayidx39 = getelementptr [7 x %struct.elf64_shdr], ptr %shdr38, i64 0, i64 6
  %sh_name40 = getelementptr inbounds %struct.elf64_shdr, ptr %arrayidx39, i32 0, i32 0
  store i32 %call37, ptr %sh_name40, align 8
  %29 = load ptr, ptr %img, align 8
  %str41 = getelementptr inbounds %struct.ElfImage, ptr %29, i32 0, i32 6
  %arraydecay42 = getelementptr inbounds [80 x i8], ptr %str41, i64 0, i64 0
  %call43 = call i32 @find_string(ptr noundef %arraydecay42, ptr noundef @.str.135)
  %30 = load ptr, ptr %img, align 8
  %sym = getelementptr inbounds %struct.ElfImage, ptr %30, i32 0, i32 3
  %arrayidx44 = getelementptr [2 x %struct.elf64_sym], ptr %sym, i64 0, i64 1
  %st_name = getelementptr inbounds %struct.elf64_sym, ptr %arrayidx44, i32 0, i32 0
  store i32 %call43, ptr %st_name, align 8
  %31 = load i64, ptr %buf, align 8
  %32 = load ptr, ptr %img, align 8
  %sym45 = getelementptr inbounds %struct.ElfImage, ptr %32, i32 0, i32 3
  %arrayidx46 = getelementptr [2 x %struct.elf64_sym], ptr %sym45, i64 0, i64 1
  %st_value = getelementptr inbounds %struct.elf64_sym, ptr %arrayidx46, i32 0, i32 4
  store i64 %31, ptr %st_value, align 8
  %33 = load i64, ptr %buf_size.addr, align 8
  %34 = load ptr, ptr %img, align 8
  %sym47 = getelementptr inbounds %struct.ElfImage, ptr %34, i32 0, i32 3
  %arrayidx48 = getelementptr [2 x %struct.elf64_sym], ptr %sym47, i64 0, i64 1
  %st_size = getelementptr inbounds %struct.elf64_sym, ptr %arrayidx48, i32 0, i32 5
  store i64 %33, ptr %st_size, align 8
  %35 = load i64, ptr %buf, align 8
  %36 = load ptr, ptr %img, align 8
  %di = getelementptr inbounds %struct.ElfImage, ptr %36, i32 0, i32 4
  %cu_low_pc = getelementptr inbounds %struct.DebugInfo, ptr %di, i32 0, i32 6
  store i64 %35, ptr %cu_low_pc, align 2
  %37 = load i64, ptr %buf, align 8
  %38 = load i64, ptr %buf_size.addr, align 8
  %add49 = add i64 %37, %38
  %39 = load ptr, ptr %img, align 8
  %di50 = getelementptr inbounds %struct.ElfImage, ptr %39, i32 0, i32 4
  %cu_high_pc = getelementptr inbounds %struct.DebugInfo, ptr %di50, i32 0, i32 7
  store i64 %add49, ptr %cu_high_pc, align 2
  %40 = load i64, ptr %buf, align 8
  %41 = load ptr, ptr %img, align 8
  %di51 = getelementptr inbounds %struct.ElfImage, ptr %41, i32 0, i32 4
  %fn_low_pc = getelementptr inbounds %struct.DebugInfo, ptr %di51, i32 0, i32 10
  store i64 %40, ptr %fn_low_pc, align 1
  %42 = load i64, ptr %buf, align 8
  %43 = load i64, ptr %buf_size.addr, align 8
  %add52 = add i64 %42, %43
  %44 = load ptr, ptr %img, align 8
  %di53 = getelementptr inbounds %struct.ElfImage, ptr %44, i32 0, i32 4
  %fn_high_pc = getelementptr inbounds %struct.DebugInfo, ptr %di53, i32 0, i32 11
  store i64 %add52, ptr %fn_high_pc, align 1
  %45 = load ptr, ptr %img, align 8
  %add.ptr = getelementptr %struct.ElfImage, ptr %45, i64 1
  store ptr %add.ptr, ptr %dfh, align 8
  %46 = load ptr, ptr %dfh, align 8
  %47 = load ptr, ptr %debug_frame.addr, align 8
  %48 = load i64, ptr %debug_frame_size.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %46, ptr align 1 %47, i64 %48, i1 false)
  %49 = load i64, ptr %buf, align 8
  %50 = load ptr, ptr %dfh, align 8
  %fde = getelementptr inbounds %struct.DebugFrameHeader, ptr %50, i32 0, i32 1
  %func_start = getelementptr inbounds %struct.DebugFrameFDEHeader, ptr %fde, i32 0, i32 2
  store i64 %49, ptr %func_start, align 1
  %51 = load i64, ptr %buf_size.addr, align 8
  %52 = load ptr, ptr %dfh, align 8
  %fde54 = getelementptr inbounds %struct.DebugFrameHeader, ptr %52, i32 0, i32 1
  %func_len = getelementptr inbounds %struct.DebugFrameFDEHeader, ptr %fde54, i32 0, i32 3
  store i64 %51, ptr %func_len, align 1
  %53 = load ptr, ptr %img, align 8
  store ptr %53, ptr getelementptr inbounds (%struct.jit_code_entry, ptr @tcg_register_jit_int.one_entry, i32 0, i32 2), align 8
  %54 = load i64, ptr %img_size, align 8
  store i64 %54, ptr getelementptr inbounds (%struct.jit_code_entry, ptr @tcg_register_jit_int.one_entry, i32 0, i32 3), align 8
  store i32 1, ptr getelementptr inbounds (%struct.jit_descriptor, ptr @__jit_debug_descriptor, i32 0, i32 1), align 4
  store ptr @tcg_register_jit_int.one_entry, ptr getelementptr inbounds (%struct.jit_descriptor, ptr @__jit_debug_descriptor, i32 0, i32 2), align 8
  store ptr @tcg_register_jit_int.one_entry, ptr getelementptr inbounds (%struct.jit_descriptor, ptr @__jit_debug_descriptor, i32 0, i32 3), align 8
  call void @__jit_debug_register_code()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_register_thread() #0 {
entry:
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  store ptr @tcg_init_ctx, ptr %0, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_malloc_internal(ptr noundef %s, i32 noundef %size) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %size.addr = alloca i32, align 4
  %p = alloca ptr, align 8
  %pool_size = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %size, ptr %size.addr, align 4
  %0 = load i32, ptr %size.addr, align 4
  %cmp = icmp sgt i32 %0, 32768
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %size.addr, align 4
  %conv = sext i32 %1 to i64
  %add = add i64 16, %conv
  %call = call noalias ptr @g_malloc(i64 noundef %add) #16
  store ptr %call, ptr %p, align 8
  %2 = load i32, ptr %size.addr, align 4
  %3 = load ptr, ptr %p, align 8
  %size1 = getelementptr inbounds %struct.TCGPool, ptr %3, i32 0, i32 1
  store i32 %2, ptr %size1, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %pool_first_large = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %pool_first_large, align 8
  %6 = load ptr, ptr %p, align 8
  %next = getelementptr inbounds %struct.TCGPool, ptr %6, i32 0, i32 0
  store ptr %5, ptr %next, align 16
  %7 = load ptr, ptr %p, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %pool_first_large2 = getelementptr inbounds %struct.TCGContext, ptr %8, i32 0, i32 4
  store ptr %7, ptr %pool_first_large2, align 8
  %9 = load ptr, ptr %p, align 8
  %data = getelementptr inbounds %struct.TCGPool, ptr %9, i32 0, i32 3
  %arraydecay = getelementptr inbounds [0 x i8], ptr %data, i64 0, i64 0
  store ptr %arraydecay, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %10 = load ptr, ptr %s.addr, align 8
  %pool_current = getelementptr inbounds %struct.TCGContext, ptr %10, i32 0, i32 3
  %11 = load ptr, ptr %pool_current, align 8
  store ptr %11, ptr %p, align 8
  %12 = load ptr, ptr %p, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.else6, label %if.then3

if.then3:                                         ; preds = %if.else
  %13 = load ptr, ptr %s.addr, align 8
  %pool_first = getelementptr inbounds %struct.TCGContext, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %pool_first, align 8
  store ptr %14, ptr %p, align 8
  %15 = load ptr, ptr %p, align 8
  %tobool4 = icmp ne ptr %15, null
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then3
  br label %new_pool

if.end:                                           ; preds = %if.then3
  br label %if.end26

if.else6:                                         ; preds = %if.else
  %16 = load ptr, ptr %p, align 8
  %next7 = getelementptr inbounds %struct.TCGPool, ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %next7, align 16
  %tobool8 = icmp ne ptr %17, null
  br i1 %tobool8, label %if.else23, label %if.then9

if.then9:                                         ; preds = %if.else6
  br label %new_pool

new_pool:                                         ; preds = %if.then9, %if.then5
  store i32 32768, ptr %pool_size, align 4
  %18 = load i32, ptr %pool_size, align 4
  %conv10 = sext i32 %18 to i64
  %add11 = add i64 16, %conv10
  %call12 = call noalias ptr @g_malloc(i64 noundef %add11) #16
  store ptr %call12, ptr %p, align 8
  %19 = load i32, ptr %pool_size, align 4
  %20 = load ptr, ptr %p, align 8
  %size13 = getelementptr inbounds %struct.TCGPool, ptr %20, i32 0, i32 1
  store i32 %19, ptr %size13, align 8
  %21 = load ptr, ptr %p, align 8
  %next14 = getelementptr inbounds %struct.TCGPool, ptr %21, i32 0, i32 0
  store ptr null, ptr %next14, align 16
  %22 = load ptr, ptr %s.addr, align 8
  %pool_current15 = getelementptr inbounds %struct.TCGContext, ptr %22, i32 0, i32 3
  %23 = load ptr, ptr %pool_current15, align 8
  %tobool16 = icmp ne ptr %23, null
  br i1 %tobool16, label %if.then17, label %if.else20

if.then17:                                        ; preds = %new_pool
  %24 = load ptr, ptr %p, align 8
  %25 = load ptr, ptr %s.addr, align 8
  %pool_current18 = getelementptr inbounds %struct.TCGContext, ptr %25, i32 0, i32 3
  %26 = load ptr, ptr %pool_current18, align 8
  %next19 = getelementptr inbounds %struct.TCGPool, ptr %26, i32 0, i32 0
  store ptr %24, ptr %next19, align 16
  br label %if.end22

if.else20:                                        ; preds = %new_pool
  %27 = load ptr, ptr %p, align 8
  %28 = load ptr, ptr %s.addr, align 8
  %pool_first21 = getelementptr inbounds %struct.TCGContext, ptr %28, i32 0, i32 2
  store ptr %27, ptr %pool_first21, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.else20, %if.then17
  br label %if.end25

if.else23:                                        ; preds = %if.else6
  %29 = load ptr, ptr %p, align 8
  %next24 = getelementptr inbounds %struct.TCGPool, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %next24, align 16
  store ptr %30, ptr %p, align 8
  br label %if.end25

if.end25:                                         ; preds = %if.else23, %if.end22
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.end
  br label %if.end27

if.end27:                                         ; preds = %if.end26
  %31 = load ptr, ptr %p, align 8
  %32 = load ptr, ptr %s.addr, align 8
  %pool_current28 = getelementptr inbounds %struct.TCGContext, ptr %32, i32 0, i32 3
  store ptr %31, ptr %pool_current28, align 8
  %33 = load ptr, ptr %p, align 8
  %data29 = getelementptr inbounds %struct.TCGPool, ptr %33, i32 0, i32 3
  %arraydecay30 = getelementptr inbounds [0 x i8], ptr %data29, i64 0, i64 0
  %34 = load i32, ptr %size.addr, align 4
  %idx.ext = sext i32 %34 to i64
  %add.ptr = getelementptr i8, ptr %arraydecay30, i64 %idx.ext
  %35 = load ptr, ptr %s.addr, align 8
  %pool_cur = getelementptr inbounds %struct.TCGContext, ptr %35, i32 0, i32 0
  store ptr %add.ptr, ptr %pool_cur, align 8
  %36 = load ptr, ptr %p, align 8
  %data31 = getelementptr inbounds %struct.TCGPool, ptr %36, i32 0, i32 3
  %arraydecay32 = getelementptr inbounds [0 x i8], ptr %data31, i64 0, i64 0
  %37 = load ptr, ptr %p, align 8
  %size33 = getelementptr inbounds %struct.TCGPool, ptr %37, i32 0, i32 1
  %38 = load i32, ptr %size33, align 8
  %idx.ext34 = sext i32 %38 to i64
  %add.ptr35 = getelementptr i8, ptr %arraydecay32, i64 %idx.ext34
  %39 = load ptr, ptr %s.addr, align 8
  %pool_end = getelementptr inbounds %struct.TCGContext, ptr %39, i32 0, i32 1
  store ptr %add.ptr35, ptr %pool_end, align 8
  %40 = load ptr, ptr %p, align 8
  %data36 = getelementptr inbounds %struct.TCGPool, ptr %40, i32 0, i32 3
  %arraydecay37 = getelementptr inbounds [0 x i8], ptr %data36, i64 0, i64 0
  store ptr %arraydecay37, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end27, %if.then
  %41 = load ptr, ptr %retval, align 8
  ret ptr %41
}

; Function Attrs: allocsize(0)
declare noalias ptr @g_malloc(i64 noundef) #6

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_pool_reset(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %t = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %pool_first_large = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %pool_first_large, align 8
  store ptr %1, ptr %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load ptr, ptr %p, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %p, align 8
  %next = getelementptr inbounds %struct.TCGPool, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %next, align 16
  store ptr %4, ptr %t, align 8
  %5 = load ptr, ptr %p, align 8
  call void @g_free(ptr noundef %5)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load ptr, ptr %t, align 8
  store ptr %6, ptr %p, align 8
  br label %for.cond, !llvm.loop !5

for.end:                                          ; preds = %for.cond
  %7 = load ptr, ptr %s.addr, align 8
  %pool_first_large1 = getelementptr inbounds %struct.TCGContext, ptr %7, i32 0, i32 4
  store ptr null, ptr %pool_first_large1, align 8
  %8 = load ptr, ptr %s.addr, align 8
  %pool_end = getelementptr inbounds %struct.TCGContext, ptr %8, i32 0, i32 1
  store ptr null, ptr %pool_end, align 8
  %9 = load ptr, ptr %s.addr, align 8
  %pool_cur = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 0
  store ptr null, ptr %pool_cur, align 8
  %10 = load ptr, ptr %s.addr, align 8
  %pool_current = getelementptr inbounds %struct.TCGContext, ptr %10, i32 0, i32 3
  store ptr null, ptr %pool_current, align 8
  ret void
}

declare void @g_free(ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_init(i64 noundef %tb_size, i32 noundef %splitwx, i32 noundef %max_cpus) #0 {
entry:
  %tb_size.addr = alloca i64, align 8
  %splitwx.addr = alloca i32, align 4
  %max_cpus.addr = alloca i32, align 4
  store i64 %tb_size, ptr %tb_size.addr, align 8
  store i32 %splitwx, ptr %splitwx.addr, align 4
  store i32 %max_cpus, ptr %max_cpus.addr, align 4
  %0 = load i32, ptr %max_cpus.addr, align 4
  call void @tcg_context_init(i32 noundef %0)
  %1 = load i64, ptr %tb_size.addr, align 8
  %2 = load i32, ptr %splitwx.addr, align 4
  %3 = load i32, ptr %max_cpus.addr, align 4
  call void @tcg_region_init(i64 noundef %1, i32 noundef %2, i32 noundef %3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_context_init(i32 noundef %max_cpus) #0 {
entry:
  %max_cpus.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  %op = alloca i32, align 4
  %total_args = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %def = alloca ptr, align 8
  %args_ct = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %r = alloca i32, align 4
  store i32 %max_cpus, ptr %max_cpus.addr, align 4
  store ptr @tcg_init_ctx, ptr %s, align 8
  %0 = load ptr, ptr %s, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %0, i8 0, i64 30872, i1 false)
  %1 = load ptr, ptr %s, align 8
  %nb_globals = getelementptr inbounds %struct.TCGContext, ptr %1, i32 0, i32 6
  store i32 0, ptr %nb_globals, align 4
  store i32 0, ptr %total_args, align 4
  store i32 0, ptr %op, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %op, align 4
  %cmp = icmp slt i32 %2, 206
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, ptr %op, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %def, align 8
  %4 = load ptr, ptr %def, align 8
  %nb_iargs = getelementptr inbounds %struct.TCGOpDef, ptr %4, i32 0, i32 2
  %5 = load i8, ptr %nb_iargs, align 1
  %conv = zext i8 %5 to i32
  %6 = load ptr, ptr %def, align 8
  %nb_oargs = getelementptr inbounds %struct.TCGOpDef, ptr %6, i32 0, i32 1
  %7 = load i8, ptr %nb_oargs, align 8
  %conv1 = zext i8 %7 to i32
  %add = add i32 %conv, %conv1
  store i32 %add, ptr %n, align 4
  %8 = load i32, ptr %n, align 4
  %9 = load i32, ptr %total_args, align 4
  %add2 = add i32 %9, %8
  store i32 %add2, ptr %total_args, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, ptr %op, align 4
  %inc = add i32 %10, 1
  store i32 %inc, ptr %op, align 4
  br label %for.cond, !llvm.loop !7

for.end:                                          ; preds = %for.cond
  %11 = load i32, ptr %total_args, align 4
  %conv3 = sext i32 %11 to i64
  %call = call noalias ptr @g_malloc0_n(i64 noundef %conv3, i64 noundef 12) #17
  store ptr %call, ptr %args_ct, align 8
  store i32 0, ptr %op, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc16, %for.end
  %12 = load i32, ptr %op, align 4
  %cmp5 = icmp slt i32 %12, 206
  br i1 %cmp5, label %for.body7, label %for.end18

for.body7:                                        ; preds = %for.cond4
  %13 = load i32, ptr %op, align 4
  %idxprom8 = sext i32 %13 to i64
  %arrayidx9 = getelementptr [0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 %idxprom8
  store ptr %arrayidx9, ptr %def, align 8
  %14 = load ptr, ptr %args_ct, align 8
  %15 = load ptr, ptr %def, align 8
  %args_ct10 = getelementptr inbounds %struct.TCGOpDef, ptr %15, i32 0, i32 6
  store ptr %14, ptr %args_ct10, align 8
  %16 = load ptr, ptr %def, align 8
  %nb_iargs11 = getelementptr inbounds %struct.TCGOpDef, ptr %16, i32 0, i32 2
  %17 = load i8, ptr %nb_iargs11, align 1
  %conv12 = zext i8 %17 to i32
  %18 = load ptr, ptr %def, align 8
  %nb_oargs13 = getelementptr inbounds %struct.TCGOpDef, ptr %18, i32 0, i32 1
  %19 = load i8, ptr %nb_oargs13, align 8
  %conv14 = zext i8 %19 to i32
  %add15 = add i32 %conv12, %conv14
  store i32 %add15, ptr %n, align 4
  %20 = load i32, ptr %n, align 4
  %21 = load ptr, ptr %args_ct, align 8
  %idx.ext = sext i32 %20 to i64
  %add.ptr = getelementptr %struct.TCGArgConstraint, ptr %21, i64 %idx.ext
  store ptr %add.ptr, ptr %args_ct, align 8
  br label %for.inc16

for.inc16:                                        ; preds = %for.body7
  %22 = load i32, ptr %op, align 4
  %inc17 = add i32 %22, 1
  store i32 %inc17, ptr %op, align 4
  br label %for.cond4, !llvm.loop !8

for.end18:                                        ; preds = %for.cond4
  call void @init_call_layout(ptr noundef @info_helper_ld32_mmu)
  call void @init_call_layout(ptr noundef @info_helper_ld64_mmu)
  call void @init_call_layout(ptr noundef @info_helper_ld128_mmu)
  call void @init_call_layout(ptr noundef @info_helper_st32_mmu)
  call void @init_call_layout(ptr noundef @info_helper_st64_mmu)
  call void @init_call_layout(ptr noundef @info_helper_st128_mmu)
  %23 = load ptr, ptr %s, align 8
  call void @tcg_target_init(ptr noundef %23)
  %24 = load ptr, ptr %s, align 8
  call void @process_op_defs(ptr noundef %24)
  store i32 0, ptr %n, align 4
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc26, %for.end18
  %25 = load i32, ptr %n, align 4
  %conv20 = sext i32 %25 to i64
  %cmp21 = icmp ult i64 %conv20, 31
  br i1 %cmp21, label %for.body23, label %for.end28

for.body23:                                       ; preds = %for.cond19
  %26 = load i32, ptr %n, align 4
  %idxprom24 = sext i32 %26 to i64
  %arrayidx25 = getelementptr [31 x i32], ptr @tcg_target_reg_alloc_order, i64 0, i64 %idxprom24
  %27 = load i32, ptr %arrayidx25, align 4
  store i32 %27, ptr %r, align 4
  %28 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %29 = load i32, ptr %r, align 4
  %shr = lshr i32 %28, %29
  %and = and i32 %shr, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body23
  br label %for.end28

if.end:                                           ; preds = %for.body23
  br label %for.inc26

for.inc26:                                        ; preds = %if.end
  %30 = load i32, ptr %n, align 4
  %inc27 = add i32 %30, 1
  store i32 %inc27, ptr %n, align 4
  br label %for.cond19, !llvm.loop !9

for.end28:                                        ; preds = %if.then, %for.cond19
  store i32 0, ptr %i, align 4
  br label %for.cond29

for.cond29:                                       ; preds = %for.inc38, %for.end28
  %31 = load i32, ptr %i, align 4
  %32 = load i32, ptr %n, align 4
  %cmp30 = icmp slt i32 %31, %32
  br i1 %cmp30, label %for.body32, label %for.end40

for.body32:                                       ; preds = %for.cond29
  %33 = load i32, ptr %n, align 4
  %sub = sub i32 %33, 1
  %34 = load i32, ptr %i, align 4
  %sub33 = sub i32 %sub, %34
  %idxprom34 = sext i32 %sub33 to i64
  %arrayidx35 = getelementptr [31 x i32], ptr @tcg_target_reg_alloc_order, i64 0, i64 %idxprom34
  %35 = load i32, ptr %arrayidx35, align 4
  %36 = load i32, ptr %i, align 4
  %idxprom36 = sext i32 %36 to i64
  %arrayidx37 = getelementptr [31 x i32], ptr @indirect_reg_alloc_order, i64 0, i64 %idxprom36
  store i32 %35, ptr %arrayidx37, align 4
  br label %for.inc38

for.inc38:                                        ; preds = %for.body32
  %37 = load i32, ptr %i, align 4
  %inc39 = add i32 %37, 1
  store i32 %inc39, ptr %i, align 4
  br label %for.cond29, !llvm.loop !10

for.end40:                                        ; preds = %for.cond29
  br label %for.cond41

for.cond41:                                       ; preds = %for.inc50, %for.end40
  %38 = load i32, ptr %i, align 4
  %conv42 = sext i32 %38 to i64
  %cmp43 = icmp ult i64 %conv42, 31
  br i1 %cmp43, label %for.body45, label %for.end52

for.body45:                                       ; preds = %for.cond41
  %39 = load i32, ptr %i, align 4
  %idxprom46 = sext i32 %39 to i64
  %arrayidx47 = getelementptr [31 x i32], ptr @tcg_target_reg_alloc_order, i64 0, i64 %idxprom46
  %40 = load i32, ptr %arrayidx47, align 4
  %41 = load i32, ptr %i, align 4
  %idxprom48 = sext i32 %41 to i64
  %arrayidx49 = getelementptr [31 x i32], ptr @indirect_reg_alloc_order, i64 0, i64 %idxprom48
  store i32 %40, ptr %arrayidx49, align 4
  br label %for.inc50

for.inc50:                                        ; preds = %for.body45
  %42 = load i32, ptr %i, align 4
  %inc51 = add i32 %42, 1
  store i32 %inc51, ptr %i, align 4
  br label %for.cond41, !llvm.loop !11

for.end52:                                        ; preds = %for.cond41
  %43 = load ptr, ptr %s, align 8
  call void @alloc_tcg_plugin_context(ptr noundef %43)
  %44 = load ptr, ptr %s, align 8
  %45 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  store ptr %44, ptr %45, align 8
  %46 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  store ptr %46, ptr @tcg_ctxs, align 8
  store i32 1, ptr @tcg_cur_ctxs, align 4
  store i32 1, ptr @tcg_max_ctxs, align 4
  br label %do.body

do.body:                                          ; preds = %for.end52
  %47 = load ptr, ptr %s, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %47, i32 0, i32 16
  %48 = load i32, ptr %reserved_regs, align 4
  %shr53 = lshr i32 %48, 5
  %and54 = and i32 %shr53, 1
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %do.body
  unreachable

if.end57:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end57
  %49 = load ptr, ptr %s, align 8
  %call58 = call ptr @tcg_global_reg_new_internal(ptr noundef %49, i32 noundef 1, i32 noundef 5, ptr noundef @.str.10)
  store ptr %call58, ptr %ts, align 8
  %50 = load ptr, ptr %ts, align 8
  %call59 = call ptr @temp_tcgv_ptr(ptr noundef %50)
  store ptr %call59, ptr @tcg_env, align 8
  ret void
}

declare void @tcg_region_init(i64 noundef, i32 noundef, i32 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_tb_alloc(ptr noundef %s) #0 {
entry:
  %retval = alloca ptr, align 8
  %s.addr = alloca ptr, align 8
  %align = alloca i64, align 8
  %tb = alloca ptr, align 8
  %next = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load i32, ptr @qemu_icache_linesize, align 4
  %conv = sext i32 %0 to i64
  store i64 %conv, ptr %align, align 8
  br label %retry

retry:                                            ; preds = %if.end, %entry
  %1 = load ptr, ptr %s.addr, align 8
  %code_gen_ptr = getelementptr inbounds %struct.TCGContext, ptr %1, i32 0, i32 26
  %2 = load ptr, ptr %code_gen_ptr, align 8
  %3 = ptrtoint ptr %2 to i64
  %4 = load i64, ptr %align, align 8
  %add = add i64 %3, %4
  %sub = sub i64 %add, 1
  %5 = load i64, ptr %align, align 8
  %sub1 = sub i64 0, %5
  %and = and i64 %sub, %sub1
  %6 = inttoptr i64 %and to ptr
  store ptr %6, ptr %tb, align 8
  %7 = load ptr, ptr %tb, align 8
  %add.ptr = getelementptr %struct.TranslationBlock, ptr %7, i64 1
  %8 = ptrtoint ptr %add.ptr to i64
  %9 = load i64, ptr %align, align 8
  %add2 = add i64 %8, %9
  %sub3 = sub i64 %add2, 1
  %10 = load i64, ptr %align, align 8
  %sub4 = sub i64 0, %10
  %and5 = and i64 %sub3, %sub4
  %11 = inttoptr i64 %and5 to ptr
  store ptr %11, ptr %next, align 8
  %12 = load ptr, ptr %next, align 8
  %13 = load ptr, ptr %s.addr, align 8
  %code_gen_highwater = getelementptr inbounds %struct.TCGContext, ptr %13, i32 0, i32 28
  %14 = load ptr, ptr %code_gen_highwater, align 8
  %cmp = icmp ugt ptr %12, %14
  %lnot = xor i1 %cmp, true
  %lnot7 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv8, 0
  br i1 %tobool, label %if.then, label %if.end10

if.then:                                          ; preds = %retry
  %15 = load ptr, ptr %s.addr, align 8
  %call = call zeroext i1 @tcg_region_alloc(ptr noundef %15)
  br i1 %call, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.then
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  br label %retry

if.end10:                                         ; preds = %retry
  br label %do.body

do.body:                                          ; preds = %if.end10
  br label %while.cond

while.cond:                                       ; preds = %do.end, %do.body
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body11

do.body11:                                        ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 1407, ptr noundef @__func__.tcg_tb_alloc, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %16 = load ptr, ptr %s.addr, align 8
  %code_gen_ptr12 = getelementptr inbounds %struct.TCGContext, ptr %16, i32 0, i32 26
  %17 = load ptr, ptr %next, align 8
  store ptr %17, ptr %.atomictmp, align 8
  %18 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %18, ptr %code_gen_ptr12 monotonic, align 8
  br label %do.end13

do.end13:                                         ; preds = %while.end
  %19 = load ptr, ptr %s.addr, align 8
  %data_gen_ptr = getelementptr inbounds %struct.TCGContext, ptr %19, i32 0, i32 27
  store ptr null, ptr %data_gen_ptr, align 8
  %20 = load ptr, ptr %tb, align 8
  store ptr %20, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end13, %if.then9
  %21 = load ptr, ptr %retval, align 8
  ret ptr %21
}

declare zeroext i1 @tcg_region_alloc(ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_prologue_init() #0 {
entry:
  %s = alloca ptr, align 8
  %prologue_size = alloca i64, align 8
  %result = alloca i32, align 4
  %logfile = alloca ptr, align 8
  %code_size = alloca i64, align 8
  %data_size = alloca i64, align 8
  %i = alloca i64, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %code_gen_ptr = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 26
  %3 = load ptr, ptr %code_gen_ptr, align 8
  %4 = load ptr, ptr %s, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 23
  store ptr %3, ptr %code_ptr, align 8
  %5 = load ptr, ptr %s, align 8
  %code_gen_ptr1 = getelementptr inbounds %struct.TCGContext, ptr %5, i32 0, i32 26
  %6 = load ptr, ptr %code_gen_ptr1, align 8
  %7 = load ptr, ptr %s, align 8
  %code_buf = getelementptr inbounds %struct.TCGContext, ptr %7, i32 0, i32 22
  store ptr %6, ptr %code_buf, align 8
  %8 = load ptr, ptr %s, align 8
  %data_gen_ptr = getelementptr inbounds %struct.TCGContext, ptr %8, i32 0, i32 27
  store ptr null, ptr %data_gen_ptr, align 8
  %9 = load ptr, ptr %s, align 8
  %code_ptr2 = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 23
  %10 = load ptr, ptr %code_ptr2, align 8
  %call = call ptr @tcg_splitwx_to_rx(ptr noundef %10)
  store ptr %call, ptr @tcg_qemu_tb_exec, align 8
  %11 = load ptr, ptr %s, align 8
  %pool_labels = getelementptr inbounds %struct.TCGContext, ptr %11, i32 0, i32 31
  store ptr null, ptr %pool_labels, align 8
  call void @qemu_thread_jit_write()
  %12 = load ptr, ptr %s, align 8
  call void @tcg_target_qemu_prologue(ptr noundef %12)
  %13 = load ptr, ptr %s, align 8
  %call3 = call i32 @tcg_out_pool_finalize(ptr noundef %13)
  store i32 %call3, ptr %result, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %14 = load i32, ptr %result, align 4
  %cmp = icmp eq i32 %14, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %15 = load ptr, ptr %s, align 8
  %call4 = call i64 @tcg_current_code_size(ptr noundef %15)
  store i64 %call4, ptr %prologue_size, align 8
  %16 = load ptr, ptr %s, align 8
  %code_gen_ptr5 = getelementptr inbounds %struct.TCGContext, ptr %16, i32 0, i32 26
  %17 = load ptr, ptr %code_gen_ptr5, align 8
  %18 = load i64, ptr %prologue_size, align 8
  call void @perf_report_prologue(ptr noundef %17, i64 noundef %18)
  %19 = load ptr, ptr %s, align 8
  %code_buf6 = getelementptr inbounds %struct.TCGContext, ptr %19, i32 0, i32 22
  %20 = load ptr, ptr %code_buf6, align 8
  %call7 = call ptr @tcg_splitwx_to_rx(ptr noundef %20)
  %21 = ptrtoint ptr %call7 to i64
  %22 = load ptr, ptr %s, align 8
  %code_buf8 = getelementptr inbounds %struct.TCGContext, ptr %22, i32 0, i32 22
  %23 = load ptr, ptr %code_buf8, align 8
  %24 = ptrtoint ptr %23 to i64
  %25 = load i64, ptr %prologue_size, align 8
  call void @flush_idcache_range(i64 noundef %21, i64 noundef %24, i64 noundef %25)
  %call9 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 1)
  br i1 %call9, label %if.then10, label %if.end29

if.then10:                                        ; preds = %do.end
  %call11 = call ptr @qemu_log_trylock()
  store ptr %call11, ptr %logfile, align 8
  %26 = load ptr, ptr %logfile, align 8
  %tobool = icmp ne ptr %26, null
  br i1 %tobool, label %if.then12, label %if.end28

if.then12:                                        ; preds = %if.then10
  %27 = load ptr, ptr %logfile, align 8
  %28 = load i64, ptr %prologue_size, align 8
  %call13 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %27, ptr noundef @.str.2, i64 noundef %28)
  %29 = load ptr, ptr %s, align 8
  %data_gen_ptr14 = getelementptr inbounds %struct.TCGContext, ptr %29, i32 0, i32 27
  %30 = load ptr, ptr %data_gen_ptr14, align 8
  %tobool15 = icmp ne ptr %30, null
  br i1 %tobool15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.then12
  %31 = load ptr, ptr %s, align 8
  %data_gen_ptr17 = getelementptr inbounds %struct.TCGContext, ptr %31, i32 0, i32 27
  %32 = load ptr, ptr %data_gen_ptr17, align 8
  %33 = load ptr, ptr %s, align 8
  %code_gen_ptr18 = getelementptr inbounds %struct.TCGContext, ptr %33, i32 0, i32 26
  %34 = load ptr, ptr %code_gen_ptr18, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %32 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %34 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, ptr %code_size, align 8
  %35 = load i64, ptr %prologue_size, align 8
  %36 = load i64, ptr %code_size, align 8
  %sub = sub i64 %35, %36
  store i64 %sub, ptr %data_size, align 8
  %37 = load ptr, ptr %logfile, align 8
  %38 = load ptr, ptr %s, align 8
  %code_gen_ptr19 = getelementptr inbounds %struct.TCGContext, ptr %38, i32 0, i32 26
  %39 = load ptr, ptr %code_gen_ptr19, align 8
  %40 = load i64, ptr %code_size, align 8
  call void @disas(ptr noundef %37, ptr noundef %39, i64 noundef %40)
  store i64 0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then16
  %41 = load i64, ptr %i, align 8
  %42 = load i64, ptr %data_size, align 8
  %cmp20 = icmp ult i64 %41, %42
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %43 = load ptr, ptr %logfile, align 8
  %44 = load ptr, ptr %s, align 8
  %data_gen_ptr21 = getelementptr inbounds %struct.TCGContext, ptr %44, i32 0, i32 27
  %45 = load ptr, ptr %data_gen_ptr21, align 8
  %46 = ptrtoint ptr %45 to i64
  %47 = load i64, ptr %i, align 8
  %add = add i64 %46, %47
  %48 = load ptr, ptr %s, align 8
  %data_gen_ptr22 = getelementptr inbounds %struct.TCGContext, ptr %48, i32 0, i32 27
  %49 = load ptr, ptr %data_gen_ptr22, align 8
  %50 = load i64, ptr %i, align 8
  %add.ptr = getelementptr i8, ptr %49, i64 %50
  %51 = load i64, ptr %add.ptr, align 8
  %call23 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %43, ptr noundef @.str.3, i64 noundef %add, i64 noundef %51)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %52 = load i64, ptr %i, align 8
  %add24 = add i64 %52, 8
  store i64 %add24, ptr %i, align 8
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %for.cond
  br label %if.end26

if.else:                                          ; preds = %if.then12
  %53 = load ptr, ptr %logfile, align 8
  %54 = load ptr, ptr %s, align 8
  %code_gen_ptr25 = getelementptr inbounds %struct.TCGContext, ptr %54, i32 0, i32 26
  %55 = load ptr, ptr %code_gen_ptr25, align 8
  %56 = load i64, ptr %prologue_size, align 8
  call void @disas(ptr noundef %53, ptr noundef %55, i64 noundef %56)
  br label %if.end26

if.end26:                                         ; preds = %if.else, %for.end
  %57 = load ptr, ptr %logfile, align 8
  %call27 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %57, ptr noundef @.str.4)
  %58 = load ptr, ptr %logfile, align 8
  call void @qemu_log_unlock(ptr noundef %58)
  br label %if.end28

if.end28:                                         ; preds = %if.end26, %if.then10
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %do.end
  br label %do.body30

do.body30:                                        ; preds = %if.end29
  %59 = load ptr, ptr @tcg_code_gen_epilogue, align 8
  %cmp31 = icmp ne ptr %59, null
  br i1 %cmp31, label %if.end33, label %if.then32

if.then32:                                        ; preds = %do.body30
  unreachable

if.end33:                                         ; preds = %do.body30
  br label %do.end34

do.end34:                                         ; preds = %if.end33
  %60 = load ptr, ptr %s, align 8
  call void @tcg_region_prologue_set(ptr noundef %60)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_splitwx_to_rx(ptr noundef %rw) #0 {
entry:
  %rw.addr = alloca ptr, align 8
  store ptr %rw, ptr %rw.addr, align 8
  %0 = load ptr, ptr %rw.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %rw.addr, align 8
  %2 = load i64, ptr @tcg_splitwx_diff, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 %2
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %add.ptr, %cond.true ], [ null, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_thread_jit_write() #0 {
entry:
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_target_qemu_prologue(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %stack_addend = alloca i32, align 4
  %seg = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 1160, ptr %stack_addend, align 4
  %0 = load ptr, ptr %s.addr, align 8
  call void @tcg_set_frame(ptr noundef %0, i32 noundef 4, i64 noundef 128, i64 noundef 1024)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %conv = sext i32 %1 to i64
  %cmp = icmp ult i64 %conv, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [6 x i32], ptr @tcg_target_callee_save_regs, i64 0, i64 %idxprom
  %4 = load i32, ptr %arrayidx, align 4
  call void @tcg_out_push(ptr noundef %2, i32 noundef %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, ptr %i, align 4
  %inc = add i32 %5, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !13

for.end:                                          ; preds = %for.cond
  %6 = load i8, ptr @tcg_use_softmmu, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %if.end14, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.end
  %7 = load i64, ptr @guest_base, align 8
  %tobool2 = icmp ne i64 %7, 0
  br i1 %tobool2, label %if.then, label %if.end14

if.then:                                          ; preds = %land.lhs.true
  %call = call i32 @setup_guest_base_seg()
  store i32 %call, ptr %seg, align 4
  %8 = load i32, ptr %seg, align 4
  %cmp3 = icmp ne i32 %8, 0
  br i1 %cmp3, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then
  %9 = load i32, ptr %seg, align 4
  store i32 %9, ptr getelementptr inbounds (%struct.HostAddress, ptr @x86_guest_base, i32 0, i32 3), align 4
  br label %if.end13

if.else:                                          ; preds = %if.then
  %10 = load i64, ptr @guest_base, align 8
  %11 = load i64, ptr @guest_base, align 8
  %conv6 = trunc i64 %11 to i32
  %conv7 = sext i32 %conv6 to i64
  %cmp8 = icmp eq i64 %10, %conv7
  br i1 %cmp8, label %if.then10, label %if.else12

if.then10:                                        ; preds = %if.else
  %12 = load i64, ptr @guest_base, align 8
  %conv11 = trunc i64 %12 to i32
  store i32 %conv11, ptr getelementptr inbounds (%struct.HostAddress, ptr @x86_guest_base, i32 0, i32 2), align 4
  br label %if.end

if.else12:                                        ; preds = %if.else
  store i32 12, ptr getelementptr inbounds (%struct.HostAddress, ptr @x86_guest_base, i32 0, i32 1), align 4
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load i32, ptr getelementptr inbounds (%struct.HostAddress, ptr @x86_guest_base, i32 0, i32 1), align 4
  %15 = load i64, ptr @guest_base, align 8
  call void @tcg_out_movi(ptr noundef %13, i32 noundef 1, i32 noundef %14, i64 noundef %15)
  %16 = load i32, ptr getelementptr inbounds (%struct.HostAddress, ptr @x86_guest_base, i32 0, i32 1), align 4
  %shl = shl i32 1, %16
  %17 = load ptr, ptr %s.addr, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %17, i32 0, i32 16
  %18 = load i32, ptr %reserved_regs, align 4
  %or = or i32 %18, %shl
  store i32 %or, ptr %reserved_regs, align 4
  br label %if.end

if.end:                                           ; preds = %if.else12, %if.then10
  br label %if.end13

if.end13:                                         ; preds = %if.end, %if.then5
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %land.lhs.true, %for.end
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %call15 = call zeroext i1 @tcg_out_mov(ptr noundef %19, i32 noundef 1, i32 noundef 5, i32 noundef %20)
  %21 = load ptr, ptr %s.addr, align 8
  %22 = load i32, ptr %stack_addend, align 4
  %sub = sub i32 0, %22
  %conv16 = sext i32 %sub to i64
  call void @tcg_out_addi(ptr noundef %21, i32 noundef 4, i64 noundef %conv16)
  %23 = load ptr, ptr %s.addr, align 8
  %24 = load i32, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 1), align 4
  call void @tcg_out_modrm(ptr noundef %23, i32 noundef 255, i32 noundef 4, i32 noundef %24)
  %25 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %25, i32 0, i32 23
  %26 = load ptr, ptr %code_ptr, align 8
  %call17 = call ptr @tcg_splitwx_to_rx(ptr noundef %26)
  store ptr %call17, ptr @tcg_code_gen_epilogue, align 8
  %27 = load ptr, ptr %s.addr, align 8
  call void @tcg_out_movi(ptr noundef %27, i32 noundef 1, i32 noundef 0, i64 noundef 0)
  %28 = load ptr, ptr %s.addr, align 8
  %code_ptr18 = getelementptr inbounds %struct.TCGContext, ptr %28, i32 0, i32 23
  %29 = load ptr, ptr %code_ptr18, align 8
  %call19 = call ptr @tcg_splitwx_to_rx(ptr noundef %29)
  store ptr %call19, ptr @tb_ret_addr, align 8
  %30 = load ptr, ptr %s.addr, align 8
  %31 = load i32, ptr %stack_addend, align 4
  %conv20 = sext i32 %31 to i64
  call void @tcg_out_addi(ptr noundef %30, i32 noundef 4, i64 noundef %conv20)
  %32 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %32, 1024
  %tobool21 = icmp ne i32 %and, 0
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end14
  %33 = load ptr, ptr %s.addr, align 8
  call void @tcg_out_vex_opc(ptr noundef %33, i32 noundef 375, i32 noundef 0, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.end14
  store i32 5, ptr %i, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc30, %if.end23
  %34 = load i32, ptr %i, align 4
  %cmp25 = icmp sge i32 %34, 0
  br i1 %cmp25, label %for.body27, label %for.end31

for.body27:                                       ; preds = %for.cond24
  %35 = load ptr, ptr %s.addr, align 8
  %36 = load i32, ptr %i, align 4
  %idxprom28 = sext i32 %36 to i64
  %arrayidx29 = getelementptr [6 x i32], ptr @tcg_target_callee_save_regs, i64 0, i64 %idxprom28
  %37 = load i32, ptr %arrayidx29, align 4
  call void @tcg_out_pop(ptr noundef %35, i32 noundef %37)
  br label %for.inc30

for.inc30:                                        ; preds = %for.body27
  %38 = load i32, ptr %i, align 4
  %dec = add i32 %38, -1
  store i32 %dec, ptr %i, align 4
  br label %for.cond24, !llvm.loop !14

for.end31:                                        ; preds = %for.cond24
  %39 = load ptr, ptr %s.addr, align 8
  call void @tcg_out_opc(ptr noundef %39, i32 noundef 195, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_out_pool_finalize(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  %l = alloca ptr, align 8
  %a = alloca ptr, align 8
  %size = alloca i64, align 8
  %value = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %pool_labels = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 31
  %1 = load ptr, ptr %pool_labels, align 8
  store ptr %1, ptr %p, align 8
  store ptr null, ptr %l, align 8
  %2 = load ptr, ptr %p, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %3 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %3, i32 0, i32 23
  %4 = load ptr, ptr %code_ptr, align 8
  %5 = ptrtoint ptr %4 to i64
  %6 = load ptr, ptr %p, align 8
  %nlong = getelementptr inbounds %struct.TCGLabelPoolData, ptr %6, i32 0, i32 4
  %7 = load i32, ptr %nlong, align 4
  %conv = zext i32 %7 to i64
  %mul = mul i64 8, %conv
  %add = add i64 %5, %mul
  %sub = sub i64 %add, 1
  %8 = load ptr, ptr %p, align 8
  %nlong1 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %8, i32 0, i32 4
  %9 = load i32, ptr %nlong1, align 4
  %conv2 = zext i32 %9 to i64
  %mul3 = mul i64 8, %conv2
  %sub4 = sub i64 0, %mul3
  %and = and i64 %sub, %sub4
  %10 = inttoptr i64 %and to ptr
  store ptr %10, ptr %a, align 8
  %11 = load ptr, ptr %s.addr, align 8
  %code_ptr5 = getelementptr inbounds %struct.TCGContext, ptr %11, i32 0, i32 23
  %12 = load ptr, ptr %code_ptr5, align 8
  %13 = load ptr, ptr %a, align 8
  %14 = load ptr, ptr %s.addr, align 8
  %code_ptr6 = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 23
  %15 = load ptr, ptr %code_ptr6, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %13 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %15 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv7 = trunc i64 %sub.ptr.sub to i32
  call void @tcg_out_nop_fill(ptr noundef %12, i32 noundef %conv7)
  %16 = load ptr, ptr %a, align 8
  %17 = load ptr, ptr %s.addr, align 8
  %data_gen_ptr = getelementptr inbounds %struct.TCGContext, ptr %17, i32 0, i32 27
  store ptr %16, ptr %data_gen_ptr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %18 = load ptr, ptr %p, align 8
  %cmp8 = icmp ne ptr %18, null
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %19 = load ptr, ptr %p, align 8
  %nlong10 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %19, i32 0, i32 4
  %20 = load i32, ptr %nlong10, align 4
  %conv11 = zext i32 %20 to i64
  %mul12 = mul i64 8, %conv11
  store i64 %mul12, ptr %size, align 8
  %21 = load ptr, ptr %l, align 8
  %tobool = icmp ne ptr %21, null
  br i1 %tobool, label %lor.lhs.false, label %if.then21

lor.lhs.false:                                    ; preds = %for.body
  %22 = load ptr, ptr %l, align 8
  %nlong13 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %22, i32 0, i32 4
  %23 = load i32, ptr %nlong13, align 4
  %24 = load ptr, ptr %p, align 8
  %nlong14 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %24, i32 0, i32 4
  %25 = load i32, ptr %nlong14, align 4
  %cmp15 = icmp ne i32 %23, %25
  br i1 %cmp15, label %if.then21, label %lor.lhs.false17

lor.lhs.false17:                                  ; preds = %lor.lhs.false
  %26 = load ptr, ptr %l, align 8
  %data = getelementptr inbounds %struct.TCGLabelPoolData, ptr %26, i32 0, i32 5
  %arraydecay = getelementptr inbounds [0 x i64], ptr %data, i64 0, i64 0
  %27 = load ptr, ptr %p, align 8
  %data18 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %27, i32 0, i32 5
  %arraydecay19 = getelementptr inbounds [0 x i64], ptr %data18, i64 0, i64 0
  %28 = load i64, ptr %size, align 8
  %call = call i32 @memcmp(ptr noundef %arraydecay, ptr noundef %arraydecay19, i64 noundef %28) #18
  %tobool20 = icmp ne i32 %call, 0
  br i1 %tobool20, label %if.then21, label %if.end31

if.then21:                                        ; preds = %lor.lhs.false17, %lor.lhs.false, %for.body
  %29 = load ptr, ptr %a, align 8
  %30 = load ptr, ptr %s.addr, align 8
  %code_gen_highwater = getelementptr inbounds %struct.TCGContext, ptr %30, i32 0, i32 28
  %31 = load ptr, ptr %code_gen_highwater, align 8
  %cmp22 = icmp ugt ptr %29, %31
  %lnot = xor i1 %cmp22, true
  %lnot24 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot24 to i32
  %conv25 = sext i32 %lnot.ext to i64
  %tobool26 = icmp ne i64 %conv25, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.then21
  store i32 -1, ptr %retval, align 4
  br label %return

if.end28:                                         ; preds = %if.then21
  %32 = load ptr, ptr %a, align 8
  %33 = load ptr, ptr %p, align 8
  %data29 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %33, i32 0, i32 5
  %arraydecay30 = getelementptr inbounds [0 x i64], ptr %data29, i64 0, i64 0
  %34 = load i64, ptr %size, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %32, ptr align 8 %arraydecay30, i64 %34, i1 false)
  %35 = load i64, ptr %size, align 8
  %36 = load ptr, ptr %a, align 8
  %add.ptr = getelementptr i8, ptr %36, i64 %35
  store ptr %add.ptr, ptr %a, align 8
  %37 = load ptr, ptr %p, align 8
  store ptr %37, ptr %l, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.end28, %lor.lhs.false17
  %38 = load ptr, ptr %a, align 8
  %call32 = call ptr @tcg_splitwx_to_rx(ptr noundef %38)
  %39 = ptrtoint ptr %call32 to i64
  %40 = load i64, ptr %size, align 8
  %sub33 = sub i64 %39, %40
  store i64 %sub33, ptr %value, align 8
  %41 = load ptr, ptr %p, align 8
  %label = getelementptr inbounds %struct.TCGLabelPoolData, ptr %41, i32 0, i32 1
  %42 = load ptr, ptr %label, align 8
  %43 = load ptr, ptr %p, align 8
  %rtype = getelementptr inbounds %struct.TCGLabelPoolData, ptr %43, i32 0, i32 3
  %44 = load i32, ptr %rtype, align 8
  %45 = load i64, ptr %value, align 8
  %46 = load ptr, ptr %p, align 8
  %addend = getelementptr inbounds %struct.TCGLabelPoolData, ptr %46, i32 0, i32 2
  %47 = load i64, ptr %addend, align 8
  %call34 = call zeroext i1 @patch_reloc(ptr noundef %42, i32 noundef %44, i64 noundef %45, i64 noundef %47)
  br i1 %call34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.end31
  store i32 -2, ptr %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.end31
  br label %for.inc

for.inc:                                          ; preds = %if.end36
  %48 = load ptr, ptr %p, align 8
  %next = getelementptr inbounds %struct.TCGLabelPoolData, ptr %48, i32 0, i32 0
  %49 = load ptr, ptr %next, align 8
  store ptr %49, ptr %p, align 8
  br label %for.cond, !llvm.loop !15

for.end:                                          ; preds = %for.cond
  %50 = load ptr, ptr %a, align 8
  %51 = load ptr, ptr %s.addr, align 8
  %code_ptr37 = getelementptr inbounds %struct.TCGContext, ptr %51, i32 0, i32 23
  store ptr %50, ptr %code_ptr37, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then35, %if.then27, %if.then
  %52 = load i32, ptr %retval, align 4
  ret i32 %52
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @tcg_current_code_size(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 23
  %1 = load ptr, ptr %code_ptr, align 8
  %2 = load ptr, ptr %s.addr, align 8
  %code_buf = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 22
  %3 = load ptr, ptr %code_buf, align 8
  %call = call i64 @tcg_ptr_byte_diff(ptr noundef %1, ptr noundef %3)
  ret i64 %call
}

declare void @perf_report_prologue(ptr noundef, i64 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal void @flush_idcache_range(i64 noundef %rx, i64 noundef %rw, i64 noundef %len) #0 {
entry:
  %rx.addr = alloca i64, align 8
  %rw.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  store i64 %rx, ptr %rx.addr, align 8
  store i64 %rw, ptr %rw.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @qemu_loglevel_mask(i32 noundef %mask) #0 {
entry:
  %mask.addr = alloca i32, align 4
  store i32 %mask, ptr %mask.addr, align 4
  %0 = load i32, ptr @qemu_loglevel, align 4
  %1 = load i32, ptr %mask.addr, align 4
  %and = and i32 %0, %1
  %cmp = icmp ne i32 %and, 0
  ret i1 %cmp
}

declare ptr @qemu_log_trylock() #7

declare i32 @fprintf(ptr noundef, ptr noundef, ...) #7

declare void @disas(ptr noundef, ptr noundef, i64 noundef) #7

declare void @qemu_log_unlock(ptr noundef) #7

declare void @tcg_region_prologue_set(ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_func_start(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  call void @tcg_pool_reset(ptr noundef %0)
  %1 = load ptr, ptr %s.addr, align 8
  %nb_globals = getelementptr inbounds %struct.TCGContext, ptr %1, i32 0, i32 6
  %2 = load i32, ptr %nb_globals, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %nb_temps = getelementptr inbounds %struct.TCGContext, ptr %3, i32 0, i32 7
  store i32 %2, ptr %nb_temps, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %free_temps = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 36
  %arraydecay = getelementptr inbounds [6 x %struct.TCGTempSet], ptr %free_temps, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay, i8 0, i64 384, i1 false)
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %5, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %s.addr, align 8
  %const_table = getelementptr inbounds %struct.TCGContext, ptr %6, i32 0, i32 35
  %7 = load i32, ptr %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr [6 x ptr], ptr %const_table, i64 0, i64 %idxprom
  %8 = load ptr, ptr %arrayidx, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %9 = load ptr, ptr %s.addr, align 8
  %const_table1 = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 35
  %10 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %10 to i64
  %arrayidx3 = getelementptr [6 x ptr], ptr %const_table1, i64 0, i64 %idxprom2
  %11 = load ptr, ptr %arrayidx3, align 8
  call void @g_hash_table_remove_all(ptr noundef %11)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %12 = load i32, ptr %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !16

for.end:                                          ; preds = %for.cond
  %13 = load ptr, ptr %s.addr, align 8
  %nb_ops = getelementptr inbounds %struct.TCGContext, ptr %13, i32 0, i32 9
  store i32 0, ptr %nb_ops, align 8
  %14 = load ptr, ptr %s.addr, align 8
  %nb_labels = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 5
  store i32 0, ptr %nb_labels, align 8
  %15 = load ptr, ptr %s.addr, align 8
  %frame_start = getelementptr inbounds %struct.TCGContext, ptr %15, i32 0, i32 18
  %16 = load i64, ptr %frame_start, align 8
  %17 = load ptr, ptr %s.addr, align 8
  %current_frame_offset = getelementptr inbounds %struct.TCGContext, ptr %17, i32 0, i32 17
  store i64 %16, ptr %current_frame_offset, align 8
  br label %do.body

do.body:                                          ; preds = %for.end
  %18 = load ptr, ptr %s.addr, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %18, i32 0, i32 38
  store ptr null, ptr %ops, align 8
  %19 = load ptr, ptr %s.addr, align 8
  %ops4 = getelementptr inbounds %struct.TCGContext, ptr %19, i32 0, i32 38
  %20 = load ptr, ptr %s.addr, align 8
  %ops5 = getelementptr inbounds %struct.TCGContext, ptr %20, i32 0, i32 38
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %ops5, i32 0, i32 1
  store ptr %ops4, ptr %tql_prev, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body6

do.body6:                                         ; preds = %do.end
  %21 = load ptr, ptr %s.addr, align 8
  %free_ops = getelementptr inbounds %struct.TCGContext, ptr %21, i32 0, i32 39
  store ptr null, ptr %free_ops, align 8
  %22 = load ptr, ptr %s.addr, align 8
  %free_ops7 = getelementptr inbounds %struct.TCGContext, ptr %22, i32 0, i32 39
  %23 = load ptr, ptr %s.addr, align 8
  %free_ops8 = getelementptr inbounds %struct.TCGContext, ptr %23, i32 0, i32 39
  %tql_prev9 = getelementptr inbounds %struct.QTailQLink, ptr %free_ops8, i32 0, i32 1
  store ptr %free_ops7, ptr %tql_prev9, align 8
  br label %do.end10

do.end10:                                         ; preds = %do.body6
  br label %do.body11

do.body11:                                        ; preds = %do.end10
  %24 = load ptr, ptr %s.addr, align 8
  %labels = getelementptr inbounds %struct.TCGContext, ptr %24, i32 0, i32 40
  %sqh_first = getelementptr inbounds %struct.anon.4, ptr %labels, i32 0, i32 0
  store ptr null, ptr %sqh_first, align 8
  %25 = load ptr, ptr %s.addr, align 8
  %labels12 = getelementptr inbounds %struct.TCGContext, ptr %25, i32 0, i32 40
  %sqh_first13 = getelementptr inbounds %struct.anon.4, ptr %labels12, i32 0, i32 0
  %26 = load ptr, ptr %s.addr, align 8
  %labels14 = getelementptr inbounds %struct.TCGContext, ptr %26, i32 0, i32 40
  %sqh_last = getelementptr inbounds %struct.anon.4, ptr %labels14, i32 0, i32 1
  store ptr %sqh_first13, ptr %sqh_last, align 8
  br label %do.end15

do.end15:                                         ; preds = %do.body11
  br label %do.body16

do.body16:                                        ; preds = %do.end15
  %27 = load ptr, ptr %s.addr, align 8
  %addr_type = getelementptr inbounds %struct.TCGContext, ptr %27, i32 0, i32 10
  %28 = load i32, ptr %addr_type, align 4
  %cmp17 = icmp eq i32 %28, 0
  br i1 %cmp17, label %if.end21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body16
  %29 = load ptr, ptr %s.addr, align 8
  %addr_type18 = getelementptr inbounds %struct.TCGContext, ptr %29, i32 0, i32 10
  %30 = load i32, ptr %addr_type18, align 4
  %cmp19 = icmp eq i32 %30, 1
  br i1 %cmp19, label %if.end21, label %if.then20

if.then20:                                        ; preds = %lor.lhs.false
  unreachable

if.end21:                                         ; preds = %lor.lhs.false, %do.body16
  br label %do.end22

do.end22:                                         ; preds = %if.end21
  br label %do.body23

do.body23:                                        ; preds = %do.end22
  %31 = load ptr, ptr %s.addr, align 8
  %insn_start_words = getelementptr inbounds %struct.TCGContext, ptr %31, i32 0, i32 14
  %32 = load i8, ptr %insn_start_words, align 2
  %conv = zext i8 %32 to i32
  %cmp24 = icmp sgt i32 %conv, 0
  br i1 %cmp24, label %if.end27, label %if.then26

if.then26:                                        ; preds = %do.body23
  unreachable

if.end27:                                         ; preds = %do.body23
  br label %do.end28

do.end28:                                         ; preds = %if.end27
  ret void
}

declare void @g_hash_table_remove_all(ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_set_frame(ptr noundef %s, i32 noundef %reg, i64 noundef %start, i64 noundef %size) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %reg.addr = alloca i32, align 4
  %start.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %reg, ptr %reg.addr, align 4
  store i64 %start, ptr %start.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  %0 = load i64, ptr %start.addr, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %frame_start = getelementptr inbounds %struct.TCGContext, ptr %1, i32 0, i32 18
  store i64 %0, ptr %frame_start, align 8
  %2 = load i64, ptr %start.addr, align 8
  %3 = load i64, ptr %size.addr, align 8
  %add = add i64 %2, %3
  %4 = load ptr, ptr %s.addr, align 8
  %frame_end = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 19
  store i64 %add, ptr %frame_end, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i32, ptr %reg.addr, align 4
  %call = call ptr @tcg_global_reg_new_internal(ptr noundef %5, i32 noundef 1, i32 noundef %6, ptr noundef @.str.5)
  %7 = load ptr, ptr %s.addr, align 8
  %frame_temp = getelementptr inbounds %struct.TCGContext, ptr %7, i32 0, i32 20
  store ptr %call, ptr %frame_temp, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_global_reg_new_internal(ptr noundef %s, i32 noundef %type, i32 noundef %reg, ptr noundef %name) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %reg.addr = alloca i32, align 4
  %name.addr = alloca ptr, align 8
  %ts = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %reg, ptr %reg.addr, align 4
  store ptr %name, ptr %name.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %s.addr, align 8
  %call = call ptr @tcg_global_alloc(ptr noundef %0)
  store ptr %call, ptr %ts, align 8
  %1 = load i32, ptr %type.addr, align 4
  %2 = load ptr, ptr %ts, align 8
  %3 = zext i32 %1 to i64
  %bf.load = load i64, ptr %2, align 8
  %bf.value = and i64 %3, 255
  %bf.shl = shl i64 %bf.value, 16
  %bf.clear = and i64 %bf.load, -16711681
  %bf.set = or i64 %bf.clear, %bf.shl
  store i64 %bf.set, ptr %2, align 8
  %4 = load i32, ptr %type.addr, align 4
  %5 = load ptr, ptr %ts, align 8
  %6 = zext i32 %4 to i64
  %bf.load1 = load i64, ptr %5, align 8
  %bf.value2 = and i64 %6, 255
  %bf.shl3 = shl i64 %bf.value2, 24
  %bf.clear4 = and i64 %bf.load1, -4278190081
  %bf.set5 = or i64 %bf.clear4, %bf.shl3
  store i64 %bf.set5, ptr %5, align 8
  %7 = load ptr, ptr %ts, align 8
  %bf.load7 = load i64, ptr %7, align 8
  %bf.clear8 = and i64 %bf.load7, -30064771073
  %bf.set9 = or i64 %bf.clear8, 12884901888
  store i64 %bf.set9, ptr %7, align 8
  %8 = load i32, ptr %reg.addr, align 4
  %9 = load ptr, ptr %ts, align 8
  %10 = zext i32 %8 to i64
  %bf.load10 = load i64, ptr %9, align 8
  %bf.value11 = and i64 %10, 255
  %bf.clear12 = and i64 %bf.load10, -256
  %bf.set13 = or i64 %bf.clear12, %bf.value11
  store i64 %bf.set13, ptr %9, align 8
  %11 = load ptr, ptr %name.addr, align 8
  %12 = load ptr, ptr %ts, align 8
  %name15 = getelementptr inbounds %struct.TCGTemp, ptr %12, i32 0, i32 4
  store ptr %11, ptr %name15, align 8
  %13 = load i32, ptr %reg.addr, align 4
  %shl = shl i32 1, %13
  %14 = load ptr, ptr %s.addr, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 16
  %15 = load i32, ptr %reserved_regs, align 4
  %or = or i32 %15, %shl
  store i32 %or, ptr %reserved_regs, align 4
  %16 = load ptr, ptr %ts, align 8
  ret ptr %16
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_global_mem_new_i32(ptr noundef %reg, i64 noundef %off, ptr noundef %name) #0 {
entry:
  %reg.addr = alloca ptr, align 8
  %off.addr = alloca i64, align 8
  %name.addr = alloca ptr, align 8
  %ts = alloca ptr, align 8
  store ptr %reg, ptr %reg.addr, align 8
  store i64 %off, ptr %off.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %reg.addr, align 8
  %1 = load i64, ptr %off.addr, align 8
  %2 = load ptr, ptr %name.addr, align 8
  %call = call ptr @tcg_global_mem_new_internal(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef 0)
  store ptr %call, ptr %ts, align 8
  %3 = load ptr, ptr %ts, align 8
  %call1 = call ptr @temp_tcgv_i32(ptr noundef %3)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_global_mem_new_internal(ptr noundef %base, i64 noundef %offset, ptr noundef %name, i32 noundef %type) #0 {
entry:
  %base.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %name.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  %base_ts = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %indirect_reg = alloca i32, align 4
  store ptr %base, ptr %base.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %s, align 8
  %2 = load ptr, ptr %base.addr, align 8
  %call = call ptr @tcgv_ptr_temp(ptr noundef %2)
  store ptr %call, ptr %base_ts, align 8
  %3 = load ptr, ptr %s, align 8
  %call1 = call ptr @tcg_global_alloc(ptr noundef %3)
  store ptr %call1, ptr %ts, align 8
  store i32 0, ptr %indirect_reg, align 4
  %4 = load ptr, ptr %base_ts, align 8
  %bf.load = load i64, ptr %4, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  switch i32 %bf.cast, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb2
  %5 = load ptr, ptr %base_ts, align 8
  %bf.load3 = load i64, ptr %5, align 8
  %bf.lshr4 = lshr i64 %bf.load3, 35
  %bf.clear5 = and i64 %bf.lshr4, 1
  %bf.cast6 = trunc i64 %bf.clear5 to i32
  %tobool = icmp ne i32 %bf.cast6, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %6 = load ptr, ptr %base_ts, align 8
  %bf.load7 = load i64, ptr %6, align 8
  %bf.clear8 = and i64 %bf.load7, -68719476737
  %bf.set = or i64 %bf.clear8, 68719476736
  store i64 %bf.set, ptr %6, align 8
  %7 = load ptr, ptr %s, align 8
  %nb_indirects = getelementptr inbounds %struct.TCGContext, ptr %7, i32 0, i32 8
  %8 = load i32, ptr %nb_indirects, align 4
  %add = add i32 %8, 1
  store i32 %add, ptr %nb_indirects, align 4
  store i32 1, ptr %indirect_reg, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body9

do.body9:                                         ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 1595, ptr noundef @__func__.tcg_global_mem_new_internal, ptr noundef null) #15
  unreachable

do.end10:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end10, %do.end, %sw.bb
  %9 = load i32, ptr %type.addr, align 4
  %10 = load ptr, ptr %ts, align 8
  %11 = zext i32 %9 to i64
  %bf.load11 = load i64, ptr %10, align 8
  %bf.value = and i64 %11, 255
  %bf.shl = shl i64 %bf.value, 16
  %bf.clear12 = and i64 %bf.load11, -16711681
  %bf.set13 = or i64 %bf.clear12, %bf.shl
  store i64 %bf.set13, ptr %10, align 8
  %12 = load i32, ptr %type.addr, align 4
  %13 = load ptr, ptr %ts, align 8
  %14 = zext i32 %12 to i64
  %bf.load14 = load i64, ptr %13, align 8
  %bf.value15 = and i64 %14, 255
  %bf.shl16 = shl i64 %bf.value15, 24
  %bf.clear17 = and i64 %bf.load14, -4278190081
  %bf.set18 = or i64 %bf.clear17, %bf.shl16
  store i64 %bf.set18, ptr %13, align 8
  %15 = load i32, ptr %indirect_reg, align 4
  %16 = load ptr, ptr %ts, align 8
  %17 = zext i32 %15 to i64
  %bf.load20 = load i64, ptr %16, align 8
  %bf.value21 = and i64 %17, 1
  %bf.shl22 = shl i64 %bf.value21, 35
  %bf.clear23 = and i64 %bf.load20, -34359738369
  %bf.set24 = or i64 %bf.clear23, %bf.shl22
  store i64 %bf.set24, ptr %16, align 8
  %18 = load ptr, ptr %ts, align 8
  %bf.load26 = load i64, ptr %18, align 8
  %bf.clear27 = and i64 %bf.load26, -274877906945
  %bf.set28 = or i64 %bf.clear27, 274877906944
  store i64 %bf.set28, ptr %18, align 8
  %19 = load ptr, ptr %base_ts, align 8
  %20 = load ptr, ptr %ts, align 8
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %20, i32 0, i32 2
  store ptr %19, ptr %mem_base, align 8
  %21 = load i64, ptr %offset.addr, align 8
  %22 = load ptr, ptr %ts, align 8
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %22, i32 0, i32 3
  store i64 %21, ptr %mem_offset, align 8
  %23 = load ptr, ptr %name.addr, align 8
  %24 = load ptr, ptr %ts, align 8
  %name29 = getelementptr inbounds %struct.TCGTemp, ptr %24, i32 0, i32 4
  store ptr %23, ptr %name29, align 8
  %25 = load ptr, ptr %ts, align 8
  ret ptr %25
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_global_mem_new_i64(ptr noundef %reg, i64 noundef %off, ptr noundef %name) #0 {
entry:
  %reg.addr = alloca ptr, align 8
  %off.addr = alloca i64, align 8
  %name.addr = alloca ptr, align 8
  %ts = alloca ptr, align 8
  store ptr %reg, ptr %reg.addr, align 8
  store i64 %off, ptr %off.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %reg.addr, align 8
  %1 = load i64, ptr %off.addr, align 8
  %2 = load ptr, ptr %name.addr, align 8
  %call = call ptr @tcg_global_mem_new_internal(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef 1)
  store ptr %call, ptr %ts, align 8
  %3 = load ptr, ptr %ts, align 8
  %call1 = call ptr @temp_tcgv_i64(ptr noundef %3)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @temp_tcgv_i64(ptr noundef %t) #0 {
entry:
  %t.addr = alloca ptr, align 8
  store ptr %t, ptr %t.addr, align 8
  %0 = load ptr, ptr %t.addr, align 8
  %call = call ptr @temp_tcgv_i32(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_global_mem_new_ptr(ptr noundef %reg, i64 noundef %off, ptr noundef %name) #0 {
entry:
  %reg.addr = alloca ptr, align 8
  %off.addr = alloca i64, align 8
  %name.addr = alloca ptr, align 8
  %ts = alloca ptr, align 8
  store ptr %reg, ptr %reg.addr, align 8
  store i64 %off, ptr %off.addr, align 8
  store ptr %name, ptr %name.addr, align 8
  %0 = load ptr, ptr %reg.addr, align 8
  %1 = load i64, ptr %off.addr, align 8
  %2 = load ptr, ptr %name.addr, align 8
  %call = call ptr @tcg_global_mem_new_internal(ptr noundef %0, i64 noundef %1, ptr noundef %2, i32 noundef 1)
  store ptr %call, ptr %ts, align 8
  %3 = load ptr, ptr %ts, align 8
  %call1 = call ptr @temp_tcgv_ptr(ptr noundef %3)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @temp_tcgv_ptr(ptr noundef %t) #0 {
entry:
  %t.addr = alloca ptr, align 8
  store ptr %t, ptr %t.addr, align 8
  %0 = load ptr, ptr %t.addr, align 8
  %call = call ptr @temp_tcgv_i32(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_temp_new_i32() #0 {
entry:
  %call = call ptr @tcg_temp_new_internal(i32 noundef 0, i32 noundef 1)
  %call1 = call ptr @temp_tcgv_i32(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_temp_new_internal(i32 noundef %type, i32 noundef %kind) #0 {
entry:
  %retval = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %kind.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %n = alloca i32, align 4
  %idx = alloca i32, align 4
  %i = alloca i32, align 4
  %ts2 = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %kind, ptr %kind.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %s, align 8
  %2 = load i32, ptr %kind.addr, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %s, align 8
  %free_temps = getelementptr inbounds %struct.TCGContext, ptr %3, i32 0, i32 36
  %4 = load i32, ptr %type.addr, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [6 x %struct.TCGTempSet], ptr %free_temps, i64 0, i64 %idxprom
  %l = getelementptr inbounds %struct.TCGTempSet, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i64], ptr %l, i64 0, i64 0
  %call = call i64 @find_first_bit(ptr noundef %arraydecay, i64 noundef 512)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %idx, align 4
  %5 = load i32, ptr %idx, align 4
  %cmp1 = icmp slt i32 %5, 512
  br i1 %cmp1, label %if.then3, label %if.end27

if.then3:                                         ; preds = %if.then
  %6 = load i32, ptr %idx, align 4
  %conv4 = sext i32 %6 to i64
  %7 = load ptr, ptr %s, align 8
  %free_temps5 = getelementptr inbounds %struct.TCGContext, ptr %7, i32 0, i32 36
  %8 = load i32, ptr %type.addr, align 4
  %idxprom6 = zext i32 %8 to i64
  %arrayidx7 = getelementptr [6 x %struct.TCGTempSet], ptr %free_temps5, i64 0, i64 %idxprom6
  %l8 = getelementptr inbounds %struct.TCGTempSet, ptr %arrayidx7, i32 0, i32 0
  %arraydecay9 = getelementptr inbounds [8 x i64], ptr %l8, i64 0, i64 0
  call void @clear_bit(i64 noundef %conv4, ptr noundef %arraydecay9)
  %9 = load ptr, ptr %s, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 37
  %10 = load i32, ptr %idx, align 4
  %idxprom10 = sext i32 %10 to i64
  %arrayidx11 = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom10
  store ptr %arrayidx11, ptr %ts, align 8
  %11 = load ptr, ptr %ts, align 8
  %bf.load = load i64, ptr %11, align 8
  %bf.clear = and i64 %bf.load, -549755813889
  %bf.set = or i64 %bf.clear, 549755813888
  store i64 %bf.set, ptr %11, align 8
  br label %do.body

do.body:                                          ; preds = %if.then3
  %12 = load ptr, ptr %ts, align 8
  %bf.load12 = load i64, ptr %12, align 8
  %bf.lshr = lshr i64 %bf.load12, 16
  %bf.clear13 = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear13 to i32
  %13 = load i32, ptr %type.addr, align 4
  %cmp14 = icmp eq i32 %bf.cast, %13
  br i1 %cmp14, label %if.end, label %if.then16

if.then16:                                        ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body17

do.body17:                                        ; preds = %do.end
  %14 = load ptr, ptr %ts, align 8
  %bf.load18 = load i64, ptr %14, align 8
  %bf.lshr19 = lshr i64 %bf.load18, 32
  %bf.clear20 = and i64 %bf.lshr19, 7
  %bf.cast21 = trunc i64 %bf.clear20 to i32
  %15 = load i32, ptr %kind.addr, align 4
  %cmp22 = icmp eq i32 %bf.cast21, %15
  br i1 %cmp22, label %if.end25, label %if.then24

if.then24:                                        ; preds = %do.body17
  unreachable

if.end25:                                         ; preds = %do.body17
  br label %do.end26

do.end26:                                         ; preds = %if.end25
  %16 = load ptr, ptr %ts, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

if.end27:                                         ; preds = %if.then
  br label %if.end34

if.else:                                          ; preds = %entry
  br label %do.body28

do.body28:                                        ; preds = %if.else
  %17 = load i32, ptr %kind.addr, align 4
  %cmp29 = icmp eq i32 %17, 1
  br i1 %cmp29, label %if.end32, label %if.then31

if.then31:                                        ; preds = %do.body28
  unreachable

if.end32:                                         ; preds = %do.body28
  br label %do.end33

do.end33:                                         ; preds = %if.end32
  br label %if.end34

if.end34:                                         ; preds = %do.end33, %if.end27
  %18 = load i32, ptr %type.addr, align 4
  switch i32 %18, label %sw.default [
    i32 0, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb
    i32 5, label %sw.bb
    i32 1, label %sw.bb35
    i32 2, label %sw.bb36
  ]

sw.bb:                                            ; preds = %if.end34, %if.end34, %if.end34, %if.end34
  store i32 1, ptr %n, align 4
  br label %sw.epilog

sw.bb35:                                          ; preds = %if.end34
  store i32 1, ptr %n, align 4
  br label %sw.epilog

sw.bb36:                                          ; preds = %if.end34
  store i32 2, ptr %n, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end34
  br label %do.body37

do.body37:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 1690, ptr noundef @__func__.tcg_temp_new_internal, ptr noundef null) #15
  unreachable

do.end38:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end38, %sw.bb36, %sw.bb35, %sw.bb
  %19 = load ptr, ptr %s, align 8
  %call39 = call ptr @tcg_temp_alloc(ptr noundef %19)
  store ptr %call39, ptr %ts, align 8
  %20 = load i32, ptr %type.addr, align 4
  %21 = load ptr, ptr %ts, align 8
  %22 = zext i32 %20 to i64
  %bf.load40 = load i64, ptr %21, align 8
  %bf.value = and i64 %22, 255
  %bf.shl = shl i64 %bf.value, 16
  %bf.clear41 = and i64 %bf.load40, -16711681
  %bf.set42 = or i64 %bf.clear41, %bf.shl
  store i64 %bf.set42, ptr %21, align 8
  %23 = load ptr, ptr %ts, align 8
  %bf.load43 = load i64, ptr %23, align 8
  %bf.clear44 = and i64 %bf.load43, -549755813889
  %bf.set45 = or i64 %bf.clear44, 549755813888
  store i64 %bf.set45, ptr %23, align 8
  %24 = load i32, ptr %kind.addr, align 4
  %25 = load ptr, ptr %ts, align 8
  %26 = zext i32 %24 to i64
  %bf.load46 = load i64, ptr %25, align 8
  %bf.value47 = and i64 %26, 7
  %bf.shl48 = shl i64 %bf.value47, 32
  %bf.clear49 = and i64 %bf.load46, -30064771073
  %bf.set50 = or i64 %bf.clear49, %bf.shl48
  store i64 %bf.set50, ptr %25, align 8
  %27 = load i32, ptr %n, align 4
  %cmp52 = icmp eq i32 %27, 1
  br i1 %cmp52, label %if.then54, label %if.else61

if.then54:                                        ; preds = %sw.epilog
  %28 = load i32, ptr %type.addr, align 4
  %29 = load ptr, ptr %ts, align 8
  %30 = zext i32 %28 to i64
  %bf.load55 = load i64, ptr %29, align 8
  %bf.value56 = and i64 %30, 255
  %bf.shl57 = shl i64 %bf.value56, 24
  %bf.clear58 = and i64 %bf.load55, -4278190081
  %bf.set59 = or i64 %bf.clear58, %bf.shl57
  store i64 %bf.set59, ptr %29, align 8
  br label %if.end98

if.else61:                                        ; preds = %sw.epilog
  %31 = load ptr, ptr %ts, align 8
  %bf.load62 = load i64, ptr %31, align 8
  %bf.clear63 = and i64 %bf.load62, -4278190081
  %bf.set64 = or i64 %bf.clear63, 16777216
  store i64 %bf.set64, ptr %31, align 8
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else61
  %32 = load i32, ptr %i, align 4
  %33 = load i32, ptr %n, align 4
  %cmp65 = icmp slt i32 %32, %33
  br i1 %cmp65, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %34 = load ptr, ptr %s, align 8
  %call67 = call ptr @tcg_temp_alloc(ptr noundef %34)
  store ptr %call67, ptr %ts2, align 8
  br label %do.body68

do.body68:                                        ; preds = %for.body
  %35 = load ptr, ptr %ts2, align 8
  %36 = load ptr, ptr %ts, align 8
  %37 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %37 to i64
  %add.ptr = getelementptr %struct.TCGTemp, ptr %36, i64 %idx.ext
  %cmp69 = icmp eq ptr %35, %add.ptr
  br i1 %cmp69, label %if.end72, label %if.then71

if.then71:                                        ; preds = %do.body68
  unreachable

if.end72:                                         ; preds = %do.body68
  br label %do.end73

do.end73:                                         ; preds = %if.end72
  %38 = load i32, ptr %type.addr, align 4
  %39 = load ptr, ptr %ts2, align 8
  %40 = zext i32 %38 to i64
  %bf.load74 = load i64, ptr %39, align 8
  %bf.value75 = and i64 %40, 255
  %bf.shl76 = shl i64 %bf.value75, 16
  %bf.clear77 = and i64 %bf.load74, -16711681
  %bf.set78 = or i64 %bf.clear77, %bf.shl76
  store i64 %bf.set78, ptr %39, align 8
  %41 = load ptr, ptr %ts2, align 8
  %bf.load80 = load i64, ptr %41, align 8
  %bf.clear81 = and i64 %bf.load80, -4278190081
  %bf.set82 = or i64 %bf.clear81, 16777216
  store i64 %bf.set82, ptr %41, align 8
  %42 = load ptr, ptr %ts2, align 8
  %bf.load83 = load i64, ptr %42, align 8
  %bf.clear84 = and i64 %bf.load83, -549755813889
  %bf.set85 = or i64 %bf.clear84, 549755813888
  store i64 %bf.set85, ptr %42, align 8
  %43 = load i32, ptr %i, align 4
  %44 = load ptr, ptr %ts2, align 8
  %45 = zext i32 %43 to i64
  %bf.load86 = load i64, ptr %44, align 8
  %bf.value87 = and i64 %45, 1
  %bf.shl88 = shl i64 %bf.value87, 40
  %bf.clear89 = and i64 %bf.load86, -1099511627777
  %bf.set90 = or i64 %bf.clear89, %bf.shl88
  store i64 %bf.set90, ptr %44, align 8
  %46 = load i32, ptr %kind.addr, align 4
  %47 = load ptr, ptr %ts2, align 8
  %48 = zext i32 %46 to i64
  %bf.load92 = load i64, ptr %47, align 8
  %bf.value93 = and i64 %48, 7
  %bf.shl94 = shl i64 %bf.value93, 32
  %bf.clear95 = and i64 %bf.load92, -30064771073
  %bf.set96 = or i64 %bf.clear95, %bf.shl94
  store i64 %bf.set96, ptr %47, align 8
  br label %for.inc

for.inc:                                          ; preds = %do.end73
  %49 = load i32, ptr %i, align 4
  %inc = add i32 %49, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !17

for.end:                                          ; preds = %for.cond
  br label %if.end98

if.end98:                                         ; preds = %for.end, %if.then54
  %50 = load ptr, ptr %ts, align 8
  store ptr %50, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end98, %do.end26
  %51 = load ptr, ptr %retval, align 8
  ret ptr %51
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_temp_ebb_new_i32() #0 {
entry:
  %call = call ptr @tcg_temp_new_internal(i32 noundef 0, i32 noundef 0)
  %call1 = call ptr @temp_tcgv_i32(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_temp_new_i64() #0 {
entry:
  %call = call ptr @tcg_temp_new_internal(i32 noundef 1, i32 noundef 1)
  %call1 = call ptr @temp_tcgv_i64(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_temp_ebb_new_i64() #0 {
entry:
  %call = call ptr @tcg_temp_new_internal(i32 noundef 1, i32 noundef 0)
  %call1 = call ptr @temp_tcgv_i64(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_temp_new_ptr() #0 {
entry:
  %call = call ptr @tcg_temp_new_internal(i32 noundef 1, i32 noundef 1)
  %call1 = call ptr @temp_tcgv_ptr(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_temp_ebb_new_ptr() #0 {
entry:
  %call = call ptr @tcg_temp_new_internal(i32 noundef 1, i32 noundef 0)
  %call1 = call ptr @temp_tcgv_ptr(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_temp_new_i128() #0 {
entry:
  %call = call ptr @tcg_temp_new_internal(i32 noundef 2, i32 noundef 1)
  %call1 = call ptr @temp_tcgv_i128(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @temp_tcgv_i128(ptr noundef %t) #0 {
entry:
  %t.addr = alloca ptr, align 8
  store ptr %t, ptr %t.addr, align 8
  %0 = load ptr, ptr %t.addr, align 8
  %call = call ptr @temp_tcgv_i32(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_temp_ebb_new_i128() #0 {
entry:
  %call = call ptr @tcg_temp_new_internal(i32 noundef 2, i32 noundef 0)
  %call1 = call ptr @temp_tcgv_i128(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_temp_new_vec(i32 noundef %type) #0 {
entry:
  %type.addr = alloca i32, align 4
  %t = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %call = call ptr @tcg_temp_new_internal(i32 noundef %0, i32 noundef 0)
  store ptr %call, ptr %t, align 8
  %1 = load ptr, ptr %t, align 8
  %call1 = call ptr @temp_tcgv_vec(ptr noundef %1)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_temp_new_vec_matching(ptr noundef %match) #0 {
entry:
  %match.addr = alloca ptr, align 8
  %t = alloca ptr, align 8
  store ptr %match, ptr %match.addr, align 8
  %0 = load ptr, ptr %match.addr, align 8
  %call = call ptr @tcgv_vec_temp(ptr noundef %0)
  store ptr %call, ptr %t, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load ptr, ptr %t, align 8
  %bf.load = load i64, ptr %1, align 8
  %bf.lshr = lshr i64 %bf.load, 39
  %bf.clear = and i64 %bf.lshr, 1
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp = icmp ne i32 %bf.cast, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %t, align 8
  %bf.load1 = load i64, ptr %2, align 8
  %bf.lshr2 = lshr i64 %bf.load1, 16
  %bf.clear3 = and i64 %bf.lshr2, 255
  %bf.cast4 = trunc i64 %bf.clear3 to i32
  %call5 = call ptr @tcg_temp_new_internal(i32 noundef %bf.cast4, i32 noundef 0)
  store ptr %call5, ptr %t, align 8
  %3 = load ptr, ptr %t, align 8
  %call6 = call ptr @temp_tcgv_vec(ptr noundef %3)
  ret ptr %call6
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcgv_vec_temp(ptr noundef %v) #0 {
entry:
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %call = call ptr @tcgv_i32_temp(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_temp_free_internal(ptr noundef %ts) #0 {
entry:
  %ts.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %s, align 8
  %2 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %2, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  switch i32 %bf.cast, label %sw.default [
    i32 4, label %sw.bb
    i32 1, label %sw.bb
    i32 0, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry, %entry
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb1
  %3 = load ptr, ptr %ts.addr, align 8
  %bf.load2 = load i64, ptr %3, align 8
  %bf.lshr3 = lshr i64 %bf.load2, 39
  %bf.clear4 = and i64 %bf.lshr3, 1
  %bf.cast5 = trunc i64 %bf.clear4 to i32
  %cmp = icmp ne i32 %bf.cast5, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %4 = load ptr, ptr %ts.addr, align 8
  %bf.load6 = load i64, ptr %4, align 8
  %bf.clear7 = and i64 %bf.load6, -549755813889
  %bf.set = or i64 %bf.clear7, 0
  store i64 %bf.set, ptr %4, align 8
  %5 = load ptr, ptr %ts.addr, align 8
  %call = call i64 @temp_idx(ptr noundef %5)
  %6 = load ptr, ptr %s, align 8
  %free_temps = getelementptr inbounds %struct.TCGContext, ptr %6, i32 0, i32 36
  %7 = load ptr, ptr %ts.addr, align 8
  %bf.load8 = load i64, ptr %7, align 8
  %bf.lshr9 = lshr i64 %bf.load8, 16
  %bf.clear10 = and i64 %bf.lshr9, 255
  %bf.cast11 = trunc i64 %bf.clear10 to i32
  %idxprom = zext i32 %bf.cast11 to i64
  %arrayidx = getelementptr [6 x %struct.TCGTempSet], ptr %free_temps, i64 0, i64 %idxprom
  %l = getelementptr inbounds %struct.TCGTempSet, ptr %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [8 x i64], ptr %l, i64 0, i64 0
  call void @set_bit(i64 noundef %call, ptr noundef %arraydecay)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body12

do.body12:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 1808, ptr noundef @__func__.tcg_temp_free_internal, ptr noundef null) #15
  unreachable

do.end13:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end13, %do.end, %sw.bb
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @set_bit(i64 noundef %nr, ptr noundef %addr) #0 {
entry:
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca ptr, align 8
  %mask = alloca i64, align 8
  %p = alloca ptr, align 8
  store i64 %nr, ptr %nr.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %nr.addr, align 8
  %rem = urem i64 %0, 64
  %shl = shl i64 1, %rem
  store i64 %shl, ptr %mask, align 8
  %1 = load ptr, ptr %addr.addr, align 8
  %2 = load i64, ptr %nr.addr, align 8
  %div = udiv i64 %2, 64
  %add.ptr = getelementptr i64, ptr %1, i64 %div
  store ptr %add.ptr, ptr %p, align 8
  %3 = load i64, ptr %mask, align 8
  %4 = load ptr, ptr %p, align 8
  %5 = load i64, ptr %4, align 8
  %or = or i64 %5, %3
  store i64 %or, ptr %4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @temp_idx(ptr noundef %ts) #0 {
entry:
  %ts.addr = alloca ptr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  %0 = load ptr, ptr %ts.addr, align 8
  %1 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %2 = load ptr, ptr %1, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 37
  %arraydecay = getelementptr inbounds [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 0
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %arraydecay to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 56
  ret i64 %sub.ptr.div
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_temp_free_i32(ptr noundef %arg) #0 {
entry:
  %arg.addr = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call ptr @tcgv_i32_temp(ptr noundef %0)
  call void @tcg_temp_free_internal(ptr noundef %call)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcgv_i32_temp(ptr noundef %v) #0 {
entry:
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  %2 = load ptr, ptr %v.addr, align 8
  %3 = ptrtoint ptr %2 to i64
  %add.ptr = getelementptr i8, ptr %1, i64 %3
  ret ptr %add.ptr
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_temp_free_i64(ptr noundef %arg) #0 {
entry:
  %arg.addr = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call ptr @tcgv_i64_temp(ptr noundef %0)
  call void @tcg_temp_free_internal(ptr noundef %call)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcgv_i64_temp(ptr noundef %v) #0 {
entry:
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %call = call ptr @tcgv_i32_temp(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_temp_free_i128(ptr noundef %arg) #0 {
entry:
  %arg.addr = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call ptr @tcgv_i128_temp(ptr noundef %0)
  call void @tcg_temp_free_internal(ptr noundef %call)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcgv_i128_temp(ptr noundef %v) #0 {
entry:
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %call = call ptr @tcgv_i32_temp(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_temp_free_ptr(ptr noundef %arg) #0 {
entry:
  %arg.addr = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call ptr @tcgv_ptr_temp(ptr noundef %0)
  call void @tcg_temp_free_internal(ptr noundef %call)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcgv_ptr_temp(ptr noundef %v) #0 {
entry:
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %call = call ptr @tcgv_i32_temp(ptr noundef %0)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_temp_free_vec(ptr noundef %arg) #0 {
entry:
  %arg.addr = alloca ptr, align 8
  store ptr %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %arg.addr, align 8
  %call = call ptr @tcgv_vec_temp(ptr noundef %0)
  call void @tcg_temp_free_internal(ptr noundef %call)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_constant_internal(i32 noundef %type, i64 noundef %val) #0 {
entry:
  %type.addr = alloca i32, align 4
  %val.addr = alloca i64, align 8
  %s = alloca ptr, align 8
  %h = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %val_ptr = alloca ptr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i64 %val, ptr %val.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %s, align 8
  %2 = load ptr, ptr %s, align 8
  %const_table = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 35
  %3 = load i32, ptr %type.addr, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [6 x ptr], ptr %const_table, i64 0, i64 %idxprom
  %4 = load ptr, ptr %arrayidx, align 8
  store ptr %4, ptr %h, align 8
  %5 = load ptr, ptr %h, align 8
  %cmp = icmp eq ptr %5, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call ptr @g_hash_table_new(ptr noundef @g_int64_hash, ptr noundef @g_int64_equal)
  store ptr %call, ptr %h, align 8
  %6 = load ptr, ptr %h, align 8
  %7 = load ptr, ptr %s, align 8
  %const_table1 = getelementptr inbounds %struct.TCGContext, ptr %7, i32 0, i32 35
  %8 = load i32, ptr %type.addr, align 4
  %idxprom2 = zext i32 %8 to i64
  %arrayidx3 = getelementptr [6 x ptr], ptr %const_table1, i64 0, i64 %idxprom2
  store ptr %6, ptr %arrayidx3, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load ptr, ptr %h, align 8
  %call4 = call ptr @g_hash_table_lookup(ptr noundef %9, ptr noundef %val.addr)
  store ptr %call4, ptr %ts, align 8
  %10 = load ptr, ptr %ts, align 8
  %cmp5 = icmp eq ptr %10, null
  br i1 %cmp5, label %if.then6, label %if.end23

if.then6:                                         ; preds = %if.end
  %11 = load ptr, ptr %s, align 8
  %call7 = call ptr @tcg_temp_alloc(ptr noundef %11)
  store ptr %call7, ptr %ts, align 8
  %12 = load i32, ptr %type.addr, align 4
  %13 = load ptr, ptr %ts, align 8
  %14 = zext i32 %12 to i64
  %bf.load = load i64, ptr %13, align 8
  %bf.value = and i64 %14, 255
  %bf.shl = shl i64 %bf.value, 16
  %bf.clear = and i64 %bf.load, -16711681
  %bf.set = or i64 %bf.clear, %bf.shl
  store i64 %bf.set, ptr %13, align 8
  %15 = load i32, ptr %type.addr, align 4
  %16 = load ptr, ptr %ts, align 8
  %17 = zext i32 %15 to i64
  %bf.load8 = load i64, ptr %16, align 8
  %bf.value9 = and i64 %17, 255
  %bf.shl10 = shl i64 %bf.value9, 24
  %bf.clear11 = and i64 %bf.load8, -4278190081
  %bf.set12 = or i64 %bf.clear11, %bf.shl10
  store i64 %bf.set12, ptr %16, align 8
  %18 = load ptr, ptr %ts, align 8
  %bf.load14 = load i64, ptr %18, align 8
  %bf.clear15 = and i64 %bf.load14, -30064771073
  %bf.set16 = or i64 %bf.clear15, 17179869184
  store i64 %bf.set16, ptr %18, align 8
  %19 = load ptr, ptr %ts, align 8
  %bf.load17 = load i64, ptr %19, align 8
  %bf.clear18 = and i64 %bf.load17, -549755813889
  %bf.set19 = or i64 %bf.clear18, 549755813888
  store i64 %bf.set19, ptr %19, align 8
  %20 = load i64, ptr %val.addr, align 8
  %21 = load ptr, ptr %ts, align 8
  %val20 = getelementptr inbounds %struct.TCGTemp, ptr %21, i32 0, i32 1
  store i64 %20, ptr %val20, align 8
  %22 = load ptr, ptr %ts, align 8
  %val21 = getelementptr inbounds %struct.TCGTemp, ptr %22, i32 0, i32 1
  store ptr %val21, ptr %val_ptr, align 8
  %23 = load ptr, ptr %h, align 8
  %24 = load ptr, ptr %val_ptr, align 8
  %25 = load ptr, ptr %ts, align 8
  %call22 = call i32 @g_hash_table_insert(ptr noundef %23, ptr noundef %24, ptr noundef %25)
  br label %if.end23

if.end23:                                         ; preds = %if.then6, %if.end
  %26 = load ptr, ptr %ts, align 8
  ret ptr %26
}

declare ptr @g_hash_table_new(ptr noundef, ptr noundef) #7

declare i32 @g_int64_hash(ptr noundef) #7

declare i32 @g_int64_equal(ptr noundef, ptr noundef) #7

declare ptr @g_hash_table_lookup(ptr noundef, ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_temp_alloc(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %nb_temps = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %nb_temps, align 8
  %inc = add i32 %1, 1
  store i32 %inc, ptr %nb_temps, align 8
  store i32 %1, ptr %n, align 4
  %2 = load i32, ptr %n, align 4
  %cmp = icmp sge i32 %2, 512
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %s.addr, align 8
  call void @tcg_raise_tb_overflow(ptr noundef %3) #15
  unreachable

if.end:                                           ; preds = %entry
  %4 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 37
  %5 = load i32, ptr %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  call void @llvm.memset.p0.i64(ptr align 8 %arrayidx, i8 0, i64 56, i1 false)
  ret ptr %arrayidx
}

declare i32 @g_hash_table_insert(ptr noundef, ptr noundef, ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_constant_i32(i32 noundef %val) #0 {
entry:
  %val.addr = alloca i32, align 4
  store i32 %val, ptr %val.addr, align 4
  %0 = load i32, ptr %val.addr, align 4
  %conv = sext i32 %0 to i64
  %call = call ptr @tcg_constant_internal(i32 noundef 0, i64 noundef %conv)
  %call1 = call ptr @temp_tcgv_i32(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_constant_i64(i64 noundef %val) #0 {
entry:
  %val.addr = alloca i64, align 8
  store i64 %val, ptr %val.addr, align 8
  %0 = load i64, ptr %val.addr, align 8
  %call = call ptr @tcg_constant_internal(i32 noundef 1, i64 noundef %0)
  %call1 = call ptr @temp_tcgv_i64(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_constant_ptr_int(i64 noundef %val) #0 {
entry:
  %val.addr = alloca i64, align 8
  store i64 %val, ptr %val.addr, align 8
  %0 = load i64, ptr %val.addr, align 8
  %call = call ptr @tcg_constant_internal(i32 noundef 1, i64 noundef %0)
  %call1 = call ptr @temp_tcgv_ptr(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_constant_vec(i32 noundef %type, i32 noundef %vece, i64 noundef %val) #0 {
entry:
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %val.addr = alloca i64, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store i64 %val, ptr %val.addr, align 8
  %0 = load i32, ptr %vece.addr, align 4
  %1 = call i1 @llvm.is.constant.i32(i32 %0)
  br i1 %1, label %cond.true, label %cond.false27

cond.true:                                        ; preds = %entry
  %2 = load i32, ptr %vece.addr, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %cond.true1, label %cond.false

cond.true1:                                       ; preds = %cond.true
  %3 = load i64, ptr %val.addr, align 8
  %conv = trunc i64 %3 to i8
  %conv2 = zext i8 %conv to i64
  %mul = mul i64 72340172838076673, %conv2
  br label %cond.end25

cond.false:                                       ; preds = %cond.true
  %4 = load i32, ptr %vece.addr, align 4
  %cmp3 = icmp eq i32 %4, 1
  br i1 %cmp3, label %cond.true5, label %cond.false9

cond.true5:                                       ; preds = %cond.false
  %5 = load i64, ptr %val.addr, align 8
  %conv6 = trunc i64 %5 to i16
  %conv7 = zext i16 %conv6 to i64
  %mul8 = mul i64 281479271743489, %conv7
  br label %cond.end23

cond.false9:                                      ; preds = %cond.false
  %6 = load i32, ptr %vece.addr, align 4
  %cmp10 = icmp eq i32 %6, 2
  br i1 %cmp10, label %cond.true12, label %cond.false16

cond.true12:                                      ; preds = %cond.false9
  %7 = load i64, ptr %val.addr, align 8
  %conv13 = trunc i64 %7 to i32
  %conv14 = zext i32 %conv13 to i64
  %mul15 = mul i64 4294967297, %conv14
  br label %cond.end21

cond.false16:                                     ; preds = %cond.false9
  %8 = load i32, ptr %vece.addr, align 4
  %cmp17 = icmp eq i32 %8, 3
  br i1 %cmp17, label %cond.true19, label %cond.false20

cond.true19:                                      ; preds = %cond.false16
  %9 = load i64, ptr %val.addr, align 8
  br label %cond.end

cond.false20:                                     ; preds = %cond.false16
  call void @qemu_build_not_reached_always() #15, !srcloc !18
  unreachable

10:                                               ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %10, %cond.true19
  %cond = phi i64 [ %9, %cond.true19 ], [ 0, %10 ]
  br label %cond.end21

cond.end21:                                       ; preds = %cond.end, %cond.true12
  %cond22 = phi i64 [ %mul15, %cond.true12 ], [ %cond, %cond.end ]
  br label %cond.end23

cond.end23:                                       ; preds = %cond.end21, %cond.true5
  %cond24 = phi i64 [ %mul8, %cond.true5 ], [ %cond22, %cond.end21 ]
  br label %cond.end25

cond.end25:                                       ; preds = %cond.end23, %cond.true1
  %cond26 = phi i64 [ %mul, %cond.true1 ], [ %cond24, %cond.end23 ]
  br label %cond.end28

cond.false27:                                     ; preds = %entry
  %11 = load i32, ptr %vece.addr, align 4
  %12 = load i64, ptr %val.addr, align 8
  %call = call i64 @dup_const(i32 noundef %11, i64 noundef %12)
  br label %cond.end28

cond.end28:                                       ; preds = %cond.false27, %cond.end25
  %cond29 = phi i64 [ %cond26, %cond.end25 ], [ %call, %cond.false27 ]
  store i64 %cond29, ptr %val.addr, align 8
  %13 = load i32, ptr %type.addr, align 4
  %14 = load i64, ptr %val.addr, align 8
  %call30 = call ptr @tcg_constant_internal(i32 noundef %13, i64 noundef %14)
  %call31 = call ptr @temp_tcgv_vec(ptr noundef %call30)
  ret ptr %call31
}

; Function Attrs: convergent nocallback nofree nosync nounwind willreturn memory(none)
declare i1 @llvm.is.constant.i32(i32) #8

; Function Attrs: noreturn
declare void @qemu_build_not_reached_always() #9

declare i64 @dup_const(i32 noundef, i64 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_constant_vec_matching(ptr noundef %match, i32 noundef %vece, i64 noundef %val) #0 {
entry:
  %match.addr = alloca ptr, align 8
  %vece.addr = alloca i32, align 4
  %val.addr = alloca i64, align 8
  %t = alloca ptr, align 8
  store ptr %match, ptr %match.addr, align 8
  store i32 %vece, ptr %vece.addr, align 4
  store i64 %val, ptr %val.addr, align 8
  %0 = load ptr, ptr %match.addr, align 8
  %call = call ptr @tcgv_vec_temp(ptr noundef %0)
  store ptr %call, ptr %t, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load ptr, ptr %t, align 8
  %bf.load = load i64, ptr %1, align 8
  %bf.lshr = lshr i64 %bf.load, 39
  %bf.clear = and i64 %bf.lshr, 1
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp = icmp ne i32 %bf.cast, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %t, align 8
  %bf.load1 = load i64, ptr %2, align 8
  %bf.lshr2 = lshr i64 %bf.load1, 16
  %bf.clear3 = and i64 %bf.lshr2, 255
  %bf.cast4 = trunc i64 %bf.clear3 to i32
  %3 = load i32, ptr %vece.addr, align 4
  %4 = load i64, ptr %val.addr, align 8
  %call5 = call ptr @tcg_constant_vec(i32 noundef %bf.cast4, i32 noundef %3, i64 noundef %4)
  ret ptr %call5
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @tcg_op_supported(i32 noundef %op) #0 {
entry:
  %retval = alloca i1, align 1
  %op.addr = alloca i32, align 4
  %have_vec = alloca i8, align 1
  store i32 %op, ptr %op.addr, align 4
  %0 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %0, 512
  %1 = load i32, ptr @cpuinfo, align 4
  %and1 = and i32 %1, 512
  %or = or i32 %and, %and1
  %2 = load i32, ptr @cpuinfo, align 4
  %and2 = and i32 %2, 1024
  %or3 = or i32 %or, %and2
  %tobool = icmp ne i32 %or3, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %have_vec, align 1
  %3 = load i32, ptr %op.addr, align 4
  switch i32 %3, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb
    i32 129, label %sw.bb
    i32 130, label %sw.bb
    i32 131, label %sw.bb
    i32 132, label %sw.bb
    i32 135, label %sw.bb
    i32 139, label %sw.bb
    i32 136, label %sw.bb
    i32 140, label %sw.bb
    i32 137, label %sw.bb
    i32 141, label %sw.bb
    i32 138, label %sw.bb
    i32 142, label %sw.bb
    i32 143, label %sw.bb4
    i32 144, label %sw.bb4
    i32 145, label %sw.bb5
    i32 146, label %sw.bb5
    i32 147, label %sw.bb5
    i32 148, label %sw.bb5
    i32 5, label %sw.bb8
    i32 6, label %sw.bb8
    i32 38, label %sw.bb8
    i32 8, label %sw.bb8
    i32 9, label %sw.bb8
    i32 10, label %sw.bb8
    i32 11, label %sw.bb8
    i32 12, label %sw.bb8
    i32 13, label %sw.bb8
    i32 14, label %sw.bb8
    i32 15, label %sw.bb8
    i32 16, label %sw.bb8
    i32 17, label %sw.bb8
    i32 18, label %sw.bb8
    i32 54, label %sw.bb8
    i32 19, label %sw.bb8
    i32 26, label %sw.bb8
    i32 27, label %sw.bb8
    i32 28, label %sw.bb8
    i32 29, label %sw.bb8
    i32 30, label %sw.bb8
    i32 31, label %sw.bb8
    i32 7, label %sw.bb9
    i32 20, label %sw.bb10
    i32 21, label %sw.bb10
    i32 22, label %sw.bb11
    i32 23, label %sw.bb11
    i32 24, label %sw.bb12
    i32 25, label %sw.bb12
    i32 32, label %sw.bb13
    i32 33, label %sw.bb13
    i32 34, label %sw.bb14
    i32 35, label %sw.bb15
    i32 36, label %sw.bb16
    i32 37, label %sw.bb17
    i32 39, label %sw.bb18
    i32 40, label %sw.bb19
    i32 41, label %sw.bb20
    i32 42, label %sw.bb21
    i32 43, label %sw.bb22
    i32 44, label %sw.bb23
    i32 47, label %sw.bb24
    i32 48, label %sw.bb25
    i32 49, label %sw.bb26
    i32 50, label %sw.bb27
    i32 51, label %sw.bb28
    i32 52, label %sw.bb29
    i32 53, label %sw.bb30
    i32 55, label %sw.bb31
    i32 56, label %sw.bb34
    i32 57, label %sw.bb35
    i32 58, label %sw.bb36
    i32 59, label %sw.bb37
    i32 60, label %sw.bb38
    i32 61, label %sw.bb39
    i32 62, label %sw.bb40
    i32 45, label %sw.bb43
    i32 46, label %sw.bb43
    i32 63, label %sw.bb44
    i32 64, label %sw.bb44
    i32 103, label %sw.bb44
    i32 66, label %sw.bb44
    i32 67, label %sw.bb44
    i32 68, label %sw.bb44
    i32 69, label %sw.bb44
    i32 70, label %sw.bb44
    i32 71, label %sw.bb44
    i32 72, label %sw.bb44
    i32 73, label %sw.bb44
    i32 74, label %sw.bb44
    i32 75, label %sw.bb44
    i32 76, label %sw.bb44
    i32 77, label %sw.bb44
    i32 78, label %sw.bb44
    i32 79, label %sw.bb44
    i32 114, label %sw.bb44
    i32 80, label %sw.bb44
    i32 87, label %sw.bb44
    i32 88, label %sw.bb44
    i32 89, label %sw.bb44
    i32 90, label %sw.bb44
    i32 91, label %sw.bb44
    i32 92, label %sw.bb44
    i32 99, label %sw.bb44
    i32 100, label %sw.bb44
    i32 65, label %sw.bb45
    i32 81, label %sw.bb46
    i32 82, label %sw.bb46
    i32 83, label %sw.bb47
    i32 84, label %sw.bb47
    i32 85, label %sw.bb48
    i32 86, label %sw.bb48
    i32 93, label %sw.bb49
    i32 94, label %sw.bb49
    i32 95, label %sw.bb50
    i32 96, label %sw.bb51
    i32 97, label %sw.bb52
    i32 98, label %sw.bb53
    i32 101, label %sw.bb54
    i32 102, label %sw.bb54
    i32 104, label %sw.bb55
    i32 105, label %sw.bb56
    i32 106, label %sw.bb57
    i32 107, label %sw.bb58
    i32 108, label %sw.bb59
    i32 109, label %sw.bb60
    i32 110, label %sw.bb61
    i32 111, label %sw.bb62
    i32 112, label %sw.bb63
    i32 113, label %sw.bb64
    i32 115, label %sw.bb65
    i32 116, label %sw.bb68
    i32 117, label %sw.bb69
    i32 118, label %sw.bb70
    i32 119, label %sw.bb71
    i32 120, label %sw.bb72
    i32 121, label %sw.bb73
    i32 122, label %sw.bb74
    i32 123, label %sw.bb77
    i32 124, label %sw.bb78
    i32 125, label %sw.bb79
    i32 126, label %sw.bb80
    i32 127, label %sw.bb81
    i32 128, label %sw.bb82
    i32 149, label %sw.bb83
    i32 150, label %sw.bb83
    i32 154, label %sw.bb83
    i32 152, label %sw.bb83
    i32 153, label %sw.bb83
    i32 155, label %sw.bb83
    i32 156, label %sw.bb83
    i32 168, label %sw.bb83
    i32 169, label %sw.bb83
    i32 170, label %sw.bb83
    i32 190, label %sw.bb83
    i32 151, label %sw.bb85
    i32 176, label %sw.bb87
    i32 158, label %sw.bb97
    i32 159, label %sw.bb101
    i32 171, label %sw.bb105
    i32 172, label %sw.bb109
    i32 173, label %sw.bb119
    i32 174, label %sw.bb129
    i32 175, label %sw.bb139
    i32 157, label %sw.bb149
    i32 177, label %sw.bb153
    i32 178, label %sw.bb153
    i32 179, label %sw.bb153
    i32 181, label %sw.bb157
    i32 182, label %sw.bb157
    i32 183, label %sw.bb157
    i32 185, label %sw.bb161
    i32 186, label %sw.bb161
    i32 187, label %sw.bb161
    i32 180, label %sw.bb167
    i32 184, label %sw.bb177
    i32 188, label %sw.bb181
    i32 189, label %sw.bb181
    i32 160, label %sw.bb191
    i32 161, label %sw.bb191
    i32 162, label %sw.bb191
    i32 163, label %sw.bb191
    i32 164, label %sw.bb195
    i32 165, label %sw.bb195
    i32 166, label %sw.bb195
    i32 167, label %sw.bb195
    i32 191, label %sw.bb199
    i32 192, label %sw.bb209
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb4:                                           ; preds = %entry, %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb5:                                           ; preds = %entry, %entry, %entry, %entry
  %4 = load i32, ptr @cpuinfo, align 4
  %and6 = and i32 %4, 65536
  %tobool7 = icmp ne i32 %and6, 0
  store i1 %tobool7, ptr %retval, align 1
  br label %return

sw.bb8:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb9:                                           ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb10:                                          ; preds = %entry, %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb11:                                          ; preds = %entry, %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb12:                                          ; preds = %entry, %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb13:                                          ; preds = %entry, %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb14:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb15:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb16:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb17:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb18:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb19:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb20:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb21:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb22:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb23:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb24:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb25:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb26:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb27:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb28:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb29:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb30:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb31:                                          ; preds = %entry
  %5 = load i32, ptr @cpuinfo, align 4
  %and32 = and i32 %5, 32
  %tobool33 = icmp ne i32 %and32, 0
  store i1 %tobool33, ptr %retval, align 1
  br label %return

sw.bb34:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb35:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb36:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb37:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb38:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb39:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb40:                                          ; preds = %entry
  %6 = load i32, ptr @cpuinfo, align 4
  %and41 = and i32 %6, 16
  %tobool42 = icmp ne i32 %and41, 0
  store i1 %tobool42, ptr %retval, align 1
  br label %return

sw.bb43:                                          ; preds = %entry, %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb44:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb45:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb46:                                          ; preds = %entry, %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb47:                                          ; preds = %entry, %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb48:                                          ; preds = %entry, %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb49:                                          ; preds = %entry, %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb50:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb51:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb52:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb53:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb54:                                          ; preds = %entry, %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb55:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb56:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb57:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb58:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb59:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb60:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb61:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb62:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb63:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb64:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb65:                                          ; preds = %entry
  %7 = load i32, ptr @cpuinfo, align 4
  %and66 = and i32 %7, 32
  %tobool67 = icmp ne i32 %and66, 0
  store i1 %tobool67, ptr %retval, align 1
  br label %return

sw.bb68:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb69:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb70:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb71:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb72:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb73:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb74:                                          ; preds = %entry
  %8 = load i32, ptr @cpuinfo, align 4
  %and75 = and i32 %8, 16
  %tobool76 = icmp ne i32 %and75, 0
  store i1 %tobool76, ptr %retval, align 1
  br label %return

sw.bb77:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb78:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb79:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb80:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

sw.bb81:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb82:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

sw.bb83:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  %9 = load i8, ptr %have_vec, align 1
  %tobool84 = trunc i8 %9 to i1
  store i1 %tobool84, ptr %retval, align 1
  br label %return

sw.bb85:                                          ; preds = %entry
  %10 = load i8, ptr %have_vec, align 1
  %tobool86 = trunc i8 %10 to i1
  br i1 %tobool86, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %sw.bb85
  br label %land.end

land.end:                                         ; preds = %land.rhs, %sw.bb85
  %11 = phi i1 [ false, %sw.bb85 ], [ false, %land.rhs ]
  store i1 %11, ptr %retval, align 1
  br label %return

sw.bb87:                                          ; preds = %entry
  %12 = load i8, ptr %have_vec, align 1
  %tobool88 = trunc i8 %12 to i1
  br i1 %tobool88, label %land.rhs89, label %land.end96

land.rhs89:                                       ; preds = %sw.bb87
  %13 = load i32, ptr @cpuinfo, align 4
  %and90 = and i32 %13, 4096
  %tobool91 = icmp ne i32 %and90, 0
  br i1 %tobool91, label %land.rhs92, label %land.end95

land.rhs92:                                       ; preds = %land.rhs89
  %14 = load i32, ptr @cpuinfo, align 4
  %and93 = and i32 %14, 2048
  %tobool94 = icmp ne i32 %and93, 0
  br label %land.end95

land.end95:                                       ; preds = %land.rhs92, %land.rhs89
  %15 = phi i1 [ false, %land.rhs89 ], [ %tobool94, %land.rhs92 ]
  br label %land.end96

land.end96:                                       ; preds = %land.end95, %sw.bb87
  %16 = phi i1 [ false, %sw.bb87 ], [ %15, %land.end95 ]
  store i1 %16, ptr %retval, align 1
  br label %return

sw.bb97:                                          ; preds = %entry
  %17 = load i8, ptr %have_vec, align 1
  %tobool98 = trunc i8 %17 to i1
  br i1 %tobool98, label %land.rhs99, label %land.end100

land.rhs99:                                       ; preds = %sw.bb97
  br label %land.end100

land.end100:                                      ; preds = %land.rhs99, %sw.bb97
  %18 = phi i1 [ false, %sw.bb97 ], [ false, %land.rhs99 ]
  store i1 %18, ptr %retval, align 1
  br label %return

sw.bb101:                                         ; preds = %entry
  %19 = load i8, ptr %have_vec, align 1
  %tobool102 = trunc i8 %19 to i1
  br i1 %tobool102, label %land.rhs103, label %land.end104

land.rhs103:                                      ; preds = %sw.bb101
  br label %land.end104

land.end104:                                      ; preds = %land.rhs103, %sw.bb101
  %20 = phi i1 [ false, %sw.bb101 ], [ true, %land.rhs103 ]
  store i1 %20, ptr %retval, align 1
  br label %return

sw.bb105:                                         ; preds = %entry
  %21 = load i8, ptr %have_vec, align 1
  %tobool106 = trunc i8 %21 to i1
  br i1 %tobool106, label %land.rhs107, label %land.end108

land.rhs107:                                      ; preds = %sw.bb105
  br label %land.end108

land.end108:                                      ; preds = %land.rhs107, %sw.bb105
  %22 = phi i1 [ false, %sw.bb105 ], [ true, %land.rhs107 ]
  store i1 %22, ptr %retval, align 1
  br label %return

sw.bb109:                                         ; preds = %entry
  %23 = load i8, ptr %have_vec, align 1
  %tobool110 = trunc i8 %23 to i1
  br i1 %tobool110, label %land.rhs111, label %land.end118

land.rhs111:                                      ; preds = %sw.bb109
  %24 = load i32, ptr @cpuinfo, align 4
  %and112 = and i32 %24, 4096
  %tobool113 = icmp ne i32 %and112, 0
  br i1 %tobool113, label %land.rhs114, label %land.end117

land.rhs114:                                      ; preds = %land.rhs111
  %25 = load i32, ptr @cpuinfo, align 4
  %and115 = and i32 %25, 2048
  %tobool116 = icmp ne i32 %and115, 0
  br label %land.end117

land.end117:                                      ; preds = %land.rhs114, %land.rhs111
  %26 = phi i1 [ false, %land.rhs111 ], [ %tobool116, %land.rhs114 ]
  br label %land.end118

land.end118:                                      ; preds = %land.end117, %sw.bb109
  %27 = phi i1 [ false, %sw.bb109 ], [ %26, %land.end117 ]
  store i1 %27, ptr %retval, align 1
  br label %return

sw.bb119:                                         ; preds = %entry
  %28 = load i8, ptr %have_vec, align 1
  %tobool120 = trunc i8 %28 to i1
  br i1 %tobool120, label %land.rhs121, label %land.end128

land.rhs121:                                      ; preds = %sw.bb119
  %29 = load i32, ptr @cpuinfo, align 4
  %and122 = and i32 %29, 4096
  %tobool123 = icmp ne i32 %and122, 0
  br i1 %tobool123, label %land.rhs124, label %land.end127

land.rhs124:                                      ; preds = %land.rhs121
  %30 = load i32, ptr @cpuinfo, align 4
  %and125 = and i32 %30, 2048
  %tobool126 = icmp ne i32 %and125, 0
  br label %land.end127

land.end127:                                      ; preds = %land.rhs124, %land.rhs121
  %31 = phi i1 [ false, %land.rhs121 ], [ %tobool126, %land.rhs124 ]
  br label %land.end128

land.end128:                                      ; preds = %land.end127, %sw.bb119
  %32 = phi i1 [ false, %sw.bb119 ], [ %31, %land.end127 ]
  store i1 %32, ptr %retval, align 1
  br label %return

sw.bb129:                                         ; preds = %entry
  %33 = load i8, ptr %have_vec, align 1
  %tobool130 = trunc i8 %33 to i1
  br i1 %tobool130, label %land.rhs131, label %land.end138

land.rhs131:                                      ; preds = %sw.bb129
  %34 = load i32, ptr @cpuinfo, align 4
  %and132 = and i32 %34, 4096
  %tobool133 = icmp ne i32 %and132, 0
  br i1 %tobool133, label %land.rhs134, label %land.end137

land.rhs134:                                      ; preds = %land.rhs131
  %35 = load i32, ptr @cpuinfo, align 4
  %and135 = and i32 %35, 2048
  %tobool136 = icmp ne i32 %and135, 0
  br label %land.end137

land.end137:                                      ; preds = %land.rhs134, %land.rhs131
  %36 = phi i1 [ false, %land.rhs131 ], [ %tobool136, %land.rhs134 ]
  br label %land.end138

land.end138:                                      ; preds = %land.end137, %sw.bb129
  %37 = phi i1 [ false, %sw.bb129 ], [ %36, %land.end137 ]
  store i1 %37, ptr %retval, align 1
  br label %return

sw.bb139:                                         ; preds = %entry
  %38 = load i8, ptr %have_vec, align 1
  %tobool140 = trunc i8 %38 to i1
  br i1 %tobool140, label %land.rhs141, label %land.end148

land.rhs141:                                      ; preds = %sw.bb139
  %39 = load i32, ptr @cpuinfo, align 4
  %and142 = and i32 %39, 4096
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %land.rhs144, label %land.end147

land.rhs144:                                      ; preds = %land.rhs141
  %40 = load i32, ptr @cpuinfo, align 4
  %and145 = and i32 %40, 2048
  %tobool146 = icmp ne i32 %and145, 0
  br label %land.end147

land.end147:                                      ; preds = %land.rhs144, %land.rhs141
  %41 = phi i1 [ false, %land.rhs141 ], [ %tobool146, %land.rhs144 ]
  br label %land.end148

land.end148:                                      ; preds = %land.end147, %sw.bb139
  %42 = phi i1 [ false, %sw.bb139 ], [ %41, %land.end147 ]
  store i1 %42, ptr %retval, align 1
  br label %return

sw.bb149:                                         ; preds = %entry
  %43 = load i8, ptr %have_vec, align 1
  %tobool150 = trunc i8 %43 to i1
  br i1 %tobool150, label %land.rhs151, label %land.end152

land.rhs151:                                      ; preds = %sw.bb149
  br label %land.end152

land.end152:                                      ; preds = %land.rhs151, %sw.bb149
  %44 = phi i1 [ false, %sw.bb149 ], [ true, %land.rhs151 ]
  store i1 %44, ptr %retval, align 1
  br label %return

sw.bb153:                                         ; preds = %entry, %entry, %entry
  %45 = load i8, ptr %have_vec, align 1
  %tobool154 = trunc i8 %45 to i1
  br i1 %tobool154, label %land.rhs155, label %land.end156

land.rhs155:                                      ; preds = %sw.bb153
  br label %land.end156

land.end156:                                      ; preds = %land.rhs155, %sw.bb153
  %46 = phi i1 [ false, %sw.bb153 ], [ true, %land.rhs155 ]
  store i1 %46, ptr %retval, align 1
  br label %return

sw.bb157:                                         ; preds = %entry, %entry, %entry
  %47 = load i8, ptr %have_vec, align 1
  %tobool158 = trunc i8 %47 to i1
  br i1 %tobool158, label %land.rhs159, label %land.end160

land.rhs159:                                      ; preds = %sw.bb157
  br label %land.end160

land.end160:                                      ; preds = %land.rhs159, %sw.bb157
  %48 = phi i1 [ false, %sw.bb157 ], [ true, %land.rhs159 ]
  store i1 %48, ptr %retval, align 1
  br label %return

sw.bb161:                                         ; preds = %entry, %entry, %entry
  %49 = load i8, ptr %have_vec, align 1
  %tobool162 = trunc i8 %49 to i1
  br i1 %tobool162, label %land.rhs163, label %land.end166

land.rhs163:                                      ; preds = %sw.bb161
  %50 = load i32, ptr @cpuinfo, align 4
  %and164 = and i32 %50, 1024
  %tobool165 = icmp ne i32 %and164, 0
  br label %land.end166

land.end166:                                      ; preds = %land.rhs163, %sw.bb161
  %51 = phi i1 [ false, %sw.bb161 ], [ %tobool165, %land.rhs163 ]
  store i1 %51, ptr %retval, align 1
  br label %return

sw.bb167:                                         ; preds = %entry
  %52 = load i8, ptr %have_vec, align 1
  %tobool168 = trunc i8 %52 to i1
  br i1 %tobool168, label %land.rhs169, label %land.end176

land.rhs169:                                      ; preds = %sw.bb167
  %53 = load i32, ptr @cpuinfo, align 4
  %and170 = and i32 %53, 4096
  %tobool171 = icmp ne i32 %and170, 0
  br i1 %tobool171, label %land.rhs172, label %land.end175

land.rhs172:                                      ; preds = %land.rhs169
  %54 = load i32, ptr @cpuinfo, align 4
  %and173 = and i32 %54, 2048
  %tobool174 = icmp ne i32 %and173, 0
  br label %land.end175

land.end175:                                      ; preds = %land.rhs172, %land.rhs169
  %55 = phi i1 [ false, %land.rhs169 ], [ %tobool174, %land.rhs172 ]
  br label %land.end176

land.end176:                                      ; preds = %land.end175, %sw.bb167
  %56 = phi i1 [ false, %sw.bb167 ], [ %55, %land.end175 ]
  store i1 %56, ptr %retval, align 1
  br label %return

sw.bb177:                                         ; preds = %entry
  %57 = load i8, ptr %have_vec, align 1
  %tobool178 = trunc i8 %57 to i1
  br i1 %tobool178, label %land.rhs179, label %land.end180

land.rhs179:                                      ; preds = %sw.bb177
  br label %land.end180

land.end180:                                      ; preds = %land.rhs179, %sw.bb177
  %58 = phi i1 [ false, %sw.bb177 ], [ false, %land.rhs179 ]
  store i1 %58, ptr %retval, align 1
  br label %return

sw.bb181:                                         ; preds = %entry, %entry
  %59 = load i8, ptr %have_vec, align 1
  %tobool182 = trunc i8 %59 to i1
  br i1 %tobool182, label %land.rhs183, label %land.end190

land.rhs183:                                      ; preds = %sw.bb181
  %60 = load i32, ptr @cpuinfo, align 4
  %and184 = and i32 %60, 4096
  %tobool185 = icmp ne i32 %and184, 0
  br i1 %tobool185, label %land.rhs186, label %land.end189

land.rhs186:                                      ; preds = %land.rhs183
  %61 = load i32, ptr @cpuinfo, align 4
  %and187 = and i32 %61, 2048
  %tobool188 = icmp ne i32 %and187, 0
  br label %land.end189

land.end189:                                      ; preds = %land.rhs186, %land.rhs183
  %62 = phi i1 [ false, %land.rhs183 ], [ %tobool188, %land.rhs186 ]
  br label %land.end190

land.end190:                                      ; preds = %land.end189, %sw.bb181
  %63 = phi i1 [ false, %sw.bb181 ], [ %62, %land.end189 ]
  store i1 %63, ptr %retval, align 1
  br label %return

sw.bb191:                                         ; preds = %entry, %entry, %entry, %entry
  %64 = load i8, ptr %have_vec, align 1
  %tobool192 = trunc i8 %64 to i1
  br i1 %tobool192, label %land.rhs193, label %land.end194

land.rhs193:                                      ; preds = %sw.bb191
  br label %land.end194

land.end194:                                      ; preds = %land.rhs193, %sw.bb191
  %65 = phi i1 [ false, %sw.bb191 ], [ true, %land.rhs193 ]
  store i1 %65, ptr %retval, align 1
  br label %return

sw.bb195:                                         ; preds = %entry, %entry, %entry, %entry
  %66 = load i8, ptr %have_vec, align 1
  %tobool196 = trunc i8 %66 to i1
  br i1 %tobool196, label %land.rhs197, label %land.end198

land.rhs197:                                      ; preds = %sw.bb195
  br label %land.end198

land.end198:                                      ; preds = %land.rhs197, %sw.bb195
  %67 = phi i1 [ false, %sw.bb195 ], [ true, %land.rhs197 ]
  store i1 %67, ptr %retval, align 1
  br label %return

sw.bb199:                                         ; preds = %entry
  %68 = load i8, ptr %have_vec, align 1
  %tobool200 = trunc i8 %68 to i1
  br i1 %tobool200, label %land.rhs201, label %land.end208

land.rhs201:                                      ; preds = %sw.bb199
  %69 = load i32, ptr @cpuinfo, align 4
  %and202 = and i32 %69, 4096
  %tobool203 = icmp ne i32 %and202, 0
  br i1 %tobool203, label %land.rhs204, label %land.end207

land.rhs204:                                      ; preds = %land.rhs201
  %70 = load i32, ptr @cpuinfo, align 4
  %and205 = and i32 %70, 2048
  %tobool206 = icmp ne i32 %and205, 0
  br label %land.end207

land.end207:                                      ; preds = %land.rhs204, %land.rhs201
  %71 = phi i1 [ false, %land.rhs201 ], [ %tobool206, %land.rhs204 ]
  br label %land.end208

land.end208:                                      ; preds = %land.end207, %sw.bb199
  %72 = phi i1 [ false, %sw.bb199 ], [ %71, %land.end207 ]
  store i1 %72, ptr %retval, align 1
  br label %return

sw.bb209:                                         ; preds = %entry
  %73 = load i8, ptr %have_vec, align 1
  %tobool210 = trunc i8 %73 to i1
  br i1 %tobool210, label %land.rhs211, label %land.end212

land.rhs211:                                      ; preds = %sw.bb209
  br label %land.end212

land.end212:                                      ; preds = %land.rhs211, %sw.bb209
  %74 = phi i1 [ false, %sw.bb209 ], [ true, %land.rhs211 ]
  store i1 %74, ptr %retval, align 1
  br label %return

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  %75 = load i32, ptr %op.addr, align 4
  %cmp = icmp ugt i32 %75, 193
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %do.body
  %76 = load i32, ptr %op.addr, align 4
  %cmp213 = icmp ult i32 %76, 206
  br i1 %cmp213, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %do.body
  unreachable

if.end:                                           ; preds = %land.lhs.true
  br label %do.end

do.end:                                           ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %do.end, %land.end212, %land.end208, %land.end198, %land.end194, %land.end190, %land.end180, %land.end176, %land.end166, %land.end160, %land.end156, %land.end152, %land.end148, %land.end138, %land.end128, %land.end118, %land.end108, %land.end104, %land.end100, %land.end96, %land.end, %sw.bb83, %sw.bb82, %sw.bb81, %sw.bb80, %sw.bb79, %sw.bb78, %sw.bb77, %sw.bb74, %sw.bb73, %sw.bb72, %sw.bb71, %sw.bb70, %sw.bb69, %sw.bb68, %sw.bb65, %sw.bb64, %sw.bb63, %sw.bb62, %sw.bb61, %sw.bb60, %sw.bb59, %sw.bb58, %sw.bb57, %sw.bb56, %sw.bb55, %sw.bb54, %sw.bb53, %sw.bb52, %sw.bb51, %sw.bb50, %sw.bb49, %sw.bb48, %sw.bb47, %sw.bb46, %sw.bb45, %sw.bb44, %sw.bb43, %sw.bb40, %sw.bb39, %sw.bb38, %sw.bb37, %sw.bb36, %sw.bb35, %sw.bb34, %sw.bb31, %sw.bb30, %sw.bb29, %sw.bb28, %sw.bb27, %sw.bb26, %sw.bb25, %sw.bb24, %sw.bb23, %sw.bb22, %sw.bb21, %sw.bb20, %sw.bb19, %sw.bb18, %sw.bb17, %sw.bb16, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb5, %sw.bb4, %sw.bb
  %77 = load i1, ptr %retval, align 1
  ret i1 %77
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_gen_call0(ptr noundef %info, ptr noundef %ret) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %1 = load ptr, ptr %ret.addr, align 8
  call void @tcg_gen_callN(ptr noundef %0, ptr noundef %1, ptr noundef null)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_gen_callN(ptr noundef %info, ptr noundef %ret, ptr noundef %args) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  %args.addr = alloca ptr, align 8
  %extend_free = alloca [7 x ptr], align 16
  %n_extend = alloca i32, align 4
  %op = alloca ptr, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %pi = alloca i32, align 4
  %total_args = alloca i32, align 4
  %tmp = alloca i32, align 4
  %gapg_temp_newval = alloca i64, align 8
  %gapg_temp_atomic = alloca ptr, align 8
  %tmp1 = alloca i64, align 8
  %loc = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %temp = alloca ptr, align 8
  %orig = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  store ptr %args, ptr %args.addr, align 8
  store i32 0, ptr %n_extend, align 4
  store i32 0, ptr %pi, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %init = getelementptr inbounds %struct.TCGHelperInfo, ptr %0, i32 0, i32 2
  store ptr %init, ptr %gapg_temp_atomic, align 8
  %1 = load ptr, ptr %gapg_temp_atomic, align 8
  %2 = load atomic i64, ptr %1 seq_cst, align 8
  store i64 %2, ptr %gapg_temp_newval, align 8
  %3 = load i64, ptr %gapg_temp_newval, align 8
  store i64 %3, ptr %tmp1, align 8
  %4 = load i64, ptr %tmp1, align 8
  %tobool = icmp ne i64 %4, 0
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %5 = load ptr, ptr %info.addr, align 8
  %init2 = getelementptr inbounds %struct.TCGHelperInfo, ptr %5, i32 0, i32 2
  %call = call i32 @g_once_init_enter(ptr noundef %init2)
  %tobool3 = icmp ne i32 %call, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %6 = phi i1 [ false, %entry ], [ %tobool3, %land.rhs ]
  %land.ext = zext i1 %6 to i32
  store i32 %land.ext, ptr %tmp, align 4
  %7 = load i32, ptr %tmp, align 4
  %tobool4 = icmp ne i32 %7, 0
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool6 = icmp ne i64 %conv, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  %8 = load ptr, ptr %info.addr, align 8
  call void @init_call_layout(ptr noundef %8)
  %9 = load ptr, ptr %info.addr, align 8
  %init7 = getelementptr inbounds %struct.TCGHelperInfo, ptr %9, i32 0, i32 2
  call void @g_once_init_leave(ptr noundef %init7, i64 noundef 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.end
  %10 = load ptr, ptr %info.addr, align 8
  %nr_out = getelementptr inbounds %struct.TCGHelperInfo, ptr %10, i32 0, i32 3
  %bf.load = load i64, ptr %nr_out, align 8
  %bf.lshr = lshr i64 %bf.load, 48
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  %11 = load ptr, ptr %info.addr, align 8
  %nr_in = getelementptr inbounds %struct.TCGHelperInfo, ptr %11, i32 0, i32 3
  %bf.load8 = load i64, ptr %nr_in, align 8
  %bf.lshr9 = lshr i64 %bf.load8, 40
  %bf.clear10 = and i64 %bf.lshr9, 255
  %bf.cast11 = trunc i64 %bf.clear10 to i32
  %add = add i32 %bf.cast, %bf.cast11
  %add12 = add i32 %add, 2
  store i32 %add12, ptr %total_args, align 4
  %12 = load i32, ptr %total_args, align 4
  %call13 = call ptr @tcg_op_alloc(i32 noundef 2, i32 noundef %12)
  store ptr %call13, ptr %op, align 8
  %13 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %14 = load ptr, ptr %13, align 8
  %plugin_insn = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 34
  %15 = load ptr, ptr %plugin_insn, align 8
  %tobool14 = icmp ne ptr %15, null
  br i1 %tobool14, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.end
  %16 = load ptr, ptr %info.addr, align 8
  %flags = getelementptr inbounds %struct.TCGHelperInfo, ptr %16, i32 0, i32 3
  %bf.load15 = load i64, ptr %flags, align 8
  %bf.lshr16 = lshr i64 %bf.load15, 32
  %bf.clear17 = and i64 %bf.lshr16, 255
  %bf.cast18 = trunc i64 %bf.clear17 to i32
  %and = and i32 %bf.cast18, 16
  %tobool19 = icmp ne i32 %and, 0
  br i1 %tobool19, label %if.end30, label %land.lhs.true20

land.lhs.true20:                                  ; preds = %land.lhs.true
  %17 = load ptr, ptr %info.addr, align 8
  %flags21 = getelementptr inbounds %struct.TCGHelperInfo, ptr %17, i32 0, i32 3
  %bf.load22 = load i64, ptr %flags21, align 8
  %bf.lshr23 = lshr i64 %bf.load22, 32
  %bf.clear24 = and i64 %bf.lshr23, 255
  %bf.cast25 = trunc i64 %bf.clear24 to i32
  %and26 = and i32 %bf.cast25, 4
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.end30, label %if.then28

if.then28:                                        ; preds = %land.lhs.true20
  %18 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %19 = load ptr, ptr %18, align 8
  %plugin_insn29 = getelementptr inbounds %struct.TCGContext, ptr %19, i32 0, i32 34
  %20 = load ptr, ptr %plugin_insn29, align 8
  %calls_helpers = getelementptr inbounds %struct.qemu_plugin_insn, ptr %20, i32 0, i32 4
  store i8 1, ptr %calls_helpers, align 8
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %land.lhs.true20, %land.lhs.true, %if.end
  %21 = load ptr, ptr %info.addr, align 8
  %nr_out31 = getelementptr inbounds %struct.TCGHelperInfo, ptr %21, i32 0, i32 3
  %bf.load32 = load i64, ptr %nr_out31, align 8
  %bf.lshr33 = lshr i64 %bf.load32, 48
  %bf.clear34 = and i64 %bf.lshr33, 255
  %bf.cast35 = trunc i64 %bf.clear34 to i32
  store i32 %bf.cast35, ptr %n, align 4
  %22 = load ptr, ptr %op, align 8
  %bf.load36 = load i32, ptr %22, align 8
  %bf.value = and i32 %bf.cast35, 255
  %bf.shl = shl i32 %bf.value, 24
  %bf.clear37 = and i32 %bf.load36, 16777215
  %bf.set = or i32 %bf.clear37, %bf.shl
  store i32 %bf.set, ptr %22, align 8
  %23 = load i32, ptr %n, align 4
  switch i32 %23, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb41
    i32 2, label %sw.bb50
    i32 4, label %sw.bb50
  ]

sw.bb:                                            ; preds = %if.end30
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %24 = load ptr, ptr %ret.addr, align 8
  %cmp = icmp eq ptr %24, null
  br i1 %cmp, label %if.end40, label %if.then39

if.then39:                                        ; preds = %do.body
  unreachable

if.end40:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end40
  br label %sw.epilog

sw.bb41:                                          ; preds = %if.end30
  br label %do.body42

do.body42:                                        ; preds = %sw.bb41
  %25 = load ptr, ptr %ret.addr, align 8
  %cmp43 = icmp ne ptr %25, null
  br i1 %cmp43, label %if.end46, label %if.then45

if.then45:                                        ; preds = %do.body42
  unreachable

if.end46:                                         ; preds = %do.body42
  br label %do.end47

do.end47:                                         ; preds = %if.end46
  %26 = load ptr, ptr %ret.addr, align 8
  %call48 = call i64 @temp_arg(ptr noundef %26)
  %27 = load ptr, ptr %op, align 8
  %args49 = getelementptr inbounds %struct.TCGOp, ptr %27, i32 0, i32 4
  %28 = load i32, ptr %pi, align 4
  %inc = add i32 %28, 1
  store i32 %inc, ptr %pi, align 4
  %idxprom = sext i32 %28 to i64
  %arrayidx = getelementptr [0 x i64], ptr %args49, i64 0, i64 %idxprom
  store i64 %call48, ptr %arrayidx, align 8
  br label %sw.epilog

sw.bb50:                                          ; preds = %if.end30, %if.end30
  br label %do.body51

do.body51:                                        ; preds = %sw.bb50
  %29 = load ptr, ptr %ret.addr, align 8
  %cmp52 = icmp ne ptr %29, null
  br i1 %cmp52, label %if.end55, label %if.then54

if.then54:                                        ; preds = %do.body51
  unreachable

if.end55:                                         ; preds = %do.body51
  br label %do.end56

do.end56:                                         ; preds = %if.end55
  br label %do.body57

do.body57:                                        ; preds = %do.end56
  %30 = load ptr, ptr %ret.addr, align 8
  %bf.load58 = load i64, ptr %30, align 8
  %bf.lshr59 = lshr i64 %bf.load58, 16
  %bf.clear60 = and i64 %bf.lshr59, 255
  %bf.cast61 = trunc i64 %bf.clear60 to i32
  %31 = load ptr, ptr %ret.addr, align 8
  %bf.load62 = load i64, ptr %31, align 8
  %bf.lshr63 = lshr i64 %bf.load62, 24
  %bf.clear64 = and i64 %bf.lshr63, 255
  %bf.cast65 = trunc i64 %bf.clear64 to i32
  %32 = load i32, ptr %n, align 4
  %call66 = call i32 @ctz32(i32 noundef %32)
  %add67 = add i32 %bf.cast65, %call66
  %cmp68 = icmp eq i32 %bf.cast61, %add67
  br i1 %cmp68, label %if.end71, label %if.then70

if.then70:                                        ; preds = %do.body57
  unreachable

if.end71:                                         ; preds = %do.body57
  br label %do.end72

do.end72:                                         ; preds = %if.end71
  br label %do.body73

do.body73:                                        ; preds = %do.end72
  %33 = load ptr, ptr %ret.addr, align 8
  %bf.load74 = load i64, ptr %33, align 8
  %bf.lshr75 = lshr i64 %bf.load74, 40
  %bf.clear76 = and i64 %bf.lshr75, 1
  %bf.cast77 = trunc i64 %bf.clear76 to i32
  %cmp78 = icmp eq i32 %bf.cast77, 0
  br i1 %cmp78, label %if.end81, label %if.then80

if.then80:                                        ; preds = %do.body73
  unreachable

if.end81:                                         ; preds = %do.body73
  br label %do.end82

do.end82:                                         ; preds = %if.end81
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end82
  %34 = load i32, ptr %i, align 4
  %35 = load i32, ptr %n, align 4
  %cmp83 = icmp slt i32 %34, %35
  br i1 %cmp83, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load ptr, ptr %ret.addr, align 8
  %37 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %37 to i64
  %add.ptr = getelementptr %struct.TCGTemp, ptr %36, i64 %idx.ext
  %call85 = call i64 @temp_arg(ptr noundef %add.ptr)
  %38 = load ptr, ptr %op, align 8
  %args86 = getelementptr inbounds %struct.TCGOp, ptr %38, i32 0, i32 4
  %39 = load i32, ptr %pi, align 4
  %inc87 = add i32 %39, 1
  store i32 %inc87, ptr %pi, align 4
  %idxprom88 = sext i32 %39 to i64
  %arrayidx89 = getelementptr [0 x i64], ptr %args86, i64 0, i64 %idxprom88
  store i64 %call85, ptr %arrayidx89, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %40 = load i32, ptr %i, align 4
  %inc90 = add i32 %40, 1
  store i32 %inc90, ptr %i, align 4
  br label %for.cond, !llvm.loop !19

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.default:                                       ; preds = %if.end30
  br label %do.body91

do.body91:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 2290, ptr noundef @__func__.tcg_gen_callN, ptr noundef null) #15
  unreachable

do.end92:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end92, %for.end, %do.end47, %do.end
  %41 = load ptr, ptr %info.addr, align 8
  %nr_in93 = getelementptr inbounds %struct.TCGHelperInfo, ptr %41, i32 0, i32 3
  %bf.load94 = load i64, ptr %nr_in93, align 8
  %bf.lshr95 = lshr i64 %bf.load94, 40
  %bf.clear96 = and i64 %bf.lshr95, 255
  %bf.cast97 = trunc i64 %bf.clear96 to i32
  store i32 %bf.cast97, ptr %n, align 4
  %42 = load ptr, ptr %op, align 8
  %bf.load98 = load i32, ptr %42, align 8
  %bf.value99 = and i32 %bf.cast97, 255
  %bf.shl100 = shl i32 %bf.value99, 16
  %bf.clear101 = and i32 %bf.load98, -16711681
  %bf.set102 = or i32 %bf.clear101, %bf.shl100
  store i32 %bf.set102, ptr %42, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond103

for.cond103:                                      ; preds = %for.inc148, %sw.epilog
  %43 = load i32, ptr %i, align 4
  %44 = load i32, ptr %n, align 4
  %cmp104 = icmp slt i32 %43, %44
  br i1 %cmp104, label %for.body106, label %for.end150

for.body106:                                      ; preds = %for.cond103
  %45 = load ptr, ptr %info.addr, align 8
  %in = getelementptr inbounds %struct.TCGHelperInfo, ptr %45, i32 0, i32 4
  %46 = load i32, ptr %i, align 4
  %idxprom107 = sext i32 %46 to i64
  %arrayidx108 = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in, i64 0, i64 %idxprom107
  store ptr %arrayidx108, ptr %loc, align 8
  %47 = load ptr, ptr %args.addr, align 8
  %48 = load ptr, ptr %loc, align 8
  %bf.load109 = load i32, ptr %48, align 4
  %bf.lshr110 = lshr i32 %bf.load109, 24
  %bf.clear111 = and i32 %bf.lshr110, 15
  %idxprom112 = zext i32 %bf.clear111 to i64
  %arrayidx113 = getelementptr ptr, ptr %47, i64 %idxprom112
  %49 = load ptr, ptr %arrayidx113, align 8
  %50 = load ptr, ptr %loc, align 8
  %bf.load114 = load i32, ptr %50, align 4
  %bf.lshr115 = lshr i32 %bf.load114, 28
  %bf.clear116 = and i32 %bf.lshr115, 3
  %idx.ext117 = sext i32 %bf.clear116 to i64
  %add.ptr118 = getelementptr %struct.TCGTemp, ptr %49, i64 %idx.ext117
  store ptr %add.ptr118, ptr %ts, align 8
  %51 = load ptr, ptr %loc, align 8
  %bf.load119 = load i32, ptr %51, align 4
  %bf.clear120 = and i32 %bf.load119, 255
  switch i32 %bf.clear120, label %sw.default144 [
    i32 0, label %sw.bb121
    i32 5, label %sw.bb121
    i32 6, label %sw.bb121
    i32 3, label %sw.bb127
    i32 4, label %sw.bb127
  ]

sw.bb121:                                         ; preds = %for.body106, %for.body106, %for.body106
  %52 = load ptr, ptr %ts, align 8
  %call122 = call i64 @temp_arg(ptr noundef %52)
  %53 = load ptr, ptr %op, align 8
  %args123 = getelementptr inbounds %struct.TCGOp, ptr %53, i32 0, i32 4
  %54 = load i32, ptr %pi, align 4
  %inc124 = add i32 %54, 1
  store i32 %inc124, ptr %pi, align 4
  %idxprom125 = sext i32 %54 to i64
  %arrayidx126 = getelementptr [0 x i64], ptr %args123, i64 0, i64 %idxprom125
  store i64 %call122, ptr %arrayidx126, align 8
  br label %sw.epilog147

sw.bb127:                                         ; preds = %for.body106, %for.body106
  %call128 = call ptr @tcg_temp_ebb_new_i64()
  store ptr %call128, ptr %temp, align 8
  %55 = load ptr, ptr %ts, align 8
  %call129 = call ptr @temp_tcgv_i32(ptr noundef %55)
  store ptr %call129, ptr %orig, align 8
  %56 = load ptr, ptr %loc, align 8
  %bf.load130 = load i32, ptr %56, align 4
  %bf.clear131 = and i32 %bf.load130, 255
  %cmp132 = icmp eq i32 %bf.clear131, 4
  br i1 %cmp132, label %if.then134, label %if.else

if.then134:                                       ; preds = %sw.bb127
  %57 = load ptr, ptr %temp, align 8
  %58 = load ptr, ptr %orig, align 8
  call void @tcg_gen_ext_i32_i64(ptr noundef %57, ptr noundef %58)
  br label %if.end135

if.else:                                          ; preds = %sw.bb127
  %59 = load ptr, ptr %temp, align 8
  %60 = load ptr, ptr %orig, align 8
  call void @tcg_gen_extu_i32_i64(ptr noundef %59, ptr noundef %60)
  br label %if.end135

if.end135:                                        ; preds = %if.else, %if.then134
  %61 = load ptr, ptr %temp, align 8
  %call136 = call i64 @tcgv_i64_arg(ptr noundef %61)
  %62 = load ptr, ptr %op, align 8
  %args137 = getelementptr inbounds %struct.TCGOp, ptr %62, i32 0, i32 4
  %63 = load i32, ptr %pi, align 4
  %inc138 = add i32 %63, 1
  store i32 %inc138, ptr %pi, align 4
  %idxprom139 = sext i32 %63 to i64
  %arrayidx140 = getelementptr [0 x i64], ptr %args137, i64 0, i64 %idxprom139
  store i64 %call136, ptr %arrayidx140, align 8
  %64 = load ptr, ptr %temp, align 8
  %65 = load i32, ptr %n_extend, align 4
  %inc141 = add i32 %65, 1
  store i32 %inc141, ptr %n_extend, align 4
  %idxprom142 = sext i32 %65 to i64
  %arrayidx143 = getelementptr [7 x ptr], ptr %extend_free, i64 0, i64 %idxprom142
  store ptr %64, ptr %arrayidx143, align 8
  br label %sw.epilog147

sw.default144:                                    ; preds = %for.body106
  br label %do.body145

do.body145:                                       ; preds = %sw.default144
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 2322, ptr noundef @__func__.tcg_gen_callN, ptr noundef null) #15
  unreachable

do.end146:                                        ; No predecessors!
  br label %sw.epilog147

sw.epilog147:                                     ; preds = %do.end146, %if.end135, %sw.bb121
  br label %for.inc148

for.inc148:                                       ; preds = %sw.epilog147
  %66 = load i32, ptr %i, align 4
  %inc149 = add i32 %66, 1
  store i32 %inc149, ptr %i, align 4
  br label %for.cond103, !llvm.loop !20

for.end150:                                       ; preds = %for.cond103
  %67 = load ptr, ptr %info.addr, align 8
  %func = getelementptr inbounds %struct.TCGHelperInfo, ptr %67, i32 0, i32 0
  %68 = load ptr, ptr %func, align 8
  %69 = ptrtoint ptr %68 to i64
  %70 = load ptr, ptr %op, align 8
  %args151 = getelementptr inbounds %struct.TCGOp, ptr %70, i32 0, i32 4
  %71 = load i32, ptr %pi, align 4
  %inc152 = add i32 %71, 1
  store i32 %inc152, ptr %pi, align 4
  %idxprom153 = sext i32 %71 to i64
  %arrayidx154 = getelementptr [0 x i64], ptr %args151, i64 0, i64 %idxprom153
  store i64 %69, ptr %arrayidx154, align 8
  %72 = load ptr, ptr %info.addr, align 8
  %73 = ptrtoint ptr %72 to i64
  %74 = load ptr, ptr %op, align 8
  %args155 = getelementptr inbounds %struct.TCGOp, ptr %74, i32 0, i32 4
  %75 = load i32, ptr %pi, align 4
  %inc156 = add i32 %75, 1
  store i32 %inc156, ptr %pi, align 4
  %idxprom157 = sext i32 %75 to i64
  %arrayidx158 = getelementptr [0 x i64], ptr %args155, i64 0, i64 %idxprom157
  store i64 %73, ptr %arrayidx158, align 8
  br label %do.body159

do.body159:                                       ; preds = %for.end150
  %76 = load i32, ptr %pi, align 4
  %77 = load i32, ptr %total_args, align 4
  %cmp160 = icmp eq i32 %76, %77
  br i1 %cmp160, label %if.end163, label %if.then162

if.then162:                                       ; preds = %do.body159
  unreachable

if.end163:                                        ; preds = %do.body159
  br label %do.end164

do.end164:                                        ; preds = %if.end163
  br label %do.body165

do.body165:                                       ; preds = %do.end164
  %78 = load ptr, ptr %op, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %78, i32 0, i32 2
  store ptr null, ptr %link, align 8
  %79 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %80 = load ptr, ptr %79, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %80, i32 0, i32 38
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %ops, i32 0, i32 1
  %81 = load ptr, ptr %tql_prev, align 8
  %82 = load ptr, ptr %op, align 8
  %link166 = getelementptr inbounds %struct.TCGOp, ptr %82, i32 0, i32 2
  %tql_prev167 = getelementptr inbounds %struct.QTailQLink, ptr %link166, i32 0, i32 1
  store ptr %81, ptr %tql_prev167, align 8
  %83 = load ptr, ptr %op, align 8
  %84 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %85 = load ptr, ptr %84, align 8
  %ops168 = getelementptr inbounds %struct.TCGContext, ptr %85, i32 0, i32 38
  %tql_prev169 = getelementptr inbounds %struct.QTailQLink, ptr %ops168, i32 0, i32 1
  %86 = load ptr, ptr %tql_prev169, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %86, i32 0, i32 0
  store ptr %83, ptr %tql_next, align 8
  %87 = load ptr, ptr %op, align 8
  %link170 = getelementptr inbounds %struct.TCGOp, ptr %87, i32 0, i32 2
  %88 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %89 = load ptr, ptr %88, align 8
  %ops171 = getelementptr inbounds %struct.TCGContext, ptr %89, i32 0, i32 38
  %tql_prev172 = getelementptr inbounds %struct.QTailQLink, ptr %ops171, i32 0, i32 1
  store ptr %link170, ptr %tql_prev172, align 8
  br label %do.end173

do.end173:                                        ; preds = %do.body165
  br label %do.body174

do.body174:                                       ; preds = %do.end173
  %90 = load i32, ptr %n_extend, align 4
  %conv175 = sext i32 %90 to i64
  %cmp176 = icmp ult i64 %conv175, 7
  br i1 %cmp176, label %if.end179, label %if.then178

if.then178:                                       ; preds = %do.body174
  unreachable

if.end179:                                        ; preds = %do.body174
  br label %do.end180

do.end180:                                        ; preds = %if.end179
  store i32 0, ptr %i, align 4
  br label %for.cond181

for.cond181:                                      ; preds = %for.inc187, %do.end180
  %91 = load i32, ptr %i, align 4
  %92 = load i32, ptr %n_extend, align 4
  %cmp182 = icmp slt i32 %91, %92
  br i1 %cmp182, label %for.body184, label %for.end189

for.body184:                                      ; preds = %for.cond181
  %93 = load i32, ptr %i, align 4
  %idxprom185 = sext i32 %93 to i64
  %arrayidx186 = getelementptr [7 x ptr], ptr %extend_free, i64 0, i64 %idxprom185
  %94 = load ptr, ptr %arrayidx186, align 8
  call void @tcg_temp_free_i64(ptr noundef %94)
  br label %for.inc187

for.inc187:                                       ; preds = %for.body184
  %95 = load i32, ptr %i, align 4
  %inc188 = add i32 %95, 1
  store i32 %inc188, ptr %i, align 4
  br label %for.cond181, !llvm.loop !21

for.end189:                                       ; preds = %for.cond181
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_gen_call1(ptr noundef %info, ptr noundef %ret, ptr noundef %t1) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  %t1.addr = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  %0 = load ptr, ptr %info.addr, align 8
  %1 = load ptr, ptr %ret.addr, align 8
  call void @tcg_gen_callN(ptr noundef %0, ptr noundef %1, ptr noundef %t1.addr)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_gen_call2(ptr noundef %info, ptr noundef %ret, ptr noundef %t1, ptr noundef %t2) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %args = alloca [2 x ptr], align 16
  store ptr %info, ptr %info.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  %arrayinit.begin = getelementptr inbounds [2 x ptr], ptr %args, i64 0, i64 0
  %0 = load ptr, ptr %t1.addr, align 8
  store ptr %0, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds ptr, ptr %arrayinit.begin, i64 1
  %1 = load ptr, ptr %t2.addr, align 8
  store ptr %1, ptr %arrayinit.element, align 8
  %2 = load ptr, ptr %info.addr, align 8
  %3 = load ptr, ptr %ret.addr, align 8
  %arraydecay = getelementptr inbounds [2 x ptr], ptr %args, i64 0, i64 0
  call void @tcg_gen_callN(ptr noundef %2, ptr noundef %3, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_gen_call3(ptr noundef %info, ptr noundef %ret, ptr noundef %t1, ptr noundef %t2, ptr noundef %t3) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %t3.addr = alloca ptr, align 8
  %args = alloca [3 x ptr], align 16
  store ptr %info, ptr %info.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  store ptr %t3, ptr %t3.addr, align 8
  %arrayinit.begin = getelementptr inbounds [3 x ptr], ptr %args, i64 0, i64 0
  %0 = load ptr, ptr %t1.addr, align 8
  store ptr %0, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds ptr, ptr %arrayinit.begin, i64 1
  %1 = load ptr, ptr %t2.addr, align 8
  store ptr %1, ptr %arrayinit.element, align 8
  %arrayinit.element1 = getelementptr inbounds ptr, ptr %arrayinit.element, i64 1
  %2 = load ptr, ptr %t3.addr, align 8
  store ptr %2, ptr %arrayinit.element1, align 8
  %3 = load ptr, ptr %info.addr, align 8
  %4 = load ptr, ptr %ret.addr, align 8
  %arraydecay = getelementptr inbounds [3 x ptr], ptr %args, i64 0, i64 0
  call void @tcg_gen_callN(ptr noundef %3, ptr noundef %4, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_gen_call4(ptr noundef %info, ptr noundef %ret, ptr noundef %t1, ptr noundef %t2, ptr noundef %t3, ptr noundef %t4) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %t3.addr = alloca ptr, align 8
  %t4.addr = alloca ptr, align 8
  %args = alloca [4 x ptr], align 16
  store ptr %info, ptr %info.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  store ptr %t3, ptr %t3.addr, align 8
  store ptr %t4, ptr %t4.addr, align 8
  %arrayinit.begin = getelementptr inbounds [4 x ptr], ptr %args, i64 0, i64 0
  %0 = load ptr, ptr %t1.addr, align 8
  store ptr %0, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds ptr, ptr %arrayinit.begin, i64 1
  %1 = load ptr, ptr %t2.addr, align 8
  store ptr %1, ptr %arrayinit.element, align 8
  %arrayinit.element1 = getelementptr inbounds ptr, ptr %arrayinit.element, i64 1
  %2 = load ptr, ptr %t3.addr, align 8
  store ptr %2, ptr %arrayinit.element1, align 8
  %arrayinit.element2 = getelementptr inbounds ptr, ptr %arrayinit.element1, i64 1
  %3 = load ptr, ptr %t4.addr, align 8
  store ptr %3, ptr %arrayinit.element2, align 8
  %4 = load ptr, ptr %info.addr, align 8
  %5 = load ptr, ptr %ret.addr, align 8
  %arraydecay = getelementptr inbounds [4 x ptr], ptr %args, i64 0, i64 0
  call void @tcg_gen_callN(ptr noundef %4, ptr noundef %5, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_gen_call5(ptr noundef %info, ptr noundef %ret, ptr noundef %t1, ptr noundef %t2, ptr noundef %t3, ptr noundef %t4, ptr noundef %t5) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %t3.addr = alloca ptr, align 8
  %t4.addr = alloca ptr, align 8
  %t5.addr = alloca ptr, align 8
  %args = alloca [5 x ptr], align 16
  store ptr %info, ptr %info.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  store ptr %t3, ptr %t3.addr, align 8
  store ptr %t4, ptr %t4.addr, align 8
  store ptr %t5, ptr %t5.addr, align 8
  %arrayinit.begin = getelementptr inbounds [5 x ptr], ptr %args, i64 0, i64 0
  %0 = load ptr, ptr %t1.addr, align 8
  store ptr %0, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds ptr, ptr %arrayinit.begin, i64 1
  %1 = load ptr, ptr %t2.addr, align 8
  store ptr %1, ptr %arrayinit.element, align 8
  %arrayinit.element1 = getelementptr inbounds ptr, ptr %arrayinit.element, i64 1
  %2 = load ptr, ptr %t3.addr, align 8
  store ptr %2, ptr %arrayinit.element1, align 8
  %arrayinit.element2 = getelementptr inbounds ptr, ptr %arrayinit.element1, i64 1
  %3 = load ptr, ptr %t4.addr, align 8
  store ptr %3, ptr %arrayinit.element2, align 8
  %arrayinit.element3 = getelementptr inbounds ptr, ptr %arrayinit.element2, i64 1
  %4 = load ptr, ptr %t5.addr, align 8
  store ptr %4, ptr %arrayinit.element3, align 8
  %5 = load ptr, ptr %info.addr, align 8
  %6 = load ptr, ptr %ret.addr, align 8
  %arraydecay = getelementptr inbounds [5 x ptr], ptr %args, i64 0, i64 0
  call void @tcg_gen_callN(ptr noundef %5, ptr noundef %6, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_gen_call6(ptr noundef %info, ptr noundef %ret, ptr noundef %t1, ptr noundef %t2, ptr noundef %t3, ptr noundef %t4, ptr noundef %t5, ptr noundef %t6) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %t3.addr = alloca ptr, align 8
  %t4.addr = alloca ptr, align 8
  %t5.addr = alloca ptr, align 8
  %t6.addr = alloca ptr, align 8
  %args = alloca [6 x ptr], align 16
  store ptr %info, ptr %info.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  store ptr %t3, ptr %t3.addr, align 8
  store ptr %t4, ptr %t4.addr, align 8
  store ptr %t5, ptr %t5.addr, align 8
  store ptr %t6, ptr %t6.addr, align 8
  %arrayinit.begin = getelementptr inbounds [6 x ptr], ptr %args, i64 0, i64 0
  %0 = load ptr, ptr %t1.addr, align 8
  store ptr %0, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds ptr, ptr %arrayinit.begin, i64 1
  %1 = load ptr, ptr %t2.addr, align 8
  store ptr %1, ptr %arrayinit.element, align 8
  %arrayinit.element1 = getelementptr inbounds ptr, ptr %arrayinit.element, i64 1
  %2 = load ptr, ptr %t3.addr, align 8
  store ptr %2, ptr %arrayinit.element1, align 8
  %arrayinit.element2 = getelementptr inbounds ptr, ptr %arrayinit.element1, i64 1
  %3 = load ptr, ptr %t4.addr, align 8
  store ptr %3, ptr %arrayinit.element2, align 8
  %arrayinit.element3 = getelementptr inbounds ptr, ptr %arrayinit.element2, i64 1
  %4 = load ptr, ptr %t5.addr, align 8
  store ptr %4, ptr %arrayinit.element3, align 8
  %arrayinit.element4 = getelementptr inbounds ptr, ptr %arrayinit.element3, i64 1
  %5 = load ptr, ptr %t6.addr, align 8
  store ptr %5, ptr %arrayinit.element4, align 8
  %6 = load ptr, ptr %info.addr, align 8
  %7 = load ptr, ptr %ret.addr, align 8
  %arraydecay = getelementptr inbounds [6 x ptr], ptr %args, i64 0, i64 0
  call void @tcg_gen_callN(ptr noundef %6, ptr noundef %7, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_gen_call7(ptr noundef %info, ptr noundef %ret, ptr noundef %t1, ptr noundef %t2, ptr noundef %t3, ptr noundef %t4, ptr noundef %t5, ptr noundef %t6, ptr noundef %t7) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %ret.addr = alloca ptr, align 8
  %t1.addr = alloca ptr, align 8
  %t2.addr = alloca ptr, align 8
  %t3.addr = alloca ptr, align 8
  %t4.addr = alloca ptr, align 8
  %t5.addr = alloca ptr, align 8
  %t6.addr = alloca ptr, align 8
  %t7.addr = alloca ptr, align 8
  %args = alloca [7 x ptr], align 16
  store ptr %info, ptr %info.addr, align 8
  store ptr %ret, ptr %ret.addr, align 8
  store ptr %t1, ptr %t1.addr, align 8
  store ptr %t2, ptr %t2.addr, align 8
  store ptr %t3, ptr %t3.addr, align 8
  store ptr %t4, ptr %t4.addr, align 8
  store ptr %t5, ptr %t5.addr, align 8
  store ptr %t6, ptr %t6.addr, align 8
  store ptr %t7, ptr %t7.addr, align 8
  %arrayinit.begin = getelementptr inbounds [7 x ptr], ptr %args, i64 0, i64 0
  %0 = load ptr, ptr %t1.addr, align 8
  store ptr %0, ptr %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds ptr, ptr %arrayinit.begin, i64 1
  %1 = load ptr, ptr %t2.addr, align 8
  store ptr %1, ptr %arrayinit.element, align 8
  %arrayinit.element1 = getelementptr inbounds ptr, ptr %arrayinit.element, i64 1
  %2 = load ptr, ptr %t3.addr, align 8
  store ptr %2, ptr %arrayinit.element1, align 8
  %arrayinit.element2 = getelementptr inbounds ptr, ptr %arrayinit.element1, i64 1
  %3 = load ptr, ptr %t4.addr, align 8
  store ptr %3, ptr %arrayinit.element2, align 8
  %arrayinit.element3 = getelementptr inbounds ptr, ptr %arrayinit.element2, i64 1
  %4 = load ptr, ptr %t5.addr, align 8
  store ptr %4, ptr %arrayinit.element3, align 8
  %arrayinit.element4 = getelementptr inbounds ptr, ptr %arrayinit.element3, i64 1
  %5 = load ptr, ptr %t6.addr, align 8
  store ptr %5, ptr %arrayinit.element4, align 8
  %arrayinit.element5 = getelementptr inbounds ptr, ptr %arrayinit.element4, i64 1
  %6 = load ptr, ptr %t7.addr, align 8
  store ptr %6, ptr %arrayinit.element5, align 8
  %7 = load ptr, ptr %info.addr, align 8
  %8 = load ptr, ptr %ret.addr, align 8
  %arraydecay = getelementptr inbounds [7 x ptr], ptr %args, i64 0, i64 0
  call void @tcg_gen_callN(ptr noundef %7, ptr noundef %8, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_op_remove(ptr noundef %s, ptr noundef %op) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %bf.load = load i32, ptr %0, align 8
  %bf.clear = and i32 %bf.load, 255
  switch i32 %bf.clear, label %sw.default [
    i32 3, label %sw.bb
    i32 38, label %sw.bb1
    i32 103, label %sw.bb1
    i32 45, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %op.addr, align 8
  call void @remove_label_use(ptr noundef %1, i32 noundef 0)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry, %entry
  %2 = load ptr, ptr %op.addr, align 8
  call void @remove_label_use(ptr noundef %2, i32 noundef 3)
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %3 = load ptr, ptr %op.addr, align 8
  call void @remove_label_use(ptr noundef %3, i32 noundef 5)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb2, %sw.bb1, %sw.bb
  br label %do.body

do.body:                                          ; preds = %sw.epilog
  %4 = load ptr, ptr %op.addr, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %link, align 8
  %cmp = icmp ne ptr %5, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  %6 = load ptr, ptr %op.addr, align 8
  %link3 = getelementptr inbounds %struct.TCGOp, ptr %6, i32 0, i32 2
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %link3, i32 0, i32 1
  %7 = load ptr, ptr %tql_prev, align 8
  %8 = load ptr, ptr %op.addr, align 8
  %link4 = getelementptr inbounds %struct.TCGOp, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %link4, align 8
  %link5 = getelementptr inbounds %struct.TCGOp, ptr %9, i32 0, i32 2
  %tql_prev6 = getelementptr inbounds %struct.QTailQLink, ptr %link5, i32 0, i32 1
  store ptr %7, ptr %tql_prev6, align 8
  br label %if.end

if.else:                                          ; preds = %do.body
  %10 = load ptr, ptr %op.addr, align 8
  %link7 = getelementptr inbounds %struct.TCGOp, ptr %10, i32 0, i32 2
  %tql_prev8 = getelementptr inbounds %struct.QTailQLink, ptr %link7, i32 0, i32 1
  %11 = load ptr, ptr %tql_prev8, align 8
  %12 = load ptr, ptr %s.addr, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %12, i32 0, i32 38
  %tql_prev9 = getelementptr inbounds %struct.QTailQLink, ptr %ops, i32 0, i32 1
  store ptr %11, ptr %tql_prev9, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %13 = load ptr, ptr %op.addr, align 8
  %link10 = getelementptr inbounds %struct.TCGOp, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %link10, align 8
  %15 = load ptr, ptr %op.addr, align 8
  %link11 = getelementptr inbounds %struct.TCGOp, ptr %15, i32 0, i32 2
  %tql_prev12 = getelementptr inbounds %struct.QTailQLink, ptr %link11, i32 0, i32 1
  %16 = load ptr, ptr %tql_prev12, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %16, i32 0, i32 0
  store ptr %14, ptr %tql_next, align 8
  %17 = load ptr, ptr %op.addr, align 8
  %link13 = getelementptr inbounds %struct.TCGOp, ptr %17, i32 0, i32 2
  %tql_prev14 = getelementptr inbounds %struct.QTailQLink, ptr %link13, i32 0, i32 1
  store ptr null, ptr %tql_prev14, align 8
  %18 = load ptr, ptr %op.addr, align 8
  %link15 = getelementptr inbounds %struct.TCGOp, ptr %18, i32 0, i32 2
  %tql_next16 = getelementptr inbounds %struct.QTailQLink, ptr %link15, i32 0, i32 0
  store ptr null, ptr %tql_next16, align 8
  %19 = load ptr, ptr %op.addr, align 8
  %link17 = getelementptr inbounds %struct.TCGOp, ptr %19, i32 0, i32 2
  store ptr null, ptr %link17, align 8
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body18

do.body18:                                        ; preds = %do.end
  %20 = load ptr, ptr %op.addr, align 8
  %link19 = getelementptr inbounds %struct.TCGOp, ptr %20, i32 0, i32 2
  store ptr null, ptr %link19, align 8
  %21 = load ptr, ptr %s.addr, align 8
  %free_ops = getelementptr inbounds %struct.TCGContext, ptr %21, i32 0, i32 39
  %tql_prev20 = getelementptr inbounds %struct.QTailQLink, ptr %free_ops, i32 0, i32 1
  %22 = load ptr, ptr %tql_prev20, align 8
  %23 = load ptr, ptr %op.addr, align 8
  %link21 = getelementptr inbounds %struct.TCGOp, ptr %23, i32 0, i32 2
  %tql_prev22 = getelementptr inbounds %struct.QTailQLink, ptr %link21, i32 0, i32 1
  store ptr %22, ptr %tql_prev22, align 8
  %24 = load ptr, ptr %op.addr, align 8
  %25 = load ptr, ptr %s.addr, align 8
  %free_ops23 = getelementptr inbounds %struct.TCGContext, ptr %25, i32 0, i32 39
  %tql_prev24 = getelementptr inbounds %struct.QTailQLink, ptr %free_ops23, i32 0, i32 1
  %26 = load ptr, ptr %tql_prev24, align 8
  %tql_next25 = getelementptr inbounds %struct.QTailQLink, ptr %26, i32 0, i32 0
  store ptr %24, ptr %tql_next25, align 8
  %27 = load ptr, ptr %op.addr, align 8
  %link26 = getelementptr inbounds %struct.TCGOp, ptr %27, i32 0, i32 2
  %28 = load ptr, ptr %s.addr, align 8
  %free_ops27 = getelementptr inbounds %struct.TCGContext, ptr %28, i32 0, i32 39
  %tql_prev28 = getelementptr inbounds %struct.QTailQLink, ptr %free_ops27, i32 0, i32 1
  store ptr %link26, ptr %tql_prev28, align 8
  br label %do.end29

do.end29:                                         ; preds = %do.body18
  %29 = load ptr, ptr %s.addr, align 8
  %nb_ops = getelementptr inbounds %struct.TCGContext, ptr %29, i32 0, i32 9
  %30 = load i32, ptr %nb_ops, align 8
  %dec = add i32 %30, -1
  store i32 %dec, ptr %nb_ops, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @remove_label_use(ptr noundef %op, i32 noundef %idx) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %idx.addr = alloca i32, align 4
  %label = alloca ptr, align 8
  %use = alloca ptr, align 8
  %elm = alloca ptr, align 8
  %curelm = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  store i32 %idx, ptr %idx.addr, align 4
  %0 = load ptr, ptr %op.addr, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %idx.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr [0 x i64], ptr %args, i64 0, i64 %idxprom
  %2 = load i64, ptr %arrayidx, align 8
  %call = call ptr @arg_label(i64 noundef %2)
  store ptr %call, ptr %label, align 8
  %3 = load ptr, ptr %label, align 8
  %branches = getelementptr inbounds %struct.TCGLabel, ptr %3, i32 0, i32 4
  %sqh_first = getelementptr inbounds %struct.anon, ptr %branches, i32 0, i32 0
  %4 = load ptr, ptr %sqh_first, align 8
  store ptr %4, ptr %use, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load ptr, ptr %use, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %use, align 8
  %op1 = getelementptr inbounds %struct.TCGLabelUse, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %op1, align 8
  %8 = load ptr, ptr %op.addr, align 8
  %cmp = icmp eq ptr %7, %8
  br i1 %cmp, label %if.then, label %if.end42

if.then:                                          ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then
  %9 = load ptr, ptr %label, align 8
  %branches2 = getelementptr inbounds %struct.TCGLabel, ptr %9, i32 0, i32 4
  %sqh_first3 = getelementptr inbounds %struct.anon, ptr %branches2, i32 0, i32 0
  %10 = load ptr, ptr %sqh_first3, align 8
  %11 = load ptr, ptr %use, align 8
  %cmp4 = icmp eq ptr %10, %11
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %do.body
  br label %do.body6

do.body6:                                         ; preds = %if.then5
  %12 = load ptr, ptr %label, align 8
  %branches7 = getelementptr inbounds %struct.TCGLabel, ptr %12, i32 0, i32 4
  %sqh_first8 = getelementptr inbounds %struct.anon, ptr %branches7, i32 0, i32 0
  %13 = load ptr, ptr %sqh_first8, align 8
  store ptr %13, ptr %elm, align 8
  %14 = load ptr, ptr %elm, align 8
  %next = getelementptr inbounds %struct.TCGLabelUse, ptr %14, i32 0, i32 0
  %sqe_next = getelementptr inbounds %struct.anon.6, ptr %next, i32 0, i32 0
  %15 = load ptr, ptr %sqe_next, align 8
  %16 = load ptr, ptr %label, align 8
  %branches9 = getelementptr inbounds %struct.TCGLabel, ptr %16, i32 0, i32 4
  %sqh_first10 = getelementptr inbounds %struct.anon, ptr %branches9, i32 0, i32 0
  store ptr %15, ptr %sqh_first10, align 8
  %cmp11 = icmp eq ptr %15, null
  br i1 %cmp11, label %if.then12, label %if.end

if.then12:                                        ; preds = %do.body6
  %17 = load ptr, ptr %label, align 8
  %branches13 = getelementptr inbounds %struct.TCGLabel, ptr %17, i32 0, i32 4
  %sqh_first14 = getelementptr inbounds %struct.anon, ptr %branches13, i32 0, i32 0
  %18 = load ptr, ptr %label, align 8
  %branches15 = getelementptr inbounds %struct.TCGLabel, ptr %18, i32 0, i32 4
  %sqh_last = getelementptr inbounds %struct.anon, ptr %branches15, i32 0, i32 1
  store ptr %sqh_first14, ptr %sqh_last, align 8
  br label %if.end

if.end:                                           ; preds = %if.then12, %do.body6
  %19 = load ptr, ptr %elm, align 8
  %next16 = getelementptr inbounds %struct.TCGLabelUse, ptr %19, i32 0, i32 0
  %sqe_next17 = getelementptr inbounds %struct.anon.6, ptr %next16, i32 0, i32 0
  store ptr null, ptr %sqe_next17, align 8
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %if.end40

if.else:                                          ; preds = %do.body
  %20 = load ptr, ptr %label, align 8
  %branches18 = getelementptr inbounds %struct.TCGLabel, ptr %20, i32 0, i32 4
  %sqh_first19 = getelementptr inbounds %struct.anon, ptr %branches18, i32 0, i32 0
  %21 = load ptr, ptr %sqh_first19, align 8
  store ptr %21, ptr %curelm, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else
  %22 = load ptr, ptr %curelm, align 8
  %next20 = getelementptr inbounds %struct.TCGLabelUse, ptr %22, i32 0, i32 0
  %sqe_next21 = getelementptr inbounds %struct.anon.6, ptr %next20, i32 0, i32 0
  %23 = load ptr, ptr %sqe_next21, align 8
  %24 = load ptr, ptr %use, align 8
  %cmp22 = icmp ne ptr %23, %24
  br i1 %cmp22, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %25 = load ptr, ptr %curelm, align 8
  %next23 = getelementptr inbounds %struct.TCGLabelUse, ptr %25, i32 0, i32 0
  %sqe_next24 = getelementptr inbounds %struct.anon.6, ptr %next23, i32 0, i32 0
  %26 = load ptr, ptr %sqe_next24, align 8
  store ptr %26, ptr %curelm, align 8
  br label %while.cond, !llvm.loop !22

while.end:                                        ; preds = %while.cond
  %27 = load ptr, ptr %curelm, align 8
  %next25 = getelementptr inbounds %struct.TCGLabelUse, ptr %27, i32 0, i32 0
  %sqe_next26 = getelementptr inbounds %struct.anon.6, ptr %next25, i32 0, i32 0
  %28 = load ptr, ptr %sqe_next26, align 8
  %next27 = getelementptr inbounds %struct.TCGLabelUse, ptr %28, i32 0, i32 0
  %sqe_next28 = getelementptr inbounds %struct.anon.6, ptr %next27, i32 0, i32 0
  %29 = load ptr, ptr %sqe_next28, align 8
  %30 = load ptr, ptr %curelm, align 8
  %next29 = getelementptr inbounds %struct.TCGLabelUse, ptr %30, i32 0, i32 0
  %sqe_next30 = getelementptr inbounds %struct.anon.6, ptr %next29, i32 0, i32 0
  store ptr %29, ptr %sqe_next30, align 8
  %cmp31 = icmp eq ptr %29, null
  br i1 %cmp31, label %if.then32, label %if.end37

if.then32:                                        ; preds = %while.end
  %31 = load ptr, ptr %curelm, align 8
  %next33 = getelementptr inbounds %struct.TCGLabelUse, ptr %31, i32 0, i32 0
  %sqe_next34 = getelementptr inbounds %struct.anon.6, ptr %next33, i32 0, i32 0
  %32 = load ptr, ptr %label, align 8
  %branches35 = getelementptr inbounds %struct.TCGLabel, ptr %32, i32 0, i32 4
  %sqh_last36 = getelementptr inbounds %struct.anon, ptr %branches35, i32 0, i32 1
  store ptr %sqe_next34, ptr %sqh_last36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then32, %while.end
  %33 = load ptr, ptr %use, align 8
  %next38 = getelementptr inbounds %struct.TCGLabelUse, ptr %33, i32 0, i32 0
  %sqe_next39 = getelementptr inbounds %struct.anon.6, ptr %next38, i32 0, i32 0
  store ptr null, ptr %sqe_next39, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.end37, %do.end
  br label %do.end41

do.end41:                                         ; preds = %if.end40
  br label %do.end46

if.end42:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end42
  %34 = load ptr, ptr %use, align 8
  %next43 = getelementptr inbounds %struct.TCGLabelUse, ptr %34, i32 0, i32 0
  %sqe_next44 = getelementptr inbounds %struct.anon.6, ptr %next43, i32 0, i32 0
  %35 = load ptr, ptr %sqe_next44, align 8
  store ptr %35, ptr %use, align 8
  br label %for.cond, !llvm.loop !23

for.end:                                          ; preds = %for.cond
  br label %do.body45

do.body45:                                        ; preds = %for.end
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 3136, ptr noundef @__func__.remove_label_use, ptr noundef null) #15
  unreachable

do.end46:                                         ; preds = %do.end41
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @tcg_remove_ops_after(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %last = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %s, align 8
  br label %while.body

while.body:                                       ; preds = %if.end, %entry
  %call = call ptr @tcg_last_op()
  store ptr %call, ptr %last, align 8
  %2 = load ptr, ptr %last, align 8
  %3 = load ptr, ptr %op.addr, align 8
  %cmp = icmp eq ptr %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  ret void

if.end:                                           ; preds = %while.body
  %4 = load ptr, ptr %s, align 8
  %5 = load ptr, ptr %last, align 8
  call void @tcg_op_remove(ptr noundef %4, ptr noundef %5)
  br label %while.body
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_last_op() #0 {
entry:
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %1, i32 0, i32 38
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %ops, i32 0, i32 1
  %2 = load ptr, ptr %tql_prev, align 8
  %tql_prev1 = getelementptr inbounds %struct.QTailQLink, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %tql_prev1, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %tql_next, align 8
  ret ptr %4
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_emit_op(i32 noundef %opc, i32 noundef %nargs) #0 {
entry:
  %opc.addr = alloca i32, align 4
  %nargs.addr = alloca i32, align 4
  %op = alloca ptr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %nargs, ptr %nargs.addr, align 4
  %0 = load i32, ptr %opc.addr, align 4
  %1 = load i32, ptr %nargs.addr, align 4
  %call = call ptr @tcg_op_alloc(i32 noundef %0, i32 noundef %1)
  store ptr %call, ptr %op, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %2 = load ptr, ptr %op, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %2, i32 0, i32 2
  store ptr null, ptr %link, align 8
  %3 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %4 = load ptr, ptr %3, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 38
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %ops, i32 0, i32 1
  %5 = load ptr, ptr %tql_prev, align 8
  %6 = load ptr, ptr %op, align 8
  %link1 = getelementptr inbounds %struct.TCGOp, ptr %6, i32 0, i32 2
  %tql_prev2 = getelementptr inbounds %struct.QTailQLink, ptr %link1, i32 0, i32 1
  store ptr %5, ptr %tql_prev2, align 8
  %7 = load ptr, ptr %op, align 8
  %8 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %9 = load ptr, ptr %8, align 8
  %ops3 = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 38
  %tql_prev4 = getelementptr inbounds %struct.QTailQLink, ptr %ops3, i32 0, i32 1
  %10 = load ptr, ptr %tql_prev4, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %10, i32 0, i32 0
  store ptr %7, ptr %tql_next, align 8
  %11 = load ptr, ptr %op, align 8
  %link5 = getelementptr inbounds %struct.TCGOp, ptr %11, i32 0, i32 2
  %12 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %13 = load ptr, ptr %12, align 8
  %ops6 = getelementptr inbounds %struct.TCGContext, ptr %13, i32 0, i32 38
  %tql_prev7 = getelementptr inbounds %struct.QTailQLink, ptr %ops6, i32 0, i32 1
  store ptr %link5, ptr %tql_prev7, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %14 = load ptr, ptr %op, align 8
  ret ptr %14
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_op_alloc(i32 noundef %opc, i32 noundef %nargs) #0 {
entry:
  %opc.addr = alloca i32, align 4
  %nargs.addr = alloca i32, align 4
  %s = alloca ptr, align 8
  %op = alloca ptr, align 8
  %_a12 = alloca i32, align 4
  %_b13 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %nargs, ptr %nargs.addr, align 4
  %0 = call align 8 ptr @llvm.threadlocal.address.p0(ptr align 8 @tcg_ctx)
  %1 = load ptr, ptr %0, align 8
  store ptr %1, ptr %s, align 8
  store ptr null, ptr %op, align 8
  %2 = load ptr, ptr %s, align 8
  %free_ops = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 39
  %3 = load ptr, ptr %free_ops, align 8
  %cmp = icmp eq ptr %3, null
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end32

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %s, align 8
  %free_ops3 = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 39
  %5 = load ptr, ptr %free_ops3, align 8
  store ptr %5, ptr %op, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %6 = load ptr, ptr %op, align 8
  %tobool4 = icmp ne ptr %6, null
  br i1 %tobool4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, ptr %nargs.addr, align 4
  %8 = load ptr, ptr %op, align 8
  %bf.load = load i32, ptr %8, align 8
  %bf.lshr = lshr i32 %bf.load, 8
  %bf.clear = and i32 %bf.lshr, 255
  %cmp5 = icmp ule i32 %7, %bf.clear
  br i1 %cmp5, label %if.then7, label %if.end30

if.then7:                                         ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then7
  %9 = load ptr, ptr %op, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %link, align 8
  %cmp8 = icmp ne ptr %10, null
  br i1 %cmp8, label %if.then10, label %if.else

if.then10:                                        ; preds = %do.body
  %11 = load ptr, ptr %op, align 8
  %link11 = getelementptr inbounds %struct.TCGOp, ptr %11, i32 0, i32 2
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %link11, i32 0, i32 1
  %12 = load ptr, ptr %tql_prev, align 8
  %13 = load ptr, ptr %op, align 8
  %link12 = getelementptr inbounds %struct.TCGOp, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %link12, align 8
  %link13 = getelementptr inbounds %struct.TCGOp, ptr %14, i32 0, i32 2
  %tql_prev14 = getelementptr inbounds %struct.QTailQLink, ptr %link13, i32 0, i32 1
  store ptr %12, ptr %tql_prev14, align 8
  br label %if.end

if.else:                                          ; preds = %do.body
  %15 = load ptr, ptr %op, align 8
  %link15 = getelementptr inbounds %struct.TCGOp, ptr %15, i32 0, i32 2
  %tql_prev16 = getelementptr inbounds %struct.QTailQLink, ptr %link15, i32 0, i32 1
  %16 = load ptr, ptr %tql_prev16, align 8
  %17 = load ptr, ptr %s, align 8
  %free_ops17 = getelementptr inbounds %struct.TCGContext, ptr %17, i32 0, i32 39
  %tql_prev18 = getelementptr inbounds %struct.QTailQLink, ptr %free_ops17, i32 0, i32 1
  store ptr %16, ptr %tql_prev18, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then10
  %18 = load ptr, ptr %op, align 8
  %link19 = getelementptr inbounds %struct.TCGOp, ptr %18, i32 0, i32 2
  %19 = load ptr, ptr %link19, align 8
  %20 = load ptr, ptr %op, align 8
  %link20 = getelementptr inbounds %struct.TCGOp, ptr %20, i32 0, i32 2
  %tql_prev21 = getelementptr inbounds %struct.QTailQLink, ptr %link20, i32 0, i32 1
  %21 = load ptr, ptr %tql_prev21, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %21, i32 0, i32 0
  store ptr %19, ptr %tql_next, align 8
  %22 = load ptr, ptr %op, align 8
  %link22 = getelementptr inbounds %struct.TCGOp, ptr %22, i32 0, i32 2
  %tql_prev23 = getelementptr inbounds %struct.QTailQLink, ptr %link22, i32 0, i32 1
  store ptr null, ptr %tql_prev23, align 8
  %23 = load ptr, ptr %op, align 8
  %link24 = getelementptr inbounds %struct.TCGOp, ptr %23, i32 0, i32 2
  %tql_next25 = getelementptr inbounds %struct.QTailQLink, ptr %link24, i32 0, i32 0
  store ptr null, ptr %tql_next25, align 8
  %24 = load ptr, ptr %op, align 8
  %link26 = getelementptr inbounds %struct.TCGOp, ptr %24, i32 0, i32 2
  store ptr null, ptr %link26, align 8
  br label %do.end

do.end:                                           ; preds = %if.end
  %25 = load ptr, ptr %op, align 8
  %bf.load27 = load i32, ptr %25, align 8
  %bf.lshr28 = lshr i32 %bf.load27, 8
  %bf.clear29 = and i32 %bf.lshr28, 255
  store i32 %bf.clear29, ptr %nargs.addr, align 4
  br label %found

if.end30:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end30
  %26 = load ptr, ptr %op, align 8
  %link31 = getelementptr inbounds %struct.TCGOp, ptr %26, i32 0, i32 2
  %27 = load ptr, ptr %link31, align 8
  store ptr %27, ptr %op, align 8
  br label %for.cond, !llvm.loop !24

for.end:                                          ; preds = %for.cond
  br label %if.end32

if.end32:                                         ; preds = %for.end, %entry
  store i32 4, ptr %_a12, align 4
  %28 = load i32, ptr %nargs.addr, align 4
  store i32 %28, ptr %_b13, align 4
  %29 = load i32, ptr %_a12, align 4
  %30 = load i32, ptr %_b13, align 4
  %cmp33 = icmp ugt i32 %29, %30
  br i1 %cmp33, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end32
  %31 = load i32, ptr %_a12, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end32
  %32 = load i32, ptr %_b13, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %31, %cond.true ], [ %32, %cond.false ]
  store i32 %cond, ptr %tmp, align 4
  %33 = load i32, ptr %tmp, align 4
  store i32 %33, ptr %nargs.addr, align 4
  %34 = load i32, ptr %nargs.addr, align 4
  %conv35 = zext i32 %34 to i64
  %mul = mul i64 8, %conv35
  %add = add i64 32, %mul
  %conv36 = trunc i64 %add to i32
  %call = call ptr @tcg_malloc(i32 noundef %conv36)
  store ptr %call, ptr %op, align 8
  br label %found

found:                                            ; preds = %cond.end, %do.end
  %35 = load ptr, ptr %op, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %35, i8 0, i64 8, i1 false)
  %36 = load i32, ptr %opc.addr, align 4
  %37 = load ptr, ptr %op, align 8
  %bf.load37 = load i32, ptr %37, align 8
  %bf.value = and i32 %36, 255
  %bf.clear38 = and i32 %bf.load37, -256
  %bf.set = or i32 %bf.clear38, %bf.value
  store i32 %bf.set, ptr %37, align 8
  %38 = load i32, ptr %nargs.addr, align 4
  %39 = load ptr, ptr %op, align 8
  %bf.load39 = load i32, ptr %39, align 8
  %bf.value40 = and i32 %38, 255
  %bf.shl = shl i32 %bf.value40, 8
  %bf.clear41 = and i32 %bf.load39, -65281
  %bf.set42 = or i32 %bf.clear41, %bf.shl
  store i32 %bf.set42, ptr %39, align 8
  br label %do.body43

do.body43:                                        ; preds = %found
  %40 = load ptr, ptr %op, align 8
  %bf.load44 = load i32, ptr %40, align 8
  %bf.lshr45 = lshr i32 %bf.load44, 8
  %bf.clear46 = and i32 %bf.lshr45, 255
  %41 = load i32, ptr %nargs.addr, align 4
  %cmp47 = icmp eq i32 %bf.clear46, %41
  br i1 %cmp47, label %if.end50, label %if.then49

if.then49:                                        ; preds = %do.body43
  unreachable

if.end50:                                         ; preds = %do.body43
  br label %do.end51

do.end51:                                         ; preds = %if.end50
  %42 = load ptr, ptr %s, align 8
  %nb_ops = getelementptr inbounds %struct.TCGContext, ptr %42, i32 0, i32 9
  %43 = load i32, ptr %nb_ops, align 8
  %inc = add i32 %43, 1
  store i32 %inc, ptr %nb_ops, align 8
  %44 = load ptr, ptr %op, align 8
  ret ptr %44
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_op_insert_before(ptr noundef %s, ptr noundef %old_op, i32 noundef %opc, i32 noundef %nargs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %old_op.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %nargs.addr = alloca i32, align 4
  %new_op = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %old_op, ptr %old_op.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %nargs, ptr %nargs.addr, align 4
  %0 = load i32, ptr %opc.addr, align 4
  %1 = load i32, ptr %nargs.addr, align 4
  %call = call ptr @tcg_op_alloc(i32 noundef %0, i32 noundef %1)
  store ptr %call, ptr %new_op, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %2 = load ptr, ptr %old_op.addr, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %2, i32 0, i32 2
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %link, i32 0, i32 1
  %3 = load ptr, ptr %tql_prev, align 8
  %4 = load ptr, ptr %new_op, align 8
  %link1 = getelementptr inbounds %struct.TCGOp, ptr %4, i32 0, i32 2
  %tql_prev2 = getelementptr inbounds %struct.QTailQLink, ptr %link1, i32 0, i32 1
  store ptr %3, ptr %tql_prev2, align 8
  %5 = load ptr, ptr %old_op.addr, align 8
  %6 = load ptr, ptr %new_op, align 8
  %link3 = getelementptr inbounds %struct.TCGOp, ptr %6, i32 0, i32 2
  store ptr %5, ptr %link3, align 8
  %7 = load ptr, ptr %new_op, align 8
  %8 = load ptr, ptr %old_op.addr, align 8
  %link4 = getelementptr inbounds %struct.TCGOp, ptr %8, i32 0, i32 2
  %tql_prev5 = getelementptr inbounds %struct.QTailQLink, ptr %link4, i32 0, i32 1
  %9 = load ptr, ptr %tql_prev5, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %9, i32 0, i32 0
  store ptr %7, ptr %tql_next, align 8
  %10 = load ptr, ptr %new_op, align 8
  %link6 = getelementptr inbounds %struct.TCGOp, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %old_op.addr, align 8
  %link7 = getelementptr inbounds %struct.TCGOp, ptr %11, i32 0, i32 2
  %tql_prev8 = getelementptr inbounds %struct.QTailQLink, ptr %link7, i32 0, i32 1
  store ptr %link6, ptr %tql_prev8, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %12 = load ptr, ptr %new_op, align 8
  ret ptr %12
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @tcg_op_insert_after(ptr noundef %s, ptr noundef %old_op, i32 noundef %opc, i32 noundef %nargs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %old_op.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %nargs.addr = alloca i32, align 4
  %new_op = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %old_op, ptr %old_op.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %nargs, ptr %nargs.addr, align 4
  %0 = load i32, ptr %opc.addr, align 4
  %1 = load i32, ptr %nargs.addr, align 4
  %call = call ptr @tcg_op_alloc(i32 noundef %0, i32 noundef %1)
  store ptr %call, ptr %new_op, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %2 = load ptr, ptr %old_op.addr, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %2, i32 0, i32 2
  %3 = load ptr, ptr %link, align 8
  %4 = load ptr, ptr %new_op, align 8
  %link1 = getelementptr inbounds %struct.TCGOp, ptr %4, i32 0, i32 2
  store ptr %3, ptr %link1, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  %5 = load ptr, ptr %new_op, align 8
  %link2 = getelementptr inbounds %struct.TCGOp, ptr %5, i32 0, i32 2
  %6 = load ptr, ptr %new_op, align 8
  %link3 = getelementptr inbounds %struct.TCGOp, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %link3, align 8
  %link4 = getelementptr inbounds %struct.TCGOp, ptr %7, i32 0, i32 2
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %link4, i32 0, i32 1
  store ptr %link2, ptr %tql_prev, align 8
  br label %if.end

if.else:                                          ; preds = %do.body
  %8 = load ptr, ptr %new_op, align 8
  %link5 = getelementptr inbounds %struct.TCGOp, ptr %8, i32 0, i32 2
  %9 = load ptr, ptr %s.addr, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 38
  %tql_prev6 = getelementptr inbounds %struct.QTailQLink, ptr %ops, i32 0, i32 1
  store ptr %link5, ptr %tql_prev6, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load ptr, ptr %new_op, align 8
  %11 = load ptr, ptr %old_op.addr, align 8
  %link7 = getelementptr inbounds %struct.TCGOp, ptr %11, i32 0, i32 2
  store ptr %10, ptr %link7, align 8
  %12 = load ptr, ptr %old_op.addr, align 8
  %link8 = getelementptr inbounds %struct.TCGOp, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %new_op, align 8
  %link9 = getelementptr inbounds %struct.TCGOp, ptr %13, i32 0, i32 2
  %tql_prev10 = getelementptr inbounds %struct.QTailQLink, ptr %link9, i32 0, i32 1
  store ptr %link8, ptr %tql_prev10, align 8
  br label %do.end

do.end:                                           ; preds = %if.end
  %14 = load ptr, ptr %new_op, align 8
  ret ptr %14
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @tcg_gen_code(ptr noundef %s, ptr noundef %tb, i64 noundef %pc_start) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %tb.addr = alloca ptr, align 8
  %pc_start.addr = alloca i64, align 8
  %i = alloca i32, align 4
  %start_words = alloca i32, align 4
  %num_insns = alloca i32, align 4
  %op = alloca ptr, align 8
  %logfile = alloca ptr, align 8
  %logfile24 = alloca ptr, align 8
  %logfile49 = alloca ptr, align 8
  %opc = alloca i32, align 4
  %off = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %tb, ptr %tb.addr, align 8
  store i64 %pc_start, ptr %pc_start.addr, align 8
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 4)
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %0 = load i64, ptr %pc_start.addr, align 8
  %call1 = call zeroext i1 @qemu_log_in_addr_range(i64 noundef %0)
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %1 = phi i1 [ false, %entry ], [ %call1, %land.rhs ]
  %lnot = xor i1 %1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool = icmp ne i64 %conv, 0
  br i1 %tobool, label %if.then, label %if.end8

if.then:                                          ; preds = %land.end
  %call3 = call ptr @qemu_log_trylock()
  store ptr %call3, ptr %logfile, align 8
  %2 = load ptr, ptr %logfile, align 8
  %tobool4 = icmp ne ptr %2, null
  br i1 %tobool4, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %3 = load ptr, ptr %logfile, align 8
  %call6 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %3, ptr noundef @.str.6)
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load ptr, ptr %logfile, align 8
  call void @tcg_dump_ops(ptr noundef %4, ptr noundef %5, i1 noundef zeroext false)
  %6 = load ptr, ptr %logfile, align 8
  %call7 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef @.str.4)
  %7 = load ptr, ptr %logfile, align 8
  call void @qemu_log_unlock(ptr noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end, %land.end
  %8 = load ptr, ptr %s.addr, align 8
  call void @tcg_optimize(ptr noundef %8)
  %9 = load ptr, ptr %s.addr, align 8
  call void @reachable_code_pass(ptr noundef %9)
  %10 = load ptr, ptr %s.addr, align 8
  call void @liveness_pass_0(ptr noundef %10)
  %11 = load ptr, ptr %s.addr, align 8
  call void @liveness_pass_1(ptr noundef %11)
  %12 = load ptr, ptr %s.addr, align 8
  %nb_indirects = getelementptr inbounds %struct.TCGContext, ptr %12, i32 0, i32 8
  %13 = load i32, ptr %nb_indirects, align 4
  %cmp = icmp sgt i32 %13, 0
  br i1 %cmp, label %if.then10, label %if.end35

if.then10:                                        ; preds = %if.end8
  %call11 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 65536)
  br i1 %call11, label %land.rhs13, label %land.end16

land.rhs13:                                       ; preds = %if.then10
  %14 = load i64, ptr %pc_start.addr, align 8
  %call14 = call zeroext i1 @qemu_log_in_addr_range(i64 noundef %14)
  br label %land.end16

land.end16:                                       ; preds = %land.rhs13, %if.then10
  %15 = phi i1 [ false, %if.then10 ], [ %call14, %land.rhs13 ]
  %lnot17 = xor i1 %15, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %tobool22 = icmp ne i64 %conv21, 0
  br i1 %tobool22, label %if.then23, label %if.end31

if.then23:                                        ; preds = %land.end16
  %call25 = call ptr @qemu_log_trylock()
  store ptr %call25, ptr %logfile24, align 8
  %16 = load ptr, ptr %logfile24, align 8
  %tobool26 = icmp ne ptr %16, null
  br i1 %tobool26, label %if.then27, label %if.end30

if.then27:                                        ; preds = %if.then23
  %17 = load ptr, ptr %logfile24, align 8
  %call28 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %17, ptr noundef @.str.7)
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load ptr, ptr %logfile24, align 8
  call void @tcg_dump_ops(ptr noundef %18, ptr noundef %19, i1 noundef zeroext false)
  %20 = load ptr, ptr %logfile24, align 8
  %call29 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %20, ptr noundef @.str.4)
  %21 = load ptr, ptr %logfile24, align 8
  call void @qemu_log_unlock(ptr noundef %21)
  br label %if.end30

if.end30:                                         ; preds = %if.then27, %if.then23
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %land.end16
  %22 = load ptr, ptr %s.addr, align 8
  %call32 = call zeroext i1 @liveness_pass_2(ptr noundef %22)
  br i1 %call32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end31
  %23 = load ptr, ptr %s.addr, align 8
  call void @liveness_pass_1(ptr noundef %23)
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.end31
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.end8
  %call36 = call zeroext i1 @qemu_loglevel_mask(i32 noundef 8)
  br i1 %call36, label %land.rhs38, label %land.end41

land.rhs38:                                       ; preds = %if.end35
  %24 = load i64, ptr %pc_start.addr, align 8
  %call39 = call zeroext i1 @qemu_log_in_addr_range(i64 noundef %24)
  br label %land.end41

land.end41:                                       ; preds = %land.rhs38, %if.end35
  %25 = phi i1 [ false, %if.end35 ], [ %call39, %land.rhs38 ]
  %lnot42 = xor i1 %25, true
  %lnot44 = xor i1 %lnot42, true
  %lnot.ext45 = zext i1 %lnot44 to i32
  %conv46 = sext i32 %lnot.ext45 to i64
  %tobool47 = icmp ne i64 %conv46, 0
  br i1 %tobool47, label %if.then48, label %if.end56

if.then48:                                        ; preds = %land.end41
  %call50 = call ptr @qemu_log_trylock()
  store ptr %call50, ptr %logfile49, align 8
  %26 = load ptr, ptr %logfile49, align 8
  %tobool51 = icmp ne ptr %26, null
  br i1 %tobool51, label %if.then52, label %if.end55

if.then52:                                        ; preds = %if.then48
  %27 = load ptr, ptr %logfile49, align 8
  %call53 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %27, ptr noundef @.str.8)
  %28 = load ptr, ptr %s.addr, align 8
  %29 = load ptr, ptr %logfile49, align 8
  call void @tcg_dump_ops(ptr noundef %28, ptr noundef %29, i1 noundef zeroext true)
  %30 = load ptr, ptr %logfile49, align 8
  %call54 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %30, ptr noundef @.str.4)
  %31 = load ptr, ptr %logfile49, align 8
  call void @qemu_log_unlock(ptr noundef %31)
  br label %if.end55

if.end55:                                         ; preds = %if.then52, %if.then48
  br label %if.end56

if.end56:                                         ; preds = %if.end55, %land.end41
  %32 = load ptr, ptr %tb.addr, align 8
  %jmp_reset_offset = getelementptr inbounds %struct.TranslationBlock, ptr %32, i32 0, i32 9
  %arrayidx = getelementptr [2 x i16], ptr %jmp_reset_offset, i64 0, i64 0
  store i16 -1, ptr %arrayidx, align 4
  %33 = load ptr, ptr %tb.addr, align 8
  %jmp_reset_offset57 = getelementptr inbounds %struct.TranslationBlock, ptr %33, i32 0, i32 9
  %arrayidx58 = getelementptr [2 x i16], ptr %jmp_reset_offset57, i64 0, i64 1
  store i16 -1, ptr %arrayidx58, align 2
  %34 = load ptr, ptr %tb.addr, align 8
  %jmp_insn_offset = getelementptr inbounds %struct.TranslationBlock, ptr %34, i32 0, i32 10
  %arrayidx59 = getelementptr [2 x i16], ptr %jmp_insn_offset, i64 0, i64 0
  store i16 -1, ptr %arrayidx59, align 8
  %35 = load ptr, ptr %tb.addr, align 8
  %jmp_insn_offset60 = getelementptr inbounds %struct.TranslationBlock, ptr %35, i32 0, i32 10
  %arrayidx61 = getelementptr [2 x i16], ptr %jmp_insn_offset60, i64 0, i64 1
  store i16 -1, ptr %arrayidx61, align 2
  %36 = load ptr, ptr %s.addr, align 8
  call void @tcg_reg_alloc_start(ptr noundef %36)
  %37 = load ptr, ptr %tb.addr, align 8
  %tc = getelementptr inbounds %struct.TranslationBlock, ptr %37, i32 0, i32 6
  %ptr = getelementptr inbounds %struct.tb_tc, ptr %tc, i32 0, i32 0
  %38 = load ptr, ptr %ptr, align 8
  %call62 = call ptr @tcg_splitwx_to_rw(ptr noundef %38)
  %39 = load ptr, ptr %s.addr, align 8
  %code_buf = getelementptr inbounds %struct.TCGContext, ptr %39, i32 0, i32 22
  store ptr %call62, ptr %code_buf, align 8
  %40 = load ptr, ptr %s.addr, align 8
  %code_buf63 = getelementptr inbounds %struct.TCGContext, ptr %40, i32 0, i32 22
  %41 = load ptr, ptr %code_buf63, align 8
  %42 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %42, i32 0, i32 23
  store ptr %41, ptr %code_ptr, align 8
  br label %do.body

do.body:                                          ; preds = %if.end56
  %43 = load ptr, ptr %s.addr, align 8
  %ldst_labels = getelementptr inbounds %struct.TCGContext, ptr %43, i32 0, i32 30
  %sqh_first = getelementptr inbounds %struct.anon.2, ptr %ldst_labels, i32 0, i32 0
  store ptr null, ptr %sqh_first, align 8
  %44 = load ptr, ptr %s.addr, align 8
  %ldst_labels64 = getelementptr inbounds %struct.TCGContext, ptr %44, i32 0, i32 30
  %sqh_first65 = getelementptr inbounds %struct.anon.2, ptr %ldst_labels64, i32 0, i32 0
  %45 = load ptr, ptr %s.addr, align 8
  %ldst_labels66 = getelementptr inbounds %struct.TCGContext, ptr %45, i32 0, i32 30
  %sqh_last = getelementptr inbounds %struct.anon.2, ptr %ldst_labels66, i32 0, i32 1
  store ptr %sqh_first65, ptr %sqh_last, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %46 = load ptr, ptr %s.addr, align 8
  %pool_labels = getelementptr inbounds %struct.TCGContext, ptr %46, i32 0, i32 31
  store ptr null, ptr %pool_labels, align 8
  %47 = load ptr, ptr %s.addr, align 8
  %insn_start_words = getelementptr inbounds %struct.TCGContext, ptr %47, i32 0, i32 14
  %48 = load i8, ptr %insn_start_words, align 2
  %conv67 = zext i8 %48 to i32
  store i32 %conv67, ptr %start_words, align 4
  %49 = load ptr, ptr %s.addr, align 8
  %gen_tb = getelementptr inbounds %struct.TCGContext, ptr %49, i32 0, i32 21
  %50 = load ptr, ptr %gen_tb, align 8
  %icount = getelementptr inbounds %struct.TranslationBlock, ptr %50, i32 0, i32 5
  %51 = load i16, ptr %icount, align 2
  %conv68 = zext i16 %51 to i64
  %mul = mul i64 8, %conv68
  %52 = load i32, ptr %start_words, align 4
  %conv69 = sext i32 %52 to i64
  %mul70 = mul i64 %mul, %conv69
  %conv71 = trunc i64 %mul70 to i32
  %call72 = call ptr @tcg_malloc(i32 noundef %conv71)
  %53 = load ptr, ptr %s.addr, align 8
  %gen_insn_data = getelementptr inbounds %struct.TCGContext, ptr %53, i32 0, i32 43
  store ptr %call72, ptr %gen_insn_data, align 8
  %54 = load ptr, ptr %s.addr, align 8
  call void @tcg_out_tb_start(ptr noundef %54)
  store i32 -1, ptr %num_insns, align 4
  %55 = load ptr, ptr %s.addr, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %55, i32 0, i32 38
  %56 = load ptr, ptr %ops, align 8
  store ptr %56, ptr %op, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc147, %do.end
  %57 = load ptr, ptr %op, align 8
  %tobool73 = icmp ne ptr %57, null
  br i1 %tobool73, label %for.body, label %for.end148

for.body:                                         ; preds = %for.cond
  %58 = load ptr, ptr %op, align 8
  %bf.load = load i32, ptr %58, align 8
  %bf.clear = and i32 %bf.load, 255
  store i32 %bf.clear, ptr %opc, align 4
  %59 = load i32, ptr %opc, align 4
  switch i32 %59, label %sw.default [
    i32 5, label %sw.bb
    i32 63, label %sw.bb
    i32 149, label %sw.bb
    i32 150, label %sw.bb74
    i32 129, label %sw.bb75
    i32 0, label %sw.bb101
    i32 1, label %sw.bb104
    i32 2, label %sw.bb108
    i32 130, label %sw.bb109
    i32 131, label %sw.bb112
    i32 151, label %sw.bb116
  ]

sw.bb:                                            ; preds = %for.body, %for.body, %for.body
  %60 = load ptr, ptr %s.addr, align 8
  %61 = load ptr, ptr %op, align 8
  call void @tcg_reg_alloc_mov(ptr noundef %60, ptr noundef %61)
  br label %sw.epilog

sw.bb74:                                          ; preds = %for.body
  %62 = load ptr, ptr %s.addr, align 8
  %63 = load ptr, ptr %op, align 8
  call void @tcg_reg_alloc_dup(ptr noundef %62, ptr noundef %63)
  br label %sw.epilog

sw.bb75:                                          ; preds = %for.body
  %64 = load i32, ptr %num_insns, align 4
  %cmp76 = icmp sge i32 %64, 0
  br i1 %cmp76, label %if.then78, label %if.end90

if.then78:                                        ; preds = %sw.bb75
  %65 = load ptr, ptr %s.addr, align 8
  %call79 = call i64 @tcg_current_code_size(ptr noundef %65)
  store i64 %call79, ptr %off, align 8
  %66 = load i64, ptr %off, align 8
  %conv80 = trunc i64 %66 to i16
  %67 = load ptr, ptr %s.addr, align 8
  %gen_insn_end_off = getelementptr inbounds %struct.TCGContext, ptr %67, i32 0, i32 42
  %68 = load i32, ptr %num_insns, align 4
  %idxprom = sext i32 %68 to i64
  %arrayidx81 = getelementptr [512 x i16], ptr %gen_insn_end_off, i64 0, i64 %idxprom
  store i16 %conv80, ptr %arrayidx81, align 2
  %69 = load ptr, ptr %s.addr, align 8
  %gen_insn_end_off82 = getelementptr inbounds %struct.TCGContext, ptr %69, i32 0, i32 42
  %70 = load i32, ptr %num_insns, align 4
  %idxprom83 = sext i32 %70 to i64
  %arrayidx84 = getelementptr [512 x i16], ptr %gen_insn_end_off82, i64 0, i64 %idxprom83
  %71 = load i16, ptr %arrayidx84, align 2
  %conv85 = zext i16 %71 to i64
  %72 = load i64, ptr %off, align 8
  %cmp86 = icmp eq i64 %conv85, %72
  br i1 %cmp86, label %if.then88, label %if.else

if.then88:                                        ; preds = %if.then78
  br label %if.end89

if.else:                                          ; preds = %if.then78
  call void @__assert_fail(ptr noundef @.str.9, ptr noundef @.str.1, i32 noundef 6138, ptr noundef @__PRETTY_FUNCTION__.tcg_gen_code) #19
  unreachable

if.end89:                                         ; preds = %if.then88
  br label %if.end90

if.end90:                                         ; preds = %if.end89, %sw.bb75
  %73 = load i32, ptr %num_insns, align 4
  %inc = add i32 %73, 1
  store i32 %inc, ptr %num_insns, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond91

for.cond91:                                       ; preds = %for.inc, %if.end90
  %74 = load i32, ptr %i, align 4
  %75 = load i32, ptr %start_words, align 4
  %cmp92 = icmp slt i32 %74, %75
  br i1 %cmp92, label %for.body94, label %for.end

for.body94:                                       ; preds = %for.cond91
  %76 = load ptr, ptr %op, align 8
  %77 = load i32, ptr %i, align 4
  %call95 = call i64 @tcg_get_insn_start_param(ptr noundef %76, i32 noundef %77)
  %78 = load ptr, ptr %s.addr, align 8
  %gen_insn_data96 = getelementptr inbounds %struct.TCGContext, ptr %78, i32 0, i32 43
  %79 = load ptr, ptr %gen_insn_data96, align 8
  %80 = load i32, ptr %num_insns, align 4
  %81 = load i32, ptr %start_words, align 4
  %mul97 = mul i32 %80, %81
  %82 = load i32, ptr %i, align 4
  %add = add i32 %mul97, %82
  %idxprom98 = sext i32 %add to i64
  %arrayidx99 = getelementptr i64, ptr %79, i64 %idxprom98
  store i64 %call95, ptr %arrayidx99, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body94
  %83 = load i32, ptr %i, align 4
  %inc100 = add i32 %83, 1
  store i32 %inc100, ptr %i, align 4
  br label %for.cond91, !llvm.loop !25

for.end:                                          ; preds = %for.cond91
  br label %sw.epilog

sw.bb101:                                         ; preds = %for.body
  %84 = load ptr, ptr %s.addr, align 8
  %85 = load ptr, ptr %op, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %85, i32 0, i32 4
  %arrayidx102 = getelementptr [0 x i64], ptr %args, i64 0, i64 0
  %86 = load i64, ptr %arrayidx102, align 8
  %call103 = call ptr @arg_temp(i64 noundef %86)
  call void @temp_dead(ptr noundef %84, ptr noundef %call103)
  br label %sw.epilog

sw.bb104:                                         ; preds = %for.body
  %87 = load ptr, ptr %s.addr, align 8
  %88 = load ptr, ptr %s.addr, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %88, i32 0, i32 16
  %89 = load i32, ptr %reserved_regs, align 4
  call void @tcg_reg_alloc_bb_end(ptr noundef %87, i32 noundef %89)
  %90 = load ptr, ptr %s.addr, align 8
  %91 = load ptr, ptr %op, align 8
  %args105 = getelementptr inbounds %struct.TCGOp, ptr %91, i32 0, i32 4
  %arrayidx106 = getelementptr [0 x i64], ptr %args105, i64 0, i64 0
  %92 = load i64, ptr %arrayidx106, align 8
  %call107 = call ptr @arg_label(i64 noundef %92)
  call void @tcg_out_label(ptr noundef %90, ptr noundef %call107)
  br label %sw.epilog

sw.bb108:                                         ; preds = %for.body
  %93 = load ptr, ptr %s.addr, align 8
  %94 = load ptr, ptr %op, align 8
  call void @tcg_reg_alloc_call(ptr noundef %93, ptr noundef %94)
  br label %sw.epilog

sw.bb109:                                         ; preds = %for.body
  %95 = load ptr, ptr %s.addr, align 8
  %96 = load ptr, ptr %op, align 8
  %args110 = getelementptr inbounds %struct.TCGOp, ptr %96, i32 0, i32 4
  %arrayidx111 = getelementptr [0 x i64], ptr %args110, i64 0, i64 0
  %97 = load i64, ptr %arrayidx111, align 8
  call void @tcg_out_exit_tb(ptr noundef %95, i64 noundef %97)
  br label %sw.epilog

sw.bb112:                                         ; preds = %for.body
  %98 = load ptr, ptr %s.addr, align 8
  %99 = load ptr, ptr %op, align 8
  %args113 = getelementptr inbounds %struct.TCGOp, ptr %99, i32 0, i32 4
  %arrayidx114 = getelementptr [0 x i64], ptr %args113, i64 0, i64 0
  %100 = load i64, ptr %arrayidx114, align 8
  %conv115 = trunc i64 %100 to i32
  call void @tcg_out_goto_tb(ptr noundef %98, i32 noundef %conv115)
  br label %sw.epilog

sw.bb116:                                         ; preds = %for.body
  %101 = load ptr, ptr %s.addr, align 8
  %102 = load ptr, ptr %op, align 8
  %call117 = call zeroext i1 @tcg_reg_alloc_dup2(ptr noundef %101, ptr noundef %102)
  br i1 %call117, label %if.then118, label %if.end119

if.then118:                                       ; preds = %sw.bb116
  br label %sw.epilog

if.end119:                                        ; preds = %sw.bb116
  br label %sw.default

sw.default:                                       ; preds = %if.end119, %for.body
  br label %do.body120

do.body120:                                       ; preds = %sw.default
  %103 = load i32, ptr %opc, align 4
  %call121 = call zeroext i1 @tcg_op_supported(i32 noundef %103)
  br i1 %call121, label %if.end123, label %if.then122

if.then122:                                       ; preds = %do.body120
  unreachable

if.end123:                                        ; preds = %do.body120
  br label %do.end124

do.end124:                                        ; preds = %if.end123
  %104 = load ptr, ptr %s.addr, align 8
  %105 = load ptr, ptr %op, align 8
  call void @tcg_reg_alloc_op(ptr noundef %104, ptr noundef %105)
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end124, %if.then118, %sw.bb112, %sw.bb109, %sw.bb108, %sw.bb104, %sw.bb101, %for.end, %sw.bb74, %sw.bb
  %106 = load ptr, ptr %s.addr, align 8
  %code_ptr125 = getelementptr inbounds %struct.TCGContext, ptr %106, i32 0, i32 23
  %107 = load ptr, ptr %code_ptr125, align 8
  %108 = load ptr, ptr %s.addr, align 8
  %code_gen_highwater = getelementptr inbounds %struct.TCGContext, ptr %108, i32 0, i32 28
  %109 = load ptr, ptr %code_gen_highwater, align 8
  %cmp126 = icmp ugt ptr %107, %109
  %lnot128 = xor i1 %cmp126, true
  %lnot130 = xor i1 %lnot128, true
  %lnot.ext131 = zext i1 %lnot130 to i32
  %conv132 = sext i32 %lnot.ext131 to i64
  %tobool133 = icmp ne i64 %conv132, 0
  br i1 %tobool133, label %if.then134, label %if.end135

if.then134:                                       ; preds = %sw.epilog
  store i32 -1, ptr %retval, align 4
  br label %return

if.end135:                                        ; preds = %sw.epilog
  %110 = load ptr, ptr %s.addr, align 8
  %call136 = call i64 @tcg_current_code_size(ptr noundef %110)
  %cmp137 = icmp ugt i64 %call136, 65535
  %lnot139 = xor i1 %cmp137, true
  %lnot141 = xor i1 %lnot139, true
  %lnot.ext142 = zext i1 %lnot141 to i32
  %conv143 = sext i32 %lnot.ext142 to i64
  %tobool144 = icmp ne i64 %conv143, 0
  br i1 %tobool144, label %if.then145, label %if.end146

if.then145:                                       ; preds = %if.end135
  store i32 -2, ptr %retval, align 4
  br label %return

if.end146:                                        ; preds = %if.end135
  br label %for.inc147

for.inc147:                                       ; preds = %if.end146
  %111 = load ptr, ptr %op, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %111, i32 0, i32 2
  %112 = load ptr, ptr %link, align 8
  store ptr %112, ptr %op, align 8
  br label %for.cond, !llvm.loop !26

for.end148:                                       ; preds = %for.cond
  br label %do.body149

do.body149:                                       ; preds = %for.end148
  %113 = load i32, ptr %num_insns, align 4
  %add150 = add i32 %113, 1
  %114 = load ptr, ptr %s.addr, align 8
  %gen_tb151 = getelementptr inbounds %struct.TCGContext, ptr %114, i32 0, i32 21
  %115 = load ptr, ptr %gen_tb151, align 8
  %icount152 = getelementptr inbounds %struct.TranslationBlock, ptr %115, i32 0, i32 5
  %116 = load i16, ptr %icount152, align 2
  %conv153 = zext i16 %116 to i32
  %cmp154 = icmp eq i32 %add150, %conv153
  br i1 %cmp154, label %if.end157, label %if.then156

if.then156:                                       ; preds = %do.body149
  unreachable

if.end157:                                        ; preds = %do.body149
  br label %do.end158

do.end158:                                        ; preds = %if.end157
  %117 = load ptr, ptr %s.addr, align 8
  %call159 = call i64 @tcg_current_code_size(ptr noundef %117)
  %conv160 = trunc i64 %call159 to i16
  %118 = load ptr, ptr %s.addr, align 8
  %gen_insn_end_off161 = getelementptr inbounds %struct.TCGContext, ptr %118, i32 0, i32 42
  %119 = load i32, ptr %num_insns, align 4
  %idxprom162 = sext i32 %119 to i64
  %arrayidx163 = getelementptr [512 x i16], ptr %gen_insn_end_off161, i64 0, i64 %idxprom162
  store i16 %conv160, ptr %arrayidx163, align 2
  %120 = load ptr, ptr %s.addr, align 8
  %call164 = call i32 @tcg_out_ldst_finalize(ptr noundef %120)
  store i32 %call164, ptr %i, align 4
  %121 = load i32, ptr %i, align 4
  %cmp165 = icmp slt i32 %121, 0
  br i1 %cmp165, label %if.then167, label %if.end168

if.then167:                                       ; preds = %do.end158
  %122 = load i32, ptr %i, align 4
  store i32 %122, ptr %retval, align 4
  br label %return

if.end168:                                        ; preds = %do.end158
  %123 = load ptr, ptr %s.addr, align 8
  %call169 = call i32 @tcg_out_pool_finalize(ptr noundef %123)
  store i32 %call169, ptr %i, align 4
  %124 = load i32, ptr %i, align 4
  %cmp170 = icmp slt i32 %124, 0
  br i1 %cmp170, label %if.then172, label %if.end173

if.then172:                                       ; preds = %if.end168
  %125 = load i32, ptr %i, align 4
  store i32 %125, ptr %retval, align 4
  br label %return

if.end173:                                        ; preds = %if.end168
  %126 = load ptr, ptr %s.addr, align 8
  %call174 = call zeroext i1 @tcg_resolve_relocs(ptr noundef %126)
  br i1 %call174, label %if.end176, label %if.then175

if.then175:                                       ; preds = %if.end173
  store i32 -2, ptr %retval, align 4
  br label %return

if.end176:                                        ; preds = %if.end173
  %127 = load ptr, ptr %s.addr, align 8
  %code_buf177 = getelementptr inbounds %struct.TCGContext, ptr %127, i32 0, i32 22
  %128 = load ptr, ptr %code_buf177, align 8
  %call178 = call ptr @tcg_splitwx_to_rx(ptr noundef %128)
  %129 = ptrtoint ptr %call178 to i64
  %130 = load ptr, ptr %s.addr, align 8
  %code_buf179 = getelementptr inbounds %struct.TCGContext, ptr %130, i32 0, i32 22
  %131 = load ptr, ptr %code_buf179, align 8
  %132 = ptrtoint ptr %131 to i64
  %133 = load ptr, ptr %s.addr, align 8
  %code_ptr180 = getelementptr inbounds %struct.TCGContext, ptr %133, i32 0, i32 23
  %134 = load ptr, ptr %code_ptr180, align 8
  %135 = load ptr, ptr %s.addr, align 8
  %code_buf181 = getelementptr inbounds %struct.TCGContext, ptr %135, i32 0, i32 22
  %136 = load ptr, ptr %code_buf181, align 8
  %call182 = call i64 @tcg_ptr_byte_diff(ptr noundef %134, ptr noundef %136)
  call void @flush_idcache_range(i64 noundef %129, i64 noundef %132, i64 noundef %call182)
  %137 = load ptr, ptr %s.addr, align 8
  %call183 = call i64 @tcg_current_code_size(ptr noundef %137)
  %conv184 = trunc i64 %call183 to i32
  store i32 %conv184, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end176, %if.then175, %if.then172, %if.then167, %if.then145, %if.then134
  %138 = load i32, ptr %retval, align 4
  ret i32 %138
}

declare zeroext i1 @qemu_log_in_addr_range(i64 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_dump_ops(ptr noundef %s, ptr noundef %f, i1 noundef zeroext %have_prefs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %f.addr = alloca ptr, align 8
  %have_prefs.addr = alloca i8, align 1
  %buf = alloca [128 x i8], align 16
  %op = alloca ptr, align 8
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %nb_oargs = alloca i32, align 4
  %nb_iargs = alloca i32, align 4
  %nb_cargs = alloca i32, align 4
  %def = alloca ptr, align 8
  %c = alloca i32, align 4
  %col = alloca i32, align 4
  %ret_ = alloca i32, align 4
  %tmp = alloca i32, align 4
  %ret_6 = alloca i32, align 4
  %tmp9 = alloca i32, align 4
  %info = alloca ptr, align 8
  %func = alloca ptr, align 8
  %ret_28 = alloca i32, align 4
  %tmp30 = alloca i32, align 4
  %ret_42 = alloca i32, align 4
  %tmp45 = alloca i32, align 4
  %ret_54 = alloca i32, align 4
  %tmp56 = alloca i32, align 4
  %ret_64 = alloca i32, align 4
  %tmp69 = alloca i32, align 4
  %ret_81 = alloca i32, align 4
  %tmp86 = alloca i32, align 4
  %arg = alloca i64, align 8
  %t = alloca ptr, align 8
  %ret_107 = alloca i32, align 4
  %tmp109 = alloca i32, align 4
  %ret_121 = alloca i32, align 4
  %tmp124 = alloca i32, align 4
  %ret_142 = alloca i32, align 4
  %tmp150 = alloca i32, align 4
  %sep = alloca ptr, align 8
  %ret_165 = alloca i32, align 4
  %tmp173 = alloca i32, align 4
  %sep188 = alloca ptr, align 8
  %ret_191 = alloca i32, align 4
  %tmp199 = alloca i32, align 4
  %ret_221 = alloca i32, align 4
  %tmp228 = alloca i32, align 4
  %ret_237 = alloca i32, align 4
  %tmp243 = alloca i32, align 4
  %s_al = alloca ptr, align 8
  %s_op = alloca ptr, align 8
  %s_at = alloca ptr, align 8
  %oi = alloca i32, align 4
  %mop = alloca i32, align 4
  %ix = alloca i32, align 4
  %ret_279 = alloca i32, align 4
  %tmp281 = alloca i32, align 4
  %ret_291 = alloca i32, align 4
  %tmp293 = alloca i32, align 4
  %flags303 = alloca i64, align 8
  %name307 = alloca ptr, align 8
  %ret_316 = alloca i32, align 4
  %tmp318 = alloca i32, align 4
  %ret_327 = alloca i32, align 4
  %tmp329 = alloca i32, align 4
  %ret_339 = alloca i32, align 4
  %tmp348 = alloca i32, align 4
  %membar = alloca i32, align 4
  %b_op = alloca ptr, align 8
  %m_op = alloca ptr, align 8
  %ret_391 = alloca i32, align 4
  %tmp395 = alloca i32, align 4
  %ret_411 = alloca i32, align 4
  %tmp418 = alloca i32, align 4
  %life448 = alloca i32, align 4
  %ret_453 = alloca i32, align 4
  %tmp455 = alloca i32, align 4
  %ret_470 = alloca i32, align 4
  %tmp472 = alloca i32, align 4
  %ret_486 = alloca i32, align 4
  %tmp488 = alloca i32, align 4
  %ret_501 = alloca i32, align 4
  %tmp503 = alloca i32, align 4
  %set = alloca i32, align 4
  %ret_527 = alloca i32, align 4
  %tmp529 = alloca i32, align 4
  %ret_537 = alloca i32, align 4
  %tmp539 = alloca i32, align 4
  %ret_550 = alloca i32, align 4
  %tmp552 = alloca i32, align 4
  %ret_564 = alloca i32, align 4
  %tmp566 = alloca i32, align 4
  %ret_574 = alloca i32, align 4
  %tmp576 = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %f, ptr %f.addr, align 8
  %frombool = zext i1 %have_prefs to i8
  store i8 %frombool, ptr %have_prefs.addr, align 1
  %0 = load ptr, ptr %s.addr, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 38
  %1 = load ptr, ptr %ops, align 8
  store ptr %1, ptr %op, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc590, %entry
  %2 = load ptr, ptr %op, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end591

for.body:                                         ; preds = %for.cond
  store i32 0, ptr %col, align 4
  %3 = load ptr, ptr %op, align 8
  %bf.load = load i32, ptr %3, align 8
  %bf.clear = and i32 %bf.load, 255
  store i32 %bf.clear, ptr %c, align 4
  %4 = load i32, ptr %c, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %def, align 8
  %5 = load i32, ptr %c, align 4
  %cmp = icmp eq i32 %5, 129
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  store i32 0, ptr %nb_oargs, align 4
  %6 = load ptr, ptr %f.addr, align 8
  %call = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %6, ptr noundef @.str.41)
  store i32 %call, ptr %ret_, align 4
  %7 = load i32, ptr %ret_, align 4
  %cmp1 = icmp sge i32 %7, 0
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %8 = load i32, ptr %ret_, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %8, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, ptr %tmp, align 4
  %9 = load i32, ptr %tmp, align 4
  %10 = load i32, ptr %col, align 4
  %add = add i32 %10, %9
  store i32 %add, ptr %col, align 4
  store i32 0, ptr %i, align 4
  %11 = load ptr, ptr %s.addr, align 8
  %insn_start_words = getelementptr inbounds %struct.TCGContext, ptr %11, i32 0, i32 14
  %12 = load i8, ptr %insn_start_words, align 2
  %conv = zext i8 %12 to i32
  store i32 %conv, ptr %k, align 4
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %cond.end
  %13 = load i32, ptr %i, align 4
  %14 = load i32, ptr %k, align 4
  %cmp3 = icmp slt i32 %13, %14
  br i1 %cmp3, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond2
  %15 = load ptr, ptr %f.addr, align 8
  %16 = load ptr, ptr %op, align 8
  %17 = load i32, ptr %i, align 4
  %call7 = call i64 @tcg_get_insn_start_param(ptr noundef %16, i32 noundef %17)
  %call8 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %15, ptr noundef @.str.42, i64 noundef %call7)
  store i32 %call8, ptr %ret_6, align 4
  %18 = load i32, ptr %ret_6, align 4
  %cmp10 = icmp sge i32 %18, 0
  br i1 %cmp10, label %cond.true12, label %cond.false13

cond.true12:                                      ; preds = %for.body5
  %19 = load i32, ptr %ret_6, align 4
  br label %cond.end14

cond.false13:                                     ; preds = %for.body5
  br label %cond.end14

cond.end14:                                       ; preds = %cond.false13, %cond.true12
  %cond15 = phi i32 [ %19, %cond.true12 ], [ 0, %cond.false13 ]
  store i32 %cond15, ptr %tmp9, align 4
  %20 = load i32, ptr %tmp9, align 4
  %21 = load i32, ptr %col, align 4
  %add16 = add i32 %21, %20
  store i32 %add16, ptr %col, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end14
  %22 = load i32, ptr %i, align 4
  %inc = add i32 %22, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond2, !llvm.loop !27

for.end:                                          ; preds = %for.cond2
  br label %if.end431

if.else:                                          ; preds = %for.body
  %23 = load i32, ptr %c, align 4
  %cmp17 = icmp eq i32 %23, 2
  br i1 %cmp17, label %if.then19, label %if.else120

if.then19:                                        ; preds = %if.else
  %24 = load ptr, ptr %op, align 8
  %call20 = call ptr @tcg_call_info(ptr noundef %24)
  store ptr %call20, ptr %info, align 8
  %25 = load ptr, ptr %op, align 8
  %call21 = call ptr @tcg_call_func(ptr noundef %25)
  store ptr %call21, ptr %func, align 8
  %26 = load ptr, ptr %op, align 8
  %bf.load22 = load i32, ptr %26, align 8
  %bf.lshr = lshr i32 %bf.load22, 24
  store i32 %bf.lshr, ptr %nb_oargs, align 4
  %27 = load ptr, ptr %op, align 8
  %bf.load23 = load i32, ptr %27, align 8
  %bf.lshr24 = lshr i32 %bf.load23, 16
  %bf.clear25 = and i32 %bf.lshr24, 255
  store i32 %bf.clear25, ptr %nb_iargs, align 4
  %28 = load ptr, ptr %def, align 8
  %nb_cargs26 = getelementptr inbounds %struct.TCGOpDef, ptr %28, i32 0, i32 3
  %29 = load i8, ptr %nb_cargs26, align 2
  %conv27 = zext i8 %29 to i32
  store i32 %conv27, ptr %nb_cargs, align 4
  %30 = load ptr, ptr %f.addr, align 8
  %31 = load ptr, ptr %def, align 8
  %name = getelementptr inbounds %struct.TCGOpDef, ptr %31, i32 0, i32 0
  %32 = load ptr, ptr %name, align 8
  %call29 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %30, ptr noundef @.str.43, ptr noundef %32)
  store i32 %call29, ptr %ret_28, align 4
  %33 = load i32, ptr %ret_28, align 4
  %cmp31 = icmp sge i32 %33, 0
  br i1 %cmp31, label %cond.true33, label %cond.false34

cond.true33:                                      ; preds = %if.then19
  %34 = load i32, ptr %ret_28, align 4
  br label %cond.end35

cond.false34:                                     ; preds = %if.then19
  br label %cond.end35

cond.end35:                                       ; preds = %cond.false34, %cond.true33
  %cond36 = phi i32 [ %34, %cond.true33 ], [ 0, %cond.false34 ]
  store i32 %cond36, ptr %tmp30, align 4
  %35 = load i32, ptr %tmp30, align 4
  %36 = load i32, ptr %col, align 4
  %add37 = add i32 %36, %35
  store i32 %add37, ptr %col, align 4
  %37 = load ptr, ptr %func, align 8
  %38 = load ptr, ptr %info, align 8
  %func38 = getelementptr inbounds %struct.TCGHelperInfo, ptr %38, i32 0, i32 0
  %39 = load ptr, ptr %func38, align 8
  %cmp39 = icmp eq ptr %37, %39
  br i1 %cmp39, label %if.then41, label %if.else53

if.then41:                                        ; preds = %cond.end35
  %40 = load ptr, ptr %f.addr, align 8
  %41 = load ptr, ptr %info, align 8
  %name43 = getelementptr inbounds %struct.TCGHelperInfo, ptr %41, i32 0, i32 1
  %42 = load ptr, ptr %name43, align 8
  %call44 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %40, ptr noundef @.str.44, ptr noundef %42)
  store i32 %call44, ptr %ret_42, align 4
  %43 = load i32, ptr %ret_42, align 4
  %cmp46 = icmp sge i32 %43, 0
  br i1 %cmp46, label %cond.true48, label %cond.false49

cond.true48:                                      ; preds = %if.then41
  %44 = load i32, ptr %ret_42, align 4
  br label %cond.end50

cond.false49:                                     ; preds = %if.then41
  br label %cond.end50

cond.end50:                                       ; preds = %cond.false49, %cond.true48
  %cond51 = phi i32 [ %44, %cond.true48 ], [ 0, %cond.false49 ]
  store i32 %cond51, ptr %tmp45, align 4
  %45 = load i32, ptr %tmp45, align 4
  %46 = load i32, ptr %col, align 4
  %add52 = add i32 %46, %45
  store i32 %add52, ptr %col, align 4
  br label %if.end

if.else53:                                        ; preds = %cond.end35
  %47 = load ptr, ptr %f.addr, align 8
  %48 = load ptr, ptr %func, align 8
  %call55 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %47, ptr noundef @.str.45, ptr noundef %48)
  store i32 %call55, ptr %ret_54, align 4
  %49 = load i32, ptr %ret_54, align 4
  %cmp57 = icmp sge i32 %49, 0
  br i1 %cmp57, label %cond.true59, label %cond.false60

cond.true59:                                      ; preds = %if.else53
  %50 = load i32, ptr %ret_54, align 4
  br label %cond.end61

cond.false60:                                     ; preds = %if.else53
  br label %cond.end61

cond.end61:                                       ; preds = %cond.false60, %cond.true59
  %cond62 = phi i32 [ %50, %cond.true59 ], [ 0, %cond.false60 ]
  store i32 %cond62, ptr %tmp56, align 4
  %51 = load i32, ptr %tmp56, align 4
  %52 = load i32, ptr %col, align 4
  %add63 = add i32 %52, %51
  store i32 %add63, ptr %col, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end61, %cond.end50
  %53 = load ptr, ptr %f.addr, align 8
  %54 = load ptr, ptr %info, align 8
  %flags = getelementptr inbounds %struct.TCGHelperInfo, ptr %54, i32 0, i32 3
  %bf.load65 = load i64, ptr %flags, align 8
  %bf.lshr66 = lshr i64 %bf.load65, 32
  %bf.clear67 = and i64 %bf.lshr66, 255
  %bf.cast = trunc i64 %bf.clear67 to i32
  %55 = load i32, ptr %nb_oargs, align 4
  %call68 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %53, ptr noundef @.str.46, i32 noundef %bf.cast, i32 noundef %55)
  store i32 %call68, ptr %ret_64, align 4
  %56 = load i32, ptr %ret_64, align 4
  %cmp70 = icmp sge i32 %56, 0
  br i1 %cmp70, label %cond.true72, label %cond.false73

cond.true72:                                      ; preds = %if.end
  %57 = load i32, ptr %ret_64, align 4
  br label %cond.end74

cond.false73:                                     ; preds = %if.end
  br label %cond.end74

cond.end74:                                       ; preds = %cond.false73, %cond.true72
  %cond75 = phi i32 [ %57, %cond.true72 ], [ 0, %cond.false73 ]
  store i32 %cond75, ptr %tmp69, align 4
  %58 = load i32, ptr %tmp69, align 4
  %59 = load i32, ptr %col, align 4
  %add76 = add i32 %59, %58
  store i32 %add76, ptr %col, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond77

for.cond77:                                       ; preds = %for.inc94, %cond.end74
  %60 = load i32, ptr %i, align 4
  %61 = load i32, ptr %nb_oargs, align 4
  %cmp78 = icmp slt i32 %60, %61
  br i1 %cmp78, label %for.body80, label %for.end96

for.body80:                                       ; preds = %for.cond77
  %62 = load ptr, ptr %f.addr, align 8
  %63 = load ptr, ptr %s.addr, align 8
  %arraydecay = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %64 = load ptr, ptr %op, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %64, i32 0, i32 4
  %65 = load i32, ptr %i, align 4
  %idxprom82 = sext i32 %65 to i64
  %arrayidx83 = getelementptr [0 x i64], ptr %args, i64 0, i64 %idxprom82
  %66 = load i64, ptr %arrayidx83, align 8
  %call84 = call ptr @tcg_get_arg_str(ptr noundef %63, ptr noundef %arraydecay, i32 noundef 128, i64 noundef %66)
  %call85 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %62, ptr noundef @.str.47, ptr noundef %call84)
  store i32 %call85, ptr %ret_81, align 4
  %67 = load i32, ptr %ret_81, align 4
  %cmp87 = icmp sge i32 %67, 0
  br i1 %cmp87, label %cond.true89, label %cond.false90

cond.true89:                                      ; preds = %for.body80
  %68 = load i32, ptr %ret_81, align 4
  br label %cond.end91

cond.false90:                                     ; preds = %for.body80
  br label %cond.end91

cond.end91:                                       ; preds = %cond.false90, %cond.true89
  %cond92 = phi i32 [ %68, %cond.true89 ], [ 0, %cond.false90 ]
  store i32 %cond92, ptr %tmp86, align 4
  %69 = load i32, ptr %tmp86, align 4
  %70 = load i32, ptr %col, align 4
  %add93 = add i32 %70, %69
  store i32 %add93, ptr %col, align 4
  br label %for.inc94

for.inc94:                                        ; preds = %cond.end91
  %71 = load i32, ptr %i, align 4
  %inc95 = add i32 %71, 1
  store i32 %inc95, ptr %i, align 4
  br label %for.cond77, !llvm.loop !28

for.end96:                                        ; preds = %for.cond77
  store i32 0, ptr %i, align 4
  br label %for.cond97

for.cond97:                                       ; preds = %for.inc117, %for.end96
  %72 = load i32, ptr %i, align 4
  %73 = load i32, ptr %nb_iargs, align 4
  %cmp98 = icmp slt i32 %72, %73
  br i1 %cmp98, label %for.body100, label %for.end119

for.body100:                                      ; preds = %for.cond97
  %74 = load ptr, ptr %op, align 8
  %args101 = getelementptr inbounds %struct.TCGOp, ptr %74, i32 0, i32 4
  %75 = load i32, ptr %nb_oargs, align 4
  %76 = load i32, ptr %i, align 4
  %add102 = add i32 %75, %76
  %idxprom103 = sext i32 %add102 to i64
  %arrayidx104 = getelementptr [0 x i64], ptr %args101, i64 0, i64 %idxprom103
  %77 = load i64, ptr %arrayidx104, align 8
  store i64 %77, ptr %arg, align 8
  %78 = load ptr, ptr %s.addr, align 8
  %arraydecay105 = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %79 = load i64, ptr %arg, align 8
  %call106 = call ptr @tcg_get_arg_str(ptr noundef %78, ptr noundef %arraydecay105, i32 noundef 128, i64 noundef %79)
  store ptr %call106, ptr %t, align 8
  %80 = load ptr, ptr %f.addr, align 8
  %81 = load ptr, ptr %t, align 8
  %call108 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %80, ptr noundef @.str.47, ptr noundef %81)
  store i32 %call108, ptr %ret_107, align 4
  %82 = load i32, ptr %ret_107, align 4
  %cmp110 = icmp sge i32 %82, 0
  br i1 %cmp110, label %cond.true112, label %cond.false113

cond.true112:                                     ; preds = %for.body100
  %83 = load i32, ptr %ret_107, align 4
  br label %cond.end114

cond.false113:                                    ; preds = %for.body100
  br label %cond.end114

cond.end114:                                      ; preds = %cond.false113, %cond.true112
  %cond115 = phi i32 [ %83, %cond.true112 ], [ 0, %cond.false113 ]
  store i32 %cond115, ptr %tmp109, align 4
  %84 = load i32, ptr %tmp109, align 4
  %85 = load i32, ptr %col, align 4
  %add116 = add i32 %85, %84
  store i32 %add116, ptr %col, align 4
  br label %for.inc117

for.inc117:                                       ; preds = %cond.end114
  %86 = load i32, ptr %i, align 4
  %inc118 = add i32 %86, 1
  store i32 %inc118, ptr %i, align 4
  br label %for.cond97, !llvm.loop !29

for.end119:                                       ; preds = %for.cond97
  br label %if.end430

if.else120:                                       ; preds = %if.else
  %87 = load ptr, ptr %f.addr, align 8
  %88 = load ptr, ptr %def, align 8
  %name122 = getelementptr inbounds %struct.TCGOpDef, ptr %88, i32 0, i32 0
  %89 = load ptr, ptr %name122, align 8
  %call123 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %87, ptr noundef @.str.43, ptr noundef %89)
  store i32 %call123, ptr %ret_121, align 4
  %90 = load i32, ptr %ret_121, align 4
  %cmp125 = icmp sge i32 %90, 0
  br i1 %cmp125, label %cond.true127, label %cond.false128

cond.true127:                                     ; preds = %if.else120
  %91 = load i32, ptr %ret_121, align 4
  br label %cond.end129

cond.false128:                                    ; preds = %if.else120
  br label %cond.end129

cond.end129:                                      ; preds = %cond.false128, %cond.true127
  %cond130 = phi i32 [ %91, %cond.true127 ], [ 0, %cond.false128 ]
  store i32 %cond130, ptr %tmp124, align 4
  %92 = load i32, ptr %tmp124, align 4
  %93 = load i32, ptr %col, align 4
  %add131 = add i32 %93, %92
  store i32 %add131, ptr %col, align 4
  %94 = load ptr, ptr %def, align 8
  %nb_oargs132 = getelementptr inbounds %struct.TCGOpDef, ptr %94, i32 0, i32 1
  %95 = load i8, ptr %nb_oargs132, align 8
  %conv133 = zext i8 %95 to i32
  store i32 %conv133, ptr %nb_oargs, align 4
  %96 = load ptr, ptr %def, align 8
  %nb_iargs134 = getelementptr inbounds %struct.TCGOpDef, ptr %96, i32 0, i32 2
  %97 = load i8, ptr %nb_iargs134, align 1
  %conv135 = zext i8 %97 to i32
  store i32 %conv135, ptr %nb_iargs, align 4
  %98 = load ptr, ptr %def, align 8
  %nb_cargs136 = getelementptr inbounds %struct.TCGOpDef, ptr %98, i32 0, i32 3
  %99 = load i8, ptr %nb_cargs136, align 2
  %conv137 = zext i8 %99 to i32
  store i32 %conv137, ptr %nb_cargs, align 4
  %100 = load ptr, ptr %def, align 8
  %flags138 = getelementptr inbounds %struct.TCGOpDef, ptr %100, i32 0, i32 5
  %101 = load i8, ptr %flags138, align 4
  %conv139 = zext i8 %101 to i32
  %and = and i32 %conv139, 64
  %tobool140 = icmp ne i32 %and, 0
  br i1 %tobool140, label %if.then141, label %if.end158

if.then141:                                       ; preds = %cond.end129
  %102 = load ptr, ptr %f.addr, align 8
  %103 = load ptr, ptr %op, align 8
  %bf.load143 = load i32, ptr %103, align 8
  %bf.lshr144 = lshr i32 %bf.load143, 16
  %bf.clear145 = and i32 %bf.lshr144, 255
  %shl = shl i32 64, %bf.clear145
  %104 = load ptr, ptr %op, align 8
  %bf.load146 = load i32, ptr %104, align 8
  %bf.lshr147 = lshr i32 %bf.load146, 24
  %shl148 = shl i32 8, %bf.lshr147
  %call149 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %102, ptr noundef @.str.48, i32 noundef %shl, i32 noundef %shl148)
  store i32 %call149, ptr %ret_142, align 4
  %105 = load i32, ptr %ret_142, align 4
  %cmp151 = icmp sge i32 %105, 0
  br i1 %cmp151, label %cond.true153, label %cond.false154

cond.true153:                                     ; preds = %if.then141
  %106 = load i32, ptr %ret_142, align 4
  br label %cond.end155

cond.false154:                                    ; preds = %if.then141
  br label %cond.end155

cond.end155:                                      ; preds = %cond.false154, %cond.true153
  %cond156 = phi i32 [ %106, %cond.true153 ], [ 0, %cond.false154 ]
  store i32 %cond156, ptr %tmp150, align 4
  %107 = load i32, ptr %tmp150, align 4
  %108 = load i32, ptr %col, align 4
  %add157 = add i32 %108, %107
  store i32 %add157, ptr %col, align 4
  br label %if.end158

if.end158:                                        ; preds = %cond.end155, %cond.end129
  store i32 0, ptr %k, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond159

for.cond159:                                      ; preds = %for.inc181, %if.end158
  %109 = load i32, ptr %i, align 4
  %110 = load i32, ptr %nb_oargs, align 4
  %cmp160 = icmp slt i32 %109, %110
  br i1 %cmp160, label %for.body162, label %for.end183

for.body162:                                      ; preds = %for.cond159
  %111 = load i32, ptr %k, align 4
  %tobool163 = icmp ne i32 %111, 0
  %cond164 = select i1 %tobool163, ptr @.str.49, ptr @.str.50
  store ptr %cond164, ptr %sep, align 8
  %112 = load ptr, ptr %f.addr, align 8
  %113 = load ptr, ptr %sep, align 8
  %114 = load ptr, ptr %s.addr, align 8
  %arraydecay166 = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %115 = load ptr, ptr %op, align 8
  %args167 = getelementptr inbounds %struct.TCGOp, ptr %115, i32 0, i32 4
  %116 = load i32, ptr %k, align 4
  %inc168 = add i32 %116, 1
  store i32 %inc168, ptr %k, align 4
  %idxprom169 = sext i32 %116 to i64
  %arrayidx170 = getelementptr [0 x i64], ptr %args167, i64 0, i64 %idxprom169
  %117 = load i64, ptr %arrayidx170, align 8
  %call171 = call ptr @tcg_get_arg_str(ptr noundef %114, ptr noundef %arraydecay166, i32 noundef 128, i64 noundef %117)
  %call172 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %112, ptr noundef @.str.51, ptr noundef %113, ptr noundef %call171)
  store i32 %call172, ptr %ret_165, align 4
  %118 = load i32, ptr %ret_165, align 4
  %cmp174 = icmp sge i32 %118, 0
  br i1 %cmp174, label %cond.true176, label %cond.false177

cond.true176:                                     ; preds = %for.body162
  %119 = load i32, ptr %ret_165, align 4
  br label %cond.end178

cond.false177:                                    ; preds = %for.body162
  br label %cond.end178

cond.end178:                                      ; preds = %cond.false177, %cond.true176
  %cond179 = phi i32 [ %119, %cond.true176 ], [ 0, %cond.false177 ]
  store i32 %cond179, ptr %tmp173, align 4
  %120 = load i32, ptr %tmp173, align 4
  %121 = load i32, ptr %col, align 4
  %add180 = add i32 %121, %120
  store i32 %add180, ptr %col, align 4
  br label %for.inc181

for.inc181:                                       ; preds = %cond.end178
  %122 = load i32, ptr %i, align 4
  %inc182 = add i32 %122, 1
  store i32 %inc182, ptr %i, align 4
  br label %for.cond159, !llvm.loop !30

for.end183:                                       ; preds = %for.cond159
  store i32 0, ptr %i, align 4
  br label %for.cond184

for.cond184:                                      ; preds = %for.inc207, %for.end183
  %123 = load i32, ptr %i, align 4
  %124 = load i32, ptr %nb_iargs, align 4
  %cmp185 = icmp slt i32 %123, %124
  br i1 %cmp185, label %for.body187, label %for.end209

for.body187:                                      ; preds = %for.cond184
  %125 = load i32, ptr %k, align 4
  %tobool189 = icmp ne i32 %125, 0
  %cond190 = select i1 %tobool189, ptr @.str.49, ptr @.str.50
  store ptr %cond190, ptr %sep188, align 8
  %126 = load ptr, ptr %f.addr, align 8
  %127 = load ptr, ptr %sep188, align 8
  %128 = load ptr, ptr %s.addr, align 8
  %arraydecay192 = getelementptr inbounds [128 x i8], ptr %buf, i64 0, i64 0
  %129 = load ptr, ptr %op, align 8
  %args193 = getelementptr inbounds %struct.TCGOp, ptr %129, i32 0, i32 4
  %130 = load i32, ptr %k, align 4
  %inc194 = add i32 %130, 1
  store i32 %inc194, ptr %k, align 4
  %idxprom195 = sext i32 %130 to i64
  %arrayidx196 = getelementptr [0 x i64], ptr %args193, i64 0, i64 %idxprom195
  %131 = load i64, ptr %arrayidx196, align 8
  %call197 = call ptr @tcg_get_arg_str(ptr noundef %128, ptr noundef %arraydecay192, i32 noundef 128, i64 noundef %131)
  %call198 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %126, ptr noundef @.str.51, ptr noundef %127, ptr noundef %call197)
  store i32 %call198, ptr %ret_191, align 4
  %132 = load i32, ptr %ret_191, align 4
  %cmp200 = icmp sge i32 %132, 0
  br i1 %cmp200, label %cond.true202, label %cond.false203

cond.true202:                                     ; preds = %for.body187
  %133 = load i32, ptr %ret_191, align 4
  br label %cond.end204

cond.false203:                                    ; preds = %for.body187
  br label %cond.end204

cond.end204:                                      ; preds = %cond.false203, %cond.true202
  %cond205 = phi i32 [ %133, %cond.true202 ], [ 0, %cond.false203 ]
  store i32 %cond205, ptr %tmp199, align 4
  %134 = load i32, ptr %tmp199, align 4
  %135 = load i32, ptr %col, align 4
  %add206 = add i32 %135, %134
  store i32 %add206, ptr %col, align 4
  br label %for.inc207

for.inc207:                                       ; preds = %cond.end204
  %136 = load i32, ptr %i, align 4
  %inc208 = add i32 %136, 1
  store i32 %inc208, ptr %i, align 4
  br label %for.cond184, !llvm.loop !31

for.end209:                                       ; preds = %for.cond184
  %137 = load i32, ptr %c, align 4
  switch i32 %137, label %sw.default [
    i32 38, label %sw.bb
    i32 6, label %sw.bb
    i32 7, label %sw.bb
    i32 8, label %sw.bb
    i32 45, label %sw.bb
    i32 46, label %sw.bb
    i32 103, label %sw.bb
    i32 64, label %sw.bb
    i32 65, label %sw.bb
    i32 66, label %sw.bb
    i32 190, label %sw.bb
    i32 192, label %sw.bb
    i32 135, label %sw.bb252
    i32 139, label %sw.bb252
    i32 136, label %sw.bb252
    i32 140, label %sw.bb252
    i32 143, label %sw.bb252
    i32 144, label %sw.bb252
    i32 137, label %sw.bb252
    i32 141, label %sw.bb252
    i32 138, label %sw.bb252
    i32 142, label %sw.bb252
    i32 145, label %sw.bb252
    i32 146, label %sw.bb252
    i32 147, label %sw.bb252
    i32 148, label %sw.bb252
    i32 51, label %sw.bb302
    i32 110, label %sw.bb302
    i32 52, label %sw.bb302
    i32 111, label %sw.bb302
    i32 112, label %sw.bb302
  ]

sw.bb:                                            ; preds = %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209
  %138 = load ptr, ptr %op, align 8
  %args210 = getelementptr inbounds %struct.TCGOp, ptr %138, i32 0, i32 4
  %139 = load i32, ptr %k, align 4
  %idxprom211 = sext i32 %139 to i64
  %arrayidx212 = getelementptr [0 x i64], ptr %args210, i64 0, i64 %idxprom211
  %140 = load i64, ptr %arrayidx212, align 8
  %cmp213 = icmp ult i64 %140, 14
  br i1 %cmp213, label %land.lhs.true, label %if.else236

land.lhs.true:                                    ; preds = %sw.bb
  %141 = load ptr, ptr %op, align 8
  %args215 = getelementptr inbounds %struct.TCGOp, ptr %141, i32 0, i32 4
  %142 = load i32, ptr %k, align 4
  %idxprom216 = sext i32 %142 to i64
  %arrayidx217 = getelementptr [0 x i64], ptr %args215, i64 0, i64 %idxprom216
  %143 = load i64, ptr %arrayidx217, align 8
  %arrayidx218 = getelementptr [14 x ptr], ptr @cond_name, i64 0, i64 %143
  %144 = load ptr, ptr %arrayidx218, align 8
  %tobool219 = icmp ne ptr %144, null
  br i1 %tobool219, label %if.then220, label %if.else236

if.then220:                                       ; preds = %land.lhs.true
  %145 = load ptr, ptr %f.addr, align 8
  %146 = load ptr, ptr %op, align 8
  %args222 = getelementptr inbounds %struct.TCGOp, ptr %146, i32 0, i32 4
  %147 = load i32, ptr %k, align 4
  %inc223 = add i32 %147, 1
  store i32 %inc223, ptr %k, align 4
  %idxprom224 = sext i32 %147 to i64
  %arrayidx225 = getelementptr [0 x i64], ptr %args222, i64 0, i64 %idxprom224
  %148 = load i64, ptr %arrayidx225, align 8
  %arrayidx226 = getelementptr [14 x ptr], ptr @cond_name, i64 0, i64 %148
  %149 = load ptr, ptr %arrayidx226, align 8
  %call227 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %145, ptr noundef @.str.47, ptr noundef %149)
  store i32 %call227, ptr %ret_221, align 4
  %150 = load i32, ptr %ret_221, align 4
  %cmp229 = icmp sge i32 %150, 0
  br i1 %cmp229, label %cond.true231, label %cond.false232

cond.true231:                                     ; preds = %if.then220
  %151 = load i32, ptr %ret_221, align 4
  br label %cond.end233

cond.false232:                                    ; preds = %if.then220
  br label %cond.end233

cond.end233:                                      ; preds = %cond.false232, %cond.true231
  %cond234 = phi i32 [ %151, %cond.true231 ], [ 0, %cond.false232 ]
  store i32 %cond234, ptr %tmp228, align 4
  %152 = load i32, ptr %tmp228, align 4
  %153 = load i32, ptr %col, align 4
  %add235 = add i32 %153, %152
  store i32 %add235, ptr %col, align 4
  br label %if.end251

if.else236:                                       ; preds = %land.lhs.true, %sw.bb
  %154 = load ptr, ptr %f.addr, align 8
  %155 = load ptr, ptr %op, align 8
  %args238 = getelementptr inbounds %struct.TCGOp, ptr %155, i32 0, i32 4
  %156 = load i32, ptr %k, align 4
  %inc239 = add i32 %156, 1
  store i32 %inc239, ptr %k, align 4
  %idxprom240 = sext i32 %156 to i64
  %arrayidx241 = getelementptr [0 x i64], ptr %args238, i64 0, i64 %idxprom240
  %157 = load i64, ptr %arrayidx241, align 8
  %call242 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %154, ptr noundef @.str.52, i64 noundef %157)
  store i32 %call242, ptr %ret_237, align 4
  %158 = load i32, ptr %ret_237, align 4
  %cmp244 = icmp sge i32 %158, 0
  br i1 %cmp244, label %cond.true246, label %cond.false247

cond.true246:                                     ; preds = %if.else236
  %159 = load i32, ptr %ret_237, align 4
  br label %cond.end248

cond.false247:                                    ; preds = %if.else236
  br label %cond.end248

cond.end248:                                      ; preds = %cond.false247, %cond.true246
  %cond249 = phi i32 [ %159, %cond.true246 ], [ 0, %cond.false247 ]
  store i32 %cond249, ptr %tmp243, align 4
  %160 = load i32, ptr %tmp243, align 4
  %161 = load i32, ptr %col, align 4
  %add250 = add i32 %161, %160
  store i32 %add250, ptr %col, align 4
  br label %if.end251

if.end251:                                        ; preds = %cond.end248, %cond.end233
  store i32 1, ptr %i, align 4
  br label %sw.epilog

sw.bb252:                                         ; preds = %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209, %for.end209
  %162 = load ptr, ptr %op, align 8
  %args253 = getelementptr inbounds %struct.TCGOp, ptr %162, i32 0, i32 4
  %163 = load i32, ptr %k, align 4
  %inc254 = add i32 %163, 1
  store i32 %inc254, ptr %k, align 4
  %idxprom255 = sext i32 %163 to i64
  %arrayidx256 = getelementptr [0 x i64], ptr %args253, i64 0, i64 %idxprom255
  %164 = load i64, ptr %arrayidx256, align 8
  %conv257 = trunc i64 %164 to i32
  store i32 %conv257, ptr %oi, align 4
  %165 = load i32, ptr %oi, align 4
  %call258 = call i32 @get_memop(i32 noundef %165)
  store i32 %call258, ptr %mop, align 4
  %166 = load i32, ptr %oi, align 4
  %call259 = call i32 @get_mmuidx(i32 noundef %166)
  store i32 %call259, ptr %ix, align 4
  %167 = load i32, ptr %mop, align 4
  %and260 = and i32 %167, 224
  %shr = lshr i32 %and260, 5
  %idxprom261 = zext i32 %shr to i64
  %arrayidx262 = getelementptr [8 x ptr], ptr @alignment_name, i64 0, i64 %idxprom261
  %168 = load ptr, ptr %arrayidx262, align 8
  store ptr %168, ptr %s_al, align 8
  %169 = load i32, ptr %mop, align 4
  %and263 = and i32 %169, 31
  %idxprom264 = zext i32 %and263 to i64
  %arrayidx265 = getelementptr [32 x ptr], ptr @ldst_name, i64 0, i64 %idxprom264
  %170 = load ptr, ptr %arrayidx265, align 8
  store ptr %170, ptr %s_op, align 8
  %171 = load i32, ptr %mop, align 4
  %and266 = and i32 %171, 1792
  %shr267 = lshr i32 %and266, 8
  %idxprom268 = zext i32 %shr267 to i64
  %arrayidx269 = getelementptr [8 x ptr], ptr @atom_name, i64 0, i64 %idxprom268
  %172 = load ptr, ptr %arrayidx269, align 8
  store ptr %172, ptr %s_at, align 8
  %173 = load i32, ptr %mop, align 4
  %and270 = and i32 %173, -2048
  store i32 %and270, ptr %mop, align 4
  %174 = load i32, ptr %mop, align 4
  %tobool271 = icmp ne i32 %174, 0
  br i1 %tobool271, label %if.else289, label %land.lhs.true272

land.lhs.true272:                                 ; preds = %sw.bb252
  %175 = load ptr, ptr %s_al, align 8
  %tobool273 = icmp ne ptr %175, null
  br i1 %tobool273, label %land.lhs.true274, label %if.else289

land.lhs.true274:                                 ; preds = %land.lhs.true272
  %176 = load ptr, ptr %s_op, align 8
  %tobool275 = icmp ne ptr %176, null
  br i1 %tobool275, label %land.lhs.true276, label %if.else289

land.lhs.true276:                                 ; preds = %land.lhs.true274
  %177 = load ptr, ptr %s_at, align 8
  %tobool277 = icmp ne ptr %177, null
  br i1 %tobool277, label %if.then278, label %if.else289

if.then278:                                       ; preds = %land.lhs.true276
  %178 = load ptr, ptr %f.addr, align 8
  %179 = load ptr, ptr %s_at, align 8
  %180 = load ptr, ptr %s_al, align 8
  %181 = load ptr, ptr %s_op, align 8
  %182 = load i32, ptr %ix, align 4
  %call280 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %178, ptr noundef @.str.53, ptr noundef %179, ptr noundef %180, ptr noundef %181, i32 noundef %182)
  store i32 %call280, ptr %ret_279, align 4
  %183 = load i32, ptr %ret_279, align 4
  %cmp282 = icmp sge i32 %183, 0
  br i1 %cmp282, label %cond.true284, label %cond.false285

cond.true284:                                     ; preds = %if.then278
  %184 = load i32, ptr %ret_279, align 4
  br label %cond.end286

cond.false285:                                    ; preds = %if.then278
  br label %cond.end286

cond.end286:                                      ; preds = %cond.false285, %cond.true284
  %cond287 = phi i32 [ %184, %cond.true284 ], [ 0, %cond.false285 ]
  store i32 %cond287, ptr %tmp281, align 4
  %185 = load i32, ptr %tmp281, align 4
  %186 = load i32, ptr %col, align 4
  %add288 = add i32 %186, %185
  store i32 %add288, ptr %col, align 4
  br label %if.end301

if.else289:                                       ; preds = %land.lhs.true276, %land.lhs.true274, %land.lhs.true272, %sw.bb252
  %187 = load i32, ptr %oi, align 4
  %call290 = call i32 @get_memop(i32 noundef %187)
  store i32 %call290, ptr %mop, align 4
  %188 = load ptr, ptr %f.addr, align 8
  %189 = load i32, ptr %mop, align 4
  %190 = load i32, ptr %ix, align 4
  %call292 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %188, ptr noundef @.str.54, i32 noundef %189, i32 noundef %190)
  store i32 %call292, ptr %ret_291, align 4
  %191 = load i32, ptr %ret_291, align 4
  %cmp294 = icmp sge i32 %191, 0
  br i1 %cmp294, label %cond.true296, label %cond.false297

cond.true296:                                     ; preds = %if.else289
  %192 = load i32, ptr %ret_291, align 4
  br label %cond.end298

cond.false297:                                    ; preds = %if.else289
  br label %cond.end298

cond.end298:                                      ; preds = %cond.false297, %cond.true296
  %cond299 = phi i32 [ %192, %cond.true296 ], [ 0, %cond.false297 ]
  store i32 %cond299, ptr %tmp293, align 4
  %193 = load i32, ptr %tmp293, align 4
  %194 = load i32, ptr %col, align 4
  %add300 = add i32 %194, %193
  store i32 %add300, ptr %col, align 4
  br label %if.end301

if.end301:                                        ; preds = %cond.end298, %cond.end286
  store i32 1, ptr %i, align 4
  br label %sw.epilog

sw.bb302:                                         ; preds = %for.end209, %for.end209, %for.end209, %for.end209, %for.end209
  %195 = load ptr, ptr %op, align 8
  %args304 = getelementptr inbounds %struct.TCGOp, ptr %195, i32 0, i32 4
  %196 = load i32, ptr %k, align 4
  %idxprom305 = sext i32 %196 to i64
  %arrayidx306 = getelementptr [0 x i64], ptr %args304, i64 0, i64 %idxprom305
  %197 = load i64, ptr %arrayidx306, align 8
  store i64 %197, ptr %flags303, align 8
  store ptr null, ptr %name307, align 8
  %198 = load i64, ptr %flags303, align 8
  %cmp308 = icmp ult i64 %198, 6
  br i1 %cmp308, label %if.then310, label %if.end313

if.then310:                                       ; preds = %sw.bb302
  %199 = load i64, ptr %flags303, align 8
  %arrayidx311 = getelementptr [6 x [6 x i8]], ptr @bswap_flag_name, i64 0, i64 %199
  %arraydecay312 = getelementptr inbounds [6 x i8], ptr %arrayidx311, i64 0, i64 0
  store ptr %arraydecay312, ptr %name307, align 8
  br label %if.end313

if.end313:                                        ; preds = %if.then310, %sw.bb302
  %200 = load ptr, ptr %name307, align 8
  %tobool314 = icmp ne ptr %200, null
  br i1 %tobool314, label %if.then315, label %if.else326

if.then315:                                       ; preds = %if.end313
  %201 = load ptr, ptr %f.addr, align 8
  %202 = load ptr, ptr %name307, align 8
  %call317 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %201, ptr noundef @.str.47, ptr noundef %202)
  store i32 %call317, ptr %ret_316, align 4
  %203 = load i32, ptr %ret_316, align 4
  %cmp319 = icmp sge i32 %203, 0
  br i1 %cmp319, label %cond.true321, label %cond.false322

cond.true321:                                     ; preds = %if.then315
  %204 = load i32, ptr %ret_316, align 4
  br label %cond.end323

cond.false322:                                    ; preds = %if.then315
  br label %cond.end323

cond.end323:                                      ; preds = %cond.false322, %cond.true321
  %cond324 = phi i32 [ %204, %cond.true321 ], [ 0, %cond.false322 ]
  store i32 %cond324, ptr %tmp318, align 4
  %205 = load i32, ptr %tmp318, align 4
  %206 = load i32, ptr %col, align 4
  %add325 = add i32 %206, %205
  store i32 %add325, ptr %col, align 4
  br label %if.end337

if.else326:                                       ; preds = %if.end313
  %207 = load ptr, ptr %f.addr, align 8
  %208 = load i64, ptr %flags303, align 8
  %call328 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %207, ptr noundef @.str.52, i64 noundef %208)
  store i32 %call328, ptr %ret_327, align 4
  %209 = load i32, ptr %ret_327, align 4
  %cmp330 = icmp sge i32 %209, 0
  br i1 %cmp330, label %cond.true332, label %cond.false333

cond.true332:                                     ; preds = %if.else326
  %210 = load i32, ptr %ret_327, align 4
  br label %cond.end334

cond.false333:                                    ; preds = %if.else326
  br label %cond.end334

cond.end334:                                      ; preds = %cond.false333, %cond.true332
  %cond335 = phi i32 [ %210, %cond.true332 ], [ 0, %cond.false333 ]
  store i32 %cond335, ptr %tmp329, align 4
  %211 = load i32, ptr %tmp329, align 4
  %212 = load i32, ptr %col, align 4
  %add336 = add i32 %212, %211
  store i32 %add336, ptr %col, align 4
  br label %if.end337

if.end337:                                        ; preds = %cond.end334, %cond.end323
  store i32 1, ptr %k, align 4
  store i32 1, ptr %i, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %for.end209
  store i32 0, ptr %i, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end337, %if.end301, %if.end251
  %213 = load i32, ptr %c, align 4
  switch i32 %213, label %sw.default405 [
    i32 1, label %sw.bb338
    i32 3, label %sw.bb338
    i32 38, label %sw.bb338
    i32 103, label %sw.bb338
    i32 45, label %sw.bb338
    i32 4, label %sw.bb358
  ]

sw.bb338:                                         ; preds = %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog, %sw.epilog
  %214 = load ptr, ptr %f.addr, align 8
  %215 = load i32, ptr %k, align 4
  %tobool340 = icmp ne i32 %215, 0
  %cond341 = select i1 %tobool340, ptr @.str.49, ptr @.str.50
  %216 = load ptr, ptr %op, align 8
  %args342 = getelementptr inbounds %struct.TCGOp, ptr %216, i32 0, i32 4
  %217 = load i32, ptr %k, align 4
  %idxprom343 = sext i32 %217 to i64
  %arrayidx344 = getelementptr [0 x i64], ptr %args342, i64 0, i64 %idxprom343
  %218 = load i64, ptr %arrayidx344, align 8
  %call345 = call ptr @arg_label(i64 noundef %218)
  %id = getelementptr inbounds %struct.TCGLabel, ptr %call345, i32 0, i32 2
  %219 = load i16, ptr %id, align 2
  %conv346 = zext i16 %219 to i32
  %call347 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %214, ptr noundef @.str.55, ptr noundef %cond341, i32 noundef %conv346)
  store i32 %call347, ptr %ret_339, align 4
  %220 = load i32, ptr %ret_339, align 4
  %cmp349 = icmp sge i32 %220, 0
  br i1 %cmp349, label %cond.true351, label %cond.false352

cond.true351:                                     ; preds = %sw.bb338
  %221 = load i32, ptr %ret_339, align 4
  br label %cond.end353

cond.false352:                                    ; preds = %sw.bb338
  br label %cond.end353

cond.end353:                                      ; preds = %cond.false352, %cond.true351
  %cond354 = phi i32 [ %221, %cond.true351 ], [ 0, %cond.false352 ]
  store i32 %cond354, ptr %tmp348, align 4
  %222 = load i32, ptr %tmp348, align 4
  %223 = load i32, ptr %col, align 4
  %add355 = add i32 %223, %222
  store i32 %add355, ptr %col, align 4
  %224 = load i32, ptr %i, align 4
  %inc356 = add i32 %224, 1
  store i32 %inc356, ptr %i, align 4
  %225 = load i32, ptr %k, align 4
  %inc357 = add i32 %225, 1
  store i32 %inc357, ptr %k, align 4
  br label %sw.epilog406

sw.bb358:                                         ; preds = %sw.epilog
  %226 = load ptr, ptr %op, align 8
  %args359 = getelementptr inbounds %struct.TCGOp, ptr %226, i32 0, i32 4
  %227 = load i32, ptr %k, align 4
  %idxprom360 = sext i32 %227 to i64
  %arrayidx361 = getelementptr [0 x i64], ptr %args359, i64 0, i64 %idxprom360
  %228 = load i64, ptr %arrayidx361, align 8
  %conv362 = trunc i64 %228 to i32
  store i32 %conv362, ptr %membar, align 4
  %229 = load i32, ptr %membar, align 4
  %and363 = and i32 %229, 48
  switch i32 %and363, label %sw.default368 [
    i32 0, label %sw.bb364
    i32 16, label %sw.bb365
    i32 32, label %sw.bb366
    i32 48, label %sw.bb367
  ]

sw.bb364:                                         ; preds = %sw.bb358
  store ptr @.str.56, ptr %b_op, align 8
  br label %sw.epilog369

sw.bb365:                                         ; preds = %sw.bb358
  store ptr @.str.57, ptr %b_op, align 8
  br label %sw.epilog369

sw.bb366:                                         ; preds = %sw.bb358
  store ptr @.str.58, ptr %b_op, align 8
  br label %sw.epilog369

sw.bb367:                                         ; preds = %sw.bb358
  store ptr @.str.59, ptr %b_op, align 8
  br label %sw.epilog369

sw.default368:                                    ; preds = %sw.bb358
  br label %do.body

do.body:                                          ; preds = %sw.default368
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 2736, ptr noundef @__func__.tcg_dump_ops, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog369

sw.epilog369:                                     ; preds = %do.end, %sw.bb367, %sw.bb366, %sw.bb365, %sw.bb364
  %230 = load i32, ptr %membar, align 4
  %and370 = and i32 %230, 15
  switch i32 %and370, label %sw.default387 [
    i32 0, label %sw.bb371
    i32 1, label %sw.bb372
    i32 4, label %sw.bb373
    i32 2, label %sw.bb374
    i32 8, label %sw.bb375
    i32 5, label %sw.bb376
    i32 3, label %sw.bb377
    i32 9, label %sw.bb378
    i32 6, label %sw.bb379
    i32 12, label %sw.bb380
    i32 10, label %sw.bb381
    i32 7, label %sw.bb382
    i32 13, label %sw.bb383
    i32 11, label %sw.bb384
    i32 14, label %sw.bb385
    i32 15, label %sw.bb386
  ]

sw.bb371:                                         ; preds = %sw.epilog369
  store ptr @.str.56, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb372:                                         ; preds = %sw.epilog369
  store ptr @.str.60, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb373:                                         ; preds = %sw.epilog369
  store ptr @.str.61, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb374:                                         ; preds = %sw.epilog369
  store ptr @.str.62, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb375:                                         ; preds = %sw.epilog369
  store ptr @.str.63, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb376:                                         ; preds = %sw.epilog369
  store ptr @.str.64, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb377:                                         ; preds = %sw.epilog369
  store ptr @.str.65, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb378:                                         ; preds = %sw.epilog369
  store ptr @.str.66, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb379:                                         ; preds = %sw.epilog369
  store ptr @.str.67, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb380:                                         ; preds = %sw.epilog369
  store ptr @.str.68, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb381:                                         ; preds = %sw.epilog369
  store ptr @.str.69, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb382:                                         ; preds = %sw.epilog369
  store ptr @.str.70, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb383:                                         ; preds = %sw.epilog369
  store ptr @.str.71, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb384:                                         ; preds = %sw.epilog369
  store ptr @.str.72, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb385:                                         ; preds = %sw.epilog369
  store ptr @.str.73, ptr %m_op, align 8
  br label %sw.epilog390

sw.bb386:                                         ; preds = %sw.epilog369
  store ptr @.str.74, ptr %m_op, align 8
  br label %sw.epilog390

sw.default387:                                    ; preds = %sw.epilog369
  br label %do.body388

do.body388:                                       ; preds = %sw.default387
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 2789, ptr noundef @__func__.tcg_dump_ops, ptr noundef null) #15
  unreachable

do.end389:                                        ; No predecessors!
  br label %sw.epilog390

sw.epilog390:                                     ; preds = %do.end389, %sw.bb386, %sw.bb385, %sw.bb384, %sw.bb383, %sw.bb382, %sw.bb381, %sw.bb380, %sw.bb379, %sw.bb378, %sw.bb377, %sw.bb376, %sw.bb375, %sw.bb374, %sw.bb373, %sw.bb372, %sw.bb371
  %231 = load ptr, ptr %f.addr, align 8
  %232 = load i32, ptr %k, align 4
  %tobool392 = icmp ne i32 %232, 0
  %cond393 = select i1 %tobool392, ptr @.str.49, ptr @.str.50
  %233 = load ptr, ptr %b_op, align 8
  %234 = load ptr, ptr %m_op, align 8
  %call394 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %231, ptr noundef @.str.75, ptr noundef %cond393, ptr noundef %233, ptr noundef %234)
  store i32 %call394, ptr %ret_391, align 4
  %235 = load i32, ptr %ret_391, align 4
  %cmp396 = icmp sge i32 %235, 0
  br i1 %cmp396, label %cond.true398, label %cond.false399

cond.true398:                                     ; preds = %sw.epilog390
  %236 = load i32, ptr %ret_391, align 4
  br label %cond.end400

cond.false399:                                    ; preds = %sw.epilog390
  br label %cond.end400

cond.end400:                                      ; preds = %cond.false399, %cond.true398
  %cond401 = phi i32 [ %236, %cond.true398 ], [ 0, %cond.false399 ]
  store i32 %cond401, ptr %tmp395, align 4
  %237 = load i32, ptr %tmp395, align 4
  %238 = load i32, ptr %col, align 4
  %add402 = add i32 %238, %237
  store i32 %add402, ptr %col, align 4
  %239 = load i32, ptr %i, align 4
  %inc403 = add i32 %239, 1
  store i32 %inc403, ptr %i, align 4
  %240 = load i32, ptr %k, align 4
  %inc404 = add i32 %240, 1
  store i32 %inc404, ptr %k, align 4
  br label %sw.epilog406

sw.default405:                                    ; preds = %sw.epilog
  br label %sw.epilog406

sw.epilog406:                                     ; preds = %sw.default405, %cond.end400, %cond.end353
  br label %for.cond407

for.cond407:                                      ; preds = %for.inc426, %sw.epilog406
  %241 = load i32, ptr %i, align 4
  %242 = load i32, ptr %nb_cargs, align 4
  %cmp408 = icmp slt i32 %241, %242
  br i1 %cmp408, label %for.body410, label %for.end429

for.body410:                                      ; preds = %for.cond407
  %243 = load ptr, ptr %f.addr, align 8
  %244 = load i32, ptr %k, align 4
  %tobool412 = icmp ne i32 %244, 0
  %cond413 = select i1 %tobool412, ptr @.str.49, ptr @.str.50
  %245 = load ptr, ptr %op, align 8
  %args414 = getelementptr inbounds %struct.TCGOp, ptr %245, i32 0, i32 4
  %246 = load i32, ptr %k, align 4
  %idxprom415 = sext i32 %246 to i64
  %arrayidx416 = getelementptr [0 x i64], ptr %args414, i64 0, i64 %idxprom415
  %247 = load i64, ptr %arrayidx416, align 8
  %call417 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %243, ptr noundef @.str.76, ptr noundef %cond413, i64 noundef %247)
  store i32 %call417, ptr %ret_411, align 4
  %248 = load i32, ptr %ret_411, align 4
  %cmp419 = icmp sge i32 %248, 0
  br i1 %cmp419, label %cond.true421, label %cond.false422

cond.true421:                                     ; preds = %for.body410
  %249 = load i32, ptr %ret_411, align 4
  br label %cond.end423

cond.false422:                                    ; preds = %for.body410
  br label %cond.end423

cond.end423:                                      ; preds = %cond.false422, %cond.true421
  %cond424 = phi i32 [ %249, %cond.true421 ], [ 0, %cond.false422 ]
  store i32 %cond424, ptr %tmp418, align 4
  %250 = load i32, ptr %tmp418, align 4
  %251 = load i32, ptr %col, align 4
  %add425 = add i32 %251, %250
  store i32 %add425, ptr %col, align 4
  br label %for.inc426

for.inc426:                                       ; preds = %cond.end423
  %252 = load i32, ptr %i, align 4
  %inc427 = add i32 %252, 1
  store i32 %inc427, ptr %i, align 4
  %253 = load i32, ptr %k, align 4
  %inc428 = add i32 %253, 1
  store i32 %inc428, ptr %k, align 4
  br label %for.cond407, !llvm.loop !32

for.end429:                                       ; preds = %for.cond407
  br label %if.end430

if.end430:                                        ; preds = %for.end429, %for.end119
  br label %if.end431

if.end431:                                        ; preds = %if.end430, %for.end
  %254 = load i8, ptr %have_prefs.addr, align 1
  %tobool432 = trunc i8 %254 to i1
  br i1 %tobool432, label %if.then435, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end431
  %255 = load ptr, ptr %op, align 8
  %life = getelementptr inbounds %struct.TCGOp, ptr %255, i32 0, i32 1
  %256 = load i32, ptr %life, align 4
  %tobool434 = icmp ne i32 %256, 0
  br i1 %tobool434, label %if.then435, label %if.end444

if.then435:                                       ; preds = %lor.lhs.false, %if.end431
  br label %for.cond436

for.cond436:                                      ; preds = %for.inc441, %if.then435
  %257 = load i32, ptr %col, align 4
  %cmp437 = icmp slt i32 %257, 40
  br i1 %cmp437, label %for.body439, label %for.end443

for.body439:                                      ; preds = %for.cond436
  %258 = load ptr, ptr %f.addr, align 8
  %call440 = call i32 @putc(i32 noundef 32, ptr noundef %258)
  br label %for.inc441

for.inc441:                                       ; preds = %for.body439
  %259 = load i32, ptr %col, align 4
  %inc442 = add i32 %259, 1
  store i32 %inc442, ptr %col, align 4
  br label %for.cond436, !llvm.loop !33

for.end443:                                       ; preds = %for.cond436
  br label %if.end444

if.end444:                                        ; preds = %for.end443, %lor.lhs.false
  %260 = load ptr, ptr %op, align 8
  %life445 = getelementptr inbounds %struct.TCGOp, ptr %260, i32 0, i32 1
  %261 = load i32, ptr %life445, align 4
  %tobool446 = icmp ne i32 %261, 0
  br i1 %tobool446, label %if.then447, label %if.end516

if.then447:                                       ; preds = %if.end444
  %262 = load ptr, ptr %op, align 8
  %life449 = getelementptr inbounds %struct.TCGOp, ptr %262, i32 0, i32 1
  %263 = load i32, ptr %life449, align 4
  store i32 %263, ptr %life448, align 4
  %264 = load i32, ptr %life448, align 4
  %and450 = and i32 %264, 3
  %tobool451 = icmp ne i32 %and450, 0
  br i1 %tobool451, label %if.then452, label %if.end483

if.then452:                                       ; preds = %if.then447
  %265 = load ptr, ptr %f.addr, align 8
  %call454 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %265, ptr noundef @.str.77)
  store i32 %call454, ptr %ret_453, align 4
  %266 = load i32, ptr %ret_453, align 4
  %cmp456 = icmp sge i32 %266, 0
  br i1 %cmp456, label %cond.true458, label %cond.false459

cond.true458:                                     ; preds = %if.then452
  %267 = load i32, ptr %ret_453, align 4
  br label %cond.end460

cond.false459:                                    ; preds = %if.then452
  br label %cond.end460

cond.end460:                                      ; preds = %cond.false459, %cond.true458
  %cond461 = phi i32 [ %267, %cond.true458 ], [ 0, %cond.false459 ]
  store i32 %cond461, ptr %tmp455, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond462

for.cond462:                                      ; preds = %for.inc480, %cond.end460
  %268 = load i32, ptr %i, align 4
  %cmp463 = icmp slt i32 %268, 2
  br i1 %cmp463, label %for.body465, label %for.end482

for.body465:                                      ; preds = %for.cond462
  %269 = load i32, ptr %life448, align 4
  %270 = load i32, ptr %i, align 4
  %shl466 = shl i32 1, %270
  %and467 = and i32 %269, %shl466
  %tobool468 = icmp ne i32 %and467, 0
  br i1 %tobool468, label %if.then469, label %if.end479

if.then469:                                       ; preds = %for.body465
  %271 = load ptr, ptr %f.addr, align 8
  %272 = load i32, ptr %i, align 4
  %call471 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %271, ptr noundef @.str.78, i32 noundef %272)
  store i32 %call471, ptr %ret_470, align 4
  %273 = load i32, ptr %ret_470, align 4
  %cmp473 = icmp sge i32 %273, 0
  br i1 %cmp473, label %cond.true475, label %cond.false476

cond.true475:                                     ; preds = %if.then469
  %274 = load i32, ptr %ret_470, align 4
  br label %cond.end477

cond.false476:                                    ; preds = %if.then469
  br label %cond.end477

cond.end477:                                      ; preds = %cond.false476, %cond.true475
  %cond478 = phi i32 [ %274, %cond.true475 ], [ 0, %cond.false476 ]
  store i32 %cond478, ptr %tmp472, align 4
  br label %if.end479

if.end479:                                        ; preds = %cond.end477, %for.body465
  br label %for.inc480

for.inc480:                                       ; preds = %if.end479
  %275 = load i32, ptr %i, align 4
  %inc481 = add i32 %275, 1
  store i32 %inc481, ptr %i, align 4
  br label %for.cond462, !llvm.loop !34

for.end482:                                       ; preds = %for.cond462
  br label %if.end483

if.end483:                                        ; preds = %for.end482, %if.then447
  %276 = load i32, ptr %life448, align 4
  %div = udiv i32 %276, 16
  store i32 %div, ptr %life448, align 4
  %277 = load i32, ptr %life448, align 4
  %tobool484 = icmp ne i32 %277, 0
  br i1 %tobool484, label %if.then485, label %if.end515

if.then485:                                       ; preds = %if.end483
  %278 = load ptr, ptr %f.addr, align 8
  %call487 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %278, ptr noundef @.str.79)
  store i32 %call487, ptr %ret_486, align 4
  %279 = load i32, ptr %ret_486, align 4
  %cmp489 = icmp sge i32 %279, 0
  br i1 %cmp489, label %cond.true491, label %cond.false492

cond.true491:                                     ; preds = %if.then485
  %280 = load i32, ptr %ret_486, align 4
  br label %cond.end493

cond.false492:                                    ; preds = %if.then485
  br label %cond.end493

cond.end493:                                      ; preds = %cond.false492, %cond.true491
  %cond494 = phi i32 [ %280, %cond.true491 ], [ 0, %cond.false492 ]
  store i32 %cond494, ptr %tmp488, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond495

for.cond495:                                      ; preds = %for.inc511, %cond.end493
  %281 = load i32, ptr %life448, align 4
  %tobool496 = icmp ne i32 %281, 0
  br i1 %tobool496, label %for.body497, label %for.end514

for.body497:                                      ; preds = %for.cond495
  %282 = load i32, ptr %life448, align 4
  %and498 = and i32 %282, 1
  %tobool499 = icmp ne i32 %and498, 0
  br i1 %tobool499, label %if.then500, label %if.end510

if.then500:                                       ; preds = %for.body497
  %283 = load ptr, ptr %f.addr, align 8
  %284 = load i32, ptr %i, align 4
  %call502 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %283, ptr noundef @.str.78, i32 noundef %284)
  store i32 %call502, ptr %ret_501, align 4
  %285 = load i32, ptr %ret_501, align 4
  %cmp504 = icmp sge i32 %285, 0
  br i1 %cmp504, label %cond.true506, label %cond.false507

cond.true506:                                     ; preds = %if.then500
  %286 = load i32, ptr %ret_501, align 4
  br label %cond.end508

cond.false507:                                    ; preds = %if.then500
  br label %cond.end508

cond.end508:                                      ; preds = %cond.false507, %cond.true506
  %cond509 = phi i32 [ %286, %cond.true506 ], [ 0, %cond.false507 ]
  store i32 %cond509, ptr %tmp503, align 4
  br label %if.end510

if.end510:                                        ; preds = %cond.end508, %for.body497
  br label %for.inc511

for.inc511:                                       ; preds = %if.end510
  %287 = load i32, ptr %i, align 4
  %inc512 = add i32 %287, 1
  store i32 %inc512, ptr %i, align 4
  %288 = load i32, ptr %life448, align 4
  %shr513 = lshr i32 %288, 1
  store i32 %shr513, ptr %life448, align 4
  br label %for.cond495, !llvm.loop !35

for.end514:                                       ; preds = %for.cond495
  br label %if.end515

if.end515:                                        ; preds = %for.end514, %if.end483
  br label %if.end516

if.end516:                                        ; preds = %if.end515, %if.end444
  %289 = load i8, ptr %have_prefs.addr, align 1
  %tobool517 = trunc i8 %289 to i1
  br i1 %tobool517, label %if.then518, label %if.end588

if.then518:                                       ; preds = %if.end516
  store i32 0, ptr %i, align 4
  br label %for.cond519

for.cond519:                                      ; preds = %for.inc585, %if.then518
  %290 = load i32, ptr %i, align 4
  %291 = load i32, ptr %nb_oargs, align 4
  %cmp520 = icmp slt i32 %290, %291
  br i1 %cmp520, label %for.body522, label %for.end587

for.body522:                                      ; preds = %for.cond519
  %292 = load ptr, ptr %op, align 8
  %293 = load i32, ptr %i, align 4
  %call523 = call i32 @output_pref(ptr noundef %292, i32 noundef %293)
  store i32 %call523, ptr %set, align 4
  %294 = load i32, ptr %i, align 4
  %cmp524 = icmp eq i32 %294, 0
  br i1 %cmp524, label %if.then526, label %if.else536

if.then526:                                       ; preds = %for.body522
  %295 = load ptr, ptr %f.addr, align 8
  %call528 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %295, ptr noundef @.str.80)
  store i32 %call528, ptr %ret_527, align 4
  %296 = load i32, ptr %ret_527, align 4
  %cmp530 = icmp sge i32 %296, 0
  br i1 %cmp530, label %cond.true532, label %cond.false533

cond.true532:                                     ; preds = %if.then526
  %297 = load i32, ptr %ret_527, align 4
  br label %cond.end534

cond.false533:                                    ; preds = %if.then526
  br label %cond.end534

cond.end534:                                      ; preds = %cond.false533, %cond.true532
  %cond535 = phi i32 [ %297, %cond.true532 ], [ 0, %cond.false533 ]
  store i32 %cond535, ptr %tmp529, align 4
  br label %if.end546

if.else536:                                       ; preds = %for.body522
  %298 = load ptr, ptr %f.addr, align 8
  %call538 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %298, ptr noundef @.str.49)
  store i32 %call538, ptr %ret_537, align 4
  %299 = load i32, ptr %ret_537, align 4
  %cmp540 = icmp sge i32 %299, 0
  br i1 %cmp540, label %cond.true542, label %cond.false543

cond.true542:                                     ; preds = %if.else536
  %300 = load i32, ptr %ret_537, align 4
  br label %cond.end544

cond.false543:                                    ; preds = %if.else536
  br label %cond.end544

cond.end544:                                      ; preds = %cond.false543, %cond.true542
  %cond545 = phi i32 [ %300, %cond.true542 ], [ 0, %cond.false543 ]
  store i32 %cond545, ptr %tmp539, align 4
  br label %if.end546

if.end546:                                        ; preds = %cond.end544, %cond.end534
  %301 = load i32, ptr %set, align 4
  %cmp547 = icmp eq i32 %301, 0
  br i1 %cmp547, label %if.then549, label %if.else559

if.then549:                                       ; preds = %if.end546
  %302 = load ptr, ptr %f.addr, align 8
  %call551 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %302, ptr noundef @.str.56)
  store i32 %call551, ptr %ret_550, align 4
  %303 = load i32, ptr %ret_550, align 4
  %cmp553 = icmp sge i32 %303, 0
  br i1 %cmp553, label %cond.true555, label %cond.false556

cond.true555:                                     ; preds = %if.then549
  %304 = load i32, ptr %ret_550, align 4
  br label %cond.end557

cond.false556:                                    ; preds = %if.then549
  br label %cond.end557

cond.end557:                                      ; preds = %cond.false556, %cond.true555
  %cond558 = phi i32 [ %304, %cond.true555 ], [ 0, %cond.false556 ]
  store i32 %cond558, ptr %tmp552, align 4
  br label %if.end584

if.else559:                                       ; preds = %if.end546
  %305 = load i32, ptr %set, align 4
  %conv560 = zext i32 %305 to i64
  %cmp561 = icmp eq i64 %conv560, 4294967295
  br i1 %cmp561, label %if.then563, label %if.else573

if.then563:                                       ; preds = %if.else559
  %306 = load ptr, ptr %f.addr, align 8
  %call565 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %306, ptr noundef @.str.74)
  store i32 %call565, ptr %ret_564, align 4
  %307 = load i32, ptr %ret_564, align 4
  %cmp567 = icmp sge i32 %307, 0
  br i1 %cmp567, label %cond.true569, label %cond.false570

cond.true569:                                     ; preds = %if.then563
  %308 = load i32, ptr %ret_564, align 4
  br label %cond.end571

cond.false570:                                    ; preds = %if.then563
  br label %cond.end571

cond.end571:                                      ; preds = %cond.false570, %cond.true569
  %cond572 = phi i32 [ %308, %cond.true569 ], [ 0, %cond.false570 ]
  store i32 %cond572, ptr %tmp566, align 4
  br label %if.end583

if.else573:                                       ; preds = %if.else559
  %309 = load ptr, ptr %f.addr, align 8
  %310 = load i32, ptr %set, align 4
  %call575 = call i32 (ptr, ptr, ...) @fprintf(ptr noundef %309, ptr noundef @.str.81, i32 noundef %310)
  store i32 %call575, ptr %ret_574, align 4
  %311 = load i32, ptr %ret_574, align 4
  %cmp577 = icmp sge i32 %311, 0
  br i1 %cmp577, label %cond.true579, label %cond.false580

cond.true579:                                     ; preds = %if.else573
  %312 = load i32, ptr %ret_574, align 4
  br label %cond.end581

cond.false580:                                    ; preds = %if.else573
  br label %cond.end581

cond.end581:                                      ; preds = %cond.false580, %cond.true579
  %cond582 = phi i32 [ %312, %cond.true579 ], [ 0, %cond.false580 ]
  store i32 %cond582, ptr %tmp576, align 4
  br label %if.end583

if.end583:                                        ; preds = %cond.end581, %cond.end571
  br label %if.end584

if.end584:                                        ; preds = %if.end583, %cond.end557
  br label %for.inc585

for.inc585:                                       ; preds = %if.end584
  %313 = load i32, ptr %i, align 4
  %inc586 = add i32 %313, 1
  store i32 %inc586, ptr %i, align 4
  br label %for.cond519, !llvm.loop !36

for.end587:                                       ; preds = %for.cond519
  br label %if.end588

if.end588:                                        ; preds = %for.end587, %if.end516
  %314 = load ptr, ptr %f.addr, align 8
  %call589 = call i32 @putc(i32 noundef 10, ptr noundef %314)
  br label %for.inc590

for.inc590:                                       ; preds = %if.end588
  %315 = load ptr, ptr %op, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %315, i32 0, i32 2
  %316 = load ptr, ptr %link, align 8
  store ptr %316, ptr %op, align 8
  br label %for.cond, !llvm.loop !37

for.end591:                                       ; preds = %for.cond
  ret void
}

declare void @tcg_optimize(ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal void @reachable_code_pass(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %op = alloca ptr, align 8
  %op_next = alloca ptr, align 8
  %op_prev = alloca ptr, align 8
  %dead = alloca i8, align 1
  %remove = alloca i8, align 1
  %label = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i8 0, ptr %dead, align 1
  %0 = load ptr, ptr %s.addr, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 38
  %1 = load ptr, ptr %ops, align 8
  store ptr %1, ptr %op, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load ptr, ptr %op, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %3 = load ptr, ptr %op, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %link, align 8
  store ptr %4, ptr %op_next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %5 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %5, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %6 = load i8, ptr %dead, align 1
  %tobool1 = trunc i8 %6 to i1
  %frombool = zext i1 %tobool1 to i8
  store i8 %frombool, ptr %remove, align 1
  %7 = load ptr, ptr %op, align 8
  %bf.load = load i32, ptr %7, align 8
  %bf.clear = and i32 %bf.load, 255
  switch i32 %bf.clear, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb25
    i32 130, label %sw.bb25
    i32 132, label %sw.bb25
    i32 2, label %sw.bb26
    i32 129, label %sw.bb31
  ]

sw.bb:                                            ; preds = %for.body
  %8 = load ptr, ptr %op, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %8, i32 0, i32 4
  %arrayidx = getelementptr [0 x i64], ptr %args, i64 0, i64 0
  %9 = load i64, ptr %arrayidx, align 8
  %call = call ptr @arg_label(i64 noundef %9)
  store ptr %call, ptr %label, align 8
  %10 = load ptr, ptr %op, align 8
  %link2 = getelementptr inbounds %struct.TCGOp, ptr %10, i32 0, i32 2
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %link2, i32 0, i32 1
  %11 = load ptr, ptr %tql_prev, align 8
  %tql_prev3 = getelementptr inbounds %struct.QTailQLink, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %tql_prev3, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %tql_next, align 8
  store ptr %13, ptr %op_prev, align 8
  %14 = load ptr, ptr %op_prev, align 8
  %bf.load4 = load i32, ptr %14, align 8
  %bf.clear5 = and i32 %bf.load4, 255
  %cmp = icmp eq i32 %bf.clear5, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %15 = load ptr, ptr %label, align 8
  %16 = load ptr, ptr %op_prev, align 8
  %args6 = getelementptr inbounds %struct.TCGOp, ptr %16, i32 0, i32 4
  %arrayidx7 = getelementptr [0 x i64], ptr %args6, i64 0, i64 0
  %17 = load i64, ptr %arrayidx7, align 8
  %call8 = call ptr @arg_label(i64 noundef %17)
  call void @move_label_uses(ptr noundef %15, ptr noundef %call8)
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load ptr, ptr %op_prev, align 8
  call void @tcg_op_remove(ptr noundef %18, ptr noundef %19)
  %20 = load ptr, ptr %op, align 8
  %link9 = getelementptr inbounds %struct.TCGOp, ptr %20, i32 0, i32 2
  %tql_prev10 = getelementptr inbounds %struct.QTailQLink, ptr %link9, i32 0, i32 1
  %21 = load ptr, ptr %tql_prev10, align 8
  %tql_prev11 = getelementptr inbounds %struct.QTailQLink, ptr %21, i32 0, i32 1
  %22 = load ptr, ptr %tql_prev11, align 8
  %tql_next12 = getelementptr inbounds %struct.QTailQLink, ptr %22, i32 0, i32 0
  %23 = load ptr, ptr %tql_next12, align 8
  store ptr %23, ptr %op_prev, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %24 = load ptr, ptr %op_prev, align 8
  %bf.load13 = load i32, ptr %24, align 8
  %bf.clear14 = and i32 %bf.load13, 255
  %cmp15 = icmp eq i32 %bf.clear14, 3
  br i1 %cmp15, label %land.lhs.true, label %if.end21

land.lhs.true:                                    ; preds = %if.end
  %25 = load ptr, ptr %label, align 8
  %26 = load ptr, ptr %op_prev, align 8
  %args16 = getelementptr inbounds %struct.TCGOp, ptr %26, i32 0, i32 4
  %arrayidx17 = getelementptr [0 x i64], ptr %args16, i64 0, i64 0
  %27 = load i64, ptr %arrayidx17, align 8
  %call18 = call ptr @arg_label(i64 noundef %27)
  %cmp19 = icmp eq ptr %25, %call18
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true
  %28 = load ptr, ptr %s.addr, align 8
  %29 = load ptr, ptr %op_prev, align 8
  call void @tcg_op_remove(ptr noundef %28, ptr noundef %29)
  store i8 0, ptr %dead, align 1
  br label %if.end21

if.end21:                                         ; preds = %if.then20, %land.lhs.true, %if.end
  %30 = load ptr, ptr %label, align 8
  %branches = getelementptr inbounds %struct.TCGLabel, ptr %30, i32 0, i32 4
  %sqh_first = getelementptr inbounds %struct.anon, ptr %branches, i32 0, i32 0
  %31 = load ptr, ptr %sqh_first, align 8
  %cmp22 = icmp eq ptr %31, null
  br i1 %cmp22, label %if.then23, label %if.else

if.then23:                                        ; preds = %if.end21
  store i8 1, ptr %remove, align 1
  br label %if.end24

if.else:                                          ; preds = %if.end21
  store i8 0, ptr %dead, align 1
  store i8 0, ptr %remove, align 1
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.then23
  br label %sw.epilog

sw.bb25:                                          ; preds = %for.body, %for.body, %for.body
  store i8 1, ptr %dead, align 1
  br label %sw.epilog

sw.bb26:                                          ; preds = %for.body
  %32 = load ptr, ptr %op, align 8
  %call27 = call i32 @tcg_call_flags(ptr noundef %32)
  %and = and i32 %call27, 8
  %tobool28 = icmp ne i32 %and, 0
  br i1 %tobool28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %sw.bb26
  store i8 1, ptr %dead, align 1
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %sw.bb26
  br label %sw.epilog

sw.bb31:                                          ; preds = %for.body
  store i8 0, ptr %remove, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb31, %if.end30, %sw.bb25, %if.end24
  %33 = load i8, ptr %remove, align 1
  %tobool32 = trunc i8 %33 to i1
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %sw.epilog
  %34 = load ptr, ptr %s.addr, align 8
  %35 = load ptr, ptr %op, align 8
  call void @tcg_op_remove(ptr noundef %34, ptr noundef %35)
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %sw.epilog
  br label %for.inc

for.inc:                                          ; preds = %if.end34
  %36 = load ptr, ptr %op_next, align 8
  store ptr %36, ptr %op, align 8
  br label %for.cond, !llvm.loop !38

for.end:                                          ; preds = %land.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @liveness_pass_0(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %multiple_ebb = alloca ptr, align 8
  %nb_temps = alloca i32, align 4
  %op = alloca ptr, align 8
  %ebb = alloca ptr, align 8
  %i = alloca i32, align 4
  %def = alloca ptr, align 8
  %nb_oargs = alloca i32, align 4
  %nb_iargs = alloca i32, align 4
  %i18 = alloca i32, align 4
  %ts = alloca ptr, align 8
  %i47 = alloca i32, align 4
  %ts53 = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr inttoptr (i64 -1 to ptr), ptr %multiple_ebb, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %nb_temps1 = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %nb_temps1, align 8
  store i32 %1, ptr %nb_temps, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %nb_globals = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %nb_globals, align 4
  store i32 %3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, ptr %i, align 4
  %5 = load i32, ptr %nb_temps, align 4
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %6, i32 0, i32 37
  %7 = load i32, ptr %i, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  %state_ptr = getelementptr inbounds %struct.TCGTemp, ptr %arrayidx, i32 0, i32 6
  store ptr null, ptr %state_ptr, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, ptr %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !39

for.end:                                          ; preds = %for.cond
  %9 = load ptr, ptr %s.addr, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 38
  %10 = load ptr, ptr %ops, align 8
  store ptr %10, ptr %ebb, align 8
  %11 = load ptr, ptr %s.addr, align 8
  %ops2 = getelementptr inbounds %struct.TCGContext, ptr %11, i32 0, i32 38
  %12 = load ptr, ptr %ops2, align 8
  store ptr %12, ptr %op, align 8
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc45, %for.end
  %13 = load ptr, ptr %op, align 8
  %tobool = icmp ne ptr %13, null
  br i1 %tobool, label %for.body4, label %for.end46

for.body4:                                        ; preds = %for.cond3
  %14 = load ptr, ptr %op, align 8
  %bf.load = load i32, ptr %14, align 8
  %bf.clear = and i32 %bf.load, 255
  switch i32 %bf.clear, label %sw.default [
    i32 1, label %sw.bb
    i32 0, label %sw.bb5
    i32 2, label %sw.bb6
  ]

sw.bb:                                            ; preds = %for.body4
  %15 = load ptr, ptr %op, align 8
  store ptr %15, ptr %ebb, align 8
  br label %for.inc45

sw.bb5:                                           ; preds = %for.body4
  br label %for.inc45

sw.bb6:                                           ; preds = %for.body4
  %16 = load ptr, ptr %op, align 8
  %bf.load7 = load i32, ptr %16, align 8
  %bf.lshr = lshr i32 %bf.load7, 24
  store i32 %bf.lshr, ptr %nb_oargs, align 4
  %17 = load ptr, ptr %op, align 8
  %bf.load8 = load i32, ptr %17, align 8
  %bf.lshr9 = lshr i32 %bf.load8, 16
  %bf.clear10 = and i32 %bf.lshr9, 255
  store i32 %bf.clear10, ptr %nb_iargs, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %for.body4
  %18 = load ptr, ptr %op, align 8
  %bf.load11 = load i32, ptr %18, align 8
  %bf.clear12 = and i32 %bf.load11, 255
  %idxprom13 = zext i32 %bf.clear12 to i64
  %arrayidx14 = getelementptr [0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 %idxprom13
  store ptr %arrayidx14, ptr %def, align 8
  %19 = load ptr, ptr %def, align 8
  %nb_oargs15 = getelementptr inbounds %struct.TCGOpDef, ptr %19, i32 0, i32 1
  %20 = load i8, ptr %nb_oargs15, align 8
  %conv = zext i8 %20 to i32
  store i32 %conv, ptr %nb_oargs, align 4
  %21 = load ptr, ptr %def, align 8
  %nb_iargs16 = getelementptr inbounds %struct.TCGOpDef, ptr %21, i32 0, i32 2
  %22 = load i8, ptr %nb_iargs16, align 1
  %conv17 = zext i8 %22 to i32
  store i32 %conv17, ptr %nb_iargs, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6
  store i32 0, ptr %i18, align 4
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc42, %sw.epilog
  %23 = load i32, ptr %i18, align 4
  %24 = load i32, ptr %nb_oargs, align 4
  %25 = load i32, ptr %nb_iargs, align 4
  %add = add i32 %24, %25
  %cmp20 = icmp slt i32 %23, %add
  br i1 %cmp20, label %for.body22, label %for.end44

for.body22:                                       ; preds = %for.cond19
  %26 = load ptr, ptr %op, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %26, i32 0, i32 4
  %27 = load i32, ptr %i18, align 4
  %idxprom23 = sext i32 %27 to i64
  %arrayidx24 = getelementptr [0 x i64], ptr %args, i64 0, i64 %idxprom23
  %28 = load i64, ptr %arrayidx24, align 8
  %call = call ptr @arg_temp(i64 noundef %28)
  store ptr %call, ptr %ts, align 8
  %29 = load ptr, ptr %ts, align 8
  %bf.load25 = load i64, ptr %29, align 8
  %bf.lshr26 = lshr i64 %bf.load25, 32
  %bf.clear27 = and i64 %bf.lshr26, 7
  %bf.cast = trunc i64 %bf.clear27 to i32
  %cmp28 = icmp ne i32 %bf.cast, 1
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %for.body22
  br label %for.inc42

if.end:                                           ; preds = %for.body22
  %30 = load ptr, ptr %ts, align 8
  %state_ptr30 = getelementptr inbounds %struct.TCGTemp, ptr %30, i32 0, i32 6
  %31 = load ptr, ptr %state_ptr30, align 8
  %cmp31 = icmp eq ptr %31, null
  br i1 %cmp31, label %if.then33, label %if.else

if.then33:                                        ; preds = %if.end
  %32 = load ptr, ptr %ebb, align 8
  %33 = load ptr, ptr %ts, align 8
  %state_ptr34 = getelementptr inbounds %struct.TCGTemp, ptr %33, i32 0, i32 6
  store ptr %32, ptr %state_ptr34, align 8
  br label %if.end41

if.else:                                          ; preds = %if.end
  %34 = load ptr, ptr %ts, align 8
  %state_ptr35 = getelementptr inbounds %struct.TCGTemp, ptr %34, i32 0, i32 6
  %35 = load ptr, ptr %state_ptr35, align 8
  %36 = load ptr, ptr %ebb, align 8
  %cmp36 = icmp ne ptr %35, %36
  br i1 %cmp36, label %if.then38, label %if.end40

if.then38:                                        ; preds = %if.else
  %37 = load ptr, ptr %ts, align 8
  %state_ptr39 = getelementptr inbounds %struct.TCGTemp, ptr %37, i32 0, i32 6
  store ptr inttoptr (i64 -1 to ptr), ptr %state_ptr39, align 8
  br label %if.end40

if.end40:                                         ; preds = %if.then38, %if.else
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then33
  br label %for.inc42

for.inc42:                                        ; preds = %if.end41, %if.then
  %38 = load i32, ptr %i18, align 4
  %inc43 = add i32 %38, 1
  store i32 %inc43, ptr %i18, align 4
  br label %for.cond19, !llvm.loop !40

for.end44:                                        ; preds = %for.cond19
  br label %for.inc45

for.inc45:                                        ; preds = %for.end44, %sw.bb5, %sw.bb
  %39 = load ptr, ptr %op, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %39, i32 0, i32 2
  %40 = load ptr, ptr %link, align 8
  store ptr %40, ptr %op, align 8
  br label %for.cond3, !llvm.loop !41

for.end46:                                        ; preds = %for.cond3
  %41 = load ptr, ptr %s.addr, align 8
  %nb_globals48 = getelementptr inbounds %struct.TCGContext, ptr %41, i32 0, i32 6
  %42 = load i32, ptr %nb_globals48, align 4
  store i32 %42, ptr %i47, align 4
  br label %for.cond49

for.cond49:                                       ; preds = %for.inc70, %for.end46
  %43 = load i32, ptr %i47, align 4
  %44 = load i32, ptr %nb_temps, align 4
  %cmp50 = icmp slt i32 %43, %44
  br i1 %cmp50, label %for.body52, label %for.end72

for.body52:                                       ; preds = %for.cond49
  %45 = load ptr, ptr %s.addr, align 8
  %temps54 = getelementptr inbounds %struct.TCGContext, ptr %45, i32 0, i32 37
  %46 = load i32, ptr %i47, align 4
  %idxprom55 = sext i32 %46 to i64
  %arrayidx56 = getelementptr [512 x %struct.TCGTemp], ptr %temps54, i64 0, i64 %idxprom55
  store ptr %arrayidx56, ptr %ts53, align 8
  %47 = load ptr, ptr %ts53, align 8
  %bf.load57 = load i64, ptr %47, align 8
  %bf.lshr58 = lshr i64 %bf.load57, 32
  %bf.clear59 = and i64 %bf.lshr58, 7
  %bf.cast60 = trunc i64 %bf.clear59 to i32
  %cmp61 = icmp eq i32 %bf.cast60, 1
  br i1 %cmp61, label %land.lhs.true, label %if.end69

land.lhs.true:                                    ; preds = %for.body52
  %48 = load ptr, ptr %ts53, align 8
  %state_ptr63 = getelementptr inbounds %struct.TCGTemp, ptr %48, i32 0, i32 6
  %49 = load ptr, ptr %state_ptr63, align 8
  %cmp64 = icmp ne ptr %49, inttoptr (i64 -1 to ptr)
  br i1 %cmp64, label %if.then66, label %if.end69

if.then66:                                        ; preds = %land.lhs.true
  %50 = load ptr, ptr %ts53, align 8
  %bf.load67 = load i64, ptr %50, align 8
  %bf.clear68 = and i64 %bf.load67, -30064771073
  %bf.set = or i64 %bf.clear68, 0
  store i64 %bf.set, ptr %50, align 8
  br label %if.end69

if.end69:                                         ; preds = %if.then66, %land.lhs.true, %for.body52
  br label %for.inc70

for.inc70:                                        ; preds = %if.end69
  %51 = load i32, ptr %i47, align 4
  %inc71 = add i32 %51, 1
  store i32 %inc71, ptr %i47, align 4
  br label %for.cond49, !llvm.loop !42

for.end72:                                        ; preds = %for.cond49
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @liveness_pass_1(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %nb_globals = alloca i32, align 4
  %nb_temps = alloca i32, align 4
  %op = alloca ptr, align 8
  %op_prev = alloca ptr, align 8
  %prefs = alloca ptr, align 8
  %i = alloca i32, align 4
  %nb_iargs = alloca i32, align 4
  %nb_oargs = alloca i32, align 4
  %opc_new = alloca i32, align 4
  %opc_new2 = alloca i32, align 4
  %have_opc_new2 = alloca i8, align 1
  %arg_life = alloca i32, align 4
  %ts = alloca ptr, align 8
  %opc = alloca i32, align 4
  %def = alloca ptr, align 8
  %info = alloca ptr, align 8
  %call_flags = alloca i32, align 4
  %loc = alloca ptr, align 8
  %loc124 = alloca ptr, align 8
  %ct = alloca ptr, align 8
  %set = alloca i32, align 4
  %pset = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %nb_globals1 = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %nb_globals1, align 4
  store i32 %1, ptr %nb_globals, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %nb_temps2 = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 7
  %3 = load i32, ptr %nb_temps2, align 8
  store i32 %3, ptr %nb_temps, align 4
  %4 = load i32, ptr %nb_temps, align 4
  %conv = sext i32 %4 to i64
  %mul = mul i64 4, %conv
  %conv3 = trunc i64 %mul to i32
  %call = call ptr @tcg_malloc(i32 noundef %conv3)
  store ptr %call, ptr %prefs, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, ptr %i, align 4
  %6 = load i32, ptr %nb_temps, align 4
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %prefs, align 8
  %8 = load i32, ptr %i, align 4
  %idx.ext = sext i32 %8 to i64
  %add.ptr = getelementptr i32, ptr %7, i64 %idx.ext
  %9 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 37
  %10 = load i32, ptr %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  %state_ptr = getelementptr inbounds %struct.TCGTemp, ptr %arrayidx, i32 0, i32 6
  store ptr %add.ptr, ptr %state_ptr, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, ptr %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !43

for.end:                                          ; preds = %for.cond
  %12 = load ptr, ptr %s.addr, align 8
  %13 = load i32, ptr %nb_globals, align 4
  %14 = load i32, ptr %nb_temps, align 4
  call void @la_func_end(ptr noundef %12, i32 noundef %13, i32 noundef %14)
  %15 = load ptr, ptr %s.addr, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %15, i32 0, i32 38
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %ops, i32 0, i32 1
  %16 = load ptr, ptr %tql_prev, align 8
  %tql_prev5 = getelementptr inbounds %struct.QTailQLink, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %tql_prev5, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %17, i32 0, i32 0
  %18 = load ptr, ptr %tql_next, align 8
  store ptr %18, ptr %op, align 8
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc442, %for.end
  %19 = load ptr, ptr %op, align 8
  %tobool = icmp ne ptr %19, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond6
  %20 = load ptr, ptr %op, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %20, i32 0, i32 2
  %tql_prev7 = getelementptr inbounds %struct.QTailQLink, ptr %link, i32 0, i32 1
  %21 = load ptr, ptr %tql_prev7, align 8
  %tql_prev8 = getelementptr inbounds %struct.QTailQLink, ptr %21, i32 0, i32 1
  %22 = load ptr, ptr %tql_prev8, align 8
  %tql_next9 = getelementptr inbounds %struct.QTailQLink, ptr %22, i32 0, i32 0
  %23 = load ptr, ptr %tql_next9, align 8
  store ptr %23, ptr %op_prev, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond6
  %24 = phi i1 [ false, %for.cond6 ], [ true, %land.rhs ]
  br i1 %24, label %for.body10, label %for.end443

for.body10:                                       ; preds = %land.end
  store i32 0, ptr %arg_life, align 4
  %25 = load ptr, ptr %op, align 8
  %bf.load = load i32, ptr %25, align 8
  %bf.clear = and i32 %bf.load, 255
  store i32 %bf.clear, ptr %opc, align 4
  %26 = load i32, ptr %opc, align 4
  %idxprom11 = zext i32 %26 to i64
  %arrayidx12 = getelementptr [0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 %idxprom11
  store ptr %arrayidx12, ptr %def, align 8
  %27 = load i32, ptr %opc, align 4
  switch i32 %27, label %sw.default251 [
    i32 2, label %sw.bb
    i32 129, label %sw.bb155
    i32 0, label %sw.bb156
    i32 39, label %sw.bb161
    i32 40, label %sw.bb162
    i32 123, label %sw.bb163
    i32 124, label %sw.bb164
    i32 41, label %sw.bb191
    i32 42, label %sw.bb192
    i32 125, label %sw.bb193
    i32 126, label %sw.bb194
  ]

sw.bb:                                            ; preds = %for.body10
  %28 = load ptr, ptr %op, align 8
  %call13 = call ptr @tcg_call_info(ptr noundef %28)
  store ptr %call13, ptr %info, align 8
  %29 = load ptr, ptr %op, align 8
  %call14 = call i32 @tcg_call_flags(ptr noundef %29)
  store i32 %call14, ptr %call_flags, align 4
  %30 = load ptr, ptr %op, align 8
  %bf.load15 = load i32, ptr %30, align 8
  %bf.lshr = lshr i32 %bf.load15, 24
  store i32 %bf.lshr, ptr %nb_oargs, align 4
  %31 = load ptr, ptr %op, align 8
  %bf.load16 = load i32, ptr %31, align 8
  %bf.lshr17 = lshr i32 %bf.load16, 16
  %bf.clear18 = and i32 %bf.lshr17, 255
  store i32 %bf.clear18, ptr %nb_iargs, align 4
  %32 = load i32, ptr %call_flags, align 4
  %and = and i32 %32, 4
  %tobool19 = icmp ne i32 %and, 0
  br i1 %tobool19, label %if.then, label %if.end33

if.then:                                          ; preds = %sw.bb
  store i32 0, ptr %i, align 4
  br label %for.cond20

for.cond20:                                       ; preds = %for.inc30, %if.then
  %33 = load i32, ptr %i, align 4
  %34 = load i32, ptr %nb_oargs, align 4
  %cmp21 = icmp slt i32 %33, %34
  br i1 %cmp21, label %for.body23, label %for.end32

for.body23:                                       ; preds = %for.cond20
  %35 = load ptr, ptr %op, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %35, i32 0, i32 4
  %36 = load i32, ptr %i, align 4
  %idxprom24 = sext i32 %36 to i64
  %arrayidx25 = getelementptr [0 x i64], ptr %args, i64 0, i64 %idxprom24
  %37 = load i64, ptr %arrayidx25, align 8
  %call26 = call ptr @arg_temp(i64 noundef %37)
  store ptr %call26, ptr %ts, align 8
  %38 = load ptr, ptr %ts, align 8
  %state = getelementptr inbounds %struct.TCGTemp, ptr %38, i32 0, i32 5
  %39 = load i64, ptr %state, align 8
  %cmp27 = icmp ne i64 %39, 1
  br i1 %cmp27, label %if.then29, label %if.end

if.then29:                                        ; preds = %for.body23
  br label %do_not_remove_call

if.end:                                           ; preds = %for.body23
  br label %for.inc30

for.inc30:                                        ; preds = %if.end
  %40 = load i32, ptr %i, align 4
  %inc31 = add i32 %40, 1
  store i32 %inc31, ptr %i, align 4
  br label %for.cond20, !llvm.loop !44

for.end32:                                        ; preds = %for.cond20
  br label %do_remove

if.end33:                                         ; preds = %sw.bb
  br label %do_not_remove_call

do_not_remove_call:                               ; preds = %if.end33, %if.then29
  store i32 0, ptr %i, align 4
  br label %for.cond34

for.cond34:                                       ; preds = %for.inc55, %do_not_remove_call
  %41 = load i32, ptr %i, align 4
  %42 = load i32, ptr %nb_oargs, align 4
  %cmp35 = icmp slt i32 %41, %42
  br i1 %cmp35, label %for.body37, label %for.end57

for.body37:                                       ; preds = %for.cond34
  %43 = load ptr, ptr %op, align 8
  %args38 = getelementptr inbounds %struct.TCGOp, ptr %43, i32 0, i32 4
  %44 = load i32, ptr %i, align 4
  %idxprom39 = sext i32 %44 to i64
  %arrayidx40 = getelementptr [0 x i64], ptr %args38, i64 0, i64 %idxprom39
  %45 = load i64, ptr %arrayidx40, align 8
  %call41 = call ptr @arg_temp(i64 noundef %45)
  store ptr %call41, ptr %ts, align 8
  %46 = load ptr, ptr %ts, align 8
  %state42 = getelementptr inbounds %struct.TCGTemp, ptr %46, i32 0, i32 5
  %47 = load i64, ptr %state42, align 8
  %and43 = and i64 %47, 1
  %tobool44 = icmp ne i64 %and43, 0
  br i1 %tobool44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %for.body37
  %48 = load i32, ptr %i, align 4
  %shl = shl i32 16, %48
  %49 = load i32, ptr %arg_life, align 4
  %or = or i32 %49, %shl
  store i32 %or, ptr %arg_life, align 4
  br label %if.end46

if.end46:                                         ; preds = %if.then45, %for.body37
  %50 = load ptr, ptr %ts, align 8
  %state47 = getelementptr inbounds %struct.TCGTemp, ptr %50, i32 0, i32 5
  %51 = load i64, ptr %state47, align 8
  %and48 = and i64 %51, 2
  %tobool49 = icmp ne i64 %and48, 0
  br i1 %tobool49, label %if.then50, label %if.end53

if.then50:                                        ; preds = %if.end46
  %52 = load i32, ptr %i, align 4
  %shl51 = shl i32 1, %52
  %53 = load i32, ptr %arg_life, align 4
  %or52 = or i32 %53, %shl51
  store i32 %or52, ptr %arg_life, align 4
  br label %if.end53

if.end53:                                         ; preds = %if.then50, %if.end46
  %54 = load ptr, ptr %ts, align 8
  %state54 = getelementptr inbounds %struct.TCGTemp, ptr %54, i32 0, i32 5
  store i64 1, ptr %state54, align 8
  %55 = load ptr, ptr %ts, align 8
  call void @la_reset_pref(ptr noundef %55)
  br label %for.inc55

for.inc55:                                        ; preds = %if.end53
  %56 = load i32, ptr %i, align 4
  %inc56 = add i32 %56, 1
  store i32 %inc56, ptr %i, align 4
  br label %for.cond34, !llvm.loop !45

for.end57:                                        ; preds = %for.cond34
  %57 = load ptr, ptr %op, align 8
  %output_pref = getelementptr inbounds %struct.TCGOp, ptr %57, i32 0, i32 3
  %arraydecay = getelementptr inbounds [2 x i32], ptr %output_pref, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay, i8 0, i64 8, i1 false)
  %58 = load i32, ptr %call_flags, align 4
  %and58 = and i32 %58, 3
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.else, label %if.then60

if.then60:                                        ; preds = %for.end57
  %59 = load ptr, ptr %s.addr, align 8
  %60 = load i32, ptr %nb_globals, align 4
  call void @la_global_kill(ptr noundef %59, i32 noundef %60)
  br label %if.end65

if.else:                                          ; preds = %for.end57
  %61 = load i32, ptr %call_flags, align 4
  %and61 = and i32 %61, 1
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.end64, label %if.then63

if.then63:                                        ; preds = %if.else
  %62 = load ptr, ptr %s.addr, align 8
  %63 = load i32, ptr %nb_globals, align 4
  call void @la_global_sync(ptr noundef %62, i32 noundef %63)
  br label %if.end64

if.end64:                                         ; preds = %if.then63, %if.else
  br label %if.end65

if.end65:                                         ; preds = %if.end64, %if.then60
  %64 = load i32, ptr %nb_oargs, align 4
  store i32 %64, ptr %i, align 4
  br label %for.cond66

for.cond66:                                       ; preds = %for.inc81, %if.end65
  %65 = load i32, ptr %i, align 4
  %66 = load i32, ptr %nb_iargs, align 4
  %67 = load i32, ptr %nb_oargs, align 4
  %add = add i32 %66, %67
  %cmp67 = icmp slt i32 %65, %add
  br i1 %cmp67, label %for.body69, label %for.end83

for.body69:                                       ; preds = %for.cond66
  %68 = load ptr, ptr %op, align 8
  %args70 = getelementptr inbounds %struct.TCGOp, ptr %68, i32 0, i32 4
  %69 = load i32, ptr %i, align 4
  %idxprom71 = sext i32 %69 to i64
  %arrayidx72 = getelementptr [0 x i64], ptr %args70, i64 0, i64 %idxprom71
  %70 = load i64, ptr %arrayidx72, align 8
  %call73 = call ptr @arg_temp(i64 noundef %70)
  store ptr %call73, ptr %ts, align 8
  %71 = load ptr, ptr %ts, align 8
  %state74 = getelementptr inbounds %struct.TCGTemp, ptr %71, i32 0, i32 5
  %72 = load i64, ptr %state74, align 8
  %and75 = and i64 %72, 1
  %tobool76 = icmp ne i64 %and75, 0
  br i1 %tobool76, label %if.then77, label %if.end80

if.then77:                                        ; preds = %for.body69
  %73 = load i32, ptr %i, align 4
  %shl78 = shl i32 16, %73
  %74 = load i32, ptr %arg_life, align 4
  %or79 = or i32 %74, %shl78
  store i32 %or79, ptr %arg_life, align 4
  br label %if.end80

if.end80:                                         ; preds = %if.then77, %for.body69
  br label %for.inc81

for.inc81:                                        ; preds = %if.end80
  %75 = load i32, ptr %i, align 4
  %inc82 = add i32 %75, 1
  store i32 %inc82, ptr %i, align 4
  br label %for.cond66, !llvm.loop !46

for.end83:                                        ; preds = %for.cond66
  %76 = load ptr, ptr %s.addr, align 8
  %77 = load i32, ptr %nb_temps, align 4
  call void @la_cross_call(ptr noundef %76, i32 noundef %77)
  %78 = load i32, ptr %nb_iargs, align 4
  %sub = sub i32 %78, 1
  store i32 %sub, ptr %i, align 4
  br label %for.cond84

for.cond84:                                       ; preds = %for.inc118, %for.end83
  %79 = load i32, ptr %i, align 4
  %cmp85 = icmp sge i32 %79, 0
  br i1 %cmp85, label %for.body87, label %for.end119

for.body87:                                       ; preds = %for.cond84
  %80 = load ptr, ptr %info, align 8
  %in = getelementptr inbounds %struct.TCGHelperInfo, ptr %80, i32 0, i32 4
  %81 = load i32, ptr %i, align 4
  %idxprom88 = sext i32 %81 to i64
  %arrayidx89 = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in, i64 0, i64 %idxprom88
  store ptr %arrayidx89, ptr %loc, align 8
  %82 = load ptr, ptr %op, align 8
  %args90 = getelementptr inbounds %struct.TCGOp, ptr %82, i32 0, i32 4
  %83 = load i32, ptr %nb_oargs, align 4
  %84 = load i32, ptr %i, align 4
  %add91 = add i32 %83, %84
  %idxprom92 = sext i32 %add91 to i64
  %arrayidx93 = getelementptr [0 x i64], ptr %args90, i64 0, i64 %idxprom92
  %85 = load i64, ptr %arrayidx93, align 8
  %call94 = call ptr @arg_temp(i64 noundef %85)
  store ptr %call94, ptr %ts, align 8
  %86 = load ptr, ptr %ts, align 8
  %state95 = getelementptr inbounds %struct.TCGTemp, ptr %86, i32 0, i32 5
  %87 = load i64, ptr %state95, align 8
  %and96 = and i64 %87, 1
  %tobool97 = icmp ne i64 %and96, 0
  br i1 %tobool97, label %if.then98, label %if.end117

if.then98:                                        ; preds = %for.body87
  %88 = load ptr, ptr %loc, align 8
  %bf.load99 = load i32, ptr %88, align 4
  %bf.clear100 = and i32 %bf.load99, 255
  switch i32 %bf.clear100, label %sw.default [
    i32 0, label %sw.bb101
    i32 3, label %sw.bb101
    i32 4, label %sw.bb101
  ]

sw.bb101:                                         ; preds = %if.then98, %if.then98, %if.then98
  %89 = load ptr, ptr %loc, align 8
  %bf.load102 = load i32, ptr %89, align 4
  %bf.lshr103 = lshr i32 %bf.load102, 8
  %bf.clear104 = and i32 %bf.lshr103, 255
  %call105 = call zeroext i1 @arg_slot_reg_p(i32 noundef %bf.clear104)
  br i1 %call105, label %if.then106, label %if.end108

if.then106:                                       ; preds = %sw.bb101
  %90 = load ptr, ptr %ts, align 8
  %call107 = call ptr @la_temp_pref(ptr noundef %90)
  store i32 0, ptr %call107, align 4
  br label %sw.epilog

if.end108:                                        ; preds = %sw.bb101
  br label %sw.default

sw.default:                                       ; preds = %if.end108, %if.then98
  %91 = load ptr, ptr %ts, align 8
  %bf.load109 = load i64, ptr %91, align 8
  %bf.lshr110 = lshr i64 %bf.load109, 24
  %bf.clear111 = and i64 %bf.lshr110, 255
  %bf.cast = trunc i64 %bf.clear111 to i32
  %idxprom112 = zext i32 %bf.cast to i64
  %arrayidx113 = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom112
  %92 = load i32, ptr %arrayidx113, align 4
  %93 = load ptr, ptr %ts, align 8
  %call114 = call ptr @la_temp_pref(ptr noundef %93)
  store i32 %92, ptr %call114, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.then106
  %94 = load ptr, ptr %ts, align 8
  %state115 = getelementptr inbounds %struct.TCGTemp, ptr %94, i32 0, i32 5
  %95 = load i64, ptr %state115, align 8
  %and116 = and i64 %95, -2
  store i64 %and116, ptr %state115, align 8
  br label %if.end117

if.end117:                                        ; preds = %sw.epilog, %for.body87
  br label %for.inc118

for.inc118:                                       ; preds = %if.end117
  %96 = load i32, ptr %i, align 4
  %dec = add i32 %96, -1
  store i32 %dec, ptr %i, align 4
  br label %for.cond84, !llvm.loop !47

for.end119:                                       ; preds = %for.cond84
  store i32 0, ptr %i, align 4
  br label %for.cond120

for.cond120:                                      ; preds = %for.inc152, %for.end119
  %97 = load i32, ptr %i, align 4
  %98 = load i32, ptr %nb_iargs, align 4
  %cmp121 = icmp slt i32 %97, %98
  br i1 %cmp121, label %for.body123, label %for.end154

for.body123:                                      ; preds = %for.cond120
  %99 = load ptr, ptr %info, align 8
  %in125 = getelementptr inbounds %struct.TCGHelperInfo, ptr %99, i32 0, i32 4
  %100 = load i32, ptr %i, align 4
  %idxprom126 = sext i32 %100 to i64
  %arrayidx127 = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in125, i64 0, i64 %idxprom126
  store ptr %arrayidx127, ptr %loc124, align 8
  %101 = load ptr, ptr %op, align 8
  %args128 = getelementptr inbounds %struct.TCGOp, ptr %101, i32 0, i32 4
  %102 = load i32, ptr %nb_oargs, align 4
  %103 = load i32, ptr %i, align 4
  %add129 = add i32 %102, %103
  %idxprom130 = sext i32 %add129 to i64
  %arrayidx131 = getelementptr [0 x i64], ptr %args128, i64 0, i64 %idxprom130
  %104 = load i64, ptr %arrayidx131, align 8
  %call132 = call ptr @arg_temp(i64 noundef %104)
  store ptr %call132, ptr %ts, align 8
  %105 = load ptr, ptr %loc124, align 8
  %bf.load133 = load i32, ptr %105, align 4
  %bf.clear134 = and i32 %bf.load133, 255
  switch i32 %bf.clear134, label %sw.default150 [
    i32 0, label %sw.bb135
    i32 3, label %sw.bb135
    i32 4, label %sw.bb135
  ]

sw.bb135:                                         ; preds = %for.body123, %for.body123, %for.body123
  %106 = load ptr, ptr %loc124, align 8
  %bf.load136 = load i32, ptr %106, align 4
  %bf.lshr137 = lshr i32 %bf.load136, 8
  %bf.clear138 = and i32 %bf.lshr137, 255
  %call139 = call zeroext i1 @arg_slot_reg_p(i32 noundef %bf.clear138)
  br i1 %call139, label %if.then140, label %if.end149

if.then140:                                       ; preds = %sw.bb135
  %107 = load ptr, ptr %loc124, align 8
  %bf.load141 = load i32, ptr %107, align 4
  %bf.lshr142 = lshr i32 %bf.load141, 8
  %bf.clear143 = and i32 %bf.lshr142, 255
  %idxprom144 = zext i32 %bf.clear143 to i64
  %arrayidx145 = getelementptr [6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 %idxprom144
  %108 = load i32, ptr %arrayidx145, align 4
  %shl146 = shl i32 1, %108
  %109 = load ptr, ptr %ts, align 8
  %call147 = call ptr @la_temp_pref(ptr noundef %109)
  %110 = load i32, ptr %call147, align 4
  %or148 = or i32 %110, %shl146
  store i32 %or148, ptr %call147, align 4
  br label %if.end149

if.end149:                                        ; preds = %if.then140, %sw.bb135
  br label %sw.epilog151

sw.default150:                                    ; preds = %for.body123
  br label %sw.epilog151

sw.epilog151:                                     ; preds = %sw.default150, %if.end149
  br label %for.inc152

for.inc152:                                       ; preds = %sw.epilog151
  %111 = load i32, ptr %i, align 4
  %inc153 = add i32 %111, 1
  store i32 %inc153, ptr %i, align 4
  br label %for.cond120, !llvm.loop !48

for.end154:                                       ; preds = %for.cond120
  br label %sw.epilog441

sw.bb155:                                         ; preds = %for.body10
  br label %sw.epilog441

sw.bb156:                                         ; preds = %for.body10
  %112 = load ptr, ptr %op, align 8
  %args157 = getelementptr inbounds %struct.TCGOp, ptr %112, i32 0, i32 4
  %arrayidx158 = getelementptr [0 x i64], ptr %args157, i64 0, i64 0
  %113 = load i64, ptr %arrayidx158, align 8
  %call159 = call ptr @arg_temp(i64 noundef %113)
  store ptr %call159, ptr %ts, align 8
  %114 = load ptr, ptr %ts, align 8
  %state160 = getelementptr inbounds %struct.TCGTemp, ptr %114, i32 0, i32 5
  store i64 1, ptr %state160, align 8
  %115 = load ptr, ptr %ts, align 8
  call void @la_reset_pref(ptr noundef %115)
  br label %sw.epilog441

sw.bb161:                                         ; preds = %for.body10
  store i32 17, ptr %opc_new, align 4
  br label %do_addsub2

sw.bb162:                                         ; preds = %for.body10
  store i32 18, ptr %opc_new, align 4
  br label %do_addsub2

sw.bb163:                                         ; preds = %for.body10
  store i32 78, ptr %opc_new, align 4
  br label %do_addsub2

sw.bb164:                                         ; preds = %for.body10
  store i32 79, ptr %opc_new, align 4
  br label %do_addsub2

do_addsub2:                                       ; preds = %sw.bb164, %sw.bb163, %sw.bb162, %sw.bb161
  store i32 4, ptr %nb_iargs, align 4
  store i32 2, ptr %nb_oargs, align 4
  %116 = load ptr, ptr %op, align 8
  %args165 = getelementptr inbounds %struct.TCGOp, ptr %116, i32 0, i32 4
  %arrayidx166 = getelementptr [0 x i64], ptr %args165, i64 0, i64 1
  %117 = load i64, ptr %arrayidx166, align 8
  %call167 = call ptr @arg_temp(i64 noundef %117)
  %state168 = getelementptr inbounds %struct.TCGTemp, ptr %call167, i32 0, i32 5
  %118 = load i64, ptr %state168, align 8
  %cmp169 = icmp eq i64 %118, 1
  br i1 %cmp169, label %if.then171, label %if.end190

if.then171:                                       ; preds = %do_addsub2
  %119 = load ptr, ptr %op, align 8
  %args172 = getelementptr inbounds %struct.TCGOp, ptr %119, i32 0, i32 4
  %arrayidx173 = getelementptr [0 x i64], ptr %args172, i64 0, i64 0
  %120 = load i64, ptr %arrayidx173, align 8
  %call174 = call ptr @arg_temp(i64 noundef %120)
  %state175 = getelementptr inbounds %struct.TCGTemp, ptr %call174, i32 0, i32 5
  %121 = load i64, ptr %state175, align 8
  %cmp176 = icmp eq i64 %121, 1
  br i1 %cmp176, label %if.then178, label %if.end179

if.then178:                                       ; preds = %if.then171
  br label %do_remove

if.end179:                                        ; preds = %if.then171
  %122 = load i32, ptr %opc_new, align 4
  store i32 %122, ptr %opc, align 4
  %123 = load ptr, ptr %op, align 8
  %bf.load180 = load i32, ptr %123, align 8
  %bf.value = and i32 %122, 255
  %bf.clear181 = and i32 %bf.load180, -256
  %bf.set = or i32 %bf.clear181, %bf.value
  store i32 %bf.set, ptr %123, align 8
  %124 = load ptr, ptr %op, align 8
  %args182 = getelementptr inbounds %struct.TCGOp, ptr %124, i32 0, i32 4
  %arrayidx183 = getelementptr [0 x i64], ptr %args182, i64 0, i64 2
  %125 = load i64, ptr %arrayidx183, align 8
  %126 = load ptr, ptr %op, align 8
  %args184 = getelementptr inbounds %struct.TCGOp, ptr %126, i32 0, i32 4
  %arrayidx185 = getelementptr [0 x i64], ptr %args184, i64 0, i64 1
  store i64 %125, ptr %arrayidx185, align 8
  %127 = load ptr, ptr %op, align 8
  %args186 = getelementptr inbounds %struct.TCGOp, ptr %127, i32 0, i32 4
  %arrayidx187 = getelementptr [0 x i64], ptr %args186, i64 0, i64 4
  %128 = load i64, ptr %arrayidx187, align 8
  %129 = load ptr, ptr %op, align 8
  %args188 = getelementptr inbounds %struct.TCGOp, ptr %129, i32 0, i32 4
  %arrayidx189 = getelementptr [0 x i64], ptr %args188, i64 0, i64 2
  store i64 %128, ptr %arrayidx189, align 8
  store i32 2, ptr %nb_iargs, align 4
  store i32 1, ptr %nb_oargs, align 4
  br label %if.end190

if.end190:                                        ; preds = %if.end179, %do_addsub2
  br label %do_not_remove

sw.bb191:                                         ; preds = %for.body10
  store i32 19, ptr %opc_new, align 4
  store i32 43, ptr %opc_new2, align 4
  store i8 0, ptr %have_opc_new2, align 1
  br label %do_mul2

sw.bb192:                                         ; preds = %for.body10
  store i32 19, ptr %opc_new, align 4
  store i32 44, ptr %opc_new2, align 4
  store i8 0, ptr %have_opc_new2, align 1
  br label %do_mul2

sw.bb193:                                         ; preds = %for.body10
  store i32 80, ptr %opc_new, align 4
  store i32 127, ptr %opc_new2, align 4
  store i8 0, ptr %have_opc_new2, align 1
  br label %do_mul2

sw.bb194:                                         ; preds = %for.body10
  store i32 80, ptr %opc_new, align 4
  store i32 128, ptr %opc_new2, align 4
  store i8 0, ptr %have_opc_new2, align 1
  br label %do_mul2

do_mul2:                                          ; preds = %sw.bb194, %sw.bb193, %sw.bb192, %sw.bb191
  store i32 2, ptr %nb_iargs, align 4
  store i32 2, ptr %nb_oargs, align 4
  %130 = load ptr, ptr %op, align 8
  %args195 = getelementptr inbounds %struct.TCGOp, ptr %130, i32 0, i32 4
  %arrayidx196 = getelementptr [0 x i64], ptr %args195, i64 0, i64 1
  %131 = load i64, ptr %arrayidx196, align 8
  %call197 = call ptr @arg_temp(i64 noundef %131)
  %state198 = getelementptr inbounds %struct.TCGTemp, ptr %call197, i32 0, i32 5
  %132 = load i64, ptr %state198, align 8
  %cmp199 = icmp eq i64 %132, 1
  br i1 %cmp199, label %if.then201, label %if.else222

if.then201:                                       ; preds = %do_mul2
  %133 = load ptr, ptr %op, align 8
  %args202 = getelementptr inbounds %struct.TCGOp, ptr %133, i32 0, i32 4
  %arrayidx203 = getelementptr [0 x i64], ptr %args202, i64 0, i64 0
  %134 = load i64, ptr %arrayidx203, align 8
  %call204 = call ptr @arg_temp(i64 noundef %134)
  %state205 = getelementptr inbounds %struct.TCGTemp, ptr %call204, i32 0, i32 5
  %135 = load i64, ptr %state205, align 8
  %cmp206 = icmp eq i64 %135, 1
  br i1 %cmp206, label %if.then208, label %if.end209

if.then208:                                       ; preds = %if.then201
  br label %do_remove

if.end209:                                        ; preds = %if.then201
  %136 = load i32, ptr %opc_new, align 4
  store i32 %136, ptr %opc, align 4
  %137 = load ptr, ptr %op, align 8
  %bf.load210 = load i32, ptr %137, align 8
  %bf.value211 = and i32 %136, 255
  %bf.clear212 = and i32 %bf.load210, -256
  %bf.set213 = or i32 %bf.clear212, %bf.value211
  store i32 %bf.set213, ptr %137, align 8
  %138 = load ptr, ptr %op, align 8
  %args214 = getelementptr inbounds %struct.TCGOp, ptr %138, i32 0, i32 4
  %arrayidx215 = getelementptr [0 x i64], ptr %args214, i64 0, i64 2
  %139 = load i64, ptr %arrayidx215, align 8
  %140 = load ptr, ptr %op, align 8
  %args216 = getelementptr inbounds %struct.TCGOp, ptr %140, i32 0, i32 4
  %arrayidx217 = getelementptr [0 x i64], ptr %args216, i64 0, i64 1
  store i64 %139, ptr %arrayidx217, align 8
  %141 = load ptr, ptr %op, align 8
  %args218 = getelementptr inbounds %struct.TCGOp, ptr %141, i32 0, i32 4
  %arrayidx219 = getelementptr [0 x i64], ptr %args218, i64 0, i64 3
  %142 = load i64, ptr %arrayidx219, align 8
  %143 = load ptr, ptr %op, align 8
  %args220 = getelementptr inbounds %struct.TCGOp, ptr %143, i32 0, i32 4
  %arrayidx221 = getelementptr [0 x i64], ptr %args220, i64 0, i64 2
  store i64 %142, ptr %arrayidx221, align 8
  br label %if.end250

if.else222:                                       ; preds = %do_mul2
  %144 = load ptr, ptr %op, align 8
  %args223 = getelementptr inbounds %struct.TCGOp, ptr %144, i32 0, i32 4
  %arrayidx224 = getelementptr [0 x i64], ptr %args223, i64 0, i64 0
  %145 = load i64, ptr %arrayidx224, align 8
  %call225 = call ptr @arg_temp(i64 noundef %145)
  %state226 = getelementptr inbounds %struct.TCGTemp, ptr %call225, i32 0, i32 5
  %146 = load i64, ptr %state226, align 8
  %cmp227 = icmp eq i64 %146, 1
  br i1 %cmp227, label %land.lhs.true, label %if.else248

land.lhs.true:                                    ; preds = %if.else222
  %147 = load i8, ptr %have_opc_new2, align 1
  %tobool229 = trunc i8 %147 to i1
  br i1 %tobool229, label %if.then231, label %if.else248

if.then231:                                       ; preds = %land.lhs.true
  %148 = load i32, ptr %opc_new2, align 4
  store i32 %148, ptr %opc, align 4
  %149 = load ptr, ptr %op, align 8
  %bf.load232 = load i32, ptr %149, align 8
  %bf.value233 = and i32 %148, 255
  %bf.clear234 = and i32 %bf.load232, -256
  %bf.set235 = or i32 %bf.clear234, %bf.value233
  store i32 %bf.set235, ptr %149, align 8
  %150 = load ptr, ptr %op, align 8
  %args236 = getelementptr inbounds %struct.TCGOp, ptr %150, i32 0, i32 4
  %arrayidx237 = getelementptr [0 x i64], ptr %args236, i64 0, i64 1
  %151 = load i64, ptr %arrayidx237, align 8
  %152 = load ptr, ptr %op, align 8
  %args238 = getelementptr inbounds %struct.TCGOp, ptr %152, i32 0, i32 4
  %arrayidx239 = getelementptr [0 x i64], ptr %args238, i64 0, i64 0
  store i64 %151, ptr %arrayidx239, align 8
  %153 = load ptr, ptr %op, align 8
  %args240 = getelementptr inbounds %struct.TCGOp, ptr %153, i32 0, i32 4
  %arrayidx241 = getelementptr [0 x i64], ptr %args240, i64 0, i64 2
  %154 = load i64, ptr %arrayidx241, align 8
  %155 = load ptr, ptr %op, align 8
  %args242 = getelementptr inbounds %struct.TCGOp, ptr %155, i32 0, i32 4
  %arrayidx243 = getelementptr [0 x i64], ptr %args242, i64 0, i64 1
  store i64 %154, ptr %arrayidx243, align 8
  %156 = load ptr, ptr %op, align 8
  %args244 = getelementptr inbounds %struct.TCGOp, ptr %156, i32 0, i32 4
  %arrayidx245 = getelementptr [0 x i64], ptr %args244, i64 0, i64 3
  %157 = load i64, ptr %arrayidx245, align 8
  %158 = load ptr, ptr %op, align 8
  %args246 = getelementptr inbounds %struct.TCGOp, ptr %158, i32 0, i32 4
  %arrayidx247 = getelementptr [0 x i64], ptr %args246, i64 0, i64 2
  store i64 %157, ptr %arrayidx247, align 8
  br label %if.end249

if.else248:                                       ; preds = %land.lhs.true, %if.else222
  br label %do_not_remove

if.end249:                                        ; preds = %if.then231
  br label %if.end250

if.end250:                                        ; preds = %if.end249, %if.end209
  store i32 1, ptr %nb_oargs, align 4
  br label %do_not_remove

sw.default251:                                    ; preds = %for.body10
  %159 = load ptr, ptr %def, align 8
  %nb_iargs252 = getelementptr inbounds %struct.TCGOpDef, ptr %159, i32 0, i32 2
  %160 = load i8, ptr %nb_iargs252, align 1
  %conv253 = zext i8 %160 to i32
  store i32 %conv253, ptr %nb_iargs, align 4
  %161 = load ptr, ptr %def, align 8
  %nb_oargs254 = getelementptr inbounds %struct.TCGOpDef, ptr %161, i32 0, i32 1
  %162 = load i8, ptr %nb_oargs254, align 8
  %conv255 = zext i8 %162 to i32
  store i32 %conv255, ptr %nb_oargs, align 4
  %163 = load ptr, ptr %def, align 8
  %flags = getelementptr inbounds %struct.TCGOpDef, ptr %163, i32 0, i32 5
  %164 = load i8, ptr %flags, align 4
  %conv256 = zext i8 %164 to i32
  %and257 = and i32 %conv256, 8
  %tobool258 = icmp ne i32 %and257, 0
  br i1 %tobool258, label %if.end279, label %land.lhs.true259

land.lhs.true259:                                 ; preds = %sw.default251
  %165 = load i32, ptr %nb_oargs, align 4
  %cmp260 = icmp ne i32 %165, 0
  br i1 %cmp260, label %if.then262, label %if.end279

if.then262:                                       ; preds = %land.lhs.true259
  store i32 0, ptr %i, align 4
  br label %for.cond263

for.cond263:                                      ; preds = %for.inc276, %if.then262
  %166 = load i32, ptr %i, align 4
  %167 = load i32, ptr %nb_oargs, align 4
  %cmp264 = icmp slt i32 %166, %167
  br i1 %cmp264, label %for.body266, label %for.end278

for.body266:                                      ; preds = %for.cond263
  %168 = load ptr, ptr %op, align 8
  %args267 = getelementptr inbounds %struct.TCGOp, ptr %168, i32 0, i32 4
  %169 = load i32, ptr %i, align 4
  %idxprom268 = sext i32 %169 to i64
  %arrayidx269 = getelementptr [0 x i64], ptr %args267, i64 0, i64 %idxprom268
  %170 = load i64, ptr %arrayidx269, align 8
  %call270 = call ptr @arg_temp(i64 noundef %170)
  %state271 = getelementptr inbounds %struct.TCGTemp, ptr %call270, i32 0, i32 5
  %171 = load i64, ptr %state271, align 8
  %cmp272 = icmp ne i64 %171, 1
  br i1 %cmp272, label %if.then274, label %if.end275

if.then274:                                       ; preds = %for.body266
  br label %do_not_remove

if.end275:                                        ; preds = %for.body266
  br label %for.inc276

for.inc276:                                       ; preds = %if.end275
  %172 = load i32, ptr %i, align 4
  %inc277 = add i32 %172, 1
  store i32 %inc277, ptr %i, align 4
  br label %for.cond263, !llvm.loop !49

for.end278:                                       ; preds = %for.cond263
  br label %do_remove

if.end279:                                        ; preds = %land.lhs.true259, %sw.default251
  br label %do_not_remove

do_remove:                                        ; preds = %for.end278, %if.then208, %if.then178, %for.end32
  %173 = load ptr, ptr %s.addr, align 8
  %174 = load ptr, ptr %op, align 8
  call void @tcg_op_remove(ptr noundef %173, ptr noundef %174)
  br label %sw.epilog441

do_not_remove:                                    ; preds = %if.end279, %if.then274, %if.end250, %if.else248, %if.end190
  store i32 0, ptr %i, align 4
  br label %for.cond280

for.cond280:                                      ; preds = %for.inc312, %do_not_remove
  %175 = load i32, ptr %i, align 4
  %176 = load i32, ptr %nb_oargs, align 4
  %cmp281 = icmp slt i32 %175, %176
  br i1 %cmp281, label %for.body283, label %for.end314

for.body283:                                      ; preds = %for.cond280
  %177 = load ptr, ptr %op, align 8
  %args284 = getelementptr inbounds %struct.TCGOp, ptr %177, i32 0, i32 4
  %178 = load i32, ptr %i, align 4
  %idxprom285 = sext i32 %178 to i64
  %arrayidx286 = getelementptr [0 x i64], ptr %args284, i64 0, i64 %idxprom285
  %179 = load i64, ptr %arrayidx286, align 8
  %call287 = call ptr @arg_temp(i64 noundef %179)
  store ptr %call287, ptr %ts, align 8
  %180 = load i32, ptr %i, align 4
  %conv288 = sext i32 %180 to i64
  %cmp289 = icmp ult i64 %conv288, 2
  br i1 %cmp289, label %if.then291, label %if.end296

if.then291:                                       ; preds = %for.body283
  %181 = load ptr, ptr %ts, align 8
  %call292 = call ptr @la_temp_pref(ptr noundef %181)
  %182 = load i32, ptr %call292, align 4
  %183 = load ptr, ptr %op, align 8
  %output_pref293 = getelementptr inbounds %struct.TCGOp, ptr %183, i32 0, i32 3
  %184 = load i32, ptr %i, align 4
  %idxprom294 = sext i32 %184 to i64
  %arrayidx295 = getelementptr [2 x i32], ptr %output_pref293, i64 0, i64 %idxprom294
  store i32 %182, ptr %arrayidx295, align 4
  br label %if.end296

if.end296:                                        ; preds = %if.then291, %for.body283
  %185 = load ptr, ptr %ts, align 8
  %state297 = getelementptr inbounds %struct.TCGTemp, ptr %185, i32 0, i32 5
  %186 = load i64, ptr %state297, align 8
  %and298 = and i64 %186, 1
  %tobool299 = icmp ne i64 %and298, 0
  br i1 %tobool299, label %if.then300, label %if.end303

if.then300:                                       ; preds = %if.end296
  %187 = load i32, ptr %i, align 4
  %shl301 = shl i32 16, %187
  %188 = load i32, ptr %arg_life, align 4
  %or302 = or i32 %188, %shl301
  store i32 %or302, ptr %arg_life, align 4
  br label %if.end303

if.end303:                                        ; preds = %if.then300, %if.end296
  %189 = load ptr, ptr %ts, align 8
  %state304 = getelementptr inbounds %struct.TCGTemp, ptr %189, i32 0, i32 5
  %190 = load i64, ptr %state304, align 8
  %and305 = and i64 %190, 2
  %tobool306 = icmp ne i64 %and305, 0
  br i1 %tobool306, label %if.then307, label %if.end310

if.then307:                                       ; preds = %if.end303
  %191 = load i32, ptr %i, align 4
  %shl308 = shl i32 1, %191
  %192 = load i32, ptr %arg_life, align 4
  %or309 = or i32 %192, %shl308
  store i32 %or309, ptr %arg_life, align 4
  br label %if.end310

if.end310:                                        ; preds = %if.then307, %if.end303
  %193 = load ptr, ptr %ts, align 8
  %state311 = getelementptr inbounds %struct.TCGTemp, ptr %193, i32 0, i32 5
  store i64 1, ptr %state311, align 8
  %194 = load ptr, ptr %ts, align 8
  call void @la_reset_pref(ptr noundef %194)
  br label %for.inc312

for.inc312:                                       ; preds = %if.end310
  %195 = load i32, ptr %i, align 4
  %inc313 = add i32 %195, 1
  store i32 %inc313, ptr %i, align 4
  br label %for.cond280, !llvm.loop !50

for.end314:                                       ; preds = %for.cond280
  %196 = load ptr, ptr %def, align 8
  %flags315 = getelementptr inbounds %struct.TCGOpDef, ptr %196, i32 0, i32 5
  %197 = load i8, ptr %flags315, align 4
  %conv316 = zext i8 %197 to i32
  %and317 = and i32 %conv316, 1
  %tobool318 = icmp ne i32 %and317, 0
  br i1 %tobool318, label %if.then319, label %if.else320

if.then319:                                       ; preds = %for.end314
  %198 = load ptr, ptr %s.addr, align 8
  %199 = load i32, ptr %nb_globals, align 4
  %200 = load i32, ptr %nb_temps, align 4
  call void @la_func_end(ptr noundef %198, i32 noundef %199, i32 noundef %200)
  br label %if.end347

if.else320:                                       ; preds = %for.end314
  %201 = load ptr, ptr %def, align 8
  %flags321 = getelementptr inbounds %struct.TCGOpDef, ptr %201, i32 0, i32 5
  %202 = load i8, ptr %flags321, align 4
  %conv322 = zext i8 %202 to i32
  %and323 = and i32 %conv322, 128
  %tobool324 = icmp ne i32 %and323, 0
  br i1 %tobool324, label %if.then325, label %if.else326

if.then325:                                       ; preds = %if.else320
  %203 = load ptr, ptr %s.addr, align 8
  %204 = load i32, ptr %nb_globals, align 4
  %205 = load i32, ptr %nb_temps, align 4
  call void @la_bb_sync(ptr noundef %203, i32 noundef %204, i32 noundef %205)
  br label %if.end346

if.else326:                                       ; preds = %if.else320
  %206 = load ptr, ptr %def, align 8
  %flags327 = getelementptr inbounds %struct.TCGOpDef, ptr %206, i32 0, i32 5
  %207 = load i8, ptr %flags327, align 4
  %conv328 = zext i8 %207 to i32
  %and329 = and i32 %conv328, 2
  %tobool330 = icmp ne i32 %and329, 0
  br i1 %tobool330, label %if.then331, label %if.else332

if.then331:                                       ; preds = %if.else326
  %208 = load ptr, ptr %s.addr, align 8
  %209 = load i32, ptr %nb_globals, align 4
  %210 = load i32, ptr %nb_temps, align 4
  call void @la_bb_end(ptr noundef %208, i32 noundef %209, i32 noundef %210)
  br label %if.end345

if.else332:                                       ; preds = %if.else326
  %211 = load ptr, ptr %def, align 8
  %flags333 = getelementptr inbounds %struct.TCGOpDef, ptr %211, i32 0, i32 5
  %212 = load i8, ptr %flags333, align 4
  %conv334 = zext i8 %212 to i32
  %and335 = and i32 %conv334, 8
  %tobool336 = icmp ne i32 %and335, 0
  br i1 %tobool336, label %if.then337, label %if.end344

if.then337:                                       ; preds = %if.else332
  %213 = load ptr, ptr %s.addr, align 8
  %214 = load i32, ptr %nb_globals, align 4
  call void @la_global_sync(ptr noundef %213, i32 noundef %214)
  %215 = load ptr, ptr %def, align 8
  %flags338 = getelementptr inbounds %struct.TCGOpDef, ptr %215, i32 0, i32 5
  %216 = load i8, ptr %flags338, align 4
  %conv339 = zext i8 %216 to i32
  %and340 = and i32 %conv339, 4
  %tobool341 = icmp ne i32 %and340, 0
  br i1 %tobool341, label %if.then342, label %if.end343

if.then342:                                       ; preds = %if.then337
  %217 = load ptr, ptr %s.addr, align 8
  %218 = load i32, ptr %nb_temps, align 4
  call void @la_cross_call(ptr noundef %217, i32 noundef %218)
  br label %if.end343

if.end343:                                        ; preds = %if.then342, %if.then337
  br label %if.end344

if.end344:                                        ; preds = %if.end343, %if.else332
  br label %if.end345

if.end345:                                        ; preds = %if.end344, %if.then331
  br label %if.end346

if.end346:                                        ; preds = %if.end345, %if.then325
  br label %if.end347

if.end347:                                        ; preds = %if.end346, %if.then319
  %219 = load i32, ptr %nb_oargs, align 4
  store i32 %219, ptr %i, align 4
  br label %for.cond348

for.cond348:                                      ; preds = %for.inc364, %if.end347
  %220 = load i32, ptr %i, align 4
  %221 = load i32, ptr %nb_oargs, align 4
  %222 = load i32, ptr %nb_iargs, align 4
  %add349 = add i32 %221, %222
  %cmp350 = icmp slt i32 %220, %add349
  br i1 %cmp350, label %for.body352, label %for.end366

for.body352:                                      ; preds = %for.cond348
  %223 = load ptr, ptr %op, align 8
  %args353 = getelementptr inbounds %struct.TCGOp, ptr %223, i32 0, i32 4
  %224 = load i32, ptr %i, align 4
  %idxprom354 = sext i32 %224 to i64
  %arrayidx355 = getelementptr [0 x i64], ptr %args353, i64 0, i64 %idxprom354
  %225 = load i64, ptr %arrayidx355, align 8
  %call356 = call ptr @arg_temp(i64 noundef %225)
  store ptr %call356, ptr %ts, align 8
  %226 = load ptr, ptr %ts, align 8
  %state357 = getelementptr inbounds %struct.TCGTemp, ptr %226, i32 0, i32 5
  %227 = load i64, ptr %state357, align 8
  %and358 = and i64 %227, 1
  %tobool359 = icmp ne i64 %and358, 0
  br i1 %tobool359, label %if.then360, label %if.end363

if.then360:                                       ; preds = %for.body352
  %228 = load i32, ptr %i, align 4
  %shl361 = shl i32 16, %228
  %229 = load i32, ptr %arg_life, align 4
  %or362 = or i32 %229, %shl361
  store i32 %or362, ptr %arg_life, align 4
  br label %if.end363

if.end363:                                        ; preds = %if.then360, %for.body352
  br label %for.inc364

for.inc364:                                       ; preds = %if.end363
  %230 = load i32, ptr %i, align 4
  %inc365 = add i32 %230, 1
  store i32 %inc365, ptr %i, align 4
  br label %for.cond348, !llvm.loop !51

for.end366:                                       ; preds = %for.cond348
  %231 = load i32, ptr %nb_oargs, align 4
  store i32 %231, ptr %i, align 4
  br label %for.cond367

for.cond367:                                      ; preds = %for.inc390, %for.end366
  %232 = load i32, ptr %i, align 4
  %233 = load i32, ptr %nb_oargs, align 4
  %234 = load i32, ptr %nb_iargs, align 4
  %add368 = add i32 %233, %234
  %cmp369 = icmp slt i32 %232, %add368
  br i1 %cmp369, label %for.body371, label %for.end392

for.body371:                                      ; preds = %for.cond367
  %235 = load ptr, ptr %op, align 8
  %args372 = getelementptr inbounds %struct.TCGOp, ptr %235, i32 0, i32 4
  %236 = load i32, ptr %i, align 4
  %idxprom373 = sext i32 %236 to i64
  %arrayidx374 = getelementptr [0 x i64], ptr %args372, i64 0, i64 %idxprom373
  %237 = load i64, ptr %arrayidx374, align 8
  %call375 = call ptr @arg_temp(i64 noundef %237)
  store ptr %call375, ptr %ts, align 8
  %238 = load ptr, ptr %ts, align 8
  %state376 = getelementptr inbounds %struct.TCGTemp, ptr %238, i32 0, i32 5
  %239 = load i64, ptr %state376, align 8
  %and377 = and i64 %239, 1
  %tobool378 = icmp ne i64 %and377, 0
  br i1 %tobool378, label %if.then379, label %if.end389

if.then379:                                       ; preds = %for.body371
  %240 = load ptr, ptr %ts, align 8
  %bf.load380 = load i64, ptr %240, align 8
  %bf.lshr381 = lshr i64 %bf.load380, 24
  %bf.clear382 = and i64 %bf.lshr381, 255
  %bf.cast383 = trunc i64 %bf.clear382 to i32
  %idxprom384 = zext i32 %bf.cast383 to i64
  %arrayidx385 = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom384
  %241 = load i32, ptr %arrayidx385, align 4
  %242 = load ptr, ptr %ts, align 8
  %call386 = call ptr @la_temp_pref(ptr noundef %242)
  store i32 %241, ptr %call386, align 4
  %243 = load ptr, ptr %ts, align 8
  %state387 = getelementptr inbounds %struct.TCGTemp, ptr %243, i32 0, i32 5
  %244 = load i64, ptr %state387, align 8
  %and388 = and i64 %244, -2
  store i64 %and388, ptr %state387, align 8
  br label %if.end389

if.end389:                                        ; preds = %if.then379, %for.body371
  br label %for.inc390

for.inc390:                                       ; preds = %if.end389
  %245 = load i32, ptr %i, align 4
  %inc391 = add i32 %245, 1
  store i32 %inc391, ptr %i, align 4
  br label %for.cond367, !llvm.loop !52

for.end392:                                       ; preds = %for.cond367
  %246 = load i32, ptr %opc, align 4
  switch i32 %246, label %sw.default406 [
    i32 5, label %sw.bb393
    i32 63, label %sw.bb393
  ]

sw.bb393:                                         ; preds = %for.end392, %for.end392
  %247 = load i32, ptr %arg_life, align 4
  %and394 = and i32 %247, 32
  %tobool395 = icmp ne i32 %and394, 0
  br i1 %tobool395, label %if.then396, label %if.end405

if.then396:                                       ; preds = %sw.bb393
  %248 = load ptr, ptr %op, align 8
  %args397 = getelementptr inbounds %struct.TCGOp, ptr %248, i32 0, i32 4
  %arrayidx398 = getelementptr [0 x i64], ptr %args397, i64 0, i64 1
  %249 = load i64, ptr %arrayidx398, align 8
  %call399 = call ptr @arg_temp(i64 noundef %249)
  %call400 = call ptr @la_temp_pref(ptr noundef %call399)
  %250 = load i32, ptr %call400, align 4
  %251 = load ptr, ptr %op, align 8
  %args401 = getelementptr inbounds %struct.TCGOp, ptr %251, i32 0, i32 4
  %arrayidx402 = getelementptr [0 x i64], ptr %args401, i64 0, i64 0
  %252 = load i64, ptr %arrayidx402, align 8
  %call403 = call ptr @arg_temp(i64 noundef %252)
  %call404 = call ptr @la_temp_pref(ptr noundef %call403)
  store i32 %250, ptr %call404, align 4
  br label %if.end405

if.end405:                                        ; preds = %if.then396, %sw.bb393
  br label %sw.epilog440

sw.default406:                                    ; preds = %for.end392
  %253 = load i32, ptr %nb_oargs, align 4
  store i32 %253, ptr %i, align 4
  br label %for.cond407

for.cond407:                                      ; preds = %for.inc437, %sw.default406
  %254 = load i32, ptr %i, align 4
  %255 = load i32, ptr %nb_oargs, align 4
  %256 = load i32, ptr %nb_iargs, align 4
  %add408 = add i32 %255, %256
  %cmp409 = icmp slt i32 %254, %add408
  br i1 %cmp409, label %for.body411, label %for.end439

for.body411:                                      ; preds = %for.cond407
  %257 = load ptr, ptr %def, align 8
  %args_ct = getelementptr inbounds %struct.TCGOpDef, ptr %257, i32 0, i32 6
  %258 = load ptr, ptr %args_ct, align 8
  %259 = load i32, ptr %i, align 4
  %idxprom412 = sext i32 %259 to i64
  %arrayidx413 = getelementptr %struct.TCGArgConstraint, ptr %258, i64 %idxprom412
  store ptr %arrayidx413, ptr %ct, align 8
  %260 = load ptr, ptr %op, align 8
  %args414 = getelementptr inbounds %struct.TCGOp, ptr %260, i32 0, i32 4
  %261 = load i32, ptr %i, align 4
  %idxprom415 = sext i32 %261 to i64
  %arrayidx416 = getelementptr [0 x i64], ptr %args414, i64 0, i64 %idxprom415
  %262 = load i64, ptr %arrayidx416, align 8
  %call417 = call ptr @arg_temp(i64 noundef %262)
  store ptr %call417, ptr %ts, align 8
  %263 = load ptr, ptr %ts, align 8
  %call418 = call ptr @la_temp_pref(ptr noundef %263)
  store ptr %call418, ptr %pset, align 8
  %264 = load ptr, ptr %pset, align 8
  %265 = load i32, ptr %264, align 4
  store i32 %265, ptr %set, align 4
  %266 = load ptr, ptr %ct, align 8
  %regs = getelementptr inbounds %struct.TCGArgConstraint, ptr %266, i32 0, i32 1
  %267 = load i32, ptr %regs, align 4
  %268 = load i32, ptr %set, align 4
  %and419 = and i32 %268, %267
  store i32 %and419, ptr %set, align 4
  %269 = load ptr, ptr %ct, align 8
  %bf.load420 = load i64, ptr %269, align 4
  %bf.lshr421 = lshr i64 %bf.load420, 31
  %bf.clear422 = and i64 %bf.lshr421, 1
  %bf.cast423 = trunc i64 %bf.clear422 to i1
  br i1 %bf.cast423, label %if.then424, label %if.end431

if.then424:                                       ; preds = %for.body411
  %270 = load ptr, ptr %op, align 8
  %271 = load ptr, ptr %ct, align 8
  %bf.load425 = load i64, ptr %271, align 4
  %bf.lshr426 = lshr i64 %bf.load425, 16
  %bf.clear427 = and i64 %bf.lshr426, 15
  %bf.cast428 = trunc i64 %bf.clear427 to i32
  %call429 = call i32 @output_pref(ptr noundef %270, i32 noundef %bf.cast428)
  %272 = load i32, ptr %set, align 4
  %and430 = and i32 %272, %call429
  store i32 %and430, ptr %set, align 4
  br label %if.end431

if.end431:                                        ; preds = %if.then424, %for.body411
  %273 = load i32, ptr %set, align 4
  %cmp432 = icmp eq i32 %273, 0
  br i1 %cmp432, label %if.then434, label %if.end436

if.then434:                                       ; preds = %if.end431
  %274 = load ptr, ptr %ct, align 8
  %regs435 = getelementptr inbounds %struct.TCGArgConstraint, ptr %274, i32 0, i32 1
  %275 = load i32, ptr %regs435, align 4
  store i32 %275, ptr %set, align 4
  br label %if.end436

if.end436:                                        ; preds = %if.then434, %if.end431
  %276 = load i32, ptr %set, align 4
  %277 = load ptr, ptr %pset, align 8
  store i32 %276, ptr %277, align 4
  br label %for.inc437

for.inc437:                                       ; preds = %if.end436
  %278 = load i32, ptr %i, align 4
  %inc438 = add i32 %278, 1
  store i32 %inc438, ptr %i, align 4
  br label %for.cond407, !llvm.loop !53

for.end439:                                       ; preds = %for.cond407
  br label %sw.epilog440

sw.epilog440:                                     ; preds = %for.end439, %if.end405
  br label %sw.epilog441

sw.epilog441:                                     ; preds = %sw.epilog440, %do_remove, %sw.bb156, %sw.bb155, %for.end154
  %279 = load i32, ptr %arg_life, align 4
  %280 = load ptr, ptr %op, align 8
  %life = getelementptr inbounds %struct.TCGOp, ptr %280, i32 0, i32 1
  store i32 %279, ptr %life, align 4
  br label %for.inc442

for.inc442:                                       ; preds = %sw.epilog441
  %281 = load ptr, ptr %op_prev, align 8
  store ptr %281, ptr %op, align 8
  br label %for.cond6, !llvm.loop !54

for.end443:                                       ; preds = %land.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @liveness_pass_2(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %nb_globals = alloca i32, align 4
  %nb_temps = alloca i32, align 4
  %i = alloca i32, align 4
  %changes = alloca i8, align 1
  %op = alloca ptr, align 8
  %op_next = alloca ptr, align 8
  %its = alloca ptr, align 8
  %dts = alloca ptr, align 8
  %its36 = alloca ptr, align 8
  %opc = alloca i32, align 4
  %def = alloca ptr, align 8
  %arg_life = alloca i32, align 4
  %nb_iargs = alloca i32, align 4
  %nb_oargs = alloca i32, align 4
  %call_flags = alloca i32, align 4
  %arg_ts = alloca ptr, align 8
  %dir_ts = alloca ptr, align 8
  %lopc = alloca i32, align 4
  %lop = alloca ptr, align 8
  %sopc = alloca i32, align 4
  %sop = alloca ptr, align 8
  %out_ts = alloca ptr, align 8
  %sopc269 = alloca i32, align 4
  %sop277 = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %nb_globals1 = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %nb_globals1, align 4
  store i32 %1, ptr %nb_globals, align 4
  store i8 0, ptr %changes, align 1
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %nb_globals, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 37
  %5 = load i32, ptr %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %its, align 8
  %6 = load ptr, ptr %its, align 8
  %bf.load = load i64, ptr %6, align 8
  %bf.lshr = lshr i64 %bf.load, 35
  %bf.clear = and i64 %bf.lshr, 1
  %bf.cast = trunc i64 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %7 = load ptr, ptr %s.addr, align 8
  %call = call ptr @tcg_temp_alloc(ptr noundef %7)
  store ptr %call, ptr %dts, align 8
  %8 = load ptr, ptr %its, align 8
  %bf.load2 = load i64, ptr %8, align 8
  %bf.lshr3 = lshr i64 %bf.load2, 24
  %bf.clear4 = and i64 %bf.lshr3, 255
  %bf.cast5 = trunc i64 %bf.clear4 to i32
  %9 = load ptr, ptr %dts, align 8
  %10 = zext i32 %bf.cast5 to i64
  %bf.load6 = load i64, ptr %9, align 8
  %bf.value = and i64 %10, 255
  %bf.shl = shl i64 %bf.value, 24
  %bf.clear7 = and i64 %bf.load6, -4278190081
  %bf.set = or i64 %bf.clear7, %bf.shl
  store i64 %bf.set, ptr %9, align 8
  %11 = load ptr, ptr %its, align 8
  %bf.load8 = load i64, ptr %11, align 8
  %bf.lshr9 = lshr i64 %bf.load8, 16
  %bf.clear10 = and i64 %bf.lshr9, 255
  %bf.cast11 = trunc i64 %bf.clear10 to i32
  %12 = load ptr, ptr %dts, align 8
  %13 = zext i32 %bf.cast11 to i64
  %bf.load12 = load i64, ptr %12, align 8
  %bf.value13 = and i64 %13, 255
  %bf.shl14 = shl i64 %bf.value13, 16
  %bf.clear15 = and i64 %bf.load12, -16711681
  %bf.set16 = or i64 %bf.clear15, %bf.shl14
  store i64 %bf.set16, ptr %12, align 8
  %14 = load ptr, ptr %its, align 8
  %bf.load18 = load i64, ptr %14, align 8
  %bf.lshr19 = lshr i64 %bf.load18, 40
  %bf.clear20 = and i64 %bf.lshr19, 1
  %bf.cast21 = trunc i64 %bf.clear20 to i32
  %15 = load ptr, ptr %dts, align 8
  %16 = zext i32 %bf.cast21 to i64
  %bf.load22 = load i64, ptr %15, align 8
  %bf.value23 = and i64 %16, 1
  %bf.shl24 = shl i64 %bf.value23, 40
  %bf.clear25 = and i64 %bf.load22, -1099511627777
  %bf.set26 = or i64 %bf.clear25, %bf.shl24
  store i64 %bf.set26, ptr %15, align 8
  %17 = load ptr, ptr %dts, align 8
  %bf.load28 = load i64, ptr %17, align 8
  %bf.clear29 = and i64 %bf.load28, -30064771073
  %bf.set30 = or i64 %bf.clear29, 0
  store i64 %bf.set30, ptr %17, align 8
  %18 = load ptr, ptr %dts, align 8
  %19 = load ptr, ptr %its, align 8
  %state_ptr = getelementptr inbounds %struct.TCGTemp, ptr %19, i32 0, i32 6
  store ptr %18, ptr %state_ptr, align 8
  br label %if.end

if.else:                                          ; preds = %for.body
  %20 = load ptr, ptr %its, align 8
  %state_ptr31 = getelementptr inbounds %struct.TCGTemp, ptr %20, i32 0, i32 6
  store ptr null, ptr %state_ptr31, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %21 = load ptr, ptr %its, align 8
  %state = getelementptr inbounds %struct.TCGTemp, ptr %21, i32 0, i32 5
  store i64 1, ptr %state, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i32, ptr %i, align 4
  %inc = add i32 %22, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !55

for.end:                                          ; preds = %for.cond
  %23 = load ptr, ptr %s.addr, align 8
  %nb_temps32 = getelementptr inbounds %struct.TCGContext, ptr %23, i32 0, i32 7
  %24 = load i32, ptr %nb_temps32, align 8
  store i32 %24, ptr %nb_temps, align 4
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc42, %for.end
  %25 = load i32, ptr %i, align 4
  %26 = load i32, ptr %nb_temps, align 4
  %cmp34 = icmp slt i32 %25, %26
  br i1 %cmp34, label %for.body35, label %for.end44

for.body35:                                       ; preds = %for.cond33
  %27 = load ptr, ptr %s.addr, align 8
  %temps37 = getelementptr inbounds %struct.TCGContext, ptr %27, i32 0, i32 37
  %28 = load i32, ptr %i, align 4
  %idxprom38 = sext i32 %28 to i64
  %arrayidx39 = getelementptr [512 x %struct.TCGTemp], ptr %temps37, i64 0, i64 %idxprom38
  store ptr %arrayidx39, ptr %its36, align 8
  %29 = load ptr, ptr %its36, align 8
  %state_ptr40 = getelementptr inbounds %struct.TCGTemp, ptr %29, i32 0, i32 6
  store ptr null, ptr %state_ptr40, align 8
  %30 = load ptr, ptr %its36, align 8
  %state41 = getelementptr inbounds %struct.TCGTemp, ptr %30, i32 0, i32 5
  store i64 1, ptr %state41, align 8
  br label %for.inc42

for.inc42:                                        ; preds = %for.body35
  %31 = load i32, ptr %i, align 4
  %inc43 = add i32 %31, 1
  store i32 %inc43, ptr %i, align 4
  br label %for.cond33, !llvm.loop !56

for.end44:                                        ; preds = %for.cond33
  %32 = load ptr, ptr %s.addr, align 8
  %ops = getelementptr inbounds %struct.TCGContext, ptr %32, i32 0, i32 38
  %33 = load ptr, ptr %ops, align 8
  store ptr %33, ptr %op, align 8
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc301, %for.end44
  %34 = load ptr, ptr %op, align 8
  %tobool46 = icmp ne ptr %34, null
  br i1 %tobool46, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond45
  %35 = load ptr, ptr %op, align 8
  %link = getelementptr inbounds %struct.TCGOp, ptr %35, i32 0, i32 2
  %36 = load ptr, ptr %link, align 8
  store ptr %36, ptr %op_next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond45
  %37 = phi i1 [ false, %for.cond45 ], [ true, %land.rhs ]
  br i1 %37, label %for.body47, label %for.end302

for.body47:                                       ; preds = %land.end
  %38 = load ptr, ptr %op, align 8
  %bf.load48 = load i32, ptr %38, align 8
  %bf.clear49 = and i32 %bf.load48, 255
  store i32 %bf.clear49, ptr %opc, align 4
  %39 = load i32, ptr %opc, align 4
  %idxprom50 = zext i32 %39 to i64
  %arrayidx51 = getelementptr [0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 %idxprom50
  store ptr %arrayidx51, ptr %def, align 8
  %40 = load ptr, ptr %op, align 8
  %life = getelementptr inbounds %struct.TCGOp, ptr %40, i32 0, i32 1
  %41 = load i32, ptr %life, align 4
  store i32 %41, ptr %arg_life, align 4
  %42 = load i32, ptr %opc, align 4
  %cmp52 = icmp eq i32 %42, 2
  br i1 %cmp52, label %if.then53, label %if.else60

if.then53:                                        ; preds = %for.body47
  %43 = load ptr, ptr %op, align 8
  %bf.load54 = load i32, ptr %43, align 8
  %bf.lshr55 = lshr i32 %bf.load54, 24
  store i32 %bf.lshr55, ptr %nb_oargs, align 4
  %44 = load ptr, ptr %op, align 8
  %bf.load56 = load i32, ptr %44, align 8
  %bf.lshr57 = lshr i32 %bf.load56, 16
  %bf.clear58 = and i32 %bf.lshr57, 255
  store i32 %bf.clear58, ptr %nb_iargs, align 4
  %45 = load ptr, ptr %op, align 8
  %call59 = call i32 @tcg_call_flags(ptr noundef %45)
  store i32 %call59, ptr %call_flags, align 4
  br label %if.end83

if.else60:                                        ; preds = %for.body47
  %46 = load ptr, ptr %def, align 8
  %nb_iargs61 = getelementptr inbounds %struct.TCGOpDef, ptr %46, i32 0, i32 2
  %47 = load i8, ptr %nb_iargs61, align 1
  %conv = zext i8 %47 to i32
  store i32 %conv, ptr %nb_iargs, align 4
  %48 = load ptr, ptr %def, align 8
  %nb_oargs62 = getelementptr inbounds %struct.TCGOpDef, ptr %48, i32 0, i32 1
  %49 = load i8, ptr %nb_oargs62, align 8
  %conv63 = zext i8 %49 to i32
  store i32 %conv63, ptr %nb_oargs, align 4
  %50 = load ptr, ptr %def, align 8
  %flags = getelementptr inbounds %struct.TCGOpDef, ptr %50, i32 0, i32 5
  %51 = load i8, ptr %flags, align 4
  %conv64 = zext i8 %51 to i32
  %and = and i32 %conv64, 128
  %tobool65 = icmp ne i32 %and, 0
  br i1 %tobool65, label %if.then66, label %if.else67

if.then66:                                        ; preds = %if.else60
  store i32 2, ptr %call_flags, align 4
  br label %if.end82

if.else67:                                        ; preds = %if.else60
  %52 = load ptr, ptr %def, align 8
  %flags68 = getelementptr inbounds %struct.TCGOpDef, ptr %52, i32 0, i32 5
  %53 = load i8, ptr %flags68, align 4
  %conv69 = zext i8 %53 to i32
  %and70 = and i32 %conv69, 2
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %if.then72, label %if.else73

if.then72:                                        ; preds = %if.else67
  store i32 0, ptr %call_flags, align 4
  br label %if.end81

if.else73:                                        ; preds = %if.else67
  %54 = load ptr, ptr %def, align 8
  %flags74 = getelementptr inbounds %struct.TCGOpDef, ptr %54, i32 0, i32 5
  %55 = load i8, ptr %flags74, align 4
  %conv75 = zext i8 %55 to i32
  %and76 = and i32 %conv75, 8
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %if.then78, label %if.else79

if.then78:                                        ; preds = %if.else73
  store i32 2, ptr %call_flags, align 4
  br label %if.end80

if.else79:                                        ; preds = %if.else73
  store i32 3, ptr %call_flags, align 4
  br label %if.end80

if.end80:                                         ; preds = %if.else79, %if.then78
  br label %if.end81

if.end81:                                         ; preds = %if.end80, %if.then72
  br label %if.end82

if.end82:                                         ; preds = %if.end81, %if.then66
  br label %if.end83

if.end83:                                         ; preds = %if.end82, %if.then53
  %56 = load i32, ptr %nb_oargs, align 4
  store i32 %56, ptr %i, align 4
  br label %for.cond84

for.cond84:                                       ; preds = %for.inc114, %if.end83
  %57 = load i32, ptr %i, align 4
  %58 = load i32, ptr %nb_iargs, align 4
  %59 = load i32, ptr %nb_oargs, align 4
  %add = add i32 %58, %59
  %cmp85 = icmp slt i32 %57, %add
  br i1 %cmp85, label %for.body87, label %for.end116

for.body87:                                       ; preds = %for.cond84
  %60 = load ptr, ptr %op, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %60, i32 0, i32 4
  %61 = load i32, ptr %i, align 4
  %idxprom88 = sext i32 %61 to i64
  %arrayidx89 = getelementptr [0 x i64], ptr %args, i64 0, i64 %idxprom88
  %62 = load i64, ptr %arrayidx89, align 8
  %call90 = call ptr @arg_temp(i64 noundef %62)
  store ptr %call90, ptr %arg_ts, align 8
  %63 = load ptr, ptr %arg_ts, align 8
  %state_ptr91 = getelementptr inbounds %struct.TCGTemp, ptr %63, i32 0, i32 6
  %64 = load ptr, ptr %state_ptr91, align 8
  store ptr %64, ptr %dir_ts, align 8
  %65 = load ptr, ptr %dir_ts, align 8
  %tobool92 = icmp ne ptr %65, null
  br i1 %tobool92, label %land.lhs.true, label %if.end113

land.lhs.true:                                    ; preds = %for.body87
  %66 = load ptr, ptr %arg_ts, align 8
  %state93 = getelementptr inbounds %struct.TCGTemp, ptr %66, i32 0, i32 5
  %67 = load i64, ptr %state93, align 8
  %cmp94 = icmp eq i64 %67, 1
  br i1 %cmp94, label %if.then96, label %if.end113

if.then96:                                        ; preds = %land.lhs.true
  %68 = load ptr, ptr %arg_ts, align 8
  %bf.load97 = load i64, ptr %68, align 8
  %bf.lshr98 = lshr i64 %bf.load97, 24
  %bf.clear99 = and i64 %bf.lshr98, 255
  %bf.cast100 = trunc i64 %bf.clear99 to i32
  %cmp101 = icmp eq i32 %bf.cast100, 0
  %cond = select i1 %cmp101, i32 13, i32 73
  store i32 %cond, ptr %lopc, align 4
  %69 = load ptr, ptr %s.addr, align 8
  %70 = load ptr, ptr %op, align 8
  %71 = load i32, ptr %lopc, align 4
  %call103 = call ptr @tcg_op_insert_before(ptr noundef %69, ptr noundef %70, i32 noundef %71, i32 noundef 3)
  store ptr %call103, ptr %lop, align 8
  %72 = load ptr, ptr %dir_ts, align 8
  %call104 = call i64 @temp_arg(ptr noundef %72)
  %73 = load ptr, ptr %lop, align 8
  %args105 = getelementptr inbounds %struct.TCGOp, ptr %73, i32 0, i32 4
  %arrayidx106 = getelementptr [0 x i64], ptr %args105, i64 0, i64 0
  store i64 %call104, ptr %arrayidx106, align 8
  %74 = load ptr, ptr %arg_ts, align 8
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %74, i32 0, i32 2
  %75 = load ptr, ptr %mem_base, align 8
  %call107 = call i64 @temp_arg(ptr noundef %75)
  %76 = load ptr, ptr %lop, align 8
  %args108 = getelementptr inbounds %struct.TCGOp, ptr %76, i32 0, i32 4
  %arrayidx109 = getelementptr [0 x i64], ptr %args108, i64 0, i64 1
  store i64 %call107, ptr %arrayidx109, align 8
  %77 = load ptr, ptr %arg_ts, align 8
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %77, i32 0, i32 3
  %78 = load i64, ptr %mem_offset, align 8
  %79 = load ptr, ptr %lop, align 8
  %args110 = getelementptr inbounds %struct.TCGOp, ptr %79, i32 0, i32 4
  %arrayidx111 = getelementptr [0 x i64], ptr %args110, i64 0, i64 2
  store i64 %78, ptr %arrayidx111, align 8
  %80 = load ptr, ptr %arg_ts, align 8
  %state112 = getelementptr inbounds %struct.TCGTemp, ptr %80, i32 0, i32 5
  store i64 2, ptr %state112, align 8
  br label %if.end113

if.end113:                                        ; preds = %if.then96, %land.lhs.true, %for.body87
  br label %for.inc114

for.inc114:                                       ; preds = %if.end113
  %81 = load i32, ptr %i, align 4
  %inc115 = add i32 %81, 1
  store i32 %inc115, ptr %i, align 4
  br label %for.cond84, !llvm.loop !57

for.end116:                                       ; preds = %for.cond84
  %82 = load i32, ptr %nb_oargs, align 4
  store i32 %82, ptr %i, align 4
  br label %for.cond117

for.cond117:                                      ; preds = %for.inc139, %for.end116
  %83 = load i32, ptr %i, align 4
  %84 = load i32, ptr %nb_iargs, align 4
  %85 = load i32, ptr %nb_oargs, align 4
  %add118 = add i32 %84, %85
  %cmp119 = icmp slt i32 %83, %add118
  br i1 %cmp119, label %for.body121, label %for.end141

for.body121:                                      ; preds = %for.cond117
  %86 = load ptr, ptr %op, align 8
  %args122 = getelementptr inbounds %struct.TCGOp, ptr %86, i32 0, i32 4
  %87 = load i32, ptr %i, align 4
  %idxprom123 = sext i32 %87 to i64
  %arrayidx124 = getelementptr [0 x i64], ptr %args122, i64 0, i64 %idxprom123
  %88 = load i64, ptr %arrayidx124, align 8
  %call125 = call ptr @arg_temp(i64 noundef %88)
  store ptr %call125, ptr %arg_ts, align 8
  %89 = load ptr, ptr %arg_ts, align 8
  %state_ptr126 = getelementptr inbounds %struct.TCGTemp, ptr %89, i32 0, i32 6
  %90 = load ptr, ptr %state_ptr126, align 8
  store ptr %90, ptr %dir_ts, align 8
  %91 = load ptr, ptr %dir_ts, align 8
  %tobool127 = icmp ne ptr %91, null
  br i1 %tobool127, label %if.then128, label %if.end138

if.then128:                                       ; preds = %for.body121
  %92 = load ptr, ptr %dir_ts, align 8
  %call129 = call i64 @temp_arg(ptr noundef %92)
  %93 = load ptr, ptr %op, align 8
  %args130 = getelementptr inbounds %struct.TCGOp, ptr %93, i32 0, i32 4
  %94 = load i32, ptr %i, align 4
  %idxprom131 = sext i32 %94 to i64
  %arrayidx132 = getelementptr [0 x i64], ptr %args130, i64 0, i64 %idxprom131
  store i64 %call129, ptr %arrayidx132, align 8
  store i8 1, ptr %changes, align 1
  %95 = load i32, ptr %arg_life, align 4
  %96 = load i32, ptr %i, align 4
  %shl = shl i32 16, %96
  %and133 = and i32 %95, %shl
  %tobool134 = icmp ne i32 %and133, 0
  br i1 %tobool134, label %if.then135, label %if.end137

if.then135:                                       ; preds = %if.then128
  %97 = load ptr, ptr %arg_ts, align 8
  %state136 = getelementptr inbounds %struct.TCGTemp, ptr %97, i32 0, i32 5
  store i64 1, ptr %state136, align 8
  br label %if.end137

if.end137:                                        ; preds = %if.then135, %if.then128
  br label %if.end138

if.end138:                                        ; preds = %if.end137, %for.body121
  br label %for.inc139

for.inc139:                                       ; preds = %if.end138
  %98 = load i32, ptr %i, align 4
  %inc140 = add i32 %98, 1
  store i32 %inc140, ptr %i, align 4
  br label %for.cond117, !llvm.loop !58

for.end141:                                       ; preds = %for.cond117
  %99 = load i32, ptr %call_flags, align 4
  %and142 = and i32 %99, 1
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %if.then144, label %if.else145

if.then144:                                       ; preds = %for.end141
  br label %if.end190

if.else145:                                       ; preds = %for.end141
  %100 = load i32, ptr %call_flags, align 4
  %and146 = and i32 %100, 2
  %tobool147 = icmp ne i32 %and146, 0
  br i1 %tobool147, label %if.then148, label %if.else167

if.then148:                                       ; preds = %if.else145
  store i32 0, ptr %i, align 4
  br label %for.cond149

for.cond149:                                      ; preds = %for.inc164, %if.then148
  %101 = load i32, ptr %i, align 4
  %102 = load i32, ptr %nb_globals, align 4
  %cmp150 = icmp slt i32 %101, %102
  br i1 %cmp150, label %for.body152, label %for.end166

for.body152:                                      ; preds = %for.cond149
  %103 = load ptr, ptr %s.addr, align 8
  %temps153 = getelementptr inbounds %struct.TCGContext, ptr %103, i32 0, i32 37
  %104 = load i32, ptr %i, align 4
  %idxprom154 = sext i32 %104 to i64
  %arrayidx155 = getelementptr [512 x %struct.TCGTemp], ptr %temps153, i64 0, i64 %idxprom154
  store ptr %arrayidx155, ptr %arg_ts, align 8
  br label %do.body

do.body:                                          ; preds = %for.body152
  %105 = load ptr, ptr %arg_ts, align 8
  %state_ptr156 = getelementptr inbounds %struct.TCGTemp, ptr %105, i32 0, i32 6
  %106 = load ptr, ptr %state_ptr156, align 8
  %cmp157 = icmp eq ptr %106, null
  br i1 %cmp157, label %if.end163, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  %107 = load ptr, ptr %arg_ts, align 8
  %state159 = getelementptr inbounds %struct.TCGTemp, ptr %107, i32 0, i32 5
  %108 = load i64, ptr %state159, align 8
  %cmp160 = icmp ne i64 %108, 0
  br i1 %cmp160, label %if.end163, label %if.then162

if.then162:                                       ; preds = %lor.lhs.false
  unreachable

if.end163:                                        ; preds = %lor.lhs.false, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end163
  br label %for.inc164

for.inc164:                                       ; preds = %do.end
  %109 = load i32, ptr %i, align 4
  %inc165 = add i32 %109, 1
  store i32 %inc165, ptr %i, align 4
  br label %for.cond149, !llvm.loop !59

for.end166:                                       ; preds = %for.cond149
  br label %if.end189

if.else167:                                       ; preds = %if.else145
  store i32 0, ptr %i, align 4
  br label %for.cond168

for.cond168:                                      ; preds = %for.inc186, %if.else167
  %110 = load i32, ptr %i, align 4
  %111 = load i32, ptr %nb_globals, align 4
  %cmp169 = icmp slt i32 %110, %111
  br i1 %cmp169, label %for.body171, label %for.end188

for.body171:                                      ; preds = %for.cond168
  %112 = load ptr, ptr %s.addr, align 8
  %temps172 = getelementptr inbounds %struct.TCGContext, ptr %112, i32 0, i32 37
  %113 = load i32, ptr %i, align 4
  %idxprom173 = sext i32 %113 to i64
  %arrayidx174 = getelementptr [512 x %struct.TCGTemp], ptr %temps172, i64 0, i64 %idxprom173
  store ptr %arrayidx174, ptr %arg_ts, align 8
  br label %do.body175

do.body175:                                       ; preds = %for.body171
  %114 = load ptr, ptr %arg_ts, align 8
  %state_ptr176 = getelementptr inbounds %struct.TCGTemp, ptr %114, i32 0, i32 6
  %115 = load ptr, ptr %state_ptr176, align 8
  %cmp177 = icmp eq ptr %115, null
  br i1 %cmp177, label %if.end184, label %lor.lhs.false179

lor.lhs.false179:                                 ; preds = %do.body175
  %116 = load ptr, ptr %arg_ts, align 8
  %state180 = getelementptr inbounds %struct.TCGTemp, ptr %116, i32 0, i32 5
  %117 = load i64, ptr %state180, align 8
  %cmp181 = icmp eq i64 %117, 1
  br i1 %cmp181, label %if.end184, label %if.then183

if.then183:                                       ; preds = %lor.lhs.false179
  unreachable

if.end184:                                        ; preds = %lor.lhs.false179, %do.body175
  br label %do.end185

do.end185:                                        ; preds = %if.end184
  br label %for.inc186

for.inc186:                                       ; preds = %do.end185
  %118 = load i32, ptr %i, align 4
  %inc187 = add i32 %118, 1
  store i32 %inc187, ptr %i, align 4
  br label %for.cond168, !llvm.loop !60

for.end188:                                       ; preds = %for.cond168
  br label %if.end189

if.end189:                                        ; preds = %for.end188, %for.end166
  br label %if.end190

if.end190:                                        ; preds = %if.end189, %if.then144
  %119 = load i32, ptr %opc, align 4
  %cmp191 = icmp eq i32 %119, 5
  br i1 %cmp191, label %if.then196, label %lor.lhs.false193

lor.lhs.false193:                                 ; preds = %if.end190
  %120 = load i32, ptr %opc, align 4
  %cmp194 = icmp eq i32 %120, 63
  br i1 %cmp194, label %if.then196, label %if.else247

if.then196:                                       ; preds = %lor.lhs.false193, %if.end190
  %121 = load ptr, ptr %op, align 8
  %args197 = getelementptr inbounds %struct.TCGOp, ptr %121, i32 0, i32 4
  %arrayidx198 = getelementptr [0 x i64], ptr %args197, i64 0, i64 0
  %122 = load i64, ptr %arrayidx198, align 8
  %call199 = call ptr @arg_temp(i64 noundef %122)
  store ptr %call199, ptr %arg_ts, align 8
  %123 = load ptr, ptr %arg_ts, align 8
  %state_ptr200 = getelementptr inbounds %struct.TCGTemp, ptr %123, i32 0, i32 6
  %124 = load ptr, ptr %state_ptr200, align 8
  store ptr %124, ptr %dir_ts, align 8
  %125 = load ptr, ptr %dir_ts, align 8
  %tobool201 = icmp ne ptr %125, null
  br i1 %tobool201, label %if.then202, label %if.end246

if.then202:                                       ; preds = %if.then196
  %126 = load ptr, ptr %dir_ts, align 8
  %call203 = call i64 @temp_arg(ptr noundef %126)
  %127 = load ptr, ptr %op, align 8
  %args204 = getelementptr inbounds %struct.TCGOp, ptr %127, i32 0, i32 4
  %arrayidx205 = getelementptr [0 x i64], ptr %args204, i64 0, i64 0
  store i64 %call203, ptr %arrayidx205, align 8
  store i8 1, ptr %changes, align 1
  %128 = load ptr, ptr %arg_ts, align 8
  %state206 = getelementptr inbounds %struct.TCGTemp, ptr %128, i32 0, i32 5
  store i64 0, ptr %state206, align 8
  %129 = load i32, ptr %arg_life, align 4
  %and207 = and i32 %129, 1
  %tobool208 = icmp ne i32 %and207, 0
  br i1 %tobool208, label %if.then209, label %if.else238

if.then209:                                       ; preds = %if.then202
  %130 = load ptr, ptr %arg_ts, align 8
  %bf.load210 = load i64, ptr %130, align 8
  %bf.lshr211 = lshr i64 %bf.load210, 24
  %bf.clear212 = and i64 %bf.lshr211, 255
  %bf.cast213 = trunc i64 %bf.clear212 to i32
  %cmp214 = icmp eq i32 %bf.cast213, 0
  %cond216 = select i1 %cmp214, i32 16, i32 77
  store i32 %cond216, ptr %sopc, align 4
  %131 = load ptr, ptr %s.addr, align 8
  %132 = load ptr, ptr %op, align 8
  %133 = load i32, ptr %sopc, align 4
  %call217 = call ptr @tcg_op_insert_after(ptr noundef %131, ptr noundef %132, i32 noundef %133, i32 noundef 3)
  store ptr %call217, ptr %sop, align 8
  %134 = load ptr, ptr %dir_ts, align 8
  store ptr %134, ptr %out_ts, align 8
  %135 = load i32, ptr %arg_life, align 4
  %and218 = and i32 %135, 16
  %tobool219 = icmp ne i32 %and218, 0
  br i1 %tobool219, label %if.then220, label %if.else225

if.then220:                                       ; preds = %if.then209
  %136 = load ptr, ptr %op, align 8
  %args221 = getelementptr inbounds %struct.TCGOp, ptr %136, i32 0, i32 4
  %arrayidx222 = getelementptr [0 x i64], ptr %args221, i64 0, i64 1
  %137 = load i64, ptr %arrayidx222, align 8
  %call223 = call ptr @arg_temp(i64 noundef %137)
  store ptr %call223, ptr %out_ts, align 8
  %138 = load ptr, ptr %arg_ts, align 8
  %state224 = getelementptr inbounds %struct.TCGTemp, ptr %138, i32 0, i32 5
  store i64 1, ptr %state224, align 8
  %139 = load ptr, ptr %s.addr, align 8
  %140 = load ptr, ptr %op, align 8
  call void @tcg_op_remove(ptr noundef %139, ptr noundef %140)
  br label %if.end227

if.else225:                                       ; preds = %if.then209
  %141 = load ptr, ptr %arg_ts, align 8
  %state226 = getelementptr inbounds %struct.TCGTemp, ptr %141, i32 0, i32 5
  store i64 2, ptr %state226, align 8
  br label %if.end227

if.end227:                                        ; preds = %if.else225, %if.then220
  %142 = load ptr, ptr %out_ts, align 8
  %call228 = call i64 @temp_arg(ptr noundef %142)
  %143 = load ptr, ptr %sop, align 8
  %args229 = getelementptr inbounds %struct.TCGOp, ptr %143, i32 0, i32 4
  %arrayidx230 = getelementptr [0 x i64], ptr %args229, i64 0, i64 0
  store i64 %call228, ptr %arrayidx230, align 8
  %144 = load ptr, ptr %arg_ts, align 8
  %mem_base231 = getelementptr inbounds %struct.TCGTemp, ptr %144, i32 0, i32 2
  %145 = load ptr, ptr %mem_base231, align 8
  %call232 = call i64 @temp_arg(ptr noundef %145)
  %146 = load ptr, ptr %sop, align 8
  %args233 = getelementptr inbounds %struct.TCGOp, ptr %146, i32 0, i32 4
  %arrayidx234 = getelementptr [0 x i64], ptr %args233, i64 0, i64 1
  store i64 %call232, ptr %arrayidx234, align 8
  %147 = load ptr, ptr %arg_ts, align 8
  %mem_offset235 = getelementptr inbounds %struct.TCGTemp, ptr %147, i32 0, i32 3
  %148 = load i64, ptr %mem_offset235, align 8
  %149 = load ptr, ptr %sop, align 8
  %args236 = getelementptr inbounds %struct.TCGOp, ptr %149, i32 0, i32 4
  %arrayidx237 = getelementptr [0 x i64], ptr %args236, i64 0, i64 2
  store i64 %148, ptr %arrayidx237, align 8
  br label %if.end245

if.else238:                                       ; preds = %if.then202
  br label %do.body239

do.body239:                                       ; preds = %if.else238
  %150 = load i32, ptr %arg_life, align 4
  %and240 = and i32 %150, 16
  %tobool241 = icmp ne i32 %and240, 0
  br i1 %tobool241, label %if.then242, label %if.end243

if.then242:                                       ; preds = %do.body239
  unreachable

if.end243:                                        ; preds = %do.body239
  br label %do.end244

do.end244:                                        ; preds = %if.end243
  br label %if.end245

if.end245:                                        ; preds = %do.end244, %if.end227
  br label %if.end246

if.end246:                                        ; preds = %if.end245, %if.then196
  br label %if.end300

if.else247:                                       ; preds = %lor.lhs.false193
  store i32 0, ptr %i, align 4
  br label %for.cond248

for.cond248:                                      ; preds = %for.inc297, %if.else247
  %151 = load i32, ptr %i, align 4
  %152 = load i32, ptr %nb_oargs, align 4
  %cmp249 = icmp slt i32 %151, %152
  br i1 %cmp249, label %for.body251, label %for.end299

for.body251:                                      ; preds = %for.cond248
  %153 = load ptr, ptr %op, align 8
  %args252 = getelementptr inbounds %struct.TCGOp, ptr %153, i32 0, i32 4
  %154 = load i32, ptr %i, align 4
  %idxprom253 = sext i32 %154 to i64
  %arrayidx254 = getelementptr [0 x i64], ptr %args252, i64 0, i64 %idxprom253
  %155 = load i64, ptr %arrayidx254, align 8
  %call255 = call ptr @arg_temp(i64 noundef %155)
  store ptr %call255, ptr %arg_ts, align 8
  %156 = load ptr, ptr %arg_ts, align 8
  %state_ptr256 = getelementptr inbounds %struct.TCGTemp, ptr %156, i32 0, i32 6
  %157 = load ptr, ptr %state_ptr256, align 8
  store ptr %157, ptr %dir_ts, align 8
  %158 = load ptr, ptr %dir_ts, align 8
  %tobool257 = icmp ne ptr %158, null
  br i1 %tobool257, label %if.end259, label %if.then258

if.then258:                                       ; preds = %for.body251
  br label %for.inc297

if.end259:                                        ; preds = %for.body251
  %159 = load ptr, ptr %dir_ts, align 8
  %call260 = call i64 @temp_arg(ptr noundef %159)
  %160 = load ptr, ptr %op, align 8
  %args261 = getelementptr inbounds %struct.TCGOp, ptr %160, i32 0, i32 4
  %161 = load i32, ptr %i, align 4
  %idxprom262 = sext i32 %161 to i64
  %arrayidx263 = getelementptr [0 x i64], ptr %args261, i64 0, i64 %idxprom262
  store i64 %call260, ptr %arrayidx263, align 8
  store i8 1, ptr %changes, align 1
  %162 = load ptr, ptr %arg_ts, align 8
  %state264 = getelementptr inbounds %struct.TCGTemp, ptr %162, i32 0, i32 5
  store i64 0, ptr %state264, align 8
  %163 = load i32, ptr %arg_life, align 4
  %164 = load i32, ptr %i, align 4
  %shl265 = shl i32 1, %164
  %and266 = and i32 %163, %shl265
  %tobool267 = icmp ne i32 %and266, 0
  br i1 %tobool267, label %if.then268, label %if.end290

if.then268:                                       ; preds = %if.end259
  %165 = load ptr, ptr %arg_ts, align 8
  %bf.load270 = load i64, ptr %165, align 8
  %bf.lshr271 = lshr i64 %bf.load270, 24
  %bf.clear272 = and i64 %bf.lshr271, 255
  %bf.cast273 = trunc i64 %bf.clear272 to i32
  %cmp274 = icmp eq i32 %bf.cast273, 0
  %cond276 = select i1 %cmp274, i32 16, i32 77
  store i32 %cond276, ptr %sopc269, align 4
  %166 = load ptr, ptr %s.addr, align 8
  %167 = load ptr, ptr %op, align 8
  %168 = load i32, ptr %sopc269, align 4
  %call278 = call ptr @tcg_op_insert_after(ptr noundef %166, ptr noundef %167, i32 noundef %168, i32 noundef 3)
  store ptr %call278, ptr %sop277, align 8
  %169 = load ptr, ptr %dir_ts, align 8
  %call279 = call i64 @temp_arg(ptr noundef %169)
  %170 = load ptr, ptr %sop277, align 8
  %args280 = getelementptr inbounds %struct.TCGOp, ptr %170, i32 0, i32 4
  %arrayidx281 = getelementptr [0 x i64], ptr %args280, i64 0, i64 0
  store i64 %call279, ptr %arrayidx281, align 8
  %171 = load ptr, ptr %arg_ts, align 8
  %mem_base282 = getelementptr inbounds %struct.TCGTemp, ptr %171, i32 0, i32 2
  %172 = load ptr, ptr %mem_base282, align 8
  %call283 = call i64 @temp_arg(ptr noundef %172)
  %173 = load ptr, ptr %sop277, align 8
  %args284 = getelementptr inbounds %struct.TCGOp, ptr %173, i32 0, i32 4
  %arrayidx285 = getelementptr [0 x i64], ptr %args284, i64 0, i64 1
  store i64 %call283, ptr %arrayidx285, align 8
  %174 = load ptr, ptr %arg_ts, align 8
  %mem_offset286 = getelementptr inbounds %struct.TCGTemp, ptr %174, i32 0, i32 3
  %175 = load i64, ptr %mem_offset286, align 8
  %176 = load ptr, ptr %sop277, align 8
  %args287 = getelementptr inbounds %struct.TCGOp, ptr %176, i32 0, i32 4
  %arrayidx288 = getelementptr [0 x i64], ptr %args287, i64 0, i64 2
  store i64 %175, ptr %arrayidx288, align 8
  %177 = load ptr, ptr %arg_ts, align 8
  %state289 = getelementptr inbounds %struct.TCGTemp, ptr %177, i32 0, i32 5
  store i64 2, ptr %state289, align 8
  br label %if.end290

if.end290:                                        ; preds = %if.then268, %if.end259
  %178 = load i32, ptr %arg_life, align 4
  %179 = load i32, ptr %i, align 4
  %shl291 = shl i32 16, %179
  %and292 = and i32 %178, %shl291
  %tobool293 = icmp ne i32 %and292, 0
  br i1 %tobool293, label %if.then294, label %if.end296

if.then294:                                       ; preds = %if.end290
  %180 = load ptr, ptr %arg_ts, align 8
  %state295 = getelementptr inbounds %struct.TCGTemp, ptr %180, i32 0, i32 5
  store i64 1, ptr %state295, align 8
  br label %if.end296

if.end296:                                        ; preds = %if.then294, %if.end290
  br label %for.inc297

for.inc297:                                       ; preds = %if.end296, %if.then258
  %181 = load i32, ptr %i, align 4
  %inc298 = add i32 %181, 1
  store i32 %inc298, ptr %i, align 4
  br label %for.cond248, !llvm.loop !61

for.end299:                                       ; preds = %for.cond248
  br label %if.end300

if.end300:                                        ; preds = %for.end299, %if.end246
  br label %for.inc301

for.inc301:                                       ; preds = %if.end300
  %182 = load ptr, ptr %op_next, align 8
  store ptr %182, ptr %op, align 8
  br label %for.cond45, !llvm.loop !62

for.end302:                                       ; preds = %land.end
  %183 = load i8, ptr %changes, align 1
  %tobool303 = trunc i8 %183 to i1
  ret i1 %tobool303
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_reg_alloc_start(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %ts = alloca ptr, align 8
  %val = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 0, ptr %i, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %nb_temps = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 7
  %1 = load i32, ptr %nb_temps, align 8
  store i32 %1, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %n, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 37
  %5 = load i32, ptr %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %ts, align 8
  store i32 2, ptr %val, align 4
  %6 = load ptr, ptr %ts, align 8
  %bf.load = load i64, ptr %6, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  switch i32 %bf.cast, label %sw.default [
    i32 4, label %sw.bb
    i32 3, label %sw.bb1
    i32 2, label %sw.bb2
    i32 0, label %sw.bb3
    i32 1, label %sw.bb4
  ]

sw.bb:                                            ; preds = %for.body
  store i32 3, ptr %val, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %for.body
  store i32 1, ptr %val, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %for.body
  br label %sw.epilog

sw.bb3:                                           ; preds = %for.body
  store i32 0, ptr %val, align 4
  br label %sw.bb4

sw.bb4:                                           ; preds = %sw.bb3, %for.body
  %7 = load ptr, ptr %ts, align 8
  %bf.load5 = load i64, ptr %7, align 8
  %bf.clear6 = and i64 %bf.load5, -274877906945
  %bf.set = or i64 %bf.clear6, 0
  store i64 %bf.set, ptr %7, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 2413, ptr noundef @__func__.tcg_reg_alloc_start, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb4, %sw.bb2, %sw.bb1, %sw.bb
  %8 = load i32, ptr %val, align 4
  %9 = load ptr, ptr %ts, align 8
  %10 = zext i32 %8 to i64
  %bf.load7 = load i64, ptr %9, align 8
  %bf.value = and i64 %10, 255
  %bf.shl = shl i64 %bf.value, 8
  %bf.clear8 = and i64 %bf.load7, -65281
  %bf.set9 = or i64 %bf.clear8, %bf.shl
  store i64 %bf.set9, ptr %9, align 8
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %11 = load i32, ptr %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !63

for.end:                                          ; preds = %for.cond
  %12 = load ptr, ptr %s.addr, align 8
  %reg_to_temp = getelementptr inbounds %struct.TCGContext, ptr %12, i32 0, i32 41
  %arraydecay = getelementptr inbounds [32 x ptr], ptr %reg_to_temp, i64 0, i64 0
  call void @llvm.memset.p0.i64(ptr align 8 %arraydecay, i8 0, i64 256, i1 false)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_splitwx_to_rw(ptr noundef %rx) #0 {
entry:
  %rx.addr = alloca ptr, align 8
  store ptr %rx, ptr %rx.addr, align 8
  %0 = load ptr, ptr %rx.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %rx.addr, align 8
  %2 = load i64, ptr @tcg_splitwx_diff, align 8
  %idx.neg = sub i64 0, %2
  %add.ptr = getelementptr i8, ptr %1, i64 %idx.neg
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %add.ptr, %cond.true ], [ null, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_tb_start(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_reg_alloc_mov(ptr noundef %s, ptr noundef %op) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %arg_life = alloca i32, align 4
  %allocated_regs = alloca i32, align 4
  %preferred_regs = alloca i32, align 4
  %ts = alloca ptr, align 8
  %ots = alloca ptr, align 8
  %otype = alloca i32, align 4
  %itype = alloca i32, align 4
  %oreg = alloca i32, align 4
  %ireg = alloca i32, align 4
  %val = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %life = getelementptr inbounds %struct.TCGOp, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %life, align 4
  store i32 %1, ptr %arg_life, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 16
  %3 = load i32, ptr %reserved_regs, align 4
  store i32 %3, ptr %allocated_regs, align 4
  %4 = load ptr, ptr %op.addr, align 8
  %call = call i32 @output_pref(ptr noundef %4, i32 noundef 0)
  store i32 %call, ptr %preferred_regs, align 4
  %5 = load ptr, ptr %op.addr, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %5, i32 0, i32 4
  %arrayidx = getelementptr [0 x i64], ptr %args, i64 0, i64 0
  %6 = load i64, ptr %arrayidx, align 8
  %call1 = call ptr @arg_temp(i64 noundef %6)
  store ptr %call1, ptr %ots, align 8
  %7 = load ptr, ptr %op.addr, align 8
  %args2 = getelementptr inbounds %struct.TCGOp, ptr %7, i32 0, i32 4
  %arrayidx3 = getelementptr [0 x i64], ptr %args2, i64 0, i64 1
  %8 = load i64, ptr %arrayidx3, align 8
  %call4 = call ptr @arg_temp(i64 noundef %8)
  store ptr %call4, ptr %ts, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %9 = load ptr, ptr %ots, align 8
  %call5 = call zeroext i1 @temp_readonly(ptr noundef %9)
  br i1 %call5, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %10 = load ptr, ptr %ots, align 8
  %bf.load = load i64, ptr %10, align 8
  %bf.lshr = lshr i64 %bf.load, 24
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  store i32 %bf.cast, ptr %otype, align 4
  %11 = load ptr, ptr %ts, align 8
  %bf.load6 = load i64, ptr %11, align 8
  %bf.lshr7 = lshr i64 %bf.load6, 24
  %bf.clear8 = and i64 %bf.lshr7, 255
  %bf.cast9 = trunc i64 %bf.clear8 to i32
  store i32 %bf.cast9, ptr %itype, align 4
  %12 = load ptr, ptr %ts, align 8
  %bf.load10 = load i64, ptr %12, align 8
  %bf.lshr11 = lshr i64 %bf.load10, 8
  %bf.clear12 = and i64 %bf.lshr11, 255
  %bf.cast13 = trunc i64 %bf.clear12 to i32
  %cmp = icmp eq i32 %bf.cast13, 3
  br i1 %cmp, label %if.then14, label %if.end18

if.then14:                                        ; preds = %do.end
  %13 = load ptr, ptr %ts, align 8
  %val15 = getelementptr inbounds %struct.TCGTemp, ptr %13, i32 0, i32 1
  %14 = load i64, ptr %val15, align 8
  store i64 %14, ptr %val, align 8
  %15 = load i32, ptr %arg_life, align 4
  %and = and i32 %15, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then14
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load ptr, ptr %ts, align 8
  call void @temp_dead(ptr noundef %16, ptr noundef %17)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.then14
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load ptr, ptr %ots, align 8
  %20 = load i64, ptr %val, align 8
  %21 = load i32, ptr %arg_life, align 4
  %22 = load i32, ptr %preferred_regs, align 4
  call void @tcg_reg_alloc_do_movi(ptr noundef %18, ptr noundef %19, i64 noundef %20, i32 noundef %21, i32 noundef %22)
  br label %if.end122

if.end18:                                         ; preds = %do.end
  %23 = load ptr, ptr %ts, align 8
  %bf.load19 = load i64, ptr %23, align 8
  %bf.lshr20 = lshr i64 %bf.load19, 8
  %bf.clear21 = and i64 %bf.lshr20, 255
  %bf.cast22 = trunc i64 %bf.clear21 to i32
  %cmp23 = icmp eq i32 %bf.cast22, 2
  br i1 %cmp23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end18
  %24 = load ptr, ptr %s.addr, align 8
  %25 = load ptr, ptr %ts, align 8
  %26 = load i32, ptr %itype, align 4
  %idxprom = zext i32 %26 to i64
  %arrayidx25 = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom
  %27 = load i32, ptr %arrayidx25, align 4
  %28 = load i32, ptr %allocated_regs, align 4
  %29 = load i32, ptr %preferred_regs, align 4
  call void @temp_load(ptr noundef %24, ptr noundef %25, i32 noundef %27, i32 noundef %28, i32 noundef %29)
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end18
  br label %do.body27

do.body27:                                        ; preds = %if.end26
  %30 = load ptr, ptr %ts, align 8
  %bf.load28 = load i64, ptr %30, align 8
  %bf.lshr29 = lshr i64 %bf.load28, 8
  %bf.clear30 = and i64 %bf.lshr29, 255
  %bf.cast31 = trunc i64 %bf.clear30 to i32
  %cmp32 = icmp eq i32 %bf.cast31, 1
  br i1 %cmp32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %do.body27
  unreachable

if.end34:                                         ; preds = %do.body27
  br label %do.end35

do.end35:                                         ; preds = %if.end34
  %31 = load ptr, ptr %ts, align 8
  %bf.load36 = load i64, ptr %31, align 8
  %bf.clear37 = and i64 %bf.load36, 255
  %bf.cast38 = trunc i64 %bf.clear37 to i32
  store i32 %bf.cast38, ptr %ireg, align 4
  %32 = load i32, ptr %arg_life, align 4
  %and39 = and i32 %32, 16
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then41, label %if.end62

if.then41:                                        ; preds = %do.end35
  br label %do.body42

do.body42:                                        ; preds = %if.then41
  %33 = load i32, ptr %arg_life, align 4
  %and43 = and i32 %33, 1
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.end46, label %if.then45

if.then45:                                        ; preds = %do.body42
  unreachable

if.end46:                                         ; preds = %do.body42
  br label %do.end47

do.end47:                                         ; preds = %if.end46
  %34 = load ptr, ptr %ots, align 8
  %bf.load48 = load i64, ptr %34, align 8
  %bf.lshr49 = lshr i64 %bf.load48, 38
  %bf.clear50 = and i64 %bf.lshr49, 1
  %bf.cast51 = trunc i64 %bf.clear50 to i32
  %tobool52 = icmp ne i32 %bf.cast51, 0
  br i1 %tobool52, label %if.end54, label %if.then53

if.then53:                                        ; preds = %do.end47
  %35 = load ptr, ptr %s.addr, align 8
  %36 = load ptr, ptr %ots, align 8
  call void @temp_allocate_frame(ptr noundef %35, ptr noundef %36)
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %do.end47
  %37 = load ptr, ptr %s.addr, align 8
  %38 = load i32, ptr %otype, align 4
  %39 = load i32, ptr %ireg, align 4
  %40 = load ptr, ptr %ots, align 8
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %40, i32 0, i32 2
  %41 = load ptr, ptr %mem_base, align 8
  %bf.load55 = load i64, ptr %41, align 8
  %bf.clear56 = and i64 %bf.load55, 255
  %bf.cast57 = trunc i64 %bf.clear56 to i32
  %42 = load ptr, ptr %ots, align 8
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %42, i32 0, i32 3
  %43 = load i64, ptr %mem_offset, align 8
  call void @tcg_out_st(ptr noundef %37, i32 noundef %38, i32 noundef %39, i32 noundef %bf.cast57, i64 noundef %43)
  %44 = load i32, ptr %arg_life, align 4
  %and58 = and i32 %44, 32
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end54
  %45 = load ptr, ptr %s.addr, align 8
  %46 = load ptr, ptr %ts, align 8
  call void @temp_dead(ptr noundef %45, ptr noundef %46)
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %if.end54
  %47 = load ptr, ptr %s.addr, align 8
  %48 = load ptr, ptr %ots, align 8
  call void @temp_dead(ptr noundef %47, ptr noundef %48)
  br label %if.end122

if.end62:                                         ; preds = %do.end35
  %49 = load i32, ptr %arg_life, align 4
  %and63 = and i32 %49, 32
  %tobool64 = icmp ne i32 %and63, 0
  br i1 %tobool64, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end62
  %50 = load ptr, ptr %ts, align 8
  %bf.load65 = load i64, ptr %50, align 8
  %bf.lshr66 = lshr i64 %bf.load65, 32
  %bf.clear67 = and i64 %bf.lshr66, 7
  %bf.cast68 = trunc i64 %bf.clear67 to i32
  %cmp69 = icmp ne i32 %bf.cast68, 3
  br i1 %cmp69, label %if.then70, label %if.else

if.then70:                                        ; preds = %land.lhs.true
  %51 = load ptr, ptr %s.addr, align 8
  %52 = load ptr, ptr %ts, align 8
  call void @temp_dead(ptr noundef %51, ptr noundef %52)
  %53 = load i32, ptr %ireg, align 4
  store i32 %53, ptr %oreg, align 4
  br label %if.end115

if.else:                                          ; preds = %land.lhs.true, %if.end62
  %54 = load ptr, ptr %ots, align 8
  %bf.load71 = load i64, ptr %54, align 8
  %bf.lshr72 = lshr i64 %bf.load71, 8
  %bf.clear73 = and i64 %bf.lshr72, 255
  %bf.cast74 = trunc i64 %bf.clear73 to i32
  %cmp75 = icmp eq i32 %bf.cast74, 1
  br i1 %cmp75, label %if.then76, label %if.else80

if.then76:                                        ; preds = %if.else
  %55 = load ptr, ptr %ots, align 8
  %bf.load77 = load i64, ptr %55, align 8
  %bf.clear78 = and i64 %bf.load77, 255
  %bf.cast79 = trunc i64 %bf.clear78 to i32
  store i32 %bf.cast79, ptr %oreg, align 4
  br label %if.end89

if.else80:                                        ; preds = %if.else
  %56 = load ptr, ptr %s.addr, align 8
  %57 = load i32, ptr %otype, align 4
  %idxprom81 = zext i32 %57 to i64
  %arrayidx82 = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom81
  %58 = load i32, ptr %arrayidx82, align 4
  %59 = load i32, ptr %allocated_regs, align 4
  %60 = load i32, ptr %ireg, align 4
  %shl = shl i32 1, %60
  %or = or i32 %59, %shl
  %61 = load i32, ptr %preferred_regs, align 4
  %62 = load ptr, ptr %ots, align 8
  %bf.load83 = load i64, ptr %62, align 8
  %bf.lshr84 = lshr i64 %bf.load83, 36
  %bf.clear85 = and i64 %bf.lshr84, 1
  %bf.cast86 = trunc i64 %bf.clear85 to i32
  %tobool87 = icmp ne i32 %bf.cast86, 0
  %call88 = call i32 @tcg_reg_alloc(ptr noundef %56, i32 noundef %58, i32 noundef %or, i32 noundef %61, i1 noundef zeroext %tobool87)
  store i32 %call88, ptr %oreg, align 4
  br label %if.end89

if.end89:                                         ; preds = %if.else80, %if.then76
  %63 = load ptr, ptr %s.addr, align 8
  %64 = load i32, ptr %otype, align 4
  %65 = load i32, ptr %oreg, align 4
  %66 = load i32, ptr %ireg, align 4
  %call90 = call zeroext i1 @tcg_out_mov(ptr noundef %63, i32 noundef %64, i32 noundef %65, i32 noundef %66)
  br i1 %call90, label %if.end114, label %if.then91

if.then91:                                        ; preds = %if.end89
  %67 = load ptr, ptr %ots, align 8
  %call92 = call zeroext i1 @temp_readonly(ptr noundef %67)
  br i1 %call92, label %if.else94, label %if.then93

if.then93:                                        ; preds = %if.then91
  br label %if.end95

if.else94:                                        ; preds = %if.then91
  call void @__assert_fail(ptr noundef @.str.126, ptr noundef @.str.1, i32 noundef 4638, ptr noundef @__PRETTY_FUNCTION__.tcg_reg_alloc_mov) #19
  unreachable

if.end95:                                         ; preds = %if.then93
  %68 = load ptr, ptr %ts, align 8
  %bf.load96 = load i64, ptr %68, align 8
  %bf.lshr97 = lshr i64 %bf.load96, 38
  %bf.clear98 = and i64 %bf.lshr97, 1
  %bf.cast99 = trunc i64 %bf.clear98 to i32
  %tobool100 = icmp ne i32 %bf.cast99, 0
  br i1 %tobool100, label %if.end102, label %if.then101

if.then101:                                       ; preds = %if.end95
  %69 = load ptr, ptr %s.addr, align 8
  %70 = load ptr, ptr %ots, align 8
  call void @temp_allocate_frame(ptr noundef %69, ptr noundef %70)
  br label %if.end102

if.end102:                                        ; preds = %if.then101, %if.end95
  %71 = load ptr, ptr %s.addr, align 8
  %72 = load ptr, ptr %ts, align 8
  %bf.load103 = load i64, ptr %72, align 8
  %bf.lshr104 = lshr i64 %bf.load103, 24
  %bf.clear105 = and i64 %bf.lshr104, 255
  %bf.cast106 = trunc i64 %bf.clear105 to i32
  %73 = load i32, ptr %ireg, align 4
  %74 = load ptr, ptr %ots, align 8
  %mem_base107 = getelementptr inbounds %struct.TCGTemp, ptr %74, i32 0, i32 2
  %75 = load ptr, ptr %mem_base107, align 8
  %bf.load108 = load i64, ptr %75, align 8
  %bf.clear109 = and i64 %bf.load108, 255
  %bf.cast110 = trunc i64 %bf.clear109 to i32
  %76 = load ptr, ptr %ots, align 8
  %mem_offset111 = getelementptr inbounds %struct.TCGTemp, ptr %76, i32 0, i32 3
  %77 = load i64, ptr %mem_offset111, align 8
  call void @tcg_out_st(ptr noundef %71, i32 noundef %bf.cast106, i32 noundef %73, i32 noundef %bf.cast110, i64 noundef %77)
  %78 = load ptr, ptr %s.addr, align 8
  %79 = load ptr, ptr %ts, align 8
  call void @set_temp_val_nonreg(ptr noundef %78, ptr noundef %79, i32 noundef 2)
  %80 = load ptr, ptr %ots, align 8
  %bf.load112 = load i64, ptr %80, align 8
  %bf.clear113 = and i64 %bf.load112, -137438953473
  %bf.set = or i64 %bf.clear113, 137438953472
  store i64 %bf.set, ptr %80, align 8
  br label %if.end122

if.end114:                                        ; preds = %if.end89
  br label %if.end115

if.end115:                                        ; preds = %if.end114, %if.then70
  %81 = load ptr, ptr %s.addr, align 8
  %82 = load ptr, ptr %ots, align 8
  %83 = load i32, ptr %oreg, align 4
  call void @set_temp_val_reg(ptr noundef %81, ptr noundef %82, i32 noundef %83)
  %84 = load ptr, ptr %ots, align 8
  %bf.load116 = load i64, ptr %84, align 8
  %bf.clear117 = and i64 %bf.load116, -137438953473
  %bf.set118 = or i64 %bf.clear117, 0
  store i64 %bf.set118, ptr %84, align 8
  %85 = load i32, ptr %arg_life, align 4
  %and119 = and i32 %85, 1
  %tobool120 = icmp ne i32 %and119, 0
  br i1 %tobool120, label %if.then121, label %if.end122

if.then121:                                       ; preds = %if.end115
  %86 = load ptr, ptr %s.addr, align 8
  %87 = load ptr, ptr %ots, align 8
  %88 = load i32, ptr %allocated_regs, align 4
  call void @temp_sync(ptr noundef %86, ptr noundef %87, i32 noundef %88, i32 noundef 0, i32 noundef 0)
  br label %if.end122

if.end122:                                        ; preds = %if.then121, %if.end115, %if.end102, %if.end61, %if.end17
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_reg_alloc_dup(ptr noundef %s, ptr noundef %op) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %arg_life = alloca i32, align 4
  %dup_out_regs = alloca i32, align 4
  %dup_in_regs = alloca i32, align 4
  %its = alloca ptr, align 8
  %ots = alloca ptr, align 8
  %itype = alloca i32, align 4
  %vtype = alloca i32, align 4
  %vece = alloca i32, align 4
  %lowpart_ofs = alloca i32, align 4
  %ok = alloca i8, align 1
  %val = alloca i64, align 8
  %allocated_regs = alloca i32, align 4
  %oreg = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %life = getelementptr inbounds %struct.TCGOp, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %life, align 4
  store i32 %1, ptr %arg_life, align 4
  %2 = load ptr, ptr %op.addr, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %2, i32 0, i32 4
  %arrayidx = getelementptr [0 x i64], ptr %args, i64 0, i64 0
  %3 = load i64, ptr %arrayidx, align 8
  %call = call ptr @arg_temp(i64 noundef %3)
  store ptr %call, ptr %ots, align 8
  %4 = load ptr, ptr %op.addr, align 8
  %args1 = getelementptr inbounds %struct.TCGOp, ptr %4, i32 0, i32 4
  %arrayidx2 = getelementptr [0 x i64], ptr %args1, i64 0, i64 1
  %5 = load i64, ptr %arrayidx2, align 8
  %call3 = call ptr @arg_temp(i64 noundef %5)
  store ptr %call3, ptr %its, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %6 = load ptr, ptr %ots, align 8
  %call4 = call zeroext i1 @temp_readonly(ptr noundef %6)
  br i1 %call4, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %7 = load ptr, ptr %its, align 8
  %bf.load = load i64, ptr %7, align 8
  %bf.lshr = lshr i64 %bf.load, 24
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  store i32 %bf.cast, ptr %itype, align 4
  %8 = load ptr, ptr %op.addr, align 8
  %bf.load5 = load i32, ptr %8, align 8
  %bf.lshr6 = lshr i32 %bf.load5, 24
  store i32 %bf.lshr6, ptr %vece, align 4
  %9 = load ptr, ptr %op.addr, align 8
  %bf.load7 = load i32, ptr %9, align 8
  %bf.lshr8 = lshr i32 %bf.load7, 16
  %bf.clear9 = and i32 %bf.lshr8, 255
  %add = add i32 %bf.clear9, 3
  store i32 %add, ptr %vtype, align 4
  %10 = load ptr, ptr %its, align 8
  %bf.load10 = load i64, ptr %10, align 8
  %bf.lshr11 = lshr i64 %bf.load10, 8
  %bf.clear12 = and i64 %bf.lshr11, 255
  %bf.cast13 = trunc i64 %bf.clear12 to i32
  %cmp = icmp eq i32 %bf.cast13, 3
  br i1 %cmp, label %if.then14, label %if.end19

if.then14:                                        ; preds = %do.end
  %11 = load ptr, ptr %its, align 8
  %val15 = getelementptr inbounds %struct.TCGTemp, ptr %11, i32 0, i32 1
  %12 = load i64, ptr %val15, align 8
  store i64 %12, ptr %val, align 8
  %13 = load i32, ptr %arg_life, align 4
  %and = and i32 %13, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then14
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load ptr, ptr %its, align 8
  call void @temp_dead(ptr noundef %14, ptr noundef %15)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.then14
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load ptr, ptr %ots, align 8
  %18 = load i64, ptr %val, align 8
  %19 = load i32, ptr %arg_life, align 4
  %20 = load ptr, ptr %op.addr, align 8
  %call18 = call i32 @output_pref(ptr noundef %20, i32 noundef 0)
  call void @tcg_reg_alloc_do_movi(ptr noundef %16, ptr noundef %17, i64 noundef %18, i32 noundef %19, i32 noundef %call18)
  br label %if.end133

if.end19:                                         ; preds = %do.end
  %21 = load ptr, ptr getelementptr ([0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 150, i32 6), align 8
  %arrayidx20 = getelementptr %struct.TCGArgConstraint, ptr %21, i64 0
  %regs = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx20, i32 0, i32 1
  %22 = load i32, ptr %regs, align 4
  store i32 %22, ptr %dup_out_regs, align 4
  %23 = load ptr, ptr getelementptr ([0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 150, i32 6), align 8
  %arrayidx21 = getelementptr %struct.TCGArgConstraint, ptr %23, i64 1
  %regs22 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx21, i32 0, i32 1
  %24 = load i32, ptr %regs22, align 4
  store i32 %24, ptr %dup_in_regs, align 4
  %25 = load ptr, ptr %ots, align 8
  %bf.load23 = load i64, ptr %25, align 8
  %bf.lshr24 = lshr i64 %bf.load23, 8
  %bf.clear25 = and i64 %bf.lshr24, 255
  %bf.cast26 = trunc i64 %bf.clear25 to i32
  %cmp27 = icmp ne i32 %bf.cast26, 1
  br i1 %cmp27, label %if.then28, label %if.end48

if.then28:                                        ; preds = %if.end19
  %26 = load ptr, ptr %s.addr, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %26, i32 0, i32 16
  %27 = load i32, ptr %reserved_regs, align 4
  store i32 %27, ptr %allocated_regs, align 4
  %28 = load i32, ptr %arg_life, align 4
  %and29 = and i32 %28, 32
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.end40, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then28
  %29 = load ptr, ptr %its, align 8
  %bf.load31 = load i64, ptr %29, align 8
  %bf.lshr32 = lshr i64 %bf.load31, 8
  %bf.clear33 = and i64 %bf.lshr32, 255
  %bf.cast34 = trunc i64 %bf.clear33 to i32
  %cmp35 = icmp eq i32 %bf.cast34, 1
  br i1 %cmp35, label %if.then36, label %if.end40

if.then36:                                        ; preds = %land.lhs.true
  %30 = load ptr, ptr %its, align 8
  %bf.load37 = load i64, ptr %30, align 8
  %bf.clear38 = and i64 %bf.load37, 255
  %bf.cast39 = trunc i64 %bf.clear38 to i32
  %shl = shl i32 1, %bf.cast39
  %31 = load i32, ptr %allocated_regs, align 4
  %or = or i32 %31, %shl
  store i32 %or, ptr %allocated_regs, align 4
  br label %if.end40

if.end40:                                         ; preds = %if.then36, %land.lhs.true, %if.then28
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load i32, ptr %dup_out_regs, align 4
  %34 = load i32, ptr %allocated_regs, align 4
  %35 = load ptr, ptr %op.addr, align 8
  %call41 = call i32 @output_pref(ptr noundef %35, i32 noundef 0)
  %36 = load ptr, ptr %ots, align 8
  %bf.load42 = load i64, ptr %36, align 8
  %bf.lshr43 = lshr i64 %bf.load42, 36
  %bf.clear44 = and i64 %bf.lshr43, 1
  %bf.cast45 = trunc i64 %bf.clear44 to i32
  %tobool46 = icmp ne i32 %bf.cast45, 0
  %call47 = call i32 @tcg_reg_alloc(ptr noundef %32, i32 noundef %33, i32 noundef %34, i32 noundef %call41, i1 noundef zeroext %tobool46)
  store i32 %call47, ptr %oreg, align 4
  %37 = load ptr, ptr %s.addr, align 8
  %38 = load ptr, ptr %ots, align 8
  %39 = load i32, ptr %oreg, align 4
  call void @set_temp_val_reg(ptr noundef %37, ptr noundef %38, i32 noundef %39)
  br label %if.end48

if.end48:                                         ; preds = %if.end40, %if.end19
  %40 = load ptr, ptr %its, align 8
  %bf.load49 = load i64, ptr %40, align 8
  %bf.lshr50 = lshr i64 %bf.load49, 8
  %bf.clear51 = and i64 %bf.lshr50, 255
  %bf.cast52 = trunc i64 %bf.clear51 to i32
  switch i32 %bf.cast52, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb86
  ]

sw.bb:                                            ; preds = %if.end48
  %41 = load i32, ptr %dup_in_regs, align 4
  %42 = load ptr, ptr %its, align 8
  %bf.load53 = load i64, ptr %42, align 8
  %bf.clear54 = and i64 %bf.load53, 255
  %bf.cast55 = trunc i64 %bf.clear54 to i32
  %shr = lshr i32 %41, %bf.cast55
  %and56 = and i32 %shr, 1
  %tobool57 = icmp ne i32 %and56, 0
  br i1 %tobool57, label %if.then58, label %if.end68

if.then58:                                        ; preds = %sw.bb
  %43 = load ptr, ptr %s.addr, align 8
  %44 = load i32, ptr %vtype, align 4
  %45 = load i32, ptr %vece, align 4
  %46 = load ptr, ptr %ots, align 8
  %bf.load59 = load i64, ptr %46, align 8
  %bf.clear60 = and i64 %bf.load59, 255
  %bf.cast61 = trunc i64 %bf.clear60 to i32
  %47 = load ptr, ptr %its, align 8
  %bf.load62 = load i64, ptr %47, align 8
  %bf.clear63 = and i64 %bf.load62, 255
  %bf.cast64 = trunc i64 %bf.clear63 to i32
  %call65 = call zeroext i1 @tcg_out_dup_vec(ptr noundef %43, i32 noundef %44, i32 noundef %45, i32 noundef %bf.cast61, i32 noundef %bf.cast64)
  br i1 %call65, label %if.then66, label %if.end67

if.then66:                                        ; preds = %if.then58
  br label %done

if.end67:                                         ; preds = %if.then58
  br label %if.end68

if.end68:                                         ; preds = %if.end67, %sw.bb
  %48 = load ptr, ptr %its, align 8
  %bf.load69 = load i64, ptr %48, align 8
  %bf.lshr70 = lshr i64 %bf.load69, 37
  %bf.clear71 = and i64 %bf.lshr70, 1
  %bf.cast72 = trunc i64 %bf.clear71 to i32
  %tobool73 = icmp ne i32 %bf.cast72, 0
  br i1 %tobool73, label %if.end85, label %if.then74

if.then74:                                        ; preds = %if.end68
  %49 = load ptr, ptr %s.addr, align 8
  %50 = load i32, ptr %itype, align 4
  %51 = load ptr, ptr %ots, align 8
  %bf.load75 = load i64, ptr %51, align 8
  %bf.clear76 = and i64 %bf.load75, 255
  %bf.cast77 = trunc i64 %bf.clear76 to i32
  %52 = load ptr, ptr %its, align 8
  %bf.load78 = load i64, ptr %52, align 8
  %bf.clear79 = and i64 %bf.load78, 255
  %bf.cast80 = trunc i64 %bf.clear79 to i32
  %call81 = call zeroext i1 @tcg_out_mov(ptr noundef %49, i32 noundef %50, i32 noundef %bf.cast77, i32 noundef %bf.cast80)
  br i1 %call81, label %if.then82, label %if.end83

if.then82:                                        ; preds = %if.then74
  br label %sw.epilog

if.end83:                                         ; preds = %if.then74
  %53 = load ptr, ptr %s.addr, align 8
  %54 = load ptr, ptr %its, align 8
  %55 = load ptr, ptr %s.addr, align 8
  %reserved_regs84 = getelementptr inbounds %struct.TCGContext, ptr %55, i32 0, i32 16
  %56 = load i32, ptr %reserved_regs84, align 4
  call void @temp_sync(ptr noundef %53, ptr noundef %54, i32 noundef %56, i32 noundef 0, i32 noundef 0)
  br label %if.end85

if.end85:                                         ; preds = %if.end83, %if.end68
  br label %sw.bb86

sw.bb86:                                          ; preds = %if.end85, %if.end48
  store i32 0, ptr %lowpart_ofs, align 4
  %57 = load ptr, ptr %s.addr, align 8
  %58 = load i32, ptr %vtype, align 4
  %59 = load i32, ptr %vece, align 4
  %60 = load ptr, ptr %ots, align 8
  %bf.load87 = load i64, ptr %60, align 8
  %bf.clear88 = and i64 %bf.load87, 255
  %bf.cast89 = trunc i64 %bf.clear88 to i32
  %61 = load ptr, ptr %its, align 8
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %61, i32 0, i32 2
  %62 = load ptr, ptr %mem_base, align 8
  %bf.load90 = load i64, ptr %62, align 8
  %bf.clear91 = and i64 %bf.load90, 255
  %bf.cast92 = trunc i64 %bf.clear91 to i32
  %63 = load ptr, ptr %its, align 8
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %63, i32 0, i32 3
  %64 = load i64, ptr %mem_offset, align 8
  %65 = load i32, ptr %lowpart_ofs, align 4
  %conv = sext i32 %65 to i64
  %add93 = add i64 %64, %conv
  %call94 = call zeroext i1 @tcg_out_dupm_vec(ptr noundef %57, i32 noundef %58, i32 noundef %59, i32 noundef %bf.cast89, i32 noundef %bf.cast92, i64 noundef %add93)
  br i1 %call94, label %if.then95, label %if.end96

if.then95:                                        ; preds = %sw.bb86
  br label %done

if.end96:                                         ; preds = %sw.bb86
  %66 = load ptr, ptr %s.addr, align 8
  %67 = load i32, ptr %itype, align 4
  %68 = load ptr, ptr %ots, align 8
  %bf.load97 = load i64, ptr %68, align 8
  %bf.clear98 = and i64 %bf.load97, 255
  %bf.cast99 = trunc i64 %bf.clear98 to i32
  %69 = load ptr, ptr %its, align 8
  %mem_base100 = getelementptr inbounds %struct.TCGTemp, ptr %69, i32 0, i32 2
  %70 = load ptr, ptr %mem_base100, align 8
  %bf.load101 = load i64, ptr %70, align 8
  %bf.clear102 = and i64 %bf.load101, 255
  %bf.cast103 = trunc i64 %bf.clear102 to i32
  %71 = load ptr, ptr %its, align 8
  %mem_offset104 = getelementptr inbounds %struct.TCGTemp, ptr %71, i32 0, i32 3
  %72 = load i64, ptr %mem_offset104, align 8
  call void @tcg_out_ld(ptr noundef %66, i32 noundef %67, i32 noundef %bf.cast99, i32 noundef %bf.cast103, i64 noundef %72)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end48
  br label %do.body105

do.body105:                                       ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 4747, ptr noundef @__func__.tcg_reg_alloc_dup, ptr noundef null) #15
  unreachable

do.end106:                                        ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end106, %if.end96, %if.then82
  %73 = load ptr, ptr %s.addr, align 8
  %74 = load i32, ptr %vtype, align 4
  %75 = load i32, ptr %vece, align 4
  %76 = load ptr, ptr %ots, align 8
  %bf.load107 = load i64, ptr %76, align 8
  %bf.clear108 = and i64 %bf.load107, 255
  %bf.cast109 = trunc i64 %bf.clear108 to i32
  %77 = load ptr, ptr %ots, align 8
  %bf.load110 = load i64, ptr %77, align 8
  %bf.clear111 = and i64 %bf.load110, 255
  %bf.cast112 = trunc i64 %bf.clear111 to i32
  %call113 = call zeroext i1 @tcg_out_dup_vec(ptr noundef %73, i32 noundef %74, i32 noundef %75, i32 noundef %bf.cast109, i32 noundef %bf.cast112)
  %frombool = zext i1 %call113 to i8
  store i8 %frombool, ptr %ok, align 1
  br label %do.body114

do.body114:                                       ; preds = %sw.epilog
  %78 = load i8, ptr %ok, align 1
  %tobool115 = trunc i8 %78 to i1
  br i1 %tobool115, label %if.end117, label %if.then116

if.then116:                                       ; preds = %do.body114
  unreachable

if.end117:                                        ; preds = %do.body114
  br label %do.end118

do.end118:                                        ; preds = %if.end117
  br label %done

done:                                             ; preds = %do.end118, %if.then95, %if.then66
  %79 = load ptr, ptr %ots, align 8
  %bf.load119 = load i64, ptr %79, align 8
  %bf.clear120 = and i64 %bf.load119, -137438953473
  %bf.set = or i64 %bf.clear120, 0
  store i64 %bf.set, ptr %79, align 8
  %80 = load i32, ptr %arg_life, align 4
  %and121 = and i32 %80, 32
  %tobool122 = icmp ne i32 %and121, 0
  br i1 %tobool122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %done
  %81 = load ptr, ptr %s.addr, align 8
  %82 = load ptr, ptr %its, align 8
  call void @temp_dead(ptr noundef %81, ptr noundef %82)
  br label %if.end124

if.end124:                                        ; preds = %if.then123, %done
  %83 = load i32, ptr %arg_life, align 4
  %and125 = and i32 %83, 1
  %tobool126 = icmp ne i32 %and125, 0
  br i1 %tobool126, label %if.then127, label %if.end129

if.then127:                                       ; preds = %if.end124
  %84 = load ptr, ptr %s.addr, align 8
  %85 = load ptr, ptr %ots, align 8
  %86 = load ptr, ptr %s.addr, align 8
  %reserved_regs128 = getelementptr inbounds %struct.TCGContext, ptr %86, i32 0, i32 16
  %87 = load i32, ptr %reserved_regs128, align 4
  call void @temp_sync(ptr noundef %84, ptr noundef %85, i32 noundef %87, i32 noundef 0, i32 noundef 0)
  br label %if.end129

if.end129:                                        ; preds = %if.then127, %if.end124
  %88 = load i32, ptr %arg_life, align 4
  %and130 = and i32 %88, 16
  %tobool131 = icmp ne i32 %and130, 0
  br i1 %tobool131, label %if.then132, label %if.end133

if.then132:                                       ; preds = %if.end129
  %89 = load ptr, ptr %s.addr, align 8
  %90 = load ptr, ptr %ots, align 8
  call void @temp_dead(ptr noundef %89, ptr noundef %90)
  br label %if.end133

if.end133:                                        ; preds = %if.then132, %if.end129, %if.end17
  ret void
}

; Function Attrs: noreturn nounwind
declare void @__assert_fail(ptr noundef, ptr noundef, i32 noundef, ptr noundef) #10

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @tcg_get_insn_start_param(ptr noundef %op, i32 noundef %arg) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %arg.addr = alloca i32, align 4
  store ptr %op, ptr %op.addr, align 8
  store i32 %arg, ptr %arg.addr, align 4
  %0 = load ptr, ptr %op.addr, align 8
  %1 = load i32, ptr %arg.addr, align 4
  %call = call i64 @tcg_get_insn_param(ptr noundef %0, i32 noundef %1)
  ret i64 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @temp_dead(ptr noundef %s, ptr noundef %ts) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ts.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %ts.addr, align 8
  call void @temp_free_or_dead(ptr noundef %0, ptr noundef %1, i32 noundef 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_reg_alloc_bb_end(ptr noundef %s, i32 noundef %allocated_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %allocated_regs.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %ts = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %nb_globals = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %nb_globals, align 4
  store i32 %1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %nb_temps = getelementptr inbounds %struct.TCGContext, ptr %3, i32 0, i32 7
  %4 = load i32, ptr %nb_temps, align 8
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %5, i32 0, i32 37
  %6 = load i32, ptr %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %ts, align 8
  %7 = load ptr, ptr %ts, align 8
  %bf.load = load i64, ptr %7, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  switch i32 %bf.cast, label %sw.default [
    i32 1, label %sw.bb
    i32 0, label %sw.bb1
    i32 4, label %sw.bb7
  ]

sw.bb:                                            ; preds = %for.body
  %8 = load ptr, ptr %s.addr, align 8
  %9 = load ptr, ptr %ts, align 8
  %10 = load i32, ptr %allocated_regs.addr, align 4
  call void @temp_save(ptr noundef %8, ptr noundef %9, i32 noundef %10)
  br label %sw.epilog

sw.bb1:                                           ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %sw.bb1
  %11 = load ptr, ptr %ts, align 8
  %bf.load2 = load i64, ptr %11, align 8
  %bf.lshr3 = lshr i64 %bf.load2, 8
  %bf.clear4 = and i64 %bf.lshr3, 255
  %bf.cast5 = trunc i64 %bf.clear4 to i32
  %cmp6 = icmp eq i32 %bf.cast5, 0
  br i1 %cmp6, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %sw.epilog

sw.bb7:                                           ; preds = %for.body
  br label %do.body8

do.body8:                                         ; preds = %sw.bb7
  %12 = load ptr, ptr %ts, align 8
  %bf.load9 = load i64, ptr %12, align 8
  %bf.lshr10 = lshr i64 %bf.load9, 8
  %bf.clear11 = and i64 %bf.lshr10, 255
  %bf.cast12 = trunc i64 %bf.clear11 to i32
  %cmp13 = icmp eq i32 %bf.cast12, 3
  br i1 %cmp13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %do.body8
  unreachable

if.end15:                                         ; preds = %do.body8
  br label %do.end16

do.end16:                                         ; preds = %if.end15
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  br label %do.body17

do.body17:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 4500, ptr noundef @__func__.tcg_reg_alloc_bb_end, ptr noundef null) #15
  unreachable

do.end18:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end18, %do.end16, %do.end, %sw.bb
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !64

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load i32, ptr %allocated_regs.addr, align 4
  call void @save_globals(ptr noundef %14, i32 noundef %15)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_label(ptr noundef %s, ptr noundef %l) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %l.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %l, ptr %l.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load ptr, ptr %l.addr, align 8
  %has_value = getelementptr inbounds %struct.TCGLabel, ptr %0, i32 0, i32 1
  %1 = load i8, ptr %has_value, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %l.addr, align 8
  %has_value1 = getelementptr inbounds %struct.TCGLabel, ptr %2, i32 0, i32 1
  store i8 1, ptr %has_value1, align 1
  %3 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %3, i32 0, i32 23
  %4 = load ptr, ptr %code_ptr, align 8
  %call = call ptr @tcg_splitwx_to_rx(ptr noundef %4)
  %5 = load ptr, ptr %l.addr, align 8
  %u = getelementptr inbounds %struct.TCGLabel, ptr %5, i32 0, i32 3
  store ptr %call, ptr %u, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @arg_label(i64 noundef %i) #0 {
entry:
  %i.addr = alloca i64, align 8
  store i64 %i, ptr %i.addr, align 8
  %0 = load i64, ptr %i.addr, align 8
  %1 = inttoptr i64 %0 to ptr
  ret ptr %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_reg_alloc_call(ptr noundef %s, ptr noundef %op) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %nb_oargs = alloca i32, align 4
  %nb_iargs = alloca i32, align 4
  %arg_life = alloca i32, align 4
  %info = alloca ptr, align 8
  %allocated_regs = alloca i32, align 4
  %i = alloca i32, align 4
  %loc = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %ts68 = alloca ptr, align 8
  %ts93 = alloca ptr, align 8
  %reg = alloca i32, align 4
  %ts110 = alloca ptr, align 8
  %ts152 = alloca ptr, align 8
  %ts171 = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %bf.load = load i32, ptr %0, align 8
  %bf.lshr = lshr i32 %bf.load, 24
  store i32 %bf.lshr, ptr %nb_oargs, align 4
  %1 = load ptr, ptr %op.addr, align 8
  %bf.load1 = load i32, ptr %1, align 8
  %bf.lshr2 = lshr i32 %bf.load1, 16
  %bf.clear = and i32 %bf.lshr2, 255
  store i32 %bf.clear, ptr %nb_iargs, align 4
  %2 = load ptr, ptr %op.addr, align 8
  %life = getelementptr inbounds %struct.TCGOp, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %life, align 4
  store i32 %3, ptr %arg_life, align 4
  %4 = load ptr, ptr %op.addr, align 8
  %call = call ptr @tcg_call_info(ptr noundef %4)
  store ptr %call, ptr %info, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %5, i32 0, i32 16
  %6 = load i32, ptr %reserved_regs, align 4
  store i32 %6, ptr %allocated_regs, align 4
  %7 = load i32, ptr %nb_iargs, align 4
  %sub = sub i32 %7, 1
  store i32 %sub, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %8 = load i32, ptr %i, align 4
  %cmp = icmp sge i32 %8, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load ptr, ptr %info, align 8
  %in = getelementptr inbounds %struct.TCGHelperInfo, ptr %9, i32 0, i32 4
  %10 = load i32, ptr %i, align 4
  %idxprom = sext i32 %10 to i64
  %arrayidx = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %loc, align 8
  %11 = load ptr, ptr %op.addr, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %11, i32 0, i32 4
  %12 = load i32, ptr %nb_oargs, align 4
  %13 = load i32, ptr %i, align 4
  %add = add i32 %12, %13
  %idxprom3 = sext i32 %add to i64
  %arrayidx4 = getelementptr [0 x i64], ptr %args, i64 0, i64 %idxprom3
  %14 = load i64, ptr %arrayidx4, align 8
  %call5 = call ptr @arg_temp(i64 noundef %14)
  store ptr %call5, ptr %ts, align 8
  %15 = load ptr, ptr %loc, align 8
  %bf.load6 = load i32, ptr %15, align 4
  %bf.clear7 = and i32 %bf.load6, 255
  switch i32 %bf.clear7, label %sw.default [
    i32 0, label %sw.bb
    i32 3, label %sw.bb
    i32 4, label %sw.bb
    i32 5, label %sw.bb8
    i32 6, label %sw.bb19
  ]

sw.bb:                                            ; preds = %for.body, %for.body, %for.body
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load ptr, ptr %loc, align 8
  %18 = load ptr, ptr %ts, align 8
  call void @load_arg_normal(ptr noundef %16, ptr noundef %17, ptr noundef %18, ptr noundef %allocated_regs)
  br label %sw.epilog

sw.bb8:                                           ; preds = %for.body
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load ptr, ptr %loc, align 8
  %bf.load9 = load i32, ptr %20, align 4
  %bf.lshr10 = lshr i32 %bf.load9, 16
  %bf.clear11 = and i32 %bf.lshr10, 255
  %21 = load ptr, ptr %ts, align 8
  %22 = load i32, ptr %allocated_regs, align 4
  call void @load_arg_stk(ptr noundef %19, i32 noundef %bf.clear11, ptr noundef %21, i32 noundef %22)
  %23 = load ptr, ptr %s.addr, align 8
  %24 = load ptr, ptr %loc, align 8
  %bf.load12 = load i32, ptr %24, align 4
  %bf.lshr13 = lshr i32 %bf.load12, 8
  %bf.clear14 = and i32 %bf.lshr13, 255
  %25 = load ptr, ptr %loc, align 8
  %bf.load15 = load i32, ptr %25, align 4
  %bf.lshr16 = lshr i32 %bf.load15, 16
  %bf.clear17 = and i32 %bf.lshr16, 255
  %call18 = call i32 @arg_slot_stk_ofs(i32 noundef %bf.clear17)
  %conv = sext i32 %call18 to i64
  call void @load_arg_ref(ptr noundef %23, i32 noundef %bf.clear14, i32 noundef 4, i64 noundef %conv, ptr noundef %allocated_regs)
  br label %sw.epilog

sw.bb19:                                          ; preds = %for.body
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load ptr, ptr %loc, align 8
  %bf.load20 = load i32, ptr %27, align 4
  %bf.lshr21 = lshr i32 %bf.load20, 16
  %bf.clear22 = and i32 %bf.lshr21, 255
  %28 = load ptr, ptr %ts, align 8
  %29 = load i32, ptr %allocated_regs, align 4
  call void @load_arg_stk(ptr noundef %26, i32 noundef %bf.clear22, ptr noundef %28, i32 noundef %29)
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5324, ptr noundef @__func__.tcg_reg_alloc_call, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb19, %sw.bb8, %sw.bb
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %30 = load i32, ptr %i, align 4
  %dec = add i32 %30, -1
  store i32 %dec, ptr %i, align 4
  br label %for.cond, !llvm.loop !65

for.end:                                          ; preds = %for.cond
  %31 = load i32, ptr %nb_oargs, align 4
  store i32 %31, ptr %i, align 4
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc32, %for.end
  %32 = load i32, ptr %i, align 4
  %33 = load i32, ptr %nb_iargs, align 4
  %34 = load i32, ptr %nb_oargs, align 4
  %add24 = add i32 %33, %34
  %cmp25 = icmp slt i32 %32, %add24
  br i1 %cmp25, label %for.body27, label %for.end33

for.body27:                                       ; preds = %for.cond23
  %35 = load i32, ptr %arg_life, align 4
  %36 = load i32, ptr %i, align 4
  %shl = shl i32 16, %36
  %and = and i32 %35, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body27
  %37 = load ptr, ptr %s.addr, align 8
  %38 = load ptr, ptr %op.addr, align 8
  %args28 = getelementptr inbounds %struct.TCGOp, ptr %38, i32 0, i32 4
  %39 = load i32, ptr %i, align 4
  %idxprom29 = sext i32 %39 to i64
  %arrayidx30 = getelementptr [0 x i64], ptr %args28, i64 0, i64 %idxprom29
  %40 = load i64, ptr %arrayidx30, align 8
  %call31 = call ptr @arg_temp(i64 noundef %40)
  call void @temp_dead(ptr noundef %37, ptr noundef %call31)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body27
  br label %for.inc32

for.inc32:                                        ; preds = %if.end
  %41 = load i32, ptr %i, align 4
  %inc = add i32 %41, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond23, !llvm.loop !66

for.end33:                                        ; preds = %for.cond23
  store i32 0, ptr %i, align 4
  br label %for.cond34

for.cond34:                                       ; preds = %for.inc42, %for.end33
  %42 = load i32, ptr %i, align 4
  %cmp35 = icmp slt i32 %42, 32
  br i1 %cmp35, label %for.body37, label %for.end44

for.body37:                                       ; preds = %for.cond34
  %43 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %44 = load i32, ptr %i, align 4
  %shr = lshr i32 %43, %44
  %and38 = and i32 %shr, 1
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %for.body37
  %45 = load ptr, ptr %s.addr, align 8
  %46 = load i32, ptr %i, align 4
  %47 = load i32, ptr %allocated_regs, align 4
  call void @tcg_reg_free(ptr noundef %45, i32 noundef %46, i32 noundef %47)
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %for.body37
  br label %for.inc42

for.inc42:                                        ; preds = %if.end41
  %48 = load i32, ptr %i, align 4
  %inc43 = add i32 %48, 1
  store i32 %inc43, ptr %i, align 4
  br label %for.cond34, !llvm.loop !67

for.end44:                                        ; preds = %for.cond34
  %49 = load ptr, ptr %info, align 8
  %flags = getelementptr inbounds %struct.TCGHelperInfo, ptr %49, i32 0, i32 3
  %bf.load45 = load i64, ptr %flags, align 8
  %bf.lshr46 = lshr i64 %bf.load45, 32
  %bf.clear47 = and i64 %bf.lshr46, 255
  %bf.cast = trunc i64 %bf.clear47 to i32
  %and48 = and i32 %bf.cast, 1
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %if.then50, label %if.else

if.then50:                                        ; preds = %for.end44
  br label %if.end61

if.else:                                          ; preds = %for.end44
  %50 = load ptr, ptr %info, align 8
  %flags51 = getelementptr inbounds %struct.TCGHelperInfo, ptr %50, i32 0, i32 3
  %bf.load52 = load i64, ptr %flags51, align 8
  %bf.lshr53 = lshr i64 %bf.load52, 32
  %bf.clear54 = and i64 %bf.lshr53, 255
  %bf.cast55 = trunc i64 %bf.clear54 to i32
  %and56 = and i32 %bf.cast55, 2
  %tobool57 = icmp ne i32 %and56, 0
  br i1 %tobool57, label %if.then58, label %if.else59

if.then58:                                        ; preds = %if.else
  %51 = load ptr, ptr %s.addr, align 8
  %52 = load i32, ptr %allocated_regs, align 4
  call void @sync_globals(ptr noundef %51, i32 noundef %52)
  br label %if.end60

if.else59:                                        ; preds = %if.else
  %53 = load ptr, ptr %s.addr, align 8
  %54 = load i32, ptr %allocated_regs, align 4
  call void @save_globals(ptr noundef %53, i32 noundef %54)
  br label %if.end60

if.end60:                                         ; preds = %if.else59, %if.then58
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %if.then50
  %55 = load ptr, ptr %info, align 8
  %out_kind = getelementptr inbounds %struct.TCGHelperInfo, ptr %55, i32 0, i32 3
  %bf.load62 = load i64, ptr %out_kind, align 8
  %bf.lshr63 = lshr i64 %bf.load62, 56
  %bf.cast64 = trunc i64 %bf.lshr63 to i32
  %cmp65 = icmp eq i32 %bf.cast64, 1
  br i1 %cmp65, label %if.then67, label %if.end82

if.then67:                                        ; preds = %if.end61
  %56 = load ptr, ptr %op.addr, align 8
  %args69 = getelementptr inbounds %struct.TCGOp, ptr %56, i32 0, i32 4
  %arrayidx70 = getelementptr [0 x i64], ptr %args69, i64 0, i64 0
  %57 = load i64, ptr %arrayidx70, align 8
  %call71 = call ptr @arg_temp(i64 noundef %57)
  store ptr %call71, ptr %ts68, align 8
  %58 = load ptr, ptr %ts68, align 8
  %bf.load72 = load i64, ptr %58, align 8
  %bf.lshr73 = lshr i64 %bf.load72, 38
  %bf.clear74 = and i64 %bf.lshr73, 1
  %bf.cast75 = trunc i64 %bf.clear74 to i32
  %tobool76 = icmp ne i32 %bf.cast75, 0
  br i1 %tobool76, label %if.end78, label %if.then77

if.then77:                                        ; preds = %if.then67
  %59 = load ptr, ptr %s.addr, align 8
  %60 = load ptr, ptr %ts68, align 8
  call void @temp_allocate_frame(ptr noundef %59, ptr noundef %60)
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %if.then67
  %61 = load ptr, ptr %s.addr, align 8
  %62 = load ptr, ptr %ts68, align 8
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %62, i32 0, i32 2
  %63 = load ptr, ptr %mem_base, align 8
  %bf.load79 = load i64, ptr %63, align 8
  %bf.clear80 = and i64 %bf.load79, 255
  %bf.cast81 = trunc i64 %bf.clear80 to i32
  %64 = load ptr, ptr %ts68, align 8
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %64, i32 0, i32 3
  %65 = load i64, ptr %mem_offset, align 8
  call void @load_arg_ref(ptr noundef %61, i32 noundef 0, i32 noundef %bf.cast81, i64 noundef %65, ptr noundef %allocated_regs)
  br label %if.end82

if.end82:                                         ; preds = %if.end78, %if.end61
  %66 = load ptr, ptr %s.addr, align 8
  %67 = load ptr, ptr %op.addr, align 8
  %call83 = call ptr @tcg_call_func(ptr noundef %67)
  %68 = load ptr, ptr %info, align 8
  call void @tcg_out_call(ptr noundef %66, ptr noundef %call83, ptr noundef %68)
  %69 = load ptr, ptr %info, align 8
  %out_kind84 = getelementptr inbounds %struct.TCGHelperInfo, ptr %69, i32 0, i32 3
  %bf.load85 = load i64, ptr %out_kind84, align 8
  %bf.lshr86 = lshr i64 %bf.load85, 56
  %bf.cast87 = trunc i64 %bf.lshr86 to i32
  switch i32 %bf.cast87, label %sw.default163 [
    i32 0, label %sw.bb88
    i32 2, label %sw.bb109
    i32 1, label %sw.bb147
  ]

sw.bb88:                                          ; preds = %if.end82
  store i32 0, ptr %i, align 4
  br label %for.cond89

for.cond89:                                       ; preds = %for.inc106, %sw.bb88
  %70 = load i32, ptr %i, align 4
  %71 = load i32, ptr %nb_oargs, align 4
  %cmp90 = icmp slt i32 %70, %71
  br i1 %cmp90, label %for.body92, label %for.end108

for.body92:                                       ; preds = %for.cond89
  %72 = load ptr, ptr %op.addr, align 8
  %args94 = getelementptr inbounds %struct.TCGOp, ptr %72, i32 0, i32 4
  %73 = load i32, ptr %i, align 4
  %idxprom95 = sext i32 %73 to i64
  %arrayidx96 = getelementptr [0 x i64], ptr %args94, i64 0, i64 %idxprom95
  %74 = load i64, ptr %arrayidx96, align 8
  %call97 = call ptr @arg_temp(i64 noundef %74)
  store ptr %call97, ptr %ts93, align 8
  %75 = load i32, ptr %i, align 4
  %call98 = call i32 @tcg_target_call_oarg_reg(i32 noundef 0, i32 noundef %75)
  store i32 %call98, ptr %reg, align 4
  br label %do.body99

do.body99:                                        ; preds = %for.body92
  %76 = load ptr, ptr %ts93, align 8
  %call100 = call zeroext i1 @temp_readonly(ptr noundef %76)
  br i1 %call100, label %if.then101, label %if.end102

if.then101:                                       ; preds = %do.body99
  unreachable

if.end102:                                        ; preds = %do.body99
  br label %do.end103

do.end103:                                        ; preds = %if.end102
  %77 = load ptr, ptr %s.addr, align 8
  %78 = load ptr, ptr %ts93, align 8
  %79 = load i32, ptr %reg, align 4
  call void @set_temp_val_reg(ptr noundef %77, ptr noundef %78, i32 noundef %79)
  %80 = load ptr, ptr %ts93, align 8
  %bf.load104 = load i64, ptr %80, align 8
  %bf.clear105 = and i64 %bf.load104, -137438953473
  %bf.set = or i64 %bf.clear105, 0
  store i64 %bf.set, ptr %80, align 8
  br label %for.inc106

for.inc106:                                       ; preds = %do.end103
  %81 = load i32, ptr %i, align 4
  %inc107 = add i32 %81, 1
  store i32 %inc107, ptr %i, align 4
  br label %for.cond89, !llvm.loop !68

for.end108:                                       ; preds = %for.cond89
  br label %sw.epilog166

sw.bb109:                                         ; preds = %if.end82
  %82 = load ptr, ptr %op.addr, align 8
  %args111 = getelementptr inbounds %struct.TCGOp, ptr %82, i32 0, i32 4
  %arrayidx112 = getelementptr [0 x i64], ptr %args111, i64 0, i64 0
  %83 = load i64, ptr %arrayidx112, align 8
  %call113 = call ptr @arg_temp(i64 noundef %83)
  store ptr %call113, ptr %ts110, align 8
  br label %do.body114

do.body114:                                       ; preds = %sw.bb109
  %84 = load ptr, ptr %ts110, align 8
  %bf.load115 = load i64, ptr %84, align 8
  %bf.lshr116 = lshr i64 %bf.load115, 16
  %bf.clear117 = and i64 %bf.lshr116, 255
  %bf.cast118 = trunc i64 %bf.clear117 to i32
  %cmp119 = icmp eq i32 %bf.cast118, 2
  br i1 %cmp119, label %if.end122, label %if.then121

if.then121:                                       ; preds = %do.body114
  unreachable

if.end122:                                        ; preds = %do.body114
  br label %do.end123

do.end123:                                        ; preds = %if.end122
  br label %do.body124

do.body124:                                       ; preds = %do.end123
  %85 = load ptr, ptr %ts110, align 8
  %bf.load125 = load i64, ptr %85, align 8
  %bf.lshr126 = lshr i64 %bf.load125, 40
  %bf.clear127 = and i64 %bf.lshr126, 1
  %bf.cast128 = trunc i64 %bf.clear127 to i32
  %cmp129 = icmp eq i32 %bf.cast128, 0
  br i1 %cmp129, label %if.end132, label %if.then131

if.then131:                                       ; preds = %do.body124
  unreachable

if.end132:                                        ; preds = %do.body124
  br label %do.end133

do.end133:                                        ; preds = %if.end132
  %86 = load ptr, ptr %ts110, align 8
  %bf.load134 = load i64, ptr %86, align 8
  %bf.lshr135 = lshr i64 %bf.load134, 38
  %bf.clear136 = and i64 %bf.lshr135, 1
  %bf.cast137 = trunc i64 %bf.clear136 to i32
  %tobool138 = icmp ne i32 %bf.cast137, 0
  br i1 %tobool138, label %if.end140, label %if.then139

if.then139:                                       ; preds = %do.end133
  %87 = load ptr, ptr %s.addr, align 8
  %88 = load ptr, ptr %ts110, align 8
  call void @temp_allocate_frame(ptr noundef %87, ptr noundef %88)
  br label %if.end140

if.end140:                                        ; preds = %if.then139, %do.end133
  %89 = load ptr, ptr %s.addr, align 8
  %call141 = call i32 @tcg_target_call_oarg_reg(i32 noundef 2, i32 noundef 0)
  %90 = load ptr, ptr %ts110, align 8
  %mem_base142 = getelementptr inbounds %struct.TCGTemp, ptr %90, i32 0, i32 2
  %91 = load ptr, ptr %mem_base142, align 8
  %bf.load143 = load i64, ptr %91, align 8
  %bf.clear144 = and i64 %bf.load143, 255
  %bf.cast145 = trunc i64 %bf.clear144 to i32
  %92 = load ptr, ptr %ts110, align 8
  %mem_offset146 = getelementptr inbounds %struct.TCGTemp, ptr %92, i32 0, i32 3
  %93 = load i64, ptr %mem_offset146, align 8
  call void @tcg_out_st(ptr noundef %89, i32 noundef 4, i32 noundef %call141, i32 noundef %bf.cast145, i64 noundef %93)
  br label %sw.bb147

sw.bb147:                                         ; preds = %if.end140, %if.end82
  store i32 0, ptr %i, align 4
  br label %for.cond148

for.cond148:                                      ; preds = %for.inc160, %sw.bb147
  %94 = load i32, ptr %i, align 4
  %95 = load i32, ptr %nb_oargs, align 4
  %cmp149 = icmp slt i32 %94, %95
  br i1 %cmp149, label %for.body151, label %for.end162

for.body151:                                      ; preds = %for.cond148
  %96 = load ptr, ptr %op.addr, align 8
  %args153 = getelementptr inbounds %struct.TCGOp, ptr %96, i32 0, i32 4
  %97 = load i32, ptr %i, align 4
  %idxprom154 = sext i32 %97 to i64
  %arrayidx155 = getelementptr [0 x i64], ptr %args153, i64 0, i64 %idxprom154
  %98 = load i64, ptr %arrayidx155, align 8
  %call156 = call ptr @arg_temp(i64 noundef %98)
  store ptr %call156, ptr %ts152, align 8
  %99 = load ptr, ptr %ts152, align 8
  %bf.load157 = load i64, ptr %99, align 8
  %bf.clear158 = and i64 %bf.load157, -65281
  %bf.set159 = or i64 %bf.clear158, 512
  store i64 %bf.set159, ptr %99, align 8
  br label %for.inc160

for.inc160:                                       ; preds = %for.body151
  %100 = load i32, ptr %i, align 4
  %inc161 = add i32 %100, 1
  store i32 %inc161, ptr %i, align 4
  br label %for.cond148, !llvm.loop !69

for.end162:                                       ; preds = %for.cond148
  br label %sw.epilog166

sw.default163:                                    ; preds = %if.end82
  br label %do.body164

do.body164:                                       ; preds = %sw.default163
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5408, ptr noundef @__func__.tcg_reg_alloc_call, ptr noundef null) #15
  unreachable

do.end165:                                        ; No predecessors!
  br label %sw.epilog166

sw.epilog166:                                     ; preds = %do.end165, %for.end162, %for.end108
  store i32 0, ptr %i, align 4
  br label %for.cond167

for.cond167:                                      ; preds = %for.inc190, %sw.epilog166
  %101 = load i32, ptr %i, align 4
  %102 = load i32, ptr %nb_oargs, align 4
  %cmp168 = icmp slt i32 %101, %102
  br i1 %cmp168, label %for.body170, label %for.end192

for.body170:                                      ; preds = %for.cond167
  %103 = load ptr, ptr %op.addr, align 8
  %args172 = getelementptr inbounds %struct.TCGOp, ptr %103, i32 0, i32 4
  %104 = load i32, ptr %i, align 4
  %idxprom173 = sext i32 %104 to i64
  %arrayidx174 = getelementptr [0 x i64], ptr %args172, i64 0, i64 %idxprom173
  %105 = load i64, ptr %arrayidx174, align 8
  %call175 = call ptr @arg_temp(i64 noundef %105)
  store ptr %call175, ptr %ts171, align 8
  %106 = load i32, ptr %arg_life, align 4
  %107 = load i32, ptr %i, align 4
  %shl176 = shl i32 1, %107
  %and177 = and i32 %106, %shl176
  %tobool178 = icmp ne i32 %and177, 0
  br i1 %tobool178, label %if.then179, label %if.else183

if.then179:                                       ; preds = %for.body170
  %108 = load ptr, ptr %s.addr, align 8
  %109 = load ptr, ptr %ts171, align 8
  %110 = load ptr, ptr %s.addr, align 8
  %reserved_regs180 = getelementptr inbounds %struct.TCGContext, ptr %110, i32 0, i32 16
  %111 = load i32, ptr %reserved_regs180, align 4
  %112 = load i32, ptr %arg_life, align 4
  %113 = load i32, ptr %i, align 4
  %shl181 = shl i32 16, %113
  %and182 = and i32 %112, %shl181
  call void @temp_sync(ptr noundef %108, ptr noundef %109, i32 noundef %111, i32 noundef 0, i32 noundef %and182)
  br label %if.end189

if.else183:                                       ; preds = %for.body170
  %114 = load i32, ptr %arg_life, align 4
  %115 = load i32, ptr %i, align 4
  %shl184 = shl i32 16, %115
  %and185 = and i32 %114, %shl184
  %tobool186 = icmp ne i32 %and185, 0
  br i1 %tobool186, label %if.then187, label %if.end188

if.then187:                                       ; preds = %if.else183
  %116 = load ptr, ptr %s.addr, align 8
  %117 = load ptr, ptr %ts171, align 8
  call void @temp_dead(ptr noundef %116, ptr noundef %117)
  br label %if.end188

if.end188:                                        ; preds = %if.then187, %if.else183
  br label %if.end189

if.end189:                                        ; preds = %if.end188, %if.then179
  br label %for.inc190

for.inc190:                                       ; preds = %if.end189
  %118 = load i32, ptr %i, align 4
  %inc191 = add i32 %118, 1
  store i32 %inc191, ptr %i, align 4
  br label %for.cond167, !llvm.loop !70

for.end192:                                       ; preds = %for.cond167
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_exit_tb(ptr noundef %s, i64 noundef %a0) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %a0.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %a0, ptr %a0.addr, align 8
  %0 = load i64, ptr %a0.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load ptr, ptr @tcg_code_gen_epilogue, align 8
  call void @tcg_out_jmp(ptr noundef %1, ptr noundef %2)
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load i64, ptr %a0.addr, align 8
  call void @tcg_out_movi(ptr noundef %3, i32 noundef 1, i32 noundef 0, i64 noundef %4)
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr @tb_ret_addr, align 8
  call void @tcg_out_jmp(ptr noundef %5, ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_goto_tb(ptr noundef %s, i32 noundef %which) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %which.addr = alloca i32, align 4
  %gap = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %which, ptr %which.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 23
  %1 = load ptr, ptr %code_ptr, align 8
  %add.ptr = getelementptr i8, ptr %1, i64 1
  %2 = ptrtoint ptr %add.ptr to i64
  %add = add i64 %2, 4
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 4
  %mul = mul i64 %div, 4
  %3 = inttoptr i64 %mul to ptr
  %4 = load ptr, ptr %s.addr, align 8
  %code_ptr1 = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 23
  %5 = load ptr, ptr %code_ptr1, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  store i32 %conv, ptr %gap, align 4
  %6 = load i32, ptr %gap, align 4
  %cmp = icmp ne i32 %6, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i32, ptr %gap, align 4
  %sub3 = sub i32 %8, 1
  call void @tcg_out_nopn(ptr noundef %7, i32 noundef %sub3)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %9, i8 noundef zeroext -23)
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load i32, ptr %which.addr, align 4
  call void @set_jmp_insn_offset(ptr noundef %10, i32 noundef %11)
  %12 = load ptr, ptr %s.addr, align 8
  call void @tcg_out32(ptr noundef %12, i32 noundef 0)
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load i32, ptr %which.addr, align 4
  call void @set_jmp_reset_offset(ptr noundef %13, i32 noundef %14)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_reg_alloc_dup2(ptr noundef %s, ptr noundef %op) #0 {
entry:
  %retval = alloca i1, align 1
  %s.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %arg_life = alloca i32, align 4
  %ots = alloca ptr, align 8
  %itsl = alloca ptr, align 8
  %itsh = alloca ptr, align 8
  %vtype = alloca i32, align 4
  %allocated_regs = alloca i32, align 4
  %dup_out_regs = alloca i32, align 4
  %oreg = alloca i32, align 4
  %val = alloca i64, align 8
  %vece = alloca i32, align 4
  %its = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %life = getelementptr inbounds %struct.TCGOp, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %life, align 4
  store i32 %1, ptr %arg_life, align 4
  %2 = load ptr, ptr %op.addr, align 8
  %bf.load = load i32, ptr %2, align 8
  %bf.lshr = lshr i32 %bf.load, 16
  %bf.clear = and i32 %bf.lshr, 255
  %add = add i32 %bf.clear, 3
  store i32 %add, ptr %vtype, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  unreachable

do.end:                                           ; No predecessors!
  br label %do.body1

do.body1:                                         ; preds = %do.end
  %3 = load ptr, ptr %op.addr, align 8
  %bf.load2 = load i32, ptr %3, align 8
  %bf.lshr3 = lshr i32 %bf.load2, 24
  %cmp = icmp eq i32 %bf.lshr3, 3
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body1
  unreachable

if.end:                                           ; preds = %do.body1
  br label %do.end4

do.end4:                                          ; preds = %if.end
  %4 = load ptr, ptr %op.addr, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %4, i32 0, i32 4
  %arrayidx = getelementptr [0 x i64], ptr %args, i64 0, i64 0
  %5 = load i64, ptr %arrayidx, align 8
  %call = call ptr @arg_temp(i64 noundef %5)
  store ptr %call, ptr %ots, align 8
  %6 = load ptr, ptr %op.addr, align 8
  %args5 = getelementptr inbounds %struct.TCGOp, ptr %6, i32 0, i32 4
  %arrayidx6 = getelementptr [0 x i64], ptr %args5, i64 0, i64 1
  %7 = load i64, ptr %arrayidx6, align 8
  %call7 = call ptr @arg_temp(i64 noundef %7)
  store ptr %call7, ptr %itsl, align 8
  %8 = load ptr, ptr %op.addr, align 8
  %args8 = getelementptr inbounds %struct.TCGOp, ptr %8, i32 0, i32 4
  %arrayidx9 = getelementptr [0 x i64], ptr %args8, i64 0, i64 2
  %9 = load i64, ptr %arrayidx9, align 8
  %call10 = call ptr @arg_temp(i64 noundef %9)
  store ptr %call10, ptr %itsh, align 8
  br label %do.body11

do.body11:                                        ; preds = %do.end4
  %10 = load ptr, ptr %ots, align 8
  %call12 = call zeroext i1 @temp_readonly(ptr noundef %10)
  br i1 %call12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %do.body11
  unreachable

if.end14:                                         ; preds = %do.body11
  br label %do.end15

do.end15:                                         ; preds = %if.end14
  %11 = load ptr, ptr %ots, align 8
  %bf.load16 = load i64, ptr %11, align 8
  %bf.lshr17 = lshr i64 %bf.load16, 8
  %bf.clear18 = and i64 %bf.lshr17, 255
  %bf.cast = trunc i64 %bf.clear18 to i32
  %cmp19 = icmp ne i32 %bf.cast, 1
  br i1 %cmp19, label %if.then20, label %if.end54

if.then20:                                        ; preds = %do.end15
  %12 = load ptr, ptr %s.addr, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %12, i32 0, i32 16
  %13 = load i32, ptr %reserved_regs, align 4
  store i32 %13, ptr %allocated_regs, align 4
  %14 = load ptr, ptr getelementptr ([0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 150, i32 6), align 8
  %arrayidx21 = getelementptr %struct.TCGArgConstraint, ptr %14, i64 0
  %regs = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx21, i32 0, i32 1
  %15 = load i32, ptr %regs, align 4
  store i32 %15, ptr %dup_out_regs, align 4
  %16 = load i32, ptr %arg_life, align 4
  %and = and i32 %16, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end31, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then20
  %17 = load ptr, ptr %itsl, align 8
  %bf.load22 = load i64, ptr %17, align 8
  %bf.lshr23 = lshr i64 %bf.load22, 8
  %bf.clear24 = and i64 %bf.lshr23, 255
  %bf.cast25 = trunc i64 %bf.clear24 to i32
  %cmp26 = icmp eq i32 %bf.cast25, 1
  br i1 %cmp26, label %if.then27, label %if.end31

if.then27:                                        ; preds = %land.lhs.true
  %18 = load ptr, ptr %itsl, align 8
  %bf.load28 = load i64, ptr %18, align 8
  %bf.clear29 = and i64 %bf.load28, 255
  %bf.cast30 = trunc i64 %bf.clear29 to i32
  %shl = shl i32 1, %bf.cast30
  %19 = load i32, ptr %allocated_regs, align 4
  %or = or i32 %19, %shl
  store i32 %or, ptr %allocated_regs, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then27, %land.lhs.true, %if.then20
  %20 = load i32, ptr %arg_life, align 4
  %and32 = and i32 %20, 64
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %if.end46, label %land.lhs.true34

land.lhs.true34:                                  ; preds = %if.end31
  %21 = load ptr, ptr %itsh, align 8
  %bf.load35 = load i64, ptr %21, align 8
  %bf.lshr36 = lshr i64 %bf.load35, 8
  %bf.clear37 = and i64 %bf.lshr36, 255
  %bf.cast38 = trunc i64 %bf.clear37 to i32
  %cmp39 = icmp eq i32 %bf.cast38, 1
  br i1 %cmp39, label %if.then40, label %if.end46

if.then40:                                        ; preds = %land.lhs.true34
  %22 = load ptr, ptr %itsh, align 8
  %bf.load41 = load i64, ptr %22, align 8
  %bf.clear42 = and i64 %bf.load41, 255
  %bf.cast43 = trunc i64 %bf.clear42 to i32
  %shl44 = shl i32 1, %bf.cast43
  %23 = load i32, ptr %allocated_regs, align 4
  %or45 = or i32 %23, %shl44
  store i32 %or45, ptr %allocated_regs, align 4
  br label %if.end46

if.end46:                                         ; preds = %if.then40, %land.lhs.true34, %if.end31
  %24 = load ptr, ptr %s.addr, align 8
  %25 = load i32, ptr %dup_out_regs, align 4
  %26 = load i32, ptr %allocated_regs, align 4
  %27 = load ptr, ptr %op.addr, align 8
  %call47 = call i32 @output_pref(ptr noundef %27, i32 noundef 0)
  %28 = load ptr, ptr %ots, align 8
  %bf.load48 = load i64, ptr %28, align 8
  %bf.lshr49 = lshr i64 %bf.load48, 36
  %bf.clear50 = and i64 %bf.lshr49, 1
  %bf.cast51 = trunc i64 %bf.clear50 to i32
  %tobool52 = icmp ne i32 %bf.cast51, 0
  %call53 = call i32 @tcg_reg_alloc(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %call47, i1 noundef zeroext %tobool52)
  store i32 %call53, ptr %oreg, align 4
  %29 = load ptr, ptr %s.addr, align 8
  %30 = load ptr, ptr %ots, align 8
  %31 = load i32, ptr %oreg, align 4
  call void @set_temp_val_reg(ptr noundef %29, ptr noundef %30, i32 noundef %31)
  br label %if.end54

if.end54:                                         ; preds = %if.end46, %do.end15
  %32 = load ptr, ptr %itsl, align 8
  %bf.load55 = load i64, ptr %32, align 8
  %bf.lshr56 = lshr i64 %bf.load55, 8
  %bf.clear57 = and i64 %bf.lshr56, 255
  %bf.cast58 = trunc i64 %bf.clear57 to i32
  %cmp59 = icmp eq i32 %bf.cast58, 3
  br i1 %cmp59, label %land.lhs.true60, label %if.end93

land.lhs.true60:                                  ; preds = %if.end54
  %33 = load ptr, ptr %itsh, align 8
  %bf.load61 = load i64, ptr %33, align 8
  %bf.lshr62 = lshr i64 %bf.load61, 8
  %bf.clear63 = and i64 %bf.lshr62, 255
  %bf.cast64 = trunc i64 %bf.clear63 to i32
  %cmp65 = icmp eq i32 %bf.cast64, 3
  br i1 %cmp65, label %if.then66, label %if.end93

if.then66:                                        ; preds = %land.lhs.true60
  %34 = load ptr, ptr %itsl, align 8
  %val67 = getelementptr inbounds %struct.TCGTemp, ptr %34, i32 0, i32 1
  %35 = load i64, ptr %val67, align 8
  %36 = load ptr, ptr %itsh, align 8
  %val68 = getelementptr inbounds %struct.TCGTemp, ptr %36, i32 0, i32 1
  %37 = load i64, ptr %val68, align 8
  %call69 = call i64 @deposit64(i64 noundef %35, i32 noundef 32, i32 noundef 32, i64 noundef %37)
  store i64 %call69, ptr %val, align 8
  store i32 3, ptr %vece, align 4
  %38 = load i64, ptr %val, align 8
  %39 = load i64, ptr %val, align 8
  %conv = trunc i64 %39 to i8
  %conv70 = zext i8 %conv to i64
  %mul = mul i64 72340172838076673, %conv70
  %cmp71 = icmp eq i64 %38, %mul
  br i1 %cmp71, label %if.then73, label %if.else

if.then73:                                        ; preds = %if.then66
  store i32 0, ptr %vece, align 4
  br label %if.end89

if.else:                                          ; preds = %if.then66
  %40 = load i64, ptr %val, align 8
  %41 = load i64, ptr %val, align 8
  %conv74 = trunc i64 %41 to i16
  %conv75 = zext i16 %conv74 to i64
  %mul76 = mul i64 281479271743489, %conv75
  %cmp77 = icmp eq i64 %40, %mul76
  br i1 %cmp77, label %if.then79, label %if.else80

if.then79:                                        ; preds = %if.else
  store i32 1, ptr %vece, align 4
  br label %if.end88

if.else80:                                        ; preds = %if.else
  %42 = load i64, ptr %val, align 8
  %43 = load i64, ptr %val, align 8
  %conv81 = trunc i64 %43 to i32
  %conv82 = zext i32 %conv81 to i64
  %mul83 = mul i64 4294967297, %conv82
  %cmp84 = icmp eq i64 %42, %mul83
  br i1 %cmp84, label %if.then86, label %if.end87

if.then86:                                        ; preds = %if.else80
  store i32 2, ptr %vece, align 4
  br label %if.end87

if.end87:                                         ; preds = %if.then86, %if.else80
  br label %if.end88

if.end88:                                         ; preds = %if.end87, %if.then79
  br label %if.end89

if.end89:                                         ; preds = %if.end88, %if.then73
  %44 = load ptr, ptr %s.addr, align 8
  %45 = load i32, ptr %vtype, align 4
  %46 = load i32, ptr %vece, align 4
  %47 = load ptr, ptr %ots, align 8
  %bf.load90 = load i64, ptr %47, align 8
  %bf.clear91 = and i64 %bf.load90, 255
  %bf.cast92 = trunc i64 %bf.clear91 to i32
  %48 = load i64, ptr %val, align 8
  call void @tcg_out_dupi_vec(ptr noundef %44, i32 noundef %45, i32 noundef %46, i32 noundef %bf.cast92, i64 noundef %48)
  br label %done

if.end93:                                         ; preds = %land.lhs.true60, %if.end54
  %49 = load ptr, ptr %itsl, align 8
  %bf.load94 = load i64, ptr %49, align 8
  %bf.lshr95 = lshr i64 %bf.load94, 40
  %bf.clear96 = and i64 %bf.lshr95, 1
  %bf.cast97 = trunc i64 %bf.clear96 to i32
  %cmp98 = icmp eq i32 %bf.cast97, 0
  br i1 %cmp98, label %land.lhs.true100, label %if.end125

land.lhs.true100:                                 ; preds = %if.end93
  %50 = load ptr, ptr %itsh, align 8
  %bf.load101 = load i64, ptr %50, align 8
  %bf.lshr102 = lshr i64 %bf.load101, 40
  %bf.clear103 = and i64 %bf.lshr102, 1
  %bf.cast104 = trunc i64 %bf.clear103 to i32
  %cmp105 = icmp eq i32 %bf.cast104, 1
  br i1 %cmp105, label %land.lhs.true107, label %if.end125

land.lhs.true107:                                 ; preds = %land.lhs.true100
  %51 = load ptr, ptr %itsl, align 8
  %52 = load ptr, ptr %itsh, align 8
  %add.ptr = getelementptr %struct.TCGTemp, ptr %52, i64 -1
  %cmp108 = icmp eq ptr %51, %add.ptr
  br i1 %cmp108, label %if.then110, label %if.end125

if.then110:                                       ; preds = %land.lhs.true107
  %53 = load ptr, ptr %itsl, align 8
  %add.ptr111 = getelementptr %struct.TCGTemp, ptr %53, i64 0
  store ptr %add.ptr111, ptr %its, align 8
  %54 = load ptr, ptr %s.addr, align 8
  %55 = load ptr, ptr %its, align 8
  %add.ptr112 = getelementptr %struct.TCGTemp, ptr %55, i64 0
  %56 = load ptr, ptr %s.addr, align 8
  %reserved_regs113 = getelementptr inbounds %struct.TCGContext, ptr %56, i32 0, i32 16
  %57 = load i32, ptr %reserved_regs113, align 4
  call void @temp_sync(ptr noundef %54, ptr noundef %add.ptr112, i32 noundef %57, i32 noundef 0, i32 noundef 0)
  %58 = load ptr, ptr %s.addr, align 8
  %59 = load ptr, ptr %its, align 8
  %add.ptr114 = getelementptr %struct.TCGTemp, ptr %59, i64 1
  %60 = load ptr, ptr %s.addr, align 8
  %reserved_regs115 = getelementptr inbounds %struct.TCGContext, ptr %60, i32 0, i32 16
  %61 = load i32, ptr %reserved_regs115, align 4
  call void @temp_sync(ptr noundef %58, ptr noundef %add.ptr114, i32 noundef %61, i32 noundef 0, i32 noundef 0)
  %62 = load ptr, ptr %s.addr, align 8
  %63 = load i32, ptr %vtype, align 4
  %64 = load ptr, ptr %ots, align 8
  %bf.load116 = load i64, ptr %64, align 8
  %bf.clear117 = and i64 %bf.load116, 255
  %bf.cast118 = trunc i64 %bf.clear117 to i32
  %65 = load ptr, ptr %its, align 8
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %65, i32 0, i32 2
  %66 = load ptr, ptr %mem_base, align 8
  %bf.load119 = load i64, ptr %66, align 8
  %bf.clear120 = and i64 %bf.load119, 255
  %bf.cast121 = trunc i64 %bf.clear120 to i32
  %67 = load ptr, ptr %its, align 8
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %67, i32 0, i32 3
  %68 = load i64, ptr %mem_offset, align 8
  %call122 = call zeroext i1 @tcg_out_dupm_vec(ptr noundef %62, i32 noundef %63, i32 noundef 3, i32 noundef %bf.cast118, i32 noundef %bf.cast121, i64 noundef %68)
  br i1 %call122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.then110
  br label %done

if.end124:                                        ; preds = %if.then110
  br label %if.end125

if.end125:                                        ; preds = %if.end124, %land.lhs.true107, %land.lhs.true100, %if.end93
  store i1 false, ptr %retval, align 1
  br label %return

done:                                             ; preds = %if.then123, %if.end89
  %69 = load ptr, ptr %ots, align 8
  %bf.load126 = load i64, ptr %69, align 8
  %bf.clear127 = and i64 %bf.load126, -137438953473
  %bf.set = or i64 %bf.clear127, 0
  store i64 %bf.set, ptr %69, align 8
  %70 = load i32, ptr %arg_life, align 4
  %and128 = and i32 %70, 32
  %tobool129 = icmp ne i32 %and128, 0
  br i1 %tobool129, label %if.then130, label %if.end131

if.then130:                                       ; preds = %done
  %71 = load ptr, ptr %s.addr, align 8
  %72 = load ptr, ptr %itsl, align 8
  call void @temp_dead(ptr noundef %71, ptr noundef %72)
  br label %if.end131

if.end131:                                        ; preds = %if.then130, %done
  %73 = load i32, ptr %arg_life, align 4
  %and132 = and i32 %73, 64
  %tobool133 = icmp ne i32 %and132, 0
  br i1 %tobool133, label %if.then134, label %if.end135

if.then134:                                       ; preds = %if.end131
  %74 = load ptr, ptr %s.addr, align 8
  %75 = load ptr, ptr %itsh, align 8
  call void @temp_dead(ptr noundef %74, ptr noundef %75)
  br label %if.end135

if.end135:                                        ; preds = %if.then134, %if.end131
  %76 = load i32, ptr %arg_life, align 4
  %and136 = and i32 %76, 1
  %tobool137 = icmp ne i32 %and136, 0
  br i1 %tobool137, label %if.then138, label %if.else141

if.then138:                                       ; preds = %if.end135
  %77 = load ptr, ptr %s.addr, align 8
  %78 = load ptr, ptr %ots, align 8
  %79 = load ptr, ptr %s.addr, align 8
  %reserved_regs139 = getelementptr inbounds %struct.TCGContext, ptr %79, i32 0, i32 16
  %80 = load i32, ptr %reserved_regs139, align 4
  %81 = load i32, ptr %arg_life, align 4
  %and140 = and i32 %81, 16
  call void @temp_sync(ptr noundef %77, ptr noundef %78, i32 noundef %80, i32 noundef 0, i32 noundef %and140)
  br label %if.end146

if.else141:                                       ; preds = %if.end135
  %82 = load i32, ptr %arg_life, align 4
  %and142 = and i32 %82, 16
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %if.then144, label %if.end145

if.then144:                                       ; preds = %if.else141
  %83 = load ptr, ptr %s.addr, align 8
  %84 = load ptr, ptr %ots, align 8
  call void @temp_dead(ptr noundef %83, ptr noundef %84)
  br label %if.end145

if.end145:                                        ; preds = %if.then144, %if.else141
  br label %if.end146

if.end146:                                        ; preds = %if.end145, %if.then138
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end146, %if.end125
  %85 = load i1, ptr %retval, align 1
  ret i1 %85
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_reg_alloc_op(ptr noundef %s, ptr noundef %op) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %op.addr = alloca ptr, align 8
  %arg_life = alloca i32, align 4
  %def = alloca ptr, align 8
  %i_allocated_regs = alloca i32, align 4
  %o_allocated_regs = alloca i32, align 4
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %nb_iargs = alloca i32, align 4
  %nb_oargs = alloca i32, align 4
  %reg = alloca i32, align 4
  %arg = alloca i64, align 8
  %arg_ct = alloca ptr, align 8
  %ts = alloca ptr, align 8
  %new_args = alloca [16 x i64], align 16
  %const_args = alloca [16 x i32], align 16
  %i_preferred_regs = alloca i32, align 4
  %i_required_regs = alloca i32, align 4
  %allocate_new_reg = alloca i8, align 1
  %copyto_new_reg = alloca i8, align 1
  %ts2 = alloca ptr, align 8
  %i1 = alloca i32, align 4
  %i2 = alloca i32, align 4
  %t_allocated_regs = alloca i32, align 4
  %nr = alloca i32, align 4
  %ok = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %life = getelementptr inbounds %struct.TCGOp, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %life, align 4
  store i32 %1, ptr %arg_life, align 4
  %2 = load ptr, ptr %op.addr, align 8
  %bf.load = load i32, ptr %2, align 8
  %bf.clear = and i32 %bf.load, 255
  %idxprom = zext i32 %bf.clear to i64
  %arrayidx = getelementptr [0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %def, align 8
  %3 = load ptr, ptr %def, align 8
  %nb_oargs1 = getelementptr inbounds %struct.TCGOpDef, ptr %3, i32 0, i32 1
  %4 = load i8, ptr %nb_oargs1, align 8
  %conv = zext i8 %4 to i32
  store i32 %conv, ptr %nb_oargs, align 4
  %5 = load ptr, ptr %def, align 8
  %nb_iargs2 = getelementptr inbounds %struct.TCGOpDef, ptr %5, i32 0, i32 2
  %6 = load i8, ptr %nb_iargs2, align 1
  %conv3 = zext i8 %6 to i32
  store i32 %conv3, ptr %nb_iargs, align 4
  %arraydecay = getelementptr inbounds [16 x i64], ptr %new_args, i64 0, i64 0
  %7 = load i32, ptr %nb_oargs, align 4
  %idx.ext = sext i32 %7 to i64
  %add.ptr = getelementptr i64, ptr %arraydecay, i64 %idx.ext
  %8 = load i32, ptr %nb_iargs, align 4
  %idx.ext4 = sext i32 %8 to i64
  %add.ptr5 = getelementptr i64, ptr %add.ptr, i64 %idx.ext4
  %9 = load ptr, ptr %op.addr, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %9, i32 0, i32 4
  %arraydecay6 = getelementptr inbounds [0 x i64], ptr %args, i64 0, i64 0
  %10 = load i32, ptr %nb_oargs, align 4
  %idx.ext7 = sext i32 %10 to i64
  %add.ptr8 = getelementptr i64, ptr %arraydecay6, i64 %idx.ext7
  %11 = load i32, ptr %nb_iargs, align 4
  %idx.ext9 = sext i32 %11 to i64
  %add.ptr10 = getelementptr i64, ptr %add.ptr8, i64 %idx.ext9
  %12 = load ptr, ptr %def, align 8
  %nb_cargs = getelementptr inbounds %struct.TCGOpDef, ptr %12, i32 0, i32 3
  %13 = load i8, ptr %nb_cargs, align 2
  %conv11 = zext i8 %13 to i64
  %mul = mul i64 8, %conv11
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %add.ptr5, ptr align 8 %add.ptr10, i64 %mul, i1 false)
  %14 = load ptr, ptr %s.addr, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 16
  %15 = load i32, ptr %reserved_regs, align 4
  store i32 %15, ptr %i_allocated_regs, align 4
  %16 = load ptr, ptr %s.addr, align 8
  %reserved_regs12 = getelementptr inbounds %struct.TCGContext, ptr %16, i32 0, i32 16
  %17 = load i32, ptr %reserved_regs12, align 4
  store i32 %17, ptr %o_allocated_regs, align 4
  store i32 0, ptr %k, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %18 = load i32, ptr %k, align 4
  %19 = load i32, ptr %nb_iargs, align 4
  %cmp = icmp slt i32 %18, %19
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load ptr, ptr %def, align 8
  %args_ct = getelementptr inbounds %struct.TCGOpDef, ptr %20, i32 0, i32 6
  %21 = load ptr, ptr %args_ct, align 8
  %22 = load i32, ptr %nb_oargs, align 4
  %23 = load i32, ptr %k, align 4
  %add = add i32 %22, %23
  %idxprom14 = sext i32 %add to i64
  %arrayidx15 = getelementptr %struct.TCGArgConstraint, ptr %21, i64 %idxprom14
  %bf.load16 = load i64, ptr %arrayidx15, align 4
  %bf.lshr = lshr i64 %bf.load16, 20
  %bf.clear17 = and i64 %bf.lshr, 15
  %bf.cast = trunc i64 %bf.clear17 to i32
  store i32 %bf.cast, ptr %i, align 4
  %24 = load ptr, ptr %op.addr, align 8
  %args18 = getelementptr inbounds %struct.TCGOp, ptr %24, i32 0, i32 4
  %25 = load i32, ptr %i, align 4
  %idxprom19 = sext i32 %25 to i64
  %arrayidx20 = getelementptr [0 x i64], ptr %args18, i64 0, i64 %idxprom19
  %26 = load i64, ptr %arrayidx20, align 8
  store i64 %26, ptr %arg, align 8
  %27 = load ptr, ptr %def, align 8
  %args_ct21 = getelementptr inbounds %struct.TCGOpDef, ptr %27, i32 0, i32 6
  %28 = load ptr, ptr %args_ct21, align 8
  %29 = load i32, ptr %i, align 4
  %idxprom22 = sext i32 %29 to i64
  %arrayidx23 = getelementptr %struct.TCGArgConstraint, ptr %28, i64 %idxprom22
  store ptr %arrayidx23, ptr %arg_ct, align 8
  %30 = load i64, ptr %arg, align 8
  %call = call ptr @arg_temp(i64 noundef %30)
  store ptr %call, ptr %ts, align 8
  %31 = load ptr, ptr %ts, align 8
  %bf.load24 = load i64, ptr %31, align 8
  %bf.lshr25 = lshr i64 %bf.load24, 8
  %bf.clear26 = and i64 %bf.lshr25, 255
  %bf.cast27 = trunc i64 %bf.clear26 to i32
  %cmp28 = icmp eq i32 %bf.cast27, 3
  br i1 %cmp28, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %32 = load ptr, ptr %ts, align 8
  %val = getelementptr inbounds %struct.TCGTemp, ptr %32, i32 0, i32 1
  %33 = load i64, ptr %val, align 8
  %34 = load ptr, ptr %ts, align 8
  %bf.load30 = load i64, ptr %34, align 8
  %bf.lshr31 = lshr i64 %bf.load30, 24
  %bf.clear32 = and i64 %bf.lshr31, 255
  %bf.cast33 = trunc i64 %bf.clear32 to i32
  %35 = load ptr, ptr %arg_ct, align 8
  %bf.load34 = load i64, ptr %35, align 4
  %bf.clear35 = and i64 %bf.load34, 65535
  %bf.cast36 = trunc i64 %bf.clear35 to i32
  %36 = load ptr, ptr %op.addr, align 8
  %bf.load37 = load i32, ptr %36, align 8
  %bf.lshr38 = lshr i32 %bf.load37, 24
  %call39 = call zeroext i1 @tcg_target_const_match(i64 noundef %33, i32 noundef %bf.cast33, i32 noundef %bf.cast36, i32 noundef %bf.lshr38)
  br i1 %call39, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %37 = load i32, ptr %i, align 4
  %idxprom41 = sext i32 %37 to i64
  %arrayidx42 = getelementptr [16 x i32], ptr %const_args, i64 0, i64 %idxprom41
  store i32 1, ptr %arrayidx42, align 4
  %38 = load ptr, ptr %ts, align 8
  %val43 = getelementptr inbounds %struct.TCGTemp, ptr %38, i32 0, i32 1
  %39 = load i64, ptr %val43, align 8
  %40 = load i32, ptr %i, align 4
  %idxprom44 = sext i32 %40 to i64
  %arrayidx45 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 %idxprom44
  store i64 %39, ptr %arrayidx45, align 8
  br label %for.inc

if.end:                                           ; preds = %land.lhs.true, %for.body
  %41 = load ptr, ptr %ts, align 8
  %bf.load46 = load i64, ptr %41, align 8
  %bf.clear47 = and i64 %bf.load46, 255
  %bf.cast48 = trunc i64 %bf.clear47 to i32
  store i32 %bf.cast48, ptr %reg, align 4
  store i32 0, ptr %i_preferred_regs, align 4
  %42 = load ptr, ptr %arg_ct, align 8
  %regs = getelementptr inbounds %struct.TCGArgConstraint, ptr %42, i32 0, i32 1
  %43 = load i32, ptr %regs, align 4
  store i32 %43, ptr %i_required_regs, align 4
  store i8 0, ptr %allocate_new_reg, align 1
  store i8 0, ptr %copyto_new_reg, align 1
  %44 = load ptr, ptr %arg_ct, align 8
  %bf.load49 = load i64, ptr %44, align 4
  %bf.lshr50 = lshr i64 %bf.load49, 28
  %bf.clear51 = and i64 %bf.lshr50, 3
  %bf.cast52 = trunc i64 %bf.clear51 to i32
  switch i32 %bf.cast52, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb116
    i32 2, label %sw.bb235
    i32 3, label %sw.bb244
  ]

sw.bb:                                            ; preds = %if.end
  %45 = load ptr, ptr %arg_ct, align 8
  %bf.load53 = load i64, ptr %45, align 4
  %bf.lshr54 = lshr i64 %bf.load53, 31
  %bf.clear55 = and i64 %bf.lshr54, 1
  %bf.cast56 = trunc i64 %bf.clear55 to i1
  br i1 %bf.cast56, label %if.then57, label %if.end90

if.then57:                                        ; preds = %sw.bb
  %46 = load ptr, ptr %op.addr, align 8
  %47 = load ptr, ptr %arg_ct, align 8
  %bf.load58 = load i64, ptr %47, align 4
  %bf.lshr59 = lshr i64 %bf.load58, 16
  %bf.clear60 = and i64 %bf.lshr59, 15
  %bf.cast61 = trunc i64 %bf.clear60 to i32
  %call62 = call i32 @output_pref(ptr noundef %46, i32 noundef %bf.cast61)
  store i32 %call62, ptr %i_preferred_regs, align 4
  %48 = load ptr, ptr %ts, align 8
  %call63 = call zeroext i1 @temp_readonly(ptr noundef %48)
  br i1 %call63, label %if.then78, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then57
  %49 = load i32, ptr %arg_life, align 4
  %50 = load i32, ptr %i, align 4
  %shl = shl i32 16, %50
  %and = and i32 %49, %shl
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false65, label %if.then78

lor.lhs.false65:                                  ; preds = %lor.lhs.false
  %51 = load ptr, ptr %def, align 8
  %args_ct66 = getelementptr inbounds %struct.TCGOpDef, ptr %51, i32 0, i32 6
  %52 = load ptr, ptr %args_ct66, align 8
  %53 = load ptr, ptr %arg_ct, align 8
  %bf.load67 = load i64, ptr %53, align 4
  %bf.lshr68 = lshr i64 %bf.load67, 16
  %bf.clear69 = and i64 %bf.lshr68, 15
  %bf.cast70 = trunc i64 %bf.clear69 to i32
  %idxprom71 = zext i32 %bf.cast70 to i64
  %arrayidx72 = getelementptr %struct.TCGArgConstraint, ptr %52, i64 %idxprom71
  %bf.load73 = load i64, ptr %arrayidx72, align 4
  %bf.lshr74 = lshr i64 %bf.load73, 32
  %bf.clear75 = and i64 %bf.lshr74, 1
  %bf.cast76 = trunc i64 %bf.clear75 to i1
  br i1 %bf.cast76, label %if.then78, label %if.else

if.then78:                                        ; preds = %lor.lhs.false65, %lor.lhs.false, %if.then57
  store i8 1, ptr %allocate_new_reg, align 1
  br label %if.end89

if.else:                                          ; preds = %lor.lhs.false65
  %54 = load ptr, ptr %ts, align 8
  %bf.load79 = load i64, ptr %54, align 8
  %bf.lshr80 = lshr i64 %bf.load79, 8
  %bf.clear81 = and i64 %bf.lshr80, 255
  %bf.cast82 = trunc i64 %bf.clear81 to i32
  %cmp83 = icmp eq i32 %bf.cast82, 1
  br i1 %cmp83, label %if.then85, label %if.end88

if.then85:                                        ; preds = %if.else
  %55 = load i32, ptr %i_allocated_regs, align 4
  %56 = load i32, ptr %reg, align 4
  %shr = lshr i32 %55, %56
  %and86 = and i32 %shr, 1
  %tobool87 = icmp ne i32 %and86, 0
  %frombool = zext i1 %tobool87 to i8
  store i8 %frombool, ptr %allocate_new_reg, align 1
  br label %if.end88

if.end88:                                         ; preds = %if.then85, %if.else
  br label %if.end89

if.end89:                                         ; preds = %if.end88, %if.then78
  br label %if.end90

if.end90:                                         ; preds = %if.end89, %sw.bb
  %57 = load i8, ptr %allocate_new_reg, align 1
  %tobool91 = trunc i8 %57 to i1
  br i1 %tobool91, label %if.end100, label %if.then92

if.then92:                                        ; preds = %if.end90
  %58 = load ptr, ptr %s.addr, align 8
  %59 = load ptr, ptr %ts, align 8
  %60 = load i32, ptr %i_required_regs, align 4
  %61 = load i32, ptr %i_allocated_regs, align 4
  %62 = load i32, ptr %i_preferred_regs, align 4
  call void @temp_load(ptr noundef %58, ptr noundef %59, i32 noundef %60, i32 noundef %61, i32 noundef %62)
  %63 = load ptr, ptr %ts, align 8
  %bf.load93 = load i64, ptr %63, align 8
  %bf.clear94 = and i64 %bf.load93, 255
  %bf.cast95 = trunc i64 %bf.clear94 to i32
  store i32 %bf.cast95, ptr %reg, align 4
  %64 = load i32, ptr %i_required_regs, align 4
  %65 = load i32, ptr %reg, align 4
  %shr96 = lshr i32 %64, %65
  %and97 = and i32 %shr96, 1
  %tobool98 = icmp ne i32 %and97, 0
  %lnot = xor i1 %tobool98, true
  %frombool99 = zext i1 %lnot to i8
  store i8 %frombool99, ptr %allocate_new_reg, align 1
  br label %if.end100

if.end100:                                        ; preds = %if.then92, %if.end90
  %66 = load i8, ptr %allocate_new_reg, align 1
  %tobool101 = trunc i8 %66 to i1
  br i1 %tobool101, label %if.then102, label %if.end115

if.then102:                                       ; preds = %if.end100
  %67 = load ptr, ptr %s.addr, align 8
  %68 = load ptr, ptr %ts, align 8
  %69 = load ptr, ptr %ts, align 8
  %bf.load103 = load i64, ptr %69, align 8
  %bf.lshr104 = lshr i64 %bf.load103, 24
  %bf.clear105 = and i64 %bf.lshr104, 255
  %bf.cast106 = trunc i64 %bf.clear105 to i32
  %idxprom107 = zext i32 %bf.cast106 to i64
  %arrayidx108 = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom107
  %70 = load i32, ptr %arrayidx108, align 4
  %71 = load i32, ptr %i_allocated_regs, align 4
  call void @temp_load(ptr noundef %67, ptr noundef %68, i32 noundef %70, i32 noundef %71, i32 noundef 0)
  %72 = load ptr, ptr %s.addr, align 8
  %73 = load i32, ptr %i_required_regs, align 4
  %74 = load i32, ptr %i_allocated_regs, align 4
  %75 = load i32, ptr %i_preferred_regs, align 4
  %76 = load ptr, ptr %ts, align 8
  %bf.load109 = load i64, ptr %76, align 8
  %bf.lshr110 = lshr i64 %bf.load109, 36
  %bf.clear111 = and i64 %bf.lshr110, 1
  %bf.cast112 = trunc i64 %bf.clear111 to i32
  %tobool113 = icmp ne i32 %bf.cast112, 0
  %call114 = call i32 @tcg_reg_alloc(ptr noundef %72, i32 noundef %73, i32 noundef %74, i32 noundef %75, i1 noundef zeroext %tobool113)
  store i32 %call114, ptr %reg, align 4
  store i8 1, ptr %copyto_new_reg, align 1
  br label %if.end115

if.end115:                                        ; preds = %if.then102, %if.end100
  br label %sw.epilog

sw.bb116:                                         ; preds = %if.end
  %77 = load i32, ptr %i, align 4
  store i32 %77, ptr %i1, align 4
  %78 = load ptr, ptr %arg_ct, align 8
  %bf.load117 = load i64, ptr %78, align 4
  %bf.lshr118 = lshr i64 %bf.load117, 24
  %bf.clear119 = and i64 %bf.lshr118, 15
  %bf.cast120 = trunc i64 %bf.clear119 to i32
  store i32 %bf.cast120, ptr %i2, align 4
  %79 = load i32, ptr %i1, align 4
  %80 = load i32, ptr %i2, align 4
  %cmp121 = icmp ne i32 %79, %80
  br i1 %cmp121, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb116
  %81 = load ptr, ptr %op.addr, align 8
  %args123 = getelementptr inbounds %struct.TCGOp, ptr %81, i32 0, i32 4
  %82 = load i32, ptr %i2, align 4
  %idxprom124 = sext i32 %82 to i64
  %arrayidx125 = getelementptr [0 x i64], ptr %args123, i64 0, i64 %idxprom124
  %83 = load i64, ptr %arrayidx125, align 8
  %call126 = call ptr @arg_temp(i64 noundef %83)
  br label %cond.end

cond.false:                                       ; preds = %sw.bb116
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call126, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %ts2, align 8
  %84 = load ptr, ptr %arg_ct, align 8
  %bf.load127 = load i64, ptr %84, align 4
  %bf.lshr128 = lshr i64 %bf.load127, 31
  %bf.clear129 = and i64 %bf.lshr128, 1
  %bf.cast130 = trunc i64 %bf.clear129 to i1
  br i1 %bf.cast130, label %if.then131, label %if.else198

if.then131:                                       ; preds = %cond.end
  %85 = load ptr, ptr %op.addr, align 8
  %86 = load ptr, ptr %arg_ct, align 8
  %bf.load132 = load i64, ptr %86, align 4
  %bf.lshr133 = lshr i64 %bf.load132, 16
  %bf.clear134 = and i64 %bf.lshr133, 15
  %bf.cast135 = trunc i64 %bf.clear134 to i32
  %call136 = call i32 @output_pref(ptr noundef %85, i32 noundef %bf.cast135)
  store i32 %call136, ptr %i_preferred_regs, align 4
  %87 = load i32, ptr %arg_life, align 4
  %88 = load i32, ptr %i1, align 4
  %shl137 = shl i32 16, %88
  %and138 = and i32 %87, %shl137
  %tobool139 = icmp ne i32 %and138, 0
  br i1 %tobool139, label %land.lhs.true140, label %if.end197

land.lhs.true140:                                 ; preds = %if.then131
  %89 = load i32, ptr %arg_life, align 4
  %90 = load i32, ptr %i2, align 4
  %shl141 = shl i32 16, %90
  %and142 = and i32 %89, %shl141
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %land.lhs.true144, label %if.end197

land.lhs.true144:                                 ; preds = %land.lhs.true140
  %91 = load ptr, ptr %ts, align 8
  %call145 = call zeroext i1 @temp_readonly(ptr noundef %91)
  br i1 %call145, label %if.end197, label %land.lhs.true146

land.lhs.true146:                                 ; preds = %land.lhs.true144
  %92 = load ptr, ptr %ts, align 8
  %bf.load147 = load i64, ptr %92, align 8
  %bf.lshr148 = lshr i64 %bf.load147, 8
  %bf.clear149 = and i64 %bf.lshr148, 255
  %bf.cast150 = trunc i64 %bf.clear149 to i32
  %cmp151 = icmp eq i32 %bf.cast150, 1
  br i1 %cmp151, label %land.lhs.true153, label %if.end197

land.lhs.true153:                                 ; preds = %land.lhs.true146
  %93 = load ptr, ptr %ts, align 8
  %bf.load154 = load i64, ptr %93, align 8
  %bf.clear155 = and i64 %bf.load154, 255
  %bf.cast156 = trunc i64 %bf.clear155 to i32
  %cmp157 = icmp slt i32 %bf.cast156, 31
  br i1 %cmp157, label %land.lhs.true159, label %if.end197

land.lhs.true159:                                 ; preds = %land.lhs.true153
  %94 = load i32, ptr %i_required_regs, align 4
  %95 = load i32, ptr %reg, align 4
  %shr160 = lshr i32 %94, %95
  %and161 = and i32 %shr160, 1
  %tobool162 = icmp ne i32 %and161, 0
  br i1 %tobool162, label %land.lhs.true163, label %if.end197

land.lhs.true163:                                 ; preds = %land.lhs.true159
  %96 = load i32, ptr %i_allocated_regs, align 4
  %97 = load i32, ptr %reg, align 4
  %shr164 = lshr i32 %96, %97
  %and165 = and i32 %shr164, 1
  %tobool166 = icmp ne i32 %and165, 0
  br i1 %tobool166, label %if.end197, label %land.lhs.true167

land.lhs.true167:                                 ; preds = %land.lhs.true163
  %98 = load i32, ptr %i_allocated_regs, align 4
  %99 = load i32, ptr %reg, align 4
  %add168 = add i32 %99, 1
  %shr169 = lshr i32 %98, %add168
  %and170 = and i32 %shr169, 1
  %tobool171 = icmp ne i32 %and170, 0
  br i1 %tobool171, label %if.end197, label %land.lhs.true172

land.lhs.true172:                                 ; preds = %land.lhs.true167
  %100 = load ptr, ptr %ts2, align 8
  %tobool173 = icmp ne ptr %100, null
  br i1 %tobool173, label %cond.true174, label %cond.false190

cond.true174:                                     ; preds = %land.lhs.true172
  %101 = load ptr, ptr %ts2, align 8
  %bf.load175 = load i64, ptr %101, align 8
  %bf.lshr176 = lshr i64 %bf.load175, 8
  %bf.clear177 = and i64 %bf.lshr176, 255
  %bf.cast178 = trunc i64 %bf.clear177 to i32
  %cmp179 = icmp eq i32 %bf.cast178, 1
  br i1 %cmp179, label %land.lhs.true181, label %if.end197

land.lhs.true181:                                 ; preds = %cond.true174
  %102 = load ptr, ptr %ts2, align 8
  %bf.load182 = load i64, ptr %102, align 8
  %bf.clear183 = and i64 %bf.load182, 255
  %bf.cast184 = trunc i64 %bf.clear183 to i32
  %103 = load i32, ptr %reg, align 4
  %add185 = add i32 %103, 1
  %cmp186 = icmp eq i32 %bf.cast184, %add185
  br i1 %cmp186, label %land.lhs.true188, label %if.end197

land.lhs.true188:                                 ; preds = %land.lhs.true181
  %104 = load ptr, ptr %ts2, align 8
  %call189 = call zeroext i1 @temp_readonly(ptr noundef %104)
  br i1 %call189, label %if.end197, label %if.then196

cond.false190:                                    ; preds = %land.lhs.true172
  %105 = load ptr, ptr %s.addr, align 8
  %reg_to_temp = getelementptr inbounds %struct.TCGContext, ptr %105, i32 0, i32 41
  %106 = load i32, ptr %reg, align 4
  %add191 = add i32 %106, 1
  %idxprom192 = zext i32 %add191 to i64
  %arrayidx193 = getelementptr [32 x ptr], ptr %reg_to_temp, i64 0, i64 %idxprom192
  %107 = load ptr, ptr %arrayidx193, align 8
  %cmp194 = icmp eq ptr %107, null
  br i1 %cmp194, label %if.then196, label %if.end197

if.then196:                                       ; preds = %cond.false190, %land.lhs.true188
  br label %sw.epilog

if.end197:                                        ; preds = %cond.false190, %land.lhs.true188, %land.lhs.true181, %cond.true174, %land.lhs.true167, %land.lhs.true163, %land.lhs.true159, %land.lhs.true153, %land.lhs.true146, %land.lhs.true144, %land.lhs.true140, %if.then131
  br label %if.end228

if.else198:                                       ; preds = %cond.end
  br label %do.body

do.body:                                          ; preds = %if.else198
  %108 = load ptr, ptr %ts2, align 8
  %tobool199 = icmp ne ptr %108, null
  br i1 %tobool199, label %if.end201, label %if.then200

if.then200:                                       ; preds = %do.body
  unreachable

if.end201:                                        ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end201
  %109 = load ptr, ptr %ts, align 8
  %bf.load202 = load i64, ptr %109, align 8
  %bf.lshr203 = lshr i64 %bf.load202, 8
  %bf.clear204 = and i64 %bf.lshr203, 255
  %bf.cast205 = trunc i64 %bf.clear204 to i32
  %cmp206 = icmp eq i32 %bf.cast205, 1
  br i1 %cmp206, label %land.lhs.true208, label %if.end227

land.lhs.true208:                                 ; preds = %do.end
  %110 = load ptr, ptr %ts2, align 8
  %bf.load209 = load i64, ptr %110, align 8
  %bf.lshr210 = lshr i64 %bf.load209, 8
  %bf.clear211 = and i64 %bf.lshr210, 255
  %bf.cast212 = trunc i64 %bf.clear211 to i32
  %cmp213 = icmp eq i32 %bf.cast212, 1
  br i1 %cmp213, label %land.lhs.true215, label %if.end227

land.lhs.true215:                                 ; preds = %land.lhs.true208
  %111 = load ptr, ptr %ts2, align 8
  %bf.load216 = load i64, ptr %111, align 8
  %bf.clear217 = and i64 %bf.load216, 255
  %bf.cast218 = trunc i64 %bf.clear217 to i32
  %112 = load i32, ptr %reg, align 4
  %add219 = add i32 %112, 1
  %cmp220 = icmp eq i32 %bf.cast218, %add219
  br i1 %cmp220, label %land.lhs.true222, label %if.end227

land.lhs.true222:                                 ; preds = %land.lhs.true215
  %113 = load i32, ptr %i_required_regs, align 4
  %114 = load i32, ptr %reg, align 4
  %shr223 = lshr i32 %113, %114
  %and224 = and i32 %shr223, 1
  %tobool225 = icmp ne i32 %and224, 0
  br i1 %tobool225, label %if.then226, label %if.end227

if.then226:                                       ; preds = %land.lhs.true222
  br label %sw.epilog

if.end227:                                        ; preds = %land.lhs.true222, %land.lhs.true215, %land.lhs.true208, %do.end
  br label %if.end228

if.end228:                                        ; preds = %if.end227, %if.end197
  %115 = load ptr, ptr %s.addr, align 8
  %116 = load i32, ptr %i_required_regs, align 4
  %117 = load i32, ptr %i_allocated_regs, align 4
  %118 = load ptr, ptr %ts, align 8
  %bf.load229 = load i64, ptr %118, align 8
  %bf.lshr230 = lshr i64 %bf.load229, 36
  %bf.clear231 = and i64 %bf.lshr230, 1
  %bf.cast232 = trunc i64 %bf.clear231 to i32
  %tobool233 = icmp ne i32 %bf.cast232, 0
  %call234 = call i32 @tcg_reg_alloc_pair(ptr noundef %115, i32 noundef %116, i32 noundef %117, i32 noundef 0, i1 noundef zeroext %tobool233)
  store i32 %call234, ptr %reg, align 4
  br label %do_pair

sw.bb235:                                         ; preds = %if.end
  %119 = load ptr, ptr %arg_ct, align 8
  %bf.load236 = load i64, ptr %119, align 4
  %bf.lshr237 = lshr i64 %bf.load236, 24
  %bf.clear238 = and i64 %bf.lshr237, 15
  %bf.cast239 = trunc i64 %bf.clear238 to i32
  %idxprom240 = zext i32 %bf.cast239 to i64
  %arrayidx241 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 %idxprom240
  %120 = load i64, ptr %arrayidx241, align 8
  %add242 = add i64 %120, 1
  %conv243 = trunc i64 %add242 to i32
  store i32 %conv243, ptr %reg, align 4
  br label %do_pair

sw.bb244:                                         ; preds = %if.end
  br label %do.body245

do.body245:                                       ; preds = %sw.bb244
  %121 = load ptr, ptr %arg_ct, align 8
  %bf.load246 = load i64, ptr %121, align 4
  %bf.lshr247 = lshr i64 %bf.load246, 31
  %bf.clear248 = and i64 %bf.lshr247, 1
  %bf.cast249 = trunc i64 %bf.clear248 to i1
  br i1 %bf.cast249, label %if.end251, label %if.then250

if.then250:                                       ; preds = %do.body245
  unreachable

if.end251:                                        ; preds = %do.body245
  br label %do.end252

do.end252:                                        ; preds = %if.end251
  %122 = load ptr, ptr %op.addr, align 8
  %123 = load ptr, ptr %arg_ct, align 8
  %bf.load253 = load i64, ptr %123, align 4
  %bf.lshr254 = lshr i64 %bf.load253, 16
  %bf.clear255 = and i64 %bf.lshr254, 15
  %bf.cast256 = trunc i64 %bf.clear255 to i32
  %call257 = call i32 @output_pref(ptr noundef %122, i32 noundef %bf.cast256)
  store i32 %call257, ptr %i_preferred_regs, align 4
  %124 = load i32, ptr %arg_life, align 4
  %125 = load i32, ptr %i, align 4
  %shl258 = shl i32 16, %125
  %and259 = and i32 %124, %shl258
  %tobool260 = icmp ne i32 %and259, 0
  br i1 %tobool260, label %land.lhs.true261, label %if.end295

land.lhs.true261:                                 ; preds = %do.end252
  %126 = load ptr, ptr %ts, align 8
  %call262 = call zeroext i1 @temp_readonly(ptr noundef %126)
  br i1 %call262, label %if.end295, label %land.lhs.true263

land.lhs.true263:                                 ; preds = %land.lhs.true261
  %127 = load ptr, ptr %ts, align 8
  %bf.load264 = load i64, ptr %127, align 8
  %bf.lshr265 = lshr i64 %bf.load264, 8
  %bf.clear266 = and i64 %bf.lshr265, 255
  %bf.cast267 = trunc i64 %bf.clear266 to i32
  %cmp268 = icmp eq i32 %bf.cast267, 1
  br i1 %cmp268, label %land.lhs.true270, label %if.end295

land.lhs.true270:                                 ; preds = %land.lhs.true263
  %128 = load i32, ptr %reg, align 4
  %cmp271 = icmp ugt i32 %128, 0
  br i1 %cmp271, label %land.lhs.true273, label %if.end295

land.lhs.true273:                                 ; preds = %land.lhs.true270
  %129 = load ptr, ptr %s.addr, align 8
  %reg_to_temp274 = getelementptr inbounds %struct.TCGContext, ptr %129, i32 0, i32 41
  %130 = load i32, ptr %reg, align 4
  %sub = sub i32 %130, 1
  %idxprom275 = zext i32 %sub to i64
  %arrayidx276 = getelementptr [32 x ptr], ptr %reg_to_temp274, i64 0, i64 %idxprom275
  %131 = load ptr, ptr %arrayidx276, align 8
  %cmp277 = icmp eq ptr %131, null
  br i1 %cmp277, label %land.lhs.true279, label %if.end295

land.lhs.true279:                                 ; preds = %land.lhs.true273
  %132 = load i32, ptr %i_required_regs, align 4
  %133 = load i32, ptr %reg, align 4
  %shr280 = lshr i32 %132, %133
  %and281 = and i32 %shr280, 1
  %tobool282 = icmp ne i32 %and281, 0
  br i1 %tobool282, label %land.lhs.true283, label %if.end295

land.lhs.true283:                                 ; preds = %land.lhs.true279
  %134 = load i32, ptr %i_allocated_regs, align 4
  %135 = load i32, ptr %reg, align 4
  %shr284 = lshr i32 %134, %135
  %and285 = and i32 %shr284, 1
  %tobool286 = icmp ne i32 %and285, 0
  br i1 %tobool286, label %if.end295, label %land.lhs.true287

land.lhs.true287:                                 ; preds = %land.lhs.true283
  %136 = load i32, ptr %i_allocated_regs, align 4
  %137 = load i32, ptr %reg, align 4
  %sub288 = sub i32 %137, 1
  %shr289 = lshr i32 %136, %sub288
  %and290 = and i32 %shr289, 1
  %tobool291 = icmp ne i32 %and290, 0
  br i1 %tobool291, label %if.end295, label %if.then292

if.then292:                                       ; preds = %land.lhs.true287
  %138 = load i32, ptr %reg, align 4
  %sub293 = sub i32 %138, 1
  %shl294 = shl i32 1, %sub293
  %139 = load i32, ptr %i_allocated_regs, align 4
  %or = or i32 %139, %shl294
  store i32 %or, ptr %i_allocated_regs, align 4
  br label %sw.epilog

if.end295:                                        ; preds = %land.lhs.true287, %land.lhs.true283, %land.lhs.true279, %land.lhs.true273, %land.lhs.true270, %land.lhs.true263, %land.lhs.true261, %do.end252
  %140 = load ptr, ptr %s.addr, align 8
  %141 = load i32, ptr %i_required_regs, align 4
  %shr296 = lshr i32 %141, 1
  %142 = load i32, ptr %i_allocated_regs, align 4
  %143 = load ptr, ptr %ts, align 8
  %bf.load297 = load i64, ptr %143, align 8
  %bf.lshr298 = lshr i64 %bf.load297, 36
  %bf.clear299 = and i64 %bf.lshr298, 1
  %bf.cast300 = trunc i64 %bf.clear299 to i32
  %tobool301 = icmp ne i32 %bf.cast300, 0
  %call302 = call i32 @tcg_reg_alloc_pair(ptr noundef %140, i32 noundef %shr296, i32 noundef %142, i32 noundef 0, i1 noundef zeroext %tobool301)
  store i32 %call302, ptr %reg, align 4
  %144 = load i32, ptr %reg, align 4
  %shl303 = shl i32 1, %144
  %145 = load i32, ptr %i_allocated_regs, align 4
  %or304 = or i32 %145, %shl303
  store i32 %or304, ptr %i_allocated_regs, align 4
  %146 = load i32, ptr %reg, align 4
  %add305 = add i32 %146, 1
  store i32 %add305, ptr %reg, align 4
  br label %do_pair

do_pair:                                          ; preds = %if.end295, %sw.bb235, %if.end228
  %147 = load ptr, ptr %arg_ct, align 8
  %bf.load306 = load i64, ptr %147, align 4
  %bf.lshr307 = lshr i64 %bf.load306, 31
  %bf.clear308 = and i64 %bf.lshr307, 1
  %bf.cast309 = trunc i64 %bf.clear308 to i1
  br i1 %bf.cast309, label %land.lhs.true311, label %if.else378

land.lhs.true311:                                 ; preds = %do_pair
  %148 = load i32, ptr %arg_life, align 4
  %149 = load i32, ptr %i, align 4
  %shl312 = shl i32 16, %149
  %and313 = and i32 %148, %shl312
  %tobool314 = icmp ne i32 %and313, 0
  br i1 %tobool314, label %lor.lhs.false315, label %if.then318

lor.lhs.false315:                                 ; preds = %land.lhs.true311
  %150 = load ptr, ptr %ts, align 8
  %call316 = call zeroext i1 @temp_readonly(ptr noundef %150)
  br i1 %call316, label %if.then318, label %if.else378

if.then318:                                       ; preds = %lor.lhs.false315, %land.lhs.true311
  %151 = load i32, ptr %i_allocated_regs, align 4
  store i32 %151, ptr %t_allocated_regs, align 4
  %152 = load i32, ptr %reg, align 4
  %shl319 = shl i32 1, %152
  %153 = load i32, ptr %t_allocated_regs, align 4
  %or320 = or i32 %153, %shl319
  store i32 %or320, ptr %t_allocated_regs, align 4
  %154 = load i32, ptr %reg, align 4
  %add321 = add i32 %154, 1
  %shl322 = shl i32 1, %add321
  %155 = load i32, ptr %t_allocated_regs, align 4
  %or323 = or i32 %155, %shl322
  store i32 %or323, ptr %t_allocated_regs, align 4
  %156 = load ptr, ptr %ts, align 8
  %bf.load324 = load i64, ptr %156, align 8
  %bf.lshr325 = lshr i64 %bf.load324, 8
  %bf.clear326 = and i64 %bf.lshr325, 255
  %bf.cast327 = trunc i64 %bf.clear326 to i32
  %cmp328 = icmp eq i32 %bf.cast327, 1
  br i1 %cmp328, label %land.lhs.true330, label %if.else370

land.lhs.true330:                                 ; preds = %if.then318
  %157 = load ptr, ptr %ts, align 8
  %bf.load331 = load i64, ptr %157, align 8
  %bf.clear332 = and i64 %bf.load331, 255
  %bf.cast333 = trunc i64 %bf.clear332 to i32
  %158 = load i32, ptr %reg, align 4
  %cmp334 = icmp eq i32 %bf.cast333, %158
  br i1 %cmp334, label %if.then336, label %if.else370

if.then336:                                       ; preds = %land.lhs.true330
  br label %do.body337

do.body337:                                       ; preds = %if.then336
  %159 = load ptr, ptr %ts, align 8
  %bf.load338 = load i64, ptr %159, align 8
  %bf.lshr339 = lshr i64 %bf.load338, 32
  %bf.clear340 = and i64 %bf.lshr339, 7
  %bf.cast341 = trunc i64 %bf.clear340 to i32
  %cmp342 = icmp ne i32 %bf.cast341, 3
  br i1 %cmp342, label %if.end345, label %if.then344

if.then344:                                       ; preds = %do.body337
  unreachable

if.end345:                                        ; preds = %do.body337
  br label %do.end346

do.end346:                                        ; preds = %if.end345
  %160 = load ptr, ptr %s.addr, align 8
  %161 = load ptr, ptr %ts, align 8
  %bf.load347 = load i64, ptr %161, align 8
  %bf.lshr348 = lshr i64 %bf.load347, 24
  %bf.clear349 = and i64 %bf.lshr348, 255
  %bf.cast350 = trunc i64 %bf.clear349 to i32
  %idxprom351 = zext i32 %bf.cast350 to i64
  %arrayidx352 = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom351
  %162 = load i32, ptr %arrayidx352, align 4
  %163 = load i32, ptr %t_allocated_regs, align 4
  %164 = load ptr, ptr %ts, align 8
  %bf.load353 = load i64, ptr %164, align 8
  %bf.lshr354 = lshr i64 %bf.load353, 36
  %bf.clear355 = and i64 %bf.lshr354, 1
  %bf.cast356 = trunc i64 %bf.clear355 to i32
  %tobool357 = icmp ne i32 %bf.cast356, 0
  %call358 = call i32 @tcg_reg_alloc(ptr noundef %160, i32 noundef %162, i32 noundef %163, i32 noundef 0, i1 noundef zeroext %tobool357)
  store i32 %call358, ptr %nr, align 4
  %165 = load ptr, ptr %s.addr, align 8
  %166 = load ptr, ptr %ts, align 8
  %bf.load359 = load i64, ptr %166, align 8
  %bf.lshr360 = lshr i64 %bf.load359, 24
  %bf.clear361 = and i64 %bf.lshr360, 255
  %bf.cast362 = trunc i64 %bf.clear361 to i32
  %167 = load i32, ptr %nr, align 4
  %168 = load i32, ptr %reg, align 4
  %call363 = call zeroext i1 @tcg_out_mov(ptr noundef %165, i32 noundef %bf.cast362, i32 noundef %167, i32 noundef %168)
  %frombool364 = zext i1 %call363 to i8
  store i8 %frombool364, ptr %ok, align 1
  br label %do.body365

do.body365:                                       ; preds = %do.end346
  %169 = load i8, ptr %ok, align 1
  %tobool366 = trunc i8 %169 to i1
  br i1 %tobool366, label %if.end368, label %if.then367

if.then367:                                       ; preds = %do.body365
  unreachable

if.end368:                                        ; preds = %do.body365
  br label %do.end369

do.end369:                                        ; preds = %if.end368
  %170 = load ptr, ptr %s.addr, align 8
  %171 = load ptr, ptr %ts, align 8
  %172 = load i32, ptr %nr, align 4
  call void @set_temp_val_reg(ptr noundef %170, ptr noundef %171, i32 noundef %172)
  br label %if.end377

if.else370:                                       ; preds = %land.lhs.true330, %if.then318
  %173 = load ptr, ptr %s.addr, align 8
  %174 = load ptr, ptr %ts, align 8
  %175 = load ptr, ptr %ts, align 8
  %bf.load371 = load i64, ptr %175, align 8
  %bf.lshr372 = lshr i64 %bf.load371, 24
  %bf.clear373 = and i64 %bf.lshr372, 255
  %bf.cast374 = trunc i64 %bf.clear373 to i32
  %idxprom375 = zext i32 %bf.cast374 to i64
  %arrayidx376 = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom375
  %176 = load i32, ptr %arrayidx376, align 4
  %177 = load i32, ptr %t_allocated_regs, align 4
  call void @temp_load(ptr noundef %173, ptr noundef %174, i32 noundef %176, i32 noundef %177, i32 noundef 0)
  store i8 1, ptr %copyto_new_reg, align 1
  br label %if.end377

if.end377:                                        ; preds = %if.else370, %do.end369
  br label %if.end386

if.else378:                                       ; preds = %lor.lhs.false315, %do_pair
  %178 = load i32, ptr %reg, align 4
  %shl379 = shl i32 1, %178
  store i32 %shl379, ptr %i_required_regs, align 4
  %179 = load ptr, ptr %s.addr, align 8
  %180 = load ptr, ptr %ts, align 8
  %181 = load i32, ptr %i_required_regs, align 4
  %182 = load i32, ptr %i_allocated_regs, align 4
  %183 = load i32, ptr %i_preferred_regs, align 4
  call void @temp_load(ptr noundef %179, ptr noundef %180, i32 noundef %181, i32 noundef %182, i32 noundef %183)
  %184 = load ptr, ptr %ts, align 8
  %bf.load380 = load i64, ptr %184, align 8
  %bf.clear381 = and i64 %bf.load380, 255
  %bf.cast382 = trunc i64 %bf.clear381 to i32
  %185 = load i32, ptr %reg, align 4
  %cmp383 = icmp ne i32 %bf.cast382, %185
  %frombool385 = zext i1 %cmp383 to i8
  store i8 %frombool385, ptr %copyto_new_reg, align 1
  br label %if.end386

if.end386:                                        ; preds = %if.else378, %if.end377
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %do.body387

do.body387:                                       ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 4969, ptr noundef @__func__.tcg_reg_alloc_op, ptr noundef null) #15
  unreachable

do.end388:                                        ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end388, %if.end386, %if.then292, %if.then226, %if.then196, %if.end115
  %186 = load i8, ptr %copyto_new_reg, align 1
  %tobool389 = trunc i8 %186 to i1
  br i1 %tobool389, label %if.then390, label %if.end408

if.then390:                                       ; preds = %sw.epilog
  %187 = load ptr, ptr %s.addr, align 8
  %188 = load ptr, ptr %ts, align 8
  %bf.load391 = load i64, ptr %188, align 8
  %bf.lshr392 = lshr i64 %bf.load391, 24
  %bf.clear393 = and i64 %bf.lshr392, 255
  %bf.cast394 = trunc i64 %bf.clear393 to i32
  %189 = load i32, ptr %reg, align 4
  %190 = load ptr, ptr %ts, align 8
  %bf.load395 = load i64, ptr %190, align 8
  %bf.clear396 = and i64 %bf.load395, 255
  %bf.cast397 = trunc i64 %bf.clear396 to i32
  %call398 = call zeroext i1 @tcg_out_mov(ptr noundef %187, i32 noundef %bf.cast394, i32 noundef %189, i32 noundef %bf.cast397)
  br i1 %call398, label %if.end407, label %if.then399

if.then399:                                       ; preds = %if.then390
  %191 = load ptr, ptr %s.addr, align 8
  %192 = load ptr, ptr %ts, align 8
  %193 = load i32, ptr %i_allocated_regs, align 4
  call void @temp_sync(ptr noundef %191, ptr noundef %192, i32 noundef %193, i32 noundef 0, i32 noundef 0)
  %194 = load ptr, ptr %s.addr, align 8
  %195 = load ptr, ptr %ts, align 8
  %bf.load400 = load i64, ptr %195, align 8
  %bf.lshr401 = lshr i64 %bf.load400, 24
  %bf.clear402 = and i64 %bf.lshr401, 255
  %bf.cast403 = trunc i64 %bf.clear402 to i32
  %196 = load i32, ptr %reg, align 4
  %197 = load ptr, ptr %ts, align 8
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %197, i32 0, i32 2
  %198 = load ptr, ptr %mem_base, align 8
  %bf.load404 = load i64, ptr %198, align 8
  %bf.clear405 = and i64 %bf.load404, 255
  %bf.cast406 = trunc i64 %bf.clear405 to i32
  %199 = load ptr, ptr %ts, align 8
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %199, i32 0, i32 3
  %200 = load i64, ptr %mem_offset, align 8
  call void @tcg_out_ld(ptr noundef %194, i32 noundef %bf.cast403, i32 noundef %196, i32 noundef %bf.cast406, i64 noundef %200)
  br label %if.end407

if.end407:                                        ; preds = %if.then399, %if.then390
  br label %if.end408

if.end408:                                        ; preds = %if.end407, %sw.epilog
  %201 = load i32, ptr %reg, align 4
  %conv409 = zext i32 %201 to i64
  %202 = load i32, ptr %i, align 4
  %idxprom410 = sext i32 %202 to i64
  %arrayidx411 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 %idxprom410
  store i64 %conv409, ptr %arrayidx411, align 8
  %203 = load i32, ptr %i, align 4
  %idxprom412 = sext i32 %203 to i64
  %arrayidx413 = getelementptr [16 x i32], ptr %const_args, i64 0, i64 %idxprom412
  store i32 0, ptr %arrayidx413, align 4
  %204 = load i32, ptr %reg, align 4
  %shl414 = shl i32 1, %204
  %205 = load i32, ptr %i_allocated_regs, align 4
  %or415 = or i32 %205, %shl414
  store i32 %or415, ptr %i_allocated_regs, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end408, %if.then
  %206 = load i32, ptr %k, align 4
  %inc = add i32 %206, 1
  store i32 %inc, ptr %k, align 4
  br label %for.cond, !llvm.loop !71

for.end:                                          ; preds = %for.cond
  %207 = load i32, ptr %nb_oargs, align 4
  store i32 %207, ptr %i, align 4
  br label %for.cond416

for.cond416:                                      ; preds = %for.inc430, %for.end
  %208 = load i32, ptr %i, align 4
  %209 = load i32, ptr %nb_oargs, align 4
  %210 = load i32, ptr %nb_iargs, align 4
  %add417 = add i32 %209, %210
  %cmp418 = icmp slt i32 %208, %add417
  br i1 %cmp418, label %for.body420, label %for.end432

for.body420:                                      ; preds = %for.cond416
  %211 = load i32, ptr %arg_life, align 4
  %212 = load i32, ptr %i, align 4
  %shl421 = shl i32 16, %212
  %and422 = and i32 %211, %shl421
  %tobool423 = icmp ne i32 %and422, 0
  br i1 %tobool423, label %if.then424, label %if.end429

if.then424:                                       ; preds = %for.body420
  %213 = load ptr, ptr %s.addr, align 8
  %214 = load ptr, ptr %op.addr, align 8
  %args425 = getelementptr inbounds %struct.TCGOp, ptr %214, i32 0, i32 4
  %215 = load i32, ptr %i, align 4
  %idxprom426 = sext i32 %215 to i64
  %arrayidx427 = getelementptr [0 x i64], ptr %args425, i64 0, i64 %idxprom426
  %216 = load i64, ptr %arrayidx427, align 8
  %call428 = call ptr @arg_temp(i64 noundef %216)
  call void @temp_dead(ptr noundef %213, ptr noundef %call428)
  br label %if.end429

if.end429:                                        ; preds = %if.then424, %for.body420
  br label %for.inc430

for.inc430:                                       ; preds = %if.end429
  %217 = load i32, ptr %i, align 4
  %inc431 = add i32 %217, 1
  store i32 %inc431, ptr %i, align 4
  br label %for.cond416, !llvm.loop !72

for.end432:                                       ; preds = %for.cond416
  %218 = load ptr, ptr %def, align 8
  %flags = getelementptr inbounds %struct.TCGOpDef, ptr %218, i32 0, i32 5
  %219 = load i8, ptr %flags, align 4
  %conv433 = zext i8 %219 to i32
  %and434 = and i32 %conv433, 128
  %tobool435 = icmp ne i32 %and434, 0
  br i1 %tobool435, label %if.then436, label %if.else437

if.then436:                                       ; preds = %for.end432
  %220 = load ptr, ptr %s.addr, align 8
  %221 = load i32, ptr %i_allocated_regs, align 4
  call void @tcg_reg_alloc_cbranch(ptr noundef %220, i32 noundef %221)
  br label %if.end636

if.else437:                                       ; preds = %for.end432
  %222 = load ptr, ptr %def, align 8
  %flags438 = getelementptr inbounds %struct.TCGOpDef, ptr %222, i32 0, i32 5
  %223 = load i8, ptr %flags438, align 4
  %conv439 = zext i8 %223 to i32
  %and440 = and i32 %conv439, 2
  %tobool441 = icmp ne i32 %and440, 0
  br i1 %tobool441, label %if.then442, label %if.else443

if.then442:                                       ; preds = %if.else437
  %224 = load ptr, ptr %s.addr, align 8
  %225 = load i32, ptr %i_allocated_regs, align 4
  call void @tcg_reg_alloc_bb_end(ptr noundef %224, i32 noundef %225)
  br label %if.end635

if.else443:                                       ; preds = %if.else437
  %226 = load ptr, ptr %def, align 8
  %flags444 = getelementptr inbounds %struct.TCGOpDef, ptr %226, i32 0, i32 5
  %227 = load i8, ptr %flags444, align 4
  %conv445 = zext i8 %227 to i32
  %and446 = and i32 %conv445, 4
  %tobool447 = icmp ne i32 %and446, 0
  br i1 %tobool447, label %if.then448, label %if.end461

if.then448:                                       ; preds = %if.else443
  store i32 0, ptr %i, align 4
  br label %for.cond449

for.cond449:                                      ; preds = %for.inc458, %if.then448
  %228 = load i32, ptr %i, align 4
  %cmp450 = icmp slt i32 %228, 32
  br i1 %cmp450, label %for.body452, label %for.end460

for.body452:                                      ; preds = %for.cond449
  %229 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %230 = load i32, ptr %i, align 4
  %shr453 = lshr i32 %229, %230
  %and454 = and i32 %shr453, 1
  %tobool455 = icmp ne i32 %and454, 0
  br i1 %tobool455, label %if.then456, label %if.end457

if.then456:                                       ; preds = %for.body452
  %231 = load ptr, ptr %s.addr, align 8
  %232 = load i32, ptr %i, align 4
  %233 = load i32, ptr %i_allocated_regs, align 4
  call void @tcg_reg_free(ptr noundef %231, i32 noundef %232, i32 noundef %233)
  br label %if.end457

if.end457:                                        ; preds = %if.then456, %for.body452
  br label %for.inc458

for.inc458:                                       ; preds = %if.end457
  %234 = load i32, ptr %i, align 4
  %inc459 = add i32 %234, 1
  store i32 %inc459, ptr %i, align 4
  br label %for.cond449, !llvm.loop !73

for.end460:                                       ; preds = %for.cond449
  br label %if.end461

if.end461:                                        ; preds = %for.end460, %if.else443
  %235 = load ptr, ptr %def, align 8
  %flags462 = getelementptr inbounds %struct.TCGOpDef, ptr %235, i32 0, i32 5
  %236 = load i8, ptr %flags462, align 4
  %conv463 = zext i8 %236 to i32
  %and464 = and i32 %conv463, 8
  %tobool465 = icmp ne i32 %and464, 0
  br i1 %tobool465, label %if.then466, label %if.end467

if.then466:                                       ; preds = %if.end461
  %237 = load ptr, ptr %s.addr, align 8
  %238 = load i32, ptr %i_allocated_regs, align 4
  call void @sync_globals(ptr noundef %237, i32 noundef %238)
  br label %if.end467

if.end467:                                        ; preds = %if.then466, %if.end461
  store i32 0, ptr %k, align 4
  br label %for.cond468

for.cond468:                                      ; preds = %for.inc632, %if.end467
  %239 = load i32, ptr %k, align 4
  %240 = load i32, ptr %nb_oargs, align 4
  %cmp469 = icmp slt i32 %239, %240
  br i1 %cmp469, label %for.body471, label %for.end634

for.body471:                                      ; preds = %for.cond468
  %241 = load ptr, ptr %def, align 8
  %args_ct472 = getelementptr inbounds %struct.TCGOpDef, ptr %241, i32 0, i32 6
  %242 = load ptr, ptr %args_ct472, align 8
  %243 = load i32, ptr %k, align 4
  %idxprom473 = sext i32 %243 to i64
  %arrayidx474 = getelementptr %struct.TCGArgConstraint, ptr %242, i64 %idxprom473
  %bf.load475 = load i64, ptr %arrayidx474, align 4
  %bf.lshr476 = lshr i64 %bf.load475, 20
  %bf.clear477 = and i64 %bf.lshr476, 15
  %bf.cast478 = trunc i64 %bf.clear477 to i32
  store i32 %bf.cast478, ptr %i, align 4
  %244 = load ptr, ptr %op.addr, align 8
  %args479 = getelementptr inbounds %struct.TCGOp, ptr %244, i32 0, i32 4
  %245 = load i32, ptr %i, align 4
  %idxprom480 = sext i32 %245 to i64
  %arrayidx481 = getelementptr [0 x i64], ptr %args479, i64 0, i64 %idxprom480
  %246 = load i64, ptr %arrayidx481, align 8
  store i64 %246, ptr %arg, align 8
  %247 = load ptr, ptr %def, align 8
  %args_ct482 = getelementptr inbounds %struct.TCGOpDef, ptr %247, i32 0, i32 6
  %248 = load ptr, ptr %args_ct482, align 8
  %249 = load i32, ptr %i, align 4
  %idxprom483 = sext i32 %249 to i64
  %arrayidx484 = getelementptr %struct.TCGArgConstraint, ptr %248, i64 %idxprom483
  store ptr %arrayidx484, ptr %arg_ct, align 8
  %250 = load i64, ptr %arg, align 8
  %call485 = call ptr @arg_temp(i64 noundef %250)
  store ptr %call485, ptr %ts, align 8
  br label %do.body486

do.body486:                                       ; preds = %for.body471
  %251 = load ptr, ptr %ts, align 8
  %call487 = call zeroext i1 @temp_readonly(ptr noundef %251)
  br i1 %call487, label %if.then488, label %if.end489

if.then488:                                       ; preds = %do.body486
  unreachable

if.end489:                                        ; preds = %do.body486
  br label %do.end490

do.end490:                                        ; preds = %if.end489
  %252 = load ptr, ptr %arg_ct, align 8
  %bf.load491 = load i64, ptr %252, align 4
  %bf.lshr492 = lshr i64 %bf.load491, 28
  %bf.clear493 = and i64 %bf.lshr492, 3
  %bf.cast494 = trunc i64 %bf.clear493 to i32
  switch i32 %bf.cast494, label %sw.default621 [
    i32 0, label %sw.bb495
    i32 1, label %sw.bb543
    i32 2, label %sw.bb573
    i32 3, label %sw.bb604
  ]

sw.bb495:                                         ; preds = %do.end490
  %253 = load ptr, ptr %arg_ct, align 8
  %bf.load496 = load i64, ptr %253, align 4
  %bf.lshr497 = lshr i64 %bf.load496, 30
  %bf.clear498 = and i64 %bf.lshr497, 1
  %bf.cast499 = trunc i64 %bf.clear498 to i1
  br i1 %bf.cast499, label %land.lhs.true501, label %if.else517

land.lhs.true501:                                 ; preds = %sw.bb495
  %254 = load ptr, ptr %arg_ct, align 8
  %bf.load502 = load i64, ptr %254, align 4
  %bf.lshr503 = lshr i64 %bf.load502, 16
  %bf.clear504 = and i64 %bf.lshr503, 15
  %bf.cast505 = trunc i64 %bf.clear504 to i32
  %idxprom506 = zext i32 %bf.cast505 to i64
  %arrayidx507 = getelementptr [16 x i32], ptr %const_args, i64 0, i64 %idxprom506
  %255 = load i32, ptr %arrayidx507, align 4
  %tobool508 = icmp ne i32 %255, 0
  br i1 %tobool508, label %if.else517, label %if.then509

if.then509:                                       ; preds = %land.lhs.true501
  %256 = load ptr, ptr %arg_ct, align 8
  %bf.load510 = load i64, ptr %256, align 4
  %bf.lshr511 = lshr i64 %bf.load510, 16
  %bf.clear512 = and i64 %bf.lshr511, 15
  %bf.cast513 = trunc i64 %bf.clear512 to i32
  %idxprom514 = zext i32 %bf.cast513 to i64
  %arrayidx515 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 %idxprom514
  %257 = load i64, ptr %arrayidx515, align 8
  %conv516 = trunc i64 %257 to i32
  store i32 %conv516, ptr %reg, align 4
  br label %if.end542

if.else517:                                       ; preds = %land.lhs.true501, %sw.bb495
  %258 = load ptr, ptr %arg_ct, align 8
  %bf.load518 = load i64, ptr %258, align 4
  %bf.lshr519 = lshr i64 %bf.load518, 32
  %bf.clear520 = and i64 %bf.lshr519, 1
  %bf.cast521 = trunc i64 %bf.clear520 to i1
  br i1 %bf.cast521, label %if.then522, label %if.else532

if.then522:                                       ; preds = %if.else517
  %259 = load ptr, ptr %s.addr, align 8
  %260 = load ptr, ptr %arg_ct, align 8
  %regs523 = getelementptr inbounds %struct.TCGArgConstraint, ptr %260, i32 0, i32 1
  %261 = load i32, ptr %regs523, align 4
  %262 = load i32, ptr %i_allocated_regs, align 4
  %263 = load i32, ptr %o_allocated_regs, align 4
  %or524 = or i32 %262, %263
  %264 = load ptr, ptr %op.addr, align 8
  %265 = load i32, ptr %k, align 4
  %call525 = call i32 @output_pref(ptr noundef %264, i32 noundef %265)
  %266 = load ptr, ptr %ts, align 8
  %bf.load526 = load i64, ptr %266, align 8
  %bf.lshr527 = lshr i64 %bf.load526, 36
  %bf.clear528 = and i64 %bf.lshr527, 1
  %bf.cast529 = trunc i64 %bf.clear528 to i32
  %tobool530 = icmp ne i32 %bf.cast529, 0
  %call531 = call i32 @tcg_reg_alloc(ptr noundef %259, i32 noundef %261, i32 noundef %or524, i32 noundef %call525, i1 noundef zeroext %tobool530)
  store i32 %call531, ptr %reg, align 4
  br label %if.end541

if.else532:                                       ; preds = %if.else517
  %267 = load ptr, ptr %s.addr, align 8
  %268 = load ptr, ptr %arg_ct, align 8
  %regs533 = getelementptr inbounds %struct.TCGArgConstraint, ptr %268, i32 0, i32 1
  %269 = load i32, ptr %regs533, align 4
  %270 = load i32, ptr %o_allocated_regs, align 4
  %271 = load ptr, ptr %op.addr, align 8
  %272 = load i32, ptr %k, align 4
  %call534 = call i32 @output_pref(ptr noundef %271, i32 noundef %272)
  %273 = load ptr, ptr %ts, align 8
  %bf.load535 = load i64, ptr %273, align 8
  %bf.lshr536 = lshr i64 %bf.load535, 36
  %bf.clear537 = and i64 %bf.lshr536, 1
  %bf.cast538 = trunc i64 %bf.clear537 to i32
  %tobool539 = icmp ne i32 %bf.cast538, 0
  %call540 = call i32 @tcg_reg_alloc(ptr noundef %267, i32 noundef %269, i32 noundef %270, i32 noundef %call534, i1 noundef zeroext %tobool539)
  store i32 %call540, ptr %reg, align 4
  br label %if.end541

if.end541:                                        ; preds = %if.else532, %if.then522
  br label %if.end542

if.end542:                                        ; preds = %if.end541, %if.then509
  br label %sw.epilog624

sw.bb543:                                         ; preds = %do.end490
  br label %do.body544

do.body544:                                       ; preds = %sw.bb543
  %274 = load ptr, ptr %arg_ct, align 8
  %bf.load545 = load i64, ptr %274, align 4
  %bf.lshr546 = lshr i64 %bf.load545, 32
  %bf.clear547 = and i64 %bf.lshr546, 1
  %bf.cast548 = trunc i64 %bf.clear547 to i1
  br i1 %bf.cast548, label %if.then549, label %if.end550

if.then549:                                       ; preds = %do.body544
  unreachable

if.end550:                                        ; preds = %do.body544
  br label %do.end551

do.end551:                                        ; preds = %if.end550
  %275 = load ptr, ptr %arg_ct, align 8
  %bf.load552 = load i64, ptr %275, align 4
  %bf.lshr553 = lshr i64 %bf.load552, 30
  %bf.clear554 = and i64 %bf.lshr553, 1
  %bf.cast555 = trunc i64 %bf.clear554 to i1
  br i1 %bf.cast555, label %if.then556, label %if.end564

if.then556:                                       ; preds = %do.end551
  %276 = load ptr, ptr %arg_ct, align 8
  %bf.load557 = load i64, ptr %276, align 4
  %bf.lshr558 = lshr i64 %bf.load557, 16
  %bf.clear559 = and i64 %bf.lshr558, 15
  %bf.cast560 = trunc i64 %bf.clear559 to i32
  %idxprom561 = zext i32 %bf.cast560 to i64
  %arrayidx562 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 %idxprom561
  %277 = load i64, ptr %arrayidx562, align 8
  %conv563 = trunc i64 %277 to i32
  store i32 %conv563, ptr %reg, align 4
  br label %sw.epilog624

if.end564:                                        ; preds = %do.end551
  %278 = load ptr, ptr %s.addr, align 8
  %279 = load ptr, ptr %arg_ct, align 8
  %regs565 = getelementptr inbounds %struct.TCGArgConstraint, ptr %279, i32 0, i32 1
  %280 = load i32, ptr %regs565, align 4
  %281 = load i32, ptr %o_allocated_regs, align 4
  %282 = load ptr, ptr %op.addr, align 8
  %283 = load i32, ptr %k, align 4
  %call566 = call i32 @output_pref(ptr noundef %282, i32 noundef %283)
  %284 = load ptr, ptr %ts, align 8
  %bf.load567 = load i64, ptr %284, align 8
  %bf.lshr568 = lshr i64 %bf.load567, 36
  %bf.clear569 = and i64 %bf.lshr568, 1
  %bf.cast570 = trunc i64 %bf.clear569 to i32
  %tobool571 = icmp ne i32 %bf.cast570, 0
  %call572 = call i32 @tcg_reg_alloc_pair(ptr noundef %278, i32 noundef %280, i32 noundef %281, i32 noundef %call566, i1 noundef zeroext %tobool571)
  store i32 %call572, ptr %reg, align 4
  br label %sw.epilog624

sw.bb573:                                         ; preds = %do.end490
  br label %do.body574

do.body574:                                       ; preds = %sw.bb573
  %285 = load ptr, ptr %arg_ct, align 8
  %bf.load575 = load i64, ptr %285, align 4
  %bf.lshr576 = lshr i64 %bf.load575, 32
  %bf.clear577 = and i64 %bf.lshr576, 1
  %bf.cast578 = trunc i64 %bf.clear577 to i1
  br i1 %bf.cast578, label %if.then579, label %if.end580

if.then579:                                       ; preds = %do.body574
  unreachable

if.end580:                                        ; preds = %do.body574
  br label %do.end581

do.end581:                                        ; preds = %if.end580
  %286 = load ptr, ptr %arg_ct, align 8
  %bf.load582 = load i64, ptr %286, align 4
  %bf.lshr583 = lshr i64 %bf.load582, 30
  %bf.clear584 = and i64 %bf.lshr583, 1
  %bf.cast585 = trunc i64 %bf.clear584 to i1
  br i1 %bf.cast585, label %if.then586, label %if.else594

if.then586:                                       ; preds = %do.end581
  %287 = load ptr, ptr %arg_ct, align 8
  %bf.load587 = load i64, ptr %287, align 4
  %bf.lshr588 = lshr i64 %bf.load587, 16
  %bf.clear589 = and i64 %bf.lshr588, 15
  %bf.cast590 = trunc i64 %bf.clear589 to i32
  %idxprom591 = zext i32 %bf.cast590 to i64
  %arrayidx592 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 %idxprom591
  %288 = load i64, ptr %arrayidx592, align 8
  %conv593 = trunc i64 %288 to i32
  store i32 %conv593, ptr %reg, align 4
  br label %if.end603

if.else594:                                       ; preds = %do.end581
  %289 = load ptr, ptr %arg_ct, align 8
  %bf.load595 = load i64, ptr %289, align 4
  %bf.lshr596 = lshr i64 %bf.load595, 24
  %bf.clear597 = and i64 %bf.lshr596, 15
  %bf.cast598 = trunc i64 %bf.clear597 to i32
  %idxprom599 = zext i32 %bf.cast598 to i64
  %arrayidx600 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 %idxprom599
  %290 = load i64, ptr %arrayidx600, align 8
  %add601 = add i64 %290, 1
  %conv602 = trunc i64 %add601 to i32
  store i32 %conv602, ptr %reg, align 4
  br label %if.end603

if.end603:                                        ; preds = %if.else594, %if.then586
  br label %sw.epilog624

sw.bb604:                                         ; preds = %do.end490
  br label %do.body605

do.body605:                                       ; preds = %sw.bb604
  %291 = load ptr, ptr %arg_ct, align 8
  %bf.load606 = load i64, ptr %291, align 4
  %bf.lshr607 = lshr i64 %bf.load606, 32
  %bf.clear608 = and i64 %bf.lshr607, 1
  %bf.cast609 = trunc i64 %bf.clear608 to i1
  br i1 %bf.cast609, label %if.then610, label %if.end611

if.then610:                                       ; preds = %do.body605
  unreachable

if.end611:                                        ; preds = %do.body605
  br label %do.end612

do.end612:                                        ; preds = %if.end611
  %292 = load ptr, ptr %arg_ct, align 8
  %bf.load613 = load i64, ptr %292, align 4
  %bf.lshr614 = lshr i64 %bf.load613, 24
  %bf.clear615 = and i64 %bf.lshr614, 15
  %bf.cast616 = trunc i64 %bf.clear615 to i32
  %idxprom617 = zext i32 %bf.cast616 to i64
  %arrayidx618 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 %idxprom617
  %293 = load i64, ptr %arrayidx618, align 8
  %sub619 = sub i64 %293, 1
  %conv620 = trunc i64 %sub619 to i32
  store i32 %conv620, ptr %reg, align 4
  br label %sw.epilog624

sw.default621:                                    ; preds = %do.end490
  br label %do.body622

do.body622:                                       ; preds = %sw.default621
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5063, ptr noundef @__func__.tcg_reg_alloc_op, ptr noundef null) #15
  unreachable

do.end623:                                        ; No predecessors!
  br label %sw.epilog624

sw.epilog624:                                     ; preds = %do.end623, %do.end612, %if.end603, %if.end564, %if.then556, %if.end542
  %294 = load i32, ptr %reg, align 4
  %shl625 = shl i32 1, %294
  %295 = load i32, ptr %o_allocated_regs, align 4
  %or626 = or i32 %295, %shl625
  store i32 %or626, ptr %o_allocated_regs, align 4
  %296 = load ptr, ptr %s.addr, align 8
  %297 = load ptr, ptr %ts, align 8
  %298 = load i32, ptr %reg, align 4
  call void @set_temp_val_reg(ptr noundef %296, ptr noundef %297, i32 noundef %298)
  %299 = load ptr, ptr %ts, align 8
  %bf.load627 = load i64, ptr %299, align 8
  %bf.clear628 = and i64 %bf.load627, -137438953473
  %bf.set = or i64 %bf.clear628, 0
  store i64 %bf.set, ptr %299, align 8
  %300 = load i32, ptr %reg, align 4
  %conv629 = zext i32 %300 to i64
  %301 = load i32, ptr %i, align 4
  %idxprom630 = sext i32 %301 to i64
  %arrayidx631 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 %idxprom630
  store i64 %conv629, ptr %arrayidx631, align 8
  br label %for.inc632

for.inc632:                                       ; preds = %sw.epilog624
  %302 = load i32, ptr %k, align 4
  %inc633 = add i32 %302, 1
  store i32 %inc633, ptr %k, align 4
  br label %for.cond468, !llvm.loop !74

for.end634:                                       ; preds = %for.cond468
  br label %if.end635

if.end635:                                        ; preds = %for.end634, %if.then442
  br label %if.end636

if.end636:                                        ; preds = %if.end635, %if.then436
  %303 = load ptr, ptr %op.addr, align 8
  %bf.load637 = load i32, ptr %303, align 8
  %bf.clear638 = and i32 %bf.load637, 255
  switch i32 %bf.clear638, label %sw.default694 [
    i32 47, label %sw.bb639
    i32 104, label %sw.bb644
    i32 49, label %sw.bb649
    i32 107, label %sw.bb649
    i32 48, label %sw.bb654
    i32 105, label %sw.bb659
    i32 50, label %sw.bb664
    i32 108, label %sw.bb664
    i32 106, label %sw.bb669
    i32 109, label %sw.bb674
    i32 99, label %sw.bb679
    i32 100, label %sw.bb684
    i32 101, label %sw.bb689
  ]

sw.bb639:                                         ; preds = %if.end636
  %304 = load ptr, ptr %s.addr, align 8
  %arrayidx640 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %305 = load i64, ptr %arrayidx640, align 16
  %conv641 = trunc i64 %305 to i32
  %arrayidx642 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %306 = load i64, ptr %arrayidx642, align 8
  %conv643 = trunc i64 %306 to i32
  call void @tcg_out_ext8s(ptr noundef %304, i32 noundef 0, i32 noundef %conv641, i32 noundef %conv643)
  br label %sw.epilog715

sw.bb644:                                         ; preds = %if.end636
  %307 = load ptr, ptr %s.addr, align 8
  %arrayidx645 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %308 = load i64, ptr %arrayidx645, align 16
  %conv646 = trunc i64 %308 to i32
  %arrayidx647 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %309 = load i64, ptr %arrayidx647, align 8
  %conv648 = trunc i64 %309 to i32
  call void @tcg_out_ext8s(ptr noundef %307, i32 noundef 1, i32 noundef %conv646, i32 noundef %conv648)
  br label %sw.epilog715

sw.bb649:                                         ; preds = %if.end636, %if.end636
  %310 = load ptr, ptr %s.addr, align 8
  %arrayidx650 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %311 = load i64, ptr %arrayidx650, align 16
  %conv651 = trunc i64 %311 to i32
  %arrayidx652 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %312 = load i64, ptr %arrayidx652, align 8
  %conv653 = trunc i64 %312 to i32
  call void @tcg_out_ext8u(ptr noundef %310, i32 noundef %conv651, i32 noundef %conv653)
  br label %sw.epilog715

sw.bb654:                                         ; preds = %if.end636
  %313 = load ptr, ptr %s.addr, align 8
  %arrayidx655 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %314 = load i64, ptr %arrayidx655, align 16
  %conv656 = trunc i64 %314 to i32
  %arrayidx657 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %315 = load i64, ptr %arrayidx657, align 8
  %conv658 = trunc i64 %315 to i32
  call void @tcg_out_ext16s(ptr noundef %313, i32 noundef 0, i32 noundef %conv656, i32 noundef %conv658)
  br label %sw.epilog715

sw.bb659:                                         ; preds = %if.end636
  %316 = load ptr, ptr %s.addr, align 8
  %arrayidx660 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %317 = load i64, ptr %arrayidx660, align 16
  %conv661 = trunc i64 %317 to i32
  %arrayidx662 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %318 = load i64, ptr %arrayidx662, align 8
  %conv663 = trunc i64 %318 to i32
  call void @tcg_out_ext16s(ptr noundef %316, i32 noundef 1, i32 noundef %conv661, i32 noundef %conv663)
  br label %sw.epilog715

sw.bb664:                                         ; preds = %if.end636, %if.end636
  %319 = load ptr, ptr %s.addr, align 8
  %arrayidx665 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %320 = load i64, ptr %arrayidx665, align 16
  %conv666 = trunc i64 %320 to i32
  %arrayidx667 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %321 = load i64, ptr %arrayidx667, align 8
  %conv668 = trunc i64 %321 to i32
  call void @tcg_out_ext16u(ptr noundef %319, i32 noundef %conv666, i32 noundef %conv668)
  br label %sw.epilog715

sw.bb669:                                         ; preds = %if.end636
  %322 = load ptr, ptr %s.addr, align 8
  %arrayidx670 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %323 = load i64, ptr %arrayidx670, align 16
  %conv671 = trunc i64 %323 to i32
  %arrayidx672 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %324 = load i64, ptr %arrayidx672, align 8
  %conv673 = trunc i64 %324 to i32
  call void @tcg_out_ext32s(ptr noundef %322, i32 noundef %conv671, i32 noundef %conv673)
  br label %sw.epilog715

sw.bb674:                                         ; preds = %if.end636
  %325 = load ptr, ptr %s.addr, align 8
  %arrayidx675 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %326 = load i64, ptr %arrayidx675, align 16
  %conv676 = trunc i64 %326 to i32
  %arrayidx677 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %327 = load i64, ptr %arrayidx677, align 8
  %conv678 = trunc i64 %327 to i32
  call void @tcg_out_ext32u(ptr noundef %325, i32 noundef %conv676, i32 noundef %conv678)
  br label %sw.epilog715

sw.bb679:                                         ; preds = %if.end636
  %328 = load ptr, ptr %s.addr, align 8
  %arrayidx680 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %329 = load i64, ptr %arrayidx680, align 16
  %conv681 = trunc i64 %329 to i32
  %arrayidx682 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %330 = load i64, ptr %arrayidx682, align 8
  %conv683 = trunc i64 %330 to i32
  call void @tcg_out_exts_i32_i64(ptr noundef %328, i32 noundef %conv681, i32 noundef %conv683)
  br label %sw.epilog715

sw.bb684:                                         ; preds = %if.end636
  %331 = load ptr, ptr %s.addr, align 8
  %arrayidx685 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %332 = load i64, ptr %arrayidx685, align 16
  %conv686 = trunc i64 %332 to i32
  %arrayidx687 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %333 = load i64, ptr %arrayidx687, align 8
  %conv688 = trunc i64 %333 to i32
  call void @tcg_out_extu_i32_i64(ptr noundef %331, i32 noundef %conv686, i32 noundef %conv688)
  br label %sw.epilog715

sw.bb689:                                         ; preds = %if.end636
  %334 = load ptr, ptr %s.addr, align 8
  %arrayidx690 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 0
  %335 = load i64, ptr %arrayidx690, align 16
  %conv691 = trunc i64 %335 to i32
  %arrayidx692 = getelementptr [16 x i64], ptr %new_args, i64 0, i64 1
  %336 = load i64, ptr %arrayidx692, align 8
  %conv693 = trunc i64 %336 to i32
  call void @tcg_out_extrl_i64_i32(ptr noundef %334, i32 noundef %conv691, i32 noundef %conv693)
  br label %sw.epilog715

sw.default694:                                    ; preds = %if.end636
  %337 = load ptr, ptr %def, align 8
  %flags695 = getelementptr inbounds %struct.TCGOpDef, ptr %337, i32 0, i32 5
  %338 = load i8, ptr %flags695, align 4
  %conv696 = zext i8 %338 to i32
  %and697 = and i32 %conv696, 64
  %tobool698 = icmp ne i32 %and697, 0
  br i1 %tobool698, label %if.then699, label %if.else709

if.then699:                                       ; preds = %sw.default694
  %339 = load ptr, ptr %s.addr, align 8
  %340 = load ptr, ptr %op.addr, align 8
  %bf.load700 = load i32, ptr %340, align 8
  %bf.clear701 = and i32 %bf.load700, 255
  %341 = load ptr, ptr %op.addr, align 8
  %bf.load702 = load i32, ptr %341, align 8
  %bf.lshr703 = lshr i32 %bf.load702, 16
  %bf.clear704 = and i32 %bf.lshr703, 255
  %342 = load ptr, ptr %op.addr, align 8
  %bf.load705 = load i32, ptr %342, align 8
  %bf.lshr706 = lshr i32 %bf.load705, 24
  %arraydecay707 = getelementptr inbounds [16 x i64], ptr %new_args, i64 0, i64 0
  %arraydecay708 = getelementptr inbounds [16 x i32], ptr %const_args, i64 0, i64 0
  call void @tcg_out_vec_op(ptr noundef %339, i32 noundef %bf.clear701, i32 noundef %bf.clear704, i32 noundef %bf.lshr706, ptr noundef %arraydecay707, ptr noundef %arraydecay708)
  br label %if.end714

if.else709:                                       ; preds = %sw.default694
  %343 = load ptr, ptr %s.addr, align 8
  %344 = load ptr, ptr %op.addr, align 8
  %bf.load710 = load i32, ptr %344, align 8
  %bf.clear711 = and i32 %bf.load710, 255
  %arraydecay712 = getelementptr inbounds [16 x i64], ptr %new_args, i64 0, i64 0
  %arraydecay713 = getelementptr inbounds [16 x i32], ptr %const_args, i64 0, i64 0
  call void @tcg_out_op(ptr noundef %343, i32 noundef %bf.clear711, ptr noundef %arraydecay712, ptr noundef %arraydecay713)
  br label %if.end714

if.end714:                                        ; preds = %if.else709, %if.then699
  br label %sw.epilog715

sw.epilog715:                                     ; preds = %if.end714, %sw.bb689, %sw.bb684, %sw.bb679, %sw.bb674, %sw.bb669, %sw.bb664, %sw.bb659, %sw.bb654, %sw.bb649, %sw.bb644, %sw.bb639
  store i32 0, ptr %i, align 4
  br label %for.cond716

for.cond716:                                      ; preds = %for.inc742, %sw.epilog715
  %345 = load i32, ptr %i, align 4
  %346 = load i32, ptr %nb_oargs, align 4
  %cmp717 = icmp slt i32 %345, %346
  br i1 %cmp717, label %for.body719, label %for.end744

for.body719:                                      ; preds = %for.cond716
  %347 = load ptr, ptr %op.addr, align 8
  %args720 = getelementptr inbounds %struct.TCGOp, ptr %347, i32 0, i32 4
  %348 = load i32, ptr %i, align 4
  %idxprom721 = sext i32 %348 to i64
  %arrayidx722 = getelementptr [0 x i64], ptr %args720, i64 0, i64 %idxprom721
  %349 = load i64, ptr %arrayidx722, align 8
  %call723 = call ptr @arg_temp(i64 noundef %349)
  store ptr %call723, ptr %ts, align 8
  br label %do.body724

do.body724:                                       ; preds = %for.body719
  %350 = load ptr, ptr %ts, align 8
  %call725 = call zeroext i1 @temp_readonly(ptr noundef %350)
  br i1 %call725, label %if.then726, label %if.end727

if.then726:                                       ; preds = %do.body724
  unreachable

if.end727:                                        ; preds = %do.body724
  br label %do.end728

do.end728:                                        ; preds = %if.end727
  %351 = load i32, ptr %arg_life, align 4
  %352 = load i32, ptr %i, align 4
  %shl729 = shl i32 1, %352
  %and730 = and i32 %351, %shl729
  %tobool731 = icmp ne i32 %and730, 0
  br i1 %tobool731, label %if.then732, label %if.else735

if.then732:                                       ; preds = %do.end728
  %353 = load ptr, ptr %s.addr, align 8
  %354 = load ptr, ptr %ts, align 8
  %355 = load i32, ptr %o_allocated_regs, align 4
  %356 = load i32, ptr %arg_life, align 4
  %357 = load i32, ptr %i, align 4
  %shl733 = shl i32 16, %357
  %and734 = and i32 %356, %shl733
  call void @temp_sync(ptr noundef %353, ptr noundef %354, i32 noundef %355, i32 noundef 0, i32 noundef %and734)
  br label %if.end741

if.else735:                                       ; preds = %do.end728
  %358 = load i32, ptr %arg_life, align 4
  %359 = load i32, ptr %i, align 4
  %shl736 = shl i32 16, %359
  %and737 = and i32 %358, %shl736
  %tobool738 = icmp ne i32 %and737, 0
  br i1 %tobool738, label %if.then739, label %if.end740

if.then739:                                       ; preds = %if.else735
  %360 = load ptr, ptr %s.addr, align 8
  %361 = load ptr, ptr %ts, align 8
  call void @temp_dead(ptr noundef %360, ptr noundef %361)
  br label %if.end740

if.end740:                                        ; preds = %if.then739, %if.else735
  br label %if.end741

if.end741:                                        ; preds = %if.end740, %if.then732
  br label %for.inc742

for.inc742:                                       ; preds = %if.end741
  %362 = load i32, ptr %i, align 4
  %inc743 = add i32 %362, 1
  store i32 %inc743, ptr %i, align 4
  br label %for.cond716, !llvm.loop !75

for.end744:                                       ; preds = %for.cond716
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_out_ldst_finalize(ptr noundef %s) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %lb = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %ldst_labels = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 30
  %sqh_first = getelementptr inbounds %struct.anon.2, ptr %ldst_labels, i32 0, i32 0
  %1 = load ptr, ptr %sqh_first, align 8
  store ptr %1, ptr %lb, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load ptr, ptr %lb, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %lb, align 8
  %is_ld = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %3, i32 0, i32 0
  %4 = load i8, ptr %is_ld, align 8
  %tobool1 = trunc i8 %4 to i1
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %lb, align 8
  %call = call zeroext i1 @tcg_out_qemu_ld_slow_path(ptr noundef %5, ptr noundef %6)
  br i1 %call, label %if.end, label %if.then

cond.false:                                       ; preds = %for.body
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load ptr, ptr %lb, align 8
  %call2 = call zeroext i1 @tcg_out_qemu_st_slow_path(ptr noundef %7, ptr noundef %8)
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %cond.false, %cond.true
  store i32 -2, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %cond.false, %cond.true
  %9 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 23
  %10 = load ptr, ptr %code_ptr, align 8
  %11 = load ptr, ptr %s.addr, align 8
  %code_gen_highwater = getelementptr inbounds %struct.TCGContext, ptr %11, i32 0, i32 28
  %12 = load ptr, ptr %code_gen_highwater, align 8
  %cmp = icmp ugt ptr %10, %12
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool4 = icmp ne i64 %conv, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %13 = load ptr, ptr %lb, align 8
  %next = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %13, i32 0, i32 9
  %sqe_next = getelementptr inbounds %struct.anon.8, ptr %next, i32 0, i32 0
  %14 = load ptr, ptr %sqe_next, align 8
  store ptr %14, ptr %lb, align 8
  br label %for.cond, !llvm.loop !76

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_resolve_relocs(ptr noundef %s) #0 {
entry:
  %retval = alloca i1, align 1
  %s.addr = alloca ptr, align 8
  %l = alloca ptr, align 8
  %r = alloca ptr, align 8
  %value = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %labels = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 40
  %sqh_first = getelementptr inbounds %struct.anon.4, ptr %labels, i32 0, i32 0
  %1 = load ptr, ptr %sqh_first, align 8
  store ptr %1, ptr %l, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc5, %entry
  %2 = load ptr, ptr %l, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %l, align 8
  %u = getelementptr inbounds %struct.TCGLabel, ptr %3, i32 0, i32 3
  %4 = load i64, ptr %u, align 8
  store i64 %4, ptr %value, align 8
  %5 = load ptr, ptr %l, align 8
  %relocs = getelementptr inbounds %struct.TCGLabel, ptr %5, i32 0, i32 5
  %sqh_first1 = getelementptr inbounds %struct.anon.0, ptr %relocs, i32 0, i32 0
  %6 = load ptr, ptr %sqh_first1, align 8
  store ptr %6, ptr %r, align 8
  br label %for.cond2

for.cond2:                                        ; preds = %for.inc, %for.body
  %7 = load ptr, ptr %r, align 8
  %tobool3 = icmp ne ptr %7, null
  br i1 %tobool3, label %for.body4, label %for.end

for.body4:                                        ; preds = %for.cond2
  %8 = load ptr, ptr %r, align 8
  %ptr = getelementptr inbounds %struct.TCGRelocation, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %ptr, align 8
  %10 = load ptr, ptr %r, align 8
  %type = getelementptr inbounds %struct.TCGRelocation, ptr %10, i32 0, i32 3
  %11 = load i32, ptr %type, align 8
  %12 = load i64, ptr %value, align 8
  %13 = load ptr, ptr %r, align 8
  %addend = getelementptr inbounds %struct.TCGRelocation, ptr %13, i32 0, i32 2
  %14 = load i64, ptr %addend, align 8
  %call = call zeroext i1 @patch_reloc(ptr noundef %9, i32 noundef %11, i64 noundef %12, i64 noundef %14)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %for.body4
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %15 = load ptr, ptr %r, align 8
  %next = getelementptr inbounds %struct.TCGRelocation, ptr %15, i32 0, i32 0
  %sqe_next = getelementptr inbounds %struct.anon.7, ptr %next, i32 0, i32 0
  %16 = load ptr, ptr %sqe_next, align 8
  store ptr %16, ptr %r, align 8
  br label %for.cond2, !llvm.loop !77

for.end:                                          ; preds = %for.cond2
  br label %for.inc5

for.inc5:                                         ; preds = %for.end
  %17 = load ptr, ptr %l, align 8
  %next6 = getelementptr inbounds %struct.TCGLabel, ptr %17, i32 0, i32 6
  %sqe_next7 = getelementptr inbounds %struct.anon.1, ptr %next6, i32 0, i32 0
  %18 = load ptr, ptr %sqe_next7, align 8
  store ptr %18, ptr %l, align 8
  br label %for.cond, !llvm.loop !78

for.end8:                                         ; preds = %for.cond
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end8, %if.then
  %19 = load i1, ptr %retval, align 1
  ret i1 %19
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @tcg_ptr_byte_diff(ptr noundef %a, ptr noundef %b) #0 {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %b.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %0 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %1 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  ret i64 %sub.ptr.sub
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @__jit_debug_register_code() #0 {
entry:
  call void asm sideeffect "", "~{dirflag},~{fpsr},~{flags}"() #20, !srcloc !79
  ret void
}

declare void @vec_gen_3(i32 noundef, i32 noundef, i32 noundef, i64 noundef, i64 noundef, i64 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @tcgv_vec_arg(ptr noundef %v) #0 {
entry:
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %call = call ptr @tcgv_vec_temp(ptr noundef %0)
  %call1 = call i64 @temp_arg(ptr noundef %call)
  ret i64 %call1
}

declare void @tcg_gen_shri_vec(i32 noundef, ptr noundef, ptr noundef, i64 noundef) #7

declare void @tcg_gen_shli_vec(i32 noundef, ptr noundef, ptr noundef, i64 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @temp_arg(ptr noundef %ts) #0 {
entry:
  %ts.addr = alloca ptr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  %0 = load ptr, ptr %ts.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  ret i64 %1
}

declare void @tcg_gen_sari_vec(i32 noundef, ptr noundef, ptr noundef, i64 noundef) #7

declare void @vec_gen_4(i32 noundef, i32 noundef, i32 noundef, i64 noundef, i64 noundef, i64 noundef, i64 noundef) #7

declare void @tcg_gen_cmp_vec(i32 noundef, i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

declare void @tcg_gen_or_vec(i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

declare void @tcg_gen_dup_i32_vec(i32 noundef, ptr noundef, ptr noundef) #7

declare void @tcg_gen_rotlv_vec(i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

declare void @tcg_gen_neg_i32(ptr noundef, ptr noundef) #7

declare void @tcg_gen_andi_i32(ptr noundef, ptr noundef, i32 noundef) #7

declare void @tcg_gen_shls_vec(i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

declare void @tcg_gen_shrs_vec(i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

declare void @tcg_gen_dupi_vec(i32 noundef, ptr noundef, i64 noundef) #7

declare void @tcg_gen_sub_vec(i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

declare void @tcg_gen_shlv_vec(i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

declare void @tcg_gen_shrv_vec(i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

declare void @tcg_gen_mul_vec(i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @expand_vec_cmp_noinv(i32 noundef %type, i32 noundef %vece, ptr noundef %v0, ptr noundef %v1, ptr noundef %v2, i32 noundef %cond) #0 {
entry:
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %v0.addr = alloca ptr, align 8
  %v1.addr = alloca ptr, align 8
  %v2.addr = alloca ptr, align 8
  %cond.addr = alloca i32, align 4
  %t1 = alloca ptr, align 8
  %t2 = alloca ptr, align 8
  %t3 = alloca ptr, align 8
  %fixup = alloca i8, align 1
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store ptr %v0, ptr %v0.addr, align 8
  store ptr %v1, ptr %v1.addr, align 8
  store ptr %v2, ptr %v2.addr, align 8
  store i32 %cond, ptr %cond.addr, align 4
  %0 = load i32, ptr %cond.addr, align 4
  switch i32 %0, label %sw.default [
    i32 8, label %sw.bb
    i32 11, label %sw.bb
    i32 9, label %sw.bb1
    i32 10, label %sw.bb1
    i32 2, label %sw.bb2
    i32 3, label %sw.bb3
    i32 12, label %sw.bb4
    i32 13, label %sw.bb5
    i32 5, label %sw.bb11
    i32 4, label %sw.bb17
  ]

sw.bb:                                            ; preds = %entry, %entry
  store i8 0, ptr %fixup, align 1
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry, %entry
  store i8 1, ptr %fixup, align 1
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  store i8 2, ptr %fixup, align 1
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  store i8 3, ptr %fixup, align 1
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %1 = load i32, ptr %type.addr, align 4
  %2 = load i32, ptr %vece.addr, align 4
  %call = call i32 @tcg_can_emit_vec_op(i32 noundef 165, i32 noundef %1, i32 noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb4
  store i8 8, ptr %fixup, align 1
  br label %if.end

if.else:                                          ; preds = %sw.bb4
  store i8 5, ptr %fixup, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %3 = load i32, ptr %type.addr, align 4
  %4 = load i32, ptr %vece.addr, align 4
  %call6 = call i32 @tcg_can_emit_vec_op(i32 noundef 165, i32 noundef %3, i32 noundef %4)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %sw.bb5
  store i8 9, ptr %fixup, align 1
  br label %if.end10

if.else9:                                         ; preds = %sw.bb5
  store i8 4, ptr %fixup, align 1
  br label %if.end10

if.end10:                                         ; preds = %if.else9, %if.then8
  br label %sw.epilog

sw.bb11:                                          ; preds = %entry
  %5 = load i32, ptr %type.addr, align 4
  %6 = load i32, ptr %vece.addr, align 4
  %call12 = call i32 @tcg_can_emit_vec_op(i32 noundef 167, i32 noundef %5, i32 noundef %6)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %sw.bb11
  store i8 16, ptr %fixup, align 1
  br label %if.end16

if.else15:                                        ; preds = %sw.bb11
  store i8 7, ptr %fixup, align 1
  br label %if.end16

if.end16:                                         ; preds = %if.else15, %if.then14
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  %7 = load i32, ptr %type.addr, align 4
  %8 = load i32, ptr %vece.addr, align 4
  %call18 = call i32 @tcg_can_emit_vec_op(i32 noundef 167, i32 noundef %7, i32 noundef %8)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %if.else21

if.then20:                                        ; preds = %sw.bb17
  store i8 17, ptr %fixup, align 1
  br label %if.end22

if.else21:                                        ; preds = %sw.bb17
  store i8 6, ptr %fixup, align 1
  br label %if.end22

if.end22:                                         ; preds = %if.else21, %if.then20
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 3956, ptr noundef @__func__.expand_vec_cmp_noinv, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %if.end22, %if.end16, %if.end10, %if.end, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %9 = load i8, ptr %fixup, align 1
  %conv = zext i8 %9 to i32
  %and = and i32 %conv, 1
  %tobool23 = icmp ne i32 %and, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %sw.epilog
  %10 = load i32, ptr %cond.addr, align 4
  %call25 = call i32 @tcg_invert_cond(i32 noundef %10)
  store i32 %call25, ptr %cond.addr, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %sw.epilog
  %11 = load i8, ptr %fixup, align 1
  %conv27 = zext i8 %11 to i32
  %and28 = and i32 %conv27, 2
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then30, label %if.end32

if.then30:                                        ; preds = %if.end26
  %12 = load ptr, ptr %v1.addr, align 8
  store ptr %12, ptr %t1, align 8
  %13 = load ptr, ptr %v2.addr, align 8
  store ptr %13, ptr %v1.addr, align 8
  %14 = load ptr, ptr %t1, align 8
  store ptr %14, ptr %v2.addr, align 8
  %15 = load i32, ptr %cond.addr, align 4
  %call31 = call i32 @tcg_swap_cond(i32 noundef %15)
  store i32 %call31, ptr %cond.addr, align 4
  br label %if.end32

if.end32:                                         ; preds = %if.then30, %if.end26
  store ptr null, ptr %t2, align 8
  store ptr null, ptr %t1, align 8
  %16 = load i8, ptr %fixup, align 1
  %conv33 = zext i8 %16 to i32
  %and34 = and i32 %conv33, 24
  %tobool35 = icmp ne i32 %and34, 0
  br i1 %tobool35, label %if.then36, label %if.else44

if.then36:                                        ; preds = %if.end32
  %17 = load i32, ptr %type.addr, align 4
  %call37 = call ptr @tcg_temp_new_vec(i32 noundef %17)
  store ptr %call37, ptr %t1, align 8
  %18 = load i8, ptr %fixup, align 1
  %conv38 = zext i8 %18 to i32
  %and39 = and i32 %conv38, 8
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then41, label %if.else42

if.then41:                                        ; preds = %if.then36
  %19 = load i32, ptr %vece.addr, align 4
  %20 = load ptr, ptr %t1, align 8
  %21 = load ptr, ptr %v1.addr, align 8
  %22 = load ptr, ptr %v2.addr, align 8
  call void @tcg_gen_umin_vec(i32 noundef %19, ptr noundef %20, ptr noundef %21, ptr noundef %22)
  br label %if.end43

if.else42:                                        ; preds = %if.then36
  %23 = load i32, ptr %vece.addr, align 4
  %24 = load ptr, ptr %t1, align 8
  %25 = load ptr, ptr %v1.addr, align 8
  %26 = load ptr, ptr %v2.addr, align 8
  call void @tcg_gen_umax_vec(i32 noundef %23, ptr noundef %24, ptr noundef %25, ptr noundef %26)
  br label %if.end43

if.end43:                                         ; preds = %if.else42, %if.then41
  %27 = load ptr, ptr %t1, align 8
  store ptr %27, ptr %v2.addr, align 8
  store i32 8, ptr %cond.addr, align 4
  br label %if.end55

if.else44:                                        ; preds = %if.end32
  %28 = load i8, ptr %fixup, align 1
  %conv45 = zext i8 %28 to i32
  %and46 = and i32 %conv45, 4
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then48, label %if.end54

if.then48:                                        ; preds = %if.else44
  %29 = load i32, ptr %type.addr, align 4
  %call49 = call ptr @tcg_temp_new_vec(i32 noundef %29)
  store ptr %call49, ptr %t1, align 8
  %30 = load i32, ptr %type.addr, align 4
  %call50 = call ptr @tcg_temp_new_vec(i32 noundef %30)
  store ptr %call50, ptr %t2, align 8
  %31 = load i32, ptr %type.addr, align 4
  %32 = load i32, ptr %vece.addr, align 4
  %33 = load i32, ptr %vece.addr, align 4
  %shl = shl i32 8, %33
  %sub = sub i32 %shl, 1
  %sh_prom = zext i32 %sub to i64
  %shl51 = shl i64 1, %sh_prom
  %call52 = call ptr @tcg_constant_vec(i32 noundef %31, i32 noundef %32, i64 noundef %shl51)
  store ptr %call52, ptr %t3, align 8
  %34 = load i32, ptr %vece.addr, align 4
  %35 = load ptr, ptr %t1, align 8
  %36 = load ptr, ptr %v1.addr, align 8
  %37 = load ptr, ptr %t3, align 8
  call void @tcg_gen_sub_vec(i32 noundef %34, ptr noundef %35, ptr noundef %36, ptr noundef %37)
  %38 = load i32, ptr %vece.addr, align 4
  %39 = load ptr, ptr %t2, align 8
  %40 = load ptr, ptr %v2.addr, align 8
  %41 = load ptr, ptr %t3, align 8
  call void @tcg_gen_sub_vec(i32 noundef %38, ptr noundef %39, ptr noundef %40, ptr noundef %41)
  %42 = load ptr, ptr %t1, align 8
  store ptr %42, ptr %v1.addr, align 8
  %43 = load ptr, ptr %t2, align 8
  store ptr %43, ptr %v2.addr, align 8
  %44 = load i32, ptr %cond.addr, align 4
  %call53 = call i32 @tcg_signed_cond(i32 noundef %44)
  store i32 %call53, ptr %cond.addr, align 4
  br label %if.end54

if.end54:                                         ; preds = %if.then48, %if.else44
  br label %if.end55

if.end55:                                         ; preds = %if.end54, %if.end43
  br label %do.body56

do.body56:                                        ; preds = %if.end55
  %45 = load i32, ptr %cond.addr, align 4
  %cmp = icmp eq i32 %45, 8
  br i1 %cmp, label %if.end61, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body56
  %46 = load i32, ptr %cond.addr, align 4
  %cmp58 = icmp eq i32 %46, 11
  br i1 %cmp58, label %if.end61, label %if.then60

if.then60:                                        ; preds = %lor.lhs.false
  unreachable

if.end61:                                         ; preds = %lor.lhs.false, %do.body56
  br label %do.end62

do.end62:                                         ; preds = %if.end61
  %47 = load i32, ptr %type.addr, align 4
  %48 = load i32, ptr %vece.addr, align 4
  %49 = load ptr, ptr %v0.addr, align 8
  %call63 = call i64 @tcgv_vec_arg(ptr noundef %49)
  %50 = load ptr, ptr %v1.addr, align 8
  %call64 = call i64 @tcgv_vec_arg(ptr noundef %50)
  %51 = load ptr, ptr %v2.addr, align 8
  %call65 = call i64 @tcgv_vec_arg(ptr noundef %51)
  %52 = load i32, ptr %cond.addr, align 4
  %conv66 = zext i32 %52 to i64
  call void @vec_gen_4(i32 noundef 190, i32 noundef %47, i32 noundef %48, i64 noundef %call63, i64 noundef %call64, i64 noundef %call65, i64 noundef %conv66)
  %53 = load ptr, ptr %t1, align 8
  %tobool67 = icmp ne ptr %53, null
  br i1 %tobool67, label %if.then68, label %if.end72

if.then68:                                        ; preds = %do.end62
  %54 = load ptr, ptr %t1, align 8
  call void @tcg_temp_free_vec(ptr noundef %54)
  %55 = load ptr, ptr %t2, align 8
  %tobool69 = icmp ne ptr %55, null
  br i1 %tobool69, label %if.then70, label %if.end71

if.then70:                                        ; preds = %if.then68
  %56 = load ptr, ptr %t2, align 8
  call void @tcg_temp_free_vec(ptr noundef %56)
  br label %if.end71

if.end71:                                         ; preds = %if.then70, %if.then68
  br label %if.end72

if.end72:                                         ; preds = %if.end71, %do.end62
  %57 = load i8, ptr %fixup, align 1
  %conv73 = zext i8 %57 to i32
  %and74 = and i32 %conv73, 1
  %tobool75 = icmp ne i32 %and74, 0
  ret i1 %tobool75
}

declare void @tcg_gen_not_vec(i32 noundef, ptr noundef, ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_invert_cond(i32 noundef %c) #0 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, ptr %c.addr, align 4
  %0 = load i32, ptr %c.addr, align 4
  %xor = xor i32 %0, 1
  ret i32 %xor
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_swap_cond(i32 noundef %c) #0 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, ptr %c.addr, align 4
  %0 = load i32, ptr %c.addr, align 4
  %and = and i32 %0, 6
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32, ptr %c.addr, align 4
  %xor = xor i32 %1, 9
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i32, ptr %c.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %xor, %cond.true ], [ %2, %cond.false ]
  ret i32 %cond
}

declare void @tcg_gen_umin_vec(i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

declare void @tcg_gen_umax_vec(i32 noundef, ptr noundef, ptr noundef, ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_signed_cond(i32 noundef %c) #0 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, ptr %c.addr, align 4
  %0 = load i32, ptr %c.addr, align 4
  %and = and i32 %0, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32, ptr %c.addr, align 4
  %xor = xor i32 %1, 6
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i32, ptr %c.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %xor, %cond.true ], [ %2, %cond.false ]
  ret i32 %cond
}

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_malloc0_n(i64 noundef, i64 noundef) #11

; Function Attrs: nounwind sspstrong uwtable
define internal void @init_call_layout(ptr noundef %info) #0 {
entry:
  %info.addr = alloca ptr, align 8
  %max_reg_slots = alloca i32, align 4
  %max_stk_slots = alloca i32, align 4
  %typemask = alloca i32, align 4
  %typecode = alloca i32, align 4
  %cum = alloca %struct.TCGCumulativeArgs, align 4
  %type = alloca i32, align 4
  %ref_base = alloca i32, align 4
  %align = alloca i32, align 4
  %i = alloca i32, align 4
  %loc = alloca ptr, align 8
  store ptr %info, ptr %info.addr, align 8
  store i32 6, ptr %max_reg_slots, align 4
  store i32 16, ptr %max_stk_slots, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %typemask1 = getelementptr inbounds %struct.TCGHelperInfo, ptr %0, i32 0, i32 3
  %bf.load = load i64, ptr %typemask1, align 8
  %bf.clear = and i64 %bf.load, 4294967295
  %bf.cast = trunc i64 %bf.clear to i32
  store i32 %bf.cast, ptr %typemask, align 4
  call void @llvm.memset.p0.i64(ptr align 4 %cum, i8 0, i64 16, i1 false)
  %1 = load i32, ptr %typemask, align 4
  %and = and i32 %1, 7
  store i32 %and, ptr %typecode, align 4
  %2 = load i32, ptr %typecode, align 4
  switch i32 %2, label %sw.default [
    i32 0, label %sw.bb
    i32 2, label %sw.bb4
    i32 3, label %sw.bb4
    i32 6, label %sw.bb4
    i32 4, label %sw.bb12
    i32 5, label %sw.bb12
    i32 7, label %sw.bb29
  ]

sw.bb:                                            ; preds = %entry
  %3 = load ptr, ptr %info.addr, align 8
  %nr_out = getelementptr inbounds %struct.TCGHelperInfo, ptr %3, i32 0, i32 3
  %bf.load2 = load i64, ptr %nr_out, align 8
  %bf.clear3 = and i64 %bf.load2, -71776119061217281
  %bf.set = or i64 %bf.clear3, 0
  store i64 %bf.set, ptr %nr_out, align 8
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry, %entry, %entry
  %4 = load ptr, ptr %info.addr, align 8
  %nr_out5 = getelementptr inbounds %struct.TCGHelperInfo, ptr %4, i32 0, i32 3
  %bf.load6 = load i64, ptr %nr_out5, align 8
  %bf.clear7 = and i64 %bf.load6, -71776119061217281
  %bf.set8 = or i64 %bf.clear7, 281474976710656
  store i64 %bf.set8, ptr %nr_out5, align 8
  %5 = load ptr, ptr %info.addr, align 8
  %out_kind = getelementptr inbounds %struct.TCGHelperInfo, ptr %5, i32 0, i32 3
  %bf.load9 = load i64, ptr %out_kind, align 8
  %bf.clear10 = and i64 %bf.load9, 72057594037927935
  %bf.set11 = or i64 %bf.clear10, 0
  store i64 %bf.set11, ptr %out_kind, align 8
  br label %sw.epilog

sw.bb12:                                          ; preds = %entry, %entry
  %6 = load ptr, ptr %info.addr, align 8
  %nr_out13 = getelementptr inbounds %struct.TCGHelperInfo, ptr %6, i32 0, i32 3
  %bf.load14 = load i64, ptr %nr_out13, align 8
  %bf.clear15 = and i64 %bf.load14, -71776119061217281
  %bf.set16 = or i64 %bf.clear15, 281474976710656
  store i64 %bf.set16, ptr %nr_out13, align 8
  %7 = load ptr, ptr %info.addr, align 8
  %out_kind17 = getelementptr inbounds %struct.TCGHelperInfo, ptr %7, i32 0, i32 3
  %bf.load18 = load i64, ptr %out_kind17, align 8
  %bf.clear19 = and i64 %bf.load18, 72057594037927935
  %bf.set20 = or i64 %bf.clear19, 0
  store i64 %bf.set20, ptr %out_kind17, align 8
  %8 = load ptr, ptr %info.addr, align 8
  %out_kind21 = getelementptr inbounds %struct.TCGHelperInfo, ptr %8, i32 0, i32 3
  %bf.load22 = load i64, ptr %out_kind21, align 8
  %bf.lshr = lshr i64 %bf.load22, 56
  %bf.cast23 = trunc i64 %bf.lshr to i32
  %9 = load ptr, ptr %info.addr, align 8
  %nr_out24 = getelementptr inbounds %struct.TCGHelperInfo, ptr %9, i32 0, i32 3
  %bf.load25 = load i64, ptr %nr_out24, align 8
  %bf.lshr26 = lshr i64 %bf.load25, 48
  %bf.clear27 = and i64 %bf.lshr26, 255
  %bf.cast28 = trunc i64 %bf.clear27 to i32
  %sub = sub i32 %bf.cast28, 1
  %call = call i32 @tcg_target_call_oarg_reg(i32 noundef %bf.cast23, i32 noundef %sub)
  br label %sw.epilog

sw.bb29:                                          ; preds = %entry
  %10 = load ptr, ptr %info.addr, align 8
  %nr_out30 = getelementptr inbounds %struct.TCGHelperInfo, ptr %10, i32 0, i32 3
  %bf.load31 = load i64, ptr %nr_out30, align 8
  %bf.clear32 = and i64 %bf.load31, -71776119061217281
  %bf.set33 = or i64 %bf.clear32, 562949953421312
  store i64 %bf.set33, ptr %nr_out30, align 8
  %11 = load ptr, ptr %info.addr, align 8
  %out_kind34 = getelementptr inbounds %struct.TCGHelperInfo, ptr %11, i32 0, i32 3
  %bf.load35 = load i64, ptr %out_kind34, align 8
  %bf.clear36 = and i64 %bf.load35, 72057594037927935
  %bf.set37 = or i64 %bf.clear36, 0
  store i64 %bf.set37, ptr %out_kind34, align 8
  %12 = load ptr, ptr %info.addr, align 8
  %out_kind38 = getelementptr inbounds %struct.TCGHelperInfo, ptr %12, i32 0, i32 3
  %bf.load39 = load i64, ptr %out_kind38, align 8
  %bf.lshr40 = lshr i64 %bf.load39, 56
  %bf.cast41 = trunc i64 %bf.lshr40 to i32
  %13 = load ptr, ptr %info.addr, align 8
  %nr_out42 = getelementptr inbounds %struct.TCGHelperInfo, ptr %13, i32 0, i32 3
  %bf.load43 = load i64, ptr %nr_out42, align 8
  %bf.lshr44 = lshr i64 %bf.load43, 48
  %bf.clear45 = and i64 %bf.lshr44, 255
  %bf.cast46 = trunc i64 %bf.clear45 to i32
  %sub47 = sub i32 %bf.cast46, 1
  %call48 = call i32 @tcg_target_call_oarg_reg(i32 noundef %bf.cast41, i32 noundef %sub47)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 1172, ptr noundef @__func__.init_call_layout, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb29, %sw.bb12, %sw.bb4, %sw.bb
  %14 = load i32, ptr %typemask, align 4
  %shr = lshr i32 %14, 3
  store i32 %shr, ptr %typemask, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %15 = load i32, ptr %typemask, align 4
  %tobool = icmp ne i32 %15, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load i32, ptr %typemask, align 4
  %and49 = and i32 %16, 7
  store i32 %and49, ptr %typecode, align 4
  %17 = load i32, ptr %typecode, align 4
  switch i32 %17, label %sw.default54 [
    i32 2, label %sw.bb50
    i32 3, label %sw.bb50
    i32 4, label %sw.bb51
    i32 5, label %sw.bb51
    i32 6, label %sw.bb52
    i32 7, label %sw.bb53
  ]

sw.bb50:                                          ; preds = %for.body, %for.body
  store i32 0, ptr %type, align 4
  br label %sw.epilog57

sw.bb51:                                          ; preds = %for.body, %for.body
  store i32 1, ptr %type, align 4
  br label %sw.epilog57

sw.bb52:                                          ; preds = %for.body
  store i32 1, ptr %type, align 4
  br label %sw.epilog57

sw.bb53:                                          ; preds = %for.body
  store i32 2, ptr %type, align 4
  br label %sw.epilog57

sw.default54:                                     ; preds = %for.body
  br label %do.body55

do.body55:                                        ; preds = %sw.default54
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 1199, ptr noundef @__func__.init_call_layout, ptr noundef null) #15
  unreachable

do.end56:                                         ; No predecessors!
  br label %sw.epilog57

sw.epilog57:                                      ; preds = %do.end56, %sw.bb53, %sw.bb52, %sw.bb51, %sw.bb50
  %18 = load i32, ptr %type, align 4
  switch i32 %18, label %sw.default61 [
    i32 0, label %sw.bb58
    i32 1, label %sw.bb59
    i32 2, label %sw.bb60
  ]

sw.bb58:                                          ; preds = %sw.epilog57
  %19 = load ptr, ptr %info.addr, align 8
  call void @layout_arg_1(ptr noundef %cum, ptr noundef %19, i32 noundef 0)
  br label %sw.epilog64

sw.bb59:                                          ; preds = %sw.epilog57
  %20 = load ptr, ptr %info.addr, align 8
  call void @layout_arg_1(ptr noundef %cum, ptr noundef %20, i32 noundef 0)
  br label %sw.epilog64

sw.bb60:                                          ; preds = %sw.epilog57
  %21 = load ptr, ptr %info.addr, align 8
  call void @layout_arg_normal_n(ptr noundef %cum, ptr noundef %21, i32 noundef 2)
  br label %sw.epilog64

sw.default61:                                     ; preds = %sw.epilog57
  br label %do.body62

do.body62:                                        ; preds = %sw.default61
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 1254, ptr noundef @__func__.init_call_layout, ptr noundef null) #15
  unreachable

do.end63:                                         ; No predecessors!
  br label %sw.epilog64

sw.epilog64:                                      ; preds = %do.end63, %sw.bb60, %sw.bb59, %sw.bb58
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog64
  %22 = load i32, ptr %typemask, align 4
  %shr65 = lshr i32 %22, 3
  store i32 %shr65, ptr %typemask, align 4
  %arg_idx = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %cum, i32 0, i32 0
  %23 = load i32, ptr %arg_idx, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %arg_idx, align 4
  br label %for.cond, !llvm.loop !80

for.end:                                          ; preds = %for.cond
  %info_in_idx = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %cum, i32 0, i32 1
  %24 = load i32, ptr %info_in_idx, align 4
  %25 = load ptr, ptr %info.addr, align 8
  %nr_in = getelementptr inbounds %struct.TCGHelperInfo, ptr %25, i32 0, i32 3
  %26 = zext i32 %24 to i64
  %bf.load66 = load i64, ptr %nr_in, align 8
  %bf.value = and i64 %26, 255
  %bf.shl = shl i64 %bf.value, 40
  %bf.clear67 = and i64 %bf.load66, -280375465082881
  %bf.set68 = or i64 %bf.clear67, %bf.shl
  store i64 %bf.set68, ptr %nr_in, align 8
  %info_in_idx69 = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %cum, i32 0, i32 1
  %27 = load i32, ptr %info_in_idx69, align 4
  %conv = sext i32 %27 to i64
  %cmp = icmp ule i64 %conv, 14
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %for.end
  br label %if.end

if.else:                                          ; preds = %for.end
  call void @__assert_fail(ptr noundef @.str.11, ptr noundef @.str.1, i32 noundef 1260, ptr noundef @__PRETTY_FUNCTION__.init_call_layout) #19
  unreachable

if.end:                                           ; preds = %if.then
  %arg_slot = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %cum, i32 0, i32 2
  %28 = load i32, ptr %arg_slot, align 4
  %29 = load i32, ptr %max_reg_slots, align 4
  %30 = load i32, ptr %max_stk_slots, align 4
  %add = add i32 %29, %30
  %cmp71 = icmp sle i32 %28, %add
  br i1 %cmp71, label %if.then73, label %if.else74

if.then73:                                        ; preds = %if.end
  br label %if.end75

if.else74:                                        ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.12, ptr noundef @.str.1, i32 noundef 1262, ptr noundef @__PRETTY_FUNCTION__.init_call_layout) #19
  unreachable

if.end75:                                         ; preds = %if.then73
  %ref_slot = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %cum, i32 0, i32 3
  %31 = load i32, ptr %ref_slot, align 4
  %cmp76 = icmp ne i32 %31, 0
  br i1 %cmp76, label %if.then78, label %if.end128

if.then78:                                        ; preds = %if.end75
  store i32 0, ptr %ref_base, align 4
  %arg_slot79 = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %cum, i32 0, i32 2
  %32 = load i32, ptr %arg_slot79, align 4
  %33 = load i32, ptr %max_reg_slots, align 4
  %cmp80 = icmp sgt i32 %32, %33
  br i1 %cmp80, label %if.then82, label %if.end93

if.then82:                                        ; preds = %if.then78
  store i32 2, ptr %align, align 4
  %arg_slot83 = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %cum, i32 0, i32 2
  %34 = load i32, ptr %arg_slot83, align 4
  %35 = load i32, ptr %max_reg_slots, align 4
  %sub84 = sub i32 %34, %35
  store i32 %sub84, ptr %ref_base, align 4
  %36 = load i32, ptr %align, align 4
  %cmp85 = icmp sgt i32 %36, 1
  br i1 %cmp85, label %if.then87, label %if.end92

if.then87:                                        ; preds = %if.then82
  %37 = load i32, ptr %ref_base, align 4
  %38 = load i32, ptr %align, align 4
  %add88 = add i32 %37, %38
  %sub89 = sub i32 %add88, 1
  %39 = load i32, ptr %align, align 4
  %sub90 = sub i32 0, %39
  %and91 = and i32 %sub89, %sub90
  store i32 %and91, ptr %ref_base, align 4
  br label %if.end92

if.end92:                                         ; preds = %if.then87, %if.then82
  br label %if.end93

if.end93:                                         ; preds = %if.end92, %if.then78
  %40 = load i32, ptr %ref_base, align 4
  %ref_slot94 = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %cum, i32 0, i32 3
  %41 = load i32, ptr %ref_slot94, align 4
  %add95 = add i32 %40, %41
  %42 = load i32, ptr %max_stk_slots, align 4
  %cmp96 = icmp sle i32 %add95, %42
  br i1 %cmp96, label %if.then98, label %if.else99

if.then98:                                        ; preds = %if.end93
  br label %if.end100

if.else99:                                        ; preds = %if.end93
  call void @__assert_fail(ptr noundef @.str.13, ptr noundef @.str.1, i32 noundef 1280, ptr noundef @__PRETTY_FUNCTION__.init_call_layout) #19
  unreachable

if.end100:                                        ; preds = %if.then98
  %43 = load i32, ptr %max_reg_slots, align 4
  %44 = load i32, ptr %ref_base, align 4
  %add101 = add i32 %44, %43
  store i32 %add101, ptr %ref_base, align 4
  %45 = load i32, ptr %ref_base, align 4
  %cmp102 = icmp ne i32 %45, 0
  br i1 %cmp102, label %if.then104, label %if.end127

if.then104:                                       ; preds = %if.end100
  %info_in_idx105 = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %cum, i32 0, i32 1
  %46 = load i32, ptr %info_in_idx105, align 4
  %sub106 = sub i32 %46, 1
  store i32 %sub106, ptr %i, align 4
  br label %for.cond107

for.cond107:                                      ; preds = %for.inc125, %if.then104
  %47 = load i32, ptr %i, align 4
  %cmp108 = icmp sge i32 %47, 0
  br i1 %cmp108, label %for.body110, label %for.end126

for.body110:                                      ; preds = %for.cond107
  %48 = load ptr, ptr %info.addr, align 8
  %in = getelementptr inbounds %struct.TCGHelperInfo, ptr %48, i32 0, i32 4
  %49 = load i32, ptr %i, align 4
  %idxprom = sext i32 %49 to i64
  %arrayidx = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %loc, align 8
  %50 = load ptr, ptr %loc, align 8
  %bf.load111 = load i32, ptr %50, align 4
  %bf.clear112 = and i32 %bf.load111, 255
  switch i32 %bf.clear112, label %sw.default123 [
    i32 5, label %sw.bb113
    i32 6, label %sw.bb113
  ]

sw.bb113:                                         ; preds = %for.body110, %for.body110
  %51 = load i32, ptr %ref_base, align 4
  %52 = load ptr, ptr %loc, align 8
  %bf.load114 = load i32, ptr %52, align 4
  %bf.lshr115 = lshr i32 %bf.load114, 16
  %bf.clear116 = and i32 %bf.lshr115, 255
  %add117 = add i32 %bf.clear116, %51
  %bf.load118 = load i32, ptr %52, align 4
  %bf.value119 = and i32 %add117, 255
  %bf.shl120 = shl i32 %bf.value119, 16
  %bf.clear121 = and i32 %bf.load118, -16711681
  %bf.set122 = or i32 %bf.clear121, %bf.shl120
  store i32 %bf.set122, ptr %52, align 4
  br label %sw.epilog124

sw.default123:                                    ; preds = %for.body110
  br label %sw.epilog124

sw.epilog124:                                     ; preds = %sw.default123, %sw.bb113
  br label %for.inc125

for.inc125:                                       ; preds = %sw.epilog124
  %53 = load i32, ptr %i, align 4
  %dec = add i32 %53, -1
  store i32 %dec, ptr %i, align 4
  br label %for.cond107, !llvm.loop !81

for.end126:                                       ; preds = %for.cond107
  br label %if.end127

if.end127:                                        ; preds = %for.end126, %if.end100
  br label %if.end128

if.end128:                                        ; preds = %if.end127, %if.end75
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_target_init(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 65535, ptr @tcg_target_available_regs, align 16
  store i32 65535, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_available_regs, i64 0, i64 1), align 4
  %0 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %0, 512
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -65536, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_available_regs, i64 0, i64 3), align 4
  store i32 -65536, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_available_regs, i64 0, i64 4), align 16
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i32, ptr @cpuinfo, align 4
  %and1 = and i32 %1, 1024
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -65536, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_available_regs, i64 0, i64 5), align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  store i32 -65536, ptr @tcg_target_call_clobber_regs, align 4
  %2 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %or = or i32 %2, 1
  store i32 %or, ptr @tcg_target_call_clobber_regs, align 4
  %3 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %or5 = or i32 %3, 4
  store i32 %or5, ptr @tcg_target_call_clobber_regs, align 4
  %4 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %or6 = or i32 %4, 2
  store i32 %or6, ptr @tcg_target_call_clobber_regs, align 4
  %5 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %or7 = or i32 %5, 128
  store i32 %or7, ptr @tcg_target_call_clobber_regs, align 4
  %6 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %or8 = or i32 %6, 64
  store i32 %or8, ptr @tcg_target_call_clobber_regs, align 4
  %7 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %or9 = or i32 %7, 256
  store i32 %or9, ptr @tcg_target_call_clobber_regs, align 4
  %8 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %or10 = or i32 %8, 512
  store i32 %or10, ptr @tcg_target_call_clobber_regs, align 4
  %9 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %or11 = or i32 %9, 1024
  store i32 %or11, ptr @tcg_target_call_clobber_regs, align 4
  %10 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %or12 = or i32 %10, 2048
  store i32 %or12, ptr @tcg_target_call_clobber_regs, align 4
  %11 = load ptr, ptr %s.addr, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %11, i32 0, i32 16
  store i32 0, ptr %reserved_regs, align 4
  %12 = load ptr, ptr %s.addr, align 8
  %reserved_regs13 = getelementptr inbounds %struct.TCGContext, ptr %12, i32 0, i32 16
  %13 = load i32, ptr %reserved_regs13, align 4
  %or14 = or i32 %13, 16
  store i32 %or14, ptr %reserved_regs13, align 4
  %14 = load ptr, ptr %s.addr, align 8
  %reserved_regs15 = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 16
  %15 = load i32, ptr %reserved_regs15, align 4
  %or16 = or i32 %15, 2097152
  store i32 %or16, ptr %reserved_regs15, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @process_op_defs(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %op = alloca i32, align 4
  %def = alloca ptr, align 8
  %tdefs = alloca ptr, align 8
  %saw_alias_pair = alloca i8, align 1
  %i = alloca i32, align 4
  %o = alloca i32, align 4
  %i2 = alloca i32, align 4
  %o2 = alloca i32, align 4
  %nb_args = alloca i32, align 4
  %con_set = alloca i32, align 4
  %ct_str = alloca ptr, align 8
  %input_p = alloca i8, align 1
  %.compoundliteral = alloca %struct.TCGArgConstraint, align 4
  %.compoundliteral256 = alloca %struct.TCGArgConstraint, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 0, ptr %op, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc742, %entry
  %0 = load i32, ptr %op, align 4
  %cmp = icmp ult i32 %0, 206
  br i1 %cmp, label %for.body, label %for.end744

for.body:                                         ; preds = %for.cond
  %1 = load i32, ptr %op, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr [0 x %struct.TCGOpDef], ptr @tcg_op_defs, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %def, align 8
  store i8 0, ptr %saw_alias_pair, align 1
  %2 = load ptr, ptr %def, align 8
  %flags = getelementptr inbounds %struct.TCGOpDef, ptr %2, i32 0, i32 5
  %3 = load i8, ptr %flags, align 4
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc742

if.end:                                           ; preds = %for.body
  %4 = load ptr, ptr %def, align 8
  %nb_iargs = getelementptr inbounds %struct.TCGOpDef, ptr %4, i32 0, i32 2
  %5 = load i8, ptr %nb_iargs, align 1
  %conv1 = zext i8 %5 to i32
  %6 = load ptr, ptr %def, align 8
  %nb_oargs = getelementptr inbounds %struct.TCGOpDef, ptr %6, i32 0, i32 1
  %7 = load i8, ptr %nb_oargs, align 8
  %conv2 = zext i8 %7 to i32
  %add = add i32 %conv1, %conv2
  store i32 %add, ptr %nb_args, align 4
  %8 = load i32, ptr %nb_args, align 4
  %cmp3 = icmp eq i32 %8, 0
  br i1 %cmp3, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  br label %for.inc742

if.end6:                                          ; preds = %if.end
  %9 = load i32, ptr %op, align 4
  %call = call i32 @tcg_target_op_def(i32 noundef %9)
  store i32 %call, ptr %con_set, align 4
  br label %do.body

do.body:                                          ; preds = %if.end6
  %10 = load i32, ptr %con_set, align 4
  %conv7 = zext i32 %10 to i64
  %cmp8 = icmp ult i64 %conv7, 42
  br i1 %cmp8, label %if.end11, label %if.then10

if.then10:                                        ; preds = %do.body
  unreachable

if.end11:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end11
  %11 = load i32, ptr %con_set, align 4
  %idxprom12 = zext i32 %11 to i64
  %arrayidx13 = getelementptr [42 x %struct.TCGTargetOpDef], ptr @constraint_sets, i64 0, i64 %idxprom12
  store ptr %arrayidx13, ptr %tdefs, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc, %do.end
  %12 = load i32, ptr %i, align 4
  %13 = load i32, ptr %nb_args, align 4
  %cmp15 = icmp slt i32 %12, %13
  br i1 %cmp15, label %for.body17, label %for.end

for.body17:                                       ; preds = %for.cond14
  %14 = load ptr, ptr %tdefs, align 8
  %args_ct_str = getelementptr inbounds %struct.TCGTargetOpDef, ptr %14, i32 0, i32 1
  %15 = load i32, ptr %i, align 4
  %idxprom18 = sext i32 %15 to i64
  %arrayidx19 = getelementptr [16 x ptr], ptr %args_ct_str, i64 0, i64 %idxprom18
  %16 = load ptr, ptr %arrayidx19, align 8
  store ptr %16, ptr %ct_str, align 8
  %17 = load i32, ptr %i, align 4
  %18 = load ptr, ptr %def, align 8
  %nb_oargs20 = getelementptr inbounds %struct.TCGOpDef, ptr %18, i32 0, i32 1
  %19 = load i8, ptr %nb_oargs20, align 8
  %conv21 = zext i8 %19 to i32
  %cmp22 = icmp sge i32 %17, %conv21
  %frombool = zext i1 %cmp22 to i8
  store i8 %frombool, ptr %input_p, align 1
  br label %do.body24

do.body24:                                        ; preds = %for.body17
  %20 = load ptr, ptr %ct_str, align 8
  %cmp25 = icmp ne ptr %20, null
  br i1 %cmp25, label %if.end28, label %if.then27

if.then27:                                        ; preds = %do.body24
  unreachable

if.end28:                                         ; preds = %do.body24
  br label %do.end29

do.end29:                                         ; preds = %if.end28
  %21 = load ptr, ptr %ct_str, align 8
  %22 = load i8, ptr %21, align 1
  %conv30 = sext i8 %22 to i32
  switch i32 %conv30, label %sw.epilog [
    i32 48, label %sw.bb
    i32 49, label %sw.bb
    i32 50, label %sw.bb
    i32 51, label %sw.bb
    i32 52, label %sw.bb
    i32 53, label %sw.bb
    i32 54, label %sw.bb
    i32 55, label %sw.bb
    i32 56, label %sw.bb
    i32 57, label %sw.bb
    i32 38, label %sw.bb110
    i32 112, label %sw.bb122
    i32 109, label %sw.bb214
  ]

sw.bb:                                            ; preds = %do.end29, %do.end29, %do.end29, %do.end29, %do.end29, %do.end29, %do.end29, %do.end29, %do.end29, %do.end29
  %23 = load ptr, ptr %ct_str, align 8
  %24 = load i8, ptr %23, align 1
  %conv31 = sext i8 %24 to i32
  %sub = sub i32 %conv31, 48
  store i32 %sub, ptr %o, align 4
  br label %do.body32

do.body32:                                        ; preds = %sw.bb
  %25 = load i8, ptr %input_p, align 1
  %tobool33 = trunc i8 %25 to i1
  br i1 %tobool33, label %if.end35, label %if.then34

if.then34:                                        ; preds = %do.body32
  unreachable

if.end35:                                         ; preds = %do.body32
  br label %do.end36

do.end36:                                         ; preds = %if.end35
  br label %do.body37

do.body37:                                        ; preds = %do.end36
  %26 = load i32, ptr %o, align 4
  %27 = load ptr, ptr %def, align 8
  %nb_oargs38 = getelementptr inbounds %struct.TCGOpDef, ptr %27, i32 0, i32 1
  %28 = load i8, ptr %nb_oargs38, align 8
  %conv39 = zext i8 %28 to i32
  %cmp40 = icmp slt i32 %26, %conv39
  br i1 %cmp40, label %if.end43, label %if.then42

if.then42:                                        ; preds = %do.body37
  unreachable

if.end43:                                         ; preds = %do.body37
  br label %do.end44

do.end44:                                         ; preds = %if.end43
  br label %do.body45

do.body45:                                        ; preds = %do.end44
  %29 = load ptr, ptr %def, align 8
  %args_ct = getelementptr inbounds %struct.TCGOpDef, ptr %29, i32 0, i32 6
  %30 = load ptr, ptr %args_ct, align 8
  %31 = load i32, ptr %o, align 4
  %idxprom46 = sext i32 %31 to i64
  %arrayidx47 = getelementptr %struct.TCGArgConstraint, ptr %30, i64 %idxprom46
  %regs = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx47, i32 0, i32 1
  %32 = load i32, ptr %regs, align 4
  %cmp48 = icmp ne i32 %32, 0
  br i1 %cmp48, label %if.end51, label %if.then50

if.then50:                                        ; preds = %do.body45
  unreachable

if.end51:                                         ; preds = %do.body45
  br label %do.end52

do.end52:                                         ; preds = %if.end51
  br label %do.body53

do.body53:                                        ; preds = %do.end52
  %33 = load ptr, ptr %def, align 8
  %args_ct54 = getelementptr inbounds %struct.TCGOpDef, ptr %33, i32 0, i32 6
  %34 = load ptr, ptr %args_ct54, align 8
  %35 = load i32, ptr %o, align 4
  %idxprom55 = sext i32 %35 to i64
  %arrayidx56 = getelementptr %struct.TCGArgConstraint, ptr %34, i64 %idxprom55
  %bf.load = load i64, ptr %arrayidx56, align 4
  %bf.lshr = lshr i64 %bf.load, 30
  %bf.clear = and i64 %bf.lshr, 1
  %bf.cast = trunc i64 %bf.clear to i1
  br i1 %bf.cast, label %if.then57, label %if.end58

if.then57:                                        ; preds = %do.body53
  unreachable

if.end58:                                         ; preds = %do.body53
  br label %do.end59

do.end59:                                         ; preds = %if.end58
  %36 = load ptr, ptr %def, align 8
  %args_ct60 = getelementptr inbounds %struct.TCGOpDef, ptr %36, i32 0, i32 6
  %37 = load ptr, ptr %args_ct60, align 8
  %38 = load i32, ptr %i, align 4
  %idxprom61 = sext i32 %38 to i64
  %arrayidx62 = getelementptr %struct.TCGArgConstraint, ptr %37, i64 %idxprom61
  %39 = load ptr, ptr %def, align 8
  %args_ct63 = getelementptr inbounds %struct.TCGOpDef, ptr %39, i32 0, i32 6
  %40 = load ptr, ptr %args_ct63, align 8
  %41 = load i32, ptr %o, align 4
  %idxprom64 = sext i32 %41 to i64
  %arrayidx65 = getelementptr %struct.TCGArgConstraint, ptr %40, i64 %idxprom64
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx62, ptr align 4 %arrayidx65, i64 12, i1 false)
  %42 = load ptr, ptr %def, align 8
  %args_ct66 = getelementptr inbounds %struct.TCGOpDef, ptr %42, i32 0, i32 6
  %43 = load ptr, ptr %args_ct66, align 8
  %44 = load i32, ptr %o, align 4
  %idxprom67 = sext i32 %44 to i64
  %arrayidx68 = getelementptr %struct.TCGArgConstraint, ptr %43, i64 %idxprom67
  %bf.load69 = load i64, ptr %arrayidx68, align 4
  %bf.clear70 = and i64 %bf.load69, -1073741825
  %bf.set = or i64 %bf.clear70, 1073741824
  store i64 %bf.set, ptr %arrayidx68, align 4
  %45 = load i32, ptr %i, align 4
  %46 = load ptr, ptr %def, align 8
  %args_ct71 = getelementptr inbounds %struct.TCGOpDef, ptr %46, i32 0, i32 6
  %47 = load ptr, ptr %args_ct71, align 8
  %48 = load i32, ptr %o, align 4
  %idxprom72 = sext i32 %48 to i64
  %arrayidx73 = getelementptr %struct.TCGArgConstraint, ptr %47, i64 %idxprom72
  %49 = zext i32 %45 to i64
  %bf.load74 = load i64, ptr %arrayidx73, align 4
  %bf.value = and i64 %49, 15
  %bf.shl = shl i64 %bf.value, 16
  %bf.clear75 = and i64 %bf.load74, -983041
  %bf.set76 = or i64 %bf.clear75, %bf.shl
  store i64 %bf.set76, ptr %arrayidx73, align 4
  %50 = load ptr, ptr %def, align 8
  %args_ct77 = getelementptr inbounds %struct.TCGOpDef, ptr %50, i32 0, i32 6
  %51 = load ptr, ptr %args_ct77, align 8
  %52 = load i32, ptr %i, align 4
  %idxprom78 = sext i32 %52 to i64
  %arrayidx79 = getelementptr %struct.TCGArgConstraint, ptr %51, i64 %idxprom78
  %bf.load80 = load i64, ptr %arrayidx79, align 4
  %bf.clear81 = and i64 %bf.load80, -2147483649
  %bf.set82 = or i64 %bf.clear81, 2147483648
  store i64 %bf.set82, ptr %arrayidx79, align 4
  %53 = load i32, ptr %o, align 4
  %54 = load ptr, ptr %def, align 8
  %args_ct83 = getelementptr inbounds %struct.TCGOpDef, ptr %54, i32 0, i32 6
  %55 = load ptr, ptr %args_ct83, align 8
  %56 = load i32, ptr %i, align 4
  %idxprom84 = sext i32 %56 to i64
  %arrayidx85 = getelementptr %struct.TCGArgConstraint, ptr %55, i64 %idxprom84
  %57 = zext i32 %53 to i64
  %bf.load86 = load i64, ptr %arrayidx85, align 4
  %bf.value87 = and i64 %57, 15
  %bf.shl88 = shl i64 %bf.value87, 16
  %bf.clear89 = and i64 %bf.load86, -983041
  %bf.set90 = or i64 %bf.clear89, %bf.shl88
  store i64 %bf.set90, ptr %arrayidx85, align 4
  %58 = load ptr, ptr %def, align 8
  %args_ct92 = getelementptr inbounds %struct.TCGOpDef, ptr %58, i32 0, i32 6
  %59 = load ptr, ptr %args_ct92, align 8
  %60 = load i32, ptr %i, align 4
  %idxprom93 = sext i32 %60 to i64
  %arrayidx94 = getelementptr %struct.TCGArgConstraint, ptr %59, i64 %idxprom93
  %bf.load95 = load i64, ptr %arrayidx94, align 4
  %bf.lshr96 = lshr i64 %bf.load95, 28
  %bf.clear97 = and i64 %bf.lshr96, 3
  %bf.cast98 = trunc i64 %bf.clear97 to i32
  %tobool99 = icmp ne i32 %bf.cast98, 0
  br i1 %tobool99, label %if.then100, label %if.end101

if.then100:                                       ; preds = %do.end59
  store i8 1, ptr %saw_alias_pair, align 1
  br label %if.end101

if.end101:                                        ; preds = %if.then100, %do.end59
  br label %do.body102

do.body102:                                       ; preds = %if.end101
  %61 = load ptr, ptr %ct_str, align 8
  %arrayidx103 = getelementptr i8, ptr %61, i64 1
  %62 = load i8, ptr %arrayidx103, align 1
  %conv104 = sext i8 %62 to i32
  %cmp105 = icmp eq i32 %conv104, 0
  br i1 %cmp105, label %if.end108, label %if.then107

if.then107:                                       ; preds = %do.body102
  unreachable

if.end108:                                        ; preds = %do.body102
  br label %do.end109

do.end109:                                        ; preds = %if.end108
  br label %for.inc

sw.bb110:                                         ; preds = %do.end29
  br label %do.body111

do.body111:                                       ; preds = %sw.bb110
  %63 = load i8, ptr %input_p, align 1
  %tobool112 = trunc i8 %63 to i1
  br i1 %tobool112, label %if.then113, label %if.end114

if.then113:                                       ; preds = %do.body111
  unreachable

if.end114:                                        ; preds = %do.body111
  br label %do.end115

do.end115:                                        ; preds = %if.end114
  %64 = load ptr, ptr %def, align 8
  %args_ct116 = getelementptr inbounds %struct.TCGOpDef, ptr %64, i32 0, i32 6
  %65 = load ptr, ptr %args_ct116, align 8
  %66 = load i32, ptr %i, align 4
  %idxprom117 = sext i32 %66 to i64
  %arrayidx118 = getelementptr %struct.TCGArgConstraint, ptr %65, i64 %idxprom117
  %bf.load119 = load i64, ptr %arrayidx118, align 4
  %bf.clear120 = and i64 %bf.load119, -4294967297
  %bf.set121 = or i64 %bf.clear120, 4294967296
  store i64 %bf.set121, ptr %arrayidx118, align 4
  %67 = load ptr, ptr %ct_str, align 8
  %incdec.ptr = getelementptr i8, ptr %67, i32 1
  store ptr %incdec.ptr, ptr %ct_str, align 8
  br label %sw.epilog

sw.bb122:                                         ; preds = %do.end29
  br label %do.body123

do.body123:                                       ; preds = %sw.bb122
  %68 = load i32, ptr %i, align 4
  %69 = load i8, ptr %input_p, align 1
  %tobool124 = trunc i8 %69 to i1
  br i1 %tobool124, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.body123
  %70 = load ptr, ptr %def, align 8
  %nb_oargs126 = getelementptr inbounds %struct.TCGOpDef, ptr %70, i32 0, i32 1
  %71 = load i8, ptr %nb_oargs126, align 8
  %conv127 = zext i8 %71 to i32
  br label %cond.end

cond.false:                                       ; preds = %do.body123
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv127, %cond.true ], [ 0, %cond.false ]
  %cmp128 = icmp sgt i32 %68, %cond
  br i1 %cmp128, label %if.end131, label %if.then130

if.then130:                                       ; preds = %cond.end
  unreachable

if.end131:                                        ; preds = %cond.end
  br label %do.end132

do.end132:                                        ; preds = %if.end131
  %72 = load i32, ptr %i, align 4
  %sub133 = sub i32 %72, 1
  store i32 %sub133, ptr %o, align 4
  br label %do.body134

do.body134:                                       ; preds = %do.end132
  %73 = load ptr, ptr %def, align 8
  %args_ct135 = getelementptr inbounds %struct.TCGOpDef, ptr %73, i32 0, i32 6
  %74 = load ptr, ptr %args_ct135, align 8
  %75 = load i32, ptr %o, align 4
  %idxprom136 = sext i32 %75 to i64
  %arrayidx137 = getelementptr %struct.TCGArgConstraint, ptr %74, i64 %idxprom136
  %bf.load138 = load i64, ptr %arrayidx137, align 4
  %bf.lshr139 = lshr i64 %bf.load138, 28
  %bf.clear140 = and i64 %bf.lshr139, 3
  %bf.cast141 = trunc i64 %bf.clear140 to i32
  %tobool142 = icmp ne i32 %bf.cast141, 0
  br i1 %tobool142, label %if.then143, label %if.end144

if.then143:                                       ; preds = %do.body134
  unreachable

if.end144:                                        ; preds = %do.body134
  br label %do.end145

do.end145:                                        ; preds = %if.end144
  br label %do.body146

do.body146:                                       ; preds = %do.end145
  %76 = load ptr, ptr %def, align 8
  %args_ct147 = getelementptr inbounds %struct.TCGOpDef, ptr %76, i32 0, i32 6
  %77 = load ptr, ptr %args_ct147, align 8
  %78 = load i32, ptr %o, align 4
  %idxprom148 = sext i32 %78 to i64
  %arrayidx149 = getelementptr %struct.TCGArgConstraint, ptr %77, i64 %idxprom148
  %bf.load150 = load i64, ptr %arrayidx149, align 4
  %bf.clear151 = and i64 %bf.load150, 65535
  %bf.cast152 = trunc i64 %bf.clear151 to i32
  %tobool153 = icmp ne i32 %bf.cast152, 0
  br i1 %tobool153, label %if.then154, label %if.end155

if.then154:                                       ; preds = %do.body146
  unreachable

if.end155:                                        ; preds = %do.body146
  br label %do.end156

do.end156:                                        ; preds = %if.end155
  %79 = load ptr, ptr %def, align 8
  %args_ct157 = getelementptr inbounds %struct.TCGOpDef, ptr %79, i32 0, i32 6
  %80 = load ptr, ptr %args_ct157, align 8
  %81 = load i32, ptr %i, align 4
  %idxprom158 = sext i32 %81 to i64
  %arrayidx159 = getelementptr %struct.TCGArgConstraint, ptr %80, i64 %idxprom158
  %bf.load160 = load i64, ptr %.compoundliteral, align 4
  %bf.clear161 = and i64 %bf.load160, -65536
  %bf.set162 = or i64 %bf.clear161, 0
  store i64 %bf.set162, ptr %.compoundliteral, align 4
  %bf.load163 = load i64, ptr %.compoundliteral, align 4
  %bf.clear164 = and i64 %bf.load163, -983041
  %bf.set165 = or i64 %bf.clear164, 0
  store i64 %bf.set165, ptr %.compoundliteral, align 4
  %bf.load166 = load i64, ptr %.compoundliteral, align 4
  %bf.clear167 = and i64 %bf.load166, -15728641
  %bf.set168 = or i64 %bf.clear167, 0
  store i64 %bf.set168, ptr %.compoundliteral, align 4
  %82 = load i32, ptr %o, align 4
  %83 = zext i32 %82 to i64
  %bf.load169 = load i64, ptr %.compoundliteral, align 4
  %bf.value170 = and i64 %83, 15
  %bf.shl171 = shl i64 %bf.value170, 24
  %bf.clear172 = and i64 %bf.load169, -251658241
  %bf.set173 = or i64 %bf.clear172, %bf.shl171
  store i64 %bf.set173, ptr %.compoundliteral, align 4
  %bf.load174 = load i64, ptr %.compoundliteral, align 4
  %bf.clear175 = and i64 %bf.load174, -805306369
  %bf.set176 = or i64 %bf.clear175, 536870912
  store i64 %bf.set176, ptr %.compoundliteral, align 4
  %bf.load177 = load i64, ptr %.compoundliteral, align 4
  %bf.clear178 = and i64 %bf.load177, -1073741825
  %bf.set179 = or i64 %bf.clear178, 0
  store i64 %bf.set179, ptr %.compoundliteral, align 4
  %bf.load180 = load i64, ptr %.compoundliteral, align 4
  %bf.clear181 = and i64 %bf.load180, -2147483649
  %bf.set182 = or i64 %bf.clear181, 0
  store i64 %bf.set182, ptr %.compoundliteral, align 4
  %bf.load183 = load i64, ptr %.compoundliteral, align 4
  %bf.clear184 = and i64 %bf.load183, -4294967297
  %bf.set185 = or i64 %bf.clear184, 0
  store i64 %bf.set185, ptr %.compoundliteral, align 4
  %regs186 = getelementptr inbounds %struct.TCGArgConstraint, ptr %.compoundliteral, i32 0, i32 1
  %84 = load ptr, ptr %def, align 8
  %args_ct187 = getelementptr inbounds %struct.TCGOpDef, ptr %84, i32 0, i32 6
  %85 = load ptr, ptr %args_ct187, align 8
  %86 = load i32, ptr %o, align 4
  %idxprom188 = sext i32 %86 to i64
  %arrayidx189 = getelementptr %struct.TCGArgConstraint, ptr %85, i64 %idxprom188
  %regs190 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx189, i32 0, i32 1
  %87 = load i32, ptr %regs190, align 4
  %shl = shl i32 %87, 1
  store i32 %shl, ptr %regs186, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx159, ptr align 4 %.compoundliteral, i64 12, i1 false)
  %88 = load ptr, ptr %def, align 8
  %args_ct191 = getelementptr inbounds %struct.TCGOpDef, ptr %88, i32 0, i32 6
  %89 = load ptr, ptr %args_ct191, align 8
  %90 = load i32, ptr %o, align 4
  %idxprom192 = sext i32 %90 to i64
  %arrayidx193 = getelementptr %struct.TCGArgConstraint, ptr %89, i64 %idxprom192
  %bf.load194 = load i64, ptr %arrayidx193, align 4
  %bf.clear195 = and i64 %bf.load194, -805306369
  %bf.set196 = or i64 %bf.clear195, 268435456
  store i64 %bf.set196, ptr %arrayidx193, align 4
  %91 = load i32, ptr %i, align 4
  %92 = load ptr, ptr %def, align 8
  %args_ct197 = getelementptr inbounds %struct.TCGOpDef, ptr %92, i32 0, i32 6
  %93 = load ptr, ptr %args_ct197, align 8
  %94 = load i32, ptr %o, align 4
  %idxprom198 = sext i32 %94 to i64
  %arrayidx199 = getelementptr %struct.TCGArgConstraint, ptr %93, i64 %idxprom198
  %95 = zext i32 %91 to i64
  %bf.load200 = load i64, ptr %arrayidx199, align 4
  %bf.value201 = and i64 %95, 15
  %bf.shl202 = shl i64 %bf.value201, 24
  %bf.clear203 = and i64 %bf.load200, -251658241
  %bf.set204 = or i64 %bf.clear203, %bf.shl202
  store i64 %bf.set204, ptr %arrayidx199, align 4
  br label %do.body206

do.body206:                                       ; preds = %do.end156
  %96 = load ptr, ptr %ct_str, align 8
  %arrayidx207 = getelementptr i8, ptr %96, i64 1
  %97 = load i8, ptr %arrayidx207, align 1
  %conv208 = sext i8 %97 to i32
  %cmp209 = icmp eq i32 %conv208, 0
  br i1 %cmp209, label %if.end212, label %if.then211

if.then211:                                       ; preds = %do.body206
  unreachable

if.end212:                                        ; preds = %do.body206
  br label %do.end213

do.end213:                                        ; preds = %if.end212
  br label %for.inc

sw.bb214:                                         ; preds = %do.end29
  br label %do.body215

do.body215:                                       ; preds = %sw.bb214
  %98 = load i32, ptr %i, align 4
  %99 = load i8, ptr %input_p, align 1
  %tobool216 = trunc i8 %99 to i1
  br i1 %tobool216, label %cond.true218, label %cond.false221

cond.true218:                                     ; preds = %do.body215
  %100 = load ptr, ptr %def, align 8
  %nb_oargs219 = getelementptr inbounds %struct.TCGOpDef, ptr %100, i32 0, i32 1
  %101 = load i8, ptr %nb_oargs219, align 8
  %conv220 = zext i8 %101 to i32
  br label %cond.end222

cond.false221:                                    ; preds = %do.body215
  br label %cond.end222

cond.end222:                                      ; preds = %cond.false221, %cond.true218
  %cond223 = phi i32 [ %conv220, %cond.true218 ], [ 0, %cond.false221 ]
  %cmp224 = icmp sgt i32 %98, %cond223
  br i1 %cmp224, label %if.end227, label %if.then226

if.then226:                                       ; preds = %cond.end222
  unreachable

if.end227:                                        ; preds = %cond.end222
  br label %do.end228

do.end228:                                        ; preds = %if.end227
  %102 = load i32, ptr %i, align 4
  %sub229 = sub i32 %102, 1
  store i32 %sub229, ptr %o, align 4
  br label %do.body230

do.body230:                                       ; preds = %do.end228
  %103 = load ptr, ptr %def, align 8
  %args_ct231 = getelementptr inbounds %struct.TCGOpDef, ptr %103, i32 0, i32 6
  %104 = load ptr, ptr %args_ct231, align 8
  %105 = load i32, ptr %o, align 4
  %idxprom232 = sext i32 %105 to i64
  %arrayidx233 = getelementptr %struct.TCGArgConstraint, ptr %104, i64 %idxprom232
  %bf.load234 = load i64, ptr %arrayidx233, align 4
  %bf.lshr235 = lshr i64 %bf.load234, 28
  %bf.clear236 = and i64 %bf.lshr235, 3
  %bf.cast237 = trunc i64 %bf.clear236 to i32
  %tobool238 = icmp ne i32 %bf.cast237, 0
  br i1 %tobool238, label %if.then239, label %if.end240

if.then239:                                       ; preds = %do.body230
  unreachable

if.end240:                                        ; preds = %do.body230
  br label %do.end241

do.end241:                                        ; preds = %if.end240
  br label %do.body242

do.body242:                                       ; preds = %do.end241
  %106 = load ptr, ptr %def, align 8
  %args_ct243 = getelementptr inbounds %struct.TCGOpDef, ptr %106, i32 0, i32 6
  %107 = load ptr, ptr %args_ct243, align 8
  %108 = load i32, ptr %o, align 4
  %idxprom244 = sext i32 %108 to i64
  %arrayidx245 = getelementptr %struct.TCGArgConstraint, ptr %107, i64 %idxprom244
  %bf.load246 = load i64, ptr %arrayidx245, align 4
  %bf.clear247 = and i64 %bf.load246, 65535
  %bf.cast248 = trunc i64 %bf.clear247 to i32
  %tobool249 = icmp ne i32 %bf.cast248, 0
  br i1 %tobool249, label %if.then250, label %if.end251

if.then250:                                       ; preds = %do.body242
  unreachable

if.end251:                                        ; preds = %do.body242
  br label %do.end252

do.end252:                                        ; preds = %if.end251
  %109 = load ptr, ptr %def, align 8
  %args_ct253 = getelementptr inbounds %struct.TCGOpDef, ptr %109, i32 0, i32 6
  %110 = load ptr, ptr %args_ct253, align 8
  %111 = load i32, ptr %i, align 4
  %idxprom254 = sext i32 %111 to i64
  %arrayidx255 = getelementptr %struct.TCGArgConstraint, ptr %110, i64 %idxprom254
  %bf.load257 = load i64, ptr %.compoundliteral256, align 4
  %bf.clear258 = and i64 %bf.load257, -65536
  %bf.set259 = or i64 %bf.clear258, 0
  store i64 %bf.set259, ptr %.compoundliteral256, align 4
  %bf.load260 = load i64, ptr %.compoundliteral256, align 4
  %bf.clear261 = and i64 %bf.load260, -983041
  %bf.set262 = or i64 %bf.clear261, 0
  store i64 %bf.set262, ptr %.compoundliteral256, align 4
  %bf.load263 = load i64, ptr %.compoundliteral256, align 4
  %bf.clear264 = and i64 %bf.load263, -15728641
  %bf.set265 = or i64 %bf.clear264, 0
  store i64 %bf.set265, ptr %.compoundliteral256, align 4
  %112 = load i32, ptr %o, align 4
  %113 = zext i32 %112 to i64
  %bf.load266 = load i64, ptr %.compoundliteral256, align 4
  %bf.value267 = and i64 %113, 15
  %bf.shl268 = shl i64 %bf.value267, 24
  %bf.clear269 = and i64 %bf.load266, -251658241
  %bf.set270 = or i64 %bf.clear269, %bf.shl268
  store i64 %bf.set270, ptr %.compoundliteral256, align 4
  %bf.load271 = load i64, ptr %.compoundliteral256, align 4
  %bf.clear272 = and i64 %bf.load271, -805306369
  %bf.set273 = or i64 %bf.clear272, 268435456
  store i64 %bf.set273, ptr %.compoundliteral256, align 4
  %bf.load274 = load i64, ptr %.compoundliteral256, align 4
  %bf.clear275 = and i64 %bf.load274, -1073741825
  %bf.set276 = or i64 %bf.clear275, 0
  store i64 %bf.set276, ptr %.compoundliteral256, align 4
  %bf.load277 = load i64, ptr %.compoundliteral256, align 4
  %bf.clear278 = and i64 %bf.load277, -2147483649
  %bf.set279 = or i64 %bf.clear278, 0
  store i64 %bf.set279, ptr %.compoundliteral256, align 4
  %bf.load280 = load i64, ptr %.compoundliteral256, align 4
  %bf.clear281 = and i64 %bf.load280, -4294967297
  %bf.set282 = or i64 %bf.clear281, 0
  store i64 %bf.set282, ptr %.compoundliteral256, align 4
  %regs283 = getelementptr inbounds %struct.TCGArgConstraint, ptr %.compoundliteral256, i32 0, i32 1
  %114 = load ptr, ptr %def, align 8
  %args_ct284 = getelementptr inbounds %struct.TCGOpDef, ptr %114, i32 0, i32 6
  %115 = load ptr, ptr %args_ct284, align 8
  %116 = load i32, ptr %o, align 4
  %idxprom285 = sext i32 %116 to i64
  %arrayidx286 = getelementptr %struct.TCGArgConstraint, ptr %115, i64 %idxprom285
  %regs287 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx286, i32 0, i32 1
  %117 = load i32, ptr %regs287, align 4
  %shr = lshr i32 %117, 1
  store i32 %shr, ptr %regs283, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx255, ptr align 4 %.compoundliteral256, i64 12, i1 false)
  %118 = load ptr, ptr %def, align 8
  %args_ct288 = getelementptr inbounds %struct.TCGOpDef, ptr %118, i32 0, i32 6
  %119 = load ptr, ptr %args_ct288, align 8
  %120 = load i32, ptr %o, align 4
  %idxprom289 = sext i32 %120 to i64
  %arrayidx290 = getelementptr %struct.TCGArgConstraint, ptr %119, i64 %idxprom289
  %bf.load291 = load i64, ptr %arrayidx290, align 4
  %bf.clear292 = and i64 %bf.load291, -805306369
  %bf.set293 = or i64 %bf.clear292, 536870912
  store i64 %bf.set293, ptr %arrayidx290, align 4
  %121 = load i32, ptr %i, align 4
  %122 = load ptr, ptr %def, align 8
  %args_ct294 = getelementptr inbounds %struct.TCGOpDef, ptr %122, i32 0, i32 6
  %123 = load ptr, ptr %args_ct294, align 8
  %124 = load i32, ptr %o, align 4
  %idxprom295 = sext i32 %124 to i64
  %arrayidx296 = getelementptr %struct.TCGArgConstraint, ptr %123, i64 %idxprom295
  %125 = zext i32 %121 to i64
  %bf.load297 = load i64, ptr %arrayidx296, align 4
  %bf.value298 = and i64 %125, 15
  %bf.shl299 = shl i64 %bf.value298, 24
  %bf.clear300 = and i64 %bf.load297, -251658241
  %bf.set301 = or i64 %bf.clear300, %bf.shl299
  store i64 %bf.set301, ptr %arrayidx296, align 4
  br label %do.body303

do.body303:                                       ; preds = %do.end252
  %126 = load ptr, ptr %ct_str, align 8
  %arrayidx304 = getelementptr i8, ptr %126, i64 1
  %127 = load i8, ptr %arrayidx304, align 1
  %conv305 = sext i8 %127 to i32
  %cmp306 = icmp eq i32 %conv305, 0
  br i1 %cmp306, label %if.end309, label %if.then308

if.then308:                                       ; preds = %do.body303
  unreachable

if.end309:                                        ; preds = %do.body303
  br label %do.end310

do.end310:                                        ; preds = %if.end309
  br label %for.inc

sw.epilog:                                        ; preds = %do.end115, %do.end29
  br label %do.body311

do.body311:                                       ; preds = %do.cond, %sw.epilog
  %128 = load ptr, ptr %ct_str, align 8
  %129 = load i8, ptr %128, align 1
  %conv312 = sext i8 %129 to i32
  switch i32 %conv312, label %sw.default [
    i32 105, label %sw.bb313
    i32 97, label %sw.bb325
    i32 98, label %sw.bb331
    i32 99, label %sw.bb337
    i32 100, label %sw.bb343
    i32 83, label %sw.bb349
    i32 68, label %sw.bb355
    i32 114, label %sw.bb361
    i32 120, label %sw.bb367
    i32 113, label %sw.bb373
    i32 76, label %sw.bb379
    i32 115, label %sw.bb392
    i32 101, label %sw.bb406
    i32 73, label %sw.bb419
    i32 87, label %sw.bb432
    i32 90, label %sw.bb445
    i32 38, label %sw.bb459
    i32 112, label %sw.bb459
    i32 109, label %sw.bb459
    i32 48, label %sw.bb458
    i32 49, label %sw.bb458
    i32 50, label %sw.bb458
    i32 51, label %sw.bb458
    i32 52, label %sw.bb458
    i32 53, label %sw.bb458
    i32 54, label %sw.bb458
    i32 55, label %sw.bb458
    i32 56, label %sw.bb458
    i32 57, label %sw.bb458
  ]

sw.bb313:                                         ; preds = %do.body311
  %130 = load ptr, ptr %def, align 8
  %args_ct314 = getelementptr inbounds %struct.TCGOpDef, ptr %130, i32 0, i32 6
  %131 = load ptr, ptr %args_ct314, align 8
  %132 = load i32, ptr %i, align 4
  %idxprom315 = sext i32 %132 to i64
  %arrayidx316 = getelementptr %struct.TCGArgConstraint, ptr %131, i64 %idxprom315
  %bf.load317 = load i64, ptr %arrayidx316, align 4
  %bf.clear318 = and i64 %bf.load317, 65535
  %bf.cast319 = trunc i64 %bf.clear318 to i32
  %or = or i32 %bf.cast319, 1
  %133 = zext i32 %or to i64
  %bf.load320 = load i64, ptr %arrayidx316, align 4
  %bf.value321 = and i64 %133, 65535
  %bf.clear322 = and i64 %bf.load320, -65536
  %bf.set323 = or i64 %bf.clear322, %bf.value321
  store i64 %bf.set323, ptr %arrayidx316, align 4
  br label %sw.epilog462

sw.bb325:                                         ; preds = %do.body311
  %134 = load ptr, ptr %def, align 8
  %args_ct326 = getelementptr inbounds %struct.TCGOpDef, ptr %134, i32 0, i32 6
  %135 = load ptr, ptr %args_ct326, align 8
  %136 = load i32, ptr %i, align 4
  %idxprom327 = sext i32 %136 to i64
  %arrayidx328 = getelementptr %struct.TCGArgConstraint, ptr %135, i64 %idxprom327
  %regs329 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx328, i32 0, i32 1
  %137 = load i32, ptr %regs329, align 4
  %or330 = or i32 %137, 1
  store i32 %or330, ptr %regs329, align 4
  br label %sw.epilog462

sw.bb331:                                         ; preds = %do.body311
  %138 = load ptr, ptr %def, align 8
  %args_ct332 = getelementptr inbounds %struct.TCGOpDef, ptr %138, i32 0, i32 6
  %139 = load ptr, ptr %args_ct332, align 8
  %140 = load i32, ptr %i, align 4
  %idxprom333 = sext i32 %140 to i64
  %arrayidx334 = getelementptr %struct.TCGArgConstraint, ptr %139, i64 %idxprom333
  %regs335 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx334, i32 0, i32 1
  %141 = load i32, ptr %regs335, align 4
  %or336 = or i32 %141, 8
  store i32 %or336, ptr %regs335, align 4
  br label %sw.epilog462

sw.bb337:                                         ; preds = %do.body311
  %142 = load ptr, ptr %def, align 8
  %args_ct338 = getelementptr inbounds %struct.TCGOpDef, ptr %142, i32 0, i32 6
  %143 = load ptr, ptr %args_ct338, align 8
  %144 = load i32, ptr %i, align 4
  %idxprom339 = sext i32 %144 to i64
  %arrayidx340 = getelementptr %struct.TCGArgConstraint, ptr %143, i64 %idxprom339
  %regs341 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx340, i32 0, i32 1
  %145 = load i32, ptr %regs341, align 4
  %or342 = or i32 %145, 2
  store i32 %or342, ptr %regs341, align 4
  br label %sw.epilog462

sw.bb343:                                         ; preds = %do.body311
  %146 = load ptr, ptr %def, align 8
  %args_ct344 = getelementptr inbounds %struct.TCGOpDef, ptr %146, i32 0, i32 6
  %147 = load ptr, ptr %args_ct344, align 8
  %148 = load i32, ptr %i, align 4
  %idxprom345 = sext i32 %148 to i64
  %arrayidx346 = getelementptr %struct.TCGArgConstraint, ptr %147, i64 %idxprom345
  %regs347 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx346, i32 0, i32 1
  %149 = load i32, ptr %regs347, align 4
  %or348 = or i32 %149, 4
  store i32 %or348, ptr %regs347, align 4
  br label %sw.epilog462

sw.bb349:                                         ; preds = %do.body311
  %150 = load ptr, ptr %def, align 8
  %args_ct350 = getelementptr inbounds %struct.TCGOpDef, ptr %150, i32 0, i32 6
  %151 = load ptr, ptr %args_ct350, align 8
  %152 = load i32, ptr %i, align 4
  %idxprom351 = sext i32 %152 to i64
  %arrayidx352 = getelementptr %struct.TCGArgConstraint, ptr %151, i64 %idxprom351
  %regs353 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx352, i32 0, i32 1
  %153 = load i32, ptr %regs353, align 4
  %or354 = or i32 %153, 64
  store i32 %or354, ptr %regs353, align 4
  br label %sw.epilog462

sw.bb355:                                         ; preds = %do.body311
  %154 = load ptr, ptr %def, align 8
  %args_ct356 = getelementptr inbounds %struct.TCGOpDef, ptr %154, i32 0, i32 6
  %155 = load ptr, ptr %args_ct356, align 8
  %156 = load i32, ptr %i, align 4
  %idxprom357 = sext i32 %156 to i64
  %arrayidx358 = getelementptr %struct.TCGArgConstraint, ptr %155, i64 %idxprom357
  %regs359 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx358, i32 0, i32 1
  %157 = load i32, ptr %regs359, align 4
  %or360 = or i32 %157, 128
  store i32 %or360, ptr %regs359, align 4
  br label %sw.epilog462

sw.bb361:                                         ; preds = %do.body311
  %158 = load ptr, ptr %def, align 8
  %args_ct362 = getelementptr inbounds %struct.TCGOpDef, ptr %158, i32 0, i32 6
  %159 = load ptr, ptr %args_ct362, align 8
  %160 = load i32, ptr %i, align 4
  %idxprom363 = sext i32 %160 to i64
  %arrayidx364 = getelementptr %struct.TCGArgConstraint, ptr %159, i64 %idxprom363
  %regs365 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx364, i32 0, i32 1
  %161 = load i32, ptr %regs365, align 4
  %or366 = or i32 %161, 65535
  store i32 %or366, ptr %regs365, align 4
  br label %sw.epilog462

sw.bb367:                                         ; preds = %do.body311
  %162 = load ptr, ptr %def, align 8
  %args_ct368 = getelementptr inbounds %struct.TCGOpDef, ptr %162, i32 0, i32 6
  %163 = load ptr, ptr %args_ct368, align 8
  %164 = load i32, ptr %i, align 4
  %idxprom369 = sext i32 %164 to i64
  %arrayidx370 = getelementptr %struct.TCGArgConstraint, ptr %163, i64 %idxprom369
  %regs371 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx370, i32 0, i32 1
  %165 = load i32, ptr %regs371, align 4
  %or372 = or i32 %165, -65536
  store i32 %or372, ptr %regs371, align 4
  br label %sw.epilog462

sw.bb373:                                         ; preds = %do.body311
  %166 = load ptr, ptr %def, align 8
  %args_ct374 = getelementptr inbounds %struct.TCGOpDef, ptr %166, i32 0, i32 6
  %167 = load ptr, ptr %args_ct374, align 8
  %168 = load i32, ptr %i, align 4
  %idxprom375 = sext i32 %168 to i64
  %arrayidx376 = getelementptr %struct.TCGArgConstraint, ptr %167, i64 %idxprom375
  %regs377 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx376, i32 0, i32 1
  %169 = load i32, ptr %regs377, align 4
  %or378 = or i32 %169, 65535
  store i32 %or378, ptr %regs377, align 4
  br label %sw.epilog462

sw.bb379:                                         ; preds = %do.body311
  %170 = load i8, ptr @tcg_use_softmmu, align 1
  %tobool380 = trunc i8 %170 to i1
  %171 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %shl382 = shl i32 1, %171
  %172 = load i32, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 1), align 4
  %shl383 = shl i32 1, %172
  %or384 = or i32 %shl382, %shl383
  %cond385 = select i1 %tobool380, i32 %or384, i32 0
  %not = xor i32 %cond385, -1
  %and386 = and i32 65535, %not
  %173 = load ptr, ptr %def, align 8
  %args_ct387 = getelementptr inbounds %struct.TCGOpDef, ptr %173, i32 0, i32 6
  %174 = load ptr, ptr %args_ct387, align 8
  %175 = load i32, ptr %i, align 4
  %idxprom388 = sext i32 %175 to i64
  %arrayidx389 = getelementptr %struct.TCGArgConstraint, ptr %174, i64 %idxprom388
  %regs390 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx389, i32 0, i32 1
  %176 = load i32, ptr %regs390, align 4
  %or391 = or i32 %176, %and386
  store i32 %or391, ptr %regs390, align 4
  br label %sw.epilog462

sw.bb392:                                         ; preds = %do.body311
  %177 = load i8, ptr @tcg_use_softmmu, align 1
  %tobool393 = trunc i8 %177 to i1
  %178 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %shl395 = shl i32 1, %178
  %179 = load i32, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 1), align 4
  %shl396 = shl i32 1, %179
  %or397 = or i32 %shl395, %shl396
  %cond398 = select i1 %tobool393, i32 %or397, i32 0
  %not399 = xor i32 %cond398, -1
  %and400 = and i32 65535, %not399
  %180 = load ptr, ptr %def, align 8
  %args_ct401 = getelementptr inbounds %struct.TCGOpDef, ptr %180, i32 0, i32 6
  %181 = load ptr, ptr %args_ct401, align 8
  %182 = load i32, ptr %i, align 4
  %idxprom402 = sext i32 %182 to i64
  %arrayidx403 = getelementptr %struct.TCGArgConstraint, ptr %181, i64 %idxprom402
  %regs404 = getelementptr inbounds %struct.TCGArgConstraint, ptr %arrayidx403, i32 0, i32 1
  %183 = load i32, ptr %regs404, align 4
  %or405 = or i32 %183, %and400
  store i32 %or405, ptr %regs404, align 4
  br label %sw.epilog462

sw.bb406:                                         ; preds = %do.body311
  %184 = load ptr, ptr %def, align 8
  %args_ct407 = getelementptr inbounds %struct.TCGOpDef, ptr %184, i32 0, i32 6
  %185 = load ptr, ptr %args_ct407, align 8
  %186 = load i32, ptr %i, align 4
  %idxprom408 = sext i32 %186 to i64
  %arrayidx409 = getelementptr %struct.TCGArgConstraint, ptr %185, i64 %idxprom408
  %bf.load410 = load i64, ptr %arrayidx409, align 4
  %bf.clear411 = and i64 %bf.load410, 65535
  %bf.cast412 = trunc i64 %bf.clear411 to i32
  %or413 = or i32 %bf.cast412, 256
  %187 = zext i32 %or413 to i64
  %bf.load414 = load i64, ptr %arrayidx409, align 4
  %bf.value415 = and i64 %187, 65535
  %bf.clear416 = and i64 %bf.load414, -65536
  %bf.set417 = or i64 %bf.clear416, %bf.value415
  store i64 %bf.set417, ptr %arrayidx409, align 4
  br label %sw.epilog462

sw.bb419:                                         ; preds = %do.body311
  %188 = load ptr, ptr %def, align 8
  %args_ct420 = getelementptr inbounds %struct.TCGOpDef, ptr %188, i32 0, i32 6
  %189 = load ptr, ptr %args_ct420, align 8
  %190 = load i32, ptr %i, align 4
  %idxprom421 = sext i32 %190 to i64
  %arrayidx422 = getelementptr %struct.TCGArgConstraint, ptr %189, i64 %idxprom421
  %bf.load423 = load i64, ptr %arrayidx422, align 4
  %bf.clear424 = and i64 %bf.load423, 65535
  %bf.cast425 = trunc i64 %bf.clear424 to i32
  %or426 = or i32 %bf.cast425, 1024
  %191 = zext i32 %or426 to i64
  %bf.load427 = load i64, ptr %arrayidx422, align 4
  %bf.value428 = and i64 %191, 65535
  %bf.clear429 = and i64 %bf.load427, -65536
  %bf.set430 = or i64 %bf.clear429, %bf.value428
  store i64 %bf.set430, ptr %arrayidx422, align 4
  br label %sw.epilog462

sw.bb432:                                         ; preds = %do.body311
  %192 = load ptr, ptr %def, align 8
  %args_ct433 = getelementptr inbounds %struct.TCGOpDef, ptr %192, i32 0, i32 6
  %193 = load ptr, ptr %args_ct433, align 8
  %194 = load i32, ptr %i, align 4
  %idxprom434 = sext i32 %194 to i64
  %arrayidx435 = getelementptr %struct.TCGArgConstraint, ptr %193, i64 %idxprom434
  %bf.load436 = load i64, ptr %arrayidx435, align 4
  %bf.clear437 = and i64 %bf.load436, 65535
  %bf.cast438 = trunc i64 %bf.clear437 to i32
  %or439 = or i32 %bf.cast438, 2048
  %195 = zext i32 %or439 to i64
  %bf.load440 = load i64, ptr %arrayidx435, align 4
  %bf.value441 = and i64 %195, 65535
  %bf.clear442 = and i64 %bf.load440, -65536
  %bf.set443 = or i64 %bf.clear442, %bf.value441
  store i64 %bf.set443, ptr %arrayidx435, align 4
  br label %sw.epilog462

sw.bb445:                                         ; preds = %do.body311
  %196 = load ptr, ptr %def, align 8
  %args_ct446 = getelementptr inbounds %struct.TCGOpDef, ptr %196, i32 0, i32 6
  %197 = load ptr, ptr %args_ct446, align 8
  %198 = load i32, ptr %i, align 4
  %idxprom447 = sext i32 %198 to i64
  %arrayidx448 = getelementptr %struct.TCGArgConstraint, ptr %197, i64 %idxprom447
  %bf.load449 = load i64, ptr %arrayidx448, align 4
  %bf.clear450 = and i64 %bf.load449, 65535
  %bf.cast451 = trunc i64 %bf.clear450 to i32
  %or452 = or i32 %bf.cast451, 512
  %199 = zext i32 %or452 to i64
  %bf.load453 = load i64, ptr %arrayidx448, align 4
  %bf.value454 = and i64 %199, 65535
  %bf.clear455 = and i64 %bf.load453, -65536
  %bf.set456 = or i64 %bf.clear455, %bf.value454
  store i64 %bf.set456, ptr %arrayidx448, align 4
  br label %sw.epilog462

sw.default:                                       ; preds = %do.body311
  br label %sw.bb458

sw.bb458:                                         ; preds = %sw.default, %do.body311, %do.body311, %do.body311, %do.body311, %do.body311, %do.body311, %do.body311, %do.body311, %do.body311, %do.body311
  br label %sw.bb459

sw.bb459:                                         ; preds = %sw.bb458, %do.body311, %do.body311, %do.body311
  br label %do.body460

do.body460:                                       ; preds = %sw.bb459
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 3038, ptr noundef @__func__.process_op_defs, ptr noundef null) #15
  unreachable

do.end461:                                        ; No predecessors!
  br label %sw.epilog462

sw.epilog462:                                     ; preds = %do.end461, %sw.bb445, %sw.bb432, %sw.bb419, %sw.bb406, %sw.bb392, %sw.bb379, %sw.bb373, %sw.bb367, %sw.bb361, %sw.bb355, %sw.bb349, %sw.bb343, %sw.bb337, %sw.bb331, %sw.bb325, %sw.bb313
  br label %do.cond

do.cond:                                          ; preds = %sw.epilog462
  %200 = load ptr, ptr %ct_str, align 8
  %incdec.ptr463 = getelementptr i8, ptr %200, i32 1
  store ptr %incdec.ptr463, ptr %ct_str, align 8
  %201 = load i8, ptr %incdec.ptr463, align 1
  %conv464 = sext i8 %201 to i32
  %cmp465 = icmp ne i32 %conv464, 0
  br i1 %cmp465, label %do.body311, label %do.end467, !llvm.loop !82

do.end467:                                        ; preds = %do.cond
  br label %for.inc

for.inc:                                          ; preds = %do.end467, %do.end310, %do.end213, %do.end109
  %202 = load i32, ptr %i, align 4
  %inc = add i32 %202, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond14, !llvm.loop !83

for.end:                                          ; preds = %for.cond14
  br label %do.body468

do.body468:                                       ; preds = %for.end
  %203 = load i32, ptr %i, align 4
  %cmp469 = icmp eq i32 %203, 16
  br i1 %cmp469, label %if.end477, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body468
  %204 = load ptr, ptr %tdefs, align 8
  %args_ct_str471 = getelementptr inbounds %struct.TCGTargetOpDef, ptr %204, i32 0, i32 1
  %205 = load i32, ptr %i, align 4
  %idxprom472 = sext i32 %205 to i64
  %arrayidx473 = getelementptr [16 x ptr], ptr %args_ct_str471, i64 0, i64 %idxprom472
  %206 = load ptr, ptr %arrayidx473, align 8
  %cmp474 = icmp eq ptr %206, null
  br i1 %cmp474, label %if.end477, label %if.then476

if.then476:                                       ; preds = %lor.lhs.false
  unreachable

if.end477:                                        ; preds = %lor.lhs.false, %do.body468
  br label %do.end479

do.end479:                                        ; preds = %if.end477
  %207 = load i8, ptr %saw_alias_pair, align 1
  %tobool480 = trunc i8 %207 to i1
  br i1 %tobool480, label %if.then481, label %if.end735

if.then481:                                       ; preds = %do.end479
  %208 = load ptr, ptr %def, align 8
  %nb_oargs482 = getelementptr inbounds %struct.TCGOpDef, ptr %208, i32 0, i32 1
  %209 = load i8, ptr %nb_oargs482, align 8
  %conv483 = zext i8 %209 to i32
  store i32 %conv483, ptr %i, align 4
  br label %for.cond484

for.cond484:                                      ; preds = %for.inc732, %if.then481
  %210 = load i32, ptr %i, align 4
  %211 = load i32, ptr %nb_args, align 4
  %cmp485 = icmp slt i32 %210, %211
  br i1 %cmp485, label %for.body487, label %for.end734

for.body487:                                      ; preds = %for.cond484
  %212 = load ptr, ptr %def, align 8
  %args_ct488 = getelementptr inbounds %struct.TCGOpDef, ptr %212, i32 0, i32 6
  %213 = load ptr, ptr %args_ct488, align 8
  %214 = load i32, ptr %i, align 4
  %idxprom489 = sext i32 %214 to i64
  %arrayidx490 = getelementptr %struct.TCGArgConstraint, ptr %213, i64 %idxprom489
  %bf.load491 = load i64, ptr %arrayidx490, align 4
  %bf.lshr492 = lshr i64 %bf.load491, 31
  %bf.clear493 = and i64 %bf.lshr492, 1
  %bf.cast494 = trunc i64 %bf.clear493 to i1
  br i1 %bf.cast494, label %if.end496, label %if.then495

if.then495:                                       ; preds = %for.body487
  br label %for.inc732

if.end496:                                        ; preds = %for.body487
  %215 = load ptr, ptr %def, align 8
  %args_ct497 = getelementptr inbounds %struct.TCGOpDef, ptr %215, i32 0, i32 6
  %216 = load ptr, ptr %args_ct497, align 8
  %217 = load i32, ptr %i, align 4
  %idxprom498 = sext i32 %217 to i64
  %arrayidx499 = getelementptr %struct.TCGArgConstraint, ptr %216, i64 %idxprom498
  %bf.load500 = load i64, ptr %arrayidx499, align 4
  %bf.lshr501 = lshr i64 %bf.load500, 28
  %bf.clear502 = and i64 %bf.lshr501, 3
  %bf.cast503 = trunc i64 %bf.clear502 to i32
  switch i32 %bf.cast503, label %sw.default727 [
    i32 0, label %sw.bb504
    i32 1, label %sw.bb505
    i32 2, label %sw.bb605
  ]

sw.bb504:                                         ; preds = %if.end496
  br label %sw.epilog731

sw.bb505:                                         ; preds = %if.end496
  %218 = load ptr, ptr %def, align 8
  %args_ct506 = getelementptr inbounds %struct.TCGOpDef, ptr %218, i32 0, i32 6
  %219 = load ptr, ptr %args_ct506, align 8
  %220 = load i32, ptr %i, align 4
  %idxprom507 = sext i32 %220 to i64
  %arrayidx508 = getelementptr %struct.TCGArgConstraint, ptr %219, i64 %idxprom507
  %bf.load509 = load i64, ptr %arrayidx508, align 4
  %bf.lshr510 = lshr i64 %bf.load509, 16
  %bf.clear511 = and i64 %bf.lshr510, 15
  %bf.cast512 = trunc i64 %bf.clear511 to i32
  store i32 %bf.cast512, ptr %o, align 4
  %221 = load ptr, ptr %def, align 8
  %args_ct513 = getelementptr inbounds %struct.TCGOpDef, ptr %221, i32 0, i32 6
  %222 = load ptr, ptr %args_ct513, align 8
  %223 = load i32, ptr %o, align 4
  %idxprom514 = sext i32 %223 to i64
  %arrayidx515 = getelementptr %struct.TCGArgConstraint, ptr %222, i64 %idxprom514
  %bf.load516 = load i64, ptr %arrayidx515, align 4
  %bf.lshr517 = lshr i64 %bf.load516, 24
  %bf.clear518 = and i64 %bf.lshr517, 15
  %bf.cast519 = trunc i64 %bf.clear518 to i32
  store i32 %bf.cast519, ptr %o2, align 4
  br label %do.body520

do.body520:                                       ; preds = %sw.bb505
  %224 = load ptr, ptr %def, align 8
  %args_ct521 = getelementptr inbounds %struct.TCGOpDef, ptr %224, i32 0, i32 6
  %225 = load ptr, ptr %args_ct521, align 8
  %226 = load i32, ptr %o, align 4
  %idxprom522 = sext i32 %226 to i64
  %arrayidx523 = getelementptr %struct.TCGArgConstraint, ptr %225, i64 %idxprom522
  %bf.load524 = load i64, ptr %arrayidx523, align 4
  %bf.lshr525 = lshr i64 %bf.load524, 28
  %bf.clear526 = and i64 %bf.lshr525, 3
  %bf.cast527 = trunc i64 %bf.clear526 to i32
  %cmp528 = icmp eq i32 %bf.cast527, 1
  br i1 %cmp528, label %if.end531, label %if.then530

if.then530:                                       ; preds = %do.body520
  unreachable

if.end531:                                        ; preds = %do.body520
  br label %do.end533

do.end533:                                        ; preds = %if.end531
  br label %do.body534

do.body534:                                       ; preds = %do.end533
  %227 = load ptr, ptr %def, align 8
  %args_ct535 = getelementptr inbounds %struct.TCGOpDef, ptr %227, i32 0, i32 6
  %228 = load ptr, ptr %args_ct535, align 8
  %229 = load i32, ptr %o2, align 4
  %idxprom536 = sext i32 %229 to i64
  %arrayidx537 = getelementptr %struct.TCGArgConstraint, ptr %228, i64 %idxprom536
  %bf.load538 = load i64, ptr %arrayidx537, align 4
  %bf.lshr539 = lshr i64 %bf.load538, 28
  %bf.clear540 = and i64 %bf.lshr539, 3
  %bf.cast541 = trunc i64 %bf.clear540 to i32
  %cmp542 = icmp eq i32 %bf.cast541, 2
  br i1 %cmp542, label %if.end545, label %if.then544

if.then544:                                       ; preds = %do.body534
  unreachable

if.end545:                                        ; preds = %do.body534
  br label %do.end547

do.end547:                                        ; preds = %if.end545
  %230 = load ptr, ptr %def, align 8
  %args_ct548 = getelementptr inbounds %struct.TCGOpDef, ptr %230, i32 0, i32 6
  %231 = load ptr, ptr %args_ct548, align 8
  %232 = load i32, ptr %o2, align 4
  %idxprom549 = sext i32 %232 to i64
  %arrayidx550 = getelementptr %struct.TCGArgConstraint, ptr %231, i64 %idxprom549
  %bf.load551 = load i64, ptr %arrayidx550, align 4
  %bf.lshr552 = lshr i64 %bf.load551, 30
  %bf.clear553 = and i64 %bf.lshr552, 1
  %bf.cast554 = trunc i64 %bf.clear553 to i1
  br i1 %bf.cast554, label %if.then555, label %if.else

if.then555:                                       ; preds = %do.end547
  %233 = load ptr, ptr %def, align 8
  %args_ct556 = getelementptr inbounds %struct.TCGOpDef, ptr %233, i32 0, i32 6
  %234 = load ptr, ptr %args_ct556, align 8
  %235 = load i32, ptr %o2, align 4
  %idxprom557 = sext i32 %235 to i64
  %arrayidx558 = getelementptr %struct.TCGArgConstraint, ptr %234, i64 %idxprom557
  %bf.load559 = load i64, ptr %arrayidx558, align 4
  %bf.lshr560 = lshr i64 %bf.load559, 16
  %bf.clear561 = and i64 %bf.lshr560, 15
  %bf.cast562 = trunc i64 %bf.clear561 to i32
  store i32 %bf.cast562, ptr %i2, align 4
  br label %do.body563

do.body563:                                       ; preds = %if.then555
  %236 = load ptr, ptr %def, align 8
  %args_ct564 = getelementptr inbounds %struct.TCGOpDef, ptr %236, i32 0, i32 6
  %237 = load ptr, ptr %args_ct564, align 8
  %238 = load i32, ptr %i2, align 4
  %idxprom565 = sext i32 %238 to i64
  %arrayidx566 = getelementptr %struct.TCGArgConstraint, ptr %237, i64 %idxprom565
  %bf.load567 = load i64, ptr %arrayidx566, align 4
  %bf.lshr568 = lshr i64 %bf.load567, 28
  %bf.clear569 = and i64 %bf.lshr568, 3
  %bf.cast570 = trunc i64 %bf.clear569 to i32
  %cmp571 = icmp eq i32 %bf.cast570, 2
  br i1 %cmp571, label %if.end574, label %if.then573

if.then573:                                       ; preds = %do.body563
  unreachable

if.end574:                                        ; preds = %do.body563
  br label %do.end576

do.end576:                                        ; preds = %if.end574
  %239 = load i32, ptr %i, align 4
  %240 = load ptr, ptr %def, align 8
  %args_ct577 = getelementptr inbounds %struct.TCGOpDef, ptr %240, i32 0, i32 6
  %241 = load ptr, ptr %args_ct577, align 8
  %242 = load i32, ptr %i2, align 4
  %idxprom578 = sext i32 %242 to i64
  %arrayidx579 = getelementptr %struct.TCGArgConstraint, ptr %241, i64 %idxprom578
  %243 = zext i32 %239 to i64
  %bf.load580 = load i64, ptr %arrayidx579, align 4
  %bf.value581 = and i64 %243, 15
  %bf.shl582 = shl i64 %bf.value581, 24
  %bf.clear583 = and i64 %bf.load580, -251658241
  %bf.set584 = or i64 %bf.clear583, %bf.shl582
  store i64 %bf.set584, ptr %arrayidx579, align 4
  %244 = load i32, ptr %i2, align 4
  %245 = load ptr, ptr %def, align 8
  %args_ct586 = getelementptr inbounds %struct.TCGOpDef, ptr %245, i32 0, i32 6
  %246 = load ptr, ptr %args_ct586, align 8
  %247 = load i32, ptr %i, align 4
  %idxprom587 = sext i32 %247 to i64
  %arrayidx588 = getelementptr %struct.TCGArgConstraint, ptr %246, i64 %idxprom587
  %248 = zext i32 %244 to i64
  %bf.load589 = load i64, ptr %arrayidx588, align 4
  %bf.value590 = and i64 %248, 15
  %bf.shl591 = shl i64 %bf.value590, 24
  %bf.clear592 = and i64 %bf.load589, -251658241
  %bf.set593 = or i64 %bf.clear592, %bf.shl591
  store i64 %bf.set593, ptr %arrayidx588, align 4
  br label %if.end604

if.else:                                          ; preds = %do.end547
  %249 = load i32, ptr %i, align 4
  %250 = load ptr, ptr %def, align 8
  %args_ct595 = getelementptr inbounds %struct.TCGOpDef, ptr %250, i32 0, i32 6
  %251 = load ptr, ptr %args_ct595, align 8
  %252 = load i32, ptr %i, align 4
  %idxprom596 = sext i32 %252 to i64
  %arrayidx597 = getelementptr %struct.TCGArgConstraint, ptr %251, i64 %idxprom596
  %253 = zext i32 %249 to i64
  %bf.load598 = load i64, ptr %arrayidx597, align 4
  %bf.value599 = and i64 %253, 15
  %bf.shl600 = shl i64 %bf.value599, 24
  %bf.clear601 = and i64 %bf.load598, -251658241
  %bf.set602 = or i64 %bf.clear601, %bf.shl600
  store i64 %bf.set602, ptr %arrayidx597, align 4
  br label %if.end604

if.end604:                                        ; preds = %if.else, %do.end576
  br label %sw.epilog731

sw.bb605:                                         ; preds = %if.end496
  %254 = load ptr, ptr %def, align 8
  %args_ct606 = getelementptr inbounds %struct.TCGOpDef, ptr %254, i32 0, i32 6
  %255 = load ptr, ptr %args_ct606, align 8
  %256 = load i32, ptr %i, align 4
  %idxprom607 = sext i32 %256 to i64
  %arrayidx608 = getelementptr %struct.TCGArgConstraint, ptr %255, i64 %idxprom607
  %bf.load609 = load i64, ptr %arrayidx608, align 4
  %bf.lshr610 = lshr i64 %bf.load609, 16
  %bf.clear611 = and i64 %bf.lshr610, 15
  %bf.cast612 = trunc i64 %bf.clear611 to i32
  store i32 %bf.cast612, ptr %o, align 4
  %257 = load ptr, ptr %def, align 8
  %args_ct613 = getelementptr inbounds %struct.TCGOpDef, ptr %257, i32 0, i32 6
  %258 = load ptr, ptr %args_ct613, align 8
  %259 = load i32, ptr %o, align 4
  %idxprom614 = sext i32 %259 to i64
  %arrayidx615 = getelementptr %struct.TCGArgConstraint, ptr %258, i64 %idxprom614
  %bf.load616 = load i64, ptr %arrayidx615, align 4
  %bf.lshr617 = lshr i64 %bf.load616, 24
  %bf.clear618 = and i64 %bf.lshr617, 15
  %bf.cast619 = trunc i64 %bf.clear618 to i32
  store i32 %bf.cast619, ptr %o2, align 4
  br label %do.body620

do.body620:                                       ; preds = %sw.bb605
  %260 = load ptr, ptr %def, align 8
  %args_ct621 = getelementptr inbounds %struct.TCGOpDef, ptr %260, i32 0, i32 6
  %261 = load ptr, ptr %args_ct621, align 8
  %262 = load i32, ptr %o, align 4
  %idxprom622 = sext i32 %262 to i64
  %arrayidx623 = getelementptr %struct.TCGArgConstraint, ptr %261, i64 %idxprom622
  %bf.load624 = load i64, ptr %arrayidx623, align 4
  %bf.lshr625 = lshr i64 %bf.load624, 28
  %bf.clear626 = and i64 %bf.lshr625, 3
  %bf.cast627 = trunc i64 %bf.clear626 to i32
  %cmp628 = icmp eq i32 %bf.cast627, 2
  br i1 %cmp628, label %if.end631, label %if.then630

if.then630:                                       ; preds = %do.body620
  unreachable

if.end631:                                        ; preds = %do.body620
  br label %do.end633

do.end633:                                        ; preds = %if.end631
  br label %do.body634

do.body634:                                       ; preds = %do.end633
  %263 = load ptr, ptr %def, align 8
  %args_ct635 = getelementptr inbounds %struct.TCGOpDef, ptr %263, i32 0, i32 6
  %264 = load ptr, ptr %args_ct635, align 8
  %265 = load i32, ptr %o2, align 4
  %idxprom636 = sext i32 %265 to i64
  %arrayidx637 = getelementptr %struct.TCGArgConstraint, ptr %264, i64 %idxprom636
  %bf.load638 = load i64, ptr %arrayidx637, align 4
  %bf.lshr639 = lshr i64 %bf.load638, 28
  %bf.clear640 = and i64 %bf.lshr639, 3
  %bf.cast641 = trunc i64 %bf.clear640 to i32
  %cmp642 = icmp eq i32 %bf.cast641, 1
  br i1 %cmp642, label %if.end645, label %if.then644

if.then644:                                       ; preds = %do.body634
  unreachable

if.end645:                                        ; preds = %do.body634
  br label %do.end647

do.end647:                                        ; preds = %if.end645
  %266 = load ptr, ptr %def, align 8
  %args_ct648 = getelementptr inbounds %struct.TCGOpDef, ptr %266, i32 0, i32 6
  %267 = load ptr, ptr %args_ct648, align 8
  %268 = load i32, ptr %o2, align 4
  %idxprom649 = sext i32 %268 to i64
  %arrayidx650 = getelementptr %struct.TCGArgConstraint, ptr %267, i64 %idxprom649
  %bf.load651 = load i64, ptr %arrayidx650, align 4
  %bf.lshr652 = lshr i64 %bf.load651, 30
  %bf.clear653 = and i64 %bf.lshr652, 1
  %bf.cast654 = trunc i64 %bf.clear653 to i1
  br i1 %bf.cast654, label %if.then655, label %if.else695

if.then655:                                       ; preds = %do.end647
  %269 = load ptr, ptr %def, align 8
  %args_ct656 = getelementptr inbounds %struct.TCGOpDef, ptr %269, i32 0, i32 6
  %270 = load ptr, ptr %args_ct656, align 8
  %271 = load i32, ptr %o2, align 4
  %idxprom657 = sext i32 %271 to i64
  %arrayidx658 = getelementptr %struct.TCGArgConstraint, ptr %270, i64 %idxprom657
  %bf.load659 = load i64, ptr %arrayidx658, align 4
  %bf.lshr660 = lshr i64 %bf.load659, 16
  %bf.clear661 = and i64 %bf.lshr660, 15
  %bf.cast662 = trunc i64 %bf.clear661 to i32
  store i32 %bf.cast662, ptr %i2, align 4
  br label %do.body663

do.body663:                                       ; preds = %if.then655
  %272 = load ptr, ptr %def, align 8
  %args_ct664 = getelementptr inbounds %struct.TCGOpDef, ptr %272, i32 0, i32 6
  %273 = load ptr, ptr %args_ct664, align 8
  %274 = load i32, ptr %i2, align 4
  %idxprom665 = sext i32 %274 to i64
  %arrayidx666 = getelementptr %struct.TCGArgConstraint, ptr %273, i64 %idxprom665
  %bf.load667 = load i64, ptr %arrayidx666, align 4
  %bf.lshr668 = lshr i64 %bf.load667, 28
  %bf.clear669 = and i64 %bf.lshr668, 3
  %bf.cast670 = trunc i64 %bf.clear669 to i32
  %cmp671 = icmp eq i32 %bf.cast670, 1
  br i1 %cmp671, label %if.end674, label %if.then673

if.then673:                                       ; preds = %do.body663
  unreachable

if.end674:                                        ; preds = %do.body663
  br label %do.end676

do.end676:                                        ; preds = %if.end674
  %275 = load i32, ptr %i, align 4
  %276 = load ptr, ptr %def, align 8
  %args_ct677 = getelementptr inbounds %struct.TCGOpDef, ptr %276, i32 0, i32 6
  %277 = load ptr, ptr %args_ct677, align 8
  %278 = load i32, ptr %i2, align 4
  %idxprom678 = sext i32 %278 to i64
  %arrayidx679 = getelementptr %struct.TCGArgConstraint, ptr %277, i64 %idxprom678
  %279 = zext i32 %275 to i64
  %bf.load680 = load i64, ptr %arrayidx679, align 4
  %bf.value681 = and i64 %279, 15
  %bf.shl682 = shl i64 %bf.value681, 24
  %bf.clear683 = and i64 %bf.load680, -251658241
  %bf.set684 = or i64 %bf.clear683, %bf.shl682
  store i64 %bf.set684, ptr %arrayidx679, align 4
  %280 = load i32, ptr %i2, align 4
  %281 = load ptr, ptr %def, align 8
  %args_ct686 = getelementptr inbounds %struct.TCGOpDef, ptr %281, i32 0, i32 6
  %282 = load ptr, ptr %args_ct686, align 8
  %283 = load i32, ptr %i, align 4
  %idxprom687 = sext i32 %283 to i64
  %arrayidx688 = getelementptr %struct.TCGArgConstraint, ptr %282, i64 %idxprom687
  %284 = zext i32 %280 to i64
  %bf.load689 = load i64, ptr %arrayidx688, align 4
  %bf.value690 = and i64 %284, 15
  %bf.shl691 = shl i64 %bf.value690, 24
  %bf.clear692 = and i64 %bf.load689, -251658241
  %bf.set693 = or i64 %bf.clear692, %bf.shl691
  store i64 %bf.set693, ptr %arrayidx688, align 4
  br label %if.end726

if.else695:                                       ; preds = %do.end647
  %285 = load ptr, ptr %def, align 8
  %args_ct696 = getelementptr inbounds %struct.TCGOpDef, ptr %285, i32 0, i32 6
  %286 = load ptr, ptr %args_ct696, align 8
  %287 = load i32, ptr %i, align 4
  %idxprom697 = sext i32 %287 to i64
  %arrayidx698 = getelementptr %struct.TCGArgConstraint, ptr %286, i64 %idxprom697
  %bf.load699 = load i64, ptr %arrayidx698, align 4
  %bf.clear700 = and i64 %bf.load699, -805306369
  %bf.set701 = or i64 %bf.clear700, 805306368
  store i64 %bf.set701, ptr %arrayidx698, align 4
  %288 = load ptr, ptr %def, align 8
  %args_ct702 = getelementptr inbounds %struct.TCGOpDef, ptr %288, i32 0, i32 6
  %289 = load ptr, ptr %args_ct702, align 8
  %290 = load i32, ptr %o2, align 4
  %idxprom703 = sext i32 %290 to i64
  %arrayidx704 = getelementptr %struct.TCGArgConstraint, ptr %289, i64 %idxprom703
  %bf.load705 = load i64, ptr %arrayidx704, align 4
  %bf.clear706 = and i64 %bf.load705, -805306369
  %bf.set707 = or i64 %bf.clear706, 805306368
  store i64 %bf.set707, ptr %arrayidx704, align 4
  %291 = load i32, ptr %o2, align 4
  %292 = load ptr, ptr %def, align 8
  %args_ct708 = getelementptr inbounds %struct.TCGOpDef, ptr %292, i32 0, i32 6
  %293 = load ptr, ptr %args_ct708, align 8
  %294 = load i32, ptr %i, align 4
  %idxprom709 = sext i32 %294 to i64
  %arrayidx710 = getelementptr %struct.TCGArgConstraint, ptr %293, i64 %idxprom709
  %295 = zext i32 %291 to i64
  %bf.load711 = load i64, ptr %arrayidx710, align 4
  %bf.value712 = and i64 %295, 15
  %bf.shl713 = shl i64 %bf.value712, 24
  %bf.clear714 = and i64 %bf.load711, -251658241
  %bf.set715 = or i64 %bf.clear714, %bf.shl713
  store i64 %bf.set715, ptr %arrayidx710, align 4
  %296 = load i32, ptr %i, align 4
  %297 = load ptr, ptr %def, align 8
  %args_ct717 = getelementptr inbounds %struct.TCGOpDef, ptr %297, i32 0, i32 6
  %298 = load ptr, ptr %args_ct717, align 8
  %299 = load i32, ptr %o2, align 4
  %idxprom718 = sext i32 %299 to i64
  %arrayidx719 = getelementptr %struct.TCGArgConstraint, ptr %298, i64 %idxprom718
  %300 = zext i32 %296 to i64
  %bf.load720 = load i64, ptr %arrayidx719, align 4
  %bf.value721 = and i64 %300, 15
  %bf.shl722 = shl i64 %bf.value721, 24
  %bf.clear723 = and i64 %bf.load720, -251658241
  %bf.set724 = or i64 %bf.clear723, %bf.shl722
  store i64 %bf.set724, ptr %arrayidx719, align 4
  br label %if.end726

if.end726:                                        ; preds = %if.else695, %do.end676
  br label %sw.epilog731

sw.default727:                                    ; preds = %if.end496
  br label %do.body728

do.body728:                                       ; preds = %sw.default727
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 3114, ptr noundef @__func__.process_op_defs, ptr noundef null) #15
  unreachable

do.end730:                                        ; No predecessors!
  br label %sw.epilog731

sw.epilog731:                                     ; preds = %do.end730, %if.end726, %if.end604, %sw.bb504
  br label %for.inc732

for.inc732:                                       ; preds = %sw.epilog731, %if.then495
  %301 = load i32, ptr %i, align 4
  %inc733 = add i32 %301, 1
  store i32 %inc733, ptr %i, align 4
  br label %for.cond484, !llvm.loop !84

for.end734:                                       ; preds = %for.cond484
  br label %if.end735

if.end735:                                        ; preds = %for.end734, %do.end479
  %302 = load ptr, ptr %def, align 8
  %303 = load ptr, ptr %def, align 8
  %nb_oargs736 = getelementptr inbounds %struct.TCGOpDef, ptr %303, i32 0, i32 1
  %304 = load i8, ptr %nb_oargs736, align 8
  %conv737 = zext i8 %304 to i32
  call void @sort_constraints(ptr noundef %302, i32 noundef 0, i32 noundef %conv737)
  %305 = load ptr, ptr %def, align 8
  %306 = load ptr, ptr %def, align 8
  %nb_oargs738 = getelementptr inbounds %struct.TCGOpDef, ptr %306, i32 0, i32 1
  %307 = load i8, ptr %nb_oargs738, align 8
  %conv739 = zext i8 %307 to i32
  %308 = load ptr, ptr %def, align 8
  %nb_iargs740 = getelementptr inbounds %struct.TCGOpDef, ptr %308, i32 0, i32 2
  %309 = load i8, ptr %nb_iargs740, align 1
  %conv741 = zext i8 %309 to i32
  call void @sort_constraints(ptr noundef %305, i32 noundef %conv739, i32 noundef %conv741)
  br label %for.inc742

for.inc742:                                       ; preds = %if.end735, %if.then5, %if.then
  %310 = load i32, ptr %op, align 4
  %inc743 = add i32 %310, 1
  store i32 %inc743, ptr %op, align 4
  br label %for.cond, !llvm.loop !85

for.end744:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @alloc_tcg_plugin_context(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %call = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 72) #17
  %0 = load ptr, ptr %s.addr, align 8
  %plugin_tb = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 33
  store ptr %call, ptr %plugin_tb, align 8
  %call1 = call ptr @g_ptr_array_new_with_free_func(ptr noundef @qemu_plugin_insn_cleanup_fn)
  %1 = load ptr, ptr %s.addr, align 8
  %plugin_tb2 = getelementptr inbounds %struct.TCGContext, ptr %1, i32 0, i32 33
  %2 = load ptr, ptr %plugin_tb2, align 8
  %insns = getelementptr inbounds %struct.qemu_plugin_tb, ptr %2, i32 0, i32 0
  store ptr %call1, ptr %insns, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_target_call_oarg_reg(i32 noundef %kind, i32 noundef %slot) #0 {
entry:
  %retval = alloca i32, align 4
  %kind.addr = alloca i32, align 4
  %slot.addr = alloca i32, align 4
  store i32 %kind, ptr %kind.addr, align 4
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load i32, ptr %kind.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %1 = load i32, ptr %slot.addr, align 4
  %cmp = icmp sge i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %do.body
  %2 = load i32, ptr %slot.addr, align 4
  %cmp1 = icmp sle i32 %2, 1
  br i1 %cmp1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %do.body
  unreachable

if.end:                                           ; preds = %land.lhs.true
  br label %do.end

do.end:                                           ; preds = %if.end
  %3 = load i32, ptr %slot.addr, align 4
  %tobool = icmp ne i32 %3, 0
  %cond = select i1 %tobool, i32 2, i32 0
  store i32 %cond, ptr %retval, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body2

do.body2:                                         ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 126, ptr noundef @__func__.tcg_target_call_oarg_reg, ptr noundef null) #15
  unreachable

do.end3:                                          ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end3, %do.end
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @layout_arg_1(ptr noundef %cum, ptr noundef %info, i32 noundef %kind) #0 {
entry:
  %cum.addr = alloca ptr, align 8
  %info.addr = alloca ptr, align 8
  %kind.addr = alloca i32, align 4
  %loc = alloca ptr, align 8
  %.compoundliteral = alloca %struct.TCGCallArgumentLoc, align 4
  store ptr %cum, ptr %cum.addr, align 8
  store ptr %info, ptr %info.addr, align 8
  store i32 %kind, ptr %kind.addr, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %in = getelementptr inbounds %struct.TCGHelperInfo, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %cum.addr, align 8
  %info_in_idx = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %info_in_idx, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %loc, align 8
  %3 = load ptr, ptr %loc, align 8
  %4 = load i32, ptr %kind.addr, align 4
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.value = and i32 %4, 255
  %bf.clear = and i32 %bf.load, -256
  %bf.set = or i32 %bf.clear, %bf.value
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %5 = load ptr, ptr %cum.addr, align 8
  %arg_slot = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %5, i32 0, i32 2
  %6 = load i32, ptr %arg_slot, align 4
  %bf.load1 = load i32, ptr %.compoundliteral, align 4
  %bf.value2 = and i32 %6, 255
  %bf.shl = shl i32 %bf.value2, 8
  %bf.clear3 = and i32 %bf.load1, -65281
  %bf.set4 = or i32 %bf.clear3, %bf.shl
  store i32 %bf.set4, ptr %.compoundliteral, align 4
  %bf.load5 = load i32, ptr %.compoundliteral, align 4
  %bf.clear6 = and i32 %bf.load5, -16711681
  %bf.set7 = or i32 %bf.clear6, 0
  store i32 %bf.set7, ptr %.compoundliteral, align 4
  %7 = load ptr, ptr %cum.addr, align 8
  %arg_idx = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %7, i32 0, i32 0
  %8 = load i32, ptr %arg_idx, align 4
  %bf.load8 = load i32, ptr %.compoundliteral, align 4
  %bf.value9 = and i32 %8, 15
  %bf.shl10 = shl i32 %bf.value9, 24
  %bf.clear11 = and i32 %bf.load8, -251658241
  %bf.set12 = or i32 %bf.clear11, %bf.shl10
  store i32 %bf.set12, ptr %.compoundliteral, align 4
  %bf.load13 = load i32, ptr %.compoundliteral, align 4
  %bf.clear14 = and i32 %bf.load13, -805306369
  %bf.set15 = or i32 %bf.clear14, 0
  store i32 %bf.set15, ptr %.compoundliteral, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %3, ptr align 4 %.compoundliteral, i64 4, i1 false)
  %9 = load ptr, ptr %cum.addr, align 8
  %info_in_idx16 = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %9, i32 0, i32 1
  %10 = load i32, ptr %info_in_idx16, align 4
  %inc = add i32 %10, 1
  store i32 %inc, ptr %info_in_idx16, align 4
  %11 = load ptr, ptr %cum.addr, align 8
  %arg_slot17 = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %11, i32 0, i32 2
  %12 = load i32, ptr %arg_slot17, align 4
  %inc18 = add i32 %12, 1
  store i32 %inc18, ptr %arg_slot17, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @layout_arg_normal_n(ptr noundef %cum, ptr noundef %info, i32 noundef %n) #0 {
entry:
  %cum.addr = alloca ptr, align 8
  %info.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %loc = alloca ptr, align 8
  %i = alloca i32, align 4
  %.compoundliteral = alloca %struct.TCGCallArgumentLoc, align 4
  store ptr %cum, ptr %cum.addr, align 8
  store ptr %info, ptr %info.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  %0 = load ptr, ptr %info.addr, align 8
  %in = getelementptr inbounds %struct.TCGHelperInfo, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %cum.addr, align 8
  %info_in_idx = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %1, i32 0, i32 1
  %2 = load i32, ptr %info_in_idx, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %loc, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %n.addr, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %loc, align 8
  %6 = load i32, ptr %i, align 4
  %idxprom1 = sext i32 %6 to i64
  %arrayidx2 = getelementptr %struct.TCGCallArgumentLoc, ptr %5, i64 %idxprom1
  %bf.load = load i32, ptr %.compoundliteral, align 4
  %bf.clear = and i32 %bf.load, -256
  %bf.set = or i32 %bf.clear, 0
  store i32 %bf.set, ptr %.compoundliteral, align 4
  %7 = load ptr, ptr %cum.addr, align 8
  %arg_slot = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %7, i32 0, i32 2
  %8 = load i32, ptr %arg_slot, align 4
  %9 = load i32, ptr %i, align 4
  %add = add i32 %8, %9
  %bf.load3 = load i32, ptr %.compoundliteral, align 4
  %bf.value = and i32 %add, 255
  %bf.shl = shl i32 %bf.value, 8
  %bf.clear4 = and i32 %bf.load3, -65281
  %bf.set5 = or i32 %bf.clear4, %bf.shl
  store i32 %bf.set5, ptr %.compoundliteral, align 4
  %bf.load6 = load i32, ptr %.compoundliteral, align 4
  %bf.clear7 = and i32 %bf.load6, -16711681
  %bf.set8 = or i32 %bf.clear7, 0
  store i32 %bf.set8, ptr %.compoundliteral, align 4
  %10 = load ptr, ptr %cum.addr, align 8
  %arg_idx = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %10, i32 0, i32 0
  %11 = load i32, ptr %arg_idx, align 4
  %bf.load9 = load i32, ptr %.compoundliteral, align 4
  %bf.value10 = and i32 %11, 15
  %bf.shl11 = shl i32 %bf.value10, 24
  %bf.clear12 = and i32 %bf.load9, -251658241
  %bf.set13 = or i32 %bf.clear12, %bf.shl11
  store i32 %bf.set13, ptr %.compoundliteral, align 4
  %12 = load i32, ptr %i, align 4
  %bf.load14 = load i32, ptr %.compoundliteral, align 4
  %bf.value15 = and i32 %12, 3
  %bf.shl16 = shl i32 %bf.value15, 28
  %bf.clear17 = and i32 %bf.load14, -805306369
  %bf.set18 = or i32 %bf.clear17, %bf.shl16
  store i32 %bf.set18, ptr %.compoundliteral, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %arrayidx2, ptr align 4 %.compoundliteral, i64 4, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !86

for.end:                                          ; preds = %for.cond
  %14 = load i32, ptr %n.addr, align 4
  %15 = load ptr, ptr %cum.addr, align 8
  %info_in_idx19 = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %15, i32 0, i32 1
  %16 = load i32, ptr %info_in_idx19, align 4
  %add20 = add i32 %16, %14
  store i32 %add20, ptr %info_in_idx19, align 4
  %17 = load i32, ptr %n.addr, align 4
  %18 = load ptr, ptr %cum.addr, align 8
  %arg_slot21 = getelementptr inbounds %struct.TCGCumulativeArgs, ptr %18, i32 0, i32 2
  %19 = load i32, ptr %arg_slot21, align 4
  %add22 = add i32 %19, %17
  store i32 %add22, ptr %arg_slot21, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_target_op_def(i32 noundef %op) #0 {
entry:
  %retval = alloca i32, align 4
  %op.addr = alloca i32, align 4
  store i32 %op, ptr %op.addr, align 4
  %0 = load i32, ptr %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 132, label %sw.bb
    i32 9, label %sw.bb1
    i32 67, label %sw.bb1
    i32 10, label %sw.bb1
    i32 68, label %sw.bb1
    i32 11, label %sw.bb1
    i32 69, label %sw.bb1
    i32 12, label %sw.bb1
    i32 70, label %sw.bb1
    i32 13, label %sw.bb1
    i32 71, label %sw.bb1
    i32 72, label %sw.bb1
    i32 73, label %sw.bb1
    i32 14, label %sw.bb2
    i32 74, label %sw.bb2
    i32 15, label %sw.bb3
    i32 75, label %sw.bb3
    i32 16, label %sw.bb3
    i32 76, label %sw.bb3
    i32 77, label %sw.bb4
    i32 17, label %sw.bb5
    i32 78, label %sw.bb5
    i32 18, label %sw.bb6
    i32 79, label %sw.bb6
    i32 19, label %sw.bb6
    i32 80, label %sw.bb6
    i32 27, label %sw.bb6
    i32 88, label %sw.bb6
    i32 28, label %sw.bb6
    i32 89, label %sw.bb6
    i32 26, label %sw.bb7
    i32 87, label %sw.bb7
    i32 55, label %sw.bb8
    i32 115, label %sw.bb8
    i32 29, label %sw.bb9
    i32 90, label %sw.bb9
    i32 30, label %sw.bb9
    i32 91, label %sw.bb9
    i32 31, label %sw.bb9
    i32 92, label %sw.bb9
    i32 32, label %sw.bb10
    i32 93, label %sw.bb10
    i32 33, label %sw.bb10
    i32 94, label %sw.bb10
    i32 38, label %sw.bb11
    i32 103, label %sw.bb11
    i32 51, label %sw.bb12
    i32 110, label %sw.bb12
    i32 52, label %sw.bb12
    i32 111, label %sw.bb12
    i32 112, label %sw.bb12
    i32 54, label %sw.bb12
    i32 114, label %sw.bb12
    i32 53, label %sw.bb12
    i32 113, label %sw.bb12
    i32 102, label %sw.bb12
    i32 47, label %sw.bb13
    i32 104, label %sw.bb13
    i32 49, label %sw.bb13
    i32 107, label %sw.bb13
    i32 48, label %sw.bb14
    i32 105, label %sw.bb14
    i32 50, label %sw.bb14
    i32 108, label %sw.bb14
    i32 106, label %sw.bb14
    i32 109, label %sw.bb14
    i32 99, label %sw.bb14
    i32 100, label %sw.bb14
    i32 101, label %sw.bb14
    i32 35, label %sw.bb14
    i32 96, label %sw.bb14
    i32 36, label %sw.bb14
    i32 62, label %sw.bb14
    i32 122, label %sw.bb14
    i32 37, label %sw.bb15
    i32 98, label %sw.bb15
    i32 34, label %sw.bb16
    i32 95, label %sw.bb16
    i32 6, label %sw.bb17
    i32 64, label %sw.bb17
    i32 7, label %sw.bb17
    i32 65, label %sw.bb17
    i32 8, label %sw.bb18
    i32 66, label %sw.bb18
    i32 24, label %sw.bb19
    i32 85, label %sw.bb19
    i32 25, label %sw.bb19
    i32 86, label %sw.bb19
    i32 41, label %sw.bb20
    i32 125, label %sw.bb20
    i32 42, label %sw.bb20
    i32 126, label %sw.bb20
    i32 39, label %sw.bb21
    i32 123, label %sw.bb21
    i32 40, label %sw.bb21
    i32 124, label %sw.bb21
    i32 61, label %sw.bb22
    i32 121, label %sw.bb22
    i32 60, label %sw.bb26
    i32 120, label %sw.bb26
    i32 135, label %sw.bb30
    i32 139, label %sw.bb31
    i32 136, label %sw.bb32
    i32 140, label %sw.bb33
    i32 143, label %sw.bb34
    i32 144, label %sw.bb35
    i32 137, label %sw.bb36
    i32 141, label %sw.bb37
    i32 138, label %sw.bb38
    i32 142, label %sw.bb39
    i32 145, label %sw.bb40
    i32 146, label %sw.bb40
    i32 147, label %sw.bb41
    i32 148, label %sw.bb41
    i32 45, label %sw.bb44
    i32 46, label %sw.bb45
    i32 152, label %sw.bb46
    i32 154, label %sw.bb46
    i32 153, label %sw.bb47
    i32 155, label %sw.bb48
    i32 156, label %sw.bb48
    i32 157, label %sw.bb48
    i32 168, label %sw.bb48
    i32 169, label %sw.bb48
    i32 170, label %sw.bb48
    i32 171, label %sw.bb48
    i32 172, label %sw.bb48
    i32 173, label %sw.bb48
    i32 174, label %sw.bb48
    i32 175, label %sw.bb48
    i32 160, label %sw.bb48
    i32 161, label %sw.bb48
    i32 162, label %sw.bb48
    i32 163, label %sw.bb48
    i32 164, label %sw.bb48
    i32 165, label %sw.bb48
    i32 166, label %sw.bb48
    i32 167, label %sw.bb48
    i32 185, label %sw.bb48
    i32 186, label %sw.bb48
    i32 187, label %sw.bb48
    i32 188, label %sw.bb48
    i32 189, label %sw.bb48
    i32 181, label %sw.bb48
    i32 182, label %sw.bb48
    i32 183, label %sw.bb48
    i32 190, label %sw.bb48
    i32 194, label %sw.bb48
    i32 196, label %sw.bb48
    i32 197, label %sw.bb48
    i32 198, label %sw.bb48
    i32 200, label %sw.bb48
    i32 201, label %sw.bb48
    i32 202, label %sw.bb48
    i32 203, label %sw.bb48
    i32 159, label %sw.bb49
    i32 150, label %sw.bb49
    i32 176, label %sw.bb49
    i32 177, label %sw.bb49
    i32 178, label %sw.bb49
    i32 179, label %sw.bb49
    i32 180, label %sw.bb49
    i32 199, label %sw.bb49
    i32 204, label %sw.bb50
    i32 205, label %sw.bb50
    i32 191, label %sw.bb51
    i32 195, label %sw.bb51
  ]

sw.bb:                                            ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i32 15, ptr %retval, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry, %entry
  store i32 2, ptr %retval, align 4
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry, %entry, %entry, %entry
  store i32 4, ptr %retval, align 4
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  store i32 3, ptr %retval, align 4
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry, %entry
  store i32 27, ptr %retval, align 4
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i32 22, ptr %retval, align 4
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry, %entry
  store i32 23, ptr %retval, align 4
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry, %entry
  store i32 29, ptr %retval, align 4
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  %1 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %1, 64
  %tobool = icmp ne i32 %and, 0
  %cond = select i1 %tobool, i32 28, i32 20
  store i32 %cond, ptr %retval, align 4
  br label %sw.epilog

sw.bb10:                                          ; preds = %entry, %entry, %entry, %entry
  store i32 20, ptr %retval, align 4
  br label %sw.epilog

sw.bb11:                                          ; preds = %entry, %entry
  store i32 5, ptr %retval, align 4
  br label %sw.epilog

sw.bb12:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i32 12, ptr %retval, align 4
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry, %entry, %entry, %entry
  store i32 14, ptr %retval, align 4
  br label %sw.epilog

sw.bb14:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i32 15, ptr %retval, align 4
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry, %entry
  store i32 21, ptr %retval, align 4
  br label %sw.epilog

sw.bb16:                                          ; preds = %entry, %entry
  store i32 18, ptr %retval, align 4
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry, %entry, %entry, %entry
  store i32 19, ptr %retval, align 4
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry, %entry
  store i32 35, ptr %retval, align 4
  br label %sw.epilog

sw.bb19:                                          ; preds = %entry, %entry, %entry, %entry
  store i32 40, ptr %retval, align 4
  br label %sw.epilog

sw.bb20:                                          ; preds = %entry, %entry, %entry, %entry
  store i32 38, ptr %retval, align 4
  br label %sw.epilog

sw.bb21:                                          ; preds = %entry, %entry, %entry, %entry
  store i32 41, ptr %retval, align 4
  br label %sw.epilog

sw.bb22:                                          ; preds = %entry, %entry
  %2 = load i32, ptr @cpuinfo, align 4
  %and23 = and i32 %2, 32
  %tobool24 = icmp ne i32 %and23, 0
  %cond25 = select i1 %tobool24, i32 32, i32 31
  store i32 %cond25, ptr %retval, align 4
  br label %sw.epilog

sw.bb26:                                          ; preds = %entry, %entry
  %3 = load i32, ptr @cpuinfo, align 4
  %and27 = and i32 %3, 8
  %tobool28 = icmp ne i32 %and27, 0
  %cond29 = select i1 %tobool28, i32 32, i32 31
  store i32 %cond29, ptr %retval, align 4
  br label %sw.epilog

sw.bb30:                                          ; preds = %entry
  store i32 13, ptr %retval, align 4
  br label %sw.epilog

sw.bb31:                                          ; preds = %entry
  store i32 13, ptr %retval, align 4
  br label %sw.epilog

sw.bb32:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %sw.epilog

sw.bb33:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %sw.epilog

sw.bb34:                                          ; preds = %entry
  store i32 6, ptr %retval, align 4
  br label %sw.epilog

sw.bb35:                                          ; preds = %entry
  store i32 6, ptr %retval, align 4
  br label %sw.epilog

sw.bb36:                                          ; preds = %entry
  store i32 13, ptr %retval, align 4
  br label %sw.epilog

sw.bb37:                                          ; preds = %entry
  store i32 13, ptr %retval, align 4
  br label %sw.epilog

sw.bb38:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %sw.epilog

sw.bb39:                                          ; preds = %entry
  store i32 1, ptr %retval, align 4
  br label %sw.epilog

sw.bb40:                                          ; preds = %entry, %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb40
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 37, ptr %retval, align 4
  br label %sw.epilog

sw.bb41:                                          ; preds = %entry, %entry
  br label %do.body42

do.body42:                                        ; preds = %sw.bb41
  br label %do.end43

do.end43:                                         ; preds = %do.body42
  store i32 8, ptr %retval, align 4
  br label %sw.epilog

sw.bb44:                                          ; preds = %entry
  store i32 11, ptr %retval, align 4
  br label %sw.epilog

sw.bb45:                                          ; preds = %entry
  store i32 36, ptr %retval, align 4
  br label %sw.epilog

sw.bb46:                                          ; preds = %entry, %entry
  store i32 16, ptr %retval, align 4
  br label %sw.epilog

sw.bb47:                                          ; preds = %entry
  store i32 7, ptr %retval, align 4
  br label %sw.epilog

sw.bb48:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i32 30, ptr %retval, align 4
  br label %sw.epilog

sw.bb49:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  store i32 17, ptr %retval, align 4
  br label %sw.epilog

sw.bb50:                                          ; preds = %entry, %entry
  store i32 33, ptr %retval, align 4
  br label %sw.epilog

sw.bb51:                                          ; preds = %entry, %entry
  store i32 34, ptr %retval, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body52

do.body52:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 3532, ptr noundef @__func__.tcg_target_op_def, ptr noundef null) #15
  unreachable

do.end53:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end53, %sw.bb51, %sw.bb50, %sw.bb49, %sw.bb48, %sw.bb47, %sw.bb46, %sw.bb45, %sw.bb44, %do.end43, %do.end, %sw.bb39, %sw.bb38, %sw.bb37, %sw.bb36, %sw.bb35, %sw.bb34, %sw.bb33, %sw.bb32, %sw.bb31, %sw.bb30, %sw.bb26, %sw.bb22, %sw.bb21, %sw.bb20, %sw.bb19, %sw.bb18, %sw.bb17, %sw.bb16, %sw.bb15, %sw.bb14, %sw.bb13, %sw.bb12, %sw.bb11, %sw.bb10, %sw.bb9, %sw.bb8, %sw.bb7, %sw.bb6, %sw.bb5, %sw.bb4, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @sort_constraints(ptr noundef %def, i32 noundef %start, i32 noundef %n) #0 {
entry:
  %def.addr = alloca ptr, align 8
  %start.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %a = alloca ptr, align 8
  %p1 = alloca i32, align 4
  %p2 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store ptr %def, ptr %def.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %n, ptr %n.addr, align 4
  %0 = load ptr, ptr %def.addr, align 8
  %args_ct = getelementptr inbounds %struct.TCGOpDef, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %args_ct, align 8
  store ptr %1, ptr %a, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %n.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, ptr %start.addr, align 4
  %5 = load i32, ptr %i, align 4
  %add = add i32 %4, %5
  %6 = load ptr, ptr %a, align 8
  %7 = load i32, ptr %start.addr, align 4
  %8 = load i32, ptr %i, align 4
  %add1 = add i32 %7, %8
  %idxprom = sext i32 %add1 to i64
  %arrayidx = getelementptr %struct.TCGArgConstraint, ptr %6, i64 %idxprom
  %9 = zext i32 %add to i64
  %bf.load = load i64, ptr %arrayidx, align 4
  %bf.value = and i64 %9, 15
  %bf.shl = shl i64 %bf.value, 20
  %bf.clear = and i64 %bf.load, -15728641
  %bf.set = or i64 %bf.clear, %bf.shl
  store i64 %bf.set, ptr %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, ptr %i, align 4
  %inc = add i32 %10, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !87

for.end:                                          ; preds = %for.cond
  %11 = load i32, ptr %n.addr, align 4
  %cmp2 = icmp sle i32 %11, 1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  br label %for.end63

if.end:                                           ; preds = %for.end
  store i32 0, ptr %i, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc61, %if.end
  %12 = load i32, ptr %i, align 4
  %13 = load i32, ptr %n.addr, align 4
  %sub = sub i32 %13, 1
  %cmp4 = icmp slt i32 %12, %sub
  br i1 %cmp4, label %for.body5, label %for.end63

for.body5:                                        ; preds = %for.cond3
  %14 = load i32, ptr %i, align 4
  %add6 = add i32 %14, 1
  store i32 %add6, ptr %j, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc58, %for.body5
  %15 = load i32, ptr %j, align 4
  %16 = load i32, ptr %n.addr, align 4
  %cmp8 = icmp slt i32 %15, %16
  br i1 %cmp8, label %for.body9, label %for.end60

for.body9:                                        ; preds = %for.cond7
  %17 = load ptr, ptr %def.addr, align 8
  %18 = load ptr, ptr %a, align 8
  %19 = load i32, ptr %start.addr, align 4
  %20 = load i32, ptr %i, align 4
  %add10 = add i32 %19, %20
  %idxprom11 = sext i32 %add10 to i64
  %arrayidx12 = getelementptr %struct.TCGArgConstraint, ptr %18, i64 %idxprom11
  %bf.load13 = load i64, ptr %arrayidx12, align 4
  %bf.lshr = lshr i64 %bf.load13, 20
  %bf.clear14 = and i64 %bf.lshr, 15
  %bf.cast = trunc i64 %bf.clear14 to i32
  %call = call i32 @get_constraint_priority(ptr noundef %17, i32 noundef %bf.cast)
  store i32 %call, ptr %p1, align 4
  %21 = load ptr, ptr %def.addr, align 8
  %22 = load ptr, ptr %a, align 8
  %23 = load i32, ptr %start.addr, align 4
  %24 = load i32, ptr %j, align 4
  %add15 = add i32 %23, %24
  %idxprom16 = sext i32 %add15 to i64
  %arrayidx17 = getelementptr %struct.TCGArgConstraint, ptr %22, i64 %idxprom16
  %bf.load18 = load i64, ptr %arrayidx17, align 4
  %bf.lshr19 = lshr i64 %bf.load18, 20
  %bf.clear20 = and i64 %bf.lshr19, 15
  %bf.cast21 = trunc i64 %bf.clear20 to i32
  %call22 = call i32 @get_constraint_priority(ptr noundef %21, i32 noundef %bf.cast21)
  store i32 %call22, ptr %p2, align 4
  %25 = load i32, ptr %p1, align 4
  %26 = load i32, ptr %p2, align 4
  %cmp23 = icmp slt i32 %25, %26
  br i1 %cmp23, label %if.then24, label %if.end57

if.then24:                                        ; preds = %for.body9
  %27 = load ptr, ptr %a, align 8
  %28 = load i32, ptr %start.addr, align 4
  %29 = load i32, ptr %i, align 4
  %add25 = add i32 %28, %29
  %idxprom26 = sext i32 %add25 to i64
  %arrayidx27 = getelementptr %struct.TCGArgConstraint, ptr %27, i64 %idxprom26
  %bf.load28 = load i64, ptr %arrayidx27, align 4
  %bf.lshr29 = lshr i64 %bf.load28, 20
  %bf.clear30 = and i64 %bf.lshr29, 15
  %bf.cast31 = trunc i64 %bf.clear30 to i32
  store i32 %bf.cast31, ptr %tmp, align 4
  %30 = load ptr, ptr %a, align 8
  %31 = load i32, ptr %start.addr, align 4
  %32 = load i32, ptr %j, align 4
  %add32 = add i32 %31, %32
  %idxprom33 = sext i32 %add32 to i64
  %arrayidx34 = getelementptr %struct.TCGArgConstraint, ptr %30, i64 %idxprom33
  %bf.load35 = load i64, ptr %arrayidx34, align 4
  %bf.lshr36 = lshr i64 %bf.load35, 20
  %bf.clear37 = and i64 %bf.lshr36, 15
  %bf.cast38 = trunc i64 %bf.clear37 to i32
  %33 = load ptr, ptr %a, align 8
  %34 = load i32, ptr %start.addr, align 4
  %35 = load i32, ptr %i, align 4
  %add39 = add i32 %34, %35
  %idxprom40 = sext i32 %add39 to i64
  %arrayidx41 = getelementptr %struct.TCGArgConstraint, ptr %33, i64 %idxprom40
  %36 = zext i32 %bf.cast38 to i64
  %bf.load42 = load i64, ptr %arrayidx41, align 4
  %bf.value43 = and i64 %36, 15
  %bf.shl44 = shl i64 %bf.value43, 20
  %bf.clear45 = and i64 %bf.load42, -15728641
  %bf.set46 = or i64 %bf.clear45, %bf.shl44
  store i64 %bf.set46, ptr %arrayidx41, align 4
  %37 = load i32, ptr %tmp, align 4
  %38 = load ptr, ptr %a, align 8
  %39 = load i32, ptr %start.addr, align 4
  %40 = load i32, ptr %j, align 4
  %add48 = add i32 %39, %40
  %idxprom49 = sext i32 %add48 to i64
  %arrayidx50 = getelementptr %struct.TCGArgConstraint, ptr %38, i64 %idxprom49
  %41 = zext i32 %37 to i64
  %bf.load51 = load i64, ptr %arrayidx50, align 4
  %bf.value52 = and i64 %41, 15
  %bf.shl53 = shl i64 %bf.value52, 20
  %bf.clear54 = and i64 %bf.load51, -15728641
  %bf.set55 = or i64 %bf.clear54, %bf.shl53
  store i64 %bf.set55, ptr %arrayidx50, align 4
  br label %if.end57

if.end57:                                         ; preds = %if.then24, %for.body9
  br label %for.inc58

for.inc58:                                        ; preds = %if.end57
  %42 = load i32, ptr %j, align 4
  %inc59 = add i32 %42, 1
  store i32 %inc59, ptr %j, align 4
  br label %for.cond7, !llvm.loop !88

for.end60:                                        ; preds = %for.cond7
  br label %for.inc61

for.inc61:                                        ; preds = %for.end60
  %43 = load i32, ptr %i, align 4
  %inc62 = add i32 %43, 1
  store i32 %inc62, ptr %i, align 4
  br label %for.cond3, !llvm.loop !89

for.end63:                                        ; preds = %for.cond3, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @get_constraint_priority(ptr noundef %def, i32 noundef %k) #0 {
entry:
  %retval = alloca i32, align 4
  %def.addr = alloca ptr, align 8
  %k.addr = alloca i32, align 4
  %arg_ct = alloca ptr, align 8
  %n = alloca i32, align 4
  store ptr %def, ptr %def.addr, align 8
  store i32 %k, ptr %k.addr, align 4
  %0 = load ptr, ptr %def.addr, align 8
  %args_ct = getelementptr inbounds %struct.TCGOpDef, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %args_ct, align 8
  %2 = load i32, ptr %k.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr %struct.TCGArgConstraint, ptr %1, i64 %idxprom
  store ptr %arrayidx, ptr %arg_ct, align 8
  %3 = load ptr, ptr %arg_ct, align 8
  %regs = getelementptr inbounds %struct.TCGArgConstraint, ptr %3, i32 0, i32 1
  %4 = load i32, ptr %regs, align 4
  %conv = zext i32 %4 to i64
  %call = call i32 @ctpop64(i64 noundef %conv)
  store i32 %call, ptr %n, align 4
  %5 = load i32, ptr %n, align 4
  %cmp = icmp eq i32 %5, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load ptr, ptr %arg_ct, align 8
  %bf.load = load i64, ptr %6, align 4
  %bf.lshr = lshr i64 %bf.load, 30
  %bf.clear = and i64 %bf.lshr, 1
  %bf.cast = trunc i64 %bf.clear to i1
  br i1 %bf.cast, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 2147483647, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %7 = load ptr, ptr %arg_ct, align 8
  %bf.load3 = load i64, ptr %7, align 4
  %bf.lshr4 = lshr i64 %bf.load3, 28
  %bf.clear5 = and i64 %bf.lshr4, 3
  %bf.cast6 = trunc i64 %bf.clear5 to i32
  switch i32 %bf.cast6, label %sw.epilog [
    i32 1, label %sw.bb
    i32 3, label %sw.bb
    i32 2, label %sw.bb7
  ]

sw.bb:                                            ; preds = %if.end, %if.end
  %8 = load i32, ptr %k.addr, align 4
  %add = add i32 %8, 1
  %mul = mul i32 %add, 2
  store i32 %mul, ptr %retval, align 4
  br label %return

sw.bb7:                                           ; preds = %if.end
  %9 = load ptr, ptr %arg_ct, align 8
  %bf.load8 = load i64, ptr %9, align 4
  %bf.lshr9 = lshr i64 %bf.load8, 24
  %bf.clear10 = and i64 %bf.lshr9, 15
  %bf.cast11 = trunc i64 %bf.clear10 to i32
  %add12 = add i32 %bf.cast11, 1
  %mul13 = mul i32 %add12, 2
  %sub = sub i32 %mul13, 1
  store i32 %sub, ptr %retval, align 4
  br label %return

sw.epilog:                                        ; preds = %if.end
  %10 = load i32, ptr %n, align 4
  %cmp14 = icmp sgt i32 %10, 1
  br i1 %cmp14, label %if.then16, label %if.else

if.then16:                                        ; preds = %sw.epilog
  br label %if.end17

if.else:                                          ; preds = %sw.epilog
  call void @__assert_fail(ptr noundef @.str.38, ptr noundef @.str.1, i32 noundef 2891, ptr noundef @__PRETTY_FUNCTION__.get_constraint_priority) #19
  unreachable

if.end17:                                         ; preds = %if.then16
  %11 = load i32, ptr %n, align 4
  %sub18 = sub i32 0, %11
  store i32 %sub18, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end17, %sw.bb7, %sw.bb, %if.then
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ctpop64(i64 noundef %val) #0 {
entry:
  %val.addr = alloca i64, align 8
  store i64 %val, ptr %val.addr, align 8
  %0 = load i64, ptr %val.addr, align 8
  %1 = call i64 @llvm.ctpop.i64(i64 %0)
  %cast = trunc i64 %1 to i32
  ret i32 %cast
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctpop.i64(i64) #1

declare ptr @g_ptr_array_new_with_free_func(ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_plugin_insn_cleanup_fn(ptr noundef %data) #0 {
entry:
  %data.addr = alloca ptr, align 8
  %insn = alloca ptr, align 8
  store ptr %data, ptr %data.addr, align 8
  %0 = load ptr, ptr %data.addr, align 8
  store ptr %0, ptr %insn, align 8
  %1 = load ptr, ptr %insn, align 8
  %data1 = getelementptr inbounds %struct.qemu_plugin_insn, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %data1, align 8
  %call = call ptr @g_byte_array_free(ptr noundef %2, i32 noundef 1)
  ret void
}

declare ptr @g_byte_array_free(ptr noundef, i32 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_push(ptr noundef %s, i32 noundef %reg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %reg.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %reg, ptr %reg.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %reg.addr, align 4
  %and = and i32 %1, 7
  %add = add i32 80, %and
  %2 = load i32, ptr %reg.addr, align 4
  call void @tcg_out_opc(ptr noundef %0, i32 noundef %add, i32 noundef 0, i32 noundef %2, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @setup_guest_base_seg() #0 {
entry:
  %retval = alloca i32, align 4
  %0 = load i64, ptr @guest_base, align 8
  %call = call i32 @arch_prctl(i32 noundef 4097, i64 noundef %0)
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 32768, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load i32, ptr %retval, align 4
  ret i32 %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_movi(ptr noundef %s, i32 noundef %type, i32 noundef %ret, i64 noundef %arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %ret.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %ret, ptr %ret.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i32, ptr %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry
  %1 = load i32, ptr %ret.addr, align 4
  %cmp = icmp ult i32 %1, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %type.addr, align 4
  %4 = load i32, ptr %ret.addr, align 4
  %5 = load i64, ptr %arg.addr, align 8
  call void @tcg_out_movi_int(ptr noundef %2, i32 noundef %3, i32 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load i32, ptr %type.addr, align 4
  %8 = load i32, ptr %ret.addr, align 4
  %9 = load i64, ptr %arg.addr, align 8
  call void @tcg_out_movi_vec(ptr noundef %6, i32 noundef %7, i32 noundef %8, i64 noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 1055, ptr noundef @__func__.tcg_out_movi, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_out_mov(ptr noundef %s, i32 noundef %type, i32 noundef %ret, i32 noundef %arg) #0 {
entry:
  %retval = alloca i1, align 1
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %ret.addr = alloca i32, align 4
  %arg.addr = alloca i32, align 4
  %rexw = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %ret, ptr %ret.addr, align 4
  store i32 %arg, ptr %arg.addr, align 4
  store i32 0, ptr %rexw, align 4
  %0 = load i32, ptr %arg.addr, align 4
  %1 = load i32, ptr %ret.addr, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, ptr %type.addr, align 4
  switch i32 %2, label %sw.default [
    i32 1, label %sw.bb
    i32 0, label %sw.bb1
    i32 3, label %sw.bb15
    i32 4, label %sw.bb20
    i32 5, label %sw.bb28
  ]

sw.bb:                                            ; preds = %if.end
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb1

sw.bb1:                                           ; preds = %sw.bb, %if.end
  %3 = load i32, ptr %ret.addr, align 4
  %cmp2 = icmp ult i32 %3, 16
  br i1 %cmp2, label %if.then3, label %if.else8

if.then3:                                         ; preds = %sw.bb1
  %4 = load i32, ptr %arg.addr, align 4
  %cmp4 = icmp ult i32 %4, 16
  br i1 %cmp4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then3
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i32, ptr %rexw, align 4
  %add = add i32 139, %6
  %7 = load i32, ptr %ret.addr, align 4
  %8 = load i32, ptr %arg.addr, align 4
  call void @tcg_out_modrm(ptr noundef %5, i32 noundef %add, i32 noundef %7, i32 noundef %8)
  br label %if.end7

if.else:                                          ; preds = %if.then3
  %9 = load ptr, ptr %s.addr, align 8
  %10 = load i32, ptr %rexw, align 4
  %add6 = add i32 1406, %10
  %11 = load i32, ptr %arg.addr, align 4
  %12 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %9, i32 noundef %add6, i32 noundef %11, i32 noundef 0, i32 noundef %12)
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then5
  br label %if.end14

if.else8:                                         ; preds = %sw.bb1
  %13 = load i32, ptr %arg.addr, align 4
  %cmp9 = icmp ult i32 %13, 16
  br i1 %cmp9, label %if.then10, label %if.else12

if.then10:                                        ; preds = %if.else8
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load i32, ptr %rexw, align 4
  %add11 = add i32 1390, %15
  %16 = load i32, ptr %ret.addr, align 4
  %17 = load i32, ptr %arg.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %14, i32 noundef %add11, i32 noundef %16, i32 noundef 0, i32 noundef %17)
  br label %if.end13

if.else12:                                        ; preds = %if.else8
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load i32, ptr %ret.addr, align 4
  %20 = load i32, ptr %arg.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %18, i32 noundef 131454, i32 noundef %19, i32 noundef 0, i32 noundef %20)
  br label %if.end13

if.end13:                                         ; preds = %if.else12, %if.then10
  br label %if.end14

if.end14:                                         ; preds = %if.end13, %if.end7
  br label %sw.epilog

sw.bb15:                                          ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %sw.bb15
  %21 = load i32, ptr %ret.addr, align 4
  %cmp16 = icmp uge i32 %21, 16
  br i1 %cmp16, label %land.lhs.true, label %if.then18

land.lhs.true:                                    ; preds = %do.body
  %22 = load i32, ptr %arg.addr, align 4
  %cmp17 = icmp uge i32 %22, 16
  br i1 %cmp17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %land.lhs.true, %do.body
  unreachable

if.end19:                                         ; preds = %land.lhs.true
  br label %do.end

do.end:                                           ; preds = %if.end19
  %23 = load ptr, ptr %s.addr, align 8
  %24 = load i32, ptr %ret.addr, align 4
  %25 = load i32, ptr %arg.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %23, i32 noundef 131454, i32 noundef %24, i32 noundef 0, i32 noundef %25)
  br label %sw.epilog

sw.bb20:                                          ; preds = %if.end
  br label %do.body21

do.body21:                                        ; preds = %sw.bb20
  %26 = load i32, ptr %ret.addr, align 4
  %cmp22 = icmp uge i32 %26, 16
  br i1 %cmp22, label %land.lhs.true23, label %if.then25

land.lhs.true23:                                  ; preds = %do.body21
  %27 = load i32, ptr %arg.addr, align 4
  %cmp24 = icmp uge i32 %27, 16
  br i1 %cmp24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %land.lhs.true23, %do.body21
  unreachable

if.end26:                                         ; preds = %land.lhs.true23
  br label %do.end27

do.end27:                                         ; preds = %if.end26
  %28 = load ptr, ptr %s.addr, align 8
  %29 = load i32, ptr %ret.addr, align 4
  %30 = load i32, ptr %arg.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %28, i32 noundef 1391, i32 noundef %29, i32 noundef 0, i32 noundef %30)
  br label %sw.epilog

sw.bb28:                                          ; preds = %if.end
  br label %do.body29

do.body29:                                        ; preds = %sw.bb28
  %31 = load i32, ptr %ret.addr, align 4
  %cmp30 = icmp uge i32 %31, 16
  br i1 %cmp30, label %land.lhs.true31, label %if.then33

land.lhs.true31:                                  ; preds = %do.body29
  %32 = load i32, ptr %arg.addr, align 4
  %cmp32 = icmp uge i32 %32, 16
  br i1 %cmp32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %land.lhs.true31, %do.body29
  unreachable

if.end34:                                         ; preds = %land.lhs.true31
  br label %do.end35

do.end35:                                         ; preds = %if.end34
  %33 = load ptr, ptr %s.addr, align 8
  %34 = load i32, ptr %ret.addr, align 4
  %35 = load i32, ptr %arg.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %33, i32 noundef 525679, i32 noundef %34, i32 noundef 0, i32 noundef %35)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %do.body36

do.body36:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 875, ptr noundef @__func__.tcg_out_mov, ptr noundef null) #15
  unreachable

do.end37:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end37, %do.end35, %do.end27, %do.end, %if.end14
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  %36 = load i1, ptr %retval, align 1
  ret i1 %36
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_addi(ptr noundef %s, i32 noundef %reg, i64 noundef %val) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %reg.addr = alloca i32, align 4
  %val.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %reg, ptr %reg.addr, align 4
  store i64 %val, ptr %val.addr, align 8
  %0 = load i64, ptr %val.addr, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %reg.addr, align 4
  %3 = load i64, ptr %val.addr, align 8
  call void @tgen_arithi(ptr noundef %1, i32 noundef 4096, i32 noundef %2, i64 noundef %3, i32 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_modrm(ptr noundef %s, i32 noundef %opc, i32 noundef %r, i32 noundef %rm) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %rm.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %rm, ptr %rm.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %opc.addr, align 4
  %2 = load i32, ptr %r.addr, align 4
  %3 = load i32, ptr %rm.addr, align 4
  call void @tcg_out_opc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef 0)
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load i32, ptr %r.addr, align 4
  %and = and i32 %5, 7
  %shl = shl i32 %and, 3
  %or = or i32 192, %shl
  %6 = load i32, ptr %rm.addr, align 4
  %and1 = and i32 %6, 7
  %or2 = or i32 %or, %and1
  %conv = trunc i32 %or2 to i8
  call void @tcg_out8(ptr noundef %4, i8 noundef zeroext %conv)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_vex_opc(ptr noundef %s, i32 noundef %opc, i32 noundef %r, i32 noundef %v, i32 noundef %rm, i32 noundef %index) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %v.addr = alloca i32, align 4
  %rm.addr = alloca i32, align 4
  %index.addr = alloca i32, align 4
  %tmp = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %v, ptr %v.addr, align 4
  store i32 %rm, ptr %rm.addr, align 4
  store i32 %index, ptr %index.addr, align 4
  %0 = load i32, ptr %opc.addr, align 4
  %and = and i32 %0, 32768
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %1, i8 noundef zeroext 101)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %opc.addr, align 4
  %and1 = and i32 %2, 70400
  %cmp = icmp eq i32 %and1, 256
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %3 = load i32, ptr %rm.addr, align 4
  %4 = load i32, ptr %index.addr, align 4
  %or = or i32 %3, %4
  %and2 = and i32 %or, 8
  %cmp3 = icmp eq i32 %and2, 0
  br i1 %cmp3, label %if.then4, label %if.else

if.then4:                                         ; preds = %land.lhs.true
  %5 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %5, i8 noundef zeroext -59)
  %6 = load i32, ptr %r.addr, align 4
  %and5 = and i32 %6, 8
  %tobool6 = icmp ne i32 %and5, 0
  %cond = select i1 %tobool6, i32 0, i32 128
  store i32 %cond, ptr %tmp, align 4
  br label %if.end37

if.else:                                          ; preds = %land.lhs.true, %if.end
  %7 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %7, i8 noundef zeroext -60)
  %8 = load i32, ptr %opc.addr, align 4
  %and7 = and i32 %8, 65536
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then9, label %if.else10

if.then9:                                         ; preds = %if.else
  store i32 3, ptr %tmp, align 4
  br label %if.end21

if.else10:                                        ; preds = %if.else
  %9 = load i32, ptr %opc.addr, align 4
  %and11 = and i32 %9, 512
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.else10
  store i32 2, ptr %tmp, align 4
  br label %if.end20

if.else14:                                        ; preds = %if.else10
  %10 = load i32, ptr %opc.addr, align 4
  %and15 = and i32 %10, 256
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then17, label %if.else18

if.then17:                                        ; preds = %if.else14
  store i32 1, ptr %tmp, align 4
  br label %if.end19

if.else18:                                        ; preds = %if.else14
  br label %do.body

do.body:                                          ; preds = %if.else18
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 618, ptr noundef @__func__.tcg_out_vex_opc, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %if.end19

if.end19:                                         ; preds = %do.end, %if.then17
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.then13
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %if.then9
  %11 = load i32, ptr %r.addr, align 4
  %and22 = and i32 %11, 8
  %tobool23 = icmp ne i32 %and22, 0
  %cond24 = select i1 %tobool23, i32 0, i32 128
  %12 = load i32, ptr %tmp, align 4
  %or25 = or i32 %12, %cond24
  store i32 %or25, ptr %tmp, align 4
  %13 = load i32, ptr %index.addr, align 4
  %and26 = and i32 %13, 8
  %tobool27 = icmp ne i32 %and26, 0
  %cond28 = select i1 %tobool27, i32 0, i32 64
  %14 = load i32, ptr %tmp, align 4
  %or29 = or i32 %14, %cond28
  store i32 %or29, ptr %tmp, align 4
  %15 = load i32, ptr %rm.addr, align 4
  %and30 = and i32 %15, 8
  %tobool31 = icmp ne i32 %and30, 0
  %cond32 = select i1 %tobool31, i32 0, i32 32
  %16 = load i32, ptr %tmp, align 4
  %or33 = or i32 %16, %cond32
  store i32 %or33, ptr %tmp, align 4
  %17 = load ptr, ptr %s.addr, align 8
  %18 = load i32, ptr %tmp, align 4
  %conv = trunc i32 %18 to i8
  call void @tcg_out8(ptr noundef %17, i8 noundef zeroext %conv)
  %19 = load i32, ptr %opc.addr, align 4
  %and34 = and i32 %19, 4096
  %tobool35 = icmp ne i32 %and34, 0
  %cond36 = select i1 %tobool35, i32 128, i32 0
  store i32 %cond36, ptr %tmp, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.end21, %if.then4
  %20 = load i32, ptr %opc.addr, align 4
  %and38 = and i32 %20, 524288
  %tobool39 = icmp ne i32 %and38, 0
  %cond40 = select i1 %tobool39, i32 4, i32 0
  %21 = load i32, ptr %tmp, align 4
  %or41 = or i32 %21, %cond40
  store i32 %or41, ptr %tmp, align 4
  %22 = load i32, ptr %opc.addr, align 4
  %and42 = and i32 %22, 1024
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.then44, label %if.else46

if.then44:                                        ; preds = %if.end37
  %23 = load i32, ptr %tmp, align 4
  %or45 = or i32 %23, 1
  store i32 %or45, ptr %tmp, align 4
  br label %if.end58

if.else46:                                        ; preds = %if.end37
  %24 = load i32, ptr %opc.addr, align 4
  %and47 = and i32 %24, 131072
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then49, label %if.else51

if.then49:                                        ; preds = %if.else46
  %25 = load i32, ptr %tmp, align 4
  %or50 = or i32 %25, 2
  store i32 %or50, ptr %tmp, align 4
  br label %if.end57

if.else51:                                        ; preds = %if.else46
  %26 = load i32, ptr %opc.addr, align 4
  %and52 = and i32 %26, 262144
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %if.then54, label %if.end56

if.then54:                                        ; preds = %if.else51
  %27 = load i32, ptr %tmp, align 4
  %or55 = or i32 %27, 3
  store i32 %or55, ptr %tmp, align 4
  br label %if.end56

if.end56:                                         ; preds = %if.then54, %if.else51
  br label %if.end57

if.end57:                                         ; preds = %if.end56, %if.then49
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %if.then44
  %28 = load i32, ptr %v.addr, align 4
  %not = xor i32 %28, -1
  %and59 = and i32 %not, 15
  %shl = shl i32 %and59, 3
  %29 = load i32, ptr %tmp, align 4
  %or60 = or i32 %29, %shl
  store i32 %or60, ptr %tmp, align 4
  %30 = load ptr, ptr %s.addr, align 8
  %31 = load i32, ptr %tmp, align 4
  %conv61 = trunc i32 %31 to i8
  call void @tcg_out8(ptr noundef %30, i8 noundef zeroext %conv61)
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load i32, ptr %opc.addr, align 4
  %conv62 = trunc i32 %33 to i8
  call void @tcg_out8(ptr noundef %32, i8 noundef zeroext %conv62)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_pop(ptr noundef %s, i32 noundef %reg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %reg.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %reg, ptr %reg.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %reg.addr, align 4
  %and = and i32 %1, 7
  %add = add i32 88, %and
  %2 = load i32, ptr %reg.addr, align 4
  call void @tcg_out_opc(ptr noundef %0, i32 noundef %add, i32 noundef 0, i32 noundef %2, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_opc(ptr noundef %s, i32 noundef %opc, i32 noundef %r, i32 noundef %rm, i32 noundef %x) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %rm.addr = alloca i32, align 4
  %x.addr = alloca i32, align 4
  %rex = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %rm, ptr %rm.addr, align 4
  store i32 %x, ptr %x.addr, align 4
  %0 = load i32, ptr %opc.addr, align 4
  %and = and i32 %0, 32768
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %1, i8 noundef zeroext 101)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, ptr %opc.addr, align 4
  %and1 = and i32 %2, 1024
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then3
  %3 = load i32, ptr %opc.addr, align 4
  %and4 = and i32 %3, 4096
  %cmp = icmp eq i32 %and4, 0
  br i1 %cmp, label %if.end6, label %if.then5

if.then5:                                         ; preds = %do.body
  unreachable

if.end6:                                          ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end6
  %4 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %4, i8 noundef zeroext 102)
  br label %if.end7

if.end7:                                          ; preds = %do.end, %if.end
  %5 = load i32, ptr %opc.addr, align 4
  %and8 = and i32 %5, 131072
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %if.end7
  %6 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %6, i8 noundef zeroext -13)
  br label %if.end15

if.else:                                          ; preds = %if.end7
  %7 = load i32, ptr %opc.addr, align 4
  %and11 = and i32 %7, 262144
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.else
  %8 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %8, i8 noundef zeroext -14)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.else
  br label %if.end15

if.end15:                                         ; preds = %if.end14, %if.then10
  store i32 0, ptr %rex, align 4
  %9 = load i32, ptr %opc.addr, align 4
  %and16 = and i32 %9, 4096
  %tobool17 = icmp ne i32 %and16, 0
  %cond = select i1 %tobool17, i32 8, i32 0
  %10 = load i32, ptr %rex, align 4
  %or = or i32 %10, %cond
  store i32 %or, ptr %rex, align 4
  %11 = load i32, ptr %r.addr, align 4
  %and18 = and i32 %11, 8
  %shr = ashr i32 %and18, 1
  %12 = load i32, ptr %rex, align 4
  %or19 = or i32 %12, %shr
  store i32 %or19, ptr %rex, align 4
  %13 = load i32, ptr %x.addr, align 4
  %and20 = and i32 %13, 8
  %shr21 = ashr i32 %and20, 2
  %14 = load i32, ptr %rex, align 4
  %or22 = or i32 %14, %shr21
  store i32 %or22, ptr %rex, align 4
  %15 = load i32, ptr %rm.addr, align 4
  %and23 = and i32 %15, 8
  %shr24 = ashr i32 %and23, 3
  %16 = load i32, ptr %rex, align 4
  %or25 = or i32 %16, %shr24
  store i32 %or25, ptr %rex, align 4
  %17 = load i32, ptr %opc.addr, align 4
  %18 = load i32, ptr %r.addr, align 4
  %cmp26 = icmp sge i32 %18, 4
  %cond27 = select i1 %cmp26, i32 8192, i32 0
  %and28 = and i32 %17, %cond27
  %19 = load i32, ptr %rex, align 4
  %or29 = or i32 %19, %and28
  store i32 %or29, ptr %rex, align 4
  %20 = load i32, ptr %opc.addr, align 4
  %21 = load i32, ptr %rm.addr, align 4
  %cmp30 = icmp sge i32 %21, 4
  %cond31 = select i1 %cmp30, i32 16384, i32 0
  %and32 = and i32 %20, %cond31
  %22 = load i32, ptr %rex, align 4
  %or33 = or i32 %22, %and32
  store i32 %or33, ptr %rex, align 4
  %23 = load i32, ptr %rex, align 4
  %tobool34 = icmp ne i32 %23, 0
  br i1 %tobool34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end15
  %24 = load ptr, ptr %s.addr, align 8
  %25 = load i32, ptr %rex, align 4
  %or36 = or i32 %25, 64
  %conv = trunc i32 %or36 to i8
  call void @tcg_out8(ptr noundef %24, i8 noundef zeroext %conv)
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end15
  %26 = load i32, ptr %opc.addr, align 4
  %and38 = and i32 %26, 66304
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %if.then40, label %if.end50

if.then40:                                        ; preds = %if.end37
  %27 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %27, i8 noundef zeroext 15)
  %28 = load i32, ptr %opc.addr, align 4
  %and41 = and i32 %28, 512
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.then43, label %if.else44

if.then43:                                        ; preds = %if.then40
  %29 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %29, i8 noundef zeroext 56)
  br label %if.end49

if.else44:                                        ; preds = %if.then40
  %30 = load i32, ptr %opc.addr, align 4
  %and45 = and i32 %30, 65536
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.else44
  %31 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %31, i8 noundef zeroext 58)
  br label %if.end48

if.end48:                                         ; preds = %if.then47, %if.else44
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.then43
  br label %if.end50

if.end50:                                         ; preds = %if.end49, %if.end37
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load i32, ptr %opc.addr, align 4
  %conv51 = trunc i32 %33 to i8
  call void @tcg_out8(ptr noundef %32, i8 noundef zeroext %conv51)
  ret void
}

declare i32 @arch_prctl(i32 noundef, i64 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_movi_int(ptr noundef %s, i32 noundef %type, i32 noundef %ret, i64 noundef %arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %ret.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %diff = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %ret, ptr %ret.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i64, ptr %arg.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %ret.addr, align 4
  %3 = load i32, ptr %ret.addr, align 4
  call void @tgen_arithr(ptr noundef %1, i32 noundef 6, i32 noundef %2, i32 noundef %3)
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i64, ptr %arg.addr, align 8
  %5 = load i64, ptr %arg.addr, align 8
  %conv = trunc i64 %5 to i32
  %conv1 = zext i32 %conv to i64
  %cmp2 = icmp eq i64 %4, %conv1
  br i1 %cmp2, label %if.then6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %6 = load i32, ptr %type.addr, align 4
  %cmp4 = icmp eq i32 %6, 0
  br i1 %cmp4, label %if.then6, label %if.end8

if.then6:                                         ; preds = %lor.lhs.false, %if.end
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i32, ptr %ret.addr, align 4
  %and = and i32 %8, 7
  %add = add i32 184, %and
  %9 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_opc(ptr noundef %7, i32 noundef %add, i32 noundef 0, i32 noundef %9, i32 noundef 0)
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load i64, ptr %arg.addr, align 8
  %conv7 = trunc i64 %11 to i32
  call void @tcg_out32(ptr noundef %10, i32 noundef %conv7)
  br label %return

if.end8:                                          ; preds = %lor.lhs.false
  %12 = load i64, ptr %arg.addr, align 8
  %13 = load i64, ptr %arg.addr, align 8
  %conv9 = trunc i64 %13 to i32
  %conv10 = sext i32 %conv9 to i64
  %cmp11 = icmp eq i64 %12, %conv10
  br i1 %cmp11, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end8
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_modrm(ptr noundef %14, i32 noundef 4295, i32 noundef 0, i32 noundef %15)
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i64, ptr %arg.addr, align 8
  %conv14 = trunc i64 %17 to i32
  call void @tcg_out32(ptr noundef %16, i32 noundef %conv14)
  br label %return

if.end15:                                         ; preds = %if.end8
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load i64, ptr %arg.addr, align 8
  %20 = inttoptr i64 %19 to ptr
  %call = call i64 @tcg_pcrel_diff(ptr noundef %18, ptr noundef %20)
  %sub = sub i64 %call, 7
  store i64 %sub, ptr %diff, align 8
  %21 = load i64, ptr %diff, align 8
  %22 = load i64, ptr %diff, align 8
  %conv16 = trunc i64 %22 to i32
  %conv17 = sext i32 %conv16 to i64
  %cmp18 = icmp eq i64 %21, %conv17
  br i1 %cmp18, label %if.then20, label %if.end24

if.then20:                                        ; preds = %if.end15
  %23 = load ptr, ptr %s.addr, align 8
  %24 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_opc(ptr noundef %23, i32 noundef 4237, i32 noundef %24, i32 noundef 0, i32 noundef 0)
  %25 = load ptr, ptr %s.addr, align 8
  %26 = load i32, ptr %ret.addr, align 4
  %and21 = and i32 %26, 7
  %shl = shl i32 %and21, 3
  %or = or i32 %shl, 5
  %conv22 = trunc i32 %or to i8
  call void @tcg_out8(ptr noundef %25, i8 noundef zeroext %conv22)
  %27 = load ptr, ptr %s.addr, align 8
  %28 = load i64, ptr %diff, align 8
  %conv23 = trunc i64 %28 to i32
  call void @tcg_out32(ptr noundef %27, i32 noundef %conv23)
  br label %return

if.end24:                                         ; preds = %if.end15
  %29 = load ptr, ptr %s.addr, align 8
  %30 = load i32, ptr %ret.addr, align 4
  %and25 = and i32 %30, 7
  %add26 = add i32 4280, %and25
  %31 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_opc(ptr noundef %29, i32 noundef %add26, i32 noundef 0, i32 noundef %31, i32 noundef 0)
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load i64, ptr %arg.addr, align 8
  call void @tcg_out64(ptr noundef %32, i64 noundef %33)
  br label %return

return:                                           ; preds = %if.end24, %if.then20, %if.then13, %if.then6, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_movi_vec(ptr noundef %s, i32 noundef %type, i32 noundef %ret, i64 noundef %arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %ret.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %rexw = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %ret, ptr %ret.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i64, ptr %arg.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %ret.addr, align 4
  %3 = load i32, ptr %ret.addr, align 4
  %4 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %1, i32 noundef 1519, i32 noundef %2, i32 noundef %3, i32 noundef %4)
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, ptr %arg.addr, align 8
  %cmp1 = icmp eq i64 %5, -1
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load i32, ptr %ret.addr, align 4
  %8 = load i32, ptr %ret.addr, align 4
  %9 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %6, i32 noundef 1396, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  br label %return

if.end3:                                          ; preds = %if.end
  %10 = load i32, ptr %type.addr, align 4
  %cmp4 = icmp eq i32 %10, 0
  %cond = select i1 %cmp4, i32 0, i32 4096
  store i32 %cond, ptr %rexw, align 4
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load i32, ptr %rexw, align 4
  %add = add i32 1390, %12
  %13 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_vex_modrm_pool(ptr noundef %11, i32 noundef %add, i32 noundef %13)
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load i64, ptr %arg.addr, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %16, i32 0, i32 23
  %17 = load ptr, ptr %code_ptr, align 8
  %add.ptr = getelementptr i8, ptr %17, i64 -4
  call void @new_pool_label(ptr noundef %14, i64 noundef %15, i32 noundef 2, ptr noundef %add.ptr, i64 noundef -4)
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tgen_arithr(ptr noundef %s, i32 noundef %subop, i32 noundef %dest, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %subop.addr = alloca i32, align 4
  %dest.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  %ext = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %subop, ptr %subop.addr, align 4
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  %0 = load i32, ptr %subop.addr, align 4
  %and = and i32 %0, -8
  store i32 %and, ptr %ext, align 4
  %1 = load i32, ptr %subop.addr, align 4
  %and1 = and i32 %1, 7
  store i32 %and1, ptr %subop.addr, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %subop.addr, align 4
  %shl = shl i32 %3, 3
  %add = add i32 3, %shl
  %4 = load i32, ptr %ext, align 4
  %add2 = add i32 %add, %4
  %5 = load i32, ptr %dest.addr, align 4
  %6 = load i32, ptr %src.addr, align 4
  call void @tcg_out_modrm(ptr noundef %2, i32 noundef %add2, i32 noundef %5, i32 noundef %6)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out32(ptr noundef %s, i32 noundef %v) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %v.addr = alloca i32, align 4
  %p = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %v, ptr %v.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 23
  %1 = load ptr, ptr %code_ptr, align 8
  store ptr %1, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %2, ptr align 4 %v.addr, i64 4, i1 false)
  %3 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr i8, ptr %3, i64 4
  %4 = load ptr, ptr %s.addr, align 8
  %code_ptr1 = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 23
  store ptr %add.ptr, ptr %code_ptr1, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @tcg_pcrel_diff(ptr noundef %s, ptr noundef %target) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %target.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %target, ptr %target.addr, align 8
  %0 = load ptr, ptr %target.addr, align 8
  %1 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %1, i32 0, i32 23
  %2 = load ptr, ptr %code_ptr, align 8
  %call = call ptr @tcg_splitwx_to_rx(ptr noundef %2)
  %call1 = call i64 @tcg_ptr_byte_diff(ptr noundef %0, ptr noundef %call)
  ret i64 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out8(ptr noundef %s, i8 noundef zeroext %v) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %v.addr = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  store i8 %v, ptr %v.addr, align 1
  %0 = load i8, ptr %v.addr, align 1
  %1 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %1, i32 0, i32 23
  %2 = load ptr, ptr %code_ptr, align 8
  %incdec.ptr = getelementptr i8, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %code_ptr, align 8
  store i8 %0, ptr %2, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out64(ptr noundef %s, i64 noundef %v) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %v.addr = alloca i64, align 8
  %p = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 23
  %1 = load ptr, ptr %code_ptr, align 8
  store ptr %1, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %2, ptr align 8 %v.addr, i64 8, i1 false)
  %3 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr i8, ptr %3, i64 8
  %4 = load ptr, ptr %s.addr, align 8
  %code_ptr1 = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 23
  store ptr %add.ptr, ptr %code_ptr1, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_vex_modrm(ptr noundef %s, i32 noundef %opc, i32 noundef %r, i32 noundef %v, i32 noundef %rm) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %v.addr = alloca i32, align 4
  %rm.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %v, ptr %v.addr, align 4
  store i32 %rm, ptr %rm.addr, align 4
  %0 = load i32, ptr %opc.addr, align 4
  %and = and i32 %0, 1048576
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %opc.addr, align 4
  %3 = load i32, ptr %r.addr, align 4
  %4 = load i32, ptr %v.addr, align 4
  %5 = load i32, ptr %rm.addr, align 4
  call void @tcg_out_evex_opc(ptr noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef 0)
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load i32, ptr %opc.addr, align 4
  %8 = load i32, ptr %r.addr, align 4
  %9 = load i32, ptr %v.addr, align 4
  %10 = load i32, ptr %rm.addr, align 4
  call void @tcg_out_vex_opc(ptr noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9, i32 noundef %10, i32 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load i32, ptr %r.addr, align 4
  %and1 = and i32 %12, 7
  %shl = shl i32 %and1, 3
  %or = or i32 192, %shl
  %13 = load i32, ptr %rm.addr, align 4
  %and2 = and i32 %13, 7
  %or3 = or i32 %or, %and2
  %conv = trunc i32 %or3 to i8
  call void @tcg_out8(ptr noundef %11, i8 noundef zeroext %conv)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_vex_modrm_pool(ptr noundef %s, i32 noundef %opc, i32 noundef %r) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %opc.addr, align 4
  %2 = load i32, ptr %r.addr, align 4
  call void @tcg_out_vex_opc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load i32, ptr %r.addr, align 4
  %and = and i32 %4, 7
  %shl = shl i32 %and, 3
  %or = or i32 %shl, 5
  %conv = trunc i32 %or to i8
  call void @tcg_out8(ptr noundef %3, i8 noundef zeroext %conv)
  %5 = load ptr, ptr %s.addr, align 8
  call void @tcg_out32(ptr noundef %5, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @new_pool_label(ptr noundef %s, i64 noundef %d, i32 noundef %rtype, ptr noundef %label, i64 noundef %addend) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %d.addr = alloca i64, align 8
  %rtype.addr = alloca i32, align 4
  %label.addr = alloca ptr, align 8
  %addend.addr = alloca i64, align 8
  %n = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %d, ptr %d.addr, align 8
  store i32 %rtype, ptr %rtype.addr, align 4
  store ptr %label, ptr %label.addr, align 8
  store i64 %addend, ptr %addend.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %rtype.addr, align 4
  %2 = load ptr, ptr %label.addr, align 8
  %3 = load i64, ptr %addend.addr, align 8
  %call = call ptr @new_pool_alloc(ptr noundef %0, i32 noundef 1, i32 noundef %1, ptr noundef %2, i64 noundef %3)
  store ptr %call, ptr %n, align 8
  %4 = load i64, ptr %d.addr, align 8
  %5 = load ptr, ptr %n, align 8
  %data = getelementptr inbounds %struct.TCGLabelPoolData, ptr %5, i32 0, i32 5
  %arrayidx = getelementptr [0 x i64], ptr %data, i64 0, i64 0
  store i64 %4, ptr %arrayidx, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load ptr, ptr %n, align 8
  call void @new_pool_insert(ptr noundef %6, ptr noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_evex_opc(ptr noundef %s, i32 noundef %opc, i32 noundef %r, i32 noundef %v, i32 noundef %rm, i32 noundef %index) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %v.addr = alloca i32, align 4
  %rm.addr = alloca i32, align 4
  %index.addr = alloca i32, align 4
  %p = alloca i32, align 4
  %mm = alloca i32, align 4
  %pp = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %v, ptr %v.addr, align 4
  store i32 %rm, ptr %rm.addr, align 4
  store i32 %index, ptr %index.addr, align 4
  store i32 134484066, ptr %p, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %0, 4096
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %do.body
  %1 = load i32, ptr @cpuinfo, align 4
  %and1 = and i32 %1, 2048
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %do.body
  unreachable

if.end:                                           ; preds = %land.lhs.true
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load i32, ptr %opc.addr, align 4
  %and3 = and i32 %2, 65536
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %do.end
  store i32 3, ptr %mm, align 4
  br label %if.end18

if.else:                                          ; preds = %do.end
  %3 = load i32, ptr %opc.addr, align 4
  %and6 = and i32 %3, 512
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %if.else
  store i32 2, ptr %mm, align 4
  br label %if.end17

if.else9:                                         ; preds = %if.else
  %4 = load i32, ptr %opc.addr, align 4
  %and10 = and i32 %4, 256
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else13

if.then12:                                        ; preds = %if.else9
  store i32 1, ptr %mm, align 4
  br label %if.end16

if.else13:                                        ; preds = %if.else9
  br label %do.body14

do.body14:                                        ; preds = %if.else13
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 659, ptr noundef @__func__.tcg_out_evex_opc, ptr noundef null) #15
  unreachable

do.end15:                                         ; No predecessors!
  br label %if.end16

if.end16:                                         ; preds = %do.end15, %if.then12
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.then8
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.then5
  %5 = load i32, ptr %opc.addr, align 4
  %and19 = and i32 %5, 1024
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.else22

if.then21:                                        ; preds = %if.end18
  store i32 1, ptr %pp, align 4
  br label %if.end33

if.else22:                                        ; preds = %if.end18
  %6 = load i32, ptr %opc.addr, align 4
  %and23 = and i32 %6, 131072
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.else26

if.then25:                                        ; preds = %if.else22
  store i32 2, ptr %pp, align 4
  br label %if.end32

if.else26:                                        ; preds = %if.else22
  %7 = load i32, ptr %opc.addr, align 4
  %and27 = and i32 %7, 262144
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.then29, label %if.else30

if.then29:                                        ; preds = %if.else26
  store i32 3, ptr %pp, align 4
  br label %if.end31

if.else30:                                        ; preds = %if.else26
  store i32 0, ptr %pp, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.else30, %if.then29
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then25
  br label %if.end33

if.end33:                                         ; preds = %if.end32, %if.then21
  %8 = load i32, ptr %p, align 4
  %9 = load i32, ptr %mm, align 4
  %call = call i32 @deposit32(i32 noundef %8, i32 noundef 8, i32 noundef 2, i32 noundef %9)
  store i32 %call, ptr %p, align 4
  %10 = load i32, ptr %p, align 4
  %11 = load i32, ptr %rm.addr, align 4
  %and34 = and i32 %11, 8
  %cmp = icmp eq i32 %and34, 0
  %conv = zext i1 %cmp to i32
  %call35 = call i32 @deposit32(i32 noundef %10, i32 noundef 13, i32 noundef 1, i32 noundef %conv)
  store i32 %call35, ptr %p, align 4
  %12 = load i32, ptr %p, align 4
  %13 = load i32, ptr %index.addr, align 4
  %and36 = and i32 %13, 8
  %cmp37 = icmp eq i32 %and36, 0
  %conv38 = zext i1 %cmp37 to i32
  %call39 = call i32 @deposit32(i32 noundef %12, i32 noundef 14, i32 noundef 1, i32 noundef %conv38)
  store i32 %call39, ptr %p, align 4
  %14 = load i32, ptr %p, align 4
  %15 = load i32, ptr %r.addr, align 4
  %and40 = and i32 %15, 8
  %cmp41 = icmp eq i32 %and40, 0
  %conv42 = zext i1 %cmp41 to i32
  %call43 = call i32 @deposit32(i32 noundef %14, i32 noundef 15, i32 noundef 1, i32 noundef %conv42)
  store i32 %call43, ptr %p, align 4
  %16 = load i32, ptr %p, align 4
  %17 = load i32, ptr %pp, align 4
  %call44 = call i32 @deposit32(i32 noundef %16, i32 noundef 16, i32 noundef 2, i32 noundef %17)
  store i32 %call44, ptr %p, align 4
  %18 = load i32, ptr %p, align 4
  %19 = load i32, ptr %v.addr, align 4
  %not = xor i32 %19, -1
  %call45 = call i32 @deposit32(i32 noundef %18, i32 noundef 19, i32 noundef 4, i32 noundef %not)
  store i32 %call45, ptr %p, align 4
  %20 = load i32, ptr %p, align 4
  %21 = load i32, ptr %opc.addr, align 4
  %and46 = and i32 %21, 4096
  %cmp47 = icmp ne i32 %and46, 0
  %conv48 = zext i1 %cmp47 to i32
  %call49 = call i32 @deposit32(i32 noundef %20, i32 noundef 23, i32 noundef 1, i32 noundef %conv48)
  store i32 %call49, ptr %p, align 4
  %22 = load i32, ptr %p, align 4
  %23 = load i32, ptr %opc.addr, align 4
  %and50 = and i32 %23, 524288
  %cmp51 = icmp ne i32 %and50, 0
  %conv52 = zext i1 %cmp51 to i32
  %call53 = call i32 @deposit32(i32 noundef %22, i32 noundef 29, i32 noundef 2, i32 noundef %conv52)
  store i32 %call53, ptr %p, align 4
  %24 = load ptr, ptr %s.addr, align 8
  %25 = load i32, ptr %p, align 4
  call void @tcg_out32(ptr noundef %24, i32 noundef %25)
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i32, ptr %opc.addr, align 4
  %conv54 = trunc i32 %27 to i8
  call void @tcg_out8(ptr noundef %26, i8 noundef zeroext %conv54)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @deposit32(i32 noundef %value, i32 noundef %start, i32 noundef %length, i32 noundef %fieldval) #0 {
entry:
  %value.addr = alloca i32, align 4
  %start.addr = alloca i32, align 4
  %length.addr = alloca i32, align 4
  %fieldval.addr = alloca i32, align 4
  %mask = alloca i32, align 4
  store i32 %value, ptr %value.addr, align 4
  store i32 %start, ptr %start.addr, align 4
  store i32 %length, ptr %length.addr, align 4
  store i32 %fieldval, ptr %fieldval.addr, align 4
  %0 = load i32, ptr %start.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %length.addr, align 4
  %cmp1 = icmp sgt i32 %1, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i32, ptr %length.addr, align 4
  %3 = load i32, ptr %start.addr, align 4
  %sub = sub i32 32, %3
  %cmp3 = icmp sle i32 %2, %sub
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true2
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  call void @__assert_fail(ptr noundef @.str.39, ptr noundef @.str.40, i32 noundef 470, ptr noundef @__PRETTY_FUNCTION__.deposit32) #19
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load i32, ptr %length.addr, align 4
  %sub4 = sub i32 32, %4
  %shr = lshr i32 -1, %sub4
  %5 = load i32, ptr %start.addr, align 4
  %shl = shl i32 %shr, %5
  store i32 %shl, ptr %mask, align 4
  %6 = load i32, ptr %value.addr, align 4
  %7 = load i32, ptr %mask, align 4
  %not = xor i32 %7, -1
  %and = and i32 %6, %not
  %8 = load i32, ptr %fieldval.addr, align 4
  %9 = load i32, ptr %start.addr, align 4
  %shl5 = shl i32 %8, %9
  %10 = load i32, ptr %mask, align 4
  %and6 = and i32 %shl5, %10
  %or = or i32 %and, %and6
  ret i32 %or
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @new_pool_alloc(ptr noundef %s, i32 noundef %nlong, i32 noundef %rtype, ptr noundef %label, i64 noundef %addend) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %nlong.addr = alloca i32, align 4
  %rtype.addr = alloca i32, align 4
  %label.addr = alloca ptr, align 8
  %addend.addr = alloca i64, align 8
  %n = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %nlong, ptr %nlong.addr, align 4
  store i32 %rtype, ptr %rtype.addr, align 4
  store ptr %label, ptr %label.addr, align 8
  store i64 %addend, ptr %addend.addr, align 8
  %0 = load i32, ptr %nlong.addr, align 4
  %conv = sext i32 %0 to i64
  %mul = mul i64 8, %conv
  %add = add i64 32, %mul
  %conv1 = trunc i64 %add to i32
  %call = call ptr @tcg_malloc(i32 noundef %conv1)
  store ptr %call, ptr %n, align 8
  %1 = load ptr, ptr %label.addr, align 8
  %2 = load ptr, ptr %n, align 8
  %label2 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %2, i32 0, i32 1
  store ptr %1, ptr %label2, align 8
  %3 = load i64, ptr %addend.addr, align 8
  %4 = load ptr, ptr %n, align 8
  %addend3 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %4, i32 0, i32 2
  store i64 %3, ptr %addend3, align 8
  %5 = load i32, ptr %rtype.addr, align 4
  %6 = load ptr, ptr %n, align 8
  %rtype4 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %6, i32 0, i32 3
  store i32 %5, ptr %rtype4, align 8
  %7 = load i32, ptr %nlong.addr, align 4
  %8 = load ptr, ptr %n, align 8
  %nlong5 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %8, i32 0, i32 4
  store i32 %7, ptr %nlong5, align 4
  %9 = load ptr, ptr %n, align 8
  ret ptr %9
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @new_pool_insert(ptr noundef %s, ptr noundef %n) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %n.addr = alloca ptr, align 8
  %i = alloca ptr, align 8
  %pp = alloca ptr, align 8
  %nlong = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %n, ptr %n.addr, align 8
  %0 = load ptr, ptr %n.addr, align 8
  %nlong1 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %nlong1, align 4
  store i32 %1, ptr %nlong, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %pool_labels = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 31
  store ptr %pool_labels, ptr %pp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load ptr, ptr %pp, align 8
  %4 = load ptr, ptr %3, align 8
  store ptr %4, ptr %i, align 8
  %cmp = icmp ne ptr %4, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32, ptr %nlong, align 4
  %6 = load ptr, ptr %i, align 8
  %nlong2 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %6, i32 0, i32 4
  %7 = load i32, ptr %nlong2, align 4
  %cmp3 = icmp ugt i32 %5, %7
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  %8 = load i32, ptr %nlong, align 4
  %9 = load ptr, ptr %i, align 8
  %nlong4 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %9, i32 0, i32 4
  %10 = load i32, ptr %nlong4, align 4
  %cmp5 = icmp ult i32 %8, %10
  br i1 %cmp5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  br label %for.inc

if.end7:                                          ; preds = %if.end
  %11 = load ptr, ptr %n.addr, align 8
  %data = getelementptr inbounds %struct.TCGLabelPoolData, ptr %11, i32 0, i32 5
  %arraydecay = getelementptr inbounds [0 x i64], ptr %data, i64 0, i64 0
  %12 = load ptr, ptr %i, align 8
  %data8 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %12, i32 0, i32 5
  %arraydecay9 = getelementptr inbounds [0 x i64], ptr %data8, i64 0, i64 0
  %13 = load i32, ptr %nlong, align 4
  %conv = sext i32 %13 to i64
  %mul = mul i64 8, %conv
  %call = call i32 @memcmp(ptr noundef %arraydecay, ptr noundef %arraydecay9, i64 noundef %mul) #18
  %cmp10 = icmp sge i32 %call, 0
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end7
  br label %for.end

if.end13:                                         ; preds = %if.end7
  br label %for.inc

for.inc:                                          ; preds = %if.end13, %if.then6
  %14 = load ptr, ptr %i, align 8
  %next = getelementptr inbounds %struct.TCGLabelPoolData, ptr %14, i32 0, i32 0
  store ptr %next, ptr %pp, align 8
  br label %for.cond, !llvm.loop !90

for.end:                                          ; preds = %if.then12, %if.then, %for.cond
  %15 = load ptr, ptr %pp, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %n.addr, align 8
  %next14 = getelementptr inbounds %struct.TCGLabelPoolData, ptr %17, i32 0, i32 0
  store ptr %16, ptr %next14, align 8
  %18 = load ptr, ptr %n.addr, align 8
  %19 = load ptr, ptr %pp, align 8
  store ptr %18, ptr %19, align 8
  ret void
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @memcmp(ptr noundef, ptr noundef, i64 noundef) #12

; Function Attrs: nounwind sspstrong uwtable
define internal void @tgen_arithi(ptr noundef %s, i32 noundef %c, i32 noundef %r0, i64 noundef %val, i32 noundef %cf) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %c.addr = alloca i32, align 4
  %r0.addr = alloca i32, align 4
  %val.addr = alloca i64, align 8
  %cf.addr = alloca i32, align 4
  %rexw = alloca i32, align 4
  %is_inc = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %c, ptr %c.addr, align 4
  store i32 %r0, ptr %r0.addr, align 4
  store i64 %val, ptr %val.addr, align 8
  store i32 %cf, ptr %cf.addr, align 4
  store i32 0, ptr %rexw, align 4
  %0 = load i32, ptr %c.addr, align 4
  %and = and i32 %0, -8
  store i32 %and, ptr %rexw, align 4
  %1 = load i32, ptr %c.addr, align 4
  %and1 = and i32 %1, 7
  store i32 %and1, ptr %c.addr, align 4
  %2 = load i32, ptr %cf.addr, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %3 = load i32, ptr %c.addr, align 4
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %land.lhs.true3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %4 = load i32, ptr %c.addr, align 4
  %cmp2 = icmp eq i32 %4, 5
  br i1 %cmp2, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %lor.lhs.false, %land.lhs.true
  %5 = load i64, ptr %val.addr, align 8
  %cmp4 = icmp eq i64 %5, 1
  br i1 %cmp4, label %if.then, label %lor.lhs.false5

lor.lhs.false5:                                   ; preds = %land.lhs.true3
  %6 = load i64, ptr %val.addr, align 8
  %cmp6 = icmp eq i64 %6, -1
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false5, %land.lhs.true3
  %7 = load i32, ptr %c.addr, align 4
  %cmp7 = icmp eq i32 %7, 0
  %conv = zext i1 %cmp7 to i32
  %8 = load i64, ptr %val.addr, align 8
  %cmp8 = icmp slt i64 %8, 0
  %conv9 = zext i1 %cmp8 to i32
  %xor = xor i32 %conv, %conv9
  store i32 %xor, ptr %is_inc, align 4
  %9 = load ptr, ptr %s.addr, align 8
  %10 = load i32, ptr %rexw, align 4
  %add = add i32 255, %10
  %11 = load i32, ptr %is_inc, align 4
  %tobool10 = icmp ne i32 %11, 0
  %cond = select i1 %tobool10, i32 0, i32 1
  %12 = load i32, ptr %r0.addr, align 4
  call void @tcg_out_modrm(ptr noundef %9, i32 noundef %add, i32 noundef %cond, i32 noundef %12)
  br label %do.end

if.end:                                           ; preds = %lor.lhs.false5, %lor.lhs.false, %entry
  %13 = load i32, ptr %c.addr, align 4
  %cmp11 = icmp eq i32 %13, 4
  br i1 %cmp11, label %if.then13, label %if.end36

if.then13:                                        ; preds = %if.end
  %14 = load i64, ptr %val.addr, align 8
  %cmp14 = icmp eq i64 %14, 4294967295
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then13
  %15 = load ptr, ptr %s.addr, align 8
  %16 = load i32, ptr %r0.addr, align 4
  %17 = load i32, ptr %r0.addr, align 4
  call void @tcg_out_ext32u(ptr noundef %15, i32 noundef %16, i32 noundef %17)
  br label %do.end

if.end17:                                         ; preds = %if.then13
  %18 = load i64, ptr %val.addr, align 8
  %19 = load i64, ptr %val.addr, align 8
  %conv18 = trunc i64 %19 to i32
  %conv19 = zext i32 %conv18 to i64
  %cmp20 = icmp eq i64 %18, %conv19
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end17
  store i32 0, ptr %rexw, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.end17
  %20 = load i64, ptr %val.addr, align 8
  %cmp24 = icmp eq i64 %20, 255
  br i1 %cmp24, label %land.lhs.true26, label %if.end31

land.lhs.true26:                                  ; preds = %if.end23
  %21 = load i32, ptr %r0.addr, align 4
  %cmp27 = icmp slt i32 %21, 4
  br i1 %cmp27, label %if.then30, label %lor.lhs.false29

lor.lhs.false29:                                  ; preds = %land.lhs.true26
  br i1 true, label %if.then30, label %if.end31

if.then30:                                        ; preds = %lor.lhs.false29, %land.lhs.true26
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load i32, ptr %r0.addr, align 4
  %24 = load i32, ptr %r0.addr, align 4
  call void @tcg_out_ext8u(ptr noundef %22, i32 noundef %23, i32 noundef %24)
  br label %do.end

if.end31:                                         ; preds = %lor.lhs.false29, %if.end23
  %25 = load i64, ptr %val.addr, align 8
  %cmp32 = icmp eq i64 %25, 65535
  br i1 %cmp32, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end31
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i32, ptr %r0.addr, align 4
  %28 = load i32, ptr %r0.addr, align 4
  call void @tcg_out_ext16u(ptr noundef %26, i32 noundef %27, i32 noundef %28)
  br label %do.end

if.end35:                                         ; preds = %if.end31
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.end
  %29 = load i64, ptr %val.addr, align 8
  %30 = load i64, ptr %val.addr, align 8
  %conv37 = trunc i64 %30 to i8
  %conv38 = sext i8 %conv37 to i64
  %cmp39 = icmp eq i64 %29, %conv38
  br i1 %cmp39, label %if.then41, label %if.end44

if.then41:                                        ; preds = %if.end36
  %31 = load ptr, ptr %s.addr, align 8
  %32 = load i32, ptr %rexw, align 4
  %add42 = add i32 131, %32
  %33 = load i32, ptr %c.addr, align 4
  %34 = load i32, ptr %r0.addr, align 4
  call void @tcg_out_modrm(ptr noundef %31, i32 noundef %add42, i32 noundef %33, i32 noundef %34)
  %35 = load ptr, ptr %s.addr, align 8
  %36 = load i64, ptr %val.addr, align 8
  %conv43 = trunc i64 %36 to i8
  call void @tcg_out8(ptr noundef %35, i8 noundef zeroext %conv43)
  br label %do.end

if.end44:                                         ; preds = %if.end36
  %37 = load i32, ptr %rexw, align 4
  %cmp45 = icmp eq i32 %37, 0
  br i1 %cmp45, label %if.then52, label %lor.lhs.false47

lor.lhs.false47:                                  ; preds = %if.end44
  %38 = load i64, ptr %val.addr, align 8
  %39 = load i64, ptr %val.addr, align 8
  %conv48 = trunc i64 %39 to i32
  %conv49 = sext i32 %conv48 to i64
  %cmp50 = icmp eq i64 %38, %conv49
  br i1 %cmp50, label %if.then52, label %if.end55

if.then52:                                        ; preds = %lor.lhs.false47, %if.end44
  %40 = load ptr, ptr %s.addr, align 8
  %41 = load i32, ptr %rexw, align 4
  %add53 = add i32 129, %41
  %42 = load i32, ptr %c.addr, align 4
  %43 = load i32, ptr %r0.addr, align 4
  call void @tcg_out_modrm(ptr noundef %40, i32 noundef %add53, i32 noundef %42, i32 noundef %43)
  %44 = load ptr, ptr %s.addr, align 8
  %45 = load i64, ptr %val.addr, align 8
  %conv54 = trunc i64 %45 to i32
  call void @tcg_out32(ptr noundef %44, i32 noundef %conv54)
  br label %do.end

if.end55:                                         ; preds = %lor.lhs.false47
  br label %do.body

do.body:                                          ; preds = %if.end55
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 1367, ptr noundef @__func__.tgen_arithi, ptr noundef null) #15
  unreachable

do.end:                                           ; preds = %if.then52, %if.then41, %if.then34, %if.then30, %if.then16, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_ext32u(ptr noundef %s, i32 noundef %dest, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dest.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %dest.addr, align 4
  %2 = load i32, ptr %src.addr, align 4
  call void @tcg_out_modrm(ptr noundef %0, i32 noundef 139, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_ext8u(ptr noundef %s, i32 noundef %dest, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dest.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i32, ptr %src.addr, align 4
  %cmp = icmp ult i32 %0, 4
  br i1 %cmp, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  br i1 true, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  unreachable

if.end:                                           ; preds = %lor.lhs.false, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %dest.addr, align 4
  %3 = load i32, ptr %src.addr, align 4
  call void @tcg_out_modrm(ptr noundef %1, i32 noundef 16822, i32 noundef %2, i32 noundef %3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_ext16u(ptr noundef %s, i32 noundef %dest, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dest.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %dest.addr, align 4
  %2 = load i32, ptr %src.addr, align 4
  call void @tcg_out_modrm(ptr noundef %0, i32 noundef 439, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_nop_fill(ptr noundef %p, i32 noundef %count) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %count.addr = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  store i32 %count, ptr %count.addr, align 4
  %0 = load ptr, ptr %p.addr, align 8
  %1 = load i32, ptr %count.addr, align 4
  %conv = sext i32 %1 to i64
  call void @llvm.memset.p0.i64(ptr align 1 %0, i8 -112, i64 %conv, i1 false)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @patch_reloc(ptr noundef %code_ptr, i32 noundef %type, i64 noundef %value, i64 noundef %addend) #0 {
entry:
  %retval = alloca i1, align 1
  %code_ptr.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %value.addr = alloca i64, align 8
  %addend.addr = alloca i64, align 8
  store ptr %code_ptr, ptr %code_ptr.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i64 %value, ptr %value.addr, align 8
  store i64 %addend, ptr %addend.addr, align 8
  %0 = load i64, ptr %addend.addr, align 8
  %1 = load i64, ptr %value.addr, align 8
  %add = add i64 %1, %0
  store i64 %add, ptr %value.addr, align 8
  %2 = load i32, ptr %type.addr, align 4
  switch i32 %2, label %sw.default [
    i32 2, label %sw.bb
    i32 1, label %sw.bb3
    i32 23, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  %3 = load ptr, ptr %code_ptr.addr, align 8
  %call = call ptr @tcg_splitwx_to_rx(ptr noundef %3)
  %4 = ptrtoint ptr %call to i64
  %5 = load i64, ptr %value.addr, align 8
  %sub = sub i64 %5, %4
  store i64 %sub, ptr %value.addr, align 8
  %6 = load i64, ptr %value.addr, align 8
  %7 = load i64, ptr %value.addr, align 8
  %conv = trunc i64 %7 to i32
  %conv1 = sext i32 %conv to i64
  %cmp = icmp ne i64 %6, %conv1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.bb3

sw.bb3:                                           ; preds = %if.end, %entry
  %8 = load ptr, ptr %code_ptr.addr, align 8
  %9 = load i64, ptr %value.addr, align 8
  %conv4 = trunc i64 %9 to i32
  call void @tcg_patch32(ptr noundef %8, i32 noundef %conv4)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  %10 = load ptr, ptr %code_ptr.addr, align 8
  %call6 = call ptr @tcg_splitwx_to_rx(ptr noundef %10)
  %11 = ptrtoint ptr %call6 to i64
  %12 = load i64, ptr %value.addr, align 8
  %sub7 = sub i64 %12, %11
  store i64 %sub7, ptr %value.addr, align 8
  %13 = load i64, ptr %value.addr, align 8
  %14 = load i64, ptr %value.addr, align 8
  %conv8 = trunc i64 %14 to i8
  %conv9 = sext i8 %conv8 to i64
  %cmp10 = icmp ne i64 %13, %conv9
  br i1 %cmp10, label %if.then12, label %if.end13

if.then12:                                        ; preds = %sw.bb5
  store i1 false, ptr %retval, align 1
  br label %return

if.end13:                                         ; preds = %sw.bb5
  %15 = load ptr, ptr %code_ptr.addr, align 8
  %16 = load i64, ptr %value.addr, align 8
  %conv14 = trunc i64 %16 to i8
  call void @tcg_patch8(ptr noundef %15, i8 noundef zeroext %conv14)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 192, ptr noundef @__func__.patch_reloc, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %if.end13, %sw.bb3
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %sw.epilog, %if.then12, %if.then
  %17 = load i1, ptr %retval, align 1
  ret i1 %17
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_patch32(ptr noundef %p, i32 noundef %v) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %v.addr = alloca i32, align 4
  store ptr %p, ptr %p.addr, align 8
  store i32 %v, ptr %v.addr, align 4
  %0 = load ptr, ptr %p.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %0, ptr align 4 %v.addr, i64 4, i1 false)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_patch8(ptr noundef %p, i8 noundef zeroext %v) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %v.addr = alloca i8, align 1
  store ptr %p, ptr %p.addr, align 8
  store i8 %v, ptr %v.addr, align 1
  %0 = load i8, ptr %v.addr, align 1
  %1 = load ptr, ptr %p.addr, align 8
  store i8 %0, ptr %1, align 1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_global_alloc(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ts = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load ptr, ptr %s.addr, align 8
  %nb_globals = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %nb_globals, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %nb_temps = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 7
  %3 = load i32, ptr %nb_temps, align 8
  %cmp = icmp eq i32 %1, %3
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body1

do.body1:                                         ; preds = %do.end
  %4 = load ptr, ptr %s.addr, align 8
  %nb_globals2 = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 6
  %5 = load i32, ptr %nb_globals2, align 4
  %cmp3 = icmp slt i32 %5, 512
  br i1 %cmp3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %do.body1
  unreachable

if.end5:                                          ; preds = %do.body1
  br label %do.end6

do.end6:                                          ; preds = %if.end5
  %6 = load ptr, ptr %s.addr, align 8
  %nb_globals7 = getelementptr inbounds %struct.TCGContext, ptr %6, i32 0, i32 6
  %7 = load i32, ptr %nb_globals7, align 4
  %inc = add i32 %7, 1
  store i32 %inc, ptr %nb_globals7, align 4
  %8 = load ptr, ptr %s.addr, align 8
  %call = call ptr @tcg_temp_alloc(ptr noundef %8)
  store ptr %call, ptr %ts, align 8
  %9 = load ptr, ptr %ts, align 8
  %bf.load = load i64, ptr %9, align 8
  %bf.clear = and i64 %bf.load, -30064771073
  %bf.set = or i64 %bf.clear, 8589934592
  store i64 %bf.set, ptr %9, align 8
  %10 = load ptr, ptr %ts, align 8
  ret ptr %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @find_first_bit(ptr noundef %addr, i64 noundef %size) #0 {
entry:
  %retval = alloca i64, align 8
  %addr.addr = alloca ptr, align 8
  %size.addr = alloca i64, align 8
  %result = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %addr, ptr %addr.addr, align 8
  store i64 %size, ptr %size.addr, align 8
  store i64 0, ptr %result, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, ptr %result, align 8
  %1 = load i64, ptr %size.addr, align 8
  %cmp = icmp ult i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %addr.addr, align 8
  %incdec.ptr = getelementptr i64, ptr %2, i32 1
  store ptr %incdec.ptr, ptr %addr.addr, align 8
  %3 = load i64, ptr %2, align 8
  store i64 %3, ptr %tmp, align 8
  %4 = load i64, ptr %tmp, align 8
  %tobool = icmp ne i64 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %5 = load i64, ptr %tmp, align 8
  %call = call i32 @ctz64(i64 noundef %5)
  %conv = sext i32 %call to i64
  %6 = load i64, ptr %result, align 8
  %add = add i64 %6, %conv
  store i64 %add, ptr %result, align 8
  %7 = load i64, ptr %result, align 8
  %8 = load i64, ptr %size.addr, align 8
  %cmp1 = icmp ult i64 %7, %8
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %9 = load i64, ptr %result, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %10 = load i64, ptr %size.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %9, %cond.true ], [ %10, %cond.false ]
  store i64 %cond, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i64, ptr %result, align 8
  %add3 = add i64 %11, 64
  store i64 %add3, ptr %result, align 8
  br label %for.cond, !llvm.loop !91

for.end:                                          ; preds = %for.cond
  %12 = load i64, ptr %size.addr, align 8
  store i64 %12, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %cond.end
  %13 = load i64, ptr %retval, align 8
  ret i64 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @clear_bit(i64 noundef %nr, ptr noundef %addr) #0 {
entry:
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca ptr, align 8
  %mask = alloca i64, align 8
  %p = alloca ptr, align 8
  store i64 %nr, ptr %nr.addr, align 8
  store ptr %addr, ptr %addr.addr, align 8
  %0 = load i64, ptr %nr.addr, align 8
  %rem = urem i64 %0, 64
  %shl = shl i64 1, %rem
  store i64 %shl, ptr %mask, align 8
  %1 = load ptr, ptr %addr.addr, align 8
  %2 = load i64, ptr %nr.addr, align 8
  %div = udiv i64 %2, 64
  %add.ptr = getelementptr i64, ptr %1, i64 %div
  store ptr %add.ptr, ptr %p, align 8
  %3 = load i64, ptr %mask, align 8
  %not = xor i64 %3, -1
  %4 = load ptr, ptr %p, align 8
  %5 = load i64, ptr %4, align 8
  %and = and i64 %5, %not
  store i64 %and, ptr %4, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ctz64(i64 noundef %val) #0 {
entry:
  %val.addr = alloca i64, align 8
  store i64 %val, ptr %val.addr, align 8
  %0 = load i64, ptr %val.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, ptr %val.addr, align 8
  %2 = call i64 @llvm.cttz.i64(i64 %1, i1 true)
  %cast = trunc i64 %2 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %cast, %cond.true ], [ 64, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.cttz.i64(i64, i1 immarg) #1

; Function Attrs: noreturn nounwind sspstrong uwtable
define internal void @tcg_raise_tb_overflow(ptr noundef %s) #13 {
entry:
  %s.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %jmp_trans = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 44
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag], ptr %jmp_trans, i64 0, i64 0
  call void @siglongjmp(ptr noundef %arraydecay, i32 noundef -2) #19
  unreachable
}

; Function Attrs: noreturn nounwind
declare void @siglongjmp(ptr noundef, i32 noundef) #10

declare i32 @g_once_init_enter(ptr noundef) #7

declare void @g_once_init_leave(ptr noundef, i64 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ctz32(i32 noundef %val) #0 {
entry:
  %val.addr = alloca i32, align 4
  store i32 %val, ptr %val.addr, align 4
  %0 = load i32, ptr %val.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32, ptr %val.addr, align 4
  %2 = call i32 @llvm.cttz.i32(i32 %1, i1 true)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %2, %cond.true ], [ 32, %cond.false ]
  ret i32 %cond
}

declare void @tcg_gen_ext_i32_i64(ptr noundef, ptr noundef) #7

declare void @tcg_gen_extu_i32_i64(ptr noundef, ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @tcgv_i64_arg(ptr noundef %v) #0 {
entry:
  %v.addr = alloca ptr, align 8
  store ptr %v, ptr %v.addr, align 8
  %0 = load ptr, ptr %v.addr, align 8
  %call = call ptr @tcgv_i64_temp(ptr noundef %0)
  %call1 = call i64 @temp_arg(ptr noundef %call)
  ret i64 %call1
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.cttz.i32(i32, i1 immarg) #1

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @get_alignment_bits(i32 noundef %memop) #0 {
entry:
  %memop.addr = alloca i32, align 4
  %a = alloca i32, align 4
  store i32 %memop, ptr %memop.addr, align 4
  %0 = load i32, ptr %memop.addr, align 4
  %and = and i32 %0, 224
  store i32 %and, ptr %a, align 4
  %1 = load i32, ptr %a, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, ptr %a, align 4
  br label %if.end5

if.else:                                          ; preds = %entry
  %2 = load i32, ptr %a, align 4
  %cmp1 = icmp eq i32 %2, 224
  br i1 %cmp1, label %if.then2, label %if.else4

if.then2:                                         ; preds = %if.else
  %3 = load i32, ptr %memop.addr, align 4
  %and3 = and i32 %3, 7
  store i32 %and3, ptr %a, align 4
  br label %if.end

if.else4:                                         ; preds = %if.else
  %4 = load i32, ptr %a, align 4
  %shr = lshr i32 %4, 5
  store i32 %shr, ptr %a, align 4
  br label %if.end

if.end:                                           ; preds = %if.else4, %if.then2
  br label %if.end5

if.end5:                                          ; preds = %if.end, %if.then
  %5 = load i32, ptr %a, align 4
  ret i32 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_call_info(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %op.addr, align 8
  %bf.load = load i32, ptr %1, align 8
  %bf.lshr = lshr i32 %bf.load, 24
  %2 = load ptr, ptr %op.addr, align 8
  %bf.load1 = load i32, ptr %2, align 8
  %bf.lshr2 = lshr i32 %bf.load1, 16
  %bf.clear = and i32 %bf.lshr2, 255
  %add = add i32 %bf.lshr, %bf.clear
  %add3 = add i32 %add, 1
  %idxprom = sext i32 %add3 to i64
  %arrayidx = getelementptr [0 x i64], ptr %args, i64 0, i64 %idxprom
  %3 = load i64, ptr %arrayidx, align 8
  %4 = inttoptr i64 %3 to ptr
  ret ptr %4
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_call_func(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %op.addr, align 8
  %bf.load = load i32, ptr %1, align 8
  %bf.lshr = lshr i32 %bf.load, 24
  %2 = load ptr, ptr %op.addr, align 8
  %bf.load1 = load i32, ptr %2, align 8
  %bf.lshr2 = lshr i32 %bf.load1, 16
  %bf.clear = and i32 %bf.lshr2, 255
  %add = add i32 %bf.lshr, %bf.clear
  %idxprom = sext i32 %add to i64
  %arrayidx = getelementptr [0 x i64], ptr %args, i64 0, i64 %idxprom
  %3 = load i64, ptr %arrayidx, align 8
  %4 = inttoptr i64 %3 to ptr
  ret ptr %4
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_get_arg_str(ptr noundef %s, ptr noundef %buf, i32 noundef %buf_size, i64 noundef %arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %buf_size.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i32 %buf_size, ptr %buf_size.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %buf.addr, align 8
  %2 = load i32, ptr %buf_size.addr, align 4
  %3 = load i64, ptr %arg.addr, align 8
  %call = call ptr @arg_temp(i64 noundef %3)
  %call1 = call ptr @tcg_get_arg_str_ptr(ptr noundef %0, ptr noundef %1, i32 noundef %2, ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @get_memop(i32 noundef %oi) #0 {
entry:
  %oi.addr = alloca i32, align 4
  store i32 %oi, ptr %oi.addr, align 4
  %0 = load i32, ptr %oi.addr, align 4
  %shr = lshr i32 %0, 4
  ret i32 %shr
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @get_mmuidx(i32 noundef %oi) #0 {
entry:
  %oi.addr = alloca i32, align 4
  store i32 %oi, ptr %oi.addr, align 4
  %0 = load i32, ptr %oi.addr, align 4
  %and = and i32 %0, 15
  ret i32 %and
}

declare i32 @putc(i32 noundef, ptr noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @output_pref(ptr noundef %op, i32 noundef %i) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %i.addr = alloca i32, align 4
  store ptr %op, ptr %op.addr, align 8
  store i32 %i, ptr %i.addr, align 4
  %0 = load i32, ptr %i.addr, align 4
  %conv = zext i32 %0 to i64
  %cmp = icmp ult i64 %conv, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %op.addr, align 8
  %output_pref = getelementptr inbounds %struct.TCGOp, ptr %1, i32 0, i32 3
  %2 = load i32, ptr %i.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr [2 x i32], ptr %output_pref, i64 0, i64 %idxprom
  %3 = load i32, ptr %arrayidx, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %3, %cond.true ], [ 0, %cond.false ]
  ret i32 %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @tcg_get_arg_str_ptr(ptr noundef %s, ptr noundef %buf, i32 noundef %buf_size, ptr noundef %ts) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %buf.addr = alloca ptr, align 8
  %buf_size.addr = alloca i32, align 4
  %ts.addr = alloca ptr, align 8
  %idx = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i32 %buf_size, ptr %buf_size.addr, align 4
  store ptr %ts, ptr %ts.addr, align 8
  %0 = load ptr, ptr %ts.addr, align 8
  %call = call i64 @temp_idx(ptr noundef %0)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %idx, align 4
  %1 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %1, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  switch i32 %bf.cast, label %sw.epilog31 [
    i32 3, label %sw.bb
    i32 2, label %sw.bb
    i32 1, label %sw.bb1
    i32 0, label %sw.bb4
    i32 4, label %sw.bb9
  ]

sw.bb:                                            ; preds = %entry, %entry
  %2 = load ptr, ptr %buf.addr, align 8
  %3 = load i32, ptr %buf_size.addr, align 4
  %4 = load ptr, ptr %ts.addr, align 8
  %name = getelementptr inbounds %struct.TCGTemp, ptr %4, i32 0, i32 4
  %5 = load ptr, ptr %name, align 8
  call void @pstrcpy(ptr noundef %2, i32 noundef %3, ptr noundef %5)
  br label %sw.epilog31

sw.bb1:                                           ; preds = %entry
  %6 = load ptr, ptr %buf.addr, align 8
  %7 = load i32, ptr %buf_size.addr, align 4
  %conv2 = sext i32 %7 to i64
  %8 = load i32, ptr %idx, align 4
  %9 = load ptr, ptr %s.addr, align 8
  %nb_globals = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 6
  %10 = load i32, ptr %nb_globals, align 4
  %sub = sub i32 %8, %10
  %call3 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %6, i64 noundef %conv2, ptr noundef @.str.82, i32 noundef %sub) #20
  br label %sw.epilog31

sw.bb4:                                           ; preds = %entry
  %11 = load ptr, ptr %buf.addr, align 8
  %12 = load i32, ptr %buf_size.addr, align 4
  %conv5 = sext i32 %12 to i64
  %13 = load i32, ptr %idx, align 4
  %14 = load ptr, ptr %s.addr, align 8
  %nb_globals6 = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 6
  %15 = load i32, ptr %nb_globals6, align 4
  %sub7 = sub i32 %13, %15
  %call8 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %11, i64 noundef %conv5, ptr noundef @.str.83, i32 noundef %sub7) #20
  br label %sw.epilog31

sw.bb9:                                           ; preds = %entry
  %16 = load ptr, ptr %ts.addr, align 8
  %bf.load10 = load i64, ptr %16, align 8
  %bf.lshr11 = lshr i64 %bf.load10, 24
  %bf.clear12 = and i64 %bf.lshr11, 255
  %bf.cast13 = trunc i64 %bf.clear12 to i32
  switch i32 %bf.cast13, label %sw.default [
    i32 0, label %sw.bb14
    i32 1, label %sw.bb18
    i32 3, label %sw.bb22
    i32 4, label %sw.bb22
    i32 5, label %sw.bb22
  ]

sw.bb14:                                          ; preds = %sw.bb9
  %17 = load ptr, ptr %buf.addr, align 8
  %18 = load i32, ptr %buf_size.addr, align 4
  %conv15 = sext i32 %18 to i64
  %19 = load ptr, ptr %ts.addr, align 8
  %val = getelementptr inbounds %struct.TCGTemp, ptr %19, i32 0, i32 1
  %20 = load i64, ptr %val, align 8
  %conv16 = trunc i64 %20 to i32
  %call17 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %17, i64 noundef %conv15, ptr noundef @.str.84, i32 noundef %conv16) #20
  br label %sw.epilog

sw.bb18:                                          ; preds = %sw.bb9
  %21 = load ptr, ptr %buf.addr, align 8
  %22 = load i32, ptr %buf_size.addr, align 4
  %conv19 = sext i32 %22 to i64
  %23 = load ptr, ptr %ts.addr, align 8
  %val20 = getelementptr inbounds %struct.TCGTemp, ptr %23, i32 0, i32 1
  %24 = load i64, ptr %val20, align 8
  %call21 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %21, i64 noundef %conv19, ptr noundef @.str.85, i64 noundef %24) #20
  br label %sw.epilog

sw.bb22:                                          ; preds = %sw.bb9, %sw.bb9, %sw.bb9
  %25 = load ptr, ptr %buf.addr, align 8
  %26 = load i32, ptr %buf_size.addr, align 4
  %conv23 = sext i32 %26 to i64
  %27 = load ptr, ptr %ts.addr, align 8
  %bf.load24 = load i64, ptr %27, align 8
  %bf.lshr25 = lshr i64 %bf.load24, 24
  %bf.clear26 = and i64 %bf.lshr25, 255
  %bf.cast27 = trunc i64 %bf.clear26 to i32
  %sub28 = sub i32 %bf.cast27, 3
  %shl = shl i32 64, %sub28
  %28 = load ptr, ptr %ts.addr, align 8
  %val29 = getelementptr inbounds %struct.TCGTemp, ptr %28, i32 0, i32 1
  %29 = load i64, ptr %val29, align 8
  %call30 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %25, i64 noundef %conv23, ptr noundef @.str.86, i32 noundef %shl, i64 noundef %29) #20
  br label %sw.epilog

sw.default:                                       ; preds = %sw.bb9
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 2454, ptr noundef @__func__.tcg_get_arg_str_ptr, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb22, %sw.bb18, %sw.bb14
  br label %sw.epilog31

sw.epilog31:                                      ; preds = %sw.epilog, %sw.bb4, %sw.bb1, %sw.bb, %entry
  %30 = load ptr, ptr %buf.addr, align 8
  ret ptr %30
}

declare void @pstrcpy(ptr noundef, i32 noundef, ptr noundef) #7

; Function Attrs: nounwind
declare i32 @snprintf(ptr noundef, i64 noundef, ptr noundef, ...) #14

; Function Attrs: nounwind sspstrong uwtable
define internal void @move_label_uses(ptr noundef %to, ptr noundef %from) #0 {
entry:
  %to.addr = alloca ptr, align 8
  %from.addr = alloca ptr, align 8
  %u = alloca ptr, align 8
  %op = alloca ptr, align 8
  store ptr %to, ptr %to.addr, align 8
  store ptr %from, ptr %from.addr, align 8
  %0 = load ptr, ptr %from.addr, align 8
  %branches = getelementptr inbounds %struct.TCGLabel, ptr %0, i32 0, i32 4
  %sqh_first = getelementptr inbounds %struct.anon, ptr %branches, i32 0, i32 0
  %1 = load ptr, ptr %sqh_first, align 8
  store ptr %1, ptr %u, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load ptr, ptr %u, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %u, align 8
  %op1 = getelementptr inbounds %struct.TCGLabelUse, ptr %3, i32 0, i32 1
  %4 = load ptr, ptr %op1, align 8
  store ptr %4, ptr %op, align 8
  %5 = load ptr, ptr %op, align 8
  %bf.load = load i32, ptr %5, align 8
  %bf.clear = and i32 %bf.load, 255
  switch i32 %bf.clear, label %sw.default [
    i32 3, label %sw.bb
    i32 38, label %sw.bb2
    i32 103, label %sw.bb2
    i32 45, label %sw.bb6
  ]

sw.bb:                                            ; preds = %for.body
  %6 = load ptr, ptr %to.addr, align 8
  %call = call i64 @label_arg(ptr noundef %6)
  %7 = load ptr, ptr %op, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %7, i32 0, i32 4
  %arrayidx = getelementptr [0 x i64], ptr %args, i64 0, i64 0
  store i64 %call, ptr %arrayidx, align 8
  br label %sw.epilog

sw.bb2:                                           ; preds = %for.body, %for.body
  %8 = load ptr, ptr %to.addr, align 8
  %call3 = call i64 @label_arg(ptr noundef %8)
  %9 = load ptr, ptr %op, align 8
  %args4 = getelementptr inbounds %struct.TCGOp, ptr %9, i32 0, i32 4
  %arrayidx5 = getelementptr [0 x i64], ptr %args4, i64 0, i64 3
  store i64 %call3, ptr %arrayidx5, align 8
  br label %sw.epilog

sw.bb6:                                           ; preds = %for.body
  %10 = load ptr, ptr %to.addr, align 8
  %call7 = call i64 @label_arg(ptr noundef %10)
  %11 = load ptr, ptr %op, align 8
  %args8 = getelementptr inbounds %struct.TCGOp, ptr %11, i32 0, i32 4
  %arrayidx9 = getelementptr [0 x i64], ptr %args8, i64 0, i64 5
  store i64 %call7, ptr %arrayidx9, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 3246, ptr noundef @__func__.move_label_uses, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb6, %sw.bb2, %sw.bb
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %12 = load ptr, ptr %u, align 8
  %next = getelementptr inbounds %struct.TCGLabelUse, ptr %12, i32 0, i32 0
  %sqe_next = getelementptr inbounds %struct.anon.6, ptr %next, i32 0, i32 0
  %13 = load ptr, ptr %sqe_next, align 8
  store ptr %13, ptr %u, align 8
  br label %for.cond, !llvm.loop !92

for.end:                                          ; preds = %for.cond
  br label %do.body10

do.body10:                                        ; preds = %for.end
  %14 = load ptr, ptr %from.addr, align 8
  %branches11 = getelementptr inbounds %struct.TCGLabel, ptr %14, i32 0, i32 4
  %sqh_first12 = getelementptr inbounds %struct.anon, ptr %branches11, i32 0, i32 0
  %15 = load ptr, ptr %sqh_first12, align 8
  %cmp = icmp eq ptr %15, null
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body10
  %16 = load ptr, ptr %from.addr, align 8
  %branches13 = getelementptr inbounds %struct.TCGLabel, ptr %16, i32 0, i32 4
  %sqh_first14 = getelementptr inbounds %struct.anon, ptr %branches13, i32 0, i32 0
  %17 = load ptr, ptr %sqh_first14, align 8
  %18 = load ptr, ptr %to.addr, align 8
  %branches15 = getelementptr inbounds %struct.TCGLabel, ptr %18, i32 0, i32 4
  %sqh_last = getelementptr inbounds %struct.anon, ptr %branches15, i32 0, i32 1
  %19 = load ptr, ptr %sqh_last, align 8
  store ptr %17, ptr %19, align 8
  %20 = load ptr, ptr %from.addr, align 8
  %branches16 = getelementptr inbounds %struct.TCGLabel, ptr %20, i32 0, i32 4
  %sqh_last17 = getelementptr inbounds %struct.anon, ptr %branches16, i32 0, i32 1
  %21 = load ptr, ptr %sqh_last17, align 8
  %22 = load ptr, ptr %to.addr, align 8
  %branches18 = getelementptr inbounds %struct.TCGLabel, ptr %22, i32 0, i32 4
  %sqh_last19 = getelementptr inbounds %struct.anon, ptr %branches18, i32 0, i32 1
  store ptr %21, ptr %sqh_last19, align 8
  br label %do.body20

do.body20:                                        ; preds = %if.then
  %23 = load ptr, ptr %from.addr, align 8
  %branches21 = getelementptr inbounds %struct.TCGLabel, ptr %23, i32 0, i32 4
  %sqh_first22 = getelementptr inbounds %struct.anon, ptr %branches21, i32 0, i32 0
  store ptr null, ptr %sqh_first22, align 8
  %24 = load ptr, ptr %from.addr, align 8
  %branches23 = getelementptr inbounds %struct.TCGLabel, ptr %24, i32 0, i32 4
  %sqh_first24 = getelementptr inbounds %struct.anon, ptr %branches23, i32 0, i32 0
  %25 = load ptr, ptr %from.addr, align 8
  %branches25 = getelementptr inbounds %struct.TCGLabel, ptr %25, i32 0, i32 4
  %sqh_last26 = getelementptr inbounds %struct.anon, ptr %branches25, i32 0, i32 1
  store ptr %sqh_first24, ptr %sqh_last26, align 8
  br label %do.end27

do.end27:                                         ; preds = %do.body20
  br label %if.end

if.end:                                           ; preds = %do.end27, %do.body10
  br label %do.end28

do.end28:                                         ; preds = %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_call_flags(ptr noundef %op) #0 {
entry:
  %op.addr = alloca ptr, align 8
  store ptr %op, ptr %op.addr, align 8
  %0 = load ptr, ptr %op.addr, align 8
  %call = call ptr @tcg_call_info(ptr noundef %0)
  %flags = getelementptr inbounds %struct.TCGHelperInfo, ptr %call, i32 0, i32 3
  %bf.load = load i64, ptr %flags, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  ret i32 %bf.cast
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @label_arg(ptr noundef %l) #0 {
entry:
  %l.addr = alloca ptr, align 8
  store ptr %l, ptr %l.addr, align 8
  %0 = load ptr, ptr %l.addr, align 8
  %1 = ptrtoint ptr %0 to i64
  ret i64 %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @la_func_end(ptr noundef %s, i32 noundef %ng, i32 noundef %nt) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ng.addr = alloca i32, align 4
  %nt.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %ng, ptr %ng.addr, align 4
  store i32 %nt, ptr %nt.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %ng.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 37
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  %state = getelementptr inbounds %struct.TCGTemp, ptr %arrayidx, i32 0, i32 5
  store i64 3, ptr %state, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %temps1 = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 37
  %5 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %5 to i64
  %arrayidx3 = getelementptr [512 x %struct.TCGTemp], ptr %temps1, i64 0, i64 %idxprom2
  call void @la_reset_pref(ptr noundef %arrayidx3)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, ptr %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !93

for.end:                                          ; preds = %for.cond
  %7 = load i32, ptr %ng.addr, align 4
  store i32 %7, ptr %i, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc14, %for.end
  %8 = load i32, ptr %i, align 4
  %9 = load i32, ptr %nt.addr, align 4
  %cmp5 = icmp slt i32 %8, %9
  br i1 %cmp5, label %for.body6, label %for.end16

for.body6:                                        ; preds = %for.cond4
  %10 = load ptr, ptr %s.addr, align 8
  %temps7 = getelementptr inbounds %struct.TCGContext, ptr %10, i32 0, i32 37
  %11 = load i32, ptr %i, align 4
  %idxprom8 = sext i32 %11 to i64
  %arrayidx9 = getelementptr [512 x %struct.TCGTemp], ptr %temps7, i64 0, i64 %idxprom8
  %state10 = getelementptr inbounds %struct.TCGTemp, ptr %arrayidx9, i32 0, i32 5
  store i64 1, ptr %state10, align 8
  %12 = load ptr, ptr %s.addr, align 8
  %temps11 = getelementptr inbounds %struct.TCGContext, ptr %12, i32 0, i32 37
  %13 = load i32, ptr %i, align 4
  %idxprom12 = sext i32 %13 to i64
  %arrayidx13 = getelementptr [512 x %struct.TCGTemp], ptr %temps11, i64 0, i64 %idxprom12
  call void @la_reset_pref(ptr noundef %arrayidx13)
  br label %for.inc14

for.inc14:                                        ; preds = %for.body6
  %14 = load i32, ptr %i, align 4
  %inc15 = add i32 %14, 1
  store i32 %inc15, ptr %i, align 4
  br label %for.cond4, !llvm.loop !94

for.end16:                                        ; preds = %for.cond4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @la_reset_pref(ptr noundef %ts) #0 {
entry:
  %ts.addr = alloca ptr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  %0 = load ptr, ptr %ts.addr, align 8
  %state = getelementptr inbounds %struct.TCGTemp, ptr %0, i32 0, i32 5
  %1 = load i64, ptr %state, align 8
  %cmp = icmp eq i64 %1, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %2, align 8
  %bf.lshr = lshr i64 %bf.load, 24
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  %idxprom = zext i32 %bf.cast to i64
  %arrayidx = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom
  %3 = load i32, ptr %arrayidx, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %3, %cond.false ]
  %4 = load ptr, ptr %ts.addr, align 8
  %call = call ptr @la_temp_pref(ptr noundef %4)
  store i32 %cond, ptr %call, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @la_global_kill(ptr noundef %s, i32 noundef %ng) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ng.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %ng, ptr %ng.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %ng.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 37
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  %state = getelementptr inbounds %struct.TCGTemp, ptr %arrayidx, i32 0, i32 5
  store i64 3, ptr %state, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %temps1 = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 37
  %5 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %5 to i64
  %arrayidx3 = getelementptr [512 x %struct.TCGTemp], ptr %temps1, i64 0, i64 %idxprom2
  call void @la_reset_pref(ptr noundef %arrayidx3)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, ptr %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !95

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @la_global_sync(ptr noundef %s, i32 noundef %ng) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ng.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %state = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %ng, ptr %ng.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %ng.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 37
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  %state1 = getelementptr inbounds %struct.TCGTemp, ptr %arrayidx, i32 0, i32 5
  %4 = load i64, ptr %state1, align 8
  %conv = trunc i64 %4 to i32
  store i32 %conv, ptr %state, align 4
  %5 = load i32, ptr %state, align 4
  %or = or i32 %5, 2
  %conv2 = sext i32 %or to i64
  %6 = load ptr, ptr %s.addr, align 8
  %temps3 = getelementptr inbounds %struct.TCGContext, ptr %6, i32 0, i32 37
  %7 = load i32, ptr %i, align 4
  %idxprom4 = sext i32 %7 to i64
  %arrayidx5 = getelementptr [512 x %struct.TCGTemp], ptr %temps3, i64 0, i64 %idxprom4
  %state6 = getelementptr inbounds %struct.TCGTemp, ptr %arrayidx5, i32 0, i32 5
  store i64 %conv2, ptr %state6, align 8
  %8 = load i32, ptr %state, align 4
  %cmp7 = icmp eq i32 %8, 1
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %9 = load ptr, ptr %s.addr, align 8
  %temps9 = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 37
  %10 = load i32, ptr %i, align 4
  %idxprom10 = sext i32 %10 to i64
  %arrayidx11 = getelementptr [512 x %struct.TCGTemp], ptr %temps9, i64 0, i64 %idxprom10
  call void @la_reset_pref(ptr noundef %arrayidx11)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i32, ptr %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !96

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @la_cross_call(ptr noundef %s, i32 noundef %nt) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %nt.addr = alloca i32, align 4
  %mask = alloca i32, align 4
  %i = alloca i32, align 4
  %ts = alloca ptr, align 8
  %pset = alloca ptr, align 8
  %set = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %nt, ptr %nt.addr, align 4
  %0 = load i32, ptr @tcg_target_call_clobber_regs, align 4
  %not = xor i32 %0, -1
  store i32 %not, ptr %mask, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %nt.addr, align 4
  %cmp = icmp slt i32 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %3, i32 0, i32 37
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %ts, align 8
  %5 = load ptr, ptr %ts, align 8
  %state = getelementptr inbounds %struct.TCGTemp, ptr %5, i32 0, i32 5
  %6 = load i64, ptr %state, align 8
  %and = and i64 %6, 1
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end7, label %if.then

if.then:                                          ; preds = %for.body
  %7 = load ptr, ptr %ts, align 8
  %call = call ptr @la_temp_pref(ptr noundef %7)
  store ptr %call, ptr %pset, align 8
  %8 = load ptr, ptr %pset, align 8
  %9 = load i32, ptr %8, align 4
  store i32 %9, ptr %set, align 4
  %10 = load i32, ptr %mask, align 4
  %11 = load i32, ptr %set, align 4
  %and1 = and i32 %11, %10
  store i32 %and1, ptr %set, align 4
  %12 = load i32, ptr %set, align 4
  %cmp2 = icmp eq i32 %12, 0
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %13 = load ptr, ptr %ts, align 8
  %bf.load = load i64, ptr %13, align 8
  %bf.lshr = lshr i64 %bf.load, 24
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  %idxprom4 = zext i32 %bf.cast to i64
  %arrayidx5 = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom4
  %14 = load i32, ptr %arrayidx5, align 4
  %15 = load i32, ptr %mask, align 4
  %and6 = and i32 %14, %15
  store i32 %and6, ptr %set, align 4
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %16 = load i32, ptr %set, align 4
  %17 = load ptr, ptr %pset, align 8
  store i32 %16, ptr %17, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %18 = load i32, ptr %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !97

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @arg_slot_reg_p(i32 noundef %arg_slot) #0 {
entry:
  %arg_slot.addr = alloca i32, align 4
  %nreg = alloca i32, align 4
  store i32 %arg_slot, ptr %arg_slot.addr, align 4
  store i32 6, ptr %nreg, align 4
  %0 = load i32, ptr %arg_slot.addr, align 4
  %1 = load i32, ptr %nreg, align 4
  %cmp = icmp ult i32 %0, %1
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @la_temp_pref(ptr noundef %ts) #0 {
entry:
  %ts.addr = alloca ptr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  %0 = load ptr, ptr %ts.addr, align 8
  %state_ptr = getelementptr inbounds %struct.TCGTemp, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %state_ptr, align 8
  ret ptr %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @la_bb_sync(ptr noundef %s, i32 noundef %ng, i32 noundef %nt) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ng.addr = alloca i32, align 4
  %nt.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %ts = alloca ptr, align 8
  %state = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %ng, ptr %ng.addr, align 4
  store i32 %nt, ptr %nt.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %ng.addr, align 4
  call void @la_global_sync(ptr noundef %0, i32 noundef %1)
  %2 = load i32, ptr %ng.addr, align 4
  store i32 %2, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32, ptr %i, align 4
  %4 = load i32, ptr %nt.addr, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %5, i32 0, i32 37
  %6 = load i32, ptr %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %ts, align 8
  %7 = load ptr, ptr %ts, align 8
  %bf.load = load i64, ptr %7, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  switch i32 %bf.cast, label %sw.default [
    i32 1, label %sw.bb
    i32 0, label %sw.bb6
    i32 4, label %sw.bb6
  ]

sw.bb:                                            ; preds = %for.body
  %8 = load ptr, ptr %ts, align 8
  %state1 = getelementptr inbounds %struct.TCGTemp, ptr %8, i32 0, i32 5
  %9 = load i64, ptr %state1, align 8
  %conv = trunc i64 %9 to i32
  store i32 %conv, ptr %state, align 4
  %10 = load i32, ptr %state, align 4
  %or = or i32 %10, 2
  %conv2 = sext i32 %or to i64
  %11 = load ptr, ptr %ts, align 8
  %state3 = getelementptr inbounds %struct.TCGTemp, ptr %11, i32 0, i32 5
  store i64 %conv2, ptr %state3, align 8
  %12 = load i32, ptr %state, align 4
  %cmp4 = icmp ne i32 %12, 1
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  br label %for.inc

if.end:                                           ; preds = %sw.bb
  br label %sw.epilog

sw.bb6:                                           ; preds = %for.body, %for.body
  br label %for.inc

sw.default:                                       ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 3450, ptr noundef @__func__.la_bb_sync, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %if.end
  %13 = load ptr, ptr %s.addr, align 8
  %temps7 = getelementptr inbounds %struct.TCGContext, ptr %13, i32 0, i32 37
  %14 = load i32, ptr %i, align 4
  %idxprom8 = sext i32 %14 to i64
  %arrayidx9 = getelementptr [512 x %struct.TCGTemp], ptr %temps7, i64 0, i64 %idxprom8
  call void @la_reset_pref(ptr noundef %arrayidx9)
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog, %sw.bb6, %if.then
  %15 = load i32, ptr %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !98

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @la_bb_end(ptr noundef %s, i32 noundef %ng, i32 noundef %nt) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ng.addr = alloca i32, align 4
  %nt.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %ts = alloca ptr, align 8
  %state = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %ng, ptr %ng.addr, align 4
  store i32 %nt, ptr %nt.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, ptr %i, align 4
  %1 = load i32, ptr %nt.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 37
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %ts, align 8
  %4 = load ptr, ptr %ts, align 8
  %bf.load = load i64, ptr %4, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  switch i32 %bf.cast, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb
    i32 1, label %sw.bb
    i32 0, label %sw.bb1
    i32 4, label %sw.bb1
  ]

sw.bb:                                            ; preds = %for.body, %for.body, %for.body
  store i32 3, ptr %state, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %for.body, %for.body
  store i32 1, ptr %state, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 3403, ptr noundef @__func__.la_bb_end, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb1, %sw.bb
  %5 = load i32, ptr %state, align 4
  %conv = sext i32 %5 to i64
  %6 = load ptr, ptr %ts, align 8
  %state2 = getelementptr inbounds %struct.TCGTemp, ptr %6, i32 0, i32 5
  store i64 %conv, ptr %state2, align 8
  %7 = load ptr, ptr %ts, align 8
  call void @la_reset_pref(ptr noundef %7)
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %8 = load i32, ptr %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !99

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @temp_readonly(ptr noundef %ts) #0 {
entry:
  %ts.addr = alloca ptr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  %0 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %0, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp = icmp sge i32 %bf.cast, 3
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_reg_alloc_do_movi(ptr noundef %s, ptr noundef %ots, i64 noundef %val, i32 noundef %arg_life, i32 noundef %preferred_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ots.addr = alloca ptr, align 8
  %val.addr = alloca i64, align 8
  %arg_life.addr = alloca i32, align 4
  %preferred_regs.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ots, ptr %ots.addr, align 8
  store i64 %val, ptr %val.addr, align 8
  store i32 %arg_life, ptr %arg_life.addr, align 4
  store i32 %preferred_regs, ptr %preferred_regs.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load ptr, ptr %ots.addr, align 8
  %call = call zeroext i1 @temp_readonly(ptr noundef %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load ptr, ptr %ots.addr, align 8
  call void @set_temp_val_nonreg(ptr noundef %1, ptr noundef %2, i32 noundef 3)
  %3 = load i64, ptr %val.addr, align 8
  %4 = load ptr, ptr %ots.addr, align 8
  %val1 = getelementptr inbounds %struct.TCGTemp, ptr %4, i32 0, i32 1
  store i64 %3, ptr %val1, align 8
  %5 = load ptr, ptr %ots.addr, align 8
  %bf.load = load i64, ptr %5, align 8
  %bf.clear = and i64 %bf.load, -137438953473
  %bf.set = or i64 %bf.clear, 0
  store i64 %bf.set, ptr %5, align 8
  %6 = load i32, ptr %arg_life.addr, align 4
  %and = and i32 %6, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.else

if.then2:                                         ; preds = %do.end
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load ptr, ptr %ots.addr, align 8
  %9 = load ptr, ptr %s.addr, align 8
  %reserved_regs = getelementptr inbounds %struct.TCGContext, ptr %9, i32 0, i32 16
  %10 = load i32, ptr %reserved_regs, align 4
  %11 = load i32, ptr %preferred_regs.addr, align 4
  %12 = load i32, ptr %arg_life.addr, align 4
  %and3 = and i32 %12, 16
  call void @temp_sync(ptr noundef %7, ptr noundef %8, i32 noundef %10, i32 noundef %11, i32 noundef %and3)
  br label %if.end8

if.else:                                          ; preds = %do.end
  %13 = load i32, ptr %arg_life.addr, align 4
  %and4 = and i32 %13, 16
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.else
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load ptr, ptr %ots.addr, align 8
  call void @temp_dead(ptr noundef %14, ptr noundef %15)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.else
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.then2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @temp_load(ptr noundef %s, ptr noundef %ts, i32 noundef %desired_regs, i32 noundef %allocated_regs, i32 noundef %preferred_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ts.addr = alloca ptr, align 8
  %desired_regs.addr = alloca i32, align 4
  %allocated_regs.addr = alloca i32, align 4
  %preferred_regs.addr = alloca i32, align 4
  %reg = alloca i32, align 4
  %val14 = alloca i64, align 8
  %vece = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  store i32 %desired_regs, ptr %desired_regs.addr, align 4
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  store i32 %preferred_regs, ptr %preferred_regs.addr, align 4
  %0 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %0, align 8
  %bf.lshr = lshr i64 %bf.load, 8
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  switch i32 %bf.cast, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb1
    i32 2, label %sw.bb44
    i32 0, label %sw.bb61
  ]

sw.bb:                                            ; preds = %entry
  br label %return

sw.bb1:                                           ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %desired_regs.addr, align 4
  %3 = load i32, ptr %allocated_regs.addr, align 4
  %4 = load i32, ptr %preferred_regs.addr, align 4
  %5 = load ptr, ptr %ts.addr, align 8
  %bf.load2 = load i64, ptr %5, align 8
  %bf.lshr3 = lshr i64 %bf.load2, 36
  %bf.clear4 = and i64 %bf.lshr3, 1
  %bf.cast5 = trunc i64 %bf.clear4 to i32
  %tobool = icmp ne i32 %bf.cast5, 0
  %call = call i32 @tcg_reg_alloc(ptr noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i1 noundef zeroext %tobool)
  store i32 %call, ptr %reg, align 4
  %6 = load ptr, ptr %ts.addr, align 8
  %bf.load6 = load i64, ptr %6, align 8
  %bf.lshr7 = lshr i64 %bf.load6, 24
  %bf.clear8 = and i64 %bf.lshr7, 255
  %bf.cast9 = trunc i64 %bf.clear8 to i32
  %cmp = icmp sle i32 %bf.cast9, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb1
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load ptr, ptr %ts.addr, align 8
  %bf.load10 = load i64, ptr %8, align 8
  %bf.lshr11 = lshr i64 %bf.load10, 24
  %bf.clear12 = and i64 %bf.lshr11, 255
  %bf.cast13 = trunc i64 %bf.clear12 to i32
  %9 = load i32, ptr %reg, align 4
  %10 = load ptr, ptr %ts.addr, align 8
  %val = getelementptr inbounds %struct.TCGTemp, ptr %10, i32 0, i32 1
  %11 = load i64, ptr %val, align 8
  call void @tcg_out_movi(ptr noundef %7, i32 noundef %bf.cast13, i32 noundef %9, i64 noundef %11)
  br label %if.end41

if.else:                                          ; preds = %sw.bb1
  %12 = load ptr, ptr %ts.addr, align 8
  %val15 = getelementptr inbounds %struct.TCGTemp, ptr %12, i32 0, i32 1
  %13 = load i64, ptr %val15, align 8
  store i64 %13, ptr %val14, align 8
  store i32 3, ptr %vece, align 4
  %14 = load i64, ptr %val14, align 8
  %15 = load i64, ptr %val14, align 8
  %conv = trunc i64 %15 to i8
  %conv16 = zext i8 %conv to i64
  %mul = mul i64 72340172838076673, %conv16
  %cmp17 = icmp eq i64 %14, %mul
  br i1 %cmp17, label %if.then19, label %if.else20

if.then19:                                        ; preds = %if.else
  store i32 0, ptr %vece, align 4
  br label %if.end35

if.else20:                                        ; preds = %if.else
  %16 = load i64, ptr %val14, align 8
  %17 = load i64, ptr %val14, align 8
  %conv21 = trunc i64 %17 to i16
  %conv22 = zext i16 %conv21 to i64
  %mul23 = mul i64 281479271743489, %conv22
  %cmp24 = icmp eq i64 %16, %mul23
  br i1 %cmp24, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.else20
  store i32 1, ptr %vece, align 4
  br label %if.end34

if.else27:                                        ; preds = %if.else20
  %18 = load i64, ptr %val14, align 8
  %19 = load i64, ptr %val14, align 8
  %conv28 = trunc i64 %19 to i32
  %conv29 = zext i32 %conv28 to i64
  %mul30 = mul i64 4294967297, %conv29
  %cmp31 = icmp eq i64 %18, %mul30
  br i1 %cmp31, label %if.then33, label %if.end

if.then33:                                        ; preds = %if.else27
  store i32 2, ptr %vece, align 4
  br label %if.end

if.end:                                           ; preds = %if.then33, %if.else27
  br label %if.end34

if.end34:                                         ; preds = %if.end, %if.then26
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then19
  %20 = load ptr, ptr %s.addr, align 8
  %21 = load ptr, ptr %ts.addr, align 8
  %bf.load36 = load i64, ptr %21, align 8
  %bf.lshr37 = lshr i64 %bf.load36, 24
  %bf.clear38 = and i64 %bf.lshr37, 255
  %bf.cast39 = trunc i64 %bf.clear38 to i32
  %22 = load i32, ptr %vece, align 4
  %23 = load i32, ptr %reg, align 4
  %24 = load ptr, ptr %ts.addr, align 8
  %val40 = getelementptr inbounds %struct.TCGTemp, ptr %24, i32 0, i32 1
  %25 = load i64, ptr %val40, align 8
  call void @tcg_out_dupi_vec(ptr noundef %20, i32 noundef %bf.cast39, i32 noundef %22, i32 noundef %23, i64 noundef %25)
  br label %if.end41

if.end41:                                         ; preds = %if.end35, %if.then
  %26 = load ptr, ptr %ts.addr, align 8
  %bf.load42 = load i64, ptr %26, align 8
  %bf.clear43 = and i64 %bf.load42, -137438953473
  %bf.set = or i64 %bf.clear43, 0
  store i64 %bf.set, ptr %26, align 8
  br label %sw.epilog

sw.bb44:                                          ; preds = %entry
  %27 = load ptr, ptr %s.addr, align 8
  %28 = load i32, ptr %desired_regs.addr, align 4
  %29 = load i32, ptr %allocated_regs.addr, align 4
  %30 = load i32, ptr %preferred_regs.addr, align 4
  %31 = load ptr, ptr %ts.addr, align 8
  %bf.load45 = load i64, ptr %31, align 8
  %bf.lshr46 = lshr i64 %bf.load45, 36
  %bf.clear47 = and i64 %bf.lshr46, 1
  %bf.cast48 = trunc i64 %bf.clear47 to i32
  %tobool49 = icmp ne i32 %bf.cast48, 0
  %call50 = call i32 @tcg_reg_alloc(ptr noundef %27, i32 noundef %28, i32 noundef %29, i32 noundef %30, i1 noundef zeroext %tobool49)
  store i32 %call50, ptr %reg, align 4
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load ptr, ptr %ts.addr, align 8
  %bf.load51 = load i64, ptr %33, align 8
  %bf.lshr52 = lshr i64 %bf.load51, 24
  %bf.clear53 = and i64 %bf.lshr52, 255
  %bf.cast54 = trunc i64 %bf.clear53 to i32
  %34 = load i32, ptr %reg, align 4
  %35 = load ptr, ptr %ts.addr, align 8
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %35, i32 0, i32 2
  %36 = load ptr, ptr %mem_base, align 8
  %bf.load55 = load i64, ptr %36, align 8
  %bf.clear56 = and i64 %bf.load55, 255
  %bf.cast57 = trunc i64 %bf.clear56 to i32
  %37 = load ptr, ptr %ts.addr, align 8
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %37, i32 0, i32 3
  %38 = load i64, ptr %mem_offset, align 8
  call void @tcg_out_ld(ptr noundef %32, i32 noundef %bf.cast54, i32 noundef %34, i32 noundef %bf.cast57, i64 noundef %38)
  %39 = load ptr, ptr %ts.addr, align 8
  %bf.load58 = load i64, ptr %39, align 8
  %bf.clear59 = and i64 %bf.load58, -137438953473
  %bf.set60 = or i64 %bf.clear59, 137438953472
  store i64 %bf.set60, ptr %39, align 8
  br label %sw.epilog

sw.bb61:                                          ; preds = %entry
  br label %sw.default

sw.default:                                       ; preds = %sw.bb61, %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 4436, ptr noundef @__func__.temp_load, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb44, %if.end41
  %40 = load ptr, ptr %s.addr, align 8
  %41 = load ptr, ptr %ts.addr, align 8
  %42 = load i32, ptr %reg, align 4
  call void @set_temp_val_reg(ptr noundef %40, ptr noundef %41, i32 noundef %42)
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @temp_allocate_frame(ptr noundef %s, ptr noundef %ts) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ts.addr = alloca ptr, align 8
  %off = alloca i64, align 8
  %size = alloca i32, align 4
  %align = alloca i32, align 4
  %_a14 = alloca i32, align 4
  %_b15 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %part_size = alloca i32, align 4
  %part_count = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  %0 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %0, align 8
  %bf.lshr = lshr i64 %bf.load, 16
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  %call = call i32 @tcg_type_size(i32 noundef %bf.cast)
  store i32 %call, ptr %size, align 4
  %1 = load ptr, ptr %ts.addr, align 8
  %bf.load1 = load i64, ptr %1, align 8
  %bf.lshr2 = lshr i64 %bf.load1, 16
  %bf.clear3 = and i64 %bf.lshr2, 255
  %bf.cast4 = trunc i64 %bf.clear3 to i32
  switch i32 %bf.cast4, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb5
    i32 3, label %sw.bb5
    i32 2, label %sw.bb6
    i32 4, label %sw.bb6
    i32 5, label %sw.bb6
  ]

sw.bb:                                            ; preds = %entry
  store i32 4, ptr %align, align 4
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry, %entry
  store i32 8, ptr %align, align 4
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry, %entry, %entry
  store i32 16, ptr %align, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 4116, ptr noundef @__func__.temp_allocate_frame, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb6, %sw.bb5, %sw.bb
  store i32 16, ptr %_a14, align 4
  %2 = load i32, ptr %align, align 4
  store i32 %2, ptr %_b15, align 4
  %3 = load i32, ptr %_a14, align 4
  %4 = load i32, ptr %_b15, align 4
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.epilog
  %5 = load i32, ptr %_a14, align 4
  br label %cond.end

cond.false:                                       ; preds = %sw.epilog
  %6 = load i32, ptr %_b15, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %5, %cond.true ], [ %6, %cond.false ]
  store i32 %cond, ptr %tmp, align 4
  %7 = load i32, ptr %tmp, align 4
  store i32 %7, ptr %align, align 4
  %8 = load ptr, ptr %s.addr, align 8
  %current_frame_offset = getelementptr inbounds %struct.TCGContext, ptr %8, i32 0, i32 17
  %9 = load i64, ptr %current_frame_offset, align 8
  %10 = load i32, ptr %align, align 4
  %conv = sext i32 %10 to i64
  %add = add i64 %9, %conv
  %sub = sub i64 %add, 1
  %11 = load i32, ptr %align, align 4
  %conv7 = sext i32 %11 to i64
  %sub8 = sub i64 0, %conv7
  %and = and i64 %sub, %sub8
  store i64 %and, ptr %off, align 8
  %12 = load i64, ptr %off, align 8
  %13 = load i32, ptr %size, align 4
  %conv9 = sext i32 %13 to i64
  %add10 = add i64 %12, %conv9
  %14 = load ptr, ptr %s.addr, align 8
  %frame_end = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 19
  %15 = load i64, ptr %frame_end, align 8
  %cmp11 = icmp sgt i64 %add10, %15
  br i1 %cmp11, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %16 = load ptr, ptr %s.addr, align 8
  call void @tcg_raise_tb_overflow(ptr noundef %16) #15
  unreachable

if.end:                                           ; preds = %cond.end
  %17 = load i64, ptr %off, align 8
  %18 = load i32, ptr %size, align 4
  %conv13 = sext i32 %18 to i64
  %add14 = add i64 %17, %conv13
  %19 = load ptr, ptr %s.addr, align 8
  %current_frame_offset15 = getelementptr inbounds %struct.TCGContext, ptr %19, i32 0, i32 17
  store i64 %add14, ptr %current_frame_offset15, align 8
  %20 = load ptr, ptr %ts.addr, align 8
  %bf.load16 = load i64, ptr %20, align 8
  %bf.lshr17 = lshr i64 %bf.load16, 16
  %bf.clear18 = and i64 %bf.lshr17, 255
  %bf.cast19 = trunc i64 %bf.clear18 to i32
  %21 = load ptr, ptr %ts.addr, align 8
  %bf.load20 = load i64, ptr %21, align 8
  %bf.lshr21 = lshr i64 %bf.load20, 24
  %bf.clear22 = and i64 %bf.lshr21, 255
  %bf.cast23 = trunc i64 %bf.clear22 to i32
  %cmp24 = icmp ne i32 %bf.cast19, %bf.cast23
  br i1 %cmp24, label %if.then26, label %if.else

if.then26:                                        ; preds = %if.end
  %22 = load ptr, ptr %ts.addr, align 8
  %bf.load27 = load i64, ptr %22, align 8
  %bf.lshr28 = lshr i64 %bf.load27, 24
  %bf.clear29 = and i64 %bf.lshr28, 255
  %bf.cast30 = trunc i64 %bf.clear29 to i32
  %call31 = call i32 @tcg_type_size(i32 noundef %bf.cast30)
  store i32 %call31, ptr %part_size, align 4
  %23 = load i32, ptr %size, align 4
  %24 = load i32, ptr %part_size, align 4
  %div = sdiv i32 %23, %24
  store i32 %div, ptr %part_count, align 4
  %25 = load ptr, ptr %ts.addr, align 8
  %bf.load32 = load i64, ptr %25, align 8
  %bf.lshr33 = lshr i64 %bf.load32, 40
  %bf.clear34 = and i64 %bf.lshr33, 1
  %bf.cast35 = trunc i64 %bf.clear34 to i32
  %26 = load ptr, ptr %ts.addr, align 8
  %idx.ext = sext i32 %bf.cast35 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr %struct.TCGTemp, ptr %26, i64 %idx.neg
  store ptr %add.ptr, ptr %ts.addr, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then26
  %27 = load i32, ptr %i, align 4
  %28 = load i32, ptr %part_count, align 4
  %cmp36 = icmp slt i32 %27, %28
  br i1 %cmp36, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %29 = load i64, ptr %off, align 8
  %30 = load i32, ptr %i, align 4
  %31 = load i32, ptr %part_size, align 4
  %mul = mul i32 %30, %31
  %conv38 = sext i32 %mul to i64
  %add39 = add i64 %29, %conv38
  %32 = load ptr, ptr %ts.addr, align 8
  %33 = load i32, ptr %i, align 4
  %idxprom = sext i32 %33 to i64
  %arrayidx = getelementptr %struct.TCGTemp, ptr %32, i64 %idxprom
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %arrayidx, i32 0, i32 3
  store i64 %add39, ptr %mem_offset, align 8
  %34 = load ptr, ptr %s.addr, align 8
  %frame_temp = getelementptr inbounds %struct.TCGContext, ptr %34, i32 0, i32 20
  %35 = load ptr, ptr %frame_temp, align 8
  %36 = load ptr, ptr %ts.addr, align 8
  %37 = load i32, ptr %i, align 4
  %idxprom40 = sext i32 %37 to i64
  %arrayidx41 = getelementptr %struct.TCGTemp, ptr %36, i64 %idxprom40
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %arrayidx41, i32 0, i32 2
  store ptr %35, ptr %mem_base, align 8
  %38 = load ptr, ptr %ts.addr, align 8
  %39 = load i32, ptr %i, align 4
  %idxprom42 = sext i32 %39 to i64
  %arrayidx43 = getelementptr %struct.TCGTemp, ptr %38, i64 %idxprom42
  %bf.load44 = load i64, ptr %arrayidx43, align 8
  %bf.clear45 = and i64 %bf.load44, -274877906945
  %bf.set = or i64 %bf.clear45, 274877906944
  store i64 %bf.set, ptr %arrayidx43, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %40 = load i32, ptr %i, align 4
  %inc = add i32 %40, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !100

for.end:                                          ; preds = %for.cond
  br label %if.end52

if.else:                                          ; preds = %if.end
  %41 = load i64, ptr %off, align 8
  %42 = load ptr, ptr %ts.addr, align 8
  %mem_offset46 = getelementptr inbounds %struct.TCGTemp, ptr %42, i32 0, i32 3
  store i64 %41, ptr %mem_offset46, align 8
  %43 = load ptr, ptr %s.addr, align 8
  %frame_temp47 = getelementptr inbounds %struct.TCGContext, ptr %43, i32 0, i32 20
  %44 = load ptr, ptr %frame_temp47, align 8
  %45 = load ptr, ptr %ts.addr, align 8
  %mem_base48 = getelementptr inbounds %struct.TCGTemp, ptr %45, i32 0, i32 2
  store ptr %44, ptr %mem_base48, align 8
  %46 = load ptr, ptr %ts.addr, align 8
  %bf.load49 = load i64, ptr %46, align 8
  %bf.clear50 = and i64 %bf.load49, -274877906945
  %bf.set51 = or i64 %bf.clear50, 274877906944
  store i64 %bf.set51, ptr %46, align 8
  br label %if.end52

if.end52:                                         ; preds = %if.else, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_st(ptr noundef %s, i32 noundef %type, i32 noundef %arg, i32 noundef %arg1, i64 noundef %arg2) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %arg.addr = alloca i32, align 4
  %arg1.addr = alloca i32, align 4
  %arg2.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %arg, ptr %arg.addr, align 4
  store i32 %arg1, ptr %arg1.addr, align 4
  store i64 %arg2, ptr %arg2.addr, align 8
  %0 = load i32, ptr %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 3, label %sw.bb5
    i32 4, label %sw.bb9
    i32 5, label %sw.bb18
  ]

sw.bb:                                            ; preds = %entry
  %1 = load i32, ptr %arg.addr, align 4
  %cmp = icmp ult i32 %1, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %arg.addr, align 4
  %4 = load i32, ptr %arg1.addr, align 4
  %5 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_modrm_offset(ptr noundef %2, i32 noundef 137, i32 noundef %3, i32 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load i32, ptr %arg.addr, align 4
  %8 = load i32, ptr %arg1.addr, align 4
  %9 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %6, i32 noundef 1406, i32 noundef %7, i32 noundef 0, i32 noundef %8, i64 noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %10 = load i32, ptr %arg.addr, align 4
  %cmp2 = icmp ult i32 %10, 16
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %sw.bb1
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load i32, ptr %arg.addr, align 4
  %13 = load i32, ptr %arg1.addr, align 4
  %14 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_modrm_offset(ptr noundef %11, i32 noundef 4233, i32 noundef %12, i32 noundef %13, i64 noundef %14)
  br label %sw.epilog

if.end4:                                          ; preds = %sw.bb1
  br label %sw.bb5

sw.bb5:                                           ; preds = %if.end4, %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb5
  %15 = load i32, ptr %arg.addr, align 4
  %cmp6 = icmp uge i32 %15, 16
  br i1 %cmp6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %do.body
  unreachable

if.end8:                                          ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end8
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i32, ptr %arg.addr, align 4
  %18 = load i32, ptr %arg1.addr, align 4
  %19 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %16, i32 noundef 1494, i32 noundef %17, i32 noundef 0, i32 noundef %18, i64 noundef %19)
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  br label %do.body10

do.body10:                                        ; preds = %sw.bb9
  %20 = load i32, ptr %arg.addr, align 4
  %cmp11 = icmp uge i32 %20, 16
  br i1 %cmp11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %do.body10
  unreachable

if.end13:                                         ; preds = %do.body10
  br label %do.end14

do.end14:                                         ; preds = %if.end13
  %21 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %21, 512
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then15, label %if.else16

if.then15:                                        ; preds = %do.end14
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load i32, ptr %arg.addr, align 4
  %24 = load i32, ptr %arg1.addr, align 4
  %25 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %22, i32 noundef 1407, i32 noundef %23, i32 noundef 0, i32 noundef %24, i64 noundef %25)
  br label %if.end17

if.else16:                                        ; preds = %do.end14
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i32, ptr %arg.addr, align 4
  %28 = load i32, ptr %arg1.addr, align 4
  %29 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_modrm_offset(ptr noundef %26, i32 noundef 1407, i32 noundef %27, i32 noundef %28, i64 noundef %29)
  br label %if.end17

if.end17:                                         ; preds = %if.else16, %if.then15
  br label %sw.epilog

sw.bb18:                                          ; preds = %entry
  br label %do.body19

do.body19:                                        ; preds = %sw.bb18
  %30 = load i32, ptr %arg.addr, align 4
  %cmp20 = icmp uge i32 %30, 16
  br i1 %cmp20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %do.body19
  unreachable

if.end22:                                         ; preds = %do.body19
  br label %do.end23

do.end23:                                         ; preds = %if.end22
  %31 = load ptr, ptr %s.addr, align 8
  %32 = load i32, ptr %arg.addr, align 4
  %33 = load i32, ptr %arg1.addr, align 4
  %34 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %31, i32 noundef 655743, i32 noundef %32, i32 noundef 0, i32 noundef %33, i64 noundef %34)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body24

do.body24:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 1202, ptr noundef @__func__.tcg_out_st, ptr noundef null) #15
  unreachable

do.end25:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end25, %do.end23, %if.end17, %do.end, %if.then3, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_reg_alloc(ptr noundef %s, i32 noundef %required_regs, i32 noundef %allocated_regs, i32 noundef %preferred_regs, i1 noundef zeroext %rev) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca ptr, align 8
  %required_regs.addr = alloca i32, align 4
  %allocated_regs.addr = alloca i32, align 4
  %preferred_regs.addr = alloca i32, align 4
  %rev.addr = alloca i8, align 1
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %f = alloca i32, align 4
  %n = alloca i32, align 4
  %reg_ct = alloca [2 x i32], align 4
  %order = alloca ptr, align 8
  %set = alloca i32, align 4
  %reg = alloca i32, align 4
  %reg22 = alloca i32, align 4
  %set40 = alloca i32, align 4
  %reg45 = alloca i32, align 4
  %reg51 = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %required_regs, ptr %required_regs.addr, align 4
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  store i32 %preferred_regs, ptr %preferred_regs.addr, align 4
  %frombool = zext i1 %rev to i8
  store i8 %frombool, ptr %rev.addr, align 1
  store i32 31, ptr %n, align 4
  %0 = load i32, ptr %required_regs.addr, align 4
  %1 = load i32, ptr %allocated_regs.addr, align 4
  %not = xor i32 %1, -1
  %and = and i32 %0, %not
  %arrayidx = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 1
  store i32 %and, ptr %arrayidx, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %arrayidx1 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 1
  %2 = load i32, ptr %arrayidx1, align 4
  %cmp = icmp ne i32 %2, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %arrayidx2 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 1
  %3 = load i32, ptr %arrayidx2, align 4
  %4 = load i32, ptr %preferred_regs.addr, align 4
  %and3 = and i32 %3, %4
  %arrayidx4 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 0
  store i32 %and3, ptr %arrayidx4, align 4
  %arrayidx5 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 0
  %5 = load i32, ptr %arrayidx5, align 4
  %cmp6 = icmp eq i32 %5, 0
  br i1 %cmp6, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.end
  %arrayidx7 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 0
  %6 = load i32, ptr %arrayidx7, align 4
  %arrayidx8 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 1
  %7 = load i32, ptr %arrayidx8, align 4
  %cmp9 = icmp eq i32 %6, %7
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.end
  %8 = phi i1 [ true, %do.end ], [ %cmp9, %lor.rhs ]
  %lor.ext = zext i1 %8 to i32
  store i32 %lor.ext, ptr %f, align 4
  %9 = load i8, ptr %rev.addr, align 1
  %tobool = trunc i8 %9 to i1
  %cond = select i1 %tobool, ptr @indirect_reg_alloc_order, ptr @tcg_target_reg_alloc_order
  store ptr %cond, ptr %order, align 8
  %10 = load i32, ptr %f, align 4
  store i32 %10, ptr %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc34, %lor.end
  %11 = load i32, ptr %j, align 4
  %cmp10 = icmp slt i32 %11, 2
  br i1 %cmp10, label %for.body, label %for.end36

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %j, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx11 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 %idxprom
  %13 = load i32, ptr %arrayidx11, align 4
  store i32 %13, ptr %set, align 4
  %14 = load i32, ptr %set, align 4
  %call = call zeroext i1 @tcg_regset_single(i32 noundef %14)
  br i1 %call, label %if.then12, label %if.else

if.then12:                                        ; preds = %for.body
  %15 = load i32, ptr %set, align 4
  %call13 = call i32 @tcg_regset_first(i32 noundef %15)
  store i32 %call13, ptr %reg, align 4
  %16 = load ptr, ptr %s.addr, align 8
  %reg_to_temp = getelementptr inbounds %struct.TCGContext, ptr %16, i32 0, i32 41
  %17 = load i32, ptr %reg, align 4
  %idxprom14 = zext i32 %17 to i64
  %arrayidx15 = getelementptr [32 x ptr], ptr %reg_to_temp, i64 0, i64 %idxprom14
  %18 = load ptr, ptr %arrayidx15, align 8
  %cmp16 = icmp eq ptr %18, null
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then12
  %19 = load i32, ptr %reg, align 4
  store i32 %19, ptr %retval, align 4
  br label %do.end67

if.end18:                                         ; preds = %if.then12
  br label %if.end33

if.else:                                          ; preds = %for.body
  store i32 0, ptr %i, align 4
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc, %if.else
  %20 = load i32, ptr %i, align 4
  %21 = load i32, ptr %n, align 4
  %cmp20 = icmp slt i32 %20, %21
  br i1 %cmp20, label %for.body21, label %for.end

for.body21:                                       ; preds = %for.cond19
  %22 = load ptr, ptr %order, align 8
  %23 = load i32, ptr %i, align 4
  %idxprom23 = sext i32 %23 to i64
  %arrayidx24 = getelementptr i32, ptr %22, i64 %idxprom23
  %24 = load i32, ptr %arrayidx24, align 4
  store i32 %24, ptr %reg22, align 4
  %25 = load ptr, ptr %s.addr, align 8
  %reg_to_temp25 = getelementptr inbounds %struct.TCGContext, ptr %25, i32 0, i32 41
  %26 = load i32, ptr %reg22, align 4
  %idxprom26 = zext i32 %26 to i64
  %arrayidx27 = getelementptr [32 x ptr], ptr %reg_to_temp25, i64 0, i64 %idxprom26
  %27 = load ptr, ptr %arrayidx27, align 8
  %cmp28 = icmp eq ptr %27, null
  br i1 %cmp28, label %land.lhs.true, label %if.end32

land.lhs.true:                                    ; preds = %for.body21
  %28 = load i32, ptr %set, align 4
  %29 = load i32, ptr %reg22, align 4
  %shr = lshr i32 %28, %29
  %and29 = and i32 %shr, 1
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %land.lhs.true
  %30 = load i32, ptr %reg22, align 4
  store i32 %30, ptr %retval, align 4
  br label %do.end67

if.end32:                                         ; preds = %land.lhs.true, %for.body21
  br label %for.inc

for.inc:                                          ; preds = %if.end32
  %31 = load i32, ptr %i, align 4
  %inc = add i32 %31, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond19, !llvm.loop !101

for.end:                                          ; preds = %for.cond19
  br label %if.end33

if.end33:                                         ; preds = %for.end, %if.end18
  br label %for.inc34

for.inc34:                                        ; preds = %if.end33
  %32 = load i32, ptr %j, align 4
  %inc35 = add i32 %32, 1
  store i32 %inc35, ptr %j, align 4
  br label %for.cond, !llvm.loop !102

for.end36:                                        ; preds = %for.cond
  %33 = load i32, ptr %f, align 4
  store i32 %33, ptr %j, align 4
  br label %for.cond37

for.cond37:                                       ; preds = %for.inc63, %for.end36
  %34 = load i32, ptr %j, align 4
  %cmp38 = icmp slt i32 %34, 2
  br i1 %cmp38, label %for.body39, label %for.end65

for.body39:                                       ; preds = %for.cond37
  %35 = load i32, ptr %j, align 4
  %idxprom41 = sext i32 %35 to i64
  %arrayidx42 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 %idxprom41
  %36 = load i32, ptr %arrayidx42, align 4
  store i32 %36, ptr %set40, align 4
  %37 = load i32, ptr %set40, align 4
  %call43 = call zeroext i1 @tcg_regset_single(i32 noundef %37)
  br i1 %call43, label %if.then44, label %if.else47

if.then44:                                        ; preds = %for.body39
  %38 = load i32, ptr %set40, align 4
  %call46 = call i32 @tcg_regset_first(i32 noundef %38)
  store i32 %call46, ptr %reg45, align 4
  %39 = load ptr, ptr %s.addr, align 8
  %40 = load i32, ptr %reg45, align 4
  %41 = load i32, ptr %allocated_regs.addr, align 4
  call void @tcg_reg_free(ptr noundef %39, i32 noundef %40, i32 noundef %41)
  %42 = load i32, ptr %reg45, align 4
  store i32 %42, ptr %retval, align 4
  br label %do.end67

if.else47:                                        ; preds = %for.body39
  store i32 0, ptr %i, align 4
  br label %for.cond48

for.cond48:                                       ; preds = %for.inc59, %if.else47
  %43 = load i32, ptr %i, align 4
  %44 = load i32, ptr %n, align 4
  %cmp49 = icmp slt i32 %43, %44
  br i1 %cmp49, label %for.body50, label %for.end61

for.body50:                                       ; preds = %for.cond48
  %45 = load ptr, ptr %order, align 8
  %46 = load i32, ptr %i, align 4
  %idxprom52 = sext i32 %46 to i64
  %arrayidx53 = getelementptr i32, ptr %45, i64 %idxprom52
  %47 = load i32, ptr %arrayidx53, align 4
  store i32 %47, ptr %reg51, align 4
  %48 = load i32, ptr %set40, align 4
  %49 = load i32, ptr %reg51, align 4
  %shr54 = lshr i32 %48, %49
  %and55 = and i32 %shr54, 1
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then57, label %if.end58

if.then57:                                        ; preds = %for.body50
  %50 = load ptr, ptr %s.addr, align 8
  %51 = load i32, ptr %reg51, align 4
  %52 = load i32, ptr %allocated_regs.addr, align 4
  call void @tcg_reg_free(ptr noundef %50, i32 noundef %51, i32 noundef %52)
  %53 = load i32, ptr %reg51, align 4
  store i32 %53, ptr %retval, align 4
  br label %do.end67

if.end58:                                         ; preds = %for.body50
  br label %for.inc59

for.inc59:                                        ; preds = %if.end58
  %54 = load i32, ptr %i, align 4
  %inc60 = add i32 %54, 1
  store i32 %inc60, ptr %i, align 4
  br label %for.cond48, !llvm.loop !103

for.end61:                                        ; preds = %for.cond48
  br label %if.end62

if.end62:                                         ; preds = %for.end61
  br label %for.inc63

for.inc63:                                        ; preds = %if.end62
  %55 = load i32, ptr %j, align 4
  %inc64 = add i32 %55, 1
  store i32 %inc64, ptr %j, align 4
  br label %for.cond37, !llvm.loop !104

for.end65:                                        ; preds = %for.cond37
  br label %do.body66

do.body66:                                        ; preds = %for.end65
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 4343, ptr noundef @__func__.tcg_reg_alloc, ptr noundef null) #15
  unreachable

do.end67:                                         ; preds = %if.then57, %if.then44, %if.then31, %if.then17
  %56 = load i32, ptr %retval, align 4
  ret i32 %56
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @set_temp_val_nonreg(ptr noundef %s, ptr noundef %ts, i32 noundef %type) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ts.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %reg = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp ne i32 %0, 1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %1, align 8
  %bf.lshr = lshr i64 %bf.load, 8
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp1 = icmp eq i32 %bf.cast, 1
  br i1 %cmp1, label %if.then2, label %if.end14

if.then2:                                         ; preds = %do.end
  %2 = load ptr, ptr %ts.addr, align 8
  %bf.load3 = load i64, ptr %2, align 8
  %bf.clear4 = and i64 %bf.load3, 255
  %bf.cast5 = trunc i64 %bf.clear4 to i32
  store i32 %bf.cast5, ptr %reg, align 4
  br label %do.body6

do.body6:                                         ; preds = %if.then2
  %3 = load ptr, ptr %s.addr, align 8
  %reg_to_temp = getelementptr inbounds %struct.TCGContext, ptr %3, i32 0, i32 41
  %4 = load i32, ptr %reg, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [32 x ptr], ptr %reg_to_temp, i64 0, i64 %idxprom
  %5 = load ptr, ptr %arrayidx, align 8
  %6 = load ptr, ptr %ts.addr, align 8
  %cmp7 = icmp eq ptr %5, %6
  br i1 %cmp7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %do.body6
  unreachable

if.end9:                                          ; preds = %do.body6
  br label %do.end10

do.end10:                                         ; preds = %if.end9
  %7 = load ptr, ptr %s.addr, align 8
  %reg_to_temp11 = getelementptr inbounds %struct.TCGContext, ptr %7, i32 0, i32 41
  %8 = load i32, ptr %reg, align 4
  %idxprom12 = zext i32 %8 to i64
  %arrayidx13 = getelementptr [32 x ptr], ptr %reg_to_temp11, i64 0, i64 %idxprom12
  store ptr null, ptr %arrayidx13, align 8
  br label %if.end14

if.end14:                                         ; preds = %do.end10, %do.end
  %9 = load i32, ptr %type.addr, align 4
  %10 = load ptr, ptr %ts.addr, align 8
  %11 = zext i32 %9 to i64
  %bf.load15 = load i64, ptr %10, align 8
  %bf.value = and i64 %11, 255
  %bf.shl = shl i64 %bf.value, 8
  %bf.clear16 = and i64 %bf.load15, -65281
  %bf.set = or i64 %bf.clear16, %bf.shl
  store i64 %bf.set, ptr %10, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @set_temp_val_reg(ptr noundef %s, ptr noundef %ts, i32 noundef %reg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ts.addr = alloca ptr, align 8
  %reg.addr = alloca i32, align 4
  %old = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  store i32 %reg, ptr %reg.addr, align 4
  %0 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %0, align 8
  %bf.lshr = lshr i64 %bf.load, 8
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 1
  br i1 %cmp, label %if.then, label %if.end12

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %ts.addr, align 8
  %bf.load1 = load i64, ptr %1, align 8
  %bf.clear2 = and i64 %bf.load1, 255
  %bf.cast3 = trunc i64 %bf.clear2 to i32
  store i32 %bf.cast3, ptr %old, align 4
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load ptr, ptr %s.addr, align 8
  %reg_to_temp = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 41
  %3 = load i32, ptr %old, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [32 x ptr], ptr %reg_to_temp, i64 0, i64 %idxprom
  %4 = load ptr, ptr %arrayidx, align 8
  %5 = load ptr, ptr %ts.addr, align 8
  %cmp4 = icmp eq ptr %4, %5
  br i1 %cmp4, label %if.end, label %if.then5

if.then5:                                         ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %6 = load i32, ptr %old, align 4
  %7 = load i32, ptr %reg.addr, align 4
  %cmp6 = icmp eq i32 %6, %7
  br i1 %cmp6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %do.end
  br label %return

if.end8:                                          ; preds = %do.end
  %8 = load ptr, ptr %s.addr, align 8
  %reg_to_temp9 = getelementptr inbounds %struct.TCGContext, ptr %8, i32 0, i32 41
  %9 = load i32, ptr %old, align 4
  %idxprom10 = zext i32 %9 to i64
  %arrayidx11 = getelementptr [32 x ptr], ptr %reg_to_temp9, i64 0, i64 %idxprom10
  store ptr null, ptr %arrayidx11, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.end8, %entry
  br label %do.body13

do.body13:                                        ; preds = %if.end12
  %10 = load ptr, ptr %s.addr, align 8
  %reg_to_temp14 = getelementptr inbounds %struct.TCGContext, ptr %10, i32 0, i32 41
  %11 = load i32, ptr %reg.addr, align 4
  %idxprom15 = zext i32 %11 to i64
  %arrayidx16 = getelementptr [32 x ptr], ptr %reg_to_temp14, i64 0, i64 %idxprom15
  %12 = load ptr, ptr %arrayidx16, align 8
  %cmp17 = icmp eq ptr %12, null
  br i1 %cmp17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %do.body13
  unreachable

if.end19:                                         ; preds = %do.body13
  br label %do.end20

do.end20:                                         ; preds = %if.end19
  %13 = load ptr, ptr %ts.addr, align 8
  %14 = load ptr, ptr %s.addr, align 8
  %reg_to_temp21 = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 41
  %15 = load i32, ptr %reg.addr, align 4
  %idxprom22 = zext i32 %15 to i64
  %arrayidx23 = getelementptr [32 x ptr], ptr %reg_to_temp21, i64 0, i64 %idxprom22
  store ptr %13, ptr %arrayidx23, align 8
  %16 = load ptr, ptr %ts.addr, align 8
  %bf.load24 = load i64, ptr %16, align 8
  %bf.clear25 = and i64 %bf.load24, -65281
  %bf.set = or i64 %bf.clear25, 256
  store i64 %bf.set, ptr %16, align 8
  %17 = load i32, ptr %reg.addr, align 4
  %18 = load ptr, ptr %ts.addr, align 8
  %19 = zext i32 %17 to i64
  %bf.load26 = load i64, ptr %18, align 8
  %bf.value = and i64 %19, 255
  %bf.clear27 = and i64 %bf.load26, -256
  %bf.set28 = or i64 %bf.clear27, %bf.value
  store i64 %bf.set28, ptr %18, align 8
  br label %return

return:                                           ; preds = %do.end20, %if.then7
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @temp_sync(ptr noundef %s, ptr noundef %ts, i32 noundef %allocated_regs, i32 noundef %preferred_regs, i32 noundef %free_or_dead) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ts.addr = alloca ptr, align 8
  %allocated_regs.addr = alloca i32, align 4
  %preferred_regs.addr = alloca i32, align 4
  %free_or_dead.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  store i32 %preferred_regs, ptr %preferred_regs.addr, align 4
  store i32 %free_or_dead, ptr %free_or_dead.addr, align 4
  %0 = load ptr, ptr %ts.addr, align 8
  %call = call zeroext i1 @temp_readonly(ptr noundef %0)
  br i1 %call, label %if.end44, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %1, align 8
  %bf.lshr = lshr i64 %bf.load, 37
  %bf.clear = and i64 %bf.lshr, 1
  %bf.cast = trunc i64 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.end44, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr %ts.addr, align 8
  %bf.load1 = load i64, ptr %2, align 8
  %bf.lshr2 = lshr i64 %bf.load1, 38
  %bf.clear3 = and i64 %bf.lshr2, 1
  %bf.cast4 = trunc i64 %bf.clear3 to i32
  %tobool5 = icmp ne i32 %bf.cast4, 0
  br i1 %tobool5, label %if.end, label %if.then6

if.then6:                                         ; preds = %if.then
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load ptr, ptr %ts.addr, align 8
  call void @temp_allocate_frame(ptr noundef %3, ptr noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  %5 = load ptr, ptr %ts.addr, align 8
  %bf.load7 = load i64, ptr %5, align 8
  %bf.lshr8 = lshr i64 %bf.load7, 8
  %bf.clear9 = and i64 %bf.lshr8, 255
  %bf.cast10 = trunc i64 %bf.clear9 to i32
  switch i32 %bf.cast10, label %sw.default [
    i32 3, label %sw.bb
    i32 1, label %sw.bb27
    i32 2, label %sw.bb40
    i32 0, label %sw.bb41
  ]

sw.bb:                                            ; preds = %if.end
  %6 = load i32, ptr %free_or_dead.addr, align 4
  %tobool11 = icmp ne i32 %6, 0
  br i1 %tobool11, label %land.lhs.true12, label %if.end22

land.lhs.true12:                                  ; preds = %sw.bb
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load ptr, ptr %ts.addr, align 8
  %bf.load13 = load i64, ptr %8, align 8
  %bf.lshr14 = lshr i64 %bf.load13, 24
  %bf.clear15 = and i64 %bf.lshr14, 255
  %bf.cast16 = trunc i64 %bf.clear15 to i32
  %9 = load ptr, ptr %ts.addr, align 8
  %val = getelementptr inbounds %struct.TCGTemp, ptr %9, i32 0, i32 1
  %10 = load i64, ptr %val, align 8
  %11 = load ptr, ptr %ts.addr, align 8
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %mem_base, align 8
  %bf.load17 = load i64, ptr %12, align 8
  %bf.clear18 = and i64 %bf.load17, 255
  %bf.cast19 = trunc i64 %bf.clear18 to i32
  %13 = load ptr, ptr %ts.addr, align 8
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %13, i32 0, i32 3
  %14 = load i64, ptr %mem_offset, align 8
  %call20 = call zeroext i1 @tcg_out_sti(ptr noundef %7, i32 noundef %bf.cast16, i64 noundef %10, i32 noundef %bf.cast19, i64 noundef %14)
  br i1 %call20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %land.lhs.true12
  br label %sw.epilog

if.end22:                                         ; preds = %land.lhs.true12, %sw.bb
  %15 = load ptr, ptr %s.addr, align 8
  %16 = load ptr, ptr %ts.addr, align 8
  %17 = load ptr, ptr %ts.addr, align 8
  %bf.load23 = load i64, ptr %17, align 8
  %bf.lshr24 = lshr i64 %bf.load23, 24
  %bf.clear25 = and i64 %bf.lshr24, 255
  %bf.cast26 = trunc i64 %bf.clear25 to i32
  %idxprom = zext i32 %bf.cast26 to i64
  %arrayidx = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom
  %18 = load i32, ptr %arrayidx, align 4
  %19 = load i32, ptr %allocated_regs.addr, align 4
  %20 = load i32, ptr %preferred_regs.addr, align 4
  call void @temp_load(ptr noundef %15, ptr noundef %16, i32 noundef %18, i32 noundef %19, i32 noundef %20)
  br label %sw.bb27

sw.bb27:                                          ; preds = %if.end22, %if.end
  %21 = load ptr, ptr %s.addr, align 8
  %22 = load ptr, ptr %ts.addr, align 8
  %bf.load28 = load i64, ptr %22, align 8
  %bf.lshr29 = lshr i64 %bf.load28, 24
  %bf.clear30 = and i64 %bf.lshr29, 255
  %bf.cast31 = trunc i64 %bf.clear30 to i32
  %23 = load ptr, ptr %ts.addr, align 8
  %bf.load32 = load i64, ptr %23, align 8
  %bf.clear33 = and i64 %bf.load32, 255
  %bf.cast34 = trunc i64 %bf.clear33 to i32
  %24 = load ptr, ptr %ts.addr, align 8
  %mem_base35 = getelementptr inbounds %struct.TCGTemp, ptr %24, i32 0, i32 2
  %25 = load ptr, ptr %mem_base35, align 8
  %bf.load36 = load i64, ptr %25, align 8
  %bf.clear37 = and i64 %bf.load36, 255
  %bf.cast38 = trunc i64 %bf.clear37 to i32
  %26 = load ptr, ptr %ts.addr, align 8
  %mem_offset39 = getelementptr inbounds %struct.TCGTemp, ptr %26, i32 0, i32 3
  %27 = load i64, ptr %mem_offset39, align 8
  call void @tcg_out_st(ptr noundef %21, i32 noundef %bf.cast31, i32 noundef %bf.cast34, i32 noundef %bf.cast38, i64 noundef %27)
  br label %sw.epilog

sw.bb40:                                          ; preds = %if.end
  br label %sw.epilog

sw.bb41:                                          ; preds = %if.end
  br label %sw.default

sw.default:                                       ; preds = %sw.bb41, %if.end
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 4256, ptr noundef @__func__.temp_sync, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb40, %sw.bb27, %if.then21
  %28 = load ptr, ptr %ts.addr, align 8
  %bf.load42 = load i64, ptr %28, align 8
  %bf.clear43 = and i64 %bf.load42, -137438953473
  %bf.set = or i64 %bf.clear43, 137438953472
  store i64 %bf.set, ptr %28, align 8
  br label %if.end44

if.end44:                                         ; preds = %sw.epilog, %land.lhs.true, %entry
  %29 = load i32, ptr %free_or_dead.addr, align 4
  %tobool45 = icmp ne i32 %29, 0
  br i1 %tobool45, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.end44
  %30 = load ptr, ptr %s.addr, align 8
  %31 = load ptr, ptr %ts.addr, align 8
  %32 = load i32, ptr %free_or_dead.addr, align 4
  call void @temp_free_or_dead(ptr noundef %30, ptr noundef %31, i32 noundef %32)
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %if.end44
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_dupi_vec(ptr noundef %s, i32 noundef %type, i32 noundef %vece, i32 noundef %ret, i64 noundef %arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %ret.addr = alloca i32, align 4
  %arg.addr = alloca i64, align 8
  %vex_l = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store i32 %ret, ptr %ret.addr, align 4
  store i64 %arg, ptr %arg.addr, align 8
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %0, 5
  %cond = select i1 %cmp, i32 524288, i32 0
  store i32 %cond, ptr %vex_l, align 4
  %1 = load i64, ptr %arg.addr, align 8
  %cmp1 = icmp eq i64 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %ret.addr, align 4
  %4 = load i32, ptr %ret.addr, align 4
  %5 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %2, i32 noundef 1519, i32 noundef %3, i32 noundef %4, i32 noundef %5)
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i64, ptr %arg.addr, align 8
  %cmp2 = icmp eq i64 %6, -1
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i32, ptr %vex_l, align 4
  %add = add i32 1396, %8
  %9 = load i32, ptr %ret.addr, align 4
  %10 = load i32, ptr %ret.addr, align 4
  %11 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %7, i32 noundef %add, i32 noundef %9, i32 noundef %10, i32 noundef %11)
  br label %return

if.end4:                                          ; preds = %if.end
  %12 = load i32, ptr %type.addr, align 4
  %cmp5 = icmp eq i32 %12, 3
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.end4
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_vex_modrm_pool(ptr noundef %13, i32 noundef 131454, i32 noundef %14)
  br label %if.end11

if.else:                                          ; preds = %if.end4
  %15 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %15, 1024
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then7, label %if.else9

if.then7:                                         ; preds = %if.else
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i32, ptr %vex_l, align 4
  %add8 = add i32 1625, %17
  %18 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_vex_modrm_pool(ptr noundef %16, i32 noundef %add8, i32 noundef %18)
  br label %if.end10

if.else9:                                         ; preds = %if.else
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load i32, ptr %ret.addr, align 4
  call void @tcg_out_vex_modrm_pool(ptr noundef %19, i32 noundef 262418, i32 noundef %20)
  br label %if.end10

if.end10:                                         ; preds = %if.else9, %if.then7
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then6
  %21 = load ptr, ptr %s.addr, align 8
  %22 = load i64, ptr %arg.addr, align 8
  %23 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %23, i32 0, i32 23
  %24 = load ptr, ptr %code_ptr, align 8
  %add.ptr = getelementptr i8, ptr %24, i64 -4
  call void @new_pool_label(ptr noundef %21, i64 noundef %22, i32 noundef 2, ptr noundef %add.ptr, i64 noundef -4)
  br label %return

return:                                           ; preds = %if.end11, %if.then3, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_ld(ptr noundef %s, i32 noundef %type, i32 noundef %ret, i32 noundef %arg1, i64 noundef %arg2) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %ret.addr = alloca i32, align 4
  %arg1.addr = alloca i32, align 4
  %arg2.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %ret, ptr %ret.addr, align 4
  store i32 %arg1, ptr %arg1.addr, align 4
  store i64 %arg2, ptr %arg2.addr, align 8
  %0 = load i32, ptr %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 3, label %sw.bb5
    i32 4, label %sw.bb9
    i32 5, label %sw.bb15
  ]

sw.bb:                                            ; preds = %entry
  %1 = load i32, ptr %ret.addr, align 4
  %cmp = icmp ult i32 %1, 16
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %ret.addr, align 4
  %4 = load i32, ptr %arg1.addr, align 4
  %5 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_modrm_offset(ptr noundef %2, i32 noundef 139, i32 noundef %3, i32 noundef %4, i64 noundef %5)
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load i32, ptr %ret.addr, align 4
  %8 = load i32, ptr %arg1.addr, align 4
  %9 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %6, i32 noundef 1390, i32 noundef %7, i32 noundef 0, i32 noundef %8, i64 noundef %9)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %10 = load i32, ptr %ret.addr, align 4
  %cmp2 = icmp ult i32 %10, 16
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %sw.bb1
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load i32, ptr %ret.addr, align 4
  %13 = load i32, ptr %arg1.addr, align 4
  %14 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_modrm_offset(ptr noundef %11, i32 noundef 4235, i32 noundef %12, i32 noundef %13, i64 noundef %14)
  br label %sw.epilog

if.end4:                                          ; preds = %sw.bb1
  br label %sw.bb5

sw.bb5:                                           ; preds = %if.end4, %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb5
  %15 = load i32, ptr %ret.addr, align 4
  %cmp6 = icmp uge i32 %15, 16
  br i1 %cmp6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %do.body
  unreachable

if.end8:                                          ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end8
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i32, ptr %ret.addr, align 4
  %18 = load i32, ptr %arg1.addr, align 4
  %19 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %16, i32 noundef 131454, i32 noundef %17, i32 noundef 0, i32 noundef %18, i64 noundef %19)
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  br label %do.body10

do.body10:                                        ; preds = %sw.bb9
  %20 = load i32, ptr %ret.addr, align 4
  %cmp11 = icmp uge i32 %20, 16
  br i1 %cmp11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %do.body10
  unreachable

if.end13:                                         ; preds = %do.body10
  br label %do.end14

do.end14:                                         ; preds = %if.end13
  %21 = load ptr, ptr %s.addr, align 8
  %22 = load i32, ptr %ret.addr, align 4
  %23 = load i32, ptr %arg1.addr, align 4
  %24 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %21, i32 noundef 1391, i32 noundef %22, i32 noundef 0, i32 noundef %23, i64 noundef %24)
  br label %sw.epilog

sw.bb15:                                          ; preds = %entry
  br label %do.body16

do.body16:                                        ; preds = %sw.bb15
  %25 = load i32, ptr %ret.addr, align 4
  %cmp17 = icmp uge i32 %25, 16
  br i1 %cmp17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %do.body16
  unreachable

if.end19:                                         ; preds = %do.body16
  br label %do.end20

do.end20:                                         ; preds = %if.end19
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i32, ptr %ret.addr, align 4
  %28 = load i32, ptr %arg1.addr, align 4
  %29 = load i64, ptr %arg2.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %26, i32 noundef 655727, i32 noundef %27, i32 noundef 0, i32 noundef %28, i64 noundef %29)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body21

do.body21:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 1150, ptr noundef @__func__.tcg_out_ld, ptr noundef null) #15
  unreachable

do.end22:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end22, %do.end20, %do.end14, %do.end, %if.then3, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_modrm_offset(ptr noundef %s, i32 noundef %opc, i32 noundef %r, i32 noundef %rm, i64 noundef %offset) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %rm.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %rm, ptr %rm.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %opc.addr, align 4
  %2 = load i32, ptr %r.addr, align 4
  %3 = load i32, ptr %rm.addr, align 4
  %4 = load i64, ptr %offset.addr, align 8
  call void @tcg_out_modrm_sib_offset(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef -1, i32 noundef 0, i64 noundef %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_vex_modrm_offset(ptr noundef %s, i32 noundef %opc, i32 noundef %r, i32 noundef %v, i32 noundef %rm, i64 noundef %offset) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %v.addr = alloca i32, align 4
  %rm.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %v, ptr %v.addr, align 4
  store i32 %rm, ptr %rm.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %opc.addr, align 4
  %2 = load i32, ptr %r.addr, align 4
  %3 = load i32, ptr %v.addr, align 4
  %4 = load i32, ptr %rm.addr, align 4
  %5 = load i64, ptr %offset.addr, align 8
  call void @tcg_out_vex_modrm_sib_offset(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef -1, i32 noundef 0, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_modrm_sib_offset(ptr noundef %s, i32 noundef %opc, i32 noundef %r, i32 noundef %rm, i32 noundef %index, i32 noundef %shift, i64 noundef %offset) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %rm.addr = alloca i32, align 4
  %index.addr = alloca i32, align 4
  %shift.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %rm, ptr %rm.addr, align 4
  store i32 %index, ptr %index.addr, align 4
  store i32 %shift, ptr %shift.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %opc.addr, align 4
  %2 = load i32, ptr %r.addr, align 4
  %3 = load i32, ptr %rm.addr, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i32, ptr %rm.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %4, %cond.false ]
  %5 = load i32, ptr %index.addr, align 4
  %cmp1 = icmp slt i32 %5, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.end
  br label %cond.end4

cond.false3:                                      ; preds = %cond.end
  %6 = load i32, ptr %index.addr, align 4
  br label %cond.end4

cond.end4:                                        ; preds = %cond.false3, %cond.true2
  %cond5 = phi i32 [ 0, %cond.true2 ], [ %6, %cond.false3 ]
  call void @tcg_out_opc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %cond, i32 noundef %cond5)
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i32, ptr %r.addr, align 4
  %9 = load i32, ptr %rm.addr, align 4
  %10 = load i32, ptr %index.addr, align 4
  %11 = load i32, ptr %shift.addr, align 4
  %12 = load i64, ptr %offset.addr, align 8
  call void @tcg_out_sib_offset(ptr noundef %7, i32 noundef %8, i32 noundef %9, i32 noundef %10, i32 noundef %11, i64 noundef %12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_sib_offset(ptr noundef %s, i32 noundef %r, i32 noundef %rm, i32 noundef %index, i32 noundef %shift, i64 noundef %offset) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %r.addr = alloca i32, align 4
  %rm.addr = alloca i32, align 4
  %index.addr = alloca i32, align 4
  %shift.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  %mod = alloca i32, align 4
  %len = alloca i32, align 4
  %pc = alloca i64, align 8
  %disp = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %r, ptr %r.addr, align 4
  store i32 %rm, ptr %rm.addr, align 4
  store i32 %index, ptr %index.addr, align 4
  store i32 %shift, ptr %shift.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i32, ptr %index.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end21

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %rm.addr, align 4
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %if.then, label %if.end21

if.then:                                          ; preds = %land.lhs.true
  %2 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 23
  %3 = load ptr, ptr %code_ptr, align 8
  %4 = ptrtoint ptr %3 to i64
  %add = add i64 %4, 5
  %5 = load i32, ptr %rm.addr, align 4
  %not = xor i32 %5, -1
  %conv = sext i32 %not to i64
  %add2 = add i64 %add, %conv
  store i64 %add2, ptr %pc, align 8
  %6 = load i64, ptr %offset.addr, align 8
  %7 = load i64, ptr %pc, align 8
  %sub = sub i64 %6, %7
  store i64 %sub, ptr %disp, align 8
  %8 = load i64, ptr %disp, align 8
  %9 = load i64, ptr %disp, align 8
  %conv3 = trunc i64 %9 to i32
  %conv4 = sext i32 %conv3 to i64
  %cmp5 = icmp eq i64 %8, %conv4
  br i1 %cmp5, label %if.then7, label %if.end

if.then7:                                         ; preds = %if.then
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load i32, ptr %r.addr, align 4
  %and = and i32 %11, 7
  %shl = shl i32 %and, 3
  %or = or i32 %shl, 5
  %conv8 = trunc i32 %or to i8
  call void @tcg_out8(ptr noundef %10, i8 noundef zeroext %conv8)
  %12 = load ptr, ptr %s.addr, align 8
  %13 = load i64, ptr %disp, align 8
  %conv9 = trunc i64 %13 to i32
  call void @tcg_out32(ptr noundef %12, i32 noundef %conv9)
  br label %if.end90

if.end:                                           ; preds = %if.then
  %14 = load i64, ptr %offset.addr, align 8
  %15 = load i64, ptr %offset.addr, align 8
  %conv10 = trunc i64 %15 to i32
  %conv11 = sext i32 %conv10 to i64
  %cmp12 = icmp eq i64 %14, %conv11
  br i1 %cmp12, label %if.then14, label %if.end20

if.then14:                                        ; preds = %if.end
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i32, ptr %r.addr, align 4
  %and15 = and i32 %17, 7
  %shl16 = shl i32 %and15, 3
  %or17 = or i32 %shl16, 4
  %conv18 = trunc i32 %or17 to i8
  call void @tcg_out8(ptr noundef %16, i8 noundef zeroext %conv18)
  %18 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %18, i8 noundef zeroext 37)
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load i64, ptr %offset.addr, align 8
  %conv19 = trunc i64 %20 to i32
  call void @tcg_out32(ptr noundef %19, i32 noundef %conv19)
  br label %if.end90

if.end20:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.end20
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 729, ptr noundef @__func__.tcg_out_sib_offset, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %if.end21

if.end21:                                         ; preds = %do.end, %land.lhs.true, %entry
  %21 = load i32, ptr %rm.addr, align 4
  %cmp22 = icmp slt i32 %21, 0
  br i1 %cmp22, label %if.then24, label %if.else

if.then24:                                        ; preds = %if.end21
  store i32 0, ptr %mod, align 4
  store i32 4, ptr %len, align 4
  store i32 5, ptr %rm.addr, align 4
  br label %if.end41

if.else:                                          ; preds = %if.end21
  %22 = load i64, ptr %offset.addr, align 8
  %cmp25 = icmp eq i64 %22, 0
  br i1 %cmp25, label %land.lhs.true27, label %if.else32

land.lhs.true27:                                  ; preds = %if.else
  %23 = load i32, ptr %rm.addr, align 4
  %and28 = and i32 %23, 7
  %cmp29 = icmp ne i32 %and28, 5
  br i1 %cmp29, label %if.then31, label %if.else32

if.then31:                                        ; preds = %land.lhs.true27
  store i32 0, ptr %mod, align 4
  store i32 0, ptr %len, align 4
  br label %if.end40

if.else32:                                        ; preds = %land.lhs.true27, %if.else
  %24 = load i64, ptr %offset.addr, align 8
  %25 = load i64, ptr %offset.addr, align 8
  %conv33 = trunc i64 %25 to i8
  %conv34 = sext i8 %conv33 to i64
  %cmp35 = icmp eq i64 %24, %conv34
  br i1 %cmp35, label %if.then37, label %if.else38

if.then37:                                        ; preds = %if.else32
  store i32 64, ptr %mod, align 4
  store i32 1, ptr %len, align 4
  br label %if.end39

if.else38:                                        ; preds = %if.else32
  store i32 128, ptr %mod, align 4
  store i32 4, ptr %len, align 4
  br label %if.end39

if.end39:                                         ; preds = %if.else38, %if.then37
  br label %if.end40

if.end40:                                         ; preds = %if.end39, %if.then31
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.then24
  %26 = load i32, ptr %index.addr, align 4
  %cmp42 = icmp slt i32 %26, 0
  br i1 %cmp42, label %land.lhs.true44, label %if.else55

land.lhs.true44:                                  ; preds = %if.end41
  %27 = load i32, ptr %rm.addr, align 4
  %and45 = and i32 %27, 7
  %cmp46 = icmp ne i32 %and45, 4
  br i1 %cmp46, label %if.then48, label %if.else55

if.then48:                                        ; preds = %land.lhs.true44
  %28 = load ptr, ptr %s.addr, align 8
  %29 = load i32, ptr %mod, align 4
  %30 = load i32, ptr %r.addr, align 4
  %and49 = and i32 %30, 7
  %shl50 = shl i32 %and49, 3
  %or51 = or i32 %29, %shl50
  %31 = load i32, ptr %rm.addr, align 4
  %and52 = and i32 %31, 7
  %or53 = or i32 %or51, %and52
  %conv54 = trunc i32 %or53 to i8
  call void @tcg_out8(ptr noundef %28, i8 noundef zeroext %conv54)
  br label %if.end79

if.else55:                                        ; preds = %land.lhs.true44, %if.end41
  %32 = load i32, ptr %index.addr, align 4
  %cmp56 = icmp slt i32 %32, 0
  br i1 %cmp56, label %if.then58, label %if.else59

if.then58:                                        ; preds = %if.else55
  store i32 4, ptr %index.addr, align 4
  br label %if.end66

if.else59:                                        ; preds = %if.else55
  br label %do.body60

do.body60:                                        ; preds = %if.else59
  %33 = load i32, ptr %index.addr, align 4
  %cmp61 = icmp ne i32 %33, 4
  br i1 %cmp61, label %if.end64, label %if.then63

if.then63:                                        ; preds = %do.body60
  unreachable

if.end64:                                         ; preds = %do.body60
  br label %do.end65

do.end65:                                         ; preds = %if.end64
  br label %if.end66

if.end66:                                         ; preds = %do.end65, %if.then58
  %34 = load ptr, ptr %s.addr, align 8
  %35 = load i32, ptr %mod, align 4
  %36 = load i32, ptr %r.addr, align 4
  %and67 = and i32 %36, 7
  %shl68 = shl i32 %and67, 3
  %or69 = or i32 %35, %shl68
  %or70 = or i32 %or69, 4
  %conv71 = trunc i32 %or70 to i8
  call void @tcg_out8(ptr noundef %34, i8 noundef zeroext %conv71)
  %37 = load ptr, ptr %s.addr, align 8
  %38 = load i32, ptr %shift.addr, align 4
  %shl72 = shl i32 %38, 6
  %39 = load i32, ptr %index.addr, align 4
  %and73 = and i32 %39, 7
  %shl74 = shl i32 %and73, 3
  %or75 = or i32 %shl72, %shl74
  %40 = load i32, ptr %rm.addr, align 4
  %and76 = and i32 %40, 7
  %or77 = or i32 %or75, %and76
  %conv78 = trunc i32 %or77 to i8
  call void @tcg_out8(ptr noundef %37, i8 noundef zeroext %conv78)
  br label %if.end79

if.end79:                                         ; preds = %if.end66, %if.then48
  %41 = load i32, ptr %len, align 4
  %cmp80 = icmp eq i32 %41, 1
  br i1 %cmp80, label %if.then82, label %if.else84

if.then82:                                        ; preds = %if.end79
  %42 = load ptr, ptr %s.addr, align 8
  %43 = load i64, ptr %offset.addr, align 8
  %conv83 = trunc i64 %43 to i8
  call void @tcg_out8(ptr noundef %42, i8 noundef zeroext %conv83)
  br label %if.end90

if.else84:                                        ; preds = %if.end79
  %44 = load i32, ptr %len, align 4
  %cmp85 = icmp eq i32 %44, 4
  br i1 %cmp85, label %if.then87, label %if.end89

if.then87:                                        ; preds = %if.else84
  %45 = load ptr, ptr %s.addr, align 8
  %46 = load i64, ptr %offset.addr, align 8
  %conv88 = trunc i64 %46 to i32
  call void @tcg_out32(ptr noundef %45, i32 noundef %conv88)
  br label %if.end89

if.end89:                                         ; preds = %if.then87, %if.else84
  br label %if.end90

if.end90:                                         ; preds = %if.end89, %if.then82, %if.then14, %if.then7
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_vex_modrm_sib_offset(ptr noundef %s, i32 noundef %opc, i32 noundef %r, i32 noundef %v, i32 noundef %rm, i32 noundef %index, i32 noundef %shift, i64 noundef %offset) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %v.addr = alloca i32, align 4
  %rm.addr = alloca i32, align 4
  %index.addr = alloca i32, align 4
  %shift.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %v, ptr %v.addr, align 4
  store i32 %rm, ptr %rm.addr, align 4
  store i32 %index, ptr %index.addr, align 4
  store i32 %shift, ptr %shift.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %opc.addr, align 4
  %2 = load i32, ptr %r.addr, align 4
  %3 = load i32, ptr %v.addr, align 4
  %4 = load i32, ptr %rm.addr, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i32, ptr %rm.addr, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %5, %cond.false ]
  %6 = load i32, ptr %index.addr, align 4
  %cmp1 = icmp slt i32 %6, 0
  br i1 %cmp1, label %cond.true2, label %cond.false3

cond.true2:                                       ; preds = %cond.end
  br label %cond.end4

cond.false3:                                      ; preds = %cond.end
  %7 = load i32, ptr %index.addr, align 4
  br label %cond.end4

cond.end4:                                        ; preds = %cond.false3, %cond.true2
  %cond5 = phi i32 [ 0, %cond.true2 ], [ %7, %cond.false3 ]
  call void @tcg_out_vex_opc(ptr noundef %0, i32 noundef %1, i32 noundef %2, i32 noundef %3, i32 noundef %cond, i32 noundef %cond5)
  %8 = load ptr, ptr %s.addr, align 8
  %9 = load i32, ptr %r.addr, align 4
  %10 = load i32, ptr %rm.addr, align 4
  %11 = load i32, ptr %index.addr, align 4
  %12 = load i32, ptr %shift.addr, align 4
  %13 = load i64, ptr %offset.addr, align 8
  call void @tcg_out_sib_offset(ptr noundef %8, i32 noundef %9, i32 noundef %10, i32 noundef %11, i32 noundef %12, i64 noundef %13)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_type_size(i32 noundef %t) #0 {
entry:
  %t.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store i32 %t, ptr %t.addr, align 4
  %0 = load i32, ptr %t.addr, align 4
  store i32 %0, ptr %i, align 4
  %1 = load i32, ptr %i, align 4
  %cmp = icmp uge i32 %1, 3
  br i1 %cmp, label %if.then, label %if.end3

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load i32, ptr %i, align 4
  %cmp1 = icmp ult i32 %2, 6
  br i1 %cmp1, label %if.end, label %if.then2

if.then2:                                         ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %3 = load i32, ptr %i, align 4
  %sub = sub i32 %3, 2
  store i32 %sub, ptr %i, align 4
  br label %if.end3

if.end3:                                          ; preds = %do.end, %entry
  %4 = load i32, ptr %i, align 4
  %shl = shl i32 4, %4
  ret i32 %shl
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_regset_single(i32 noundef %d) #0 {
entry:
  %d.addr = alloca i32, align 4
  store i32 %d, ptr %d.addr, align 4
  %0 = load i32, ptr %d.addr, align 4
  %1 = load i32, ptr %d.addr, align 4
  %sub = sub i32 %1, 1
  %and = and i32 %0, %sub
  %cmp = icmp eq i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_regset_first(i32 noundef %d) #0 {
entry:
  %d.addr = alloca i32, align 4
  store i32 %d, ptr %d.addr, align 4
  %0 = load i32, ptr %d.addr, align 4
  %call = call i32 @ctz32(i32 noundef %0)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_reg_free(ptr noundef %s, i32 noundef %reg, i32 noundef %allocated_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %reg.addr = alloca i32, align 4
  %allocated_regs.addr = alloca i32, align 4
  %ts = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %reg, ptr %reg.addr, align 4
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %reg_to_temp = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 41
  %1 = load i32, ptr %reg.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr [32 x ptr], ptr %reg_to_temp, i64 0, i64 %idxprom
  %2 = load ptr, ptr %arrayidx, align 8
  store ptr %2, ptr %ts, align 8
  %3 = load ptr, ptr %ts, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load ptr, ptr %ts, align 8
  %6 = load i32, ptr %allocated_regs.addr, align 4
  call void @temp_sync(ptr noundef %4, ptr noundef %5, i32 noundef %6, i32 noundef 0, i32 noundef -1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_out_sti(ptr noundef %s, i32 noundef %type, i64 noundef %val, i32 noundef %base, i64 noundef %ofs) #0 {
entry:
  %retval = alloca i1, align 1
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %val.addr = alloca i64, align 8
  %base.addr = alloca i32, align 4
  %ofs.addr = alloca i64, align 8
  %rexw = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i64 %val, ptr %val.addr, align 8
  store i32 %base, ptr %base.addr, align 4
  store i64 %ofs, ptr %ofs.addr, align 8
  store i32 0, ptr %rexw, align 4
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %val.addr, align 8
  %2 = load i64, ptr %val.addr, align 8
  %conv = trunc i64 %2 to i32
  %conv1 = sext i32 %conv to i64
  %cmp2 = icmp ne i64 %1, %conv1
  br i1 %cmp2, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %if.then
  store i32 4096, ptr %rexw, align 4
  br label %if.end9

if.else:                                          ; preds = %entry
  %3 = load i32, ptr %type.addr, align 4
  %cmp5 = icmp ne i32 %3, 0
  br i1 %cmp5, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.else
  store i1 false, ptr %retval, align 1
  br label %return

if.end8:                                          ; preds = %if.else
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %if.end
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load i32, ptr %rexw, align 4
  %or = or i32 199, %5
  %6 = load i32, ptr %base.addr, align 4
  %7 = load i64, ptr %ofs.addr, align 8
  call void @tcg_out_modrm_offset(ptr noundef %4, i32 noundef %or, i32 noundef 0, i32 noundef %6, i64 noundef %7)
  %8 = load ptr, ptr %s.addr, align 8
  %9 = load i64, ptr %val.addr, align 8
  %conv10 = trunc i64 %9 to i32
  call void @tcg_out32(ptr noundef %8, i32 noundef %conv10)
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end9, %if.then7, %if.then4
  %10 = load i1, ptr %retval, align 1
  ret i1 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @temp_free_or_dead(ptr noundef %s, ptr noundef %ts, i32 noundef %free_or_dead) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ts.addr = alloca ptr, align 8
  %free_or_dead.addr = alloca i32, align 4
  %new_type = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  store i32 %free_or_dead, ptr %free_or_dead.addr, align 4
  %0 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %0, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  switch i32 %bf.cast, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb1
    i32 1, label %sw.bb1
    i32 0, label %sw.bb2
    i32 4, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry
  br label %return

sw.bb1:                                           ; preds = %entry, %entry
  store i32 2, ptr %new_type, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %1 = load i32, ptr %free_or_dead.addr, align 4
  %cmp = icmp slt i32 %1, 0
  %cond = select i1 %cmp, i32 2, i32 0
  store i32 %cond, ptr %new_type, align 4
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  store i32 3, ptr %new_type, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 4210, ptr noundef @__func__.temp_free_or_dead, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb3, %sw.bb2, %sw.bb1
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load ptr, ptr %ts.addr, align 8
  %4 = load i32, ptr %new_type, align 4
  call void @set_temp_val_nonreg(ptr noundef %2, ptr noundef %3, i32 noundef %4)
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_out_dup_vec(ptr noundef %s, i32 noundef %type, i32 noundef %vece, i32 noundef %r, i32 noundef %a) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %vex_l = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %a, ptr %a.addr, align 4
  %0 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %0, 1024
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %1, 5
  %cond = select i1 %cmp, i32 524288, i32 0
  store i32 %cond, ptr %vex_l, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %vece.addr, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [4 x i32], ptr @avx2_dup_insn, i64 0, i64 %idxprom
  %4 = load i32, ptr %arrayidx, align 4
  %5 = load i32, ptr %vex_l, align 4
  %add = add i32 %4, %5
  %6 = load i32, ptr %r.addr, align 4
  %7 = load i32, ptr %a.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %2, i32 noundef %add, i32 noundef %6, i32 noundef 0, i32 noundef %7)
  br label %if.end

if.else:                                          ; preds = %entry
  %8 = load i32, ptr %vece.addr, align 4
  switch i32 %8, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb1
    i32 2, label %sw.bb2
    i32 3, label %sw.bb3
  ]

sw.bb:                                            ; preds = %if.else
  %9 = load ptr, ptr %s.addr, align 8
  %10 = load i32, ptr %r.addr, align 4
  %11 = load i32, ptr %a.addr, align 4
  %12 = load i32, ptr %a.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %9, i32 noundef 1376, i32 noundef %10, i32 noundef %11, i32 noundef %12)
  %13 = load i32, ptr %r.addr, align 4
  store i32 %13, ptr %a.addr, align 4
  br label %sw.bb1

sw.bb1:                                           ; preds = %sw.bb, %if.else
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load i32, ptr %r.addr, align 4
  %16 = load i32, ptr %a.addr, align 4
  %17 = load i32, ptr %a.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %14, i32 noundef 1377, i32 noundef %15, i32 noundef %16, i32 noundef %17)
  %18 = load i32, ptr %r.addr, align 4
  store i32 %18, ptr %a.addr, align 4
  br label %sw.bb2

sw.bb2:                                           ; preds = %sw.bb1, %if.else
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load i32, ptr %r.addr, align 4
  %21 = load i32, ptr %a.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %19, i32 noundef 1392, i32 noundef %20, i32 noundef 0, i32 noundef %21)
  %22 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %22, i8 noundef zeroext 0)
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.else
  %23 = load ptr, ptr %s.addr, align 8
  %24 = load i32, ptr %r.addr, align 4
  %25 = load i32, ptr %a.addr, align 4
  %26 = load i32, ptr %a.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %23, i32 noundef 1388, i32 noundef %24, i32 noundef %25, i32 noundef %26)
  br label %sw.epilog

sw.default:                                       ; preds = %if.else
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 911, ptr noundef @__func__.tcg_out_dup_vec, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb3, %sw.bb2
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %if.then
  ret i1 true
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_out_dupm_vec(ptr noundef %s, i32 noundef %type, i32 noundef %vece, i32 noundef %r, i32 noundef %base, i64 noundef %offset) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %r.addr = alloca i32, align 4
  %base.addr = alloca i32, align 4
  %offset.addr = alloca i64, align 8
  %vex_l = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store i32 %r, ptr %r.addr, align 4
  store i32 %base, ptr %base.addr, align 4
  store i64 %offset, ptr %offset.addr, align 8
  %0 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %0, 1024
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %1, 5
  %cond = select i1 %cmp, i32 524288, i32 0
  store i32 %cond, ptr %vex_l, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %vece.addr, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [4 x i32], ptr @avx2_dup_insn, i64 0, i64 %idxprom
  %4 = load i32, ptr %arrayidx, align 4
  %5 = load i32, ptr %vex_l, align 4
  %add = add i32 %4, %5
  %6 = load i32, ptr %r.addr, align 4
  %7 = load i32, ptr %base.addr, align 4
  %8 = load i64, ptr %offset.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %2, i32 noundef %add, i32 noundef %6, i32 noundef 0, i32 noundef %7, i64 noundef %8)
  br label %if.end

if.else:                                          ; preds = %entry
  %9 = load i32, ptr %vece.addr, align 4
  switch i32 %9, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb1
    i32 1, label %sw.bb2
    i32 0, label %sw.bb3
  ]

sw.bb:                                            ; preds = %if.else
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load i32, ptr %r.addr, align 4
  %12 = load i32, ptr %base.addr, align 4
  %13 = load i64, ptr %offset.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %10, i32 noundef 262418, i32 noundef %11, i32 noundef 0, i32 noundef %12, i64 noundef %13)
  br label %sw.epilog

sw.bb1:                                           ; preds = %if.else
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load i32, ptr %r.addr, align 4
  %16 = load i32, ptr %base.addr, align 4
  %17 = load i64, ptr %offset.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %14, i32 noundef 1560, i32 noundef %15, i32 noundef 0, i32 noundef %16, i64 noundef %17)
  br label %sw.epilog

sw.bb2:                                           ; preds = %if.else
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load i32, ptr %r.addr, align 4
  %20 = load i32, ptr %r.addr, align 4
  %21 = load i32, ptr %base.addr, align 4
  %22 = load i64, ptr %offset.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %18, i32 noundef 1476, i32 noundef %19, i32 noundef %20, i32 noundef %21, i64 noundef %22)
  %23 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %23, i8 noundef zeroext 0)
  %24 = load ptr, ptr %s.addr, align 8
  %25 = load i32, ptr %type.addr, align 4
  %26 = load i32, ptr %vece.addr, align 4
  %27 = load i32, ptr %r.addr, align 4
  %28 = load i32, ptr %r.addr, align 4
  %call = call zeroext i1 @tcg_out_dup_vec(ptr noundef %24, i32 noundef %25, i32 noundef %26, i32 noundef %27, i32 noundef %28)
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.else
  %29 = load ptr, ptr %s.addr, align 8
  %30 = load i32, ptr %r.addr, align 4
  %31 = load i32, ptr %r.addr, align 4
  %32 = load i32, ptr %base.addr, align 4
  %33 = load i64, ptr %offset.addr, align 8
  call void @tcg_out_vex_modrm_offset(ptr noundef %29, i32 noundef 66592, i32 noundef %30, i32 noundef %31, i32 noundef %32, i64 noundef %33)
  %34 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %34, i8 noundef zeroext 0)
  %35 = load ptr, ptr %s.addr, align 8
  %36 = load i32, ptr %type.addr, align 4
  %37 = load i32, ptr %vece.addr, align 4
  %38 = load i32, ptr %r.addr, align 4
  %39 = load i32, ptr %r.addr, align 4
  %call4 = call zeroext i1 @tcg_out_dup_vec(ptr noundef %35, i32 noundef %36, i32 noundef %37, i32 noundef %38, i32 noundef %39)
  br label %sw.epilog

sw.default:                                       ; preds = %if.else
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 943, ptr noundef @__func__.tcg_out_dupm_vec, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %if.then
  ret i1 true
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @tcg_get_insn_param(ptr noundef %op, i32 noundef %arg) #0 {
entry:
  %op.addr = alloca ptr, align 8
  %arg.addr = alloca i32, align 4
  store ptr %op, ptr %op.addr, align 8
  store i32 %arg, ptr %arg.addr, align 4
  %0 = load ptr, ptr %op.addr, align 8
  %args = getelementptr inbounds %struct.TCGOp, ptr %0, i32 0, i32 4
  %1 = load i32, ptr %arg.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr [0 x i64], ptr %args, i64 0, i64 %idxprom
  %2 = load i64, ptr %arrayidx, align 8
  ret i64 %2
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @temp_save(ptr noundef %s, ptr noundef %ts, i32 noundef %allocated_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ts.addr = alloca ptr, align 8
  %allocated_regs.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %0, align 8
  %bf.lshr = lshr i64 %bf.load, 8
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 2
  br i1 %cmp, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  %1 = load ptr, ptr %ts.addr, align 8
  %call = call zeroext i1 @temp_readonly(ptr noundef %1)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  unreachable

if.end:                                           ; preds = %lor.lhs.false, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @save_globals(ptr noundef %s, i32 noundef %allocated_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %allocated_regs.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  store i32 0, ptr %i, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %nb_globals = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %nb_globals, align 4
  store i32 %1, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %n, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %5, i32 0, i32 37
  %6 = load i32, ptr %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  %7 = load i32, ptr %allocated_regs.addr, align 4
  call void @temp_save(ptr noundef %4, ptr noundef %arrayidx, i32 noundef %7)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load i32, ptr %i, align 4
  %inc = add i32 %8, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !105

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @load_arg_normal(ptr noundef %s, ptr noundef %l, ptr noundef %ts, ptr noundef %allocated_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %l.addr = alloca ptr, align 8
  %ts.addr = alloca ptr, align 8
  %allocated_regs.addr = alloca ptr, align 8
  %reg = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %l, ptr %l.addr, align 8
  store ptr %ts, ptr %ts.addr, align 8
  store ptr %allocated_regs, ptr %allocated_regs.addr, align 8
  %0 = load ptr, ptr %l.addr, align 8
  %bf.load = load i32, ptr %0, align 4
  %bf.lshr = lshr i32 %bf.load, 8
  %bf.clear = and i32 %bf.lshr, 255
  %call = call zeroext i1 @arg_slot_reg_p(i32 noundef %bf.clear)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %l.addr, align 8
  %bf.load1 = load i32, ptr %1, align 4
  %bf.lshr2 = lshr i32 %bf.load1, 8
  %bf.clear3 = and i32 %bf.lshr2, 255
  %idxprom = zext i32 %bf.clear3 to i64
  %arrayidx = getelementptr [6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 %idxprom
  %2 = load i32, ptr %arrayidx, align 4
  store i32 %2, ptr %reg, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load i32, ptr %reg, align 4
  %5 = load ptr, ptr %ts.addr, align 8
  %6 = load ptr, ptr %allocated_regs.addr, align 8
  %7 = load i32, ptr %6, align 4
  call void @load_arg_reg(ptr noundef %3, i32 noundef %4, ptr noundef %5, i32 noundef %7)
  %8 = load i32, ptr %reg, align 4
  %shl = shl i32 1, %8
  %9 = load ptr, ptr %allocated_regs.addr, align 8
  %10 = load i32, ptr %9, align 4
  %or = or i32 %10, %shl
  store i32 %or, ptr %9, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load ptr, ptr %l.addr, align 8
  %bf.load4 = load i32, ptr %12, align 4
  %bf.lshr5 = lshr i32 %bf.load4, 8
  %bf.clear6 = and i32 %bf.lshr5, 255
  %13 = load ptr, ptr %ts.addr, align 8
  %14 = load ptr, ptr %allocated_regs.addr, align 8
  %15 = load i32, ptr %14, align 4
  call void @load_arg_stk(ptr noundef %11, i32 noundef %bf.clear6, ptr noundef %13, i32 noundef %15)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @load_arg_stk(ptr noundef %s, i32 noundef %arg_slot, ptr noundef %ts, i32 noundef %allocated_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %arg_slot.addr = alloca i32, align 4
  %ts.addr = alloca ptr, align 8
  %allocated_regs.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %arg_slot, ptr %arg_slot.addr, align 4
  store ptr %ts, ptr %ts.addr, align 8
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %ts.addr, align 8
  %2 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %2, align 8
  %bf.lshr = lshr i64 %bf.load, 24
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  %idxprom = zext i32 %bf.cast to i64
  %arrayidx = getelementptr [6 x i32], ptr @tcg_target_available_regs, i64 0, i64 %idxprom
  %3 = load i32, ptr %arrayidx, align 4
  %4 = load i32, ptr %allocated_regs.addr, align 4
  call void @temp_load(ptr noundef %0, ptr noundef %1, i32 noundef %3, i32 noundef %4, i32 noundef 0)
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load ptr, ptr %ts.addr, align 8
  %bf.load1 = load i64, ptr %6, align 8
  %bf.lshr2 = lshr i64 %bf.load1, 24
  %bf.clear3 = and i64 %bf.lshr2, 255
  %bf.cast4 = trunc i64 %bf.clear3 to i32
  %7 = load ptr, ptr %ts.addr, align 8
  %bf.load5 = load i64, ptr %7, align 8
  %bf.clear6 = and i64 %bf.load5, 255
  %bf.cast7 = trunc i64 %bf.clear6 to i32
  %8 = load i32, ptr %arg_slot.addr, align 4
  %call = call i32 @arg_slot_stk_ofs(i32 noundef %8)
  %conv = sext i32 %call to i64
  call void @tcg_out_st(ptr noundef %5, i32 noundef %bf.cast4, i32 noundef %bf.cast7, i32 noundef 4, i64 noundef %conv)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @load_arg_ref(ptr noundef %s, i32 noundef %arg_slot, i32 noundef %ref_base, i64 noundef %ref_off, ptr noundef %allocated_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %arg_slot.addr = alloca i32, align 4
  %ref_base.addr = alloca i32, align 4
  %ref_off.addr = alloca i64, align 8
  %allocated_regs.addr = alloca ptr, align 8
  %reg = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %arg_slot, ptr %arg_slot.addr, align 4
  store i32 %ref_base, ptr %ref_base.addr, align 4
  store i64 %ref_off, ptr %ref_off.addr, align 8
  store ptr %allocated_regs, ptr %allocated_regs.addr, align 8
  %0 = load i32, ptr %arg_slot.addr, align 4
  %call = call zeroext i1 @arg_slot_reg_p(i32 noundef %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32, ptr %arg_slot.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr [6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 %idxprom
  %2 = load i32, ptr %arrayidx, align 4
  store i32 %2, ptr %reg, align 4
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load i32, ptr %reg, align 4
  %5 = load ptr, ptr %allocated_regs.addr, align 8
  %6 = load i32, ptr %5, align 4
  call void @tcg_reg_free(ptr noundef %3, i32 noundef %4, i32 noundef %6)
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i32, ptr %reg, align 4
  %9 = load i32, ptr %ref_base.addr, align 4
  %10 = load i64, ptr %ref_off.addr, align 8
  call void @tcg_out_addi_ptr(ptr noundef %7, i32 noundef %8, i32 noundef %9, i64 noundef %10)
  %11 = load i32, ptr %reg, align 4
  %shl = shl i32 1, %11
  %12 = load ptr, ptr %allocated_regs.addr, align 8
  %13 = load i32, ptr %12, align 4
  %or = or i32 %13, %shl
  store i32 %or, ptr %12, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load i32, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_available_regs, i64 0, i64 1), align 4
  %16 = load ptr, ptr %allocated_regs.addr, align 8
  %17 = load i32, ptr %16, align 4
  %call1 = call i32 @tcg_reg_alloc(ptr noundef %14, i32 noundef %15, i32 noundef %17, i32 noundef 0, i1 noundef zeroext false)
  store i32 %call1, ptr %reg, align 4
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load i32, ptr %reg, align 4
  %20 = load i32, ptr %ref_base.addr, align 4
  %21 = load i64, ptr %ref_off.addr, align 8
  call void @tcg_out_addi_ptr(ptr noundef %18, i32 noundef %19, i32 noundef %20, i64 noundef %21)
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load i32, ptr %reg, align 4
  %24 = load i32, ptr %arg_slot.addr, align 4
  %call2 = call i32 @arg_slot_stk_ofs(i32 noundef %24)
  %conv = sext i32 %call2 to i64
  call void @tcg_out_st(ptr noundef %22, i32 noundef 1, i32 noundef %23, i32 noundef 4, i64 noundef %conv)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @arg_slot_stk_ofs(i32 noundef %arg_slot) #0 {
entry:
  %arg_slot.addr = alloca i32, align 4
  %max = alloca i32, align 4
  %stk_slot = alloca i32, align 4
  store i32 %arg_slot, ptr %arg_slot.addr, align 4
  store i32 16, ptr %max, align 4
  %0 = load i32, ptr %arg_slot.addr, align 4
  %conv = zext i32 %0 to i64
  %sub = sub i64 %conv, 6
  %conv1 = trunc i64 %sub to i32
  store i32 %conv1, ptr %stk_slot, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32, ptr %stk_slot, align 4
  %2 = load i32, ptr %max, align 4
  %cmp = icmp ult i32 %1, %2
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %3 = load i32, ptr %stk_slot, align 4
  %conv3 = zext i32 %3 to i64
  %mul = mul i64 %conv3, 8
  %add = add i64 0, %mul
  %conv4 = trunc i64 %add to i32
  ret i32 %conv4
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @sync_globals(ptr noundef %s, i32 noundef %allocated_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %allocated_regs.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %ts = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  store i32 0, ptr %i, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %nb_globals = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 6
  %1 = load i32, ptr %nb_globals, align 4
  store i32 %1, ptr %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, ptr %i, align 4
  %3 = load i32, ptr %n, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 37
  %5 = load i32, ptr %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %ts, align 8
  br label %do.body

do.body:                                          ; preds = %for.body
  %6 = load ptr, ptr %ts, align 8
  %bf.load = load i64, ptr %6, align 8
  %bf.lshr = lshr i64 %bf.load, 8
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp1 = icmp ne i32 %bf.cast, 1
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  %7 = load ptr, ptr %ts, align 8
  %bf.load2 = load i64, ptr %7, align 8
  %bf.lshr3 = lshr i64 %bf.load2, 32
  %bf.clear4 = and i64 %bf.lshr3, 7
  %bf.cast5 = trunc i64 %bf.clear4 to i32
  %cmp6 = icmp eq i32 %bf.cast5, 3
  br i1 %cmp6, label %if.end, label %lor.lhs.false7

lor.lhs.false7:                                   ; preds = %lor.lhs.false
  %8 = load ptr, ptr %ts, align 8
  %bf.load8 = load i64, ptr %8, align 8
  %bf.lshr9 = lshr i64 %bf.load8, 37
  %bf.clear10 = and i64 %bf.lshr9, 1
  %bf.cast11 = trunc i64 %bf.clear10 to i32
  %tobool = icmp ne i32 %bf.cast11, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false7
  unreachable

if.end:                                           ; preds = %lor.lhs.false7, %lor.lhs.false, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %9 = load i32, ptr %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !106

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_call(ptr noundef %s, ptr noundef %dest, ptr noundef %info) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  %info.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  store ptr %info, ptr %info.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %dest.addr, align 8
  call void @tcg_out_branch(ptr noundef %0, i32 noundef 1, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @load_arg_reg(ptr noundef %s, i32 noundef %reg, ptr noundef %ts, i32 noundef %allocated_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %reg.addr = alloca i32, align 4
  %ts.addr = alloca ptr, align 8
  %allocated_regs.addr = alloca i32, align 4
  %arg_set = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %reg, ptr %reg.addr, align 4
  store ptr %ts, ptr %ts.addr, align 8
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  %0 = load ptr, ptr %ts.addr, align 8
  %bf.load = load i64, ptr %0, align 8
  %bf.lshr = lshr i64 %bf.load, 8
  %bf.clear = and i64 %bf.lshr, 255
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %ts.addr, align 8
  %bf.load1 = load i64, ptr %1, align 8
  %bf.clear2 = and i64 %bf.load1, 255
  %bf.cast3 = trunc i64 %bf.clear2 to i32
  %2 = load i32, ptr %reg.addr, align 4
  %cmp4 = icmp ne i32 %bf.cast3, %2
  br i1 %cmp4, label %if.then5, label %if.end21

if.then5:                                         ; preds = %if.then
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load i32, ptr %reg.addr, align 4
  %5 = load i32, ptr %allocated_regs.addr, align 4
  call void @tcg_reg_free(ptr noundef %3, i32 noundef %4, i32 noundef %5)
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load ptr, ptr %ts.addr, align 8
  %bf.load6 = load i64, ptr %7, align 8
  %bf.lshr7 = lshr i64 %bf.load6, 24
  %bf.clear8 = and i64 %bf.lshr7, 255
  %bf.cast9 = trunc i64 %bf.clear8 to i32
  %8 = load i32, ptr %reg.addr, align 4
  %9 = load ptr, ptr %ts.addr, align 8
  %bf.load10 = load i64, ptr %9, align 8
  %bf.clear11 = and i64 %bf.load10, 255
  %bf.cast12 = trunc i64 %bf.clear11 to i32
  %call = call zeroext i1 @tcg_out_mov(ptr noundef %6, i32 noundef %bf.cast9, i32 noundef %8, i32 noundef %bf.cast12)
  br i1 %call, label %if.end, label %if.then13

if.then13:                                        ; preds = %if.then5
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load ptr, ptr %ts.addr, align 8
  %12 = load i32, ptr %allocated_regs.addr, align 4
  call void @temp_sync(ptr noundef %10, ptr noundef %11, i32 noundef %12, i32 noundef 0, i32 noundef 0)
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load ptr, ptr %ts.addr, align 8
  %bf.load14 = load i64, ptr %14, align 8
  %bf.lshr15 = lshr i64 %bf.load14, 24
  %bf.clear16 = and i64 %bf.lshr15, 255
  %bf.cast17 = trunc i64 %bf.clear16 to i32
  %15 = load i32, ptr %reg.addr, align 4
  %16 = load ptr, ptr %ts.addr, align 8
  %mem_base = getelementptr inbounds %struct.TCGTemp, ptr %16, i32 0, i32 2
  %17 = load ptr, ptr %mem_base, align 8
  %bf.load18 = load i64, ptr %17, align 8
  %bf.clear19 = and i64 %bf.load18, 255
  %bf.cast20 = trunc i64 %bf.clear19 to i32
  %18 = load ptr, ptr %ts.addr, align 8
  %mem_offset = getelementptr inbounds %struct.TCGTemp, ptr %18, i32 0, i32 3
  %19 = load i64, ptr %mem_offset, align 8
  call void @tcg_out_ld(ptr noundef %13, i32 noundef %bf.cast17, i32 noundef %15, i32 noundef %bf.cast20, i64 noundef %19)
  br label %if.end

if.end:                                           ; preds = %if.then13, %if.then5
  br label %if.end21

if.end21:                                         ; preds = %if.end, %if.then
  br label %if.end22

if.else:                                          ; preds = %entry
  store i32 0, ptr %arg_set, align 4
  %20 = load ptr, ptr %s.addr, align 8
  %21 = load i32, ptr %reg.addr, align 4
  %22 = load i32, ptr %allocated_regs.addr, align 4
  call void @tcg_reg_free(ptr noundef %20, i32 noundef %21, i32 noundef %22)
  %23 = load i32, ptr %reg.addr, align 4
  %shl = shl i32 1, %23
  %24 = load i32, ptr %arg_set, align 4
  %or = or i32 %24, %shl
  store i32 %or, ptr %arg_set, align 4
  %25 = load ptr, ptr %s.addr, align 8
  %26 = load ptr, ptr %ts.addr, align 8
  %27 = load i32, ptr %arg_set, align 4
  %28 = load i32, ptr %allocated_regs.addr, align 4
  call void @temp_load(ptr noundef %25, ptr noundef %26, i32 noundef %27, i32 noundef %28, i32 noundef 0)
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.end21
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_addi_ptr(ptr noundef %s, i32 noundef %rd, i32 noundef %rs, i64 noundef %imm) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %rd.addr = alloca i32, align 4
  %rs.addr = alloca i32, align 4
  %imm.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %rd, ptr %rd.addr, align 4
  store i32 %rs, ptr %rs.addr, align 4
  store i64 %imm, ptr %imm.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i64, ptr %imm.addr, align 8
  %1 = load i64, ptr %imm.addr, align 8
  %conv = trunc i64 %1 to i32
  %conv1 = sext i32 %conv to i64
  %cmp = icmp eq i64 %0, %conv1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %rd.addr, align 4
  %4 = load i32, ptr %rs.addr, align 4
  %5 = load i64, ptr %imm.addr, align 8
  call void @tcg_out_modrm_offset(ptr noundef %2, i32 noundef 4237, i32 noundef %3, i32 noundef %4, i64 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_branch(ptr noundef %s, i32 noundef %call, ptr noundef %dest) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %call.addr = alloca i32, align 4
  %dest.addr = alloca ptr, align 8
  %disp = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %call, ptr %call.addr, align 4
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %dest.addr, align 8
  %call1 = call i64 @tcg_pcrel_diff(ptr noundef %0, ptr noundef %1)
  %sub = sub i64 %call1, 5
  store i64 %sub, ptr %disp, align 8
  %2 = load i64, ptr %disp, align 8
  %3 = load i64, ptr %disp, align 8
  %conv = trunc i64 %3 to i32
  %conv2 = sext i32 %conv to i64
  %cmp = icmp eq i64 %2, %conv2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load i32, ptr %call.addr, align 4
  %tobool = icmp ne i32 %5, 0
  %cond = select i1 %tobool, i32 232, i32 233
  call void @tcg_out_opc(ptr noundef %4, i32 noundef %cond, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load i64, ptr %disp, align 8
  %conv4 = trunc i64 %7 to i32
  call void @tcg_out32(ptr noundef %6, i32 noundef %conv4)
  br label %if.end

if.else:                                          ; preds = %entry
  %8 = load ptr, ptr %s.addr, align 8
  call void @tcg_out_opc(ptr noundef %8, i32 noundef 255, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  %9 = load ptr, ptr %s.addr, align 8
  %10 = load i32, ptr %call.addr, align 4
  %tobool5 = icmp ne i32 %10, 0
  %cond6 = select i1 %tobool5, i32 2, i32 4
  %shl = shl i32 %cond6, 3
  %or = or i32 %shl, 5
  %conv7 = trunc i32 %or to i8
  call void @tcg_out8(ptr noundef %9, i8 noundef zeroext %conv7)
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load ptr, ptr %dest.addr, align 8
  %13 = ptrtoint ptr %12 to i64
  %14 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %14, i32 0, i32 23
  %15 = load ptr, ptr %code_ptr, align 8
  call void @new_pool_label(ptr noundef %11, i64 noundef %13, i32 noundef 2, ptr noundef %15, i64 noundef -4)
  %16 = load ptr, ptr %s.addr, align 8
  call void @tcg_out32(ptr noundef %16, i32 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_jmp(ptr noundef %s, ptr noundef %dest) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dest.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %dest, ptr %dest.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %dest.addr, align 8
  call void @tcg_out_branch(ptr noundef %0, i32 noundef 0, ptr noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_nopn(ptr noundef %s, i32 noundef %n) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %n.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %n, ptr %n.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i32, ptr %n.addr, align 4
  %cmp = icmp sge i32 %0, 1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  store i32 1, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %1 = load i32, ptr %i, align 4
  %2 = load i32, ptr %n.addr, align 4
  %cmp1 = icmp slt i32 %1, %2
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %3, i8 noundef zeroext 102)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, ptr %i, align 4
  %inc = add i32 %4, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !107

for.end:                                          ; preds = %for.cond
  %5 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %5, i8 noundef zeroext -112)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @set_jmp_insn_offset(ptr noundef %s, i32 noundef %which) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %which.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %which, ptr %which.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %call = call i64 @tcg_current_code_size(ptr noundef %0)
  %conv = trunc i64 %call to i16
  %1 = load ptr, ptr %s.addr, align 8
  %gen_tb = getelementptr inbounds %struct.TCGContext, ptr %1, i32 0, i32 21
  %2 = load ptr, ptr %gen_tb, align 8
  %jmp_insn_offset = getelementptr inbounds %struct.TranslationBlock, ptr %2, i32 0, i32 10
  %3 = load i32, ptr %which.addr, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [2 x i16], ptr %jmp_insn_offset, i64 0, i64 %idxprom
  store i16 %conv, ptr %arrayidx, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @set_jmp_reset_offset(ptr noundef %s, i32 noundef %which) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %which.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %which, ptr %which.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %call = call i64 @tcg_current_code_size(ptr noundef %0)
  %conv = trunc i64 %call to i16
  %1 = load ptr, ptr %s.addr, align 8
  %gen_tb = getelementptr inbounds %struct.TCGContext, ptr %1, i32 0, i32 21
  %2 = load ptr, ptr %gen_tb, align 8
  %jmp_reset_offset = getelementptr inbounds %struct.TranslationBlock, ptr %2, i32 0, i32 9
  %3 = load i32, ptr %which.addr, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [2 x i16], ptr %jmp_reset_offset, i64 0, i64 %idxprom
  store i16 %conv, ptr %arrayidx, align 2
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @deposit64(i64 noundef %value, i32 noundef %start, i32 noundef %length, i64 noundef %fieldval) #0 {
entry:
  %value.addr = alloca i64, align 8
  %start.addr = alloca i32, align 4
  %length.addr = alloca i32, align 4
  %fieldval.addr = alloca i64, align 8
  %mask = alloca i64, align 8
  store i64 %value, ptr %value.addr, align 8
  store i32 %start, ptr %start.addr, align 4
  store i32 %length, ptr %length.addr, align 4
  store i64 %fieldval, ptr %fieldval.addr, align 8
  %0 = load i32, ptr %start.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, ptr %length.addr, align 4
  %cmp1 = icmp sgt i32 %1, 0
  br i1 %cmp1, label %land.lhs.true2, label %if.else

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = load i32, ptr %length.addr, align 4
  %3 = load i32, ptr %start.addr, align 4
  %sub = sub i32 64, %3
  %cmp3 = icmp sle i32 %2, %sub
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true2
  br label %if.end

if.else:                                          ; preds = %land.lhs.true2, %land.lhs.true, %entry
  call void @__assert_fail(ptr noundef @.str.127, ptr noundef @.str.40, i32 noundef 496, ptr noundef @__PRETTY_FUNCTION__.deposit64) #19
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load i32, ptr %length.addr, align 4
  %sub4 = sub i32 64, %4
  %sh_prom = zext i32 %sub4 to i64
  %shr = lshr i64 -1, %sh_prom
  %5 = load i32, ptr %start.addr, align 4
  %sh_prom5 = zext i32 %5 to i64
  %shl = shl i64 %shr, %sh_prom5
  store i64 %shl, ptr %mask, align 8
  %6 = load i64, ptr %value.addr, align 8
  %7 = load i64, ptr %mask, align 8
  %not = xor i64 %7, -1
  %and = and i64 %6, %not
  %8 = load i64, ptr %fieldval.addr, align 8
  %9 = load i32, ptr %start.addr, align 4
  %sh_prom6 = zext i32 %9 to i64
  %shl7 = shl i64 %8, %sh_prom6
  %10 = load i64, ptr %mask, align 8
  %and8 = and i64 %shl7, %10
  %or = or i64 %and, %and8
  ret i64 %or
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_target_const_match(i64 noundef %val, i32 noundef %type, i32 noundef %ct, i32 noundef %vece) #0 {
entry:
  %retval = alloca i1, align 1
  %val.addr = alloca i64, align 8
  %type.addr = alloca i32, align 4
  %ct.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  store i64 %val, ptr %val.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %ct, ptr %ct.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  %0 = load i32, ptr %ct.addr, align 4
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %2 = load i32, ptr %ct.addr, align 4
  %and2 = and i32 %2, 1792
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then1
  store i1 true, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.then1
  br label %if.end32

if.else:                                          ; preds = %if.end
  %3 = load i32, ptr %ct.addr, align 4
  %and6 = and i32 %3, 256
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end12

land.lhs.true:                                    ; preds = %if.else
  %4 = load i64, ptr %val.addr, align 8
  %5 = load i64, ptr %val.addr, align 8
  %conv = trunc i64 %5 to i32
  %conv8 = sext i32 %conv to i64
  %cmp9 = icmp eq i64 %4, %conv8
  br i1 %cmp9, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true
  store i1 true, ptr %retval, align 1
  br label %return

if.end12:                                         ; preds = %land.lhs.true, %if.else
  %6 = load i32, ptr %ct.addr, align 4
  %and13 = and i32 %6, 512
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %land.lhs.true15, label %if.end21

land.lhs.true15:                                  ; preds = %if.end12
  %7 = load i64, ptr %val.addr, align 8
  %8 = load i64, ptr %val.addr, align 8
  %conv16 = trunc i64 %8 to i32
  %conv17 = zext i32 %conv16 to i64
  %cmp18 = icmp eq i64 %7, %conv17
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true15
  store i1 true, ptr %retval, align 1
  br label %return

if.end21:                                         ; preds = %land.lhs.true15, %if.end12
  %9 = load i32, ptr %ct.addr, align 4
  %and22 = and i32 %9, 1024
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %land.lhs.true24, label %if.end31

land.lhs.true24:                                  ; preds = %if.end21
  %10 = load i64, ptr %val.addr, align 8
  %not = xor i64 %10, -1
  %11 = load i64, ptr %val.addr, align 8
  %not25 = xor i64 %11, -1
  %conv26 = trunc i64 %not25 to i32
  %conv27 = sext i32 %conv26 to i64
  %cmp28 = icmp eq i64 %not, %conv27
  br i1 %cmp28, label %if.then30, label %if.end31

if.then30:                                        ; preds = %land.lhs.true24
  store i1 true, ptr %retval, align 1
  br label %return

if.end31:                                         ; preds = %land.lhs.true24, %if.end21
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.end5
  %12 = load i32, ptr %ct.addr, align 4
  %and33 = and i32 %12, 2048
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %land.lhs.true35, label %if.end42

land.lhs.true35:                                  ; preds = %if.end32
  %13 = load i64, ptr %val.addr, align 8
  %14 = load i32, ptr %type.addr, align 4
  %cmp36 = icmp eq i32 %14, 0
  %cond = select i1 %cmp36, i32 32, i32 64
  %conv38 = sext i32 %cond to i64
  %cmp39 = icmp eq i64 %13, %conv38
  br i1 %cmp39, label %if.then41, label %if.end42

if.then41:                                        ; preds = %land.lhs.true35
  store i1 true, ptr %retval, align 1
  br label %return

if.end42:                                         ; preds = %land.lhs.true35, %if.end32
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end42, %if.then41, %if.then30, %if.then20, %if.then11, %if.then4, %if.then
  %15 = load i1, ptr %retval, align 1
  ret i1 %15
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_reg_alloc_pair(ptr noundef %s, i32 noundef %required_regs, i32 noundef %allocated_regs, i32 noundef %preferred_regs, i1 noundef zeroext %rev) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %required_regs.addr = alloca i32, align 4
  %allocated_regs.addr = alloca i32, align 4
  %preferred_regs.addr = alloca i32, align 4
  %rev.addr = alloca i8, align 1
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %k = alloca i32, align 4
  %fmin = alloca i32, align 4
  %n = alloca i32, align 4
  %reg_ct = alloca [2 x i32], align 4
  %order = alloca ptr, align 8
  %set = alloca i32, align 4
  %reg = alloca i32, align 4
  %f = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %required_regs, ptr %required_regs.addr, align 4
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  store i32 %preferred_regs, ptr %preferred_regs.addr, align 4
  %frombool = zext i1 %rev to i8
  store i8 %frombool, ptr %rev.addr, align 1
  store i32 31, ptr %n, align 4
  %0 = load i32, ptr %required_regs.addr, align 4
  %1 = load i32, ptr %allocated_regs.addr, align 4
  %2 = load i32, ptr %allocated_regs.addr, align 4
  %shr = lshr i32 %2, 1
  %or = or i32 %1, %shr
  %not = xor i32 %or, -1
  %and = and i32 %0, %not
  %arrayidx = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 1
  store i32 %and, ptr %arrayidx, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %arrayidx1 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 1
  %3 = load i32, ptr %arrayidx1, align 4
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %arrayidx2 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 1
  %4 = load i32, ptr %arrayidx2, align 4
  %5 = load i32, ptr %preferred_regs.addr, align 4
  %and3 = and i32 %4, %5
  %arrayidx4 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 0
  store i32 %and3, ptr %arrayidx4, align 4
  %6 = load i8, ptr %rev.addr, align 1
  %tobool = trunc i8 %6 to i1
  %cond = select i1 %tobool, ptr @indirect_reg_alloc_order, ptr @tcg_target_reg_alloc_order
  store ptr %cond, ptr %order, align 8
  %arrayidx5 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 0
  %7 = load i32, ptr %arrayidx5, align 4
  %cmp6 = icmp eq i32 %7, 0
  br i1 %cmp6, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.end
  %arrayidx7 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 0
  %8 = load i32, ptr %arrayidx7, align 4
  %arrayidx8 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 1
  %9 = load i32, ptr %arrayidx8, align 4
  %cmp9 = icmp eq i32 %8, %9
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.end
  %10 = phi i1 [ true, %do.end ], [ %cmp9, %lor.rhs ]
  %lor.ext = zext i1 %10 to i32
  store i32 %lor.ext, ptr %k, align 4
  store i32 2, ptr %fmin, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc42, %lor.end
  %11 = load i32, ptr %fmin, align 4
  %cmp10 = icmp sge i32 %11, 0
  br i1 %cmp10, label %for.body, label %for.end43

for.body:                                         ; preds = %for.cond
  %12 = load i32, ptr %k, align 4
  store i32 %12, ptr %j, align 4
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc39, %for.body
  %13 = load i32, ptr %j, align 4
  %cmp12 = icmp slt i32 %13, 2
  br i1 %cmp12, label %for.body13, label %for.end41

for.body13:                                       ; preds = %for.cond11
  %14 = load i32, ptr %j, align 4
  %idxprom = sext i32 %14 to i64
  %arrayidx14 = getelementptr [2 x i32], ptr %reg_ct, i64 0, i64 %idxprom
  %15 = load i32, ptr %arrayidx14, align 4
  store i32 %15, ptr %set, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond15

for.cond15:                                       ; preds = %for.inc, %for.body13
  %16 = load i32, ptr %i, align 4
  %17 = load i32, ptr %n, align 4
  %cmp16 = icmp slt i32 %16, %17
  br i1 %cmp16, label %for.body17, label %for.end

for.body17:                                       ; preds = %for.cond15
  %18 = load ptr, ptr %order, align 8
  %19 = load i32, ptr %i, align 4
  %idxprom18 = sext i32 %19 to i64
  %arrayidx19 = getelementptr i32, ptr %18, i64 %idxprom18
  %20 = load i32, ptr %arrayidx19, align 4
  store i32 %20, ptr %reg, align 4
  %21 = load i32, ptr %set, align 4
  %22 = load i32, ptr %reg, align 4
  %shr20 = lshr i32 %21, %22
  %and21 = and i32 %shr20, 1
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then23, label %if.end38

if.then23:                                        ; preds = %for.body17
  %23 = load ptr, ptr %s.addr, align 8
  %reg_to_temp = getelementptr inbounds %struct.TCGContext, ptr %23, i32 0, i32 41
  %24 = load i32, ptr %reg, align 4
  %idxprom24 = zext i32 %24 to i64
  %arrayidx25 = getelementptr [32 x ptr], ptr %reg_to_temp, i64 0, i64 %idxprom24
  %25 = load ptr, ptr %arrayidx25, align 8
  %tobool26 = icmp ne ptr %25, null
  %lnot = xor i1 %tobool26, true
  %lnot.ext = zext i1 %lnot to i32
  %26 = load ptr, ptr %s.addr, align 8
  %reg_to_temp27 = getelementptr inbounds %struct.TCGContext, ptr %26, i32 0, i32 41
  %27 = load i32, ptr %reg, align 4
  %add = add i32 %27, 1
  %idxprom28 = zext i32 %add to i64
  %arrayidx29 = getelementptr [32 x ptr], ptr %reg_to_temp27, i64 0, i64 %idxprom28
  %28 = load ptr, ptr %arrayidx29, align 8
  %tobool30 = icmp ne ptr %28, null
  %lnot31 = xor i1 %tobool30, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %add33 = add i32 %lnot.ext, %lnot.ext32
  store i32 %add33, ptr %f, align 4
  %29 = load i32, ptr %f, align 4
  %30 = load i32, ptr %fmin, align 4
  %cmp34 = icmp sge i32 %29, %30
  br i1 %cmp34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.then23
  %31 = load ptr, ptr %s.addr, align 8
  %32 = load i32, ptr %reg, align 4
  %33 = load i32, ptr %allocated_regs.addr, align 4
  call void @tcg_reg_free(ptr noundef %31, i32 noundef %32, i32 noundef %33)
  %34 = load ptr, ptr %s.addr, align 8
  %35 = load i32, ptr %reg, align 4
  %add36 = add i32 %35, 1
  %36 = load i32, ptr %allocated_regs.addr, align 4
  call void @tcg_reg_free(ptr noundef %34, i32 noundef %add36, i32 noundef %36)
  %37 = load i32, ptr %reg, align 4
  br label %do.end45

if.end37:                                         ; preds = %if.then23
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %for.body17
  br label %for.inc

for.inc:                                          ; preds = %if.end38
  %38 = load i32, ptr %i, align 4
  %inc = add i32 %38, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond15, !llvm.loop !108

for.end:                                          ; preds = %for.cond15
  br label %for.inc39

for.inc39:                                        ; preds = %for.end
  %39 = load i32, ptr %j, align 4
  %inc40 = add i32 %39, 1
  store i32 %inc40, ptr %j, align 4
  br label %for.cond11, !llvm.loop !109

for.end41:                                        ; preds = %for.cond11
  br label %for.inc42

for.inc42:                                        ; preds = %for.end41
  %40 = load i32, ptr %fmin, align 4
  %dec = add i32 %40, -1
  store i32 %dec, ptr %fmin, align 4
  br label %for.cond, !llvm.loop !110

for.end43:                                        ; preds = %for.cond
  br label %do.body44

do.body44:                                        ; preds = %for.end43
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 4389, ptr noundef @__func__.tcg_reg_alloc_pair, ptr noundef null) #15
  unreachable

do.end45:                                         ; preds = %if.then35
  ret i32 %37
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_reg_alloc_cbranch(ptr noundef %s, i32 noundef %allocated_regs) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %allocated_regs.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %ts = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %allocated_regs, ptr %allocated_regs.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %allocated_regs.addr, align 4
  call void @sync_globals(ptr noundef %0, i32 noundef %1)
  %2 = load ptr, ptr %s.addr, align 8
  %nb_globals = getelementptr inbounds %struct.TCGContext, ptr %2, i32 0, i32 6
  %3 = load i32, ptr %nb_globals, align 4
  store i32 %3, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, ptr %i, align 4
  %5 = load ptr, ptr %s.addr, align 8
  %nb_temps = getelementptr inbounds %struct.TCGContext, ptr %5, i32 0, i32 7
  %6 = load i32, ptr %nb_temps, align 8
  %cmp = icmp slt i32 %4, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %s.addr, align 8
  %temps = getelementptr inbounds %struct.TCGContext, ptr %7, i32 0, i32 37
  %8 = load i32, ptr %i, align 4
  %idxprom = sext i32 %8 to i64
  %arrayidx = getelementptr [512 x %struct.TCGTemp], ptr %temps, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %ts, align 8
  %9 = load ptr, ptr %ts, align 8
  %bf.load = load i64, ptr %9, align 8
  %bf.lshr = lshr i64 %bf.load, 32
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  switch i32 %bf.cast, label %sw.default [
    i32 1, label %sw.bb
    i32 0, label %sw.bb10
    i32 4, label %sw.bb10
  ]

sw.bb:                                            ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %10 = load ptr, ptr %ts, align 8
  %bf.load1 = load i64, ptr %10, align 8
  %bf.lshr2 = lshr i64 %bf.load1, 8
  %bf.clear3 = and i64 %bf.lshr2, 255
  %bf.cast4 = trunc i64 %bf.clear3 to i32
  %cmp5 = icmp ne i32 %bf.cast4, 1
  br i1 %cmp5, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  %11 = load ptr, ptr %ts, align 8
  %bf.load6 = load i64, ptr %11, align 8
  %bf.lshr7 = lshr i64 %bf.load6, 37
  %bf.clear8 = and i64 %bf.lshr7, 1
  %bf.cast9 = trunc i64 %bf.clear8 to i32
  %tobool = icmp ne i32 %bf.cast9, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  unreachable

if.end:                                           ; preds = %lor.lhs.false, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %sw.epilog

sw.bb10:                                          ; preds = %for.body, %for.body
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  br label %do.body11

do.body11:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 4530, ptr noundef @__func__.tcg_reg_alloc_cbranch, ptr noundef null) #15
  unreachable

do.end12:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end12, %sw.bb10, %do.end
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %12 = load i32, ptr %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !111

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_ext8s(ptr noundef %s, i32 noundef %type, i32 noundef %dest, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %dest.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  %rexw = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %0, 0
  %cond = select i1 %cmp, i32 0, i32 4096
  store i32 %cond, ptr %rexw, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32, ptr %src.addr, align 4
  %cmp1 = icmp ult i32 %1, 4
  br i1 %cmp1, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  br i1 true, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false
  unreachable

if.end:                                           ; preds = %lor.lhs.false, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %rexw, align 4
  %add = add i32 16830, %3
  %4 = load i32, ptr %dest.addr, align 4
  %5 = load i32, ptr %src.addr, align 4
  call void @tcg_out_modrm(ptr noundef %2, i32 noundef %add, i32 noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_ext16s(ptr noundef %s, i32 noundef %type, i32 noundef %dest, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %dest.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  %rexw = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %0, 0
  %cond = select i1 %cmp, i32 0, i32 4096
  store i32 %cond, ptr %rexw, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %rexw, align 4
  %add = add i32 447, %2
  %3 = load i32, ptr %dest.addr, align 4
  %4 = load i32, ptr %src.addr, align 4
  call void @tcg_out_modrm(ptr noundef %1, i32 noundef %add, i32 noundef %3, i32 noundef %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_ext32s(ptr noundef %s, i32 noundef %dest, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dest.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %dest.addr, align 4
  %2 = load i32, ptr %src.addr, align 4
  call void @tcg_out_modrm(ptr noundef %0, i32 noundef 4195, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_exts_i32_i64(ptr noundef %s, i32 noundef %dest, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dest.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %dest.addr, align 4
  %2 = load i32, ptr %src.addr, align 4
  call void @tcg_out_ext32s(ptr noundef %0, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_extu_i32_i64(ptr noundef %s, i32 noundef %dest, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dest.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  %0 = load i32, ptr %dest.addr, align 4
  %1 = load i32, ptr %src.addr, align 4
  %cmp = icmp ne i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %dest.addr, align 4
  %4 = load i32, ptr %src.addr, align 4
  call void @tcg_out_ext32u(ptr noundef %2, i32 noundef %3, i32 noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_extrl_i64_i32(ptr noundef %s, i32 noundef %dest, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dest.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %dest.addr, align 4
  %2 = load i32, ptr %src.addr, align 4
  call void @tcg_out_ext32u(ptr noundef %0, i32 noundef %1, i32 noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_vec_op(ptr noundef %s, i32 noundef %opc, i32 noundef %vecl, i32 noundef %vece, ptr noundef %args, ptr noundef %const_args) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %vecl.addr = alloca i32, align 4
  %vece.addr = alloca i32, align 4
  %args.addr = alloca ptr, align 8
  %const_args.addr = alloca ptr, align 8
  %type = alloca i32, align 4
  %insn = alloca i32, align 4
  %sub = alloca i32, align 4
  %a0 = alloca i64, align 8
  %a1 = alloca i64, align 8
  %a2 = alloca i64, align 8
  %a3 = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store i32 %vecl, ptr %vecl.addr, align 4
  store i32 %vece, ptr %vece.addr, align 4
  store ptr %args, ptr %args.addr, align 8
  store ptr %const_args, ptr %const_args.addr, align 8
  %0 = load i32, ptr %vecl.addr, align 4
  %add = add i32 %0, 3
  store i32 %add, ptr %type, align 4
  %1 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr i64, ptr %1, i64 0
  %2 = load i64, ptr %arrayidx, align 8
  store i64 %2, ptr %a0, align 8
  %3 = load ptr, ptr %args.addr, align 8
  %arrayidx1 = getelementptr i64, ptr %3, i64 1
  %4 = load i64, ptr %arrayidx1, align 8
  store i64 %4, ptr %a1, align 8
  %5 = load ptr, ptr %args.addr, align 8
  %arrayidx2 = getelementptr i64, ptr %5, i64 2
  %6 = load i64, ptr %arrayidx2, align 8
  store i64 %6, ptr %a2, align 8
  %7 = load i32, ptr %opc.addr, align 4
  switch i32 %7, label %sw.default [
    i32 155, label %sw.bb
    i32 160, label %sw.bb4
    i32 161, label %sw.bb7
    i32 156, label %sw.bb10
    i32 162, label %sw.bb13
    i32 163, label %sw.bb16
    i32 157, label %sw.bb19
    i32 168, label %sw.bb22
    i32 169, label %sw.bb23
    i32 170, label %sw.bb24
    i32 164, label %sw.bb25
    i32 165, label %sw.bb28
    i32 166, label %sw.bb31
    i32 167, label %sw.bb34
    i32 185, label %sw.bb37
    i32 186, label %sw.bb40
    i32 187, label %sw.bb43
    i32 188, label %sw.bb46
    i32 189, label %sw.bb49
    i32 181, label %sw.bb52
    i32 182, label %sw.bb55
    i32 183, label %sw.bb58
    i32 201, label %sw.bb61
    i32 202, label %sw.bb64
    i32 197, label %sw.bb67
    i32 198, label %sw.bb70
    i32 204, label %sw.bb73
    i32 205, label %sw.bb77
    i32 159, label %sw.bb81
    i32 190, label %sw.bb89
    i32 171, label %sw.bb107
    i32 177, label %sw.bb116
    i32 178, label %sw.bb119
    i32 179, label %sw.bb122
    i32 180, label %sw.bb130
    i32 152, label %sw.bb150
    i32 153, label %sw.bb153
    i32 154, label %sw.bb156
    i32 194, label %sw.bb159
    i32 196, label %sw.bb162
    i32 200, label %sw.bb177
    i32 203, label %sw.bb180
    i32 176, label %sw.bb185
    i32 174, label %sw.bb186
    i32 173, label %sw.bb187
    i32 175, label %sw.bb188
    i32 172, label %sw.bb189
    i32 191, label %sw.bb190
    i32 195, label %sw.bb220
    i32 199, label %sw.bb231
    i32 149, label %sw.bb235
    i32 150, label %sw.bb235
  ]

sw.bb:                                            ; preds = %entry
  %8 = load i32, ptr %vece.addr, align 4
  %idxprom = zext i32 %8 to i64
  %arrayidx3 = getelementptr [4 x i32], ptr @tcg_out_vec_op.add_insn, i64 0, i64 %idxprom
  %9 = load i32, ptr %arrayidx3, align 4
  store i32 %9, ptr %insn, align 4
  br label %gen_simd

sw.bb4:                                           ; preds = %entry
  %10 = load i32, ptr %vece.addr, align 4
  %idxprom5 = zext i32 %10 to i64
  %arrayidx6 = getelementptr [4 x i32], ptr @tcg_out_vec_op.ssadd_insn, i64 0, i64 %idxprom5
  %11 = load i32, ptr %arrayidx6, align 4
  store i32 %11, ptr %insn, align 4
  br label %gen_simd

sw.bb7:                                           ; preds = %entry
  %12 = load i32, ptr %vece.addr, align 4
  %idxprom8 = zext i32 %12 to i64
  %arrayidx9 = getelementptr [4 x i32], ptr @tcg_out_vec_op.usadd_insn, i64 0, i64 %idxprom8
  %13 = load i32, ptr %arrayidx9, align 4
  store i32 %13, ptr %insn, align 4
  br label %gen_simd

sw.bb10:                                          ; preds = %entry
  %14 = load i32, ptr %vece.addr, align 4
  %idxprom11 = zext i32 %14 to i64
  %arrayidx12 = getelementptr [4 x i32], ptr @tcg_out_vec_op.sub_insn, i64 0, i64 %idxprom11
  %15 = load i32, ptr %arrayidx12, align 4
  store i32 %15, ptr %insn, align 4
  br label %gen_simd

sw.bb13:                                          ; preds = %entry
  %16 = load i32, ptr %vece.addr, align 4
  %idxprom14 = zext i32 %16 to i64
  %arrayidx15 = getelementptr [4 x i32], ptr @tcg_out_vec_op.sssub_insn, i64 0, i64 %idxprom14
  %17 = load i32, ptr %arrayidx15, align 4
  store i32 %17, ptr %insn, align 4
  br label %gen_simd

sw.bb16:                                          ; preds = %entry
  %18 = load i32, ptr %vece.addr, align 4
  %idxprom17 = zext i32 %18 to i64
  %arrayidx18 = getelementptr [4 x i32], ptr @tcg_out_vec_op.ussub_insn, i64 0, i64 %idxprom17
  %19 = load i32, ptr %arrayidx18, align 4
  store i32 %19, ptr %insn, align 4
  br label %gen_simd

sw.bb19:                                          ; preds = %entry
  %20 = load i32, ptr %vece.addr, align 4
  %idxprom20 = zext i32 %20 to i64
  %arrayidx21 = getelementptr [4 x i32], ptr @tcg_out_vec_op.mul_insn, i64 0, i64 %idxprom20
  %21 = load i32, ptr %arrayidx21, align 4
  store i32 %21, ptr %insn, align 4
  br label %gen_simd

sw.bb22:                                          ; preds = %entry
  store i32 1499, ptr %insn, align 4
  br label %gen_simd

sw.bb23:                                          ; preds = %entry
  store i32 1515, ptr %insn, align 4
  br label %gen_simd

sw.bb24:                                          ; preds = %entry
  store i32 1519, ptr %insn, align 4
  br label %gen_simd

sw.bb25:                                          ; preds = %entry
  %22 = load i32, ptr %vece.addr, align 4
  %idxprom26 = zext i32 %22 to i64
  %arrayidx27 = getelementptr [4 x i32], ptr @tcg_out_vec_op.smin_insn, i64 0, i64 %idxprom26
  %23 = load i32, ptr %arrayidx27, align 4
  store i32 %23, ptr %insn, align 4
  br label %gen_simd

sw.bb28:                                          ; preds = %entry
  %24 = load i32, ptr %vece.addr, align 4
  %idxprom29 = zext i32 %24 to i64
  %arrayidx30 = getelementptr [4 x i32], ptr @tcg_out_vec_op.umin_insn, i64 0, i64 %idxprom29
  %25 = load i32, ptr %arrayidx30, align 4
  store i32 %25, ptr %insn, align 4
  br label %gen_simd

sw.bb31:                                          ; preds = %entry
  %26 = load i32, ptr %vece.addr, align 4
  %idxprom32 = zext i32 %26 to i64
  %arrayidx33 = getelementptr [4 x i32], ptr @tcg_out_vec_op.smax_insn, i64 0, i64 %idxprom32
  %27 = load i32, ptr %arrayidx33, align 4
  store i32 %27, ptr %insn, align 4
  br label %gen_simd

sw.bb34:                                          ; preds = %entry
  %28 = load i32, ptr %vece.addr, align 4
  %idxprom35 = zext i32 %28 to i64
  %arrayidx36 = getelementptr [4 x i32], ptr @tcg_out_vec_op.umax_insn, i64 0, i64 %idxprom35
  %29 = load i32, ptr %arrayidx36, align 4
  store i32 %29, ptr %insn, align 4
  br label %gen_simd

sw.bb37:                                          ; preds = %entry
  %30 = load i32, ptr %vece.addr, align 4
  %idxprom38 = zext i32 %30 to i64
  %arrayidx39 = getelementptr [4 x i32], ptr @tcg_out_vec_op.shlv_insn, i64 0, i64 %idxprom38
  %31 = load i32, ptr %arrayidx39, align 4
  store i32 %31, ptr %insn, align 4
  br label %gen_simd

sw.bb40:                                          ; preds = %entry
  %32 = load i32, ptr %vece.addr, align 4
  %idxprom41 = zext i32 %32 to i64
  %arrayidx42 = getelementptr [4 x i32], ptr @tcg_out_vec_op.shrv_insn, i64 0, i64 %idxprom41
  %33 = load i32, ptr %arrayidx42, align 4
  store i32 %33, ptr %insn, align 4
  br label %gen_simd

sw.bb43:                                          ; preds = %entry
  %34 = load i32, ptr %vece.addr, align 4
  %idxprom44 = zext i32 %34 to i64
  %arrayidx45 = getelementptr [4 x i32], ptr @tcg_out_vec_op.sarv_insn, i64 0, i64 %idxprom44
  %35 = load i32, ptr %arrayidx45, align 4
  store i32 %35, ptr %insn, align 4
  br label %gen_simd

sw.bb46:                                          ; preds = %entry
  %36 = load i32, ptr %vece.addr, align 4
  %idxprom47 = zext i32 %36 to i64
  %arrayidx48 = getelementptr [4 x i32], ptr @tcg_out_vec_op.rotlv_insn, i64 0, i64 %idxprom47
  %37 = load i32, ptr %arrayidx48, align 4
  store i32 %37, ptr %insn, align 4
  br label %gen_simd

sw.bb49:                                          ; preds = %entry
  %38 = load i32, ptr %vece.addr, align 4
  %idxprom50 = zext i32 %38 to i64
  %arrayidx51 = getelementptr [4 x i32], ptr @tcg_out_vec_op.rotrv_insn, i64 0, i64 %idxprom50
  %39 = load i32, ptr %arrayidx51, align 4
  store i32 %39, ptr %insn, align 4
  br label %gen_simd

sw.bb52:                                          ; preds = %entry
  %40 = load i32, ptr %vece.addr, align 4
  %idxprom53 = zext i32 %40 to i64
  %arrayidx54 = getelementptr [4 x i32], ptr @tcg_out_vec_op.shls_insn, i64 0, i64 %idxprom53
  %41 = load i32, ptr %arrayidx54, align 4
  store i32 %41, ptr %insn, align 4
  br label %gen_simd

sw.bb55:                                          ; preds = %entry
  %42 = load i32, ptr %vece.addr, align 4
  %idxprom56 = zext i32 %42 to i64
  %arrayidx57 = getelementptr [4 x i32], ptr @tcg_out_vec_op.shrs_insn, i64 0, i64 %idxprom56
  %43 = load i32, ptr %arrayidx57, align 4
  store i32 %43, ptr %insn, align 4
  br label %gen_simd

sw.bb58:                                          ; preds = %entry
  %44 = load i32, ptr %vece.addr, align 4
  %idxprom59 = zext i32 %44 to i64
  %arrayidx60 = getelementptr [4 x i32], ptr @tcg_out_vec_op.sars_insn, i64 0, i64 %idxprom59
  %45 = load i32, ptr %arrayidx60, align 4
  store i32 %45, ptr %insn, align 4
  br label %gen_simd

sw.bb61:                                          ; preds = %entry
  %46 = load i32, ptr %vece.addr, align 4
  %idxprom62 = zext i32 %46 to i64
  %arrayidx63 = getelementptr [4 x i32], ptr @tcg_out_vec_op.punpckl_insn, i64 0, i64 %idxprom62
  %47 = load i32, ptr %arrayidx63, align 4
  store i32 %47, ptr %insn, align 4
  br label %gen_simd

sw.bb64:                                          ; preds = %entry
  %48 = load i32, ptr %vece.addr, align 4
  %idxprom65 = zext i32 %48 to i64
  %arrayidx66 = getelementptr [4 x i32], ptr @tcg_out_vec_op.punpckh_insn, i64 0, i64 %idxprom65
  %49 = load i32, ptr %arrayidx66, align 4
  store i32 %49, ptr %insn, align 4
  br label %gen_simd

sw.bb67:                                          ; preds = %entry
  %50 = load i32, ptr %vece.addr, align 4
  %idxprom68 = zext i32 %50 to i64
  %arrayidx69 = getelementptr [4 x i32], ptr @tcg_out_vec_op.packss_insn, i64 0, i64 %idxprom68
  %51 = load i32, ptr %arrayidx69, align 4
  store i32 %51, ptr %insn, align 4
  br label %gen_simd

sw.bb70:                                          ; preds = %entry
  %52 = load i32, ptr %vece.addr, align 4
  %idxprom71 = zext i32 %52 to i64
  %arrayidx72 = getelementptr [4 x i32], ptr @tcg_out_vec_op.packus_insn, i64 0, i64 %idxprom71
  %53 = load i32, ptr %arrayidx72, align 4
  store i32 %53, ptr %insn, align 4
  br label %gen_simd

sw.bb73:                                          ; preds = %entry
  %54 = load i32, ptr %vece.addr, align 4
  %idxprom74 = zext i32 %54 to i64
  %arrayidx75 = getelementptr [4 x i32], ptr @tcg_out_vec_op.vpshldv_insn, i64 0, i64 %idxprom74
  %55 = load i32, ptr %arrayidx75, align 4
  store i32 %55, ptr %insn, align 4
  %56 = load i64, ptr %a2, align 8
  store i64 %56, ptr %a1, align 8
  %57 = load ptr, ptr %args.addr, align 8
  %arrayidx76 = getelementptr i64, ptr %57, i64 3
  %58 = load i64, ptr %arrayidx76, align 8
  store i64 %58, ptr %a2, align 8
  br label %gen_simd

sw.bb77:                                          ; preds = %entry
  %59 = load i32, ptr %vece.addr, align 4
  %idxprom78 = zext i32 %59 to i64
  %arrayidx79 = getelementptr [4 x i32], ptr @tcg_out_vec_op.vpshrdv_insn, i64 0, i64 %idxprom78
  %60 = load i32, ptr %arrayidx79, align 4
  store i32 %60, ptr %insn, align 4
  %61 = load i64, ptr %a2, align 8
  store i64 %61, ptr %a1, align 8
  %62 = load ptr, ptr %args.addr, align 8
  %arrayidx80 = getelementptr i64, ptr %62, i64 3
  %63 = load i64, ptr %arrayidx80, align 8
  store i64 %63, ptr %a2, align 8
  br label %gen_simd

sw.bb81:                                          ; preds = %entry
  %64 = load i32, ptr %vece.addr, align 4
  %idxprom82 = zext i32 %64 to i64
  %arrayidx83 = getelementptr [4 x i32], ptr @tcg_out_vec_op.abs_insn, i64 0, i64 %idxprom82
  %65 = load i32, ptr %arrayidx83, align 4
  store i32 %65, ptr %insn, align 4
  %66 = load i64, ptr %a1, align 8
  store i64 %66, ptr %a2, align 8
  store i64 0, ptr %a1, align 8
  br label %gen_simd

gen_simd:                                         ; preds = %if.end106, %sw.bb81, %sw.bb77, %sw.bb73, %sw.bb70, %sw.bb67, %sw.bb64, %sw.bb61, %sw.bb58, %sw.bb55, %sw.bb52, %sw.bb49, %sw.bb46, %sw.bb43, %sw.bb40, %sw.bb37, %sw.bb34, %sw.bb31, %sw.bb28, %sw.bb25, %sw.bb24, %sw.bb23, %sw.bb22, %sw.bb19, %sw.bb16, %sw.bb13, %sw.bb10, %sw.bb7, %sw.bb4, %sw.bb
  br label %do.body

do.body:                                          ; preds = %gen_simd
  %67 = load i32, ptr %insn, align 4
  %cmp = icmp ne i32 %67, 267
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %68 = load i32, ptr %type, align 4
  %cmp84 = icmp eq i32 %68, 5
  br i1 %cmp84, label %if.then85, label %if.end86

if.then85:                                        ; preds = %do.end
  %69 = load i32, ptr %insn, align 4
  %or = or i32 %69, 524288
  store i32 %or, ptr %insn, align 4
  br label %if.end86

if.end86:                                         ; preds = %if.then85, %do.end
  %70 = load ptr, ptr %s.addr, align 8
  %71 = load i32, ptr %insn, align 4
  %72 = load i64, ptr %a0, align 8
  %conv = trunc i64 %72 to i32
  %73 = load i64, ptr %a1, align 8
  %conv87 = trunc i64 %73 to i32
  %74 = load i64, ptr %a2, align 8
  %conv88 = trunc i64 %74 to i32
  call void @tcg_out_vex_modrm(ptr noundef %70, i32 noundef %71, i32 noundef %conv, i32 noundef %conv87, i32 noundef %conv88)
  br label %sw.epilog

sw.bb89:                                          ; preds = %entry
  %75 = load ptr, ptr %args.addr, align 8
  %arrayidx90 = getelementptr i64, ptr %75, i64 3
  %76 = load i64, ptr %arrayidx90, align 8
  %conv91 = trunc i64 %76 to i32
  store i32 %conv91, ptr %sub, align 4
  %77 = load i32, ptr %sub, align 4
  %cmp92 = icmp eq i32 %77, 8
  br i1 %cmp92, label %if.then94, label %if.else

if.then94:                                        ; preds = %sw.bb89
  %78 = load i32, ptr %vece.addr, align 4
  %idxprom95 = zext i32 %78 to i64
  %arrayidx96 = getelementptr [4 x i32], ptr @tcg_out_vec_op.cmpeq_insn, i64 0, i64 %idxprom95
  %79 = load i32, ptr %arrayidx96, align 4
  store i32 %79, ptr %insn, align 4
  br label %if.end106

if.else:                                          ; preds = %sw.bb89
  %80 = load i32, ptr %sub, align 4
  %cmp97 = icmp eq i32 %80, 11
  br i1 %cmp97, label %if.then99, label %if.else102

if.then99:                                        ; preds = %if.else
  %81 = load i32, ptr %vece.addr, align 4
  %idxprom100 = zext i32 %81 to i64
  %arrayidx101 = getelementptr [4 x i32], ptr @tcg_out_vec_op.cmpgt_insn, i64 0, i64 %idxprom100
  %82 = load i32, ptr %arrayidx101, align 4
  store i32 %82, ptr %insn, align 4
  br label %if.end105

if.else102:                                       ; preds = %if.else
  br label %do.body103

do.body103:                                       ; preds = %if.else102
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 3130, ptr noundef @__func__.tcg_out_vec_op, ptr noundef null) #15
  unreachable

do.end104:                                        ; No predecessors!
  br label %if.end105

if.end105:                                        ; preds = %do.end104, %if.then99
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %if.then94
  br label %gen_simd

sw.bb107:                                         ; preds = %entry
  store i32 1503, ptr %insn, align 4
  %83 = load i32, ptr %type, align 4
  %cmp108 = icmp eq i32 %83, 5
  br i1 %cmp108, label %if.then110, label %if.end112

if.then110:                                       ; preds = %sw.bb107
  %84 = load i32, ptr %insn, align 4
  %or111 = or i32 %84, 524288
  store i32 %or111, ptr %insn, align 4
  br label %if.end112

if.end112:                                        ; preds = %if.then110, %sw.bb107
  %85 = load ptr, ptr %s.addr, align 8
  %86 = load i32, ptr %insn, align 4
  %87 = load i64, ptr %a0, align 8
  %conv113 = trunc i64 %87 to i32
  %88 = load i64, ptr %a2, align 8
  %conv114 = trunc i64 %88 to i32
  %89 = load i64, ptr %a1, align 8
  %conv115 = trunc i64 %89 to i32
  call void @tcg_out_vex_modrm(ptr noundef %85, i32 noundef %86, i32 noundef %conv113, i32 noundef %conv114, i32 noundef %conv115)
  br label %sw.epilog

sw.bb116:                                         ; preds = %entry
  %90 = load i32, ptr %vece.addr, align 4
  %idxprom117 = zext i32 %90 to i64
  %arrayidx118 = getelementptr [4 x i32], ptr @tcg_out_vec_op.shift_imm_insn, i64 0, i64 %idxprom117
  %91 = load i32, ptr %arrayidx118, align 4
  store i32 %91, ptr %insn, align 4
  store i32 6, ptr %sub, align 4
  br label %gen_shift

sw.bb119:                                         ; preds = %entry
  %92 = load i32, ptr %vece.addr, align 4
  %idxprom120 = zext i32 %92 to i64
  %arrayidx121 = getelementptr [4 x i32], ptr @tcg_out_vec_op.shift_imm_insn, i64 0, i64 %idxprom120
  %93 = load i32, ptr %arrayidx121, align 4
  store i32 %93, ptr %insn, align 4
  store i32 2, ptr %sub, align 4
  br label %gen_shift

sw.bb122:                                         ; preds = %entry
  %94 = load i32, ptr %vece.addr, align 4
  %cmp123 = icmp eq i32 %94, 3
  br i1 %cmp123, label %if.then125, label %if.else126

if.then125:                                       ; preds = %sw.bb122
  store i32 1054066, ptr %insn, align 4
  br label %if.end129

if.else126:                                       ; preds = %sw.bb122
  %95 = load i32, ptr %vece.addr, align 4
  %idxprom127 = zext i32 %95 to i64
  %arrayidx128 = getelementptr [4 x i32], ptr @tcg_out_vec_op.shift_imm_insn, i64 0, i64 %idxprom127
  %96 = load i32, ptr %arrayidx128, align 4
  store i32 %96, ptr %insn, align 4
  br label %if.end129

if.end129:                                        ; preds = %if.else126, %if.then125
  store i32 4, ptr %sub, align 4
  br label %gen_shift

sw.bb130:                                         ; preds = %entry
  store i32 1049970, ptr %insn, align 4
  %97 = load i32, ptr %vece.addr, align 4
  %cmp131 = icmp eq i32 %97, 3
  br i1 %cmp131, label %if.then133, label %if.end135

if.then133:                                       ; preds = %sw.bb130
  %98 = load i32, ptr %insn, align 4
  %or134 = or i32 %98, 4096
  store i32 %or134, ptr %insn, align 4
  br label %if.end135

if.end135:                                        ; preds = %if.then133, %sw.bb130
  store i32 1, ptr %sub, align 4
  br label %gen_shift

gen_shift:                                        ; preds = %if.end135, %if.end129, %sw.bb119, %sw.bb116
  br label %do.body136

do.body136:                                       ; preds = %gen_shift
  %99 = load i32, ptr %vece.addr, align 4
  %cmp137 = icmp ne i32 %99, 0
  br i1 %cmp137, label %if.end140, label %if.then139

if.then139:                                       ; preds = %do.body136
  unreachable

if.end140:                                        ; preds = %do.body136
  br label %do.end141

do.end141:                                        ; preds = %if.end140
  %100 = load i32, ptr %type, align 4
  %cmp142 = icmp eq i32 %100, 5
  br i1 %cmp142, label %if.then144, label %if.end146

if.then144:                                       ; preds = %do.end141
  %101 = load i32, ptr %insn, align 4
  %or145 = or i32 %101, 524288
  store i32 %or145, ptr %insn, align 4
  br label %if.end146

if.end146:                                        ; preds = %if.then144, %do.end141
  %102 = load ptr, ptr %s.addr, align 8
  %103 = load i32, ptr %insn, align 4
  %104 = load i32, ptr %sub, align 4
  %105 = load i64, ptr %a0, align 8
  %conv147 = trunc i64 %105 to i32
  %106 = load i64, ptr %a1, align 8
  %conv148 = trunc i64 %106 to i32
  call void @tcg_out_vex_modrm(ptr noundef %102, i32 noundef %103, i32 noundef %104, i32 noundef %conv147, i32 noundef %conv148)
  %107 = load ptr, ptr %s.addr, align 8
  %108 = load i64, ptr %a2, align 8
  %conv149 = trunc i64 %108 to i8
  call void @tcg_out8(ptr noundef %107, i8 noundef zeroext %conv149)
  br label %sw.epilog

sw.bb150:                                         ; preds = %entry
  %109 = load ptr, ptr %s.addr, align 8
  %110 = load i32, ptr %type, align 4
  %111 = load i64, ptr %a0, align 8
  %conv151 = trunc i64 %111 to i32
  %112 = load i64, ptr %a1, align 8
  %conv152 = trunc i64 %112 to i32
  %113 = load i64, ptr %a2, align 8
  call void @tcg_out_ld(ptr noundef %109, i32 noundef %110, i32 noundef %conv151, i32 noundef %conv152, i64 noundef %113)
  br label %sw.epilog

sw.bb153:                                         ; preds = %entry
  %114 = load ptr, ptr %s.addr, align 8
  %115 = load i32, ptr %type, align 4
  %116 = load i64, ptr %a0, align 8
  %conv154 = trunc i64 %116 to i32
  %117 = load i64, ptr %a1, align 8
  %conv155 = trunc i64 %117 to i32
  %118 = load i64, ptr %a2, align 8
  call void @tcg_out_st(ptr noundef %114, i32 noundef %115, i32 noundef %conv154, i32 noundef %conv155, i64 noundef %118)
  br label %sw.epilog

sw.bb156:                                         ; preds = %entry
  %119 = load ptr, ptr %s.addr, align 8
  %120 = load i32, ptr %type, align 4
  %121 = load i32, ptr %vece.addr, align 4
  %122 = load i64, ptr %a0, align 8
  %conv157 = trunc i64 %122 to i32
  %123 = load i64, ptr %a1, align 8
  %conv158 = trunc i64 %123 to i32
  %124 = load i64, ptr %a2, align 8
  %call = call zeroext i1 @tcg_out_dupm_vec(ptr noundef %119, i32 noundef %120, i32 noundef %121, i32 noundef %conv157, i32 noundef %conv158, i64 noundef %124)
  br label %sw.epilog

sw.bb159:                                         ; preds = %entry
  store i32 454, ptr %insn, align 4
  %125 = load ptr, ptr %args.addr, align 8
  %arrayidx160 = getelementptr i64, ptr %125, i64 3
  %126 = load i64, ptr %arrayidx160, align 8
  %conv161 = trunc i64 %126 to i32
  store i32 %conv161, ptr %sub, align 4
  br label %gen_simd_imm8

sw.bb162:                                         ; preds = %entry
  %127 = load i32, ptr %vece.addr, align 4
  %cmp163 = icmp eq i32 %127, 1
  br i1 %cmp163, label %if.then165, label %if.else166

if.then165:                                       ; preds = %sw.bb162
  store i32 66574, ptr %insn, align 4
  br label %if.end174

if.else166:                                       ; preds = %sw.bb162
  %128 = load i32, ptr %vece.addr, align 4
  %cmp167 = icmp eq i32 %128, 2
  br i1 %cmp167, label %if.then169, label %if.else170

if.then169:                                       ; preds = %if.else166
  %129 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %129, 1024
  %tobool = icmp ne i32 %and, 0
  %cond = select i1 %tobool, i32 66562, i32 66572
  store i32 %cond, ptr %insn, align 4
  br label %if.end173

if.else170:                                       ; preds = %if.else166
  br label %do.body171

do.body171:                                       ; preds = %if.else170
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 3194, ptr noundef @__func__.tcg_out_vec_op, ptr noundef null) #15
  unreachable

do.end172:                                        ; No predecessors!
  br label %if.end173

if.end173:                                        ; preds = %do.end172, %if.then169
  br label %if.end174

if.end174:                                        ; preds = %if.end173, %if.then165
  %130 = load ptr, ptr %args.addr, align 8
  %arrayidx175 = getelementptr i64, ptr %130, i64 3
  %131 = load i64, ptr %arrayidx175, align 8
  %conv176 = trunc i64 %131 to i32
  store i32 %conv176, ptr %sub, align 4
  br label %gen_simd_imm8

sw.bb177:                                         ; preds = %entry
  store i32 590918, ptr %insn, align 4
  %132 = load ptr, ptr %args.addr, align 8
  %arrayidx178 = getelementptr i64, ptr %132, i64 3
  %133 = load i64, ptr %arrayidx178, align 8
  %conv179 = trunc i64 %133 to i32
  store i32 %conv179, ptr %sub, align 4
  br label %gen_simd_imm8

sw.bb180:                                         ; preds = %entry
  %134 = load i32, ptr %vece.addr, align 4
  %idxprom181 = zext i32 %134 to i64
  %arrayidx182 = getelementptr [4 x i32], ptr @tcg_out_vec_op.vpshldi_insn, i64 0, i64 %idxprom181
  %135 = load i32, ptr %arrayidx182, align 4
  store i32 %135, ptr %insn, align 4
  %136 = load ptr, ptr %args.addr, align 8
  %arrayidx183 = getelementptr i64, ptr %136, i64 3
  %137 = load i64, ptr %arrayidx183, align 8
  %conv184 = trunc i64 %137 to i32
  store i32 %conv184, ptr %sub, align 4
  br label %gen_simd_imm8

sw.bb185:                                         ; preds = %entry
  store i32 1119269, ptr %insn, align 4
  %138 = load i64, ptr %a1, align 8
  store i64 %138, ptr %a2, align 8
  store i32 51, ptr %sub, align 4
  br label %gen_simd_imm8

sw.bb186:                                         ; preds = %entry
  store i32 1119269, ptr %insn, align 4
  store i32 17, ptr %sub, align 4
  br label %gen_simd_imm8

sw.bb187:                                         ; preds = %entry
  store i32 1119269, ptr %insn, align 4
  store i32 119, ptr %sub, align 4
  br label %gen_simd_imm8

sw.bb188:                                         ; preds = %entry
  store i32 1119269, ptr %insn, align 4
  store i32 153, ptr %sub, align 4
  br label %gen_simd_imm8

sw.bb189:                                         ; preds = %entry
  store i32 1119269, ptr %insn, align 4
  store i32 221, ptr %sub, align 4
  br label %gen_simd_imm8

sw.bb190:                                         ; preds = %entry
  store i32 1119269, ptr %insn, align 4
  %139 = load ptr, ptr %args.addr, align 8
  %arrayidx191 = getelementptr i64, ptr %139, i64 3
  %140 = load i64, ptr %arrayidx191, align 8
  store i64 %140, ptr %a3, align 8
  %141 = load i64, ptr %a0, align 8
  %142 = load i64, ptr %a1, align 8
  %cmp192 = icmp eq i64 %141, %142
  br i1 %cmp192, label %if.then194, label %if.else195

if.then194:                                       ; preds = %sw.bb190
  %143 = load i64, ptr %a2, align 8
  store i64 %143, ptr %a1, align 8
  %144 = load i64, ptr %a3, align 8
  store i64 %144, ptr %a2, align 8
  store i32 202, ptr %sub, align 4
  br label %if.end204

if.else195:                                       ; preds = %sw.bb190
  %145 = load i64, ptr %a0, align 8
  %146 = load i64, ptr %a2, align 8
  %cmp196 = icmp eq i64 %145, %146
  br i1 %cmp196, label %if.then198, label %if.else199

if.then198:                                       ; preds = %if.else195
  %147 = load i64, ptr %a3, align 8
  store i64 %147, ptr %a2, align 8
  store i32 226, ptr %sub, align 4
  br label %if.end203

if.else199:                                       ; preds = %if.else195
  %148 = load ptr, ptr %s.addr, align 8
  %149 = load i32, ptr %type, align 4
  %150 = load i64, ptr %a0, align 8
  %conv200 = trunc i64 %150 to i32
  %151 = load i64, ptr %a3, align 8
  %conv201 = trunc i64 %151 to i32
  %call202 = call zeroext i1 @tcg_out_mov(ptr noundef %148, i32 noundef %149, i32 noundef %conv200, i32 noundef %conv201)
  store i32 184, ptr %sub, align 4
  br label %if.end203

if.end203:                                        ; preds = %if.else199, %if.then198
  br label %if.end204

if.end204:                                        ; preds = %if.end203, %if.then194
  br label %gen_simd_imm8

gen_simd_imm8:                                    ; preds = %if.end204, %sw.bb189, %sw.bb188, %sw.bb187, %sw.bb186, %sw.bb185, %sw.bb180, %sw.bb177, %if.end174, %sw.bb159
  br label %do.body205

do.body205:                                       ; preds = %gen_simd_imm8
  %152 = load i32, ptr %insn, align 4
  %cmp206 = icmp ne i32 %152, 267
  br i1 %cmp206, label %if.end209, label %if.then208

if.then208:                                       ; preds = %do.body205
  unreachable

if.end209:                                        ; preds = %do.body205
  br label %do.end210

do.end210:                                        ; preds = %if.end209
  %153 = load i32, ptr %type, align 4
  %cmp211 = icmp eq i32 %153, 5
  br i1 %cmp211, label %if.then213, label %if.end215

if.then213:                                       ; preds = %do.end210
  %154 = load i32, ptr %insn, align 4
  %or214 = or i32 %154, 524288
  store i32 %or214, ptr %insn, align 4
  br label %if.end215

if.end215:                                        ; preds = %if.then213, %do.end210
  %155 = load ptr, ptr %s.addr, align 8
  %156 = load i32, ptr %insn, align 4
  %157 = load i64, ptr %a0, align 8
  %conv216 = trunc i64 %157 to i32
  %158 = load i64, ptr %a1, align 8
  %conv217 = trunc i64 %158 to i32
  %159 = load i64, ptr %a2, align 8
  %conv218 = trunc i64 %159 to i32
  call void @tcg_out_vex_modrm(ptr noundef %155, i32 noundef %156, i32 noundef %conv216, i32 noundef %conv217, i32 noundef %conv218)
  %160 = load ptr, ptr %s.addr, align 8
  %161 = load i32, ptr %sub, align 4
  %conv219 = trunc i32 %161 to i8
  call void @tcg_out8(ptr noundef %160, i8 noundef zeroext %conv219)
  br label %sw.epilog

sw.bb220:                                         ; preds = %entry
  store i32 66636, ptr %insn, align 4
  %162 = load i32, ptr %type, align 4
  %cmp221 = icmp eq i32 %162, 5
  br i1 %cmp221, label %if.then223, label %if.end225

if.then223:                                       ; preds = %sw.bb220
  %163 = load i32, ptr %insn, align 4
  %or224 = or i32 %163, 524288
  store i32 %or224, ptr %insn, align 4
  br label %if.end225

if.end225:                                        ; preds = %if.then223, %sw.bb220
  %164 = load ptr, ptr %s.addr, align 8
  %165 = load i32, ptr %insn, align 4
  %166 = load i64, ptr %a0, align 8
  %conv226 = trunc i64 %166 to i32
  %167 = load i64, ptr %a1, align 8
  %conv227 = trunc i64 %167 to i32
  %168 = load i64, ptr %a2, align 8
  %conv228 = trunc i64 %168 to i32
  call void @tcg_out_vex_modrm(ptr noundef %164, i32 noundef %165, i32 noundef %conv226, i32 noundef %conv227, i32 noundef %conv228)
  %169 = load ptr, ptr %s.addr, align 8
  %170 = load ptr, ptr %args.addr, align 8
  %arrayidx229 = getelementptr i64, ptr %170, i64 3
  %171 = load i64, ptr %arrayidx229, align 8
  %shl = shl i64 %171, 4
  %conv230 = trunc i64 %shl to i8
  call void @tcg_out8(ptr noundef %169, i8 noundef zeroext %conv230)
  br label %sw.epilog

sw.bb231:                                         ; preds = %entry
  %172 = load ptr, ptr %s.addr, align 8
  %173 = load i64, ptr %a0, align 8
  %conv232 = trunc i64 %173 to i32
  %174 = load i64, ptr %a1, align 8
  %conv233 = trunc i64 %174 to i32
  call void @tcg_out_vex_modrm(ptr noundef %172, i32 noundef 1395, i32 noundef 3, i32 noundef %conv232, i32 noundef %conv233)
  %175 = load ptr, ptr %s.addr, align 8
  %176 = load i64, ptr %a2, align 8
  %conv234 = trunc i64 %176 to i8
  call void @tcg_out8(ptr noundef %175, i8 noundef zeroext %conv234)
  br label %sw.epilog

sw.bb235:                                         ; preds = %entry, %entry
  br label %sw.default

sw.default:                                       ; preds = %sw.bb235, %entry
  br label %do.body236

do.body236:                                       ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 3271, ptr noundef @__func__.tcg_out_vec_op, ptr noundef null) #15
  unreachable

do.end237:                                        ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end237, %sw.bb231, %if.end225, %if.end215, %sw.bb156, %sw.bb153, %sw.bb150, %if.end146, %if.end112, %if.end86
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_op(ptr noundef %s, i32 noundef %opc, ptr noundef %args, ptr noundef %const_args) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %args.addr = alloca ptr, align 8
  %const_args.addr = alloca ptr, align 8
  %a0 = alloca i64, align 8
  %a1 = alloca i64, align 8
  %a2 = alloca i64, align 8
  %c = alloca i32, align 4
  %const_a2 = alloca i32, align 4
  %vexop = alloca i32, align 4
  %rexw = alloca i32, align 4
  %c3 = alloca i64, align 8
  %val = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store ptr %args, ptr %args.addr, align 8
  store ptr %const_args, ptr %const_args.addr, align 8
  store i32 0, ptr %rexw, align 4
  %0 = load ptr, ptr %args.addr, align 8
  %arrayidx = getelementptr i64, ptr %0, i64 0
  %1 = load i64, ptr %arrayidx, align 8
  store i64 %1, ptr %a0, align 8
  %2 = load ptr, ptr %args.addr, align 8
  %arrayidx1 = getelementptr i64, ptr %2, i64 1
  %3 = load i64, ptr %arrayidx1, align 8
  store i64 %3, ptr %a1, align 8
  %4 = load ptr, ptr %args.addr, align 8
  %arrayidx2 = getelementptr i64, ptr %4, i64 2
  %5 = load i64, ptr %arrayidx2, align 8
  store i64 %5, ptr %a2, align 8
  %6 = load ptr, ptr %const_args.addr, align 8
  %arrayidx3 = getelementptr i32, ptr %6, i64 2
  %7 = load i32, ptr %arrayidx3, align 4
  store i32 %7, ptr %const_a2, align 4
  %8 = load i32, ptr %opc.addr, align 4
  switch i32 %8, label %sw.default [
    i32 132, label %sw.bb
    i32 3, label %sw.bb4
    i32 67, label %sw.bb5
    i32 9, label %sw.bb6
    i32 68, label %sw.bb9
    i32 10, label %sw.bb10
    i32 69, label %sw.bb13
    i32 11, label %sw.bb14
    i32 70, label %sw.bb17
    i32 12, label %sw.bb18
    i32 71, label %sw.bb22
    i32 13, label %sw.bb22
    i32 74, label %sw.bb25
    i32 14, label %sw.bb26
    i32 75, label %sw.bb32
    i32 15, label %sw.bb33
    i32 76, label %sw.bb43
    i32 16, label %sw.bb43
    i32 78, label %sw.bb53
    i32 17, label %sw.bb54
    i32 79, label %sw.bb73
    i32 18, label %sw.bb74
    i32 87, label %sw.bb75
    i32 26, label %sw.bb76
    i32 88, label %sw.bb77
    i32 27, label %sw.bb78
    i32 89, label %sw.bb79
    i32 28, label %sw.bb80
    i32 115, label %sw.bb90
    i32 55, label %sw.bb91
    i32 80, label %sw.bb106
    i32 19, label %sw.bb107
    i32 85, label %sw.bb130
    i32 24, label %sw.bb131
    i32 86, label %sw.bb135
    i32 25, label %sw.bb136
    i32 90, label %sw.bb140
    i32 29, label %sw.bb141
    i32 91, label %sw.bb164
    i32 30, label %sw.bb165
    i32 92, label %sw.bb166
    i32 31, label %sw.bb167
    i32 93, label %sw.bb168
    i32 32, label %sw.bb169
    i32 94, label %sw.bb170
    i32 33, label %sw.bb171
    i32 121, label %sw.bb196
    i32 61, label %sw.bb197
    i32 120, label %sw.bb205
    i32 60, label %sw.bb206
    i32 122, label %sw.bb214
    i32 62, label %sw.bb215
    i32 103, label %sw.bb219
    i32 38, label %sw.bb220
    i32 64, label %sw.bb225
    i32 6, label %sw.bb226
    i32 65, label %sw.bb229
    i32 7, label %sw.bb230
    i32 66, label %sw.bb233
    i32 8, label %sw.bb234
    i32 110, label %sw.bb241
    i32 51, label %sw.bb242
    i32 111, label %sw.bb266
    i32 52, label %sw.bb267
    i32 114, label %sw.bb277
    i32 54, label %sw.bb278
    i32 113, label %sw.bb281
    i32 53, label %sw.bb282
    i32 139, label %sw.bb285
    i32 135, label %sw.bb286
    i32 137, label %sw.bb290
    i32 141, label %sw.bb294
    i32 145, label %sw.bb298
    i32 146, label %sw.bb298
    i32 140, label %sw.bb304
    i32 144, label %sw.bb304
    i32 136, label %sw.bb305
    i32 143, label %sw.bb305
    i32 138, label %sw.bb309
    i32 142, label %sw.bb313
    i32 147, label %sw.bb317
    i32 148, label %sw.bb317
    i32 125, label %sw.bb325
    i32 41, label %sw.bb326
    i32 126, label %sw.bb330
    i32 42, label %sw.bb331
    i32 123, label %sw.bb335
    i32 39, label %sw.bb336
    i32 124, label %sw.bb361
    i32 40, label %sw.bb362
    i32 72, label %sw.bb387
    i32 73, label %sw.bb390
    i32 77, label %sw.bb393
    i32 112, label %sw.bb403
    i32 102, label %sw.bb405
    i32 95, label %sw.bb407
    i32 34, label %sw.bb408
    i32 96, label %sw.bb452
    i32 35, label %sw.bb464
    i32 36, label %sw.bb489
    i32 98, label %sw.bb514
    i32 37, label %sw.bb515
    i32 4, label %sw.bb521
    i32 5, label %sw.bb522
    i32 63, label %sw.bb522
    i32 2, label %sw.bb522
    i32 130, label %sw.bb522
    i32 131, label %sw.bb522
    i32 47, label %sw.bb522
    i32 104, label %sw.bb522
    i32 49, label %sw.bb522
    i32 107, label %sw.bb522
    i32 48, label %sw.bb522
    i32 105, label %sw.bb522
    i32 50, label %sw.bb522
    i32 108, label %sw.bb522
    i32 106, label %sw.bb522
    i32 109, label %sw.bb522
    i32 99, label %sw.bb522
    i32 100, label %sw.bb522
    i32 101, label %sw.bb522
  ]

sw.bb:                                            ; preds = %entry
  %9 = load ptr, ptr %s.addr, align 8
  %10 = load i64, ptr %a0, align 8
  %conv = trunc i64 %10 to i32
  call void @tcg_out_modrm(ptr noundef %9, i32 noundef 255, i32 noundef 4, i32 noundef %conv)
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load i64, ptr %a0, align 8
  %call = call ptr @arg_label(i64 noundef %12)
  call void @tcg_out_jxx(ptr noundef %11, i32 noundef -1, ptr noundef %call, i1 noundef zeroext false)
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb6

sw.bb6:                                           ; preds = %sw.bb5, %entry
  %13 = load ptr, ptr %s.addr, align 8
  %14 = load i64, ptr %a0, align 8
  %conv7 = trunc i64 %14 to i32
  %15 = load i64, ptr %a1, align 8
  %conv8 = trunc i64 %15 to i32
  %16 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %13, i32 noundef 438, i32 noundef %conv7, i32 noundef %conv8, i64 noundef %16)
  br label %sw.epilog

sw.bb9:                                           ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb10

sw.bb10:                                          ; preds = %sw.bb9, %entry
  %17 = load ptr, ptr %s.addr, align 8
  %18 = load i32, ptr %rexw, align 4
  %add = add i32 446, %18
  %19 = load i64, ptr %a0, align 8
  %conv11 = trunc i64 %19 to i32
  %20 = load i64, ptr %a1, align 8
  %conv12 = trunc i64 %20 to i32
  %21 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %17, i32 noundef %add, i32 noundef %conv11, i32 noundef %conv12, i64 noundef %21)
  br label %sw.epilog

sw.bb13:                                          ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb14

sw.bb14:                                          ; preds = %sw.bb13, %entry
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load i64, ptr %a0, align 8
  %conv15 = trunc i64 %23 to i32
  %24 = load i64, ptr %a1, align 8
  %conv16 = trunc i64 %24 to i32
  %25 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %22, i32 noundef 439, i32 noundef %conv15, i32 noundef %conv16, i64 noundef %25)
  br label %sw.epilog

sw.bb17:                                          ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb18

sw.bb18:                                          ; preds = %sw.bb17, %entry
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i32, ptr %rexw, align 4
  %add19 = add i32 447, %27
  %28 = load i64, ptr %a0, align 8
  %conv20 = trunc i64 %28 to i32
  %29 = load i64, ptr %a1, align 8
  %conv21 = trunc i64 %29 to i32
  %30 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %26, i32 noundef %add19, i32 noundef %conv20, i32 noundef %conv21, i64 noundef %30)
  br label %sw.epilog

sw.bb22:                                          ; preds = %entry, %entry
  %31 = load ptr, ptr %s.addr, align 8
  %32 = load i64, ptr %a0, align 8
  %conv23 = trunc i64 %32 to i32
  %33 = load i64, ptr %a1, align 8
  %conv24 = trunc i64 %33 to i32
  %34 = load i64, ptr %a2, align 8
  call void @tcg_out_ld(ptr noundef %31, i32 noundef 0, i32 noundef %conv23, i32 noundef %conv24, i64 noundef %34)
  br label %sw.epilog

sw.bb25:                                          ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb26

sw.bb26:                                          ; preds = %sw.bb25, %entry
  %35 = load ptr, ptr %const_args.addr, align 8
  %arrayidx27 = getelementptr i32, ptr %35, i64 0
  %36 = load i32, ptr %arrayidx27, align 4
  %tobool = icmp ne i32 %36, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb26
  %37 = load ptr, ptr %s.addr, align 8
  %38 = load i64, ptr %a1, align 8
  %conv28 = trunc i64 %38 to i32
  %39 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %37, i32 noundef 198, i32 noundef 0, i32 noundef %conv28, i64 noundef %39)
  %40 = load ptr, ptr %s.addr, align 8
  %41 = load i64, ptr %a0, align 8
  %conv29 = trunc i64 %41 to i8
  call void @tcg_out8(ptr noundef %40, i8 noundef zeroext %conv29)
  br label %if.end

if.else:                                          ; preds = %sw.bb26
  %42 = load ptr, ptr %s.addr, align 8
  %43 = load i64, ptr %a0, align 8
  %conv30 = trunc i64 %43 to i32
  %44 = load i64, ptr %a1, align 8
  %conv31 = trunc i64 %44 to i32
  %45 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %42, i32 noundef 8328, i32 noundef %conv30, i32 noundef %conv31, i64 noundef %45)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb32:                                          ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb33

sw.bb33:                                          ; preds = %sw.bb32, %entry
  %46 = load ptr, ptr %const_args.addr, align 8
  %arrayidx34 = getelementptr i32, ptr %46, i64 0
  %47 = load i32, ptr %arrayidx34, align 4
  %tobool35 = icmp ne i32 %47, 0
  br i1 %tobool35, label %if.then36, label %if.else39

if.then36:                                        ; preds = %sw.bb33
  %48 = load ptr, ptr %s.addr, align 8
  %49 = load i64, ptr %a1, align 8
  %conv37 = trunc i64 %49 to i32
  %50 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %48, i32 noundef 1223, i32 noundef 0, i32 noundef %conv37, i64 noundef %50)
  %51 = load ptr, ptr %s.addr, align 8
  %52 = load i64, ptr %a0, align 8
  %conv38 = trunc i64 %52 to i16
  call void @tcg_out16(ptr noundef %51, i16 noundef zeroext %conv38)
  br label %if.end42

if.else39:                                        ; preds = %sw.bb33
  %53 = load ptr, ptr %s.addr, align 8
  %54 = load i64, ptr %a0, align 8
  %conv40 = trunc i64 %54 to i32
  %55 = load i64, ptr %a1, align 8
  %conv41 = trunc i64 %55 to i32
  %56 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %53, i32 noundef 1161, i32 noundef %conv40, i32 noundef %conv41, i64 noundef %56)
  br label %if.end42

if.end42:                                         ; preds = %if.else39, %if.then36
  br label %sw.epilog

sw.bb43:                                          ; preds = %entry, %entry
  %57 = load ptr, ptr %const_args.addr, align 8
  %arrayidx44 = getelementptr i32, ptr %57, i64 0
  %58 = load i32, ptr %arrayidx44, align 4
  %tobool45 = icmp ne i32 %58, 0
  br i1 %tobool45, label %if.then46, label %if.else49

if.then46:                                        ; preds = %sw.bb43
  %59 = load ptr, ptr %s.addr, align 8
  %60 = load i64, ptr %a1, align 8
  %conv47 = trunc i64 %60 to i32
  %61 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %59, i32 noundef 199, i32 noundef 0, i32 noundef %conv47, i64 noundef %61)
  %62 = load ptr, ptr %s.addr, align 8
  %63 = load i64, ptr %a0, align 8
  %conv48 = trunc i64 %63 to i32
  call void @tcg_out32(ptr noundef %62, i32 noundef %conv48)
  br label %if.end52

if.else49:                                        ; preds = %sw.bb43
  %64 = load ptr, ptr %s.addr, align 8
  %65 = load i64, ptr %a0, align 8
  %conv50 = trunc i64 %65 to i32
  %66 = load i64, ptr %a1, align 8
  %conv51 = trunc i64 %66 to i32
  %67 = load i64, ptr %a2, align 8
  call void @tcg_out_st(ptr noundef %64, i32 noundef 0, i32 noundef %conv50, i32 noundef %conv51, i64 noundef %67)
  br label %if.end52

if.end52:                                         ; preds = %if.else49, %if.then46
  br label %sw.epilog

sw.bb53:                                          ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb54

sw.bb54:                                          ; preds = %sw.bb53, %entry
  %68 = load i64, ptr %a0, align 8
  %69 = load i64, ptr %a1, align 8
  %cmp = icmp ne i64 %68, %69
  br i1 %cmp, label %if.then56, label %if.end72

if.then56:                                        ; preds = %sw.bb54
  store i64 0, ptr %c3, align 8
  %70 = load i32, ptr %const_a2, align 4
  %tobool57 = icmp ne i32 %70, 0
  br i1 %tobool57, label %if.then58, label %if.else59

if.then58:                                        ; preds = %if.then56
  %71 = load i64, ptr %a2, align 8
  store i64 %71, ptr %c3, align 8
  store i64 -1, ptr %a2, align 8
  br label %if.end67

if.else59:                                        ; preds = %if.then56
  %72 = load i64, ptr %a0, align 8
  %73 = load i64, ptr %a2, align 8
  %cmp60 = icmp eq i64 %72, %73
  br i1 %cmp60, label %if.then62, label %if.end66

if.then62:                                        ; preds = %if.else59
  %74 = load ptr, ptr %s.addr, align 8
  %75 = load i32, ptr %rexw, align 4
  %add63 = add i32 0, %75
  %76 = load i64, ptr %a0, align 8
  %conv64 = trunc i64 %76 to i32
  %77 = load i64, ptr %a1, align 8
  %conv65 = trunc i64 %77 to i32
  call void @tgen_arithr(ptr noundef %74, i32 noundef %add63, i32 noundef %conv64, i32 noundef %conv65)
  br label %sw.epilog

if.end66:                                         ; preds = %if.else59
  br label %if.end67

if.end67:                                         ; preds = %if.end66, %if.then58
  %78 = load ptr, ptr %s.addr, align 8
  %79 = load i32, ptr %rexw, align 4
  %add68 = add i32 141, %79
  %80 = load i64, ptr %a0, align 8
  %conv69 = trunc i64 %80 to i32
  %81 = load i64, ptr %a1, align 8
  %conv70 = trunc i64 %81 to i32
  %82 = load i64, ptr %a2, align 8
  %conv71 = trunc i64 %82 to i32
  %83 = load i64, ptr %c3, align 8
  call void @tcg_out_modrm_sib_offset(ptr noundef %78, i32 noundef %add68, i32 noundef %conv69, i32 noundef %conv70, i32 noundef %conv71, i32 noundef 0, i64 noundef %83)
  br label %sw.epilog

if.end72:                                         ; preds = %sw.bb54
  store i32 0, ptr %c, align 4
  br label %gen_arith

sw.bb73:                                          ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb74

sw.bb74:                                          ; preds = %sw.bb73, %entry
  store i32 5, ptr %c, align 4
  br label %gen_arith

sw.bb75:                                          ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb76

sw.bb76:                                          ; preds = %sw.bb75, %entry
  store i32 4, ptr %c, align 4
  br label %gen_arith

sw.bb77:                                          ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb78

sw.bb78:                                          ; preds = %sw.bb77, %entry
  store i32 1, ptr %c, align 4
  br label %gen_arith

sw.bb79:                                          ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb80

sw.bb80:                                          ; preds = %sw.bb79, %entry
  store i32 6, ptr %c, align 4
  br label %gen_arith

gen_arith:                                        ; preds = %sw.bb80, %sw.bb78, %sw.bb76, %sw.bb74, %if.end72
  %84 = load i32, ptr %const_a2, align 4
  %tobool81 = icmp ne i32 %84, 0
  br i1 %tobool81, label %if.then82, label %if.else85

if.then82:                                        ; preds = %gen_arith
  %85 = load ptr, ptr %s.addr, align 8
  %86 = load i32, ptr %c, align 4
  %87 = load i32, ptr %rexw, align 4
  %add83 = add i32 %86, %87
  %88 = load i64, ptr %a0, align 8
  %conv84 = trunc i64 %88 to i32
  %89 = load i64, ptr %a2, align 8
  call void @tgen_arithi(ptr noundef %85, i32 noundef %add83, i32 noundef %conv84, i64 noundef %89, i32 noundef 0)
  br label %if.end89

if.else85:                                        ; preds = %gen_arith
  %90 = load ptr, ptr %s.addr, align 8
  %91 = load i32, ptr %c, align 4
  %92 = load i32, ptr %rexw, align 4
  %add86 = add i32 %91, %92
  %93 = load i64, ptr %a0, align 8
  %conv87 = trunc i64 %93 to i32
  %94 = load i64, ptr %a2, align 8
  %conv88 = trunc i64 %94 to i32
  call void @tgen_arithr(ptr noundef %90, i32 noundef %add86, i32 noundef %conv87, i32 noundef %conv88)
  br label %if.end89

if.end89:                                         ; preds = %if.else85, %if.then82
  br label %sw.epilog

sw.bb90:                                          ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb91

sw.bb91:                                          ; preds = %sw.bb90, %entry
  %95 = load i32, ptr %const_a2, align 4
  %tobool92 = icmp ne i32 %95, 0
  br i1 %tobool92, label %if.then93, label %if.else100

if.then93:                                        ; preds = %sw.bb91
  %96 = load ptr, ptr %s.addr, align 8
  %97 = load i32, ptr %rexw, align 4
  %tobool94 = icmp ne i32 %97, 0
  %cond = select i1 %tobool94, i32 1, i32 0
  %98 = load i64, ptr %a0, align 8
  %conv95 = trunc i64 %98 to i32
  %99 = load i64, ptr %a1, align 8
  %conv96 = trunc i64 %99 to i32
  %call97 = call zeroext i1 @tcg_out_mov(ptr noundef %96, i32 noundef %cond, i32 noundef %conv95, i32 noundef %conv96)
  %100 = load ptr, ptr %s.addr, align 8
  %101 = load i32, ptr %rexw, align 4
  %add98 = add i32 4, %101
  %102 = load i64, ptr %a0, align 8
  %conv99 = trunc i64 %102 to i32
  %103 = load i64, ptr %a2, align 8
  %not = xor i64 %103, -1
  call void @tgen_arithi(ptr noundef %100, i32 noundef %add98, i32 noundef %conv99, i64 noundef %not, i32 noundef 0)
  br label %if.end105

if.else100:                                       ; preds = %sw.bb91
  %104 = load ptr, ptr %s.addr, align 8
  %105 = load i32, ptr %rexw, align 4
  %add101 = add i32 754, %105
  %106 = load i64, ptr %a0, align 8
  %conv102 = trunc i64 %106 to i32
  %107 = load i64, ptr %a2, align 8
  %conv103 = trunc i64 %107 to i32
  %108 = load i64, ptr %a1, align 8
  %conv104 = trunc i64 %108 to i32
  call void @tcg_out_vex_modrm(ptr noundef %104, i32 noundef %add101, i32 noundef %conv102, i32 noundef %conv103, i32 noundef %conv104)
  br label %if.end105

if.end105:                                        ; preds = %if.else100, %if.then93
  br label %sw.epilog

sw.bb106:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb107

sw.bb107:                                         ; preds = %sw.bb106, %entry
  %109 = load i32, ptr %const_a2, align 4
  %tobool108 = icmp ne i32 %109, 0
  br i1 %tobool108, label %if.then109, label %if.else125

if.then109:                                       ; preds = %sw.bb107
  %110 = load i64, ptr %a2, align 8
  %conv110 = trunc i64 %110 to i32
  store i32 %conv110, ptr %val, align 4
  %111 = load i32, ptr %val, align 4
  %112 = load i32, ptr %val, align 4
  %conv111 = trunc i32 %112 to i8
  %conv112 = sext i8 %conv111 to i32
  %cmp113 = icmp eq i32 %111, %conv112
  br i1 %cmp113, label %if.then115, label %if.else120

if.then115:                                       ; preds = %if.then109
  %113 = load ptr, ptr %s.addr, align 8
  %114 = load i32, ptr %rexw, align 4
  %add116 = add i32 107, %114
  %115 = load i64, ptr %a0, align 8
  %conv117 = trunc i64 %115 to i32
  %116 = load i64, ptr %a0, align 8
  %conv118 = trunc i64 %116 to i32
  call void @tcg_out_modrm(ptr noundef %113, i32 noundef %add116, i32 noundef %conv117, i32 noundef %conv118)
  %117 = load ptr, ptr %s.addr, align 8
  %118 = load i32, ptr %val, align 4
  %conv119 = trunc i32 %118 to i8
  call void @tcg_out8(ptr noundef %117, i8 noundef zeroext %conv119)
  br label %if.end124

if.else120:                                       ; preds = %if.then109
  %119 = load ptr, ptr %s.addr, align 8
  %120 = load i32, ptr %rexw, align 4
  %add121 = add i32 105, %120
  %121 = load i64, ptr %a0, align 8
  %conv122 = trunc i64 %121 to i32
  %122 = load i64, ptr %a0, align 8
  %conv123 = trunc i64 %122 to i32
  call void @tcg_out_modrm(ptr noundef %119, i32 noundef %add121, i32 noundef %conv122, i32 noundef %conv123)
  %123 = load ptr, ptr %s.addr, align 8
  %124 = load i32, ptr %val, align 4
  call void @tcg_out32(ptr noundef %123, i32 noundef %124)
  br label %if.end124

if.end124:                                        ; preds = %if.else120, %if.then115
  br label %if.end129

if.else125:                                       ; preds = %sw.bb107
  %125 = load ptr, ptr %s.addr, align 8
  %126 = load i32, ptr %rexw, align 4
  %add126 = add i32 431, %126
  %127 = load i64, ptr %a0, align 8
  %conv127 = trunc i64 %127 to i32
  %128 = load i64, ptr %a2, align 8
  %conv128 = trunc i64 %128 to i32
  call void @tcg_out_modrm(ptr noundef %125, i32 noundef %add126, i32 noundef %conv127, i32 noundef %conv128)
  br label %if.end129

if.end129:                                        ; preds = %if.else125, %if.end124
  br label %sw.epilog

sw.bb130:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb131

sw.bb131:                                         ; preds = %sw.bb130, %entry
  %129 = load ptr, ptr %s.addr, align 8
  %130 = load i32, ptr %rexw, align 4
  %add132 = add i32 247, %130
  %131 = load ptr, ptr %args.addr, align 8
  %arrayidx133 = getelementptr i64, ptr %131, i64 4
  %132 = load i64, ptr %arrayidx133, align 8
  %conv134 = trunc i64 %132 to i32
  call void @tcg_out_modrm(ptr noundef %129, i32 noundef %add132, i32 noundef 7, i32 noundef %conv134)
  br label %sw.epilog

sw.bb135:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb136

sw.bb136:                                         ; preds = %sw.bb135, %entry
  %133 = load ptr, ptr %s.addr, align 8
  %134 = load i32, ptr %rexw, align 4
  %add137 = add i32 247, %134
  %135 = load ptr, ptr %args.addr, align 8
  %arrayidx138 = getelementptr i64, ptr %135, i64 4
  %136 = load i64, ptr %arrayidx138, align 8
  %conv139 = trunc i64 %136 to i32
  call void @tcg_out_modrm(ptr noundef %133, i32 noundef %add137, i32 noundef 6, i32 noundef %conv139)
  br label %sw.epilog

sw.bb140:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb141

sw.bb141:                                         ; preds = %sw.bb140, %entry
  %137 = load i32, ptr %const_a2, align 4
  %tobool142 = icmp ne i32 %137, 0
  br i1 %tobool142, label %land.lhs.true, label %if.end163

land.lhs.true:                                    ; preds = %sw.bb141
  %138 = load i64, ptr %a0, align 8
  %139 = load i64, ptr %a1, align 8
  %cmp143 = icmp ne i64 %138, %139
  br i1 %cmp143, label %land.lhs.true145, label %if.end163

land.lhs.true145:                                 ; preds = %land.lhs.true
  %140 = load i64, ptr %a2, align 8
  %sub = sub i64 %140, 1
  %cmp146 = icmp ult i64 %sub, 3
  br i1 %cmp146, label %if.then148, label %if.end163

if.then148:                                       ; preds = %land.lhs.true145
  %141 = load i64, ptr %a2, align 8
  %sub149 = sub i64 %141, 1
  %cmp150 = icmp eq i64 %sub149, 0
  br i1 %cmp150, label %if.then152, label %if.else157

if.then152:                                       ; preds = %if.then148
  %142 = load ptr, ptr %s.addr, align 8
  %143 = load i32, ptr %rexw, align 4
  %add153 = add i32 141, %143
  %144 = load i64, ptr %a0, align 8
  %conv154 = trunc i64 %144 to i32
  %145 = load i64, ptr %a1, align 8
  %conv155 = trunc i64 %145 to i32
  %146 = load i64, ptr %a1, align 8
  %conv156 = trunc i64 %146 to i32
  call void @tcg_out_modrm_sib_offset(ptr noundef %142, i32 noundef %add153, i32 noundef %conv154, i32 noundef %conv155, i32 noundef %conv156, i32 noundef 0, i64 noundef 0)
  br label %if.end162

if.else157:                                       ; preds = %if.then148
  %147 = load ptr, ptr %s.addr, align 8
  %148 = load i32, ptr %rexw, align 4
  %add158 = add i32 141, %148
  %149 = load i64, ptr %a0, align 8
  %conv159 = trunc i64 %149 to i32
  %150 = load i64, ptr %a1, align 8
  %conv160 = trunc i64 %150 to i32
  %151 = load i64, ptr %a2, align 8
  %conv161 = trunc i64 %151 to i32
  call void @tcg_out_modrm_sib_offset(ptr noundef %147, i32 noundef %add158, i32 noundef %conv159, i32 noundef -1, i32 noundef %conv160, i32 noundef %conv161, i64 noundef 0)
  br label %if.end162

if.end162:                                        ; preds = %if.else157, %if.then152
  br label %sw.epilog

if.end163:                                        ; preds = %land.lhs.true145, %land.lhs.true, %sw.bb141
  store i32 4, ptr %c, align 4
  store i32 1783, ptr %vexop, align 4
  br label %gen_shift_maybe_vex

sw.bb164:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb165

sw.bb165:                                         ; preds = %sw.bb164, %entry
  store i32 5, ptr %c, align 4
  store i32 262903, ptr %vexop, align 4
  br label %gen_shift_maybe_vex

sw.bb166:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb167

sw.bb167:                                         ; preds = %sw.bb166, %entry
  store i32 7, ptr %c, align 4
  store i32 131831, ptr %vexop, align 4
  br label %gen_shift_maybe_vex

sw.bb168:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb169

sw.bb169:                                         ; preds = %sw.bb168, %entry
  store i32 0, ptr %c, align 4
  br label %gen_shift

sw.bb170:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb171

sw.bb171:                                         ; preds = %sw.bb170, %entry
  store i32 1, ptr %c, align 4
  br label %gen_shift

gen_shift_maybe_vex:                              ; preds = %sw.bb167, %sw.bb165, %if.end163
  %152 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %152, 64
  %tobool172 = icmp ne i32 %and, 0
  br i1 %tobool172, label %if.then173, label %if.end186

if.then173:                                       ; preds = %gen_shift_maybe_vex
  %153 = load i32, ptr %const_a2, align 4
  %tobool174 = icmp ne i32 %153, 0
  br i1 %tobool174, label %if.end180, label %if.then175

if.then175:                                       ; preds = %if.then173
  %154 = load ptr, ptr %s.addr, align 8
  %155 = load i32, ptr %vexop, align 4
  %156 = load i32, ptr %rexw, align 4
  %add176 = add i32 %155, %156
  %157 = load i64, ptr %a0, align 8
  %conv177 = trunc i64 %157 to i32
  %158 = load i64, ptr %a2, align 8
  %conv178 = trunc i64 %158 to i32
  %159 = load i64, ptr %a1, align 8
  %conv179 = trunc i64 %159 to i32
  call void @tcg_out_vex_modrm(ptr noundef %154, i32 noundef %add176, i32 noundef %conv177, i32 noundef %conv178, i32 noundef %conv179)
  br label %sw.epilog

if.end180:                                        ; preds = %if.then173
  %160 = load ptr, ptr %s.addr, align 8
  %161 = load i32, ptr %rexw, align 4
  %tobool181 = icmp ne i32 %161, 0
  %cond182 = select i1 %tobool181, i32 1, i32 0
  %162 = load i64, ptr %a0, align 8
  %conv183 = trunc i64 %162 to i32
  %163 = load i64, ptr %a1, align 8
  %conv184 = trunc i64 %163 to i32
  %call185 = call zeroext i1 @tcg_out_mov(ptr noundef %160, i32 noundef %cond182, i32 noundef %conv183, i32 noundef %conv184)
  br label %if.end186

if.end186:                                        ; preds = %if.end180, %gen_shift_maybe_vex
  br label %gen_shift

gen_shift:                                        ; preds = %if.end186, %sw.bb171, %sw.bb169
  %164 = load i32, ptr %const_a2, align 4
  %tobool187 = icmp ne i32 %164, 0
  br i1 %tobool187, label %if.then188, label %if.else192

if.then188:                                       ; preds = %gen_shift
  %165 = load ptr, ptr %s.addr, align 8
  %166 = load i32, ptr %c, align 4
  %167 = load i32, ptr %rexw, align 4
  %add189 = add i32 %166, %167
  %168 = load i64, ptr %a0, align 8
  %conv190 = trunc i64 %168 to i32
  %169 = load i64, ptr %a2, align 8
  %conv191 = trunc i64 %169 to i32
  call void @tcg_out_shifti(ptr noundef %165, i32 noundef %add189, i32 noundef %conv190, i32 noundef %conv191)
  br label %if.end195

if.else192:                                       ; preds = %gen_shift
  %170 = load ptr, ptr %s.addr, align 8
  %171 = load i32, ptr %rexw, align 4
  %add193 = add i32 211, %171
  %172 = load i32, ptr %c, align 4
  %173 = load i64, ptr %a0, align 8
  %conv194 = trunc i64 %173 to i32
  call void @tcg_out_modrm(ptr noundef %170, i32 noundef %add193, i32 noundef %172, i32 noundef %conv194)
  br label %if.end195

if.end195:                                        ; preds = %if.else192, %if.then188
  br label %sw.epilog

sw.bb196:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb197

sw.bb197:                                         ; preds = %sw.bb196, %entry
  %174 = load ptr, ptr %s.addr, align 8
  %175 = load i32, ptr %rexw, align 4
  %176 = load ptr, ptr %args.addr, align 8
  %arrayidx198 = getelementptr i64, ptr %176, i64 0
  %177 = load i64, ptr %arrayidx198, align 8
  %conv199 = trunc i64 %177 to i32
  %178 = load ptr, ptr %args.addr, align 8
  %arrayidx200 = getelementptr i64, ptr %178, i64 1
  %179 = load i64, ptr %arrayidx200, align 8
  %conv201 = trunc i64 %179 to i32
  %180 = load ptr, ptr %args.addr, align 8
  %arrayidx202 = getelementptr i64, ptr %180, i64 2
  %181 = load i64, ptr %arrayidx202, align 8
  %182 = load ptr, ptr %const_args.addr, align 8
  %arrayidx203 = getelementptr i32, ptr %182, i64 2
  %183 = load i32, ptr %arrayidx203, align 4
  %tobool204 = icmp ne i32 %183, 0
  call void @tcg_out_ctz(ptr noundef %174, i32 noundef %175, i32 noundef %conv199, i32 noundef %conv201, i64 noundef %181, i1 noundef zeroext %tobool204)
  br label %sw.epilog

sw.bb205:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb206

sw.bb206:                                         ; preds = %sw.bb205, %entry
  %184 = load ptr, ptr %s.addr, align 8
  %185 = load i32, ptr %rexw, align 4
  %186 = load ptr, ptr %args.addr, align 8
  %arrayidx207 = getelementptr i64, ptr %186, i64 0
  %187 = load i64, ptr %arrayidx207, align 8
  %conv208 = trunc i64 %187 to i32
  %188 = load ptr, ptr %args.addr, align 8
  %arrayidx209 = getelementptr i64, ptr %188, i64 1
  %189 = load i64, ptr %arrayidx209, align 8
  %conv210 = trunc i64 %189 to i32
  %190 = load ptr, ptr %args.addr, align 8
  %arrayidx211 = getelementptr i64, ptr %190, i64 2
  %191 = load i64, ptr %arrayidx211, align 8
  %192 = load ptr, ptr %const_args.addr, align 8
  %arrayidx212 = getelementptr i32, ptr %192, i64 2
  %193 = load i32, ptr %arrayidx212, align 4
  %tobool213 = icmp ne i32 %193, 0
  call void @tcg_out_clz(ptr noundef %184, i32 noundef %185, i32 noundef %conv208, i32 noundef %conv210, i64 noundef %191, i1 noundef zeroext %tobool213)
  br label %sw.epilog

sw.bb214:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb215

sw.bb215:                                         ; preds = %sw.bb214, %entry
  %194 = load ptr, ptr %s.addr, align 8
  %195 = load i32, ptr %rexw, align 4
  %add216 = add i32 131512, %195
  %196 = load i64, ptr %a0, align 8
  %conv217 = trunc i64 %196 to i32
  %197 = load i64, ptr %a1, align 8
  %conv218 = trunc i64 %197 to i32
  call void @tcg_out_modrm(ptr noundef %194, i32 noundef %add216, i32 noundef %conv217, i32 noundef %conv218)
  br label %sw.epilog

sw.bb219:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb220

sw.bb220:                                         ; preds = %sw.bb219, %entry
  %198 = load ptr, ptr %s.addr, align 8
  %199 = load i32, ptr %rexw, align 4
  %200 = load i64, ptr %a2, align 8
  %conv221 = trunc i64 %200 to i32
  %201 = load i64, ptr %a0, align 8
  %202 = load i64, ptr %a1, align 8
  %203 = load ptr, ptr %const_args.addr, align 8
  %arrayidx222 = getelementptr i32, ptr %203, i64 1
  %204 = load i32, ptr %arrayidx222, align 4
  %205 = load ptr, ptr %args.addr, align 8
  %arrayidx223 = getelementptr i64, ptr %205, i64 3
  %206 = load i64, ptr %arrayidx223, align 8
  %call224 = call ptr @arg_label(i64 noundef %206)
  call void @tcg_out_brcond(ptr noundef %198, i32 noundef %199, i32 noundef %conv221, i64 noundef %201, i64 noundef %202, i32 noundef %204, ptr noundef %call224, i1 noundef zeroext false)
  br label %sw.epilog

sw.bb225:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb226

sw.bb226:                                         ; preds = %sw.bb225, %entry
  %207 = load ptr, ptr %s.addr, align 8
  %208 = load i32, ptr %rexw, align 4
  %209 = load ptr, ptr %args.addr, align 8
  %arrayidx227 = getelementptr i64, ptr %209, i64 3
  %210 = load i64, ptr %arrayidx227, align 8
  %conv228 = trunc i64 %210 to i32
  %211 = load i64, ptr %a0, align 8
  %212 = load i64, ptr %a1, align 8
  %213 = load i64, ptr %a2, align 8
  %214 = load i32, ptr %const_a2, align 4
  call void @tcg_out_setcond(ptr noundef %207, i32 noundef %208, i32 noundef %conv228, i64 noundef %211, i64 noundef %212, i64 noundef %213, i32 noundef %214, i1 noundef zeroext false)
  br label %sw.epilog

sw.bb229:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb230

sw.bb230:                                         ; preds = %sw.bb229, %entry
  %215 = load ptr, ptr %s.addr, align 8
  %216 = load i32, ptr %rexw, align 4
  %217 = load ptr, ptr %args.addr, align 8
  %arrayidx231 = getelementptr i64, ptr %217, i64 3
  %218 = load i64, ptr %arrayidx231, align 8
  %conv232 = trunc i64 %218 to i32
  %219 = load i64, ptr %a0, align 8
  %220 = load i64, ptr %a1, align 8
  %221 = load i64, ptr %a2, align 8
  %222 = load i32, ptr %const_a2, align 4
  call void @tcg_out_setcond(ptr noundef %215, i32 noundef %216, i32 noundef %conv232, i64 noundef %219, i64 noundef %220, i64 noundef %221, i32 noundef %222, i1 noundef zeroext true)
  br label %sw.epilog

sw.bb233:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb234

sw.bb234:                                         ; preds = %sw.bb233, %entry
  %223 = load ptr, ptr %s.addr, align 8
  %224 = load i32, ptr %rexw, align 4
  %225 = load ptr, ptr %args.addr, align 8
  %arrayidx235 = getelementptr i64, ptr %225, i64 5
  %226 = load i64, ptr %arrayidx235, align 8
  %conv236 = trunc i64 %226 to i32
  %227 = load i64, ptr %a0, align 8
  %conv237 = trunc i64 %227 to i32
  %228 = load i64, ptr %a1, align 8
  %conv238 = trunc i64 %228 to i32
  %229 = load i64, ptr %a2, align 8
  %230 = load i32, ptr %const_a2, align 4
  %231 = load ptr, ptr %args.addr, align 8
  %arrayidx239 = getelementptr i64, ptr %231, i64 3
  %232 = load i64, ptr %arrayidx239, align 8
  %conv240 = trunc i64 %232 to i32
  call void @tcg_out_movcond(ptr noundef %223, i32 noundef %224, i32 noundef %conv236, i32 noundef %conv237, i32 noundef %conv238, i64 noundef %229, i32 noundef %230, i32 noundef %conv240)
  br label %sw.epilog

sw.bb241:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb242

sw.bb242:                                         ; preds = %sw.bb241, %entry
  %233 = load i64, ptr %a2, align 8
  %and243 = and i64 %233, 4
  %tobool244 = icmp ne i64 %and243, 0
  br i1 %tobool244, label %if.then245, label %if.else255

if.then245:                                       ; preds = %sw.bb242
  %234 = load i32, ptr %rexw, align 4
  %tobool246 = icmp ne i32 %234, 0
  br i1 %tobool246, label %if.then247, label %if.else251

if.then247:                                       ; preds = %if.then245
  %235 = load ptr, ptr %s.addr, align 8
  %236 = load i64, ptr %a0, align 8
  %conv248 = trunc i64 %236 to i32
  call void @tcg_out_bswap64(ptr noundef %235, i32 noundef %conv248)
  %237 = load ptr, ptr %s.addr, align 8
  %238 = load i32, ptr %rexw, align 4
  %add249 = add i32 7, %238
  %239 = load i64, ptr %a0, align 8
  %conv250 = trunc i64 %239 to i32
  call void @tcg_out_shifti(ptr noundef %237, i32 noundef %add249, i32 noundef %conv250, i32 noundef 48)
  br label %if.end254

if.else251:                                       ; preds = %if.then245
  %240 = load ptr, ptr %s.addr, align 8
  %241 = load i64, ptr %a0, align 8
  %conv252 = trunc i64 %241 to i32
  call void @tcg_out_bswap32(ptr noundef %240, i32 noundef %conv252)
  %242 = load ptr, ptr %s.addr, align 8
  %243 = load i64, ptr %a0, align 8
  %conv253 = trunc i64 %243 to i32
  call void @tcg_out_shifti(ptr noundef %242, i32 noundef 7, i32 noundef %conv253, i32 noundef 16)
  br label %if.end254

if.end254:                                        ; preds = %if.else251, %if.then247
  br label %if.end265

if.else255:                                       ; preds = %sw.bb242
  %244 = load i64, ptr %a2, align 8
  %and256 = and i64 %244, 3
  %cmp257 = icmp eq i64 %and256, 2
  br i1 %cmp257, label %if.then259, label %if.else262

if.then259:                                       ; preds = %if.else255
  %245 = load ptr, ptr %s.addr, align 8
  %246 = load i64, ptr %a0, align 8
  %conv260 = trunc i64 %246 to i32
  call void @tcg_out_bswap32(ptr noundef %245, i32 noundef %conv260)
  %247 = load ptr, ptr %s.addr, align 8
  %248 = load i64, ptr %a0, align 8
  %conv261 = trunc i64 %248 to i32
  call void @tcg_out_shifti(ptr noundef %247, i32 noundef 5, i32 noundef %conv261, i32 noundef 16)
  br label %if.end264

if.else262:                                       ; preds = %if.else255
  %249 = load ptr, ptr %s.addr, align 8
  %250 = load i64, ptr %a0, align 8
  %conv263 = trunc i64 %250 to i32
  call void @tcg_out_rolw_8(ptr noundef %249, i32 noundef %conv263)
  br label %if.end264

if.end264:                                        ; preds = %if.else262, %if.then259
  br label %if.end265

if.end265:                                        ; preds = %if.end264, %if.end254
  br label %sw.epilog

sw.bb266:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb267

sw.bb267:                                         ; preds = %sw.bb266, %entry
  %251 = load ptr, ptr %s.addr, align 8
  %252 = load i64, ptr %a0, align 8
  %conv268 = trunc i64 %252 to i32
  call void @tcg_out_bswap32(ptr noundef %251, i32 noundef %conv268)
  %253 = load i32, ptr %rexw, align 4
  %tobool269 = icmp ne i32 %253, 0
  br i1 %tobool269, label %land.lhs.true270, label %if.end276

land.lhs.true270:                                 ; preds = %sw.bb267
  %254 = load i64, ptr %a2, align 8
  %and271 = and i64 %254, 4
  %tobool272 = icmp ne i64 %and271, 0
  br i1 %tobool272, label %if.then273, label %if.end276

if.then273:                                       ; preds = %land.lhs.true270
  %255 = load ptr, ptr %s.addr, align 8
  %256 = load i64, ptr %a0, align 8
  %conv274 = trunc i64 %256 to i32
  %257 = load i64, ptr %a0, align 8
  %conv275 = trunc i64 %257 to i32
  call void @tcg_out_ext32s(ptr noundef %255, i32 noundef %conv274, i32 noundef %conv275)
  br label %if.end276

if.end276:                                        ; preds = %if.then273, %land.lhs.true270, %sw.bb267
  br label %sw.epilog

sw.bb277:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb278

sw.bb278:                                         ; preds = %sw.bb277, %entry
  %258 = load ptr, ptr %s.addr, align 8
  %259 = load i32, ptr %rexw, align 4
  %add279 = add i32 247, %259
  %260 = load i64, ptr %a0, align 8
  %conv280 = trunc i64 %260 to i32
  call void @tcg_out_modrm(ptr noundef %258, i32 noundef %add279, i32 noundef 3, i32 noundef %conv280)
  br label %sw.epilog

sw.bb281:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb282

sw.bb282:                                         ; preds = %sw.bb281, %entry
  %261 = load ptr, ptr %s.addr, align 8
  %262 = load i32, ptr %rexw, align 4
  %add283 = add i32 247, %262
  %263 = load i64, ptr %a0, align 8
  %conv284 = trunc i64 %263 to i32
  call void @tcg_out_modrm(ptr noundef %261, i32 noundef %add283, i32 noundef 2, i32 noundef %conv284)
  br label %sw.epilog

sw.bb285:                                         ; preds = %entry
  br label %sw.bb286

sw.bb286:                                         ; preds = %sw.bb285, %entry
  %264 = load ptr, ptr %s.addr, align 8
  %265 = load i64, ptr %a0, align 8
  %conv287 = trunc i64 %265 to i32
  %266 = load i64, ptr %a1, align 8
  %conv288 = trunc i64 %266 to i32
  %267 = load i64, ptr %a2, align 8
  %conv289 = trunc i64 %267 to i32
  call void @tcg_out_qemu_ld(ptr noundef %264, i32 noundef %conv287, i32 noundef -1, i32 noundef %conv288, i32 noundef -1, i32 noundef %conv289, i32 noundef 0)
  br label %sw.epilog

sw.bb290:                                         ; preds = %entry
  %268 = load ptr, ptr %s.addr, align 8
  %269 = load i64, ptr %a0, align 8
  %conv291 = trunc i64 %269 to i32
  %270 = load i64, ptr %a1, align 8
  %conv292 = trunc i64 %270 to i32
  %271 = load i64, ptr %a2, align 8
  %conv293 = trunc i64 %271 to i32
  call void @tcg_out_qemu_ld(ptr noundef %268, i32 noundef %conv291, i32 noundef -1, i32 noundef %conv292, i32 noundef -1, i32 noundef %conv293, i32 noundef 1)
  br label %sw.epilog

sw.bb294:                                         ; preds = %entry
  %272 = load ptr, ptr %s.addr, align 8
  %273 = load i64, ptr %a0, align 8
  %conv295 = trunc i64 %273 to i32
  %274 = load i64, ptr %a1, align 8
  %conv296 = trunc i64 %274 to i32
  %275 = load i64, ptr %a2, align 8
  %conv297 = trunc i64 %275 to i32
  call void @tcg_out_qemu_ld(ptr noundef %272, i32 noundef %conv295, i32 noundef -1, i32 noundef %conv296, i32 noundef -1, i32 noundef %conv297, i32 noundef 1)
  br label %sw.epilog

sw.bb298:                                         ; preds = %entry, %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb298
  br label %do.end

do.end:                                           ; preds = %do.body
  %276 = load ptr, ptr %s.addr, align 8
  %277 = load i64, ptr %a0, align 8
  %conv299 = trunc i64 %277 to i32
  %278 = load i64, ptr %a1, align 8
  %conv300 = trunc i64 %278 to i32
  %279 = load i64, ptr %a2, align 8
  %conv301 = trunc i64 %279 to i32
  %280 = load ptr, ptr %args.addr, align 8
  %arrayidx302 = getelementptr i64, ptr %280, i64 3
  %281 = load i64, ptr %arrayidx302, align 8
  %conv303 = trunc i64 %281 to i32
  call void @tcg_out_qemu_ld(ptr noundef %276, i32 noundef %conv299, i32 noundef %conv300, i32 noundef %conv301, i32 noundef -1, i32 noundef %conv303, i32 noundef 2)
  br label %sw.epilog

sw.bb304:                                         ; preds = %entry, %entry
  br label %sw.bb305

sw.bb305:                                         ; preds = %sw.bb304, %entry, %entry
  %282 = load ptr, ptr %s.addr, align 8
  %283 = load i64, ptr %a0, align 8
  %conv306 = trunc i64 %283 to i32
  %284 = load i64, ptr %a1, align 8
  %conv307 = trunc i64 %284 to i32
  %285 = load i64, ptr %a2, align 8
  %conv308 = trunc i64 %285 to i32
  call void @tcg_out_qemu_st(ptr noundef %282, i32 noundef %conv306, i32 noundef -1, i32 noundef %conv307, i32 noundef -1, i32 noundef %conv308, i32 noundef 0)
  br label %sw.epilog

sw.bb309:                                         ; preds = %entry
  %286 = load ptr, ptr %s.addr, align 8
  %287 = load i64, ptr %a0, align 8
  %conv310 = trunc i64 %287 to i32
  %288 = load i64, ptr %a1, align 8
  %conv311 = trunc i64 %288 to i32
  %289 = load i64, ptr %a2, align 8
  %conv312 = trunc i64 %289 to i32
  call void @tcg_out_qemu_st(ptr noundef %286, i32 noundef %conv310, i32 noundef -1, i32 noundef %conv311, i32 noundef -1, i32 noundef %conv312, i32 noundef 1)
  br label %sw.epilog

sw.bb313:                                         ; preds = %entry
  %290 = load ptr, ptr %s.addr, align 8
  %291 = load i64, ptr %a0, align 8
  %conv314 = trunc i64 %291 to i32
  %292 = load i64, ptr %a1, align 8
  %conv315 = trunc i64 %292 to i32
  %293 = load i64, ptr %a2, align 8
  %conv316 = trunc i64 %293 to i32
  call void @tcg_out_qemu_st(ptr noundef %290, i32 noundef %conv314, i32 noundef -1, i32 noundef %conv315, i32 noundef -1, i32 noundef %conv316, i32 noundef 1)
  br label %sw.epilog

sw.bb317:                                         ; preds = %entry, %entry
  br label %do.body318

do.body318:                                       ; preds = %sw.bb317
  br label %do.end319

do.end319:                                        ; preds = %do.body318
  %294 = load ptr, ptr %s.addr, align 8
  %295 = load i64, ptr %a0, align 8
  %conv320 = trunc i64 %295 to i32
  %296 = load i64, ptr %a1, align 8
  %conv321 = trunc i64 %296 to i32
  %297 = load i64, ptr %a2, align 8
  %conv322 = trunc i64 %297 to i32
  %298 = load ptr, ptr %args.addr, align 8
  %arrayidx323 = getelementptr i64, ptr %298, i64 3
  %299 = load i64, ptr %arrayidx323, align 8
  %conv324 = trunc i64 %299 to i32
  call void @tcg_out_qemu_st(ptr noundef %294, i32 noundef %conv320, i32 noundef %conv321, i32 noundef %conv322, i32 noundef -1, i32 noundef %conv324, i32 noundef 2)
  br label %sw.epilog

sw.bb325:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb326

sw.bb326:                                         ; preds = %sw.bb325, %entry
  %300 = load ptr, ptr %s.addr, align 8
  %301 = load i32, ptr %rexw, align 4
  %add327 = add i32 247, %301
  %302 = load ptr, ptr %args.addr, align 8
  %arrayidx328 = getelementptr i64, ptr %302, i64 3
  %303 = load i64, ptr %arrayidx328, align 8
  %conv329 = trunc i64 %303 to i32
  call void @tcg_out_modrm(ptr noundef %300, i32 noundef %add327, i32 noundef 4, i32 noundef %conv329)
  br label %sw.epilog

sw.bb330:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb331

sw.bb331:                                         ; preds = %sw.bb330, %entry
  %304 = load ptr, ptr %s.addr, align 8
  %305 = load i32, ptr %rexw, align 4
  %add332 = add i32 247, %305
  %306 = load ptr, ptr %args.addr, align 8
  %arrayidx333 = getelementptr i64, ptr %306, i64 3
  %307 = load i64, ptr %arrayidx333, align 8
  %conv334 = trunc i64 %307 to i32
  call void @tcg_out_modrm(ptr noundef %304, i32 noundef %add332, i32 noundef 5, i32 noundef %conv334)
  br label %sw.epilog

sw.bb335:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb336

sw.bb336:                                         ; preds = %sw.bb335, %entry
  %308 = load ptr, ptr %const_args.addr, align 8
  %arrayidx337 = getelementptr i32, ptr %308, i64 4
  %309 = load i32, ptr %arrayidx337, align 4
  %tobool338 = icmp ne i32 %309, 0
  br i1 %tobool338, label %if.then339, label %if.else343

if.then339:                                       ; preds = %sw.bb336
  %310 = load ptr, ptr %s.addr, align 8
  %311 = load i32, ptr %rexw, align 4
  %add340 = add i32 0, %311
  %312 = load i64, ptr %a0, align 8
  %conv341 = trunc i64 %312 to i32
  %313 = load ptr, ptr %args.addr, align 8
  %arrayidx342 = getelementptr i64, ptr %313, i64 4
  %314 = load i64, ptr %arrayidx342, align 8
  call void @tgen_arithi(ptr noundef %310, i32 noundef %add340, i32 noundef %conv341, i64 noundef %314, i32 noundef 1)
  br label %if.end348

if.else343:                                       ; preds = %sw.bb336
  %315 = load ptr, ptr %s.addr, align 8
  %316 = load i32, ptr %rexw, align 4
  %add344 = add i32 0, %316
  %317 = load i64, ptr %a0, align 8
  %conv345 = trunc i64 %317 to i32
  %318 = load ptr, ptr %args.addr, align 8
  %arrayidx346 = getelementptr i64, ptr %318, i64 4
  %319 = load i64, ptr %arrayidx346, align 8
  %conv347 = trunc i64 %319 to i32
  call void @tgen_arithr(ptr noundef %315, i32 noundef %add344, i32 noundef %conv345, i32 noundef %conv347)
  br label %if.end348

if.end348:                                        ; preds = %if.else343, %if.then339
  %320 = load ptr, ptr %const_args.addr, align 8
  %arrayidx349 = getelementptr i32, ptr %320, i64 5
  %321 = load i32, ptr %arrayidx349, align 4
  %tobool350 = icmp ne i32 %321, 0
  br i1 %tobool350, label %if.then351, label %if.else355

if.then351:                                       ; preds = %if.end348
  %322 = load ptr, ptr %s.addr, align 8
  %323 = load i32, ptr %rexw, align 4
  %add352 = add i32 2, %323
  %324 = load i64, ptr %a1, align 8
  %conv353 = trunc i64 %324 to i32
  %325 = load ptr, ptr %args.addr, align 8
  %arrayidx354 = getelementptr i64, ptr %325, i64 5
  %326 = load i64, ptr %arrayidx354, align 8
  call void @tgen_arithi(ptr noundef %322, i32 noundef %add352, i32 noundef %conv353, i64 noundef %326, i32 noundef 1)
  br label %if.end360

if.else355:                                       ; preds = %if.end348
  %327 = load ptr, ptr %s.addr, align 8
  %328 = load i32, ptr %rexw, align 4
  %add356 = add i32 2, %328
  %329 = load i64, ptr %a1, align 8
  %conv357 = trunc i64 %329 to i32
  %330 = load ptr, ptr %args.addr, align 8
  %arrayidx358 = getelementptr i64, ptr %330, i64 5
  %331 = load i64, ptr %arrayidx358, align 8
  %conv359 = trunc i64 %331 to i32
  call void @tgen_arithr(ptr noundef %327, i32 noundef %add356, i32 noundef %conv357, i32 noundef %conv359)
  br label %if.end360

if.end360:                                        ; preds = %if.else355, %if.then351
  br label %sw.epilog

sw.bb361:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb362

sw.bb362:                                         ; preds = %sw.bb361, %entry
  %332 = load ptr, ptr %const_args.addr, align 8
  %arrayidx363 = getelementptr i32, ptr %332, i64 4
  %333 = load i32, ptr %arrayidx363, align 4
  %tobool364 = icmp ne i32 %333, 0
  br i1 %tobool364, label %if.then365, label %if.else369

if.then365:                                       ; preds = %sw.bb362
  %334 = load ptr, ptr %s.addr, align 8
  %335 = load i32, ptr %rexw, align 4
  %add366 = add i32 5, %335
  %336 = load i64, ptr %a0, align 8
  %conv367 = trunc i64 %336 to i32
  %337 = load ptr, ptr %args.addr, align 8
  %arrayidx368 = getelementptr i64, ptr %337, i64 4
  %338 = load i64, ptr %arrayidx368, align 8
  call void @tgen_arithi(ptr noundef %334, i32 noundef %add366, i32 noundef %conv367, i64 noundef %338, i32 noundef 1)
  br label %if.end374

if.else369:                                       ; preds = %sw.bb362
  %339 = load ptr, ptr %s.addr, align 8
  %340 = load i32, ptr %rexw, align 4
  %add370 = add i32 5, %340
  %341 = load i64, ptr %a0, align 8
  %conv371 = trunc i64 %341 to i32
  %342 = load ptr, ptr %args.addr, align 8
  %arrayidx372 = getelementptr i64, ptr %342, i64 4
  %343 = load i64, ptr %arrayidx372, align 8
  %conv373 = trunc i64 %343 to i32
  call void @tgen_arithr(ptr noundef %339, i32 noundef %add370, i32 noundef %conv371, i32 noundef %conv373)
  br label %if.end374

if.end374:                                        ; preds = %if.else369, %if.then365
  %344 = load ptr, ptr %const_args.addr, align 8
  %arrayidx375 = getelementptr i32, ptr %344, i64 5
  %345 = load i32, ptr %arrayidx375, align 4
  %tobool376 = icmp ne i32 %345, 0
  br i1 %tobool376, label %if.then377, label %if.else381

if.then377:                                       ; preds = %if.end374
  %346 = load ptr, ptr %s.addr, align 8
  %347 = load i32, ptr %rexw, align 4
  %add378 = add i32 3, %347
  %348 = load i64, ptr %a1, align 8
  %conv379 = trunc i64 %348 to i32
  %349 = load ptr, ptr %args.addr, align 8
  %arrayidx380 = getelementptr i64, ptr %349, i64 5
  %350 = load i64, ptr %arrayidx380, align 8
  call void @tgen_arithi(ptr noundef %346, i32 noundef %add378, i32 noundef %conv379, i64 noundef %350, i32 noundef 1)
  br label %if.end386

if.else381:                                       ; preds = %if.end374
  %351 = load ptr, ptr %s.addr, align 8
  %352 = load i32, ptr %rexw, align 4
  %add382 = add i32 3, %352
  %353 = load i64, ptr %a1, align 8
  %conv383 = trunc i64 %353 to i32
  %354 = load ptr, ptr %args.addr, align 8
  %arrayidx384 = getelementptr i64, ptr %354, i64 5
  %355 = load i64, ptr %arrayidx384, align 8
  %conv385 = trunc i64 %355 to i32
  call void @tgen_arithr(ptr noundef %351, i32 noundef %add382, i32 noundef %conv383, i32 noundef %conv385)
  br label %if.end386

if.end386:                                        ; preds = %if.else381, %if.then377
  br label %sw.epilog

sw.bb387:                                         ; preds = %entry
  %356 = load ptr, ptr %s.addr, align 8
  %357 = load i64, ptr %a0, align 8
  %conv388 = trunc i64 %357 to i32
  %358 = load i64, ptr %a1, align 8
  %conv389 = trunc i64 %358 to i32
  %359 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %356, i32 noundef 4195, i32 noundef %conv388, i32 noundef %conv389, i64 noundef %359)
  br label %sw.epilog

sw.bb390:                                         ; preds = %entry
  %360 = load ptr, ptr %s.addr, align 8
  %361 = load i64, ptr %a0, align 8
  %conv391 = trunc i64 %361 to i32
  %362 = load i64, ptr %a1, align 8
  %conv392 = trunc i64 %362 to i32
  %363 = load i64, ptr %a2, align 8
  call void @tcg_out_ld(ptr noundef %360, i32 noundef 1, i32 noundef %conv391, i32 noundef %conv392, i64 noundef %363)
  br label %sw.epilog

sw.bb393:                                         ; preds = %entry
  %364 = load ptr, ptr %const_args.addr, align 8
  %arrayidx394 = getelementptr i32, ptr %364, i64 0
  %365 = load i32, ptr %arrayidx394, align 4
  %tobool395 = icmp ne i32 %365, 0
  br i1 %tobool395, label %if.then396, label %if.else399

if.then396:                                       ; preds = %sw.bb393
  %366 = load ptr, ptr %s.addr, align 8
  %367 = load i64, ptr %a1, align 8
  %conv397 = trunc i64 %367 to i32
  %368 = load i64, ptr %a2, align 8
  call void @tcg_out_modrm_offset(ptr noundef %366, i32 noundef 4295, i32 noundef 0, i32 noundef %conv397, i64 noundef %368)
  %369 = load ptr, ptr %s.addr, align 8
  %370 = load i64, ptr %a0, align 8
  %conv398 = trunc i64 %370 to i32
  call void @tcg_out32(ptr noundef %369, i32 noundef %conv398)
  br label %if.end402

if.else399:                                       ; preds = %sw.bb393
  %371 = load ptr, ptr %s.addr, align 8
  %372 = load i64, ptr %a0, align 8
  %conv400 = trunc i64 %372 to i32
  %373 = load i64, ptr %a1, align 8
  %conv401 = trunc i64 %373 to i32
  %374 = load i64, ptr %a2, align 8
  call void @tcg_out_st(ptr noundef %371, i32 noundef 1, i32 noundef %conv400, i32 noundef %conv401, i64 noundef %374)
  br label %if.end402

if.end402:                                        ; preds = %if.else399, %if.then396
  br label %sw.epilog

sw.bb403:                                         ; preds = %entry
  %375 = load ptr, ptr %s.addr, align 8
  %376 = load i64, ptr %a0, align 8
  %conv404 = trunc i64 %376 to i32
  call void @tcg_out_bswap64(ptr noundef %375, i32 noundef %conv404)
  br label %sw.epilog

sw.bb405:                                         ; preds = %entry
  %377 = load ptr, ptr %s.addr, align 8
  %378 = load i64, ptr %a0, align 8
  %conv406 = trunc i64 %378 to i32
  call void @tcg_out_shifti(ptr noundef %377, i32 noundef 4101, i32 noundef %conv406, i32 noundef 32)
  br label %sw.epilog

sw.bb407:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb408

sw.bb408:                                         ; preds = %sw.bb407, %entry
  %379 = load ptr, ptr %args.addr, align 8
  %arrayidx409 = getelementptr i64, ptr %379, i64 3
  %380 = load i64, ptr %arrayidx409, align 8
  %cmp410 = icmp eq i64 %380, 0
  br i1 %cmp410, label %land.lhs.true412, label %if.else427

land.lhs.true412:                                 ; preds = %sw.bb408
  %381 = load ptr, ptr %args.addr, align 8
  %arrayidx413 = getelementptr i64, ptr %381, i64 4
  %382 = load i64, ptr %arrayidx413, align 8
  %cmp414 = icmp eq i64 %382, 8
  br i1 %cmp414, label %if.then416, label %if.else427

if.then416:                                       ; preds = %land.lhs.true412
  %383 = load i32, ptr %const_a2, align 4
  %tobool417 = icmp ne i32 %383, 0
  br i1 %tobool417, label %if.then418, label %if.else423

if.then418:                                       ; preds = %if.then416
  %384 = load ptr, ptr %s.addr, align 8
  %385 = load i64, ptr %a0, align 8
  %and419 = and i64 %385, 7
  %or = or i64 16560, %and419
  %conv420 = trunc i64 %or to i32
  %386 = load i64, ptr %a0, align 8
  %conv421 = trunc i64 %386 to i32
  call void @tcg_out_opc(ptr noundef %384, i32 noundef %conv420, i32 noundef 0, i32 noundef %conv421, i32 noundef 0)
  %387 = load ptr, ptr %s.addr, align 8
  %388 = load i64, ptr %a2, align 8
  %conv422 = trunc i64 %388 to i8
  call void @tcg_out8(ptr noundef %387, i8 noundef zeroext %conv422)
  br label %if.end426

if.else423:                                       ; preds = %if.then416
  %389 = load ptr, ptr %s.addr, align 8
  %390 = load i64, ptr %a2, align 8
  %conv424 = trunc i64 %390 to i32
  %391 = load i64, ptr %a0, align 8
  %conv425 = trunc i64 %391 to i32
  call void @tcg_out_modrm(ptr noundef %389, i32 noundef 24712, i32 noundef %conv424, i32 noundef %conv425)
  br label %if.end426

if.end426:                                        ; preds = %if.else423, %if.then418
  br label %if.end451

if.else427:                                       ; preds = %land.lhs.true412, %sw.bb408
  %392 = load ptr, ptr %args.addr, align 8
  %arrayidx428 = getelementptr i64, ptr %392, i64 3
  %393 = load i64, ptr %arrayidx428, align 8
  %cmp429 = icmp eq i64 %393, 0
  br i1 %cmp429, label %land.lhs.true431, label %if.else447

land.lhs.true431:                                 ; preds = %if.else427
  %394 = load ptr, ptr %args.addr, align 8
  %arrayidx432 = getelementptr i64, ptr %394, i64 4
  %395 = load i64, ptr %arrayidx432, align 8
  %cmp433 = icmp eq i64 %395, 16
  br i1 %cmp433, label %if.then435, label %if.else447

if.then435:                                       ; preds = %land.lhs.true431
  %396 = load i32, ptr %const_a2, align 4
  %tobool436 = icmp ne i32 %396, 0
  br i1 %tobool436, label %if.then437, label %if.else443

if.then437:                                       ; preds = %if.then435
  %397 = load ptr, ptr %s.addr, align 8
  %398 = load i64, ptr %a0, align 8
  %and438 = and i64 %398, 7
  %or439 = or i64 1208, %and438
  %conv440 = trunc i64 %or439 to i32
  %399 = load i64, ptr %a0, align 8
  %conv441 = trunc i64 %399 to i32
  call void @tcg_out_opc(ptr noundef %397, i32 noundef %conv440, i32 noundef 0, i32 noundef %conv441, i32 noundef 0)
  %400 = load ptr, ptr %s.addr, align 8
  %401 = load i64, ptr %a2, align 8
  %conv442 = trunc i64 %401 to i16
  call void @tcg_out16(ptr noundef %400, i16 noundef zeroext %conv442)
  br label %if.end446

if.else443:                                       ; preds = %if.then435
  %402 = load ptr, ptr %s.addr, align 8
  %403 = load i64, ptr %a2, align 8
  %conv444 = trunc i64 %403 to i32
  %404 = load i64, ptr %a0, align 8
  %conv445 = trunc i64 %404 to i32
  call void @tcg_out_modrm(ptr noundef %402, i32 noundef 1161, i32 noundef %conv444, i32 noundef %conv445)
  br label %if.end446

if.end446:                                        ; preds = %if.else443, %if.then437
  br label %if.end450

if.else447:                                       ; preds = %land.lhs.true431, %if.else427
  br label %do.body448

do.body448:                                       ; preds = %if.else447
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 2835, ptr noundef @__func__.tcg_out_op, ptr noundef null) #15
  unreachable

do.end449:                                        ; No predecessors!
  br label %if.end450

if.end450:                                        ; preds = %do.end449, %if.end446
  br label %if.end451

if.end451:                                        ; preds = %if.end450, %if.end426
  br label %sw.epilog

sw.bb452:                                         ; preds = %entry
  %405 = load i64, ptr %a2, align 8
  %406 = load ptr, ptr %args.addr, align 8
  %arrayidx453 = getelementptr i64, ptr %406, i64 3
  %407 = load i64, ptr %arrayidx453, align 8
  %add454 = add i64 %405, %407
  %cmp455 = icmp eq i64 %add454, 32
  br i1 %cmp455, label %if.then457, label %if.end463

if.then457:                                       ; preds = %sw.bb452
  %408 = load ptr, ptr %s.addr, align 8
  %409 = load i64, ptr %a0, align 8
  %conv458 = trunc i64 %409 to i32
  %410 = load i64, ptr %a1, align 8
  %conv459 = trunc i64 %410 to i32
  %call460 = call zeroext i1 @tcg_out_mov(ptr noundef %408, i32 noundef 0, i32 noundef %conv458, i32 noundef %conv459)
  %411 = load ptr, ptr %s.addr, align 8
  %412 = load i64, ptr %a0, align 8
  %conv461 = trunc i64 %412 to i32
  %413 = load i64, ptr %a2, align 8
  %conv462 = trunc i64 %413 to i32
  call void @tcg_out_shifti(ptr noundef %411, i32 noundef 5, i32 noundef %conv461, i32 noundef %conv462)
  br label %sw.epilog

if.end463:                                        ; preds = %sw.bb452
  br label %sw.bb464

sw.bb464:                                         ; preds = %if.end463, %entry
  br label %do.body465

do.body465:                                       ; preds = %sw.bb464
  %414 = load i64, ptr %a2, align 8
  %cmp466 = icmp eq i64 %414, 8
  br i1 %cmp466, label %land.lhs.true468, label %if.then472

land.lhs.true468:                                 ; preds = %do.body465
  %415 = load ptr, ptr %args.addr, align 8
  %arrayidx469 = getelementptr i64, ptr %415, i64 3
  %416 = load i64, ptr %arrayidx469, align 8
  %cmp470 = icmp eq i64 %416, 8
  br i1 %cmp470, label %if.end473, label %if.then472

if.then472:                                       ; preds = %land.lhs.true468, %do.body465
  unreachable

if.end473:                                        ; preds = %land.lhs.true468
  br label %do.end474

do.end474:                                        ; preds = %if.end473
  %417 = load i64, ptr %a1, align 8
  %cmp475 = icmp ult i64 %417, 4
  br i1 %cmp475, label %land.lhs.true477, label %if.else484

land.lhs.true477:                                 ; preds = %do.end474
  %418 = load i64, ptr %a0, align 8
  %cmp478 = icmp ult i64 %418, 8
  br i1 %cmp478, label %if.then480, label %if.else484

if.then480:                                       ; preds = %land.lhs.true477
  %419 = load ptr, ptr %s.addr, align 8
  %420 = load i64, ptr %a0, align 8
  %conv481 = trunc i64 %420 to i32
  %421 = load i64, ptr %a1, align 8
  %add482 = add i64 %421, 4
  %conv483 = trunc i64 %add482 to i32
  call void @tcg_out_modrm(ptr noundef %419, i32 noundef 438, i32 noundef %conv481, i32 noundef %conv483)
  br label %if.end488

if.else484:                                       ; preds = %land.lhs.true477, %do.end474
  %422 = load ptr, ptr %s.addr, align 8
  %423 = load i64, ptr %a0, align 8
  %conv485 = trunc i64 %423 to i32
  %424 = load i64, ptr %a1, align 8
  %conv486 = trunc i64 %424 to i32
  call void @tcg_out_ext16u(ptr noundef %422, i32 noundef %conv485, i32 noundef %conv486)
  %425 = load ptr, ptr %s.addr, align 8
  %426 = load i64, ptr %a0, align 8
  %conv487 = trunc i64 %426 to i32
  call void @tcg_out_shifti(ptr noundef %425, i32 noundef 5, i32 noundef %conv487, i32 noundef 8)
  br label %if.end488

if.end488:                                        ; preds = %if.else484, %if.then480
  br label %sw.epilog

sw.bb489:                                         ; preds = %entry
  br label %do.body490

do.body490:                                       ; preds = %sw.bb489
  %427 = load i64, ptr %a2, align 8
  %cmp491 = icmp eq i64 %427, 8
  br i1 %cmp491, label %land.lhs.true493, label %if.then497

land.lhs.true493:                                 ; preds = %do.body490
  %428 = load ptr, ptr %args.addr, align 8
  %arrayidx494 = getelementptr i64, ptr %428, i64 3
  %429 = load i64, ptr %arrayidx494, align 8
  %cmp495 = icmp eq i64 %429, 8
  br i1 %cmp495, label %if.end498, label %if.then497

if.then497:                                       ; preds = %land.lhs.true493, %do.body490
  unreachable

if.end498:                                        ; preds = %land.lhs.true493
  br label %do.end499

do.end499:                                        ; preds = %if.end498
  %430 = load i64, ptr %a1, align 8
  %cmp500 = icmp ult i64 %430, 4
  br i1 %cmp500, label %land.lhs.true502, label %if.else509

land.lhs.true502:                                 ; preds = %do.end499
  %431 = load i64, ptr %a0, align 8
  %cmp503 = icmp ult i64 %431, 8
  br i1 %cmp503, label %if.then505, label %if.else509

if.then505:                                       ; preds = %land.lhs.true502
  %432 = load ptr, ptr %s.addr, align 8
  %433 = load i64, ptr %a0, align 8
  %conv506 = trunc i64 %433 to i32
  %434 = load i64, ptr %a1, align 8
  %add507 = add i64 %434, 4
  %conv508 = trunc i64 %add507 to i32
  call void @tcg_out_modrm(ptr noundef %432, i32 noundef 446, i32 noundef %conv506, i32 noundef %conv508)
  br label %if.end513

if.else509:                                       ; preds = %land.lhs.true502, %do.end499
  %435 = load ptr, ptr %s.addr, align 8
  %436 = load i64, ptr %a0, align 8
  %conv510 = trunc i64 %436 to i32
  %437 = load i64, ptr %a1, align 8
  %conv511 = trunc i64 %437 to i32
  call void @tcg_out_ext16s(ptr noundef %435, i32 noundef 0, i32 noundef %conv510, i32 noundef %conv511)
  %438 = load ptr, ptr %s.addr, align 8
  %439 = load i64, ptr %a0, align 8
  %conv512 = trunc i64 %439 to i32
  call void @tcg_out_shifti(ptr noundef %438, i32 noundef 7, i32 noundef %conv512, i32 noundef 8)
  br label %if.end513

if.end513:                                        ; preds = %if.else509, %if.then505
  br label %sw.epilog

sw.bb514:                                         ; preds = %entry
  store i32 4096, ptr %rexw, align 4
  br label %sw.bb515

sw.bb515:                                         ; preds = %sw.bb514, %entry
  %440 = load ptr, ptr %s.addr, align 8
  %441 = load i32, ptr %rexw, align 4
  %add516 = add i32 428, %441
  %442 = load i64, ptr %a2, align 8
  %conv517 = trunc i64 %442 to i32
  %443 = load i64, ptr %a0, align 8
  %conv518 = trunc i64 %443 to i32
  call void @tcg_out_modrm(ptr noundef %440, i32 noundef %add516, i32 noundef %conv517, i32 noundef %conv518)
  %444 = load ptr, ptr %s.addr, align 8
  %445 = load ptr, ptr %args.addr, align 8
  %arrayidx519 = getelementptr i64, ptr %445, i64 3
  %446 = load i64, ptr %arrayidx519, align 8
  %conv520 = trunc i64 %446 to i8
  call void @tcg_out8(ptr noundef %444, i8 noundef zeroext %conv520)
  br label %sw.epilog

sw.bb521:                                         ; preds = %entry
  %447 = load ptr, ptr %s.addr, align 8
  %448 = load i64, ptr %a0, align 8
  call void @tcg_out_mb(ptr noundef %447, i64 noundef %448)
  br label %sw.epilog

sw.bb522:                                         ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry
  br label %sw.default

sw.default:                                       ; preds = %sw.bb522, %entry
  br label %do.body523

do.body523:                                       ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 2901, ptr noundef @__func__.tcg_out_op, ptr noundef null) #15
  unreachable

do.end524:                                        ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end524, %sw.bb521, %sw.bb515, %if.end513, %if.end488, %if.then457, %if.end451, %sw.bb405, %sw.bb403, %if.end402, %sw.bb390, %sw.bb387, %if.end386, %if.end360, %sw.bb331, %sw.bb326, %do.end319, %sw.bb313, %sw.bb309, %sw.bb305, %do.end, %sw.bb294, %sw.bb290, %sw.bb286, %sw.bb282, %sw.bb278, %if.end276, %if.end265, %sw.bb234, %sw.bb230, %sw.bb226, %sw.bb220, %sw.bb215, %sw.bb206, %sw.bb197, %if.end195, %if.then175, %if.end162, %sw.bb136, %sw.bb131, %if.end129, %if.end105, %if.end89, %if.end67, %if.then62, %if.end52, %if.end42, %if.end, %sw.bb22, %sw.bb18, %sw.bb14, %sw.bb10, %sw.bb6, %sw.bb4, %sw.bb
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_jxx(ptr noundef %s, i32 noundef %opc, ptr noundef %l, i1 noundef zeroext %small) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %opc.addr = alloca i32, align 4
  %l.addr = alloca ptr, align 8
  %small.addr = alloca i8, align 1
  %val = alloca i32, align 4
  %val1 = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %opc, ptr %opc.addr, align 4
  store ptr %l, ptr %l.addr, align 8
  %frombool = zext i1 %small to i8
  store i8 %frombool, ptr %small.addr, align 1
  %0 = load ptr, ptr %l.addr, align 8
  %has_value = getelementptr inbounds %struct.TCGLabel, ptr %0, i32 0, i32 1
  %1 = load i8, ptr %has_value, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.else23

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load ptr, ptr %l.addr, align 8
  %u = getelementptr inbounds %struct.TCGLabel, ptr %3, i32 0, i32 3
  %4 = load ptr, ptr %u, align 8
  %call = call i64 @tcg_pcrel_diff(ptr noundef %2, ptr noundef %4)
  %conv = trunc i64 %call to i32
  store i32 %conv, ptr %val, align 4
  %5 = load i32, ptr %val, align 4
  %sub = sub i32 %5, 2
  store i32 %sub, ptr %val1, align 4
  %6 = load i32, ptr %val1, align 4
  %conv1 = trunc i32 %6 to i8
  %conv2 = sext i8 %conv1 to i32
  %7 = load i32, ptr %val1, align 4
  %cmp = icmp eq i32 %conv2, %7
  br i1 %cmp, label %if.then4, label %if.else10

if.then4:                                         ; preds = %if.then
  %8 = load i32, ptr %opc.addr, align 4
  %cmp5 = icmp eq i32 %8, -1
  br i1 %cmp5, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.then4
  %9 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %9, i8 noundef zeroext -21)
  br label %if.end

if.else:                                          ; preds = %if.then4
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load i32, ptr %opc.addr, align 4
  %add = add i32 112, %11
  %conv8 = trunc i32 %add to i8
  call void @tcg_out8(ptr noundef %10, i8 noundef zeroext %conv8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then7
  %12 = load ptr, ptr %s.addr, align 8
  %13 = load i32, ptr %val1, align 4
  %conv9 = trunc i32 %13 to i8
  call void @tcg_out8(ptr noundef %12, i8 noundef zeroext %conv9)
  br label %if.end22

if.else10:                                        ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.else10
  %14 = load i8, ptr %small.addr, align 1
  %tobool11 = trunc i8 %14 to i1
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %do.body
  unreachable

if.end13:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end13
  %15 = load i32, ptr %opc.addr, align 4
  %cmp14 = icmp eq i32 %15, -1
  br i1 %cmp14, label %if.then16, label %if.else18

if.then16:                                        ; preds = %do.end
  %16 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %16, i8 noundef zeroext -23)
  %17 = load ptr, ptr %s.addr, align 8
  %18 = load i32, ptr %val, align 4
  %sub17 = sub i32 %18, 5
  call void @tcg_out32(ptr noundef %17, i32 noundef %sub17)
  br label %if.end21

if.else18:                                        ; preds = %do.end
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load i32, ptr %opc.addr, align 4
  %add19 = add i32 384, %20
  call void @tcg_out_opc(ptr noundef %19, i32 noundef %add19, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  %21 = load ptr, ptr %s.addr, align 8
  %22 = load i32, ptr %val, align 4
  %sub20 = sub i32 %22, 6
  call void @tcg_out32(ptr noundef %21, i32 noundef %sub20)
  br label %if.end21

if.end21:                                         ; preds = %if.else18, %if.then16
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end
  br label %if.end45

if.else23:                                        ; preds = %entry
  %23 = load i8, ptr %small.addr, align 1
  %tobool24 = trunc i8 %23 to i1
  br i1 %tobool24, label %if.then25, label %if.else34

if.then25:                                        ; preds = %if.else23
  %24 = load i32, ptr %opc.addr, align 4
  %cmp26 = icmp eq i32 %24, -1
  br i1 %cmp26, label %if.then28, label %if.else29

if.then28:                                        ; preds = %if.then25
  %25 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %25, i8 noundef zeroext -21)
  br label %if.end32

if.else29:                                        ; preds = %if.then25
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i32, ptr %opc.addr, align 4
  %add30 = add i32 112, %27
  %conv31 = trunc i32 %add30 to i8
  call void @tcg_out8(ptr noundef %26, i8 noundef zeroext %conv31)
  br label %if.end32

if.end32:                                         ; preds = %if.else29, %if.then28
  %28 = load ptr, ptr %s.addr, align 8
  %29 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %29, i32 0, i32 23
  %30 = load ptr, ptr %code_ptr, align 8
  %31 = load ptr, ptr %l.addr, align 8
  call void @tcg_out_reloc(ptr noundef %28, ptr noundef %30, i32 noundef 23, ptr noundef %31, i64 noundef -1)
  %32 = load ptr, ptr %s.addr, align 8
  %code_ptr33 = getelementptr inbounds %struct.TCGContext, ptr %32, i32 0, i32 23
  %33 = load ptr, ptr %code_ptr33, align 8
  %add.ptr = getelementptr i8, ptr %33, i64 1
  store ptr %add.ptr, ptr %code_ptr33, align 8
  br label %if.end44

if.else34:                                        ; preds = %if.else23
  %34 = load i32, ptr %opc.addr, align 4
  %cmp35 = icmp eq i32 %34, -1
  br i1 %cmp35, label %if.then37, label %if.else38

if.then37:                                        ; preds = %if.else34
  %35 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %35, i8 noundef zeroext -23)
  br label %if.end40

if.else38:                                        ; preds = %if.else34
  %36 = load ptr, ptr %s.addr, align 8
  %37 = load i32, ptr %opc.addr, align 4
  %add39 = add i32 384, %37
  call void @tcg_out_opc(ptr noundef %36, i32 noundef %add39, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  br label %if.end40

if.end40:                                         ; preds = %if.else38, %if.then37
  %38 = load ptr, ptr %s.addr, align 8
  %39 = load ptr, ptr %s.addr, align 8
  %code_ptr41 = getelementptr inbounds %struct.TCGContext, ptr %39, i32 0, i32 23
  %40 = load ptr, ptr %code_ptr41, align 8
  %41 = load ptr, ptr %l.addr, align 8
  call void @tcg_out_reloc(ptr noundef %38, ptr noundef %40, i32 noundef 2, ptr noundef %41, i64 noundef -4)
  %42 = load ptr, ptr %s.addr, align 8
  %code_ptr42 = getelementptr inbounds %struct.TCGContext, ptr %42, i32 0, i32 23
  %43 = load ptr, ptr %code_ptr42, align 8
  %add.ptr43 = getelementptr i8, ptr %43, i64 4
  store ptr %add.ptr43, ptr %code_ptr42, align 8
  br label %if.end44

if.end44:                                         ; preds = %if.end40, %if.end32
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.end22
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out16(ptr noundef %s, i16 noundef zeroext %v) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %v.addr = alloca i16, align 2
  %p = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i16 %v, ptr %v.addr, align 2
  %0 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %0, i32 0, i32 23
  %1 = load ptr, ptr %code_ptr, align 8
  store ptr %1, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %2, ptr align 2 %v.addr, i64 2, i1 false)
  %3 = load ptr, ptr %p, align 8
  %add.ptr = getelementptr i8, ptr %3, i64 2
  %4 = load ptr, ptr %s.addr, align 8
  %code_ptr1 = getelementptr inbounds %struct.TCGContext, ptr %4, i32 0, i32 23
  store ptr %add.ptr, ptr %code_ptr1, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_shifti(ptr noundef %s, i32 noundef %subopc, i32 noundef %reg, i32 noundef %count) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %subopc.addr = alloca i32, align 4
  %reg.addr = alloca i32, align 4
  %count.addr = alloca i32, align 4
  %ext = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %subopc, ptr %subopc.addr, align 4
  store i32 %reg, ptr %reg.addr, align 4
  store i32 %count, ptr %count.addr, align 4
  %0 = load i32, ptr %subopc.addr, align 4
  %and = and i32 %0, -8
  store i32 %and, ptr %ext, align 4
  %1 = load i32, ptr %subopc.addr, align 4
  %and1 = and i32 %1, 7
  store i32 %and1, ptr %subopc.addr, align 4
  %2 = load i32, ptr %count.addr, align 4
  %cmp = icmp eq i32 %2, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load i32, ptr %ext, align 4
  %add = add i32 209, %4
  %5 = load i32, ptr %subopc.addr, align 4
  %6 = load i32, ptr %reg.addr, align 4
  call void @tcg_out_modrm(ptr noundef %3, i32 noundef %add, i32 noundef %5, i32 noundef %6)
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i32, ptr %ext, align 4
  %add2 = add i32 193, %8
  %9 = load i32, ptr %subopc.addr, align 4
  %10 = load i32, ptr %reg.addr, align 4
  call void @tcg_out_modrm(ptr noundef %7, i32 noundef %add2, i32 noundef %9, i32 noundef %10)
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load i32, ptr %count.addr, align 4
  %conv = trunc i32 %12 to i8
  call void @tcg_out8(ptr noundef %11, i8 noundef zeroext %conv)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_ctz(ptr noundef %s, i32 noundef %rexw, i32 noundef %dest, i32 noundef %arg1, i64 noundef %arg2, i1 noundef zeroext %const_a2) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %rexw.addr = alloca i32, align 4
  %dest.addr = alloca i32, align 4
  %arg1.addr = alloca i32, align 4
  %arg2.addr = alloca i64, align 8
  %const_a2.addr = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  store i32 %rexw, ptr %rexw.addr, align 4
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %arg1, ptr %arg1.addr, align 4
  store i64 %arg2, ptr %arg2.addr, align 8
  %frombool = zext i1 %const_a2 to i8
  store i8 %frombool, ptr %const_a2.addr, align 1
  %0 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %0, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else15

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %rexw.addr, align 4
  %add = add i32 131516, %2
  %3 = load i32, ptr %dest.addr, align 4
  %4 = load i32, ptr %arg1.addr, align 4
  call void @tcg_out_modrm(ptr noundef %1, i32 noundef %add, i32 noundef %3, i32 noundef %4)
  %5 = load i8, ptr %const_a2.addr, align 1
  %tobool1 = trunc i8 %5 to i1
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then2
  %6 = load i64, ptr %arg2.addr, align 8
  %7 = load i32, ptr %rexw.addr, align 4
  %tobool3 = icmp ne i32 %7, 0
  %cond = select i1 %tobool3, i32 64, i32 32
  %conv = sext i32 %cond to i64
  %cmp = icmp eq i64 %6, %conv
  br i1 %cmp, label %if.end, label %if.then5

if.then5:                                         ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %if.end14

if.else:                                          ; preds = %if.then
  br label %do.body6

do.body6:                                         ; preds = %if.else
  %8 = load i32, ptr %dest.addr, align 4
  %conv7 = zext i32 %8 to i64
  %9 = load i64, ptr %arg2.addr, align 8
  %cmp8 = icmp ne i64 %conv7, %9
  br i1 %cmp8, label %if.end11, label %if.then10

if.then10:                                        ; preds = %do.body6
  unreachable

if.end11:                                         ; preds = %do.body6
  br label %do.end12

do.end12:                                         ; preds = %if.end11
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load i32, ptr %rexw.addr, align 4
  %12 = load i32, ptr %dest.addr, align 4
  %13 = load i64, ptr %arg2.addr, align 8
  %conv13 = trunc i64 %13 to i32
  call void @tcg_out_cmov(ptr noundef %10, i32 noundef 4, i32 noundef %11, i32 noundef %12, i32 noundef %conv13)
  br label %if.end14

if.end14:                                         ; preds = %do.end12, %do.end
  br label %if.end25

if.else15:                                        ; preds = %entry
  br label %do.body16

do.body16:                                        ; preds = %if.else15
  %14 = load i32, ptr %dest.addr, align 4
  %conv17 = zext i32 %14 to i64
  %15 = load i64, ptr %arg2.addr, align 8
  %cmp18 = icmp ne i64 %conv17, %15
  br i1 %cmp18, label %if.end21, label %if.then20

if.then20:                                        ; preds = %do.body16
  unreachable

if.end21:                                         ; preds = %do.body16
  br label %do.end22

do.end22:                                         ; preds = %if.end21
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i32, ptr %rexw.addr, align 4
  %add23 = add i32 444, %17
  %18 = load i32, ptr %dest.addr, align 4
  %19 = load i32, ptr %arg1.addr, align 4
  call void @tcg_out_modrm(ptr noundef %16, i32 noundef %add23, i32 noundef %18, i32 noundef %19)
  %20 = load ptr, ptr %s.addr, align 8
  %21 = load i32, ptr %rexw.addr, align 4
  %22 = load i32, ptr %dest.addr, align 4
  %23 = load i64, ptr %arg2.addr, align 8
  %conv24 = trunc i64 %23 to i32
  call void @tcg_out_cmov(ptr noundef %20, i32 noundef 8, i32 noundef %21, i32 noundef %22, i32 noundef %conv24)
  br label %if.end25

if.end25:                                         ; preds = %do.end22, %if.end14
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_clz(ptr noundef %s, i32 noundef %rexw, i32 noundef %dest, i32 noundef %arg1, i64 noundef %arg2, i1 noundef zeroext %const_a2) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %rexw.addr = alloca i32, align 4
  %dest.addr = alloca i32, align 4
  %arg1.addr = alloca i32, align 4
  %arg2.addr = alloca i64, align 8
  %const_a2.addr = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  store i32 %rexw, ptr %rexw.addr, align 4
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %arg1, ptr %arg1.addr, align 4
  store i64 %arg2, ptr %arg2.addr, align 8
  %frombool = zext i1 %const_a2 to i8
  store i8 %frombool, ptr %const_a2.addr, align 1
  %0 = load i32, ptr @cpuinfo, align 4
  %and = and i32 %0, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else15

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %rexw.addr, align 4
  %add = add i32 131517, %2
  %3 = load i32, ptr %dest.addr, align 4
  %4 = load i32, ptr %arg1.addr, align 4
  call void @tcg_out_modrm(ptr noundef %1, i32 noundef %add, i32 noundef %3, i32 noundef %4)
  %5 = load i8, ptr %const_a2.addr, align 1
  %tobool1 = trunc i8 %5 to i1
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then2
  %6 = load i64, ptr %arg2.addr, align 8
  %7 = load i32, ptr %rexw.addr, align 4
  %tobool3 = icmp ne i32 %7, 0
  %cond = select i1 %tobool3, i32 64, i32 32
  %conv = sext i32 %cond to i64
  %cmp = icmp eq i64 %6, %conv
  br i1 %cmp, label %if.end, label %if.then5

if.then5:                                         ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %if.end14

if.else:                                          ; preds = %if.then
  br label %do.body6

do.body6:                                         ; preds = %if.else
  %8 = load i32, ptr %dest.addr, align 4
  %conv7 = zext i32 %8 to i64
  %9 = load i64, ptr %arg2.addr, align 8
  %cmp8 = icmp ne i64 %conv7, %9
  br i1 %cmp8, label %if.end11, label %if.then10

if.then10:                                        ; preds = %do.body6
  unreachable

if.end11:                                         ; preds = %do.body6
  br label %do.end12

do.end12:                                         ; preds = %if.end11
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load i32, ptr %rexw.addr, align 4
  %12 = load i32, ptr %dest.addr, align 4
  %13 = load i64, ptr %arg2.addr, align 8
  %conv13 = trunc i64 %13 to i32
  call void @tcg_out_cmov(ptr noundef %10, i32 noundef 4, i32 noundef %11, i32 noundef %12, i32 noundef %conv13)
  br label %if.end14

if.end14:                                         ; preds = %do.end12, %do.end
  br label %if.end41

if.else15:                                        ; preds = %entry
  br label %do.body16

do.body16:                                        ; preds = %if.else15
  %14 = load i8, ptr %const_a2.addr, align 1
  %tobool17 = trunc i8 %14 to i1
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %do.body16
  unreachable

if.end19:                                         ; preds = %do.body16
  br label %do.end20

do.end20:                                         ; preds = %if.end19
  br label %do.body21

do.body21:                                        ; preds = %do.end20
  %15 = load i32, ptr %dest.addr, align 4
  %16 = load i32, ptr %arg1.addr, align 4
  %cmp22 = icmp ne i32 %15, %16
  br i1 %cmp22, label %if.end25, label %if.then24

if.then24:                                        ; preds = %do.body21
  unreachable

if.end25:                                         ; preds = %do.body21
  br label %do.end26

do.end26:                                         ; preds = %if.end25
  br label %do.body27

do.body27:                                        ; preds = %do.end26
  %17 = load i32, ptr %dest.addr, align 4
  %conv28 = zext i32 %17 to i64
  %18 = load i64, ptr %arg2.addr, align 8
  %cmp29 = icmp ne i64 %conv28, %18
  br i1 %cmp29, label %if.end32, label %if.then31

if.then31:                                        ; preds = %do.body27
  unreachable

if.end32:                                         ; preds = %do.body27
  br label %do.end33

do.end33:                                         ; preds = %if.end32
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load i32, ptr %rexw.addr, align 4
  %add34 = add i32 445, %20
  %21 = load i32, ptr %dest.addr, align 4
  %22 = load i32, ptr %arg1.addr, align 4
  call void @tcg_out_modrm(ptr noundef %19, i32 noundef %add34, i32 noundef %21, i32 noundef %22)
  %23 = load ptr, ptr %s.addr, align 8
  %24 = load i32, ptr %rexw.addr, align 4
  %add35 = add i32 6, %24
  %25 = load i32, ptr %dest.addr, align 4
  %26 = load i32, ptr %rexw.addr, align 4
  %tobool36 = icmp ne i32 %26, 0
  %cond37 = select i1 %tobool36, i32 63, i32 31
  %conv38 = sext i32 %cond37 to i64
  call void @tgen_arithi(ptr noundef %23, i32 noundef %add35, i32 noundef %25, i64 noundef %conv38, i32 noundef 0)
  %27 = load ptr, ptr %s.addr, align 8
  %28 = load i32, ptr %arg1.addr, align 4
  %conv39 = zext i32 %28 to i64
  %29 = load i32, ptr %rexw.addr, align 4
  call void @tcg_out_cmp(ptr noundef %27, i64 noundef %conv39, i64 noundef 0, i32 noundef 1, i32 noundef %29)
  %30 = load ptr, ptr %s.addr, align 8
  %31 = load i32, ptr %rexw.addr, align 4
  %32 = load i32, ptr %dest.addr, align 4
  %33 = load i64, ptr %arg2.addr, align 8
  %conv40 = trunc i64 %33 to i32
  call void @tcg_out_cmov(ptr noundef %30, i32 noundef 8, i32 noundef %31, i32 noundef %32, i32 noundef %conv40)
  br label %if.end41

if.end41:                                         ; preds = %do.end33, %if.end14
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_brcond(ptr noundef %s, i32 noundef %rexw, i32 noundef %cond, i64 noundef %arg1, i64 noundef %arg2, i32 noundef %const_arg2, ptr noundef %label, i1 noundef zeroext %small) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %rexw.addr = alloca i32, align 4
  %cond.addr = alloca i32, align 4
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %const_arg2.addr = alloca i32, align 4
  %label.addr = alloca ptr, align 8
  %small.addr = alloca i8, align 1
  store ptr %s, ptr %s.addr, align 8
  store i32 %rexw, ptr %rexw.addr, align 4
  store i32 %cond, ptr %cond.addr, align 4
  store i64 %arg1, ptr %arg1.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i32 %const_arg2, ptr %const_arg2.addr, align 4
  store ptr %label, ptr %label.addr, align 8
  %frombool = zext i1 %small to i8
  store i8 %frombool, ptr %small.addr, align 1
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i64, ptr %arg1.addr, align 8
  %2 = load i64, ptr %arg2.addr, align 8
  %3 = load i32, ptr %const_arg2.addr, align 4
  %4 = load i32, ptr %rexw.addr, align 4
  call void @tcg_out_cmp(ptr noundef %0, i64 noundef %1, i64 noundef %2, i32 noundef %3, i32 noundef %4)
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i32, ptr %cond.addr, align 4
  %idxprom = zext i32 %6 to i64
  %arrayidx = getelementptr [14 x i8], ptr @tcg_cond_to_jcc, i64 0, i64 %idxprom
  %7 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %7 to i32
  %8 = load ptr, ptr %label.addr, align 8
  %9 = load i8, ptr %small.addr, align 1
  %tobool = trunc i8 %9 to i1
  call void @tcg_out_jxx(ptr noundef %5, i32 noundef %conv, ptr noundef %8, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_setcond(ptr noundef %s, i32 noundef %rexw, i32 noundef %cond, i64 noundef %dest, i64 noundef %arg1, i64 noundef %arg2, i32 noundef %const_arg2, i1 noundef zeroext %neg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %rexw.addr = alloca i32, align 4
  %cond.addr = alloca i32, align 4
  %dest.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %const_arg2.addr = alloca i32, align 4
  %neg.addr = alloca i8, align 1
  %inv = alloca i8, align 1
  %cleared = alloca i8, align 1
  %t = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %rexw, ptr %rexw.addr, align 4
  store i32 %cond, ptr %cond.addr, align 4
  store i64 %dest, ptr %dest.addr, align 8
  store i64 %arg1, ptr %arg1.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i32 %const_arg2, ptr %const_arg2.addr, align 4
  %frombool = zext i1 %neg to i8
  store i8 %frombool, ptr %neg.addr, align 1
  store i8 0, ptr %inv, align 1
  %0 = load i32, ptr %cond.addr, align 4
  switch i32 %0, label %sw.default [
    i32 9, label %sw.bb
    i32 8, label %sw.bb1
    i32 12, label %sw.bb2
    i32 13, label %sw.bb3
    i32 5, label %sw.bb8
    i32 4, label %sw.bb9
    i32 3, label %sw.bb33
    i32 2, label %sw.bb34
  ]

sw.bb:                                            ; preds = %entry
  store i8 1, ptr %inv, align 1
  br label %sw.bb1

sw.bb1:                                           ; preds = %sw.bb, %entry
  %1 = load i32, ptr %const_arg2.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %sw.bb1
  %2 = load i64, ptr %arg2.addr, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i64 1, ptr %arg2.addr, align 8
  br label %do_ltu

if.end:                                           ; preds = %land.lhs.true, %sw.bb1
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  store i8 1, ptr %inv, align 1
  br label %sw.bb3

sw.bb3:                                           ; preds = %sw.bb2, %entry
  %3 = load i32, ptr %const_arg2.addr, align 4
  %tobool4 = icmp ne i32 %3, 0
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %sw.bb3
  %4 = load i64, ptr %arg1.addr, align 8
  %conv = trunc i64 %4 to i32
  store i32 %conv, ptr %t, align 4
  %5 = load i64, ptr %arg2.addr, align 8
  store i64 %5, ptr %arg1.addr, align 8
  %6 = load i32, ptr %t, align 4
  %conv6 = zext i32 %6 to i64
  store i64 %conv6, ptr %arg2.addr, align 8
  br label %do_ltu

if.end7:                                          ; preds = %sw.bb3
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry
  store i8 1, ptr %inv, align 1
  br label %sw.bb9

sw.bb9:                                           ; preds = %sw.bb8, %entry
  br label %do_ltu

do_ltu:                                           ; preds = %sw.bb9, %if.then5, %if.then
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i64, ptr %arg1.addr, align 8
  %9 = load i64, ptr %arg2.addr, align 8
  %10 = load i32, ptr %const_arg2.addr, align 4
  %11 = load i32, ptr %rexw.addr, align 4
  call void @tcg_out_cmp(ptr noundef %7, i64 noundef %8, i64 noundef %9, i32 noundef %10, i32 noundef %11)
  %12 = load ptr, ptr %s.addr, align 8
  %13 = load i8, ptr %neg.addr, align 1
  %tobool10 = trunc i8 %13 to i1
  br i1 %tobool10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do_ltu
  %14 = load i32, ptr %rexw.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %do_ltu
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond12 = phi i32 [ %14, %cond.true ], [ 0, %cond.false ]
  %add = add i32 3, %cond12
  %15 = load i64, ptr %dest.addr, align 8
  %conv13 = trunc i64 %15 to i32
  %16 = load i64, ptr %dest.addr, align 8
  %conv14 = trunc i64 %16 to i32
  call void @tgen_arithr(ptr noundef %12, i32 noundef %add, i32 noundef %conv13, i32 noundef %conv14)
  %17 = load i8, ptr %inv, align 1
  %tobool15 = trunc i8 %17 to i1
  br i1 %tobool15, label %land.lhs.true17, label %if.else

land.lhs.true17:                                  ; preds = %cond.end
  %18 = load i8, ptr %neg.addr, align 1
  %tobool18 = trunc i8 %18 to i1
  br i1 %tobool18, label %if.then20, label %if.else

if.then20:                                        ; preds = %land.lhs.true17
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load i32, ptr %rexw.addr, align 4
  %add21 = add i32 247, %20
  %21 = load i64, ptr %dest.addr, align 8
  %conv22 = trunc i64 %21 to i32
  call void @tcg_out_modrm(ptr noundef %19, i32 noundef %add21, i32 noundef 2, i32 noundef %conv22)
  br label %if.end32

if.else:                                          ; preds = %land.lhs.true17, %cond.end
  %22 = load i8, ptr %inv, align 1
  %tobool23 = trunc i8 %22 to i1
  br i1 %tobool23, label %if.then24, label %if.else26

if.then24:                                        ; preds = %if.else
  %23 = load ptr, ptr %s.addr, align 8
  %24 = load i64, ptr %dest.addr, align 8
  %conv25 = trunc i64 %24 to i32
  call void @tgen_arithi(ptr noundef %23, i32 noundef 0, i32 noundef %conv25, i64 noundef 1, i32 noundef 0)
  br label %if.end31

if.else26:                                        ; preds = %if.else
  %25 = load i8, ptr %neg.addr, align 1
  %tobool27 = trunc i8 %25 to i1
  br i1 %tobool27, label %if.end30, label %if.then28

if.then28:                                        ; preds = %if.else26
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i64, ptr %dest.addr, align 8
  %conv29 = trunc i64 %27 to i32
  call void @tcg_out_modrm(ptr noundef %26, i32 noundef 247, i32 noundef 3, i32 noundef %conv29)
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.else26
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then24
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then20
  br label %if.end78

sw.bb33:                                          ; preds = %entry
  store i8 1, ptr %inv, align 1
  br label %sw.bb34

sw.bb34:                                          ; preds = %sw.bb33, %entry
  %28 = load i32, ptr %const_arg2.addr, align 4
  %tobool35 = icmp ne i32 %28, 0
  br i1 %tobool35, label %land.lhs.true36, label %if.end56

land.lhs.true36:                                  ; preds = %sw.bb34
  %29 = load i64, ptr %arg2.addr, align 8
  %cmp37 = icmp eq i64 %29, 0
  br i1 %cmp37, label %if.then39, label %if.end56

if.then39:                                        ; preds = %land.lhs.true36
  %30 = load ptr, ptr %s.addr, align 8
  %31 = load i32, ptr %rexw.addr, align 4
  %tobool40 = icmp ne i32 %31, 0
  %cond41 = select i1 %tobool40, i32 1, i32 0
  %32 = load i64, ptr %dest.addr, align 8
  %conv42 = trunc i64 %32 to i32
  %33 = load i64, ptr %arg1.addr, align 8
  %conv43 = trunc i64 %33 to i32
  %call = call zeroext i1 @tcg_out_mov(ptr noundef %30, i32 noundef %cond41, i32 noundef %conv42, i32 noundef %conv43)
  %34 = load i8, ptr %inv, align 1
  %tobool44 = trunc i8 %34 to i1
  br i1 %tobool44, label %if.then45, label %if.end48

if.then45:                                        ; preds = %if.then39
  %35 = load ptr, ptr %s.addr, align 8
  %36 = load i32, ptr %rexw.addr, align 4
  %add46 = add i32 247, %36
  %37 = load i64, ptr %dest.addr, align 8
  %conv47 = trunc i64 %37 to i32
  call void @tcg_out_modrm(ptr noundef %35, i32 noundef %add46, i32 noundef 2, i32 noundef %conv47)
  br label %if.end48

if.end48:                                         ; preds = %if.then45, %if.then39
  %38 = load ptr, ptr %s.addr, align 8
  %39 = load i8, ptr %neg.addr, align 1
  %tobool49 = trunc i8 %39 to i1
  %cond51 = select i1 %tobool49, i32 7, i32 5
  %40 = load i32, ptr %rexw.addr, align 4
  %add52 = add i32 %cond51, %40
  %41 = load i64, ptr %dest.addr, align 8
  %conv53 = trunc i64 %41 to i32
  %42 = load i32, ptr %rexw.addr, align 4
  %tobool54 = icmp ne i32 %42, 0
  %cond55 = select i1 %tobool54, i32 63, i32 31
  call void @tcg_out_shifti(ptr noundef %38, i32 noundef %add52, i32 noundef %conv53, i32 noundef %cond55)
  br label %if.end78

if.end56:                                         ; preds = %land.lhs.true36, %sw.bb34
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end56, %if.end7, %if.end
  store i8 0, ptr %cleared, align 1
  %43 = load i64, ptr %dest.addr, align 8
  %44 = load i64, ptr %arg1.addr, align 8
  %cmp57 = icmp ne i64 %43, %44
  br i1 %cmp57, label %land.lhs.true59, label %if.end66

land.lhs.true59:                                  ; preds = %sw.epilog
  %45 = load i32, ptr %const_arg2.addr, align 4
  %tobool60 = icmp ne i32 %45, 0
  br i1 %tobool60, label %if.then63, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true59
  %46 = load i64, ptr %dest.addr, align 8
  %47 = load i64, ptr %arg2.addr, align 8
  %cmp61 = icmp ne i64 %46, %47
  br i1 %cmp61, label %if.then63, label %if.end66

if.then63:                                        ; preds = %lor.lhs.false, %land.lhs.true59
  %48 = load ptr, ptr %s.addr, align 8
  %49 = load i64, ptr %dest.addr, align 8
  %conv64 = trunc i64 %49 to i32
  %50 = load i64, ptr %dest.addr, align 8
  %conv65 = trunc i64 %50 to i32
  call void @tgen_arithr(ptr noundef %48, i32 noundef 6, i32 noundef %conv64, i32 noundef %conv65)
  store i8 1, ptr %cleared, align 1
  br label %if.end66

if.end66:                                         ; preds = %if.then63, %lor.lhs.false, %sw.epilog
  %51 = load ptr, ptr %s.addr, align 8
  %52 = load i64, ptr %arg1.addr, align 8
  %53 = load i64, ptr %arg2.addr, align 8
  %54 = load i32, ptr %const_arg2.addr, align 4
  %55 = load i32, ptr %rexw.addr, align 4
  call void @tcg_out_cmp(ptr noundef %51, i64 noundef %52, i64 noundef %53, i32 noundef %54, i32 noundef %55)
  %56 = load ptr, ptr %s.addr, align 8
  %57 = load i32, ptr %cond.addr, align 4
  %idxprom = zext i32 %57 to i64
  %arrayidx = getelementptr [14 x i8], ptr @tcg_cond_to_jcc, i64 0, i64 %idxprom
  %58 = load i8, ptr %arrayidx, align 1
  %conv67 = zext i8 %58 to i32
  %or = or i32 16784, %conv67
  %59 = load i64, ptr %dest.addr, align 8
  %conv68 = trunc i64 %59 to i32
  call void @tcg_out_modrm(ptr noundef %56, i32 noundef %or, i32 noundef 0, i32 noundef %conv68)
  %60 = load i8, ptr %cleared, align 1
  %tobool69 = trunc i8 %60 to i1
  br i1 %tobool69, label %if.end73, label %if.then70

if.then70:                                        ; preds = %if.end66
  %61 = load ptr, ptr %s.addr, align 8
  %62 = load i64, ptr %dest.addr, align 8
  %conv71 = trunc i64 %62 to i32
  %63 = load i64, ptr %dest.addr, align 8
  %conv72 = trunc i64 %63 to i32
  call void @tcg_out_ext8u(ptr noundef %61, i32 noundef %conv71, i32 noundef %conv72)
  br label %if.end73

if.end73:                                         ; preds = %if.then70, %if.end66
  %64 = load i8, ptr %neg.addr, align 1
  %tobool74 = trunc i8 %64 to i1
  br i1 %tobool74, label %if.then75, label %if.end78

if.then75:                                        ; preds = %if.end73
  %65 = load ptr, ptr %s.addr, align 8
  %66 = load i32, ptr %rexw.addr, align 4
  %add76 = add i32 247, %66
  %67 = load i64, ptr %dest.addr, align 8
  %conv77 = trunc i64 %67 to i32
  call void @tcg_out_modrm(ptr noundef %65, i32 noundef %add76, i32 noundef 3, i32 noundef %conv77)
  br label %if.end78

if.end78:                                         ; preds = %if.then75, %if.end73, %if.end48, %if.end32
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_movcond(ptr noundef %s, i32 noundef %rexw, i32 noundef %cond, i32 noundef %dest, i32 noundef %c1, i64 noundef %c2, i32 noundef %const_c2, i32 noundef %v1) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %rexw.addr = alloca i32, align 4
  %cond.addr = alloca i32, align 4
  %dest.addr = alloca i32, align 4
  %c1.addr = alloca i32, align 4
  %c2.addr = alloca i64, align 8
  %const_c2.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %rexw, ptr %rexw.addr, align 4
  store i32 %cond, ptr %cond.addr, align 4
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %c1, ptr %c1.addr, align 4
  store i64 %c2, ptr %c2.addr, align 8
  store i32 %const_c2, ptr %const_c2.addr, align 4
  store i32 %v1, ptr %v1.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %c1.addr, align 4
  %conv = zext i32 %1 to i64
  %2 = load i64, ptr %c2.addr, align 8
  %3 = load i32, ptr %const_c2.addr, align 4
  %4 = load i32, ptr %rexw.addr, align 4
  call void @tcg_out_cmp(ptr noundef %0, i64 noundef %conv, i64 noundef %2, i32 noundef %3, i32 noundef %4)
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i32, ptr %cond.addr, align 4
  %7 = load i32, ptr %rexw.addr, align 4
  %8 = load i32, ptr %dest.addr, align 4
  %9 = load i32, ptr %v1.addr, align 4
  call void @tcg_out_cmov(ptr noundef %5, i32 noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_bswap64(ptr noundef %s, i32 noundef %reg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %reg.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %reg, ptr %reg.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %reg.addr, align 4
  %and = and i32 %1, 7
  %add = add i32 4552, %and
  %2 = load i32, ptr %reg.addr, align 4
  call void @tcg_out_opc(ptr noundef %0, i32 noundef %add, i32 noundef 0, i32 noundef %2, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_bswap32(ptr noundef %s, i32 noundef %reg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %reg.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %reg, ptr %reg.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %reg.addr, align 4
  %and = and i32 %1, 7
  %add = add i32 456, %and
  %2 = load i32, ptr %reg.addr, align 4
  call void @tcg_out_opc(ptr noundef %0, i32 noundef %add, i32 noundef 0, i32 noundef %2, i32 noundef 0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_rolw_8(ptr noundef %s, i32 noundef %reg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %reg.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %reg, ptr %reg.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %reg.addr, align 4
  call void @tcg_out_shifti(ptr noundef %0, i32 noundef 1024, i32 noundef %1, i32 noundef 8)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_qemu_ld(ptr noundef %s, i32 noundef %datalo, i32 noundef %datahi, i32 noundef %addrlo, i32 noundef %addrhi, i32 noundef %oi, i32 noundef %data_type) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %datalo.addr = alloca i32, align 4
  %datahi.addr = alloca i32, align 4
  %addrlo.addr = alloca i32, align 4
  %addrhi.addr = alloca i32, align 4
  %oi.addr = alloca i32, align 4
  %data_type.addr = alloca i32, align 4
  %ldst = alloca ptr, align 8
  %h = alloca %struct.HostAddress, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %datalo, ptr %datalo.addr, align 4
  store i32 %datahi, ptr %datahi.addr, align 4
  store i32 %addrlo, ptr %addrlo.addr, align 4
  store i32 %addrhi, ptr %addrhi.addr, align 4
  store i32 %oi, ptr %oi.addr, align 4
  store i32 %data_type, ptr %data_type.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %addrlo.addr, align 4
  %2 = load i32, ptr %addrhi.addr, align 4
  %3 = load i32, ptr %oi.addr, align 4
  %call = call ptr @prepare_host_addr(ptr noundef %0, ptr noundef %h, i32 noundef %1, i32 noundef %2, i32 noundef %3, i1 noundef zeroext true)
  store ptr %call, ptr %ldst, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load i32, ptr %datalo.addr, align 4
  %6 = load i32, ptr %datahi.addr, align 4
  %7 = load i32, ptr %data_type.addr, align 4
  %8 = load i32, ptr %oi.addr, align 4
  %call1 = call i32 @get_memop(i32 noundef %8)
  call void @tcg_out_qemu_ld_direct(ptr noundef %4, i32 noundef %5, i32 noundef %6, ptr noundef byval(%struct.HostAddress) align 8 %h, i32 noundef %7, i32 noundef %call1)
  %9 = load ptr, ptr %ldst, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i32, ptr %data_type.addr, align 4
  %11 = load ptr, ptr %ldst, align 8
  %type = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %11, i32 0, i32 2
  store i32 %10, ptr %type, align 8
  %12 = load i32, ptr %datalo.addr, align 4
  %13 = load ptr, ptr %ldst, align 8
  %datalo_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %13, i32 0, i32 5
  store i32 %12, ptr %datalo_reg, align 4
  %14 = load i32, ptr %datahi.addr, align 4
  %15 = load ptr, ptr %ldst, align 8
  %datahi_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %15, i32 0, i32 6
  store i32 %14, ptr %datahi_reg, align 8
  %16 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %16, i32 0, i32 23
  %17 = load ptr, ptr %code_ptr, align 8
  %call2 = call ptr @tcg_splitwx_to_rx(ptr noundef %17)
  %18 = load ptr, ptr %ldst, align 8
  %raddr = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %18, i32 0, i32 7
  store ptr %call2, ptr %raddr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_qemu_st(ptr noundef %s, i32 noundef %datalo, i32 noundef %datahi, i32 noundef %addrlo, i32 noundef %addrhi, i32 noundef %oi, i32 noundef %data_type) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %datalo.addr = alloca i32, align 4
  %datahi.addr = alloca i32, align 4
  %addrlo.addr = alloca i32, align 4
  %addrhi.addr = alloca i32, align 4
  %oi.addr = alloca i32, align 4
  %data_type.addr = alloca i32, align 4
  %ldst = alloca ptr, align 8
  %h = alloca %struct.HostAddress, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %datalo, ptr %datalo.addr, align 4
  store i32 %datahi, ptr %datahi.addr, align 4
  store i32 %addrlo, ptr %addrlo.addr, align 4
  store i32 %addrhi, ptr %addrhi.addr, align 4
  store i32 %oi, ptr %oi.addr, align 4
  store i32 %data_type, ptr %data_type.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %addrlo.addr, align 4
  %2 = load i32, ptr %addrhi.addr, align 4
  %3 = load i32, ptr %oi.addr, align 4
  %call = call ptr @prepare_host_addr(ptr noundef %0, ptr noundef %h, i32 noundef %1, i32 noundef %2, i32 noundef %3, i1 noundef zeroext false)
  store ptr %call, ptr %ldst, align 8
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load i32, ptr %datalo.addr, align 4
  %6 = load i32, ptr %datahi.addr, align 4
  %7 = load i32, ptr %oi.addr, align 4
  %call1 = call i32 @get_memop(i32 noundef %7)
  call void @tcg_out_qemu_st_direct(ptr noundef %4, i32 noundef %5, i32 noundef %6, ptr noundef byval(%struct.HostAddress) align 8 %h, i32 noundef %call1)
  %8 = load ptr, ptr %ldst, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load i32, ptr %data_type.addr, align 4
  %10 = load ptr, ptr %ldst, align 8
  %type = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %10, i32 0, i32 2
  store i32 %9, ptr %type, align 8
  %11 = load i32, ptr %datalo.addr, align 4
  %12 = load ptr, ptr %ldst, align 8
  %datalo_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %12, i32 0, i32 5
  store i32 %11, ptr %datalo_reg, align 4
  %13 = load i32, ptr %datahi.addr, align 4
  %14 = load ptr, ptr %ldst, align 8
  %datahi_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %14, i32 0, i32 6
  store i32 %13, ptr %datahi_reg, align 8
  %15 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %15, i32 0, i32 23
  %16 = load ptr, ptr %code_ptr, align 8
  %call2 = call ptr @tcg_splitwx_to_rx(ptr noundef %16)
  %17 = load ptr, ptr %ldst, align 8
  %raddr = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %17, i32 0, i32 7
  store ptr %call2, ptr %raddr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_mb(ptr noundef %s, i64 noundef %a0) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %a0.addr = alloca i64, align 8
  store ptr %s, ptr %s.addr, align 8
  store i64 %a0, ptr %a0.addr, align 8
  %0 = load i64, ptr %a0.addr, align 8
  %and = and i64 %0, 2
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %1, i8 noundef zeroext -16)
  %2 = load ptr, ptr %s.addr, align 8
  call void @tcg_out_modrm_offset(ptr noundef %2, i32 noundef 131, i32 noundef 1, i32 noundef 4, i64 noundef 0)
  %3 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %3, i8 noundef zeroext 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_reloc(ptr noundef %s, ptr noundef %code_ptr, i32 noundef %type, ptr noundef %l, i64 noundef %addend) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %code_ptr.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %l.addr = alloca ptr, align 8
  %addend.addr = alloca i64, align 8
  %r = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %code_ptr, ptr %code_ptr.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store ptr %l, ptr %l.addr, align 8
  store i64 %addend, ptr %addend.addr, align 8
  %call = call ptr @tcg_malloc(i32 noundef 32)
  store ptr %call, ptr %r, align 8
  %0 = load i32, ptr %type.addr, align 4
  %1 = load ptr, ptr %r, align 8
  %type1 = getelementptr inbounds %struct.TCGRelocation, ptr %1, i32 0, i32 3
  store i32 %0, ptr %type1, align 8
  %2 = load ptr, ptr %code_ptr.addr, align 8
  %3 = load ptr, ptr %r, align 8
  %ptr = getelementptr inbounds %struct.TCGRelocation, ptr %3, i32 0, i32 1
  store ptr %2, ptr %ptr, align 8
  %4 = load i64, ptr %addend.addr, align 8
  %5 = load ptr, ptr %r, align 8
  %addend2 = getelementptr inbounds %struct.TCGRelocation, ptr %5, i32 0, i32 2
  store i64 %4, ptr %addend2, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %6 = load ptr, ptr %r, align 8
  %next = getelementptr inbounds %struct.TCGRelocation, ptr %6, i32 0, i32 0
  %sqe_next = getelementptr inbounds %struct.anon.7, ptr %next, i32 0, i32 0
  store ptr null, ptr %sqe_next, align 8
  %7 = load ptr, ptr %r, align 8
  %8 = load ptr, ptr %l.addr, align 8
  %relocs = getelementptr inbounds %struct.TCGLabel, ptr %8, i32 0, i32 5
  %sqh_last = getelementptr inbounds %struct.anon.0, ptr %relocs, i32 0, i32 1
  %9 = load ptr, ptr %sqh_last, align 8
  store ptr %7, ptr %9, align 8
  %10 = load ptr, ptr %r, align 8
  %next3 = getelementptr inbounds %struct.TCGRelocation, ptr %10, i32 0, i32 0
  %sqe_next4 = getelementptr inbounds %struct.anon.7, ptr %next3, i32 0, i32 0
  %11 = load ptr, ptr %l.addr, align 8
  %relocs5 = getelementptr inbounds %struct.TCGLabel, ptr %11, i32 0, i32 5
  %sqh_last6 = getelementptr inbounds %struct.anon.0, ptr %relocs5, i32 0, i32 1
  store ptr %sqe_next4, ptr %sqh_last6, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_cmov(ptr noundef %s, i32 noundef %cond, i32 noundef %rexw, i32 noundef %dest, i32 noundef %v1) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %cond.addr = alloca i32, align 4
  %rexw.addr = alloca i32, align 4
  %dest.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %cond, ptr %cond.addr, align 4
  store i32 %rexw, ptr %rexw.addr, align 4
  store i32 %dest, ptr %dest.addr, align 4
  store i32 %v1, ptr %v1.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load i32, ptr %cond.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr [14 x i8], ptr @tcg_cond_to_jcc, i64 0, i64 %idxprom
  %2 = load i8, ptr %arrayidx, align 1
  %conv = zext i8 %2 to i32
  %or = or i32 320, %conv
  %3 = load i32, ptr %rexw.addr, align 4
  %or1 = or i32 %or, %3
  %4 = load i32, ptr %dest.addr, align 4
  %5 = load i32, ptr %v1.addr, align 4
  call void @tcg_out_modrm(ptr noundef %0, i32 noundef %or1, i32 noundef %4, i32 noundef %5)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_cmp(ptr noundef %s, i64 noundef %arg1, i64 noundef %arg2, i32 noundef %const_arg2, i32 noundef %rexw) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %const_arg2.addr = alloca i32, align 4
  %rexw.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i64 %arg1, ptr %arg1.addr, align 8
  store i64 %arg2, ptr %arg2.addr, align 8
  store i32 %const_arg2, ptr %const_arg2.addr, align 4
  store i32 %rexw, ptr %rexw.addr, align 4
  %0 = load i32, ptr %const_arg2.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else5

if.then:                                          ; preds = %entry
  %1 = load i64, ptr %arg2.addr, align 8
  %cmp = icmp eq i64 %1, 0
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.then
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load i32, ptr %rexw.addr, align 4
  %add = add i32 133, %3
  %4 = load i64, ptr %arg1.addr, align 8
  %conv = trunc i64 %4 to i32
  %5 = load i64, ptr %arg1.addr, align 8
  %conv2 = trunc i64 %5 to i32
  call void @tcg_out_modrm(ptr noundef %2, i32 noundef %add, i32 noundef %conv, i32 noundef %conv2)
  br label %if.end

if.else:                                          ; preds = %if.then
  %6 = load ptr, ptr %s.addr, align 8
  %7 = load i32, ptr %rexw.addr, align 4
  %add3 = add i32 7, %7
  %8 = load i64, ptr %arg1.addr, align 8
  %conv4 = trunc i64 %8 to i32
  %9 = load i64, ptr %arg2.addr, align 8
  call void @tgen_arithi(ptr noundef %6, i32 noundef %add3, i32 noundef %conv4, i64 noundef %9, i32 noundef 0)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then1
  br label %if.end9

if.else5:                                         ; preds = %entry
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load i32, ptr %rexw.addr, align 4
  %add6 = add i32 7, %11
  %12 = load i64, ptr %arg1.addr, align 8
  %conv7 = trunc i64 %12 to i32
  %13 = load i64, ptr %arg2.addr, align 8
  %conv8 = trunc i64 %13 to i32
  call void @tgen_arithr(ptr noundef %10, i32 noundef %add6, i32 noundef %conv7, i32 noundef %conv8)
  br label %if.end9

if.end9:                                          ; preds = %if.else5, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @prepare_host_addr(ptr noundef %s, ptr noundef %h, i32 noundef %addrlo, i32 noundef %addrhi, i32 noundef %oi, i1 noundef zeroext %is_ld) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %h.addr = alloca ptr, align 8
  %addrlo.addr = alloca i32, align 4
  %addrhi.addr = alloca i32, align 4
  %oi.addr = alloca i32, align 4
  %is_ld.addr = alloca i8, align 1
  %ldst = alloca ptr, align 8
  %opc = alloca i32, align 4
  %s_bits = alloca i32, align 4
  %a_mask = alloca i32, align 4
  %tmp = alloca %struct.TCGAtomAlign, align 4
  %cmp_ofs = alloca i32, align 4
  %ttype = alloca i32, align 4
  %tlbtype = alloca i32, align 4
  %trexw = alloca i32, align 4
  %hrexw = alloca i32, align 4
  %tlbrexw = alloca i32, align 4
  %mem_index = alloca i32, align 4
  %s_mask = alloca i32, align 4
  %fast_ofs = alloca i32, align 4
  %tlb_mask = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %h, ptr %h.addr, align 8
  store i32 %addrlo, ptr %addrlo.addr, align 4
  store i32 %addrhi, ptr %addrhi.addr, align 4
  store i32 %oi, ptr %oi.addr, align 4
  %frombool = zext i1 %is_ld to i8
  store i8 %frombool, ptr %is_ld.addr, align 1
  store ptr null, ptr %ldst, align 8
  %0 = load i32, ptr %oi.addr, align 4
  %call = call i32 @get_memop(i32 noundef %0)
  store i32 %call, ptr %opc, align 4
  %1 = load i32, ptr %opc, align 4
  %and = and i32 %1, 7
  store i32 %and, ptr %s_bits, align 4
  %2 = load i8, ptr @tcg_use_softmmu, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %4 = load ptr, ptr %h.addr, align 8
  %index = getelementptr inbounds %struct.HostAddress, ptr %4, i32 0, i32 1
  store i32 %3, ptr %index, align 4
  %5 = load ptr, ptr %h.addr, align 8
  %ofs = getelementptr inbounds %struct.HostAddress, ptr %5, i32 0, i32 2
  store i32 0, ptr %ofs, align 4
  %6 = load ptr, ptr %h.addr, align 8
  %seg = getelementptr inbounds %struct.HostAddress, ptr %6, i32 0, i32 3
  store i32 0, ptr %seg, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load ptr, ptr %h.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %7, ptr align 4 @x86_guest_base, i64 24, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %8 = load i32, ptr %addrlo.addr, align 4
  %9 = load ptr, ptr %h.addr, align 8
  %base = getelementptr inbounds %struct.HostAddress, ptr %9, i32 0, i32 0
  store i32 %8, ptr %base, align 4
  %10 = load ptr, ptr %h.addr, align 8
  %aa = getelementptr inbounds %struct.HostAddress, ptr %10, i32 0, i32 4
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load i32, ptr %opc, align 4
  %13 = load i32, ptr %s_bits, align 4
  %cmp = icmp eq i32 %13, 4
  %call1 = call i64 @atom_and_align_for_opc(ptr noundef %11, i32 noundef %12, i32 noundef 0, i1 noundef zeroext %cmp)
  store i64 %call1, ptr %tmp, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %aa, ptr align 4 %tmp, i64 8, i1 false)
  %14 = load ptr, ptr %h.addr, align 8
  %aa2 = getelementptr inbounds %struct.HostAddress, ptr %14, i32 0, i32 4
  %align = getelementptr inbounds %struct.TCGAtomAlign, ptr %aa2, i32 0, i32 1
  %15 = load i32, ptr %align, align 4
  %shl = shl i32 1, %15
  %sub = sub i32 %shl, 1
  store i32 %sub, ptr %a_mask, align 4
  %16 = load i8, ptr @tcg_use_softmmu, align 1
  %tobool3 = trunc i8 %16 to i1
  br i1 %tobool3, label %if.then4, label %if.else49

if.then4:                                         ; preds = %if.end
  %17 = load i8, ptr %is_ld.addr, align 1
  %tobool5 = trunc i8 %17 to i1
  %cond = select i1 %tobool5, i64 0, i64 8
  %conv = trunc i64 %cond to i32
  store i32 %conv, ptr %cmp_ofs, align 4
  store i32 0, ptr %ttype, align 4
  store i32 0, ptr %tlbtype, align 4
  store i32 0, ptr %trexw, align 4
  store i32 0, ptr %hrexw, align 4
  store i32 0, ptr %tlbrexw, align 4
  %18 = load i32, ptr %oi.addr, align 4
  %call6 = call i32 @get_mmuidx(i32 noundef %18)
  store i32 %call6, ptr %mem_index, align 4
  %19 = load i32, ptr %s_bits, align 4
  %shl7 = shl i32 1, %19
  %sub8 = sub i32 %shl7, 1
  store i32 %sub8, ptr %s_mask, align 4
  %20 = load ptr, ptr %s.addr, align 8
  %21 = load i32, ptr %mem_index, align 4
  %call9 = call i32 @tlb_mask_table_ofs(ptr noundef %20, i32 noundef %21)
  store i32 %call9, ptr %fast_ofs, align 4
  %22 = load ptr, ptr %s.addr, align 8
  %call10 = call ptr @new_ldst_label(ptr noundef %22)
  store ptr %call10, ptr %ldst, align 8
  %23 = load i8, ptr %is_ld.addr, align 1
  %tobool11 = trunc i8 %23 to i1
  %24 = load ptr, ptr %ldst, align 8
  %is_ld12 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %24, i32 0, i32 0
  %frombool13 = zext i1 %tobool11 to i8
  store i8 %frombool13, ptr %is_ld12, align 8
  %25 = load i32, ptr %oi.addr, align 4
  %26 = load ptr, ptr %ldst, align 8
  %oi14 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %26, i32 0, i32 1
  store i32 %25, ptr %oi14, align 4
  %27 = load i32, ptr %addrlo.addr, align 4
  %28 = load ptr, ptr %ldst, align 8
  %addrlo_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %28, i32 0, i32 3
  store i32 %27, ptr %addrlo_reg, align 4
  %29 = load i32, ptr %addrhi.addr, align 4
  %30 = load ptr, ptr %ldst, align 8
  %addrhi_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %30, i32 0, i32 4
  store i32 %29, ptr %addrhi_reg, align 8
  %31 = load ptr, ptr %s.addr, align 8
  %addr_type = getelementptr inbounds %struct.TCGContext, ptr %31, i32 0, i32 10
  %32 = load i32, ptr %addr_type, align 4
  store i32 %32, ptr %ttype, align 4
  %33 = load i32, ptr %ttype, align 4
  %cmp15 = icmp eq i32 %33, 0
  %cond17 = select i1 %cmp15, i32 0, i32 4096
  store i32 %cond17, ptr %trexw, align 4
  store i32 4096, ptr %hrexw, align 4
  %34 = load ptr, ptr %s.addr, align 8
  %page_bits = getelementptr inbounds %struct.TCGContext, ptr %34, i32 0, i32 12
  %35 = load i8, ptr %page_bits, align 4
  %conv18 = zext i8 %35 to i32
  %36 = load ptr, ptr %s.addr, align 8
  %tlb_dyn_max_bits = getelementptr inbounds %struct.TCGContext, ptr %36, i32 0, i32 13
  %37 = load i8, ptr %tlb_dyn_max_bits, align 1
  %conv19 = zext i8 %37 to i32
  %add = add i32 %conv18, %conv19
  %cmp20 = icmp sgt i32 %add, 32
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then4
  store i32 1, ptr %tlbtype, align 4
  store i32 4096, ptr %tlbrexw, align 4
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then4
  %38 = load ptr, ptr %s.addr, align 8
  %39 = load i32, ptr %tlbtype, align 4
  %40 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %41 = load i32, ptr %addrlo.addr, align 4
  %call24 = call zeroext i1 @tcg_out_mov(ptr noundef %38, i32 noundef %39, i32 noundef %40, i32 noundef %41)
  %42 = load ptr, ptr %s.addr, align 8
  %43 = load i32, ptr %tlbrexw, align 4
  %add25 = add i32 5, %43
  %44 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %45 = load ptr, ptr %s.addr, align 8
  %page_bits26 = getelementptr inbounds %struct.TCGContext, ptr %45, i32 0, i32 12
  %46 = load i8, ptr %page_bits26, align 4
  %conv27 = zext i8 %46 to i32
  %sub28 = sub i32 %conv27, 5
  call void @tcg_out_shifti(ptr noundef %42, i32 noundef %add25, i32 noundef %44, i32 noundef %sub28)
  %47 = load ptr, ptr %s.addr, align 8
  %48 = load i32, ptr %trexw, align 4
  %add29 = add i32 35, %48
  %49 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %50 = load i32, ptr %fast_ofs, align 4
  %conv30 = sext i32 %50 to i64
  %add31 = add i64 %conv30, 0
  call void @tcg_out_modrm_offset(ptr noundef %47, i32 noundef %add29, i32 noundef %49, i32 noundef 5, i64 noundef %add31)
  %51 = load ptr, ptr %s.addr, align 8
  %52 = load i32, ptr %hrexw, align 4
  %add32 = add i32 3, %52
  %53 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %54 = load i32, ptr %fast_ofs, align 4
  %conv33 = sext i32 %54 to i64
  %add34 = add i64 %conv33, 8
  call void @tcg_out_modrm_offset(ptr noundef %51, i32 noundef %add32, i32 noundef %53, i32 noundef 5, i64 noundef %add34)
  %55 = load i32, ptr %a_mask, align 4
  %56 = load i32, ptr %s_mask, align 4
  %cmp35 = icmp uge i32 %55, %56
  br i1 %cmp35, label %if.then37, label %if.else39

if.then37:                                        ; preds = %if.end23
  %57 = load ptr, ptr %s.addr, align 8
  %58 = load i32, ptr %ttype, align 4
  %59 = load i32, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 1), align 4
  %60 = load i32, ptr %addrlo.addr, align 4
  %call38 = call zeroext i1 @tcg_out_mov(ptr noundef %57, i32 noundef %58, i32 noundef %59, i32 noundef %60)
  br label %if.end43

if.else39:                                        ; preds = %if.end23
  %61 = load ptr, ptr %s.addr, align 8
  %62 = load i32, ptr %trexw, align 4
  %add40 = add i32 141, %62
  %63 = load i32, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 1), align 4
  %64 = load i32, ptr %addrlo.addr, align 4
  %65 = load i32, ptr %s_mask, align 4
  %66 = load i32, ptr %a_mask, align 4
  %sub41 = sub i32 %65, %66
  %conv42 = zext i32 %sub41 to i64
  call void @tcg_out_modrm_offset(ptr noundef %61, i32 noundef %add40, i32 noundef %63, i32 noundef %64, i64 noundef %conv42)
  br label %if.end43

if.end43:                                         ; preds = %if.else39, %if.then37
  %67 = load ptr, ptr %s.addr, align 8
  %page_mask = getelementptr inbounds %struct.TCGContext, ptr %67, i32 0, i32 11
  %68 = load i32, ptr %page_mask, align 8
  %69 = load i32, ptr %a_mask, align 4
  %or = or i32 %68, %69
  store i32 %or, ptr %tlb_mask, align 4
  %70 = load ptr, ptr %s.addr, align 8
  %71 = load i32, ptr %trexw, align 4
  %add44 = add i32 4, %71
  %72 = load i32, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 1), align 4
  %73 = load i32, ptr %tlb_mask, align 4
  %conv45 = sext i32 %73 to i64
  call void @tgen_arithi(ptr noundef %70, i32 noundef %add44, i32 noundef %72, i64 noundef %conv45, i32 noundef 0)
  %74 = load ptr, ptr %s.addr, align 8
  %75 = load i32, ptr %trexw, align 4
  %add46 = add i32 59, %75
  %76 = load i32, ptr getelementptr inbounds ([6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 1), align 4
  %77 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %78 = load i32, ptr %cmp_ofs, align 4
  %conv47 = sext i32 %78 to i64
  call void @tcg_out_modrm_offset(ptr noundef %74, i32 noundef %add46, i32 noundef %76, i32 noundef %77, i64 noundef %conv47)
  %79 = load ptr, ptr %s.addr, align 8
  call void @tcg_out_opc(ptr noundef %79, i32 noundef 389, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  %80 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %80, i32 0, i32 23
  %81 = load ptr, ptr %code_ptr, align 8
  %82 = load ptr, ptr %ldst, align 8
  %label_ptr = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %82, i32 0, i32 8
  %arrayidx = getelementptr [2 x ptr], ptr %label_ptr, i64 0, i64 0
  store ptr %81, ptr %arrayidx, align 8
  %83 = load ptr, ptr %s.addr, align 8
  %code_ptr48 = getelementptr inbounds %struct.TCGContext, ptr %83, i32 0, i32 23
  %84 = load ptr, ptr %code_ptr48, align 8
  %add.ptr = getelementptr i8, ptr %84, i64 4
  store ptr %add.ptr, ptr %code_ptr48, align 8
  %85 = load ptr, ptr %s.addr, align 8
  %86 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %87 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  call void @tcg_out_ld(ptr noundef %85, i32 noundef 1, i32 noundef %86, i32 noundef %87, i64 noundef 24)
  br label %if.end65

if.else49:                                        ; preds = %if.end
  %88 = load i32, ptr %a_mask, align 4
  %tobool50 = icmp ne i32 %88, 0
  br i1 %tobool50, label %if.then51, label %if.end64

if.then51:                                        ; preds = %if.else49
  %89 = load ptr, ptr %s.addr, align 8
  %call52 = call ptr @new_ldst_label(ptr noundef %89)
  store ptr %call52, ptr %ldst, align 8
  %90 = load i8, ptr %is_ld.addr, align 1
  %tobool53 = trunc i8 %90 to i1
  %91 = load ptr, ptr %ldst, align 8
  %is_ld54 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %91, i32 0, i32 0
  %frombool55 = zext i1 %tobool53 to i8
  store i8 %frombool55, ptr %is_ld54, align 8
  %92 = load i32, ptr %oi.addr, align 4
  %93 = load ptr, ptr %ldst, align 8
  %oi56 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %93, i32 0, i32 1
  store i32 %92, ptr %oi56, align 4
  %94 = load i32, ptr %addrlo.addr, align 4
  %95 = load ptr, ptr %ldst, align 8
  %addrlo_reg57 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %95, i32 0, i32 3
  store i32 %94, ptr %addrlo_reg57, align 4
  %96 = load i32, ptr %addrhi.addr, align 4
  %97 = load ptr, ptr %ldst, align 8
  %addrhi_reg58 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %97, i32 0, i32 4
  store i32 %96, ptr %addrhi_reg58, align 8
  %98 = load ptr, ptr %s.addr, align 8
  %99 = load i32, ptr %addrlo.addr, align 4
  %100 = load i32, ptr %a_mask, align 4
  call void @tcg_out_testi(ptr noundef %98, i32 noundef %99, i32 noundef %100)
  %101 = load ptr, ptr %s.addr, align 8
  call void @tcg_out_opc(ptr noundef %101, i32 noundef 389, i32 noundef 0, i32 noundef 0, i32 noundef 0)
  %102 = load ptr, ptr %s.addr, align 8
  %code_ptr59 = getelementptr inbounds %struct.TCGContext, ptr %102, i32 0, i32 23
  %103 = load ptr, ptr %code_ptr59, align 8
  %104 = load ptr, ptr %ldst, align 8
  %label_ptr60 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %104, i32 0, i32 8
  %arrayidx61 = getelementptr [2 x ptr], ptr %label_ptr60, i64 0, i64 0
  store ptr %103, ptr %arrayidx61, align 8
  %105 = load ptr, ptr %s.addr, align 8
  %code_ptr62 = getelementptr inbounds %struct.TCGContext, ptr %105, i32 0, i32 23
  %106 = load ptr, ptr %code_ptr62, align 8
  %add.ptr63 = getelementptr i8, ptr %106, i64 4
  store ptr %add.ptr63, ptr %code_ptr62, align 8
  br label %if.end64

if.end64:                                         ; preds = %if.then51, %if.else49
  br label %if.end65

if.end65:                                         ; preds = %if.end64, %if.end43
  %107 = load ptr, ptr %ldst, align 8
  ret ptr %107
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_qemu_ld_direct(ptr noundef %s, i32 noundef %datalo, i32 noundef %datahi, ptr noundef byval(%struct.HostAddress) align 8 %h, i32 noundef %type, i32 noundef %memop) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %datalo.addr = alloca i32, align 4
  %datahi.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %memop.addr = alloca i32, align 4
  %use_movbe = alloca i8, align 1
  %rexw = alloca i32, align 4
  %movop = alloca i32, align 4
  %t = alloca i32, align 4
  %l1 = alloca ptr, align 8
  %l2 = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %datalo, ptr %datalo.addr, align 4
  store i32 %datahi, ptr %datahi.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  store i32 %memop, ptr %memop.addr, align 4
  store i8 0, ptr %use_movbe, align 1
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %0, 0
  %cond = select i1 %cmp, i32 0, i32 4096
  store i32 %cond, ptr %rexw, align 4
  store i32 139, ptr %movop, align 4
  %1 = load i32, ptr %memop.addr, align 4
  %and = and i32 %1, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load i32, ptr @cpuinfo, align 4
  %and1 = and i32 %2, 4
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.end, label %if.then3

if.then3:                                         ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  store i8 1, ptr %use_movbe, align 1
  store i32 752, ptr %movop, align 4
  br label %if.end4

if.end4:                                          ; preds = %do.end, %entry
  %3 = load i32, ptr %memop.addr, align 4
  %and5 = and i32 %3, 15
  switch i32 %and5, label %sw.default [
    i32 0, label %sw.bb
    i32 8, label %sw.bb6
    i32 1, label %sw.bb14
    i32 9, label %sw.bb45
    i32 2, label %sw.bb63
    i32 10, label %sw.bb70
    i32 3, label %sw.bb87
    i32 4, label %sw.bb95
  ]

sw.bb:                                            ; preds = %if.end4
  %4 = load ptr, ptr %s.addr, align 8
  %seg = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %5 = load i32, ptr %seg, align 4
  %add = add i32 438, %5
  %6 = load i32, ptr %datalo.addr, align 4
  %base = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %7 = load i32, ptr %base, align 8
  %index = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %8 = load i32, ptr %index, align 4
  %ofs = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %9 = load i32, ptr %ofs, align 8
  %conv = sext i32 %9 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %4, i32 noundef %add, i32 noundef %6, i32 noundef %7, i32 noundef %8, i32 noundef 0, i64 noundef %conv)
  br label %sw.epilog

sw.bb6:                                           ; preds = %if.end4
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load i32, ptr %rexw, align 4
  %add7 = add i32 446, %11
  %seg8 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %12 = load i32, ptr %seg8, align 4
  %add9 = add i32 %add7, %12
  %13 = load i32, ptr %datalo.addr, align 4
  %base10 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %14 = load i32, ptr %base10, align 8
  %index11 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %15 = load i32, ptr %index11, align 4
  %ofs12 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %16 = load i32, ptr %ofs12, align 8
  %conv13 = sext i32 %16 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %10, i32 noundef %add9, i32 noundef %13, i32 noundef %14, i32 noundef %15, i32 noundef 0, i64 noundef %conv13)
  br label %sw.epilog

sw.bb14:                                          ; preds = %if.end4
  %17 = load i8, ptr %use_movbe, align 1
  %tobool15 = trunc i8 %17 to i1
  br i1 %tobool15, label %if.then16, label %if.else37

if.then16:                                        ; preds = %sw.bb14
  %18 = load i32, ptr %datalo.addr, align 4
  %base17 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %19 = load i32, ptr %base17, align 8
  %cmp18 = icmp ne i32 %18, %19
  br i1 %cmp18, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then16
  %20 = load i32, ptr %datalo.addr, align 4
  %index20 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %21 = load i32, ptr %index20, align 4
  %cmp21 = icmp ne i32 %20, %21
  br i1 %cmp21, label %if.then23, label %if.else

if.then23:                                        ; preds = %land.lhs.true
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load i32, ptr %datalo.addr, align 4
  %24 = load i32, ptr %datalo.addr, align 4
  call void @tgen_arithr(ptr noundef %22, i32 noundef 6, i32 noundef %23, i32 noundef %24)
  %25 = load ptr, ptr %s.addr, align 8
  %seg24 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %26 = load i32, ptr %seg24, align 4
  %add25 = add i32 1776, %26
  %27 = load i32, ptr %datalo.addr, align 4
  %base26 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %28 = load i32, ptr %base26, align 8
  %index27 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %29 = load i32, ptr %index27, align 4
  %ofs28 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %30 = load i32, ptr %ofs28, align 8
  %conv29 = sext i32 %30 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %25, i32 noundef %add25, i32 noundef %27, i32 noundef %28, i32 noundef %29, i32 noundef 0, i64 noundef %conv29)
  br label %if.end36

if.else:                                          ; preds = %land.lhs.true, %if.then16
  %31 = load ptr, ptr %s.addr, align 8
  %seg30 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %32 = load i32, ptr %seg30, align 4
  %add31 = add i32 1776, %32
  %33 = load i32, ptr %datalo.addr, align 4
  %base32 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %34 = load i32, ptr %base32, align 8
  %index33 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %35 = load i32, ptr %index33, align 4
  %ofs34 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %36 = load i32, ptr %ofs34, align 8
  %conv35 = sext i32 %36 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %31, i32 noundef %add31, i32 noundef %33, i32 noundef %34, i32 noundef %35, i32 noundef 0, i64 noundef %conv35)
  %37 = load ptr, ptr %s.addr, align 8
  %38 = load i32, ptr %datalo.addr, align 4
  %39 = load i32, ptr %datalo.addr, align 4
  call void @tcg_out_ext16u(ptr noundef %37, i32 noundef %38, i32 noundef %39)
  br label %if.end36

if.end36:                                         ; preds = %if.else, %if.then23
  br label %if.end44

if.else37:                                        ; preds = %sw.bb14
  %40 = load ptr, ptr %s.addr, align 8
  %seg38 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %41 = load i32, ptr %seg38, align 4
  %add39 = add i32 439, %41
  %42 = load i32, ptr %datalo.addr, align 4
  %base40 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %43 = load i32, ptr %base40, align 8
  %index41 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %44 = load i32, ptr %index41, align 4
  %ofs42 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %45 = load i32, ptr %ofs42, align 8
  %conv43 = sext i32 %45 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %40, i32 noundef %add39, i32 noundef %42, i32 noundef %43, i32 noundef %44, i32 noundef 0, i64 noundef %conv43)
  br label %if.end44

if.end44:                                         ; preds = %if.else37, %if.end36
  br label %sw.epilog

sw.bb45:                                          ; preds = %if.end4
  %46 = load i8, ptr %use_movbe, align 1
  %tobool46 = trunc i8 %46 to i1
  br i1 %tobool46, label %if.then47, label %if.else54

if.then47:                                        ; preds = %sw.bb45
  %47 = load ptr, ptr %s.addr, align 8
  %seg48 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %48 = load i32, ptr %seg48, align 4
  %add49 = add i32 1776, %48
  %49 = load i32, ptr %datalo.addr, align 4
  %base50 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %50 = load i32, ptr %base50, align 8
  %index51 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %51 = load i32, ptr %index51, align 4
  %ofs52 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %52 = load i32, ptr %ofs52, align 8
  %conv53 = sext i32 %52 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %47, i32 noundef %add49, i32 noundef %49, i32 noundef %50, i32 noundef %51, i32 noundef 0, i64 noundef %conv53)
  %53 = load ptr, ptr %s.addr, align 8
  %54 = load i32, ptr %type.addr, align 4
  %55 = load i32, ptr %datalo.addr, align 4
  %56 = load i32, ptr %datalo.addr, align 4
  call void @tcg_out_ext16s(ptr noundef %53, i32 noundef %54, i32 noundef %55, i32 noundef %56)
  br label %if.end62

if.else54:                                        ; preds = %sw.bb45
  %57 = load ptr, ptr %s.addr, align 8
  %58 = load i32, ptr %rexw, align 4
  %add55 = add i32 447, %58
  %seg56 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %59 = load i32, ptr %seg56, align 4
  %add57 = add i32 %add55, %59
  %60 = load i32, ptr %datalo.addr, align 4
  %base58 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %61 = load i32, ptr %base58, align 8
  %index59 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %62 = load i32, ptr %index59, align 4
  %ofs60 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %63 = load i32, ptr %ofs60, align 8
  %conv61 = sext i32 %63 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %57, i32 noundef %add57, i32 noundef %60, i32 noundef %61, i32 noundef %62, i32 noundef 0, i64 noundef %conv61)
  br label %if.end62

if.end62:                                         ; preds = %if.else54, %if.then47
  br label %sw.epilog

sw.bb63:                                          ; preds = %if.end4
  %64 = load ptr, ptr %s.addr, align 8
  %65 = load i32, ptr %movop, align 4
  %seg64 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %66 = load i32, ptr %seg64, align 4
  %add65 = add i32 %65, %66
  %67 = load i32, ptr %datalo.addr, align 4
  %base66 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %68 = load i32, ptr %base66, align 8
  %index67 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %69 = load i32, ptr %index67, align 4
  %ofs68 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %70 = load i32, ptr %ofs68, align 8
  %conv69 = sext i32 %70 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %64, i32 noundef %add65, i32 noundef %67, i32 noundef %68, i32 noundef %69, i32 noundef 0, i64 noundef %conv69)
  br label %sw.epilog

sw.bb70:                                          ; preds = %if.end4
  %71 = load i8, ptr %use_movbe, align 1
  %tobool71 = trunc i8 %71 to i1
  br i1 %tobool71, label %if.then72, label %if.else79

if.then72:                                        ; preds = %sw.bb70
  %72 = load ptr, ptr %s.addr, align 8
  %seg73 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %73 = load i32, ptr %seg73, align 4
  %add74 = add i32 752, %73
  %74 = load i32, ptr %datalo.addr, align 4
  %base75 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %75 = load i32, ptr %base75, align 8
  %index76 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %76 = load i32, ptr %index76, align 4
  %ofs77 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %77 = load i32, ptr %ofs77, align 8
  %conv78 = sext i32 %77 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %72, i32 noundef %add74, i32 noundef %74, i32 noundef %75, i32 noundef %76, i32 noundef 0, i64 noundef %conv78)
  %78 = load ptr, ptr %s.addr, align 8
  %79 = load i32, ptr %datalo.addr, align 4
  %80 = load i32, ptr %datalo.addr, align 4
  call void @tcg_out_ext32s(ptr noundef %78, i32 noundef %79, i32 noundef %80)
  br label %if.end86

if.else79:                                        ; preds = %sw.bb70
  %81 = load ptr, ptr %s.addr, align 8
  %seg80 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %82 = load i32, ptr %seg80, align 4
  %add81 = add i32 4195, %82
  %83 = load i32, ptr %datalo.addr, align 4
  %base82 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %84 = load i32, ptr %base82, align 8
  %index83 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %85 = load i32, ptr %index83, align 4
  %ofs84 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %86 = load i32, ptr %ofs84, align 8
  %conv85 = sext i32 %86 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %81, i32 noundef %add81, i32 noundef %83, i32 noundef %84, i32 noundef %85, i32 noundef 0, i64 noundef %conv85)
  br label %if.end86

if.end86:                                         ; preds = %if.else79, %if.then72
  br label %sw.epilog

sw.bb87:                                          ; preds = %if.end4
  %87 = load ptr, ptr %s.addr, align 8
  %88 = load i32, ptr %movop, align 4
  %add88 = add i32 %88, 4096
  %seg89 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %89 = load i32, ptr %seg89, align 4
  %add90 = add i32 %add88, %89
  %90 = load i32, ptr %datalo.addr, align 4
  %base91 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %91 = load i32, ptr %base91, align 8
  %index92 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %92 = load i32, ptr %index92, align 4
  %ofs93 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %93 = load i32, ptr %ofs93, align 8
  %conv94 = sext i32 %93 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %87, i32 noundef %add90, i32 noundef %90, i32 noundef %91, i32 noundef %92, i32 noundef 0, i64 noundef %conv94)
  br label %sw.epilog

sw.bb95:                                          ; preds = %if.end4
  br label %do.body96

do.body96:                                        ; preds = %sw.bb95
  br label %do.end97

do.end97:                                         ; preds = %do.body96
  %aa = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 4
  %atom = getelementptr inbounds %struct.TCGAtomAlign, ptr %aa, i32 0, i32 0
  %94 = load i32, ptr %atom, align 8
  %cmp98 = icmp ult i32 %94, 4
  br i1 %cmp98, label %if.then100, label %if.end138

if.then100:                                       ; preds = %do.end97
  %95 = load i8, ptr %use_movbe, align 1
  %tobool101 = trunc i8 %95 to i1
  br i1 %tobool101, label %if.then102, label %if.end103

if.then102:                                       ; preds = %if.then100
  %96 = load i32, ptr %datalo.addr, align 4
  store i32 %96, ptr %t, align 4
  %97 = load i32, ptr %datahi.addr, align 4
  store i32 %97, ptr %datalo.addr, align 4
  %98 = load i32, ptr %t, align 4
  store i32 %98, ptr %datahi.addr, align 4
  br label %if.end103

if.end103:                                        ; preds = %if.then102, %if.then100
  %base104 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %99 = load i32, ptr %base104, align 8
  %100 = load i32, ptr %datalo.addr, align 4
  %cmp105 = icmp eq i32 %99, %100
  br i1 %cmp105, label %if.then110, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end103
  %index107 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %101 = load i32, ptr %index107, align 4
  %102 = load i32, ptr %datalo.addr, align 4
  %cmp108 = icmp eq i32 %101, %102
  br i1 %cmp108, label %if.then110, label %if.else121

if.then110:                                       ; preds = %lor.lhs.false, %if.end103
  %103 = load ptr, ptr %s.addr, align 8
  %104 = load i32, ptr %datahi.addr, align 4
  %base111 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %105 = load i32, ptr %base111, align 8
  %index112 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %106 = load i32, ptr %index112, align 4
  %ofs113 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %107 = load i32, ptr %ofs113, align 8
  %conv114 = sext i32 %107 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %103, i32 noundef 4237, i32 noundef %104, i32 noundef %105, i32 noundef %106, i32 noundef 0, i64 noundef %conv114)
  %108 = load ptr, ptr %s.addr, align 8
  %109 = load i32, ptr %movop, align 4
  %add115 = add i32 %109, 4096
  %seg116 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %110 = load i32, ptr %seg116, align 4
  %add117 = add i32 %add115, %110
  %111 = load i32, ptr %datalo.addr, align 4
  %112 = load i32, ptr %datahi.addr, align 4
  call void @tcg_out_modrm_offset(ptr noundef %108, i32 noundef %add117, i32 noundef %111, i32 noundef %112, i64 noundef 0)
  %113 = load ptr, ptr %s.addr, align 8
  %114 = load i32, ptr %movop, align 4
  %add118 = add i32 %114, 4096
  %seg119 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %115 = load i32, ptr %seg119, align 4
  %add120 = add i32 %add118, %115
  %116 = load i32, ptr %datahi.addr, align 4
  %117 = load i32, ptr %datahi.addr, align 4
  call void @tcg_out_modrm_offset(ptr noundef %113, i32 noundef %add120, i32 noundef %116, i32 noundef %117, i64 noundef 8)
  br label %if.end137

if.else121:                                       ; preds = %lor.lhs.false
  %118 = load ptr, ptr %s.addr, align 8
  %119 = load i32, ptr %movop, align 4
  %add122 = add i32 %119, 4096
  %seg123 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %120 = load i32, ptr %seg123, align 4
  %add124 = add i32 %add122, %120
  %121 = load i32, ptr %datalo.addr, align 4
  %base125 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %122 = load i32, ptr %base125, align 8
  %index126 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %123 = load i32, ptr %index126, align 4
  %ofs127 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %124 = load i32, ptr %ofs127, align 8
  %conv128 = sext i32 %124 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %118, i32 noundef %add124, i32 noundef %121, i32 noundef %122, i32 noundef %123, i32 noundef 0, i64 noundef %conv128)
  %125 = load ptr, ptr %s.addr, align 8
  %126 = load i32, ptr %movop, align 4
  %add129 = add i32 %126, 4096
  %seg130 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %127 = load i32, ptr %seg130, align 4
  %add131 = add i32 %add129, %127
  %128 = load i32, ptr %datahi.addr, align 4
  %base132 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %129 = load i32, ptr %base132, align 8
  %index133 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %130 = load i32, ptr %index133, align 4
  %ofs134 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %131 = load i32, ptr %ofs134, align 8
  %add135 = add i32 %131, 8
  %conv136 = sext i32 %add135 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %125, i32 noundef %add131, i32 noundef %128, i32 noundef %129, i32 noundef %130, i32 noundef 0, i64 noundef %conv136)
  br label %if.end137

if.end137:                                        ; preds = %if.else121, %if.then110
  br label %sw.epilog

if.end138:                                        ; preds = %do.end97
  %aa139 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 4
  %align = getelementptr inbounds %struct.TCGAtomAlign, ptr %aa139, i32 0, i32 1
  %132 = load i32, ptr %align, align 4
  %cmp140 = icmp uge i32 %132, 4
  br i1 %cmp140, label %if.then142, label %if.else149

if.then142:                                       ; preds = %if.end138
  %133 = load ptr, ptr %s.addr, align 8
  %seg143 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %134 = load i32, ptr %seg143, align 4
  %add144 = add i32 1391, %134
  %base145 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %135 = load i32, ptr %base145, align 8
  %index146 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %136 = load i32, ptr %index146, align 4
  %ofs147 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %137 = load i32, ptr %ofs147, align 8
  %conv148 = sext i32 %137 to i64
  call void @tcg_out_vex_modrm_sib_offset(ptr noundef %133, i32 noundef %add144, i32 noundef 21, i32 noundef 0, i32 noundef %135, i32 noundef %136, i32 noundef 0, i64 noundef %conv148)
  br label %if.end175

if.else149:                                       ; preds = %if.end138
  %138 = load i32, ptr @cpuinfo, align 4
  %and150 = and i32 %138, 131072
  %tobool151 = icmp ne i32 %and150, 0
  br i1 %tobool151, label %if.then152, label %if.else159

if.then152:                                       ; preds = %if.else149
  %139 = load ptr, ptr %s.addr, align 8
  %seg153 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %140 = load i32, ptr %seg153, align 4
  %add154 = add i32 131439, %140
  %base155 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %141 = load i32, ptr %base155, align 8
  %index156 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %142 = load i32, ptr %index156, align 4
  %ofs157 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %143 = load i32, ptr %ofs157, align 8
  %conv158 = sext i32 %143 to i64
  call void @tcg_out_vex_modrm_sib_offset(ptr noundef %139, i32 noundef %add154, i32 noundef 21, i32 noundef 0, i32 noundef %141, i32 noundef %142, i32 noundef 0, i64 noundef %conv158)
  br label %if.end174

if.else159:                                       ; preds = %if.else149
  %call = call ptr @gen_new_label()
  store ptr %call, ptr %l1, align 8
  %call160 = call ptr @gen_new_label()
  store ptr %call160, ptr %l2, align 8
  %144 = load ptr, ptr %s.addr, align 8
  %base161 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %145 = load i32, ptr %base161, align 8
  call void @tcg_out_testi(ptr noundef %144, i32 noundef %145, i32 noundef 15)
  %146 = load ptr, ptr %s.addr, align 8
  %147 = load ptr, ptr %l1, align 8
  call void @tcg_out_jxx(ptr noundef %146, i32 noundef 5, ptr noundef %147, i1 noundef zeroext true)
  %148 = load ptr, ptr %s.addr, align 8
  %seg162 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %149 = load i32, ptr %seg162, align 4
  %add163 = add i32 1391, %149
  %base164 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %150 = load i32, ptr %base164, align 8
  %index165 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %151 = load i32, ptr %index165, align 4
  %ofs166 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %152 = load i32, ptr %ofs166, align 8
  %conv167 = sext i32 %152 to i64
  call void @tcg_out_vex_modrm_sib_offset(ptr noundef %148, i32 noundef %add163, i32 noundef 21, i32 noundef 0, i32 noundef %150, i32 noundef %151, i32 noundef 0, i64 noundef %conv167)
  %153 = load ptr, ptr %s.addr, align 8
  %154 = load ptr, ptr %l2, align 8
  call void @tcg_out_jxx(ptr noundef %153, i32 noundef -1, ptr noundef %154, i1 noundef zeroext true)
  %155 = load ptr, ptr %s.addr, align 8
  %156 = load ptr, ptr %l1, align 8
  call void @tcg_out_label(ptr noundef %155, ptr noundef %156)
  %157 = load ptr, ptr %s.addr, align 8
  %seg168 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %158 = load i32, ptr %seg168, align 4
  %add169 = add i32 131439, %158
  %base170 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %159 = load i32, ptr %base170, align 8
  %index171 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %160 = load i32, ptr %index171, align 4
  %ofs172 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %161 = load i32, ptr %ofs172, align 8
  %conv173 = sext i32 %161 to i64
  call void @tcg_out_vex_modrm_sib_offset(ptr noundef %157, i32 noundef %add169, i32 noundef 21, i32 noundef 0, i32 noundef %159, i32 noundef %160, i32 noundef 0, i64 noundef %conv173)
  %162 = load ptr, ptr %s.addr, align 8
  %163 = load ptr, ptr %l2, align 8
  call void @tcg_out_label(ptr noundef %162, ptr noundef %163)
  br label %if.end174

if.end174:                                        ; preds = %if.else159, %if.then152
  br label %if.end175

if.end175:                                        ; preds = %if.end174, %if.then142
  %164 = load ptr, ptr %s.addr, align 8
  %165 = load i32, ptr %datalo.addr, align 4
  %166 = load i32, ptr %datahi.addr, align 4
  call void @tcg_out_vec_to_pair(ptr noundef %164, i32 noundef 1, i32 noundef %165, i32 noundef %166, i32 noundef 21)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end4
  br label %do.body176

do.body176:                                       ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 2248, ptr noundef @__func__.tcg_out_qemu_ld_direct, ptr noundef null) #15
  unreachable

do.end177:                                        ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end177, %if.end175, %if.end137, %sw.bb87, %if.end86, %sw.bb63, %if.end62, %if.end44, %sw.bb6, %sw.bb
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tlb_mask_table_ofs(ptr noundef %s, i32 noundef %which) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %which.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %which, ptr %which.addr, align 4
  %0 = load i32, ptr %which.addr, align 4
  %conv = sext i32 %0 to i64
  %1 = mul i64 %conv, 16
  %2 = add i64 9120, %1
  %sub = sub i64 %2, 9392
  %conv1 = trunc i64 %sub to i32
  ret i32 %conv1
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @new_ldst_label(ptr noundef %s) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %l = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  %call = call ptr @tcg_malloc(i32 noundef 64)
  store ptr %call, ptr %l, align 8
  %0 = load ptr, ptr %l, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %0, i8 0, i64 64, i1 false)
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load ptr, ptr %l, align 8
  %next = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %1, i32 0, i32 9
  %sqe_next = getelementptr inbounds %struct.anon.8, ptr %next, i32 0, i32 0
  store ptr null, ptr %sqe_next, align 8
  %2 = load ptr, ptr %l, align 8
  %3 = load ptr, ptr %s.addr, align 8
  %ldst_labels = getelementptr inbounds %struct.TCGContext, ptr %3, i32 0, i32 30
  %sqh_last = getelementptr inbounds %struct.anon.2, ptr %ldst_labels, i32 0, i32 1
  %4 = load ptr, ptr %sqh_last, align 8
  store ptr %2, ptr %4, align 8
  %5 = load ptr, ptr %l, align 8
  %next1 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %5, i32 0, i32 9
  %sqe_next2 = getelementptr inbounds %struct.anon.8, ptr %next1, i32 0, i32 0
  %6 = load ptr, ptr %s.addr, align 8
  %ldst_labels3 = getelementptr inbounds %struct.TCGContext, ptr %6, i32 0, i32 30
  %sqh_last4 = getelementptr inbounds %struct.anon.2, ptr %ldst_labels3, i32 0, i32 1
  store ptr %sqe_next2, ptr %sqh_last4, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %7 = load ptr, ptr %l, align 8
  ret ptr %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_testi(ptr noundef %s, i32 noundef %r, i32 noundef %i) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %r.addr = alloca i32, align 4
  %i.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %r, ptr %r.addr, align 4
  store i32 %i, ptr %i.addr, align 4
  %0 = load i32, ptr %i.addr, align 4
  %cmp = icmp ule i32 %0, 255
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %r.addr, align 4
  call void @tcg_out_modrm(ptr noundef %1, i32 noundef 16630, i32 noundef 0, i32 noundef %2)
  %3 = load ptr, ptr %s.addr, align 8
  %4 = load i32, ptr %i.addr, align 4
  %conv = trunc i32 %4 to i8
  call void @tcg_out8(ptr noundef %3, i8 noundef zeroext %conv)
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i32, ptr %r.addr, align 4
  call void @tcg_out_modrm(ptr noundef %5, i32 noundef 247, i32 noundef 0, i32 noundef %6)
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load i32, ptr %i.addr, align 4
  call void @tcg_out32(ptr noundef %7, i32 noundef %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_vec_to_pair(ptr noundef %s, i32 noundef %type, i32 noundef %l, i32 noundef %h, i32 noundef %v) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %l.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %v.addr = alloca i32, align 4
  %rexw = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %l, ptr %l.addr, align 4
  store i32 %h, ptr %h.addr, align 4
  store i32 %v, ptr %v.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %0, 0
  %cond = select i1 %cmp, i32 0, i32 4096
  store i32 %cond, ptr %rexw, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %rexw, align 4
  %add = add i32 1406, %2
  %3 = load i32, ptr %v.addr, align 4
  %4 = load i32, ptr %l.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %1, i32 noundef %add, i32 noundef %3, i32 noundef 0, i32 noundef %4)
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i32, ptr %rexw, align 4
  %add1 = add i32 66582, %6
  %7 = load i32, ptr %v.addr, align 4
  %8 = load i32, ptr %h.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %5, i32 noundef %add1, i32 noundef %7, i32 noundef 0, i32 noundef %8)
  %9 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %9, i8 noundef zeroext 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_qemu_st_direct(ptr noundef %s, i32 noundef %datalo, i32 noundef %datahi, ptr noundef byval(%struct.HostAddress) align 8 %h, i32 noundef %memop) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %datalo.addr = alloca i32, align 4
  %datahi.addr = alloca i32, align 4
  %memop.addr = alloca i32, align 4
  %use_movbe = alloca i8, align 1
  %movop = alloca i32, align 4
  %t = alloca i32, align 4
  %l1 = alloca ptr, align 8
  %l2 = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store i32 %datalo, ptr %datalo.addr, align 4
  store i32 %datahi, ptr %datahi.addr, align 4
  store i32 %memop, ptr %memop.addr, align 4
  store i8 0, ptr %use_movbe, align 1
  store i32 137, ptr %movop, align 4
  %0 = load i32, ptr %memop.addr, align 4
  %and = and i32 %0, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %1 = load i32, ptr @cpuinfo, align 4
  %and1 = and i32 %1, 4
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.end, label %if.then3

if.then3:                                         ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  store i8 1, ptr %use_movbe, align 1
  store i32 753, ptr %movop, align 4
  br label %if.end4

if.end4:                                          ; preds = %do.end, %entry
  %2 = load i32, ptr %memop.addr, align 4
  %and5 = and i32 %2, 7
  switch i32 %and5, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb8
    i32 2, label %sw.bb16
    i32 3, label %sw.bb23
    i32 4, label %sw.bb31
  ]

sw.bb:                                            ; preds = %if.end4
  br label %do.body6

do.body6:                                         ; preds = %sw.bb
  br label %do.end7

do.end7:                                          ; preds = %do.body6
  %3 = load ptr, ptr %s.addr, align 8
  %seg = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %4 = load i32, ptr %seg, align 4
  %add = add i32 8328, %4
  %5 = load i32, ptr %datalo.addr, align 4
  %base = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %6 = load i32, ptr %base, align 8
  %index = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %7 = load i32, ptr %index, align 4
  %ofs = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %8 = load i32, ptr %ofs, align 8
  %conv = sext i32 %8 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %3, i32 noundef %add, i32 noundef %5, i32 noundef %6, i32 noundef %7, i32 noundef 0, i64 noundef %conv)
  br label %sw.epilog

sw.bb8:                                           ; preds = %if.end4
  %9 = load ptr, ptr %s.addr, align 8
  %10 = load i32, ptr %movop, align 4
  %add9 = add i32 %10, 1024
  %seg10 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %11 = load i32, ptr %seg10, align 4
  %add11 = add i32 %add9, %11
  %12 = load i32, ptr %datalo.addr, align 4
  %base12 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %13 = load i32, ptr %base12, align 8
  %index13 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %14 = load i32, ptr %index13, align 4
  %ofs14 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %15 = load i32, ptr %ofs14, align 8
  %conv15 = sext i32 %15 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %9, i32 noundef %add11, i32 noundef %12, i32 noundef %13, i32 noundef %14, i32 noundef 0, i64 noundef %conv15)
  br label %sw.epilog

sw.bb16:                                          ; preds = %if.end4
  %16 = load ptr, ptr %s.addr, align 8
  %17 = load i32, ptr %movop, align 4
  %seg17 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %18 = load i32, ptr %seg17, align 4
  %add18 = add i32 %17, %18
  %19 = load i32, ptr %datalo.addr, align 4
  %base19 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %20 = load i32, ptr %base19, align 8
  %index20 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %21 = load i32, ptr %index20, align 4
  %ofs21 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %22 = load i32, ptr %ofs21, align 8
  %conv22 = sext i32 %22 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %16, i32 noundef %add18, i32 noundef %19, i32 noundef %20, i32 noundef %21, i32 noundef 0, i64 noundef %conv22)
  br label %sw.epilog

sw.bb23:                                          ; preds = %if.end4
  %23 = load ptr, ptr %s.addr, align 8
  %24 = load i32, ptr %movop, align 4
  %add24 = add i32 %24, 4096
  %seg25 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %25 = load i32, ptr %seg25, align 4
  %add26 = add i32 %add24, %25
  %26 = load i32, ptr %datalo.addr, align 4
  %base27 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %27 = load i32, ptr %base27, align 8
  %index28 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %28 = load i32, ptr %index28, align 4
  %ofs29 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %29 = load i32, ptr %ofs29, align 8
  %conv30 = sext i32 %29 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %23, i32 noundef %add26, i32 noundef %26, i32 noundef %27, i32 noundef %28, i32 noundef 0, i64 noundef %conv30)
  br label %sw.epilog

sw.bb31:                                          ; preds = %if.end4
  br label %do.body32

do.body32:                                        ; preds = %sw.bb31
  br label %do.end33

do.end33:                                         ; preds = %do.body32
  %aa = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 4
  %atom = getelementptr inbounds %struct.TCGAtomAlign, ptr %aa, i32 0, i32 0
  %30 = load i32, ptr %atom, align 8
  %cmp = icmp ult i32 %30, 4
  br i1 %cmp, label %if.then35, label %if.end54

if.then35:                                        ; preds = %do.end33
  %31 = load i8, ptr %use_movbe, align 1
  %tobool36 = trunc i8 %31 to i1
  br i1 %tobool36, label %if.then37, label %if.end38

if.then37:                                        ; preds = %if.then35
  %32 = load i32, ptr %datalo.addr, align 4
  store i32 %32, ptr %t, align 4
  %33 = load i32, ptr %datahi.addr, align 4
  store i32 %33, ptr %datalo.addr, align 4
  %34 = load i32, ptr %t, align 4
  store i32 %34, ptr %datahi.addr, align 4
  br label %if.end38

if.end38:                                         ; preds = %if.then37, %if.then35
  %35 = load ptr, ptr %s.addr, align 8
  %36 = load i32, ptr %movop, align 4
  %add39 = add i32 %36, 4096
  %seg40 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %37 = load i32, ptr %seg40, align 4
  %add41 = add i32 %add39, %37
  %38 = load i32, ptr %datalo.addr, align 4
  %base42 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %39 = load i32, ptr %base42, align 8
  %index43 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %40 = load i32, ptr %index43, align 4
  %ofs44 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %41 = load i32, ptr %ofs44, align 8
  %conv45 = sext i32 %41 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %35, i32 noundef %add41, i32 noundef %38, i32 noundef %39, i32 noundef %40, i32 noundef 0, i64 noundef %conv45)
  %42 = load ptr, ptr %s.addr, align 8
  %43 = load i32, ptr %movop, align 4
  %add46 = add i32 %43, 4096
  %seg47 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %44 = load i32, ptr %seg47, align 4
  %add48 = add i32 %add46, %44
  %45 = load i32, ptr %datahi.addr, align 4
  %base49 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %46 = load i32, ptr %base49, align 8
  %index50 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %47 = load i32, ptr %index50, align 4
  %ofs51 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %48 = load i32, ptr %ofs51, align 8
  %add52 = add i32 %48, 8
  %conv53 = sext i32 %add52 to i64
  call void @tcg_out_modrm_sib_offset(ptr noundef %42, i32 noundef %add48, i32 noundef %45, i32 noundef %46, i32 noundef %47, i32 noundef 0, i64 noundef %conv53)
  br label %sw.epilog

if.end54:                                         ; preds = %do.end33
  %49 = load ptr, ptr %s.addr, align 8
  %50 = load i32, ptr %datalo.addr, align 4
  %51 = load i32, ptr %datahi.addr, align 4
  call void @tcg_out_pair_to_vec(ptr noundef %49, i32 noundef 1, i32 noundef 21, i32 noundef %50, i32 noundef %51)
  %aa55 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 4
  %align = getelementptr inbounds %struct.TCGAtomAlign, ptr %aa55, i32 0, i32 1
  %52 = load i32, ptr %align, align 4
  %cmp56 = icmp uge i32 %52, 4
  br i1 %cmp56, label %if.then58, label %if.else

if.then58:                                        ; preds = %if.end54
  %53 = load ptr, ptr %s.addr, align 8
  %seg59 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %54 = load i32, ptr %seg59, align 4
  %add60 = add i32 1407, %54
  %base61 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %55 = load i32, ptr %base61, align 8
  %index62 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %56 = load i32, ptr %index62, align 4
  %ofs63 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %57 = load i32, ptr %ofs63, align 8
  %conv64 = sext i32 %57 to i64
  call void @tcg_out_vex_modrm_sib_offset(ptr noundef %53, i32 noundef %add60, i32 noundef 21, i32 noundef 0, i32 noundef %55, i32 noundef %56, i32 noundef 0, i64 noundef %conv64)
  br label %if.end90

if.else:                                          ; preds = %if.end54
  %58 = load i32, ptr @cpuinfo, align 4
  %and65 = and i32 %58, 131072
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %if.then67, label %if.else74

if.then67:                                        ; preds = %if.else
  %59 = load ptr, ptr %s.addr, align 8
  %seg68 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %60 = load i32, ptr %seg68, align 4
  %add69 = add i32 131455, %60
  %base70 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %61 = load i32, ptr %base70, align 8
  %index71 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %62 = load i32, ptr %index71, align 4
  %ofs72 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %63 = load i32, ptr %ofs72, align 8
  %conv73 = sext i32 %63 to i64
  call void @tcg_out_vex_modrm_sib_offset(ptr noundef %59, i32 noundef %add69, i32 noundef 21, i32 noundef 0, i32 noundef %61, i32 noundef %62, i32 noundef 0, i64 noundef %conv73)
  br label %if.end89

if.else74:                                        ; preds = %if.else
  %call = call ptr @gen_new_label()
  store ptr %call, ptr %l1, align 8
  %call75 = call ptr @gen_new_label()
  store ptr %call75, ptr %l2, align 8
  %64 = load ptr, ptr %s.addr, align 8
  %base76 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %65 = load i32, ptr %base76, align 8
  call void @tcg_out_testi(ptr noundef %64, i32 noundef %65, i32 noundef 15)
  %66 = load ptr, ptr %s.addr, align 8
  %67 = load ptr, ptr %l1, align 8
  call void @tcg_out_jxx(ptr noundef %66, i32 noundef 5, ptr noundef %67, i1 noundef zeroext true)
  %68 = load ptr, ptr %s.addr, align 8
  %seg77 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %69 = load i32, ptr %seg77, align 4
  %add78 = add i32 1407, %69
  %base79 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %70 = load i32, ptr %base79, align 8
  %index80 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %71 = load i32, ptr %index80, align 4
  %ofs81 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %72 = load i32, ptr %ofs81, align 8
  %conv82 = sext i32 %72 to i64
  call void @tcg_out_vex_modrm_sib_offset(ptr noundef %68, i32 noundef %add78, i32 noundef 21, i32 noundef 0, i32 noundef %70, i32 noundef %71, i32 noundef 0, i64 noundef %conv82)
  %73 = load ptr, ptr %s.addr, align 8
  %74 = load ptr, ptr %l2, align 8
  call void @tcg_out_jxx(ptr noundef %73, i32 noundef -1, ptr noundef %74, i1 noundef zeroext true)
  %75 = load ptr, ptr %s.addr, align 8
  %76 = load ptr, ptr %l1, align 8
  call void @tcg_out_label(ptr noundef %75, ptr noundef %76)
  %77 = load ptr, ptr %s.addr, align 8
  %seg83 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 3
  %78 = load i32, ptr %seg83, align 4
  %add84 = add i32 131455, %78
  %base85 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 0
  %79 = load i32, ptr %base85, align 8
  %index86 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 1
  %80 = load i32, ptr %index86, align 4
  %ofs87 = getelementptr inbounds %struct.HostAddress, ptr %h, i32 0, i32 2
  %81 = load i32, ptr %ofs87, align 8
  %conv88 = sext i32 %81 to i64
  call void @tcg_out_vex_modrm_sib_offset(ptr noundef %77, i32 noundef %add84, i32 noundef 21, i32 noundef 0, i32 noundef %79, i32 noundef %80, i32 noundef 0, i64 noundef %conv88)
  %82 = load ptr, ptr %s.addr, align 8
  %83 = load ptr, ptr %l2, align 8
  call void @tcg_out_label(ptr noundef %82, ptr noundef %83)
  br label %if.end89

if.end89:                                         ; preds = %if.else74, %if.then67
  br label %if.end90

if.end90:                                         ; preds = %if.end89, %if.then58
  br label %sw.epilog

sw.default:                                       ; preds = %if.end4
  br label %do.body91

do.body91:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str, i32 noundef 2375, ptr noundef @__func__.tcg_out_qemu_st_direct, ptr noundef null) #15
  unreachable

do.end92:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end92, %if.end90, %if.end38, %sw.bb23, %sw.bb16, %sw.bb8, %do.end7
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_pair_to_vec(ptr noundef %s, i32 noundef %type, i32 noundef %v, i32 noundef %l, i32 noundef %h) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %v.addr = alloca i32, align 4
  %l.addr = alloca i32, align 4
  %h.addr = alloca i32, align 4
  %rexw = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %v, ptr %v.addr, align 4
  store i32 %l, ptr %l.addr, align 4
  store i32 %h, ptr %h.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %0, 0
  %cond = select i1 %cmp, i32 0, i32 4096
  store i32 %cond, ptr %rexw, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %rexw, align 4
  %add = add i32 1390, %2
  %3 = load i32, ptr %v.addr, align 4
  %4 = load i32, ptr %l.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %1, i32 noundef %add, i32 noundef %3, i32 noundef 0, i32 noundef %4)
  %5 = load ptr, ptr %s.addr, align 8
  %6 = load i32, ptr %rexw, align 4
  %add1 = add i32 66594, %6
  %7 = load i32, ptr %v.addr, align 4
  %8 = load i32, ptr %v.addr, align 4
  %9 = load i32, ptr %h.addr, align 4
  call void @tcg_out_vex_modrm(ptr noundef %5, i32 noundef %add1, i32 noundef %7, i32 noundef %8, i32 noundef %9)
  %10 = load ptr, ptr %s.addr, align 8
  call void @tcg_out8(ptr noundef %10, i8 noundef zeroext 1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_out_qemu_ld_slow_path(ptr noundef %s, ptr noundef %l) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %l.addr = alloca ptr, align 8
  %opc = alloca i32, align 4
  %label_ptr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %l, ptr %l.addr, align 8
  %0 = load ptr, ptr %l.addr, align 8
  %oi = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %oi, align 4
  %call = call i32 @get_memop(i32 noundef %1)
  store i32 %call, ptr %opc, align 4
  %2 = load ptr, ptr %l.addr, align 8
  %label_ptr1 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %2, i32 0, i32 8
  %arrayidx = getelementptr [2 x ptr], ptr %label_ptr1, i64 0, i64 0
  store ptr %arrayidx, ptr %label_ptr, align 8
  %3 = load ptr, ptr %label_ptr, align 8
  %arrayidx2 = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx2, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %5, i32 0, i32 23
  %6 = load ptr, ptr %code_ptr, align 8
  %7 = load ptr, ptr %label_ptr, align 8
  %arrayidx3 = getelementptr ptr, ptr %7, i64 0
  %8 = load ptr, ptr %arrayidx3, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub = sub i64 %sub.ptr.sub, 4
  %conv = trunc i64 %sub to i32
  call void @tcg_patch32(ptr noundef %4, i32 noundef %conv)
  %9 = load ptr, ptr %label_ptr, align 8
  %arrayidx4 = getelementptr ptr, ptr %9, i64 1
  %10 = load ptr, ptr %arrayidx4, align 8
  %tobool = icmp ne ptr %10, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load ptr, ptr %label_ptr, align 8
  %arrayidx5 = getelementptr ptr, ptr %11, i64 1
  %12 = load ptr, ptr %arrayidx5, align 8
  %13 = load ptr, ptr %s.addr, align 8
  %code_ptr6 = getelementptr inbounds %struct.TCGContext, ptr %13, i32 0, i32 23
  %14 = load ptr, ptr %code_ptr6, align 8
  %15 = load ptr, ptr %label_ptr, align 8
  %arrayidx7 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx7, align 8
  %sub.ptr.lhs.cast8 = ptrtoint ptr %14 to i64
  %sub.ptr.rhs.cast9 = ptrtoint ptr %16 to i64
  %sub.ptr.sub10 = sub i64 %sub.ptr.lhs.cast8, %sub.ptr.rhs.cast9
  %sub11 = sub i64 %sub.ptr.sub10, 4
  %conv12 = trunc i64 %sub11 to i32
  call void @tcg_patch32(ptr noundef %12, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %17 = load ptr, ptr %s.addr, align 8
  %18 = load ptr, ptr %l.addr, align 8
  call void @tcg_out_ld_helper_args(ptr noundef %17, ptr noundef %18, ptr noundef @ldst_helper_param)
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load i32, ptr %opc, align 4
  %and = and i32 %20, 7
  %idxprom = zext i32 %and to i64
  %arrayidx13 = getelementptr [16 x ptr], ptr @qemu_ld_helpers, i64 0, i64 %idxprom
  %21 = load ptr, ptr %arrayidx13, align 8
  call void @tcg_out_branch(ptr noundef %19, i32 noundef 1, ptr noundef %21)
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load ptr, ptr %l.addr, align 8
  call void @tcg_out_ld_helper_ret(ptr noundef %22, ptr noundef %23, i1 noundef zeroext false, ptr noundef @ldst_helper_param)
  %24 = load ptr, ptr %s.addr, align 8
  %25 = load ptr, ptr %l.addr, align 8
  %raddr = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %25, i32 0, i32 7
  %26 = load ptr, ptr %raddr, align 8
  call void @tcg_out_jmp(ptr noundef %24, ptr noundef %26)
  ret i1 true
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_out_qemu_st_slow_path(ptr noundef %s, ptr noundef %l) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %l.addr = alloca ptr, align 8
  %opc = alloca i32, align 4
  %label_ptr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %l, ptr %l.addr, align 8
  %0 = load ptr, ptr %l.addr, align 8
  %oi = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %oi, align 4
  %call = call i32 @get_memop(i32 noundef %1)
  store i32 %call, ptr %opc, align 4
  %2 = load ptr, ptr %l.addr, align 8
  %label_ptr1 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %2, i32 0, i32 8
  %arrayidx = getelementptr [2 x ptr], ptr %label_ptr1, i64 0, i64 0
  store ptr %arrayidx, ptr %label_ptr, align 8
  %3 = load ptr, ptr %label_ptr, align 8
  %arrayidx2 = getelementptr ptr, ptr %3, i64 0
  %4 = load ptr, ptr %arrayidx2, align 8
  %5 = load ptr, ptr %s.addr, align 8
  %code_ptr = getelementptr inbounds %struct.TCGContext, ptr %5, i32 0, i32 23
  %6 = load ptr, ptr %code_ptr, align 8
  %7 = load ptr, ptr %label_ptr, align 8
  %arrayidx3 = getelementptr ptr, ptr %7, i64 0
  %8 = load ptr, ptr %arrayidx3, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %6 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub = sub i64 %sub.ptr.sub, 4
  %conv = trunc i64 %sub to i32
  call void @tcg_patch32(ptr noundef %4, i32 noundef %conv)
  %9 = load ptr, ptr %label_ptr, align 8
  %arrayidx4 = getelementptr ptr, ptr %9, i64 1
  %10 = load ptr, ptr %arrayidx4, align 8
  %tobool = icmp ne ptr %10, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %11 = load ptr, ptr %label_ptr, align 8
  %arrayidx5 = getelementptr ptr, ptr %11, i64 1
  %12 = load ptr, ptr %arrayidx5, align 8
  %13 = load ptr, ptr %s.addr, align 8
  %code_ptr6 = getelementptr inbounds %struct.TCGContext, ptr %13, i32 0, i32 23
  %14 = load ptr, ptr %code_ptr6, align 8
  %15 = load ptr, ptr %label_ptr, align 8
  %arrayidx7 = getelementptr ptr, ptr %15, i64 1
  %16 = load ptr, ptr %arrayidx7, align 8
  %sub.ptr.lhs.cast8 = ptrtoint ptr %14 to i64
  %sub.ptr.rhs.cast9 = ptrtoint ptr %16 to i64
  %sub.ptr.sub10 = sub i64 %sub.ptr.lhs.cast8, %sub.ptr.rhs.cast9
  %sub11 = sub i64 %sub.ptr.sub10, 4
  %conv12 = trunc i64 %sub11 to i32
  call void @tcg_patch32(ptr noundef %12, i32 noundef %conv12)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %17 = load ptr, ptr %s.addr, align 8
  %18 = load ptr, ptr %l.addr, align 8
  call void @tcg_out_st_helper_args(ptr noundef %17, ptr noundef %18, ptr noundef @ldst_helper_param)
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load i32, ptr %opc, align 4
  %and = and i32 %20, 7
  %idxprom = zext i32 %and to i64
  %arrayidx13 = getelementptr [8 x ptr], ptr @qemu_st_helpers, i64 0, i64 %idxprom
  %21 = load ptr, ptr %arrayidx13, align 8
  call void @tcg_out_branch(ptr noundef %19, i32 noundef 1, ptr noundef %21)
  %22 = load ptr, ptr %s.addr, align 8
  %23 = load ptr, ptr %l.addr, align 8
  %raddr = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %23, i32 0, i32 7
  %24 = load ptr, ptr %raddr, align 8
  call void @tcg_out_jmp(ptr noundef %22, ptr noundef %24)
  ret i1 true
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_ld_helper_args(ptr noundef %s, ptr noundef %ldst, ptr noundef %parm) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ldst.addr = alloca ptr, align 8
  %parm.addr = alloca ptr, align 8
  %info = alloca ptr, align 8
  %loc = alloca ptr, align 8
  %mov = alloca [2 x %struct.TCGMovExtend], align 16
  %next_arg = alloca i32, align 4
  %nmov = alloca i32, align 4
  %mop = alloca i32, align 4
  %ofs_slot0 = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ldst, ptr %ldst.addr, align 8
  store ptr %parm, ptr %parm.addr, align 8
  %0 = load ptr, ptr %ldst.addr, align 8
  %oi = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %oi, align 4
  %call = call i32 @get_memop(i32 noundef %1)
  store i32 %call, ptr %mop, align 4
  %2 = load i32, ptr %mop, align 4
  %and = and i32 %2, 7
  switch i32 %and, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb1
    i32 4, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  store ptr @info_helper_ld32_mmu, ptr %info, align 8
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store ptr @info_helper_ld64_mmu, ptr %info, align 8
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  store ptr @info_helper_ld128_mmu, ptr %info, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5771, ptr noundef @__func__.tcg_out_ld_helper_args, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb2, %sw.bb1, %sw.bb
  store i32 1, ptr %next_arg, align 4
  %3 = load ptr, ptr %info, align 8
  %in = getelementptr inbounds %struct.TCGHelperInfo, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %next_arg, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %loc, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %5 = load ptr, ptr %loc, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %addr_type = getelementptr inbounds %struct.TCGContext, ptr %6, i32 0, i32 10
  %7 = load i32, ptr %addr_type, align 4
  %8 = load ptr, ptr %ldst.addr, align 8
  %addrlo_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %addrlo_reg, align 4
  %10 = load ptr, ptr %ldst.addr, align 8
  %addrhi_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %10, i32 0, i32 4
  %11 = load i32, ptr %addrhi_reg, align 8
  %call3 = call i32 @tcg_out_helper_add_mov(ptr noundef %arraydecay, ptr noundef %5, i32 noundef 1, i32 noundef %7, i32 noundef %9, i32 noundef %11)
  store i32 %call3, ptr %nmov, align 4
  %12 = load ptr, ptr %s.addr, align 8
  %13 = load i32, ptr %nmov, align 4
  %arraydecay4 = getelementptr inbounds [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %14 = load ptr, ptr %parm.addr, align 8
  call void @tcg_out_helper_load_slots(ptr noundef %12, i32 noundef %13, ptr noundef %arraydecay4, ptr noundef %14)
  %15 = load i32, ptr %nmov, align 4
  %16 = load i32, ptr %next_arg, align 4
  %add = add i32 %16, %15
  store i32 %add, ptr %next_arg, align 4
  %17 = load ptr, ptr %info, align 8
  %out_kind = getelementptr inbounds %struct.TCGHelperInfo, ptr %17, i32 0, i32 3
  %bf.load = load i64, ptr %out_kind, align 8
  %bf.lshr = lshr i64 %bf.load, 56
  %bf.cast = trunc i64 %bf.lshr to i32
  switch i32 %bf.cast, label %sw.default18 [
    i32 0, label %sw.bb5
    i32 2, label %sw.bb5
    i32 1, label %sw.bb6
  ]

sw.bb5:                                           ; preds = %sw.epilog, %sw.epilog
  br label %sw.epilog21

sw.bb6:                                           ; preds = %sw.epilog
  store i32 0, ptr %ofs_slot0, align 4
  %call7 = call zeroext i1 @arg_slot_reg_p(i32 noundef 0)
  br i1 %call7, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb6
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load i32, ptr @tcg_target_call_iarg_regs, align 16
  %20 = load i32, ptr %ofs_slot0, align 4
  %conv = sext i32 %20 to i64
  call void @tcg_out_addi_ptr(ptr noundef %18, i32 noundef %19, i32 noundef 4, i64 noundef %conv)
  br label %if.end17

if.else:                                          ; preds = %sw.bb6
  br label %do.body8

do.body8:                                         ; preds = %if.else
  %21 = load ptr, ptr %parm.addr, align 8
  %ntmp = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %21, i32 0, i32 1
  %22 = load i32, ptr %ntmp, align 8
  %cmp = icmp ne i32 %22, 0
  br i1 %cmp, label %if.end, label %if.then10

if.then10:                                        ; preds = %do.body8
  unreachable

if.end:                                           ; preds = %do.body8
  br label %do.end11

do.end11:                                         ; preds = %if.end
  %23 = load ptr, ptr %s.addr, align 8
  %24 = load ptr, ptr %parm.addr, align 8
  %tmp = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %24, i32 0, i32 2
  %arrayidx12 = getelementptr [3 x i32], ptr %tmp, i64 0, i64 0
  %25 = load i32, ptr %arrayidx12, align 4
  %26 = load i32, ptr %ofs_slot0, align 4
  %conv13 = sext i32 %26 to i64
  call void @tcg_out_addi_ptr(ptr noundef %23, i32 noundef %25, i32 noundef 4, i64 noundef %conv13)
  %27 = load ptr, ptr %s.addr, align 8
  %28 = load ptr, ptr %parm.addr, align 8
  %tmp14 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %28, i32 0, i32 2
  %arrayidx15 = getelementptr [3 x i32], ptr %tmp14, i64 0, i64 0
  %29 = load i32, ptr %arrayidx15, align 4
  %30 = load i32, ptr %ofs_slot0, align 4
  %conv16 = sext i32 %30 to i64
  call void @tcg_out_st(ptr noundef %27, i32 noundef 1, i32 noundef %29, i32 noundef 4, i64 noundef %conv16)
  br label %if.end17

if.end17:                                         ; preds = %do.end11, %if.then
  br label %sw.epilog21

sw.default18:                                     ; preds = %sw.epilog
  br label %do.body19

do.body19:                                        ; preds = %sw.default18
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5824, ptr noundef @__func__.tcg_out_ld_helper_args, ptr noundef null) #15
  unreachable

do.end20:                                         ; No predecessors!
  br label %sw.epilog21

sw.epilog21:                                      ; preds = %do.end20, %if.end17, %sw.bb5
  %31 = load ptr, ptr %s.addr, align 8
  %32 = load ptr, ptr %ldst.addr, align 8
  %33 = load ptr, ptr %parm.addr, align 8
  %34 = load ptr, ptr %info, align 8
  %35 = load i32, ptr %next_arg, align 4
  call void @tcg_out_helper_load_common_args(ptr noundef %31, ptr noundef %32, ptr noundef %33, ptr noundef %34, i32 noundef %35)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_ld_helper_ret(ptr noundef %s, ptr noundef %ldst, i1 noundef zeroext %load_sign, ptr noundef %parm) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ldst.addr = alloca ptr, align 8
  %load_sign.addr = alloca i8, align 1
  %parm.addr = alloca ptr, align 8
  %mop = alloca i32, align 4
  %mov = alloca [2 x %struct.TCGMovExtend], align 16
  %ofs_slot0 = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ldst, ptr %ldst.addr, align 8
  %frombool = zext i1 %load_sign to i8
  store i8 %frombool, ptr %load_sign.addr, align 1
  store ptr %parm, ptr %parm.addr, align 8
  %0 = load ptr, ptr %ldst.addr, align 8
  %oi = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %oi, align 4
  %call = call i32 @get_memop(i32 noundef %1)
  store i32 %call, ptr %mop, align 4
  %2 = load ptr, ptr %ldst.addr, align 8
  %type = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %type, align 8
  switch i32 %3, label %sw.default [
    i32 1, label %sw.bb
    i32 0, label %sw.bb1
    i32 2, label %sw.bb18
  ]

sw.bb:                                            ; preds = %entry
  br label %sw.bb1

sw.bb1:                                           ; preds = %sw.bb, %entry
  %4 = load ptr, ptr %ldst.addr, align 8
  %datalo_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %4, i32 0, i32 5
  %5 = load i32, ptr %datalo_reg, align 4
  %arrayidx = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %dst = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx, i32 0, i32 0
  store i32 %5, ptr %dst, align 16
  %call2 = call i32 @tcg_target_call_oarg_reg(i32 noundef 0, i32 noundef 0)
  %arrayidx3 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %src = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx3, i32 0, i32 1
  store i32 %call2, ptr %src, align 4
  %6 = load ptr, ptr %ldst.addr, align 8
  %type4 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %6, i32 0, i32 2
  %7 = load i32, ptr %type4, align 8
  %arrayidx5 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %dst_type = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx5, i32 0, i32 2
  store i32 %7, ptr %dst_type, align 8
  %arrayidx6 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %src_type = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx6, i32 0, i32 3
  store i32 1, ptr %src_type, align 4
  %8 = load i8, ptr %load_sign.addr, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb1
  %9 = load i32, ptr %mop, align 4
  %and = and i32 %9, 8
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %if.else13, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %sw.bb1
  %10 = load ptr, ptr %ldst.addr, align 8
  %type8 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %10, i32 0, i32 2
  %11 = load i32, ptr %type8, align 8
  %cmp = icmp eq i32 %11, 0
  br i1 %cmp, label %if.then9, label %if.else

if.then9:                                         ; preds = %if.then
  %arrayidx10 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %src_ext = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx10, i32 0, i32 4
  store i32 2, ptr %src_ext, align 16
  br label %if.end

if.else:                                          ; preds = %if.then
  %arrayidx11 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %src_ext12 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx11, i32 0, i32 4
  store i32 3, ptr %src_ext12, align 16
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then9
  br label %if.end17

if.else13:                                        ; preds = %lor.lhs.false
  %12 = load i32, ptr %mop, align 4
  %and14 = and i32 %12, 15
  %arrayidx15 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %src_ext16 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx15, i32 0, i32 4
  store i32 %and14, ptr %src_ext16, align 16
  br label %if.end17

if.end17:                                         ; preds = %if.else13, %if.end
  %13 = load ptr, ptr %s.addr, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  call void @tcg_out_movext1(ptr noundef %13, ptr noundef %arraydecay)
  br label %return

sw.bb18:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb18
  br label %do.end

do.end:                                           ; preds = %do.body
  store i32 0, ptr %ofs_slot0, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body19

do.body19:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5896, ptr noundef @__func__.tcg_out_ld_helper_ret, ptr noundef null) #15
  unreachable

do.end20:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end20, %do.end
  %14 = load ptr, ptr %ldst.addr, align 8
  %datalo_reg21 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %14, i32 0, i32 5
  %15 = load i32, ptr %datalo_reg21, align 4
  %arrayidx22 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %dst23 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx22, i32 0, i32 0
  store i32 %15, ptr %dst23, align 16
  %call24 = call i32 @tcg_target_call_oarg_reg(i32 noundef 0, i32 noundef 0)
  %arrayidx25 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %src26 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx25, i32 0, i32 1
  store i32 %call24, ptr %src26, align 4
  %arrayidx27 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %dst_type28 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx27, i32 0, i32 2
  store i32 1, ptr %dst_type28, align 8
  %arrayidx29 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %src_type30 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx29, i32 0, i32 3
  store i32 1, ptr %src_type30, align 4
  %arrayidx31 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %src_ext32 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx31, i32 0, i32 4
  store i32 3, ptr %src_ext32, align 16
  %16 = load ptr, ptr %ldst.addr, align 8
  %datahi_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %16, i32 0, i32 6
  %17 = load i32, ptr %datahi_reg, align 8
  %arrayidx33 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 1
  %dst34 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx33, i32 0, i32 0
  store i32 %17, ptr %dst34, align 4
  %call35 = call i32 @tcg_target_call_oarg_reg(i32 noundef 0, i32 noundef 1)
  %arrayidx36 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 1
  %src37 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx36, i32 0, i32 1
  store i32 %call35, ptr %src37, align 4
  %arrayidx38 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 1
  %dst_type39 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx38, i32 0, i32 2
  store i32 1, ptr %dst_type39, align 4
  %arrayidx40 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 1
  %src_type41 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx40, i32 0, i32 3
  store i32 1, ptr %src_type41, align 4
  %arrayidx42 = getelementptr [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 1
  %src_ext43 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx42, i32 0, i32 4
  store i32 3, ptr %src_ext43, align 4
  %18 = load ptr, ptr %s.addr, align 8
  %arraydecay44 = getelementptr inbounds [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %arraydecay45 = getelementptr inbounds [2 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %add.ptr = getelementptr %struct.TCGMovExtend, ptr %arraydecay45, i64 1
  %19 = load ptr, ptr %parm.addr, align 8
  %ntmp = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %19, i32 0, i32 1
  %20 = load i32, ptr %ntmp, align 8
  %tobool46 = icmp ne i32 %20, 0
  br i1 %tobool46, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.epilog
  %21 = load ptr, ptr %parm.addr, align 8
  %tmp = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %21, i32 0, i32 2
  %arrayidx47 = getelementptr [3 x i32], ptr %tmp, i64 0, i64 0
  %22 = load i32, ptr %arrayidx47, align 4
  br label %cond.end

cond.false:                                       ; preds = %sw.epilog
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %22, %cond.true ], [ -1, %cond.false ]
  call void @tcg_out_movext2(ptr noundef %18, ptr noundef %arraydecay44, ptr noundef %add.ptr, i32 noundef %cond)
  br label %return

return:                                           ; preds = %cond.end, %if.end17
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_out_helper_add_mov(ptr noundef %mov, ptr noundef %loc, i32 noundef %dst_type, i32 noundef %src_type, i32 noundef %lo, i32 noundef %hi) #0 {
entry:
  %retval = alloca i32, align 4
  %mov.addr = alloca ptr, align 8
  %loc.addr = alloca ptr, align 8
  %dst_type.addr = alloca i32, align 4
  %src_type.addr = alloca i32, align 4
  %lo.addr = alloca i32, align 4
  %hi.addr = alloca i32, align 4
  %reg_mo = alloca i32, align 4
  %src_ext = alloca i32, align 4
  store ptr %mov, ptr %mov.addr, align 8
  store ptr %loc, ptr %loc.addr, align 8
  store i32 %dst_type, ptr %dst_type.addr, align 4
  store i32 %src_type, ptr %src_type.addr, align 4
  store i32 %lo, ptr %lo.addr, align 4
  store i32 %hi, ptr %hi.addr, align 4
  %0 = load i32, ptr %dst_type.addr, align 4
  %cmp = icmp ule i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %loc.addr, align 8
  %bf.load = load i32, ptr %1, align 4
  %bf.clear = and i32 %bf.load, 255
  switch i32 %bf.clear, label %sw.default [
    i32 0, label %sw.bb
    i32 3, label %sw.bb2
    i32 4, label %sw.bb3
  ]

sw.bb:                                            ; preds = %if.then
  %2 = load i32, ptr %src_type.addr, align 4
  %cmp1 = icmp eq i32 %2, 0
  %cond = select i1 %cmp1, i32 2, i32 3
  store i32 %cond, ptr %src_ext, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %if.then
  store i32 1, ptr %dst_type.addr, align 4
  store i32 2, ptr %src_ext, align 4
  br label %sw.epilog

sw.bb3:                                           ; preds = %if.then
  store i32 1, ptr %dst_type.addr, align 4
  store i32 10, ptr %src_ext, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5715, ptr noundef @__func__.tcg_out_helper_add_mov, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb3, %sw.bb2, %sw.bb
  %3 = load ptr, ptr %loc.addr, align 8
  %bf.load4 = load i32, ptr %3, align 4
  %bf.lshr = lshr i32 %bf.load4, 8
  %bf.clear5 = and i32 %bf.lshr, 255
  %4 = load ptr, ptr %mov.addr, align 8
  %arrayidx = getelementptr %struct.TCGMovExtend, ptr %4, i64 0
  %dst = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx, i32 0, i32 0
  store i32 %bf.clear5, ptr %dst, align 4
  %5 = load i32, ptr %dst_type.addr, align 4
  %6 = load ptr, ptr %mov.addr, align 8
  %arrayidx6 = getelementptr %struct.TCGMovExtend, ptr %6, i64 0
  %dst_type7 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx6, i32 0, i32 2
  store i32 %5, ptr %dst_type7, align 4
  %7 = load i32, ptr %lo.addr, align 4
  %8 = load ptr, ptr %mov.addr, align 8
  %arrayidx8 = getelementptr %struct.TCGMovExtend, ptr %8, i64 0
  %src = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx8, i32 0, i32 1
  store i32 %7, ptr %src, align 4
  %9 = load i32, ptr %src_type.addr, align 4
  %10 = load ptr, ptr %mov.addr, align 8
  %arrayidx9 = getelementptr %struct.TCGMovExtend, ptr %10, i64 0
  %src_type10 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx9, i32 0, i32 3
  store i32 %9, ptr %src_type10, align 4
  %11 = load i32, ptr %src_ext, align 4
  %12 = load ptr, ptr %mov.addr, align 8
  %arrayidx11 = getelementptr %struct.TCGMovExtend, ptr %12, i64 0
  %src_ext12 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx11, i32 0, i32 4
  store i32 %11, ptr %src_ext12, align 4
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  %13 = load i32, ptr %dst_type.addr, align 4
  %cmp13 = icmp eq i32 %13, 2
  br i1 %cmp13, label %if.then14, label %if.else

if.then14:                                        ; preds = %if.end
  br label %if.end15

if.else:                                          ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.128, ptr noundef @.str.1, i32 noundef 5730, ptr noundef @__PRETTY_FUNCTION__.tcg_out_helper_add_mov) #19
  unreachable

if.end15:                                         ; preds = %if.then14
  store i32 3, ptr %reg_mo, align 4
  %14 = load ptr, ptr %loc.addr, align 8
  %arrayidx16 = getelementptr %struct.TCGCallArgumentLoc, ptr %14, i64 0
  %bf.load17 = load i32, ptr %arrayidx16, align 4
  %bf.lshr18 = lshr i32 %bf.load17, 8
  %bf.clear19 = and i32 %bf.lshr18, 255
  %15 = load ptr, ptr %mov.addr, align 8
  %arrayidx20 = getelementptr %struct.TCGMovExtend, ptr %15, i64 0
  %dst21 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx20, i32 0, i32 0
  store i32 %bf.clear19, ptr %dst21, align 4
  %16 = load i32, ptr %lo.addr, align 4
  %17 = load ptr, ptr %mov.addr, align 8
  %arrayidx22 = getelementptr %struct.TCGMovExtend, ptr %17, i64 0
  %src23 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx22, i32 0, i32 1
  store i32 %16, ptr %src23, align 4
  %18 = load ptr, ptr %mov.addr, align 8
  %arrayidx24 = getelementptr %struct.TCGMovExtend, ptr %18, i64 0
  %dst_type25 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx24, i32 0, i32 2
  store i32 1, ptr %dst_type25, align 4
  %19 = load ptr, ptr %mov.addr, align 8
  %arrayidx26 = getelementptr %struct.TCGMovExtend, ptr %19, i64 0
  %src_type27 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx26, i32 0, i32 3
  store i32 1, ptr %src_type27, align 4
  %20 = load i32, ptr %reg_mo, align 4
  %21 = load ptr, ptr %mov.addr, align 8
  %arrayidx28 = getelementptr %struct.TCGMovExtend, ptr %21, i64 0
  %src_ext29 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx28, i32 0, i32 4
  store i32 %20, ptr %src_ext29, align 4
  %22 = load ptr, ptr %loc.addr, align 8
  %arrayidx30 = getelementptr %struct.TCGCallArgumentLoc, ptr %22, i64 1
  %bf.load31 = load i32, ptr %arrayidx30, align 4
  %bf.lshr32 = lshr i32 %bf.load31, 8
  %bf.clear33 = and i32 %bf.lshr32, 255
  %23 = load ptr, ptr %mov.addr, align 8
  %arrayidx34 = getelementptr %struct.TCGMovExtend, ptr %23, i64 1
  %dst35 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx34, i32 0, i32 0
  store i32 %bf.clear33, ptr %dst35, align 4
  %24 = load i32, ptr %hi.addr, align 4
  %25 = load ptr, ptr %mov.addr, align 8
  %arrayidx36 = getelementptr %struct.TCGMovExtend, ptr %25, i64 1
  %src37 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx36, i32 0, i32 1
  store i32 %24, ptr %src37, align 4
  %26 = load ptr, ptr %mov.addr, align 8
  %arrayidx38 = getelementptr %struct.TCGMovExtend, ptr %26, i64 1
  %dst_type39 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx38, i32 0, i32 2
  store i32 1, ptr %dst_type39, align 4
  %27 = load ptr, ptr %mov.addr, align 8
  %arrayidx40 = getelementptr %struct.TCGMovExtend, ptr %27, i64 1
  %src_type41 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx40, i32 0, i32 3
  store i32 1, ptr %src_type41, align 4
  %28 = load i32, ptr %reg_mo, align 4
  %29 = load ptr, ptr %mov.addr, align 8
  %arrayidx42 = getelementptr %struct.TCGMovExtend, ptr %29, i64 1
  %src_ext43 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx42, i32 0, i32 4
  store i32 %28, ptr %src_ext43, align 4
  store i32 2, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %sw.epilog
  %30 = load i32, ptr %retval, align 4
  ret i32 %30
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_helper_load_slots(ptr noundef %s, i32 noundef %nmov, ptr noundef %mov, ptr noundef %parm) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %nmov.addr = alloca i32, align 4
  %mov.addr = alloca ptr, align 8
  %parm.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  %dst3 = alloca i32, align 4
  %slot = alloca i32, align 4
  %src = alloca i32, align 4
  %dst_type = alloca i32, align 4
  %dst_mo = alloca i32, align 4
  %j = alloca i32, align 4
  %scratch = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %nmov, ptr %nmov.addr, align 4
  store ptr %mov, ptr %mov.addr, align 8
  store ptr %parm, ptr %parm.addr, align 8
  %0 = load i32, ptr %nmov.addr, align 4
  store i32 %0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end21, %entry
  %1 = load i32, ptr %i, align 4
  %dec = add i32 %1, -1
  store i32 %dec, ptr %i, align 4
  %cmp = icmp ugt i32 %1, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %mov.addr, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr %struct.TCGMovExtend, ptr %2, i64 %idxprom
  %dst = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx, i32 0, i32 0
  %4 = load i32, ptr %dst, align 4
  store i32 %4, ptr %slot, align 4
  %5 = load i32, ptr %slot, align 4
  %call = call zeroext i1 @arg_slot_reg_p(i32 noundef %5)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %found_reg

if.end:                                           ; preds = %for.body
  %6 = load ptr, ptr %mov.addr, align 8
  %7 = load i32, ptr %i, align 4
  %idxprom1 = zext i32 %7 to i64
  %arrayidx2 = getelementptr %struct.TCGMovExtend, ptr %6, i64 %idxprom1
  %src3 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx2, i32 0, i32 1
  %8 = load i32, ptr %src3, align 4
  store i32 %8, ptr %src, align 4
  %9 = load ptr, ptr %mov.addr, align 8
  %10 = load i32, ptr %i, align 4
  %idxprom4 = zext i32 %10 to i64
  %arrayidx5 = getelementptr %struct.TCGMovExtend, ptr %9, i64 %idxprom4
  %dst_type6 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx5, i32 0, i32 2
  %11 = load i32, ptr %dst_type6, align 4
  store i32 %11, ptr %dst_type, align 4
  %12 = load i32, ptr %dst_type, align 4
  %cmp7 = icmp eq i32 %12, 0
  %cond = select i1 %cmp7, i32 2, i32 3
  store i32 %cond, ptr %dst_mo, align 4
  %13 = load ptr, ptr %mov.addr, align 8
  %14 = load i32, ptr %i, align 4
  %idxprom8 = zext i32 %14 to i64
  %arrayidx9 = getelementptr %struct.TCGMovExtend, ptr %13, i64 %idxprom8
  %src_ext = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx9, i32 0, i32 4
  %15 = load i32, ptr %src_ext, align 4
  %and = and i32 %15, 7
  %16 = load i32, ptr %dst_mo, align 4
  %cmp10 = icmp ne i32 %and, %16
  br i1 %cmp10, label %if.then11, label %if.end21

if.then11:                                        ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then11
  %17 = load ptr, ptr %parm.addr, align 8
  %ntmp = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %17, i32 0, i32 1
  %18 = load i32, ptr %ntmp, align 8
  %cmp12 = icmp ne i32 %18, 0
  br i1 %cmp12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %do.body
  unreachable

if.end14:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end14
  %19 = load ptr, ptr %parm.addr, align 8
  %tmp = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %19, i32 0, i32 2
  %arrayidx15 = getelementptr [3 x i32], ptr %tmp, i64 0, i64 0
  %20 = load i32, ptr %arrayidx15, align 4
  store i32 %20, ptr %src, align 4
  %21 = load ptr, ptr %mov.addr, align 8
  %22 = load i32, ptr %i, align 4
  %idxprom16 = zext i32 %22 to i64
  %arrayidx17 = getelementptr %struct.TCGMovExtend, ptr %21, i64 %idxprom16
  %dst18 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx17, i32 0, i32 0
  store i32 %20, ptr %dst18, align 4
  %23 = load ptr, ptr %s.addr, align 8
  %24 = load ptr, ptr %mov.addr, align 8
  %25 = load i32, ptr %i, align 4
  %idxprom19 = zext i32 %25 to i64
  %arrayidx20 = getelementptr %struct.TCGMovExtend, ptr %24, i64 %idxprom19
  call void @tcg_out_movext1(ptr noundef %23, ptr noundef %arrayidx20)
  br label %if.end21

if.end21:                                         ; preds = %do.end, %if.end
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load i32, ptr %dst_type, align 4
  %28 = load i32, ptr %src, align 4
  %29 = load i32, ptr %dst_type, align 4
  %30 = load i32, ptr %slot, align 4
  %call22 = call i32 @tcg_out_helper_stk_ofs(i32 noundef %29, i32 noundef %30)
  %conv = sext i32 %call22 to i64
  call void @tcg_out_st(ptr noundef %26, i32 noundef %27, i32 noundef %28, i32 noundef 4, i64 noundef %conv)
  br label %for.cond, !llvm.loop !112

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

found_reg:                                        ; preds = %if.then
  %31 = load i32, ptr %i, align 4
  %add = add i32 %31, 1
  store i32 %add, ptr %nmov.addr, align 4
  store i32 0, ptr %i, align 4
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc, %found_reg
  %32 = load i32, ptr %i, align 4
  %33 = load i32, ptr %nmov.addr, align 4
  %cmp24 = icmp ult i32 %32, %33
  br i1 %cmp24, label %for.body26, label %for.end35

for.body26:                                       ; preds = %for.cond23
  %34 = load ptr, ptr %mov.addr, align 8
  %35 = load i32, ptr %i, align 4
  %idxprom27 = zext i32 %35 to i64
  %arrayidx28 = getelementptr %struct.TCGMovExtend, ptr %34, i64 %idxprom27
  %dst29 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx28, i32 0, i32 0
  %36 = load i32, ptr %dst29, align 4
  %idxprom30 = zext i32 %36 to i64
  %arrayidx31 = getelementptr [6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 %idxprom30
  %37 = load i32, ptr %arrayidx31, align 4
  %38 = load ptr, ptr %mov.addr, align 8
  %39 = load i32, ptr %i, align 4
  %idxprom32 = zext i32 %39 to i64
  %arrayidx33 = getelementptr %struct.TCGMovExtend, ptr %38, i64 %idxprom32
  %dst34 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx33, i32 0, i32 0
  store i32 %37, ptr %dst34, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body26
  %40 = load i32, ptr %i, align 4
  %inc = add i32 %40, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond23, !llvm.loop !113

for.end35:                                        ; preds = %for.cond23
  %41 = load i32, ptr %nmov.addr, align 4
  switch i32 %41, label %sw.default [
    i32 4, label %sw.bb
    i32 3, label %sw.bb70
    i32 2, label %sw.bb77
    i32 1, label %sw.bb87
  ]

sw.bb:                                            ; preds = %for.end35
  br label %do.body36

do.body36:                                        ; preds = %sw.bb
  %42 = load ptr, ptr %parm.addr, align 8
  %ntmp37 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %42, i32 0, i32 1
  %43 = load i32, ptr %ntmp37, align 8
  %cmp38 = icmp uge i32 %43, 2
  br i1 %cmp38, label %if.end41, label %if.then40

if.then40:                                        ; preds = %do.body36
  unreachable

if.end41:                                         ; preds = %do.body36
  br label %do.end42

do.end42:                                         ; preds = %if.end41
  %44 = load ptr, ptr %mov.addr, align 8
  %arrayidx43 = getelementptr %struct.TCGMovExtend, ptr %44, i64 3
  %dst44 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx43, i32 0, i32 0
  %45 = load i32, ptr %dst44, align 4
  store i32 %45, ptr %dst3, align 4
  store i32 0, ptr %j, align 4
  br label %for.cond45

for.cond45:                                       ; preds = %for.inc66, %do.end42
  %46 = load i32, ptr %j, align 4
  %cmp46 = icmp ult i32 %46, 3
  br i1 %cmp46, label %for.body48, label %for.end68

for.body48:                                       ; preds = %for.cond45
  %47 = load i32, ptr %dst3, align 4
  %48 = load ptr, ptr %mov.addr, align 8
  %49 = load i32, ptr %j, align 4
  %idxprom49 = zext i32 %49 to i64
  %arrayidx50 = getelementptr %struct.TCGMovExtend, ptr %48, i64 %idxprom49
  %src51 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx50, i32 0, i32 1
  %50 = load i32, ptr %src51, align 4
  %cmp52 = icmp eq i32 %47, %50
  br i1 %cmp52, label %if.then54, label %if.end65

if.then54:                                        ; preds = %for.body48
  %51 = load ptr, ptr %parm.addr, align 8
  %tmp55 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %51, i32 0, i32 2
  %arrayidx56 = getelementptr [3 x i32], ptr %tmp55, i64 0, i64 1
  %52 = load i32, ptr %arrayidx56, align 4
  store i32 %52, ptr %scratch, align 4
  %53 = load ptr, ptr %s.addr, align 8
  %54 = load ptr, ptr %mov.addr, align 8
  %arrayidx57 = getelementptr %struct.TCGMovExtend, ptr %54, i64 3
  %src_type = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx57, i32 0, i32 3
  %55 = load i32, ptr %src_type, align 4
  %56 = load i32, ptr %scratch, align 4
  %57 = load ptr, ptr %mov.addr, align 8
  %arrayidx58 = getelementptr %struct.TCGMovExtend, ptr %57, i64 3
  %src59 = getelementptr inbounds %struct.TCGMovExtend, ptr %arrayidx58, i32 0, i32 1
  %58 = load i32, ptr %src59, align 4
  %call60 = call zeroext i1 @tcg_out_mov(ptr noundef %53, i32 noundef %55, i32 noundef %56, i32 noundef %58)
  %59 = load ptr, ptr %s.addr, align 8
  %60 = load ptr, ptr %mov.addr, align 8
  %61 = load ptr, ptr %mov.addr, align 8
  %add.ptr = getelementptr %struct.TCGMovExtend, ptr %61, i64 1
  %62 = load ptr, ptr %mov.addr, align 8
  %add.ptr61 = getelementptr %struct.TCGMovExtend, ptr %62, i64 2
  %63 = load ptr, ptr %parm.addr, align 8
  %tmp62 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %63, i32 0, i32 2
  %arrayidx63 = getelementptr [3 x i32], ptr %tmp62, i64 0, i64 0
  %64 = load i32, ptr %arrayidx63, align 4
  call void @tcg_out_movext3(ptr noundef %59, ptr noundef %60, ptr noundef %add.ptr, ptr noundef %add.ptr61, i32 noundef %64)
  %65 = load ptr, ptr %s.addr, align 8
  %66 = load ptr, ptr %mov.addr, align 8
  %arrayidx64 = getelementptr %struct.TCGMovExtend, ptr %66, i64 3
  %67 = load i32, ptr %scratch, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %65, ptr noundef %arrayidx64, i32 noundef %67)
  br label %for.end68

if.end65:                                         ; preds = %for.body48
  br label %for.inc66

for.inc66:                                        ; preds = %if.end65
  %68 = load i32, ptr %j, align 4
  %inc67 = add i32 %68, 1
  store i32 %inc67, ptr %j, align 4
  br label %for.cond45, !llvm.loop !114

for.end68:                                        ; preds = %if.then54, %for.cond45
  %69 = load ptr, ptr %s.addr, align 8
  %70 = load ptr, ptr %mov.addr, align 8
  %arrayidx69 = getelementptr %struct.TCGMovExtend, ptr %70, i64 3
  call void @tcg_out_movext1(ptr noundef %69, ptr noundef %arrayidx69)
  br label %sw.bb70

sw.bb70:                                          ; preds = %for.end68, %for.end35
  %71 = load ptr, ptr %s.addr, align 8
  %72 = load ptr, ptr %mov.addr, align 8
  %73 = load ptr, ptr %mov.addr, align 8
  %add.ptr71 = getelementptr %struct.TCGMovExtend, ptr %73, i64 1
  %74 = load ptr, ptr %mov.addr, align 8
  %add.ptr72 = getelementptr %struct.TCGMovExtend, ptr %74, i64 2
  %75 = load ptr, ptr %parm.addr, align 8
  %ntmp73 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %75, i32 0, i32 1
  %76 = load i32, ptr %ntmp73, align 8
  %tobool = icmp ne i32 %76, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb70
  %77 = load ptr, ptr %parm.addr, align 8
  %tmp74 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %77, i32 0, i32 2
  %arrayidx75 = getelementptr [3 x i32], ptr %tmp74, i64 0, i64 0
  %78 = load i32, ptr %arrayidx75, align 4
  br label %cond.end

cond.false:                                       ; preds = %sw.bb70
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond76 = phi i32 [ %78, %cond.true ], [ -1, %cond.false ]
  call void @tcg_out_movext3(ptr noundef %71, ptr noundef %72, ptr noundef %add.ptr71, ptr noundef %add.ptr72, i32 noundef %cond76)
  br label %sw.epilog

sw.bb77:                                          ; preds = %for.end35
  %79 = load ptr, ptr %s.addr, align 8
  %80 = load ptr, ptr %mov.addr, align 8
  %81 = load ptr, ptr %mov.addr, align 8
  %add.ptr78 = getelementptr %struct.TCGMovExtend, ptr %81, i64 1
  %82 = load ptr, ptr %parm.addr, align 8
  %ntmp79 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %82, i32 0, i32 1
  %83 = load i32, ptr %ntmp79, align 8
  %tobool80 = icmp ne i32 %83, 0
  br i1 %tobool80, label %cond.true81, label %cond.false84

cond.true81:                                      ; preds = %sw.bb77
  %84 = load ptr, ptr %parm.addr, align 8
  %tmp82 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %84, i32 0, i32 2
  %arrayidx83 = getelementptr [3 x i32], ptr %tmp82, i64 0, i64 0
  %85 = load i32, ptr %arrayidx83, align 4
  br label %cond.end85

cond.false84:                                     ; preds = %sw.bb77
  br label %cond.end85

cond.end85:                                       ; preds = %cond.false84, %cond.true81
  %cond86 = phi i32 [ %85, %cond.true81 ], [ -1, %cond.false84 ]
  call void @tcg_out_movext2(ptr noundef %79, ptr noundef %80, ptr noundef %add.ptr78, i32 noundef %cond86)
  br label %sw.epilog

sw.bb87:                                          ; preds = %for.end35
  %86 = load ptr, ptr %s.addr, align 8
  %87 = load ptr, ptr %mov.addr, align 8
  call void @tcg_out_movext1(ptr noundef %86, ptr noundef %87)
  br label %sw.epilog

sw.default:                                       ; preds = %for.end35
  br label %do.body88

do.body88:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5605, ptr noundef @__func__.tcg_out_helper_load_slots, ptr noundef null) #15
  unreachable

do.end89:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end89, %sw.bb87, %cond.end85, %cond.end, %for.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_helper_load_common_args(ptr noundef %s, ptr noundef %ldst, ptr noundef %parm, ptr noundef %info, i32 noundef %next_arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ldst.addr = alloca ptr, align 8
  %parm.addr = alloca ptr, align 8
  %info.addr = alloca ptr, align 8
  %next_arg.addr = alloca i32, align 4
  %ptr_mov = alloca %struct.TCGMovExtend, align 4
  %loc = alloca ptr, align 8
  %type = alloca i32, align 4
  %slot = alloca i32, align 4
  %imm = alloca i64, align 8
  %arg_reg = alloca i32, align 4
  %ra_reg = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ldst, ptr %ldst.addr, align 8
  store ptr %parm, ptr %parm.addr, align 8
  store ptr %info, ptr %info.addr, align 8
  store i32 %next_arg, ptr %next_arg.addr, align 4
  call void @llvm.memcpy.p0.p0.i64(ptr align 4 %ptr_mov, ptr align 4 @__const.tcg_out_helper_load_common_args.ptr_mov, i64 20, i1 false)
  %0 = load ptr, ptr %info.addr, align 8
  %in = getelementptr inbounds %struct.TCGHelperInfo, ptr %0, i32 0, i32 4
  %arrayidx = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in, i64 0, i64 0
  store ptr %arrayidx, ptr %loc, align 8
  %1 = load ptr, ptr %loc, align 8
  %bf.load = load i32, ptr %1, align 4
  %bf.lshr = lshr i32 %bf.load, 8
  %bf.clear = and i32 %bf.lshr, 255
  %dst = getelementptr inbounds %struct.TCGMovExtend, ptr %ptr_mov, i32 0, i32 0
  store i32 %bf.clear, ptr %dst, align 4
  %src = getelementptr inbounds %struct.TCGMovExtend, ptr %ptr_mov, i32 0, i32 1
  store i32 5, ptr %src, align 4
  %2 = load ptr, ptr %s.addr, align 8
  %3 = load ptr, ptr %parm.addr, align 8
  call void @tcg_out_helper_load_slots(ptr noundef %2, i32 noundef 1, ptr noundef %ptr_mov, ptr noundef %3)
  %4 = load ptr, ptr %ldst.addr, align 8
  %oi = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %4, i32 0, i32 1
  %5 = load i32, ptr %oi, align 4
  %conv = zext i32 %5 to i64
  store i64 %conv, ptr %imm, align 8
  %6 = load ptr, ptr %info.addr, align 8
  %in1 = getelementptr inbounds %struct.TCGHelperInfo, ptr %6, i32 0, i32 4
  %7 = load i32, ptr %next_arg.addr, align 4
  %idxprom = zext i32 %7 to i64
  %arrayidx2 = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in1, i64 0, i64 %idxprom
  store ptr %arrayidx2, ptr %loc, align 8
  store i32 0, ptr %type, align 4
  %8 = load ptr, ptr %loc, align 8
  %bf.load3 = load i32, ptr %8, align 4
  %bf.clear4 = and i32 %bf.load3, 255
  switch i32 %bf.clear4, label %sw.default [
    i32 0, label %sw.bb
    i32 3, label %sw.bb5
    i32 4, label %sw.bb5
  ]

sw.bb:                                            ; preds = %entry
  br label %sw.epilog

sw.bb5:                                           ; preds = %entry, %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb5
  %9 = load i64, ptr %imm, align 8
  %cmp = icmp ule i64 %9, 2147483647
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  store i32 1, ptr %type, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body7

do.body7:                                         ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5664, ptr noundef @__func__.tcg_out_helper_load_common_args, ptr noundef null) #15
  unreachable

do.end8:                                          ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end8, %do.end, %sw.bb
  %10 = load ptr, ptr %s.addr, align 8
  %11 = load ptr, ptr %loc, align 8
  %bf.load9 = load i32, ptr %11, align 4
  %bf.lshr10 = lshr i32 %bf.load9, 8
  %bf.clear11 = and i32 %bf.lshr10, 255
  %12 = load i32, ptr %type, align 4
  %13 = load i64, ptr %imm, align 8
  %14 = load ptr, ptr %parm.addr, align 8
  call void @tcg_out_helper_load_imm(ptr noundef %10, i32 noundef %bf.clear11, i32 noundef %12, i64 noundef %13, ptr noundef %14)
  %15 = load i32, ptr %next_arg.addr, align 4
  %inc = add i32 %15, 1
  store i32 %inc, ptr %next_arg.addr, align 4
  %16 = load ptr, ptr %info.addr, align 8
  %in12 = getelementptr inbounds %struct.TCGHelperInfo, ptr %16, i32 0, i32 4
  %17 = load i32, ptr %next_arg.addr, align 4
  %idxprom13 = zext i32 %17 to i64
  %arrayidx14 = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in12, i64 0, i64 %idxprom13
  store ptr %arrayidx14, ptr %loc, align 8
  %18 = load ptr, ptr %loc, align 8
  %bf.load15 = load i32, ptr %18, align 4
  %bf.lshr16 = lshr i32 %bf.load15, 8
  %bf.clear17 = and i32 %bf.lshr16, 255
  store i32 %bf.clear17, ptr %slot, align 4
  %19 = load ptr, ptr %parm.addr, align 8
  %ra_gen = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %ra_gen, align 8
  %tobool = icmp ne ptr %20, null
  br i1 %tobool, label %if.then18, label %if.else

if.then18:                                        ; preds = %sw.epilog
  store i32 -1, ptr %arg_reg, align 4
  %21 = load i32, ptr %slot, align 4
  %call = call zeroext i1 @arg_slot_reg_p(i32 noundef %21)
  br i1 %call, label %if.then19, label %if.end22

if.then19:                                        ; preds = %if.then18
  %22 = load i32, ptr %slot, align 4
  %idxprom20 = zext i32 %22 to i64
  %arrayidx21 = getelementptr [6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 %idxprom20
  %23 = load i32, ptr %arrayidx21, align 4
  store i32 %23, ptr %arg_reg, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.then18
  %24 = load ptr, ptr %parm.addr, align 8
  %ra_gen23 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %24, i32 0, i32 0
  %25 = load ptr, ptr %ra_gen23, align 8
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load ptr, ptr %ldst.addr, align 8
  %28 = load i32, ptr %arg_reg, align 4
  %call24 = call i32 %25(ptr noundef %26, ptr noundef %27, i32 noundef %28)
  store i32 %call24, ptr %ra_reg, align 4
  %29 = load i32, ptr %slot, align 4
  %dst25 = getelementptr inbounds %struct.TCGMovExtend, ptr %ptr_mov, i32 0, i32 0
  store i32 %29, ptr %dst25, align 4
  %30 = load i32, ptr %ra_reg, align 4
  %src26 = getelementptr inbounds %struct.TCGMovExtend, ptr %ptr_mov, i32 0, i32 1
  store i32 %30, ptr %src26, align 4
  %31 = load ptr, ptr %s.addr, align 8
  %32 = load ptr, ptr %parm.addr, align 8
  call void @tcg_out_helper_load_slots(ptr noundef %31, i32 noundef 1, ptr noundef %ptr_mov, ptr noundef %32)
  br label %if.end27

if.else:                                          ; preds = %sw.epilog
  %33 = load ptr, ptr %ldst.addr, align 8
  %raddr = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %33, i32 0, i32 7
  %34 = load ptr, ptr %raddr, align 8
  %35 = ptrtoint ptr %34 to i64
  store i64 %35, ptr %imm, align 8
  %36 = load ptr, ptr %s.addr, align 8
  %37 = load i32, ptr %slot, align 4
  %38 = load i64, ptr %imm, align 8
  %39 = load ptr, ptr %parm.addr, align 8
  call void @tcg_out_helper_load_imm(ptr noundef %36, i32 noundef %37, i32 noundef 1, i64 noundef %38, ptr noundef %39)
  br label %if.end27

if.end27:                                         ; preds = %if.else, %if.end22
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_movext1(ptr noundef %s, ptr noundef %i) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %i.addr = alloca ptr, align 8
  store ptr %s, ptr %s.addr, align 8
  store ptr %i, ptr %i.addr, align 8
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %i.addr, align 8
  %2 = load ptr, ptr %i.addr, align 8
  %src = getelementptr inbounds %struct.TCGMovExtend, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %src, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %0, ptr noundef %1, i32 noundef %3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @tcg_out_helper_stk_ofs(i32 noundef %type, i32 noundef %slot) #0 {
entry:
  %type.addr = alloca i32, align 4
  %slot.addr = alloca i32, align 4
  %ofs = alloca i32, align 4
  store i32 %type, ptr %type.addr, align 4
  store i32 %slot, ptr %slot.addr, align 4
  %0 = load i32, ptr %slot.addr, align 4
  %call = call i32 @arg_slot_stk_ofs(i32 noundef %0)
  store i32 %call, ptr %ofs, align 4
  %1 = load i32, ptr %ofs, align 4
  ret i32 %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_movext3(ptr noundef %s, ptr noundef %i1, ptr noundef %i2, ptr noundef %i3, i32 noundef %scratch) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %i1.addr = alloca ptr, align 8
  %i2.addr = alloca ptr, align 8
  %i3.addr = alloca ptr, align 8
  %scratch.addr = alloca i32, align 4
  %src1 = alloca i32, align 4
  %src2 = alloca i32, align 4
  %src34 = alloca i32, align 4
  %_a2 = alloca i32, align 4
  %_b3 = alloca i32, align 4
  %tmp = alloca i32, align 4
  %_a4 = alloca i32, align 4
  %_b5 = alloca i32, align 4
  %tmp36 = alloca i32, align 4
  %_a6 = alloca i32, align 4
  %_b7 = alloca i32, align 4
  %tmp64 = alloca i32, align 4
  %_a8 = alloca i32, align 4
  %_b9 = alloca i32, align 4
  %tmp74 = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %i1, ptr %i1.addr, align 8
  store ptr %i2, ptr %i2.addr, align 8
  store ptr %i3, ptr %i3.addr, align 8
  store i32 %scratch, ptr %scratch.addr, align 4
  %0 = load ptr, ptr %i1.addr, align 8
  %src = getelementptr inbounds %struct.TCGMovExtend, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %src, align 4
  store i32 %1, ptr %src1, align 4
  %2 = load ptr, ptr %i2.addr, align 8
  %src3 = getelementptr inbounds %struct.TCGMovExtend, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %src3, align 4
  store i32 %3, ptr %src2, align 4
  %4 = load ptr, ptr %i3.addr, align 8
  %src5 = getelementptr inbounds %struct.TCGMovExtend, ptr %4, i32 0, i32 1
  %5 = load i32, ptr %src5, align 4
  store i32 %5, ptr %src34, align 4
  %6 = load ptr, ptr %i1.addr, align 8
  %dst = getelementptr inbounds %struct.TCGMovExtend, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %dst, align 4
  %8 = load i32, ptr %src2, align 4
  %cmp = icmp ne i32 %7, %8
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %9 = load ptr, ptr %i1.addr, align 8
  %dst6 = getelementptr inbounds %struct.TCGMovExtend, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %dst6, align 4
  %11 = load i32, ptr %src34, align 4
  %cmp7 = icmp ne i32 %10, %11
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %12 = load ptr, ptr %s.addr, align 8
  %13 = load ptr, ptr %i1.addr, align 8
  call void @tcg_out_movext1(ptr noundef %12, ptr noundef %13)
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load ptr, ptr %i2.addr, align 8
  %16 = load ptr, ptr %i3.addr, align 8
  %17 = load i32, ptr %scratch.addr, align 4
  call void @tcg_out_movext2(ptr noundef %14, ptr noundef %15, ptr noundef %16, i32 noundef %17)
  br label %if.end97

if.end:                                           ; preds = %land.lhs.true, %entry
  %18 = load ptr, ptr %i2.addr, align 8
  %dst8 = getelementptr inbounds %struct.TCGMovExtend, ptr %18, i32 0, i32 0
  %19 = load i32, ptr %dst8, align 4
  %20 = load i32, ptr %src1, align 4
  %cmp9 = icmp ne i32 %19, %20
  br i1 %cmp9, label %land.lhs.true10, label %if.end14

land.lhs.true10:                                  ; preds = %if.end
  %21 = load ptr, ptr %i2.addr, align 8
  %dst11 = getelementptr inbounds %struct.TCGMovExtend, ptr %21, i32 0, i32 0
  %22 = load i32, ptr %dst11, align 4
  %23 = load i32, ptr %src34, align 4
  %cmp12 = icmp ne i32 %22, %23
  br i1 %cmp12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %land.lhs.true10
  %24 = load ptr, ptr %s.addr, align 8
  %25 = load ptr, ptr %i2.addr, align 8
  call void @tcg_out_movext1(ptr noundef %24, ptr noundef %25)
  %26 = load ptr, ptr %s.addr, align 8
  %27 = load ptr, ptr %i1.addr, align 8
  %28 = load ptr, ptr %i3.addr, align 8
  %29 = load i32, ptr %scratch.addr, align 4
  call void @tcg_out_movext2(ptr noundef %26, ptr noundef %27, ptr noundef %28, i32 noundef %29)
  br label %if.end97

if.end14:                                         ; preds = %land.lhs.true10, %if.end
  %30 = load ptr, ptr %i3.addr, align 8
  %dst15 = getelementptr inbounds %struct.TCGMovExtend, ptr %30, i32 0, i32 0
  %31 = load i32, ptr %dst15, align 4
  %32 = load i32, ptr %src1, align 4
  %cmp16 = icmp ne i32 %31, %32
  br i1 %cmp16, label %land.lhs.true17, label %if.end21

land.lhs.true17:                                  ; preds = %if.end14
  %33 = load ptr, ptr %i3.addr, align 8
  %dst18 = getelementptr inbounds %struct.TCGMovExtend, ptr %33, i32 0, i32 0
  %34 = load i32, ptr %dst18, align 4
  %35 = load i32, ptr %src2, align 4
  %cmp19 = icmp ne i32 %34, %35
  br i1 %cmp19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %land.lhs.true17
  %36 = load ptr, ptr %s.addr, align 8
  %37 = load ptr, ptr %i3.addr, align 8
  call void @tcg_out_movext1(ptr noundef %36, ptr noundef %37)
  %38 = load ptr, ptr %s.addr, align 8
  %39 = load ptr, ptr %i1.addr, align 8
  %40 = load ptr, ptr %i2.addr, align 8
  %41 = load i32, ptr %scratch.addr, align 4
  call void @tcg_out_movext2(ptr noundef %38, ptr noundef %39, ptr noundef %40, i32 noundef %41)
  br label %if.end97

if.end21:                                         ; preds = %land.lhs.true17, %if.end14
  %42 = load ptr, ptr %i1.addr, align 8
  %dst22 = getelementptr inbounds %struct.TCGMovExtend, ptr %42, i32 0, i32 0
  %43 = load i32, ptr %dst22, align 4
  %44 = load i32, ptr %src2, align 4
  %cmp23 = icmp eq i32 %43, %44
  br i1 %cmp23, label %land.lhs.true24, label %if.else52

land.lhs.true24:                                  ; preds = %if.end21
  %45 = load ptr, ptr %i2.addr, align 8
  %dst25 = getelementptr inbounds %struct.TCGMovExtend, ptr %45, i32 0, i32 0
  %46 = load i32, ptr %dst25, align 4
  %47 = load i32, ptr %src34, align 4
  %cmp26 = icmp eq i32 %46, %47
  br i1 %cmp26, label %land.lhs.true27, label %if.else52

land.lhs.true27:                                  ; preds = %land.lhs.true24
  %48 = load ptr, ptr %i3.addr, align 8
  %dst28 = getelementptr inbounds %struct.TCGMovExtend, ptr %48, i32 0, i32 0
  %49 = load i32, ptr %dst28, align 4
  %50 = load i32, ptr %src1, align 4
  %cmp29 = icmp eq i32 %49, %50
  br i1 %cmp29, label %if.then30, label %if.else52

if.then30:                                        ; preds = %land.lhs.true27
  %51 = load ptr, ptr %s.addr, align 8
  %52 = load ptr, ptr %i1.addr, align 8
  %src_type = getelementptr inbounds %struct.TCGMovExtend, ptr %52, i32 0, i32 3
  %53 = load i32, ptr %src_type, align 4
  store i32 %53, ptr %_a2, align 4
  %54 = load ptr, ptr %i2.addr, align 8
  %src_type31 = getelementptr inbounds %struct.TCGMovExtend, ptr %54, i32 0, i32 3
  %55 = load i32, ptr %src_type31, align 4
  store i32 %55, ptr %_b3, align 4
  %56 = load i32, ptr %_a2, align 4
  %57 = load i32, ptr %_b3, align 4
  %cmp32 = icmp ugt i32 %56, %57
  br i1 %cmp32, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then30
  %58 = load i32, ptr %_a2, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then30
  %59 = load i32, ptr %_b3, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %58, %cond.true ], [ %59, %cond.false ]
  store i32 %cond, ptr %tmp, align 4
  %60 = load i32, ptr %tmp, align 4
  %61 = load i32, ptr %src1, align 4
  %62 = load i32, ptr %src2, align 4
  %call = call zeroext i1 @tcg_out_xchg(ptr noundef %51, i32 noundef %60, i32 noundef %61, i32 noundef %62)
  br i1 %call, label %if.then33, label %if.else

if.then33:                                        ; preds = %cond.end
  %63 = load ptr, ptr %s.addr, align 8
  %64 = load ptr, ptr %i2.addr, align 8
  %src_type34 = getelementptr inbounds %struct.TCGMovExtend, ptr %64, i32 0, i32 3
  %65 = load i32, ptr %src_type34, align 4
  store i32 %65, ptr %_a4, align 4
  %66 = load ptr, ptr %i3.addr, align 8
  %src_type35 = getelementptr inbounds %struct.TCGMovExtend, ptr %66, i32 0, i32 3
  %67 = load i32, ptr %src_type35, align 4
  store i32 %67, ptr %_b5, align 4
  %68 = load i32, ptr %_a4, align 4
  %69 = load i32, ptr %_b5, align 4
  %cmp37 = icmp ugt i32 %68, %69
  br i1 %cmp37, label %cond.true38, label %cond.false39

cond.true38:                                      ; preds = %if.then33
  %70 = load i32, ptr %_a4, align 4
  br label %cond.end40

cond.false39:                                     ; preds = %if.then33
  %71 = load i32, ptr %_b5, align 4
  br label %cond.end40

cond.end40:                                       ; preds = %cond.false39, %cond.true38
  %cond41 = phi i32 [ %70, %cond.true38 ], [ %71, %cond.false39 ]
  store i32 %cond41, ptr %tmp36, align 4
  %72 = load i32, ptr %tmp36, align 4
  %73 = load i32, ptr %src2, align 4
  %74 = load i32, ptr %src34, align 4
  %call42 = call zeroext i1 @tcg_out_xchg(ptr noundef %63, i32 noundef %72, i32 noundef %73, i32 noundef %74)
  %75 = load ptr, ptr %s.addr, align 8
  %76 = load ptr, ptr %i1.addr, align 8
  %77 = load ptr, ptr %i1.addr, align 8
  %dst43 = getelementptr inbounds %struct.TCGMovExtend, ptr %77, i32 0, i32 0
  %78 = load i32, ptr %dst43, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %75, ptr noundef %76, i32 noundef %78)
  %79 = load ptr, ptr %s.addr, align 8
  %80 = load ptr, ptr %i2.addr, align 8
  %81 = load ptr, ptr %i2.addr, align 8
  %dst44 = getelementptr inbounds %struct.TCGMovExtend, ptr %81, i32 0, i32 0
  %82 = load i32, ptr %dst44, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %79, ptr noundef %80, i32 noundef %82)
  %83 = load ptr, ptr %s.addr, align 8
  %84 = load ptr, ptr %i3.addr, align 8
  %85 = load ptr, ptr %i3.addr, align 8
  %dst45 = getelementptr inbounds %struct.TCGMovExtend, ptr %85, i32 0, i32 0
  %86 = load i32, ptr %dst45, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %83, ptr noundef %84, i32 noundef %86)
  br label %if.end51

if.else:                                          ; preds = %cond.end
  br label %do.body

do.body:                                          ; preds = %if.else
  %87 = load i32, ptr %scratch.addr, align 4
  %cmp46 = icmp sge i32 %87, 0
  br i1 %cmp46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %do.body
  unreachable

if.end48:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end48
  %88 = load ptr, ptr %s.addr, align 8
  %89 = load ptr, ptr %i1.addr, align 8
  %src_type49 = getelementptr inbounds %struct.TCGMovExtend, ptr %89, i32 0, i32 3
  %90 = load i32, ptr %src_type49, align 4
  %91 = load i32, ptr %scratch.addr, align 4
  %92 = load i32, ptr %src1, align 4
  %call50 = call zeroext i1 @tcg_out_mov(ptr noundef %88, i32 noundef %90, i32 noundef %91, i32 noundef %92)
  %93 = load ptr, ptr %s.addr, align 8
  %94 = load ptr, ptr %i3.addr, align 8
  call void @tcg_out_movext1(ptr noundef %93, ptr noundef %94)
  %95 = load ptr, ptr %s.addr, align 8
  %96 = load ptr, ptr %i2.addr, align 8
  call void @tcg_out_movext1(ptr noundef %95, ptr noundef %96)
  %97 = load ptr, ptr %s.addr, align 8
  %98 = load ptr, ptr %i1.addr, align 8
  %99 = load i32, ptr %scratch.addr, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %97, ptr noundef %98, i32 noundef %99)
  br label %if.end51

if.end51:                                         ; preds = %do.end, %cond.end40
  br label %if.end97

if.else52:                                        ; preds = %land.lhs.true27, %land.lhs.true24, %if.end21
  %100 = load ptr, ptr %i1.addr, align 8
  %dst53 = getelementptr inbounds %struct.TCGMovExtend, ptr %100, i32 0, i32 0
  %101 = load i32, ptr %dst53, align 4
  %102 = load i32, ptr %src34, align 4
  %cmp54 = icmp eq i32 %101, %102
  br i1 %cmp54, label %land.lhs.true55, label %if.else93

land.lhs.true55:                                  ; preds = %if.else52
  %103 = load ptr, ptr %i2.addr, align 8
  %dst56 = getelementptr inbounds %struct.TCGMovExtend, ptr %103, i32 0, i32 0
  %104 = load i32, ptr %dst56, align 4
  %105 = load i32, ptr %src1, align 4
  %cmp57 = icmp eq i32 %104, %105
  br i1 %cmp57, label %land.lhs.true58, label %if.else93

land.lhs.true58:                                  ; preds = %land.lhs.true55
  %106 = load ptr, ptr %i3.addr, align 8
  %dst59 = getelementptr inbounds %struct.TCGMovExtend, ptr %106, i32 0, i32 0
  %107 = load i32, ptr %dst59, align 4
  %108 = load i32, ptr %src2, align 4
  %cmp60 = icmp eq i32 %107, %108
  br i1 %cmp60, label %if.then61, label %if.else93

if.then61:                                        ; preds = %land.lhs.true58
  %109 = load ptr, ptr %s.addr, align 8
  %110 = load ptr, ptr %i2.addr, align 8
  %src_type62 = getelementptr inbounds %struct.TCGMovExtend, ptr %110, i32 0, i32 3
  %111 = load i32, ptr %src_type62, align 4
  store i32 %111, ptr %_a6, align 4
  %112 = load ptr, ptr %i3.addr, align 8
  %src_type63 = getelementptr inbounds %struct.TCGMovExtend, ptr %112, i32 0, i32 3
  %113 = load i32, ptr %src_type63, align 4
  store i32 %113, ptr %_b7, align 4
  %114 = load i32, ptr %_a6, align 4
  %115 = load i32, ptr %_b7, align 4
  %cmp65 = icmp ugt i32 %114, %115
  br i1 %cmp65, label %cond.true66, label %cond.false67

cond.true66:                                      ; preds = %if.then61
  %116 = load i32, ptr %_a6, align 4
  br label %cond.end68

cond.false67:                                     ; preds = %if.then61
  %117 = load i32, ptr %_b7, align 4
  br label %cond.end68

cond.end68:                                       ; preds = %cond.false67, %cond.true66
  %cond69 = phi i32 [ %116, %cond.true66 ], [ %117, %cond.false67 ]
  store i32 %cond69, ptr %tmp64, align 4
  %118 = load i32, ptr %tmp64, align 4
  %119 = load i32, ptr %src2, align 4
  %120 = load i32, ptr %src34, align 4
  %call70 = call zeroext i1 @tcg_out_xchg(ptr noundef %109, i32 noundef %118, i32 noundef %119, i32 noundef %120)
  br i1 %call70, label %if.then71, label %if.else84

if.then71:                                        ; preds = %cond.end68
  %121 = load ptr, ptr %s.addr, align 8
  %122 = load ptr, ptr %i1.addr, align 8
  %src_type72 = getelementptr inbounds %struct.TCGMovExtend, ptr %122, i32 0, i32 3
  %123 = load i32, ptr %src_type72, align 4
  store i32 %123, ptr %_a8, align 4
  %124 = load ptr, ptr %i2.addr, align 8
  %src_type73 = getelementptr inbounds %struct.TCGMovExtend, ptr %124, i32 0, i32 3
  %125 = load i32, ptr %src_type73, align 4
  store i32 %125, ptr %_b9, align 4
  %126 = load i32, ptr %_a8, align 4
  %127 = load i32, ptr %_b9, align 4
  %cmp75 = icmp ugt i32 %126, %127
  br i1 %cmp75, label %cond.true76, label %cond.false77

cond.true76:                                      ; preds = %if.then71
  %128 = load i32, ptr %_a8, align 4
  br label %cond.end78

cond.false77:                                     ; preds = %if.then71
  %129 = load i32, ptr %_b9, align 4
  br label %cond.end78

cond.end78:                                       ; preds = %cond.false77, %cond.true76
  %cond79 = phi i32 [ %128, %cond.true76 ], [ %129, %cond.false77 ]
  store i32 %cond79, ptr %tmp74, align 4
  %130 = load i32, ptr %tmp74, align 4
  %131 = load i32, ptr %src1, align 4
  %132 = load i32, ptr %src2, align 4
  %call80 = call zeroext i1 @tcg_out_xchg(ptr noundef %121, i32 noundef %130, i32 noundef %131, i32 noundef %132)
  %133 = load ptr, ptr %s.addr, align 8
  %134 = load ptr, ptr %i1.addr, align 8
  %135 = load ptr, ptr %i1.addr, align 8
  %dst81 = getelementptr inbounds %struct.TCGMovExtend, ptr %135, i32 0, i32 0
  %136 = load i32, ptr %dst81, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %133, ptr noundef %134, i32 noundef %136)
  %137 = load ptr, ptr %s.addr, align 8
  %138 = load ptr, ptr %i2.addr, align 8
  %139 = load ptr, ptr %i2.addr, align 8
  %dst82 = getelementptr inbounds %struct.TCGMovExtend, ptr %139, i32 0, i32 0
  %140 = load i32, ptr %dst82, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %137, ptr noundef %138, i32 noundef %140)
  %141 = load ptr, ptr %s.addr, align 8
  %142 = load ptr, ptr %i3.addr, align 8
  %143 = load ptr, ptr %i3.addr, align 8
  %dst83 = getelementptr inbounds %struct.TCGMovExtend, ptr %143, i32 0, i32 0
  %144 = load i32, ptr %dst83, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %141, ptr noundef %142, i32 noundef %144)
  br label %if.end92

if.else84:                                        ; preds = %cond.end68
  br label %do.body85

do.body85:                                        ; preds = %if.else84
  %145 = load i32, ptr %scratch.addr, align 4
  %cmp86 = icmp sge i32 %145, 0
  br i1 %cmp86, label %if.end88, label %if.then87

if.then87:                                        ; preds = %do.body85
  unreachable

if.end88:                                         ; preds = %do.body85
  br label %do.end89

do.end89:                                         ; preds = %if.end88
  %146 = load ptr, ptr %s.addr, align 8
  %147 = load ptr, ptr %i1.addr, align 8
  %src_type90 = getelementptr inbounds %struct.TCGMovExtend, ptr %147, i32 0, i32 3
  %148 = load i32, ptr %src_type90, align 4
  %149 = load i32, ptr %scratch.addr, align 4
  %150 = load i32, ptr %src1, align 4
  %call91 = call zeroext i1 @tcg_out_mov(ptr noundef %146, i32 noundef %148, i32 noundef %149, i32 noundef %150)
  %151 = load ptr, ptr %s.addr, align 8
  %152 = load ptr, ptr %i2.addr, align 8
  call void @tcg_out_movext1(ptr noundef %151, ptr noundef %152)
  %153 = load ptr, ptr %s.addr, align 8
  %154 = load ptr, ptr %i3.addr, align 8
  call void @tcg_out_movext1(ptr noundef %153, ptr noundef %154)
  %155 = load ptr, ptr %s.addr, align 8
  %156 = load ptr, ptr %i1.addr, align 8
  %157 = load i32, ptr %scratch.addr, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %155, ptr noundef %156, i32 noundef %157)
  br label %if.end92

if.end92:                                         ; preds = %do.end89, %cond.end78
  br label %if.end96

if.else93:                                        ; preds = %land.lhs.true58, %land.lhs.true55, %if.else52
  br label %do.body94

do.body94:                                        ; preds = %if.else93
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 632, ptr noundef @__func__.tcg_out_movext3, ptr noundef null) #15
  unreachable

do.end95:                                         ; No predecessors!
  br label %if.end96

if.end96:                                         ; preds = %do.end95, %if.end92
  br label %if.end97

if.end97:                                         ; preds = %if.end96, %if.end51, %if.then20, %if.then13, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_movext1_new_src(ptr noundef %s, ptr noundef %i, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %i.addr = alloca ptr, align 8
  %src.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %i, ptr %i.addr, align 8
  store i32 %src, ptr %src.addr, align 4
  %0 = load ptr, ptr %s.addr, align 8
  %1 = load ptr, ptr %i.addr, align 8
  %dst_type = getelementptr inbounds %struct.TCGMovExtend, ptr %1, i32 0, i32 2
  %2 = load i32, ptr %dst_type, align 4
  %3 = load ptr, ptr %i.addr, align 8
  %dst = getelementptr inbounds %struct.TCGMovExtend, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %dst, align 4
  %5 = load ptr, ptr %i.addr, align 8
  %src_type = getelementptr inbounds %struct.TCGMovExtend, ptr %5, i32 0, i32 3
  %6 = load i32, ptr %src_type, align 4
  %7 = load ptr, ptr %i.addr, align 8
  %src_ext = getelementptr inbounds %struct.TCGMovExtend, ptr %7, i32 0, i32 4
  %8 = load i32, ptr %src_ext, align 4
  %9 = load i32, ptr %src.addr, align 4
  call void @tcg_out_movext(ptr noundef %0, i32 noundef %2, i32 noundef %4, i32 noundef %6, i32 noundef %8, i32 noundef %9)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_movext2(ptr noundef %s, ptr noundef %i1, ptr noundef %i2, i32 noundef %scratch) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %i1.addr = alloca ptr, align 8
  %i2.addr = alloca ptr, align 8
  %scratch.addr = alloca i32, align 4
  %src1 = alloca i32, align 4
  %src2 = alloca i32, align 4
  %src1_type = alloca i32, align 4
  %src2_type = alloca i32, align 4
  %_a0 = alloca i32, align 4
  %_b1 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %i1, ptr %i1.addr, align 8
  store ptr %i2, ptr %i2.addr, align 8
  store i32 %scratch, ptr %scratch.addr, align 4
  %0 = load ptr, ptr %i1.addr, align 8
  %src = getelementptr inbounds %struct.TCGMovExtend, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %src, align 4
  store i32 %1, ptr %src1, align 4
  %2 = load ptr, ptr %i2.addr, align 8
  %src3 = getelementptr inbounds %struct.TCGMovExtend, ptr %2, i32 0, i32 1
  %3 = load i32, ptr %src3, align 4
  store i32 %3, ptr %src2, align 4
  %4 = load ptr, ptr %i1.addr, align 8
  %dst = getelementptr inbounds %struct.TCGMovExtend, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %dst, align 4
  %6 = load i32, ptr %src2, align 4
  %cmp = icmp ne i32 %5, %6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %s.addr, align 8
  %8 = load ptr, ptr %i1.addr, align 8
  call void @tcg_out_movext1(ptr noundef %7, ptr noundef %8)
  %9 = load ptr, ptr %s.addr, align 8
  %10 = load ptr, ptr %i2.addr, align 8
  call void @tcg_out_movext1(ptr noundef %9, ptr noundef %10)
  br label %return

if.end:                                           ; preds = %entry
  %11 = load ptr, ptr %i2.addr, align 8
  %dst4 = getelementptr inbounds %struct.TCGMovExtend, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %dst4, align 4
  %13 = load i32, ptr %src1, align 4
  %cmp5 = icmp eq i32 %12, %13
  br i1 %cmp5, label %if.then6, label %if.end17

if.then6:                                         ; preds = %if.end
  %14 = load ptr, ptr %i1.addr, align 8
  %src_type = getelementptr inbounds %struct.TCGMovExtend, ptr %14, i32 0, i32 3
  %15 = load i32, ptr %src_type, align 4
  store i32 %15, ptr %src1_type, align 4
  %16 = load ptr, ptr %i2.addr, align 8
  %src_type7 = getelementptr inbounds %struct.TCGMovExtend, ptr %16, i32 0, i32 3
  %17 = load i32, ptr %src_type7, align 4
  store i32 %17, ptr %src2_type, align 4
  %18 = load ptr, ptr %s.addr, align 8
  %19 = load i32, ptr %src1_type, align 4
  store i32 %19, ptr %_a0, align 4
  %20 = load i32, ptr %src2_type, align 4
  store i32 %20, ptr %_b1, align 4
  %21 = load i32, ptr %_a0, align 4
  %22 = load i32, ptr %_b1, align 4
  %cmp8 = icmp ugt i32 %21, %22
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then6
  %23 = load i32, ptr %_a0, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then6
  %24 = load i32, ptr %_b1, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %23, %cond.true ], [ %24, %cond.false ]
  store i32 %cond, ptr %tmp, align 4
  %25 = load i32, ptr %tmp, align 4
  %26 = load i32, ptr %src1, align 4
  %27 = load i32, ptr %src2, align 4
  %call = call zeroext i1 @tcg_out_xchg(ptr noundef %18, i32 noundef %25, i32 noundef %26, i32 noundef %27)
  br i1 %call, label %if.then9, label %if.else

if.then9:                                         ; preds = %cond.end
  %28 = load ptr, ptr %i2.addr, align 8
  %src10 = getelementptr inbounds %struct.TCGMovExtend, ptr %28, i32 0, i32 1
  %29 = load i32, ptr %src10, align 4
  store i32 %29, ptr %src1, align 4
  %30 = load ptr, ptr %i1.addr, align 8
  %src11 = getelementptr inbounds %struct.TCGMovExtend, ptr %30, i32 0, i32 1
  %31 = load i32, ptr %src11, align 4
  store i32 %31, ptr %src2, align 4
  br label %if.end16

if.else:                                          ; preds = %cond.end
  br label %do.body

do.body:                                          ; preds = %if.else
  %32 = load i32, ptr %scratch.addr, align 4
  %cmp12 = icmp sge i32 %32, 0
  br i1 %cmp12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %do.body
  unreachable

if.end14:                                         ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end14
  %33 = load ptr, ptr %s.addr, align 8
  %34 = load i32, ptr %src1_type, align 4
  %35 = load i32, ptr %scratch.addr, align 4
  %36 = load i32, ptr %src1, align 4
  %call15 = call zeroext i1 @tcg_out_mov(ptr noundef %33, i32 noundef %34, i32 noundef %35, i32 noundef %36)
  %37 = load i32, ptr %scratch.addr, align 4
  store i32 %37, ptr %src1, align 4
  br label %if.end16

if.end16:                                         ; preds = %do.end, %if.then9
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end
  %38 = load ptr, ptr %s.addr, align 8
  %39 = load ptr, ptr %i2.addr, align 8
  %40 = load i32, ptr %src2, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %38, ptr noundef %39, i32 noundef %40)
  %41 = load ptr, ptr %s.addr, align 8
  %42 = load ptr, ptr %i1.addr, align 8
  %43 = load i32, ptr %src1, align 4
  call void @tcg_out_movext1_new_src(ptr noundef %41, ptr noundef %42, i32 noundef %43)
  br label %return

return:                                           ; preds = %if.end17, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @tcg_out_xchg(ptr noundef %s, i32 noundef %type, i32 noundef %r1, i32 noundef %r2) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %r1.addr = alloca i32, align 4
  %r2.addr = alloca i32, align 4
  %rexw = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store i32 %r1, ptr %r1.addr, align 4
  store i32 %r2, ptr %r2.addr, align 4
  %0 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %0, 0
  %cond = select i1 %cmp, i32 0, i32 4096
  store i32 %cond, ptr %rexw, align 4
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %rexw, align 4
  %add = add i32 135, %2
  %3 = load i32, ptr %r1.addr, align 4
  %4 = load i32, ptr %r2.addr, align 4
  call void @tcg_out_modrm(ptr noundef %1, i32 noundef %add, i32 noundef %3, i32 noundef %4)
  ret i1 true
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_movext(ptr noundef %s, i32 noundef %dst_type, i32 noundef %dst, i32 noundef %src_type, i32 noundef %src_ext, i32 noundef %src) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %dst_type.addr = alloca i32, align 4
  %dst.addr = alloca i32, align 4
  %src_type.addr = alloca i32, align 4
  %src_ext.addr = alloca i32, align 4
  %src.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %dst_type, ptr %dst_type.addr, align 4
  store i32 %dst, ptr %dst.addr, align 4
  store i32 %src_type, ptr %src_type.addr, align 4
  store i32 %src_ext, ptr %src_ext.addr, align 4
  store i32 %src, ptr %src.addr, align 4
  %0 = load i32, ptr %src_ext.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 8, label %sw.bb1
    i32 1, label %sw.bb2
    i32 9, label %sw.bb3
    i32 2, label %sw.bb4
    i32 10, label %sw.bb4
    i32 3, label %sw.bb21
  ]

sw.bb:                                            ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %dst.addr, align 4
  %3 = load i32, ptr %src.addr, align 4
  call void @tcg_out_ext8u(ptr noundef %1, i32 noundef %2, i32 noundef %3)
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  %4 = load ptr, ptr %s.addr, align 8
  %5 = load i32, ptr %dst_type.addr, align 4
  %6 = load i32, ptr %dst.addr, align 4
  %7 = load i32, ptr %src.addr, align 4
  call void @tcg_out_ext8s(ptr noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7)
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  %8 = load ptr, ptr %s.addr, align 8
  %9 = load i32, ptr %dst.addr, align 4
  %10 = load i32, ptr %src.addr, align 4
  call void @tcg_out_ext16u(ptr noundef %8, i32 noundef %9, i32 noundef %10)
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %11 = load ptr, ptr %s.addr, align 8
  %12 = load i32, ptr %dst_type.addr, align 4
  %13 = load i32, ptr %dst.addr, align 4
  %14 = load i32, ptr %src.addr, align 4
  call void @tcg_out_ext16s(ptr noundef %11, i32 noundef %12, i32 noundef %13, i32 noundef %14)
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry, %entry
  %15 = load i32, ptr %dst_type.addr, align 4
  %cmp = icmp eq i32 %15, 0
  br i1 %cmp, label %if.then, label %if.else7

if.then:                                          ; preds = %sw.bb4
  %16 = load i32, ptr %src_type.addr, align 4
  %cmp5 = icmp eq i32 %16, 0
  br i1 %cmp5, label %if.then6, label %if.else

if.then6:                                         ; preds = %if.then
  %17 = load ptr, ptr %s.addr, align 8
  %18 = load i32, ptr %dst.addr, align 4
  %19 = load i32, ptr %src.addr, align 4
  %call = call zeroext i1 @tcg_out_mov(ptr noundef %17, i32 noundef 0, i32 noundef %18, i32 noundef %19)
  br label %if.end

if.else:                                          ; preds = %if.then
  %20 = load ptr, ptr %s.addr, align 8
  %21 = load i32, ptr %dst.addr, align 4
  %22 = load i32, ptr %src.addr, align 4
  call void @tcg_out_extrl_i64_i32(ptr noundef %20, i32 noundef %21, i32 noundef %22)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then6
  br label %if.end20

if.else7:                                         ; preds = %sw.bb4
  %23 = load i32, ptr %src_type.addr, align 4
  %cmp8 = icmp eq i32 %23, 0
  br i1 %cmp8, label %if.then9, label %if.else13

if.then9:                                         ; preds = %if.else7
  %24 = load i32, ptr %src_ext.addr, align 4
  %and = and i32 %24, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.then9
  %25 = load ptr, ptr %s.addr, align 8
  %26 = load i32, ptr %dst.addr, align 4
  %27 = load i32, ptr %src.addr, align 4
  call void @tcg_out_exts_i32_i64(ptr noundef %25, i32 noundef %26, i32 noundef %27)
  br label %if.end12

if.else11:                                        ; preds = %if.then9
  %28 = load ptr, ptr %s.addr, align 8
  %29 = load i32, ptr %dst.addr, align 4
  %30 = load i32, ptr %src.addr, align 4
  call void @tcg_out_extu_i32_i64(ptr noundef %28, i32 noundef %29, i32 noundef %30)
  br label %if.end12

if.end12:                                         ; preds = %if.else11, %if.then10
  br label %if.end19

if.else13:                                        ; preds = %if.else7
  %31 = load i32, ptr %src_ext.addr, align 4
  %and14 = and i32 %31, 8
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then16, label %if.else17

if.then16:                                        ; preds = %if.else13
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load i32, ptr %dst.addr, align 4
  %34 = load i32, ptr %src.addr, align 4
  call void @tcg_out_ext32s(ptr noundef %32, i32 noundef %33, i32 noundef %34)
  br label %if.end18

if.else17:                                        ; preds = %if.else13
  %35 = load ptr, ptr %s.addr, align 8
  %36 = load i32, ptr %dst.addr, align 4
  %37 = load i32, ptr %src.addr, align 4
  call void @tcg_out_ext32u(ptr noundef %35, i32 noundef %36, i32 noundef %37)
  br label %if.end18

if.end18:                                         ; preds = %if.else17, %if.then16
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.end12
  br label %if.end20

if.end20:                                         ; preds = %if.end19, %if.end
  br label %sw.epilog

sw.bb21:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb21
  br label %do.end

do.end:                                           ; preds = %do.body
  %38 = load i32, ptr %dst_type.addr, align 4
  %cmp22 = icmp eq i32 %38, 0
  br i1 %cmp22, label %if.then23, label %if.else24

if.then23:                                        ; preds = %do.end
  %39 = load ptr, ptr %s.addr, align 8
  %40 = load i32, ptr %dst.addr, align 4
  %41 = load i32, ptr %src.addr, align 4
  call void @tcg_out_extrl_i64_i32(ptr noundef %39, i32 noundef %40, i32 noundef %41)
  br label %if.end26

if.else24:                                        ; preds = %do.end
  %42 = load ptr, ptr %s.addr, align 8
  %43 = load i32, ptr %dst.addr, align 4
  %44 = load i32, ptr %src.addr, align 4
  %call25 = call zeroext i1 @tcg_out_mov(ptr noundef %42, i32 noundef 1, i32 noundef %43, i32 noundef %44)
  br label %if.end26

if.end26:                                         ; preds = %if.else24, %if.then23
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body27

do.body27:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 504, ptr noundef @__func__.tcg_out_movext, ptr noundef null) #15
  unreachable

do.end28:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end28, %if.end26, %if.end20, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_helper_load_imm(ptr noundef %s, i32 noundef %slot, i32 noundef %type, i64 noundef %imm, ptr noundef %parm) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %slot.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %imm.addr = alloca i64, align 8
  %parm.addr = alloca ptr, align 8
  %ofs = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store i32 %slot, ptr %slot.addr, align 4
  store i32 %type, ptr %type.addr, align 4
  store i64 %imm, ptr %imm.addr, align 8
  store ptr %parm, ptr %parm.addr, align 8
  %0 = load i32, ptr %slot.addr, align 4
  %call = call zeroext i1 @arg_slot_reg_p(i32 noundef %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %type.addr, align 4
  %3 = load i32, ptr %slot.addr, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 %idxprom
  %4 = load i32, ptr %arrayidx, align 4
  %5 = load i64, ptr %imm.addr, align 8
  call void @tcg_out_movi(ptr noundef %1, i32 noundef %2, i32 noundef %4, i64 noundef %5)
  br label %if.end11

if.else:                                          ; preds = %entry
  %6 = load i32, ptr %type.addr, align 4
  %7 = load i32, ptr %slot.addr, align 4
  %call1 = call i32 @tcg_out_helper_stk_ofs(i32 noundef %6, i32 noundef %7)
  store i32 %call1, ptr %ofs, align 4
  %8 = load ptr, ptr %s.addr, align 8
  %9 = load i32, ptr %type.addr, align 4
  %10 = load i64, ptr %imm.addr, align 8
  %11 = load i32, ptr %ofs, align 4
  %conv = sext i32 %11 to i64
  %call2 = call zeroext i1 @tcg_out_sti(ptr noundef %8, i32 noundef %9, i64 noundef %10, i32 noundef 4, i64 noundef %conv)
  br i1 %call2, label %if.end10, label %if.then3

if.then3:                                         ; preds = %if.else
  br label %do.body

do.body:                                          ; preds = %if.then3
  %12 = load ptr, ptr %parm.addr, align 8
  %ntmp = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %12, i32 0, i32 1
  %13 = load i32, ptr %ntmp, align 8
  %cmp = icmp ne i32 %13, 0
  br i1 %cmp, label %if.end, label %if.then5

if.then5:                                         ; preds = %do.body
  unreachable

if.end:                                           ; preds = %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %14 = load ptr, ptr %s.addr, align 8
  %15 = load i32, ptr %type.addr, align 4
  %16 = load ptr, ptr %parm.addr, align 8
  %tmp = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %16, i32 0, i32 2
  %arrayidx6 = getelementptr [3 x i32], ptr %tmp, i64 0, i64 0
  %17 = load i32, ptr %arrayidx6, align 4
  %18 = load i64, ptr %imm.addr, align 8
  call void @tcg_out_movi(ptr noundef %14, i32 noundef %15, i32 noundef %17, i64 noundef %18)
  %19 = load ptr, ptr %s.addr, align 8
  %20 = load i32, ptr %type.addr, align 4
  %21 = load ptr, ptr %parm.addr, align 8
  %tmp7 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %21, i32 0, i32 2
  %arrayidx8 = getelementptr [3 x i32], ptr %tmp7, i64 0, i64 0
  %22 = load i32, ptr %arrayidx8, align 4
  %23 = load i32, ptr %ofs, align 4
  %conv9 = sext i32 %23 to i64
  call void @tcg_out_st(ptr noundef %19, i32 noundef %20, i32 noundef %22, i32 noundef 4, i64 noundef %conv9)
  br label %if.end10

if.end10:                                         ; preds = %do.end, %if.else
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ldst_ra_gen(ptr noundef %s, ptr noundef %l, i32 noundef %arg) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %l.addr = alloca ptr, align 8
  %arg.addr = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %l, ptr %l.addr, align 8
  store i32 %arg, ptr %arg.addr, align 4
  %0 = load i32, ptr %arg.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, ptr %arg.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr %s.addr, align 8
  %2 = load i32, ptr %arg.addr, align 4
  %3 = load ptr, ptr %l.addr, align 8
  %raddr = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %3, i32 0, i32 7
  %4 = load ptr, ptr %raddr, align 8
  %5 = ptrtoint ptr %4 to i64
  call void @tcg_out_movi(ptr noundef %1, i32 noundef 1, i32 noundef %2, i64 noundef %5)
  %6 = load i32, ptr %arg.addr, align 4
  ret i32 %6
}

declare i64 @helper_ldub_mmu(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #7

declare i64 @helper_lduw_mmu(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #7

declare i64 @helper_ldul_mmu(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #7

declare i64 @helper_ldq_mmu(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #7

declare { i64, i64 } @helper_ld16_mmu(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #7

declare i64 @helper_ldsb_mmu(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #7

declare i64 @helper_ldsw_mmu(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #7

declare i64 @helper_ldsl_mmu(ptr noundef, i64 noundef, i32 noundef, i64 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal void @tcg_out_st_helper_args(ptr noundef %s, ptr noundef %ldst, ptr noundef %parm) #0 {
entry:
  %s.addr = alloca ptr, align 8
  %ldst.addr = alloca ptr, align 8
  %parm.addr = alloca ptr, align 8
  %info = alloca ptr, align 8
  %loc = alloca ptr, align 8
  %mov = alloca [4 x %struct.TCGMovExtend], align 16
  %data_type = alloca i32, align 4
  %next_arg = alloca i32, align 4
  %nmov = alloca i32, align 4
  %n = alloca i32, align 4
  %mop = alloca i32, align 4
  store ptr %s, ptr %s.addr, align 8
  store ptr %ldst, ptr %ldst.addr, align 8
  store ptr %parm, ptr %parm.addr, align 8
  %0 = load ptr, ptr %ldst.addr, align 8
  %oi = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %0, i32 0, i32 1
  %1 = load i32, ptr %oi, align 4
  %call = call i32 @get_memop(i32 noundef %1)
  store i32 %call, ptr %mop, align 4
  %2 = load i32, ptr %mop, align 4
  %and = and i32 %2, 7
  switch i32 %and, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb1
    i32 4, label %sw.bb2
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  store ptr @info_helper_st32_mmu, ptr %info, align 8
  store i32 0, ptr %data_type, align 4
  br label %sw.epilog

sw.bb1:                                           ; preds = %entry
  store ptr @info_helper_st64_mmu, ptr %info, align 8
  store i32 1, ptr %data_type, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry
  store ptr @info_helper_st128_mmu, ptr %info, align 8
  store i32 2, ptr %data_type, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 5942, ptr noundef @__func__.tcg_out_st_helper_args, ptr noundef null) #15
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb2, %sw.bb1, %sw.bb
  store i32 1, ptr %next_arg, align 4
  store i32 0, ptr %nmov, align 4
  %3 = load ptr, ptr %info, align 8
  %in = getelementptr inbounds %struct.TCGHelperInfo, ptr %3, i32 0, i32 4
  %4 = load i32, ptr %next_arg, align 4
  %idxprom = zext i32 %4 to i64
  %arrayidx = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in, i64 0, i64 %idxprom
  store ptr %arrayidx, ptr %loc, align 8
  %arraydecay = getelementptr inbounds [4 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %5 = load ptr, ptr %loc, align 8
  %6 = load ptr, ptr %s.addr, align 8
  %addr_type = getelementptr inbounds %struct.TCGContext, ptr %6, i32 0, i32 10
  %7 = load i32, ptr %addr_type, align 4
  %8 = load ptr, ptr %ldst.addr, align 8
  %addrlo_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %8, i32 0, i32 3
  %9 = load i32, ptr %addrlo_reg, align 4
  %10 = load ptr, ptr %ldst.addr, align 8
  %addrhi_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %10, i32 0, i32 4
  %11 = load i32, ptr %addrhi_reg, align 8
  %call3 = call i32 @tcg_out_helper_add_mov(ptr noundef %arraydecay, ptr noundef %5, i32 noundef 1, i32 noundef %7, i32 noundef %9, i32 noundef %11)
  store i32 %call3, ptr %n, align 4
  %12 = load i32, ptr %n, align 4
  %13 = load i32, ptr %next_arg, align 4
  %add = add i32 %13, %12
  store i32 %add, ptr %next_arg, align 4
  %14 = load i32, ptr %n, align 4
  %15 = load i32, ptr %nmov, align 4
  %add4 = add i32 %15, %14
  store i32 %add4, ptr %nmov, align 4
  %16 = load ptr, ptr %info, align 8
  %in5 = getelementptr inbounds %struct.TCGHelperInfo, ptr %16, i32 0, i32 4
  %17 = load i32, ptr %next_arg, align 4
  %idxprom6 = zext i32 %17 to i64
  %arrayidx7 = getelementptr [14 x %struct.TCGCallArgumentLoc], ptr %in5, i64 0, i64 %idxprom6
  store ptr %arrayidx7, ptr %loc, align 8
  %18 = load ptr, ptr %loc, align 8
  %bf.load = load i32, ptr %18, align 4
  %bf.clear = and i32 %bf.load, 255
  switch i32 %bf.clear, label %sw.default68 [
    i32 0, label %sw.bb8
    i32 3, label %sw.bb8
    i32 4, label %sw.bb8
    i32 5, label %sw.bb14
  ]

sw.bb8:                                           ; preds = %sw.epilog, %sw.epilog, %sw.epilog
  %arraydecay9 = getelementptr inbounds [4 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %19 = load i32, ptr %nmov, align 4
  %idx.ext = zext i32 %19 to i64
  %add.ptr = getelementptr %struct.TCGMovExtend, ptr %arraydecay9, i64 %idx.ext
  %20 = load ptr, ptr %loc, align 8
  %21 = load i32, ptr %data_type, align 4
  %22 = load ptr, ptr %ldst.addr, align 8
  %type = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %22, i32 0, i32 2
  %23 = load i32, ptr %type, align 8
  %24 = load ptr, ptr %ldst.addr, align 8
  %datalo_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %24, i32 0, i32 5
  %25 = load i32, ptr %datalo_reg, align 4
  %26 = load ptr, ptr %ldst.addr, align 8
  %datahi_reg = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %26, i32 0, i32 6
  %27 = load i32, ptr %datahi_reg, align 8
  %call10 = call i32 @tcg_out_helper_add_mov(ptr noundef %add.ptr, ptr noundef %20, i32 noundef %21, i32 noundef %23, i32 noundef %25, i32 noundef %27)
  store i32 %call10, ptr %n, align 4
  %28 = load i32, ptr %n, align 4
  %29 = load i32, ptr %next_arg, align 4
  %add11 = add i32 %29, %28
  store i32 %add11, ptr %next_arg, align 4
  %30 = load i32, ptr %n, align 4
  %31 = load i32, ptr %nmov, align 4
  %add12 = add i32 %31, %30
  store i32 %add12, ptr %nmov, align 4
  %32 = load ptr, ptr %s.addr, align 8
  %33 = load i32, ptr %nmov, align 4
  %arraydecay13 = getelementptr inbounds [4 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %34 = load ptr, ptr %parm.addr, align 8
  call void @tcg_out_helper_load_slots(ptr noundef %32, i32 noundef %33, ptr noundef %arraydecay13, ptr noundef %34)
  br label %sw.epilog71

sw.bb14:                                          ; preds = %sw.epilog
  br label %do.body15

do.body15:                                        ; preds = %sw.bb14
  br label %do.end16

do.end16:                                         ; preds = %do.body15
  br label %do.body17

do.body17:                                        ; preds = %do.end16
  %35 = load i32, ptr %data_type, align 4
  %cmp = icmp eq i32 %35, 2
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %do.body17
  unreachable

if.end:                                           ; preds = %do.body17
  br label %do.end18

do.end18:                                         ; preds = %if.end
  %36 = load ptr, ptr %s.addr, align 8
  %37 = load ptr, ptr %ldst.addr, align 8
  %datalo_reg19 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %37, i32 0, i32 5
  %38 = load i32, ptr %datalo_reg19, align 4
  %39 = load ptr, ptr %loc, align 8
  %arrayidx20 = getelementptr %struct.TCGCallArgumentLoc, ptr %39, i64 0
  %bf.load21 = load i32, ptr %arrayidx20, align 4
  %bf.lshr = lshr i32 %bf.load21, 16
  %bf.clear22 = and i32 %bf.lshr, 255
  %call23 = call i32 @arg_slot_stk_ofs(i32 noundef %bf.clear22)
  %conv = sext i32 %call23 to i64
  call void @tcg_out_st(ptr noundef %36, i32 noundef 1, i32 noundef %38, i32 noundef 4, i64 noundef %conv)
  %40 = load ptr, ptr %s.addr, align 8
  %41 = load ptr, ptr %ldst.addr, align 8
  %datahi_reg24 = getelementptr inbounds %struct.TCGLabelQemuLdst, ptr %41, i32 0, i32 6
  %42 = load i32, ptr %datahi_reg24, align 8
  %43 = load ptr, ptr %loc, align 8
  %arrayidx25 = getelementptr %struct.TCGCallArgumentLoc, ptr %43, i64 1
  %bf.load26 = load i32, ptr %arrayidx25, align 4
  %bf.lshr27 = lshr i32 %bf.load26, 16
  %bf.clear28 = and i32 %bf.lshr27, 255
  %call29 = call i32 @arg_slot_stk_ofs(i32 noundef %bf.clear28)
  %conv30 = sext i32 %call29 to i64
  call void @tcg_out_st(ptr noundef %40, i32 noundef 1, i32 noundef %42, i32 noundef 4, i64 noundef %conv30)
  %44 = load ptr, ptr %s.addr, align 8
  %45 = load i32, ptr %nmov, align 4
  %arraydecay31 = getelementptr inbounds [4 x %struct.TCGMovExtend], ptr %mov, i64 0, i64 0
  %46 = load ptr, ptr %parm.addr, align 8
  call void @tcg_out_helper_load_slots(ptr noundef %44, i32 noundef %45, ptr noundef %arraydecay31, ptr noundef %46)
  %47 = load ptr, ptr %loc, align 8
  %bf.load32 = load i32, ptr %47, align 4
  %bf.lshr33 = lshr i32 %bf.load32, 8
  %bf.clear34 = and i32 %bf.lshr33, 255
  %call35 = call zeroext i1 @arg_slot_reg_p(i32 noundef %bf.clear34)
  br i1 %call35, label %if.then36, label %if.else

if.then36:                                        ; preds = %do.end18
  %48 = load ptr, ptr %s.addr, align 8
  %49 = load ptr, ptr %loc, align 8
  %bf.load37 = load i32, ptr %49, align 4
  %bf.lshr38 = lshr i32 %bf.load37, 8
  %bf.clear39 = and i32 %bf.lshr38, 255
  %idxprom40 = zext i32 %bf.clear39 to i64
  %arrayidx41 = getelementptr [6 x i32], ptr @tcg_target_call_iarg_regs, i64 0, i64 %idxprom40
  %50 = load i32, ptr %arrayidx41, align 4
  %51 = load ptr, ptr %loc, align 8
  %bf.load42 = load i32, ptr %51, align 4
  %bf.lshr43 = lshr i32 %bf.load42, 16
  %bf.clear44 = and i32 %bf.lshr43, 255
  %call45 = call i32 @arg_slot_stk_ofs(i32 noundef %bf.clear44)
  %conv46 = sext i32 %call45 to i64
  call void @tcg_out_addi_ptr(ptr noundef %48, i32 noundef %50, i32 noundef 4, i64 noundef %conv46)
  br label %if.end66

if.else:                                          ; preds = %do.end18
  br label %do.body47

do.body47:                                        ; preds = %if.else
  %52 = load ptr, ptr %parm.addr, align 8
  %ntmp = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %52, i32 0, i32 1
  %53 = load i32, ptr %ntmp, align 8
  %cmp48 = icmp ne i32 %53, 0
  br i1 %cmp48, label %if.end51, label %if.then50

if.then50:                                        ; preds = %do.body47
  unreachable

if.end51:                                         ; preds = %do.body47
  br label %do.end52

do.end52:                                         ; preds = %if.end51
  %54 = load ptr, ptr %s.addr, align 8
  %55 = load ptr, ptr %parm.addr, align 8
  %tmp = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %55, i32 0, i32 2
  %arrayidx53 = getelementptr [3 x i32], ptr %tmp, i64 0, i64 0
  %56 = load i32, ptr %arrayidx53, align 4
  %57 = load ptr, ptr %loc, align 8
  %bf.load54 = load i32, ptr %57, align 4
  %bf.lshr55 = lshr i32 %bf.load54, 16
  %bf.clear56 = and i32 %bf.lshr55, 255
  %call57 = call i32 @arg_slot_stk_ofs(i32 noundef %bf.clear56)
  %conv58 = sext i32 %call57 to i64
  call void @tcg_out_addi_ptr(ptr noundef %54, i32 noundef %56, i32 noundef 4, i64 noundef %conv58)
  %58 = load ptr, ptr %s.addr, align 8
  %59 = load ptr, ptr %parm.addr, align 8
  %tmp59 = getelementptr inbounds %struct.TCGLdstHelperParam, ptr %59, i32 0, i32 2
  %arrayidx60 = getelementptr [3 x i32], ptr %tmp59, i64 0, i64 0
  %60 = load i32, ptr %arrayidx60, align 4
  %61 = load ptr, ptr %loc, align 8
  %bf.load61 = load i32, ptr %61, align 4
  %bf.lshr62 = lshr i32 %bf.load61, 8
  %bf.clear63 = and i32 %bf.lshr62, 255
  %call64 = call i32 @arg_slot_stk_ofs(i32 noundef %bf.clear63)
  %conv65 = sext i32 %call64 to i64
  call void @tcg_out_st(ptr noundef %58, i32 noundef 1, i32 noundef %60, i32 noundef 4, i64 noundef %conv65)
  br label %if.end66

if.end66:                                         ; preds = %do.end52, %if.then36
  %62 = load i32, ptr %next_arg, align 4
  %add67 = add i32 %62, 2
  store i32 %add67, ptr %next_arg, align 4
  br label %sw.epilog71

sw.default68:                                     ; preds = %sw.epilog
  br label %do.body69

do.body69:                                        ; preds = %sw.default68
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.1, i32 noundef 6010, ptr noundef @__func__.tcg_out_st_helper_args, ptr noundef null) #15
  unreachable

do.end70:                                         ; No predecessors!
  br label %sw.epilog71

sw.epilog71:                                      ; preds = %do.end70, %if.end66, %sw.bb8
  %63 = load ptr, ptr %s.addr, align 8
  %64 = load ptr, ptr %ldst.addr, align 8
  %65 = load ptr, ptr %parm.addr, align 8
  %66 = load ptr, ptr %info, align 8
  %67 = load i32, ptr %next_arg, align 4
  call void @tcg_out_helper_load_common_args(ptr noundef %63, ptr noundef %64, ptr noundef %65, ptr noundef %66, i32 noundef %67)
  ret void
}

declare void @helper_stb_mmu(ptr noundef, i64 noundef, i32 noundef, i32 noundef, i64 noundef) #7

declare void @helper_stw_mmu(ptr noundef, i64 noundef, i32 noundef, i32 noundef, i64 noundef) #7

declare void @helper_stl_mmu(ptr noundef, i64 noundef, i32 noundef, i32 noundef, i64 noundef) #7

declare void @helper_stq_mmu(ptr noundef, i64 noundef, i64 noundef, i32 noundef, i64 noundef) #7

declare void @helper_st16_mmu(ptr noundef, i64 noundef, i64 noundef, i64 noundef, i32 noundef, i64 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @find_string(ptr noundef %strtab, ptr noundef %str) #0 {
entry:
  %strtab.addr = alloca ptr, align 8
  %str.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %strtab, ptr %strtab.addr, align 8
  store ptr %str, ptr %str.addr, align 8
  %0 = load ptr, ptr %strtab.addr, align 8
  %add.ptr = getelementptr i8, ptr %0, i64 1
  store ptr %add.ptr, ptr %p, align 8
  br label %while.body

while.body:                                       ; preds = %if.end, %entry
  %1 = load ptr, ptr %p, align 8
  %2 = load ptr, ptr %str.addr, align 8
  %call = call i32 @strcmp(ptr noundef %1, ptr noundef %2) #18
  %cmp = icmp eq i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %3 = load ptr, ptr %p, align 8
  %4 = load ptr, ptr %strtab.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %3 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  ret i32 %conv

if.end:                                           ; preds = %while.body
  %5 = load ptr, ptr %p, align 8
  %call1 = call i64 @strlen(ptr noundef %5) #18
  %add = add i64 %call1, 1
  %6 = load ptr, ptr %p, align 8
  %add.ptr2 = getelementptr i8, ptr %6, i64 %add
  store ptr %add.ptr2, ptr %p, align 8
  br label %while.body
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #12

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #12

attributes #0 = { nounwind sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #2 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #3 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { noreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #5 = { nocallback nofree nosync nounwind willreturn }
attributes #6 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { convergent nocallback nofree nosync nounwind willreturn memory(none) }
attributes #9 = { noreturn "dontcall-error"="code path is reachable" "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { allocsize(0,1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #12 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #13 = { noreturn nounwind sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #14 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #15 = { noreturn }
attributes #16 = { allocsize(0) }
attributes #17 = { allocsize(0,1) }
attributes #18 = { nounwind willreturn memory(read) }
attributes #19 = { noreturn nounwind }
attributes #20 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = !{i32 -2138823156}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = !{i64 201918}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
!88 = distinct !{!88, !6}
!89 = distinct !{!89, !6}
!90 = distinct !{!90, !6}
!91 = distinct !{!91, !6}
!92 = distinct !{!92, !6}
!93 = distinct !{!93, !6}
!94 = distinct !{!94, !6}
!95 = distinct !{!95, !6}
!96 = distinct !{!96, !6}
!97 = distinct !{!97, !6}
!98 = distinct !{!98, !6}
!99 = distinct !{!99, !6}
!100 = distinct !{!100, !6}
!101 = distinct !{!101, !6}
!102 = distinct !{!102, !6}
!103 = distinct !{!103, !6}
!104 = distinct !{!104, !6}
!105 = distinct !{!105, !6}
!106 = distinct !{!106, !6}
!107 = distinct !{!107, !6}
!108 = distinct !{!108, !6}
!109 = distinct !{!109, !6}
!110 = distinct !{!110, !6}
!111 = distinct !{!111, !6}
!112 = distinct !{!112, !6}
!113 = distinct !{!113, !6}
!114 = distinct !{!114, !6}
