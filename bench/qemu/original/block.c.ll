target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.anon.10 = type { ptr }
%union.anon.11 = type { %struct.QTailQLink }
%struct.QTailQLink = type { ptr, ptr }
%struct.anon.12 = type { ptr, ptr, ptr }
%struct.QEnumLookup = type { ptr, ptr, i32 }
%struct.BlockDriver = type { ptr, i32, i8, i8, i8, i8, i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, %struct.anon.9, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%struct.anon.9 = type { ptr, ptr }
%struct.BdrvChildClass = type { i8, i8, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr }
%union.anon.16 = type { %struct.QTailQLink }
%struct.QemuOptDesc = type { ptr, i32, ptr, ptr }
%struct.TransactionActionDrv = type { ptr, ptr, ptr }
%struct.perm_name = type { i64, ptr }
%union.anon.20 = type { %struct.QTailQLink }
%struct.QemuMutex = type { %union.pthread_mutex_t, i8 }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { ptr, ptr }
%struct.QemuEvent = type { i32, i8 }
%struct.BlockDriverState = type { i32, i8, i8, i8, i8, i8, ptr, ptr, ptr, %struct.anon, i8, [4096 x i8], [4096 x i8], [4096 x i8], [16 x i8], ptr, [4096 x i8], %struct.BlockLimits, i32, i32, i32, i32, [32 x i8], %union.anon, %union.anon.0, %union.anon.1, i32, [16 x %struct.anon.2], ptr, %struct.anon.3, ptr, ptr, %struct.anon.4, ptr, ptr, i32, ptr, i64, i64, %struct.QemuMutex, %struct.anon.5, %struct.Stat64, i32, i32, i32, i32, i32, i32, %struct.QemuMutex, %struct.anon.6, %struct.CoQueue, i8, i32, i8, %struct.CoMutex, ptr, ptr }
%struct.anon = type { ptr }
%struct.BlockLimits = type { i32, i64, i32, i64, i32, i32, i32, i64, i32, i64, i64, i32, i8, i32, i32, i32, i32, i32, i32, i32 }
%union.anon = type { %struct.QTailQLink }
%union.anon.0 = type { %struct.QTailQLink }
%union.anon.1 = type { %struct.QTailQLink }
%struct.anon.2 = type { ptr }
%struct.anon.3 = type { ptr }
%struct.anon.4 = type { ptr }
%struct.anon.5 = type { ptr }
%struct.Stat64 = type { i64 }
%struct.anon.6 = type { ptr }
%struct.CoQueue = type { %struct.anon.7 }
%struct.anon.7 = type { ptr, ptr }
%struct.CoMutex = type { i32, ptr, %struct.anon.8, %struct.anon.8, i32, i32, ptr }
%struct.anon.8 = type { ptr }
%struct._GString = type { ptr, i64, i64 }
%struct.QString = type { %struct.QObjectBase_, ptr }
%struct.QObjectBase_ = type { i32, i64 }
%struct.ErrorPropagator = type { ptr, ptr }
%struct.QDict = type { %struct.QObjectBase_, i64, [512 x %struct.anon.13] }
%struct.anon.13 = type { ptr }
%struct.QObject = type { %struct.QObjectBase_ }
%struct.GraphLockableMainloop = type {}
%struct.BdrvChild = type { ptr, ptr, ptr, i32, ptr, i64, i64, i8, i8, %struct.anon.14, %struct.anon.15 }
%struct.anon.14 = type { ptr, ptr }
%struct.anon.15 = type { ptr, ptr }
%struct.BdrvChildSetPermState = type { ptr, i64, i64 }
%struct.BdrvAttachChildCommonState = type { ptr, ptr, ptr }
%struct.QDictEntry = type { ptr, ptr, %struct.anon.27 }
%struct.anon.27 = type { ptr, ptr }
%struct.BlockdevRef = type { i32, %union.anon.17 }
%union.anon.17 = type { %struct.BlockdevOptions }
%struct.BlockdevOptions = type { i32, ptr, i8, i32, ptr, i8, i8, i8, i8, i8, i8, i8, i32, %union.anon.18 }
%union.anon.18 = type { %struct.BlockdevOptionsBlkdebug }
%struct.BlockdevOptionsBlkdebug = type { ptr, ptr, i8, i64, i8, i32, i8, i32, i8, i32, i8, i32, i8, i32, i8, ptr, i8, ptr, i8, ptr, i8, ptr }
%struct.BlockReopenQueueEntry = type { i8, %struct.BDRVReopenState, %union.anon.19 }
%struct.BDRVReopenState = type { ptr, i32, i32, i8, ptr, ptr, ptr, ptr, ptr }
%union.anon.19 = type { %struct.QTailQLink }
%struct._GSList = type { ptr, ptr }
%struct.BdrvReplaceChildState = type { ptr, ptr }
%struct.BlockDeviceInfoList = type { ptr, ptr }
%struct.QemuLockable = type { ptr, ptr, ptr }
%struct.BlockJob = type { %struct.Job, i32, i64, %struct.RateLimit, ptr, %struct.Notifier, %struct.Notifier, %struct.Notifier, %struct.Notifier, %struct.Notifier, ptr }
%struct.Job = type { ptr, ptr, ptr, i8, i8, ptr, ptr, %struct.ProgressMeter, ptr, i32, i32, %struct.QEMUTimer, i32, i8, i8, i8, i8, i8, i8, i32, ptr, %struct.NotifierList, %struct.NotifierList, %struct.NotifierList, %struct.NotifierList, %struct.NotifierList, %struct.anon.22, ptr, %struct.anon.23 }
%struct.ProgressMeter = type { i64, i64, %struct.QemuMutex }
%struct.QEMUTimer = type { i64, ptr, ptr, ptr, ptr, i32, i32 }
%struct.NotifierList = type { %struct.anon.21 }
%struct.anon.21 = type { ptr }
%struct.anon.22 = type { ptr, ptr }
%struct.anon.23 = type { ptr, ptr }
%struct.RateLimit = type { %struct.QemuMutex, i64, i64, i64, i64, i64 }
%struct.Notifier = type { ptr, %struct.anon.24 }
%struct.anon.24 = type { ptr, ptr }
%struct.XDbgBlockGraphConstructor = type { ptr, ptr }
%struct.XDbgBlockGraphNode = type { i64, i32, ptr }
%struct.XDbgBlockGraphNodeList = type { ptr, ptr }
%struct.XDbgBlockGraph = type { ptr, ptr }
%struct.XDbgBlockGraphEdge = type { i64, i64, ptr, ptr, ptr }
%struct.BlockPermissionList = type { ptr, i32 }
%struct.XDbgBlockGraphEdgeList = type { ptr, ptr }
%struct.BlockDriverInfo = type { i32, i32, i64, i8, i8 }
%struct.BdrvNextIterator = type { i32, ptr, ptr }
%struct.BdrvOpBlocker = type { ptr, %struct.anon.25 }
%struct.anon.25 = type { ptr, ptr }
%struct.BdrvStateSetAioContext = type { ptr, ptr }
%struct.BdrvAioNotifier = type { ptr, ptr, ptr, i8, %struct.anon.26 }
%struct.anon.26 = type { ptr, ptr }
%struct.BdrvBlockStatusCache = type { %struct.rcu_head, i8, i64, i64 }
%struct.rcu_head = type { ptr, ptr }
%struct.BdrvSetInheritsFrom = type { ptr, ptr }
%struct.timeval = type { i64, i64 }
%struct.rcu_reader_data = type { i64, i8, i32, %struct.anon.28, %struct.NotifierList }
%struct.anon.28 = type { ptr, ptr }

@.str = private unnamed_addr constant [3 x i8] c":/\00", align 1
@.str.1 = private unnamed_addr constant [28 x i8] c"!path_is_absolute(filename)\00", align 1
@.str.2 = private unnamed_addr constant [16 x i8] c"../qemu/block.c\00", align 1
@__PRETTY_FUNCTION__.bdrv_parse_filename_strip_prefix = private unnamed_addr constant [75 x i8] c"void bdrv_parse_filename_strip_prefix(const char *, const char *, QDict *)\00", align 1
@.str.3 = private unnamed_addr constant [3 x i8] c"./\00", align 1
@.str.4 = private unnamed_addr constant [38 x i8] c"!path_has_protocol(fat_filename->str)\00", align 1
@.str.5 = private unnamed_addr constant [9 x i8] c"filename\00", align 1
@__func__.bdrv_apply_auto_read_only = private unnamed_addr constant [26 x i8] c"bdrv_apply_auto_read_only\00", align 1
@.str.6 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.7 = private unnamed_addr constant [19 x i8] c"Image is read-only\00", align 1
@.str.8 = private unnamed_addr constant [6 x i8] c"json:\00", align 1
@__func__.bdrv_get_full_backing_filename_from_filename = private unnamed_addr constant [45 x i8] c"bdrv_get_full_backing_filename_from_filename\00", align 1
@.str.9 = private unnamed_addr constant [48 x i8] c"Cannot use relative backing file names for '%s'\00", align 1
@.str.10 = private unnamed_addr constant [22 x i8] c"qemu_in_main_thread()\00", align 1
@__PRETTY_FUNCTION__.bdrv_get_full_backing_filename = private unnamed_addr constant [67 x i8] c"char *bdrv_get_full_backing_filename(BlockDriverState *, Error **)\00", align 1
@.str.11 = private unnamed_addr constant [18 x i8] c"bdrv->format_name\00", align 1
@__PRETTY_FUNCTION__.bdrv_register = private unnamed_addr constant [34 x i8] c"void bdrv_register(BlockDriver *)\00", align 1
@bdrv_drivers = internal global %struct.anon.10 zeroinitializer, align 8
@__PRETTY_FUNCTION__.bdrv_new = private unnamed_addr constant [33 x i8] c"BlockDriverState *bdrv_new(void)\00", align 1
@bdrv_drain_all_count = external global i32, align 4
@all_bdrv_states = internal global %union.anon.11 { %struct.QTailQLink { ptr null, ptr @all_bdrv_states } }, align 8
@__PRETTY_FUNCTION__.bdrv_find_format = private unnamed_addr constant [44 x i8] c"BlockDriver *bdrv_find_format(const char *)\00", align 1
@block_driver_modules = internal constant [0 x %struct.anon.12] zeroinitializer, align 8
@.str.12 = private unnamed_addr constant [7 x i8] c"block-\00", align 1
@__PRETTY_FUNCTION__.bdrv_is_whitelisted = private unnamed_addr constant [46 x i8] c"int bdrv_is_whitelisted(BlockDriver *, _Bool)\00", align 1
@use_bdrv_whitelist = internal global i32 0, align 4
@__PRETTY_FUNCTION__.bdrv_co_create = private unnamed_addr constant [70 x i8] c"int bdrv_co_create(BlockDriver *, const char *, QemuOpts *, Error **)\00", align 1
@error_fatal = external global ptr, align 8
@.str.13 = private unnamed_addr constant [13 x i8] c"coroutine_fn\00", section "llvm.metadata"
@.str.14 = private unnamed_addr constant [111 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/block_int-common.h\00", section "llvm.metadata"
@__func__.bdrv_co_create = private unnamed_addr constant [15 x i8] c"bdrv_co_create\00", align 1
@.str.15 = private unnamed_addr constant [44 x i8] c"Driver '%s' does not support image creation\00", align 1
@.str.16 = private unnamed_addr constant [23 x i8] c"Could not create image\00", align 1
@__PRETTY_FUNCTION__.bdrv_co_create_opts_simple = private unnamed_addr constant [82 x i8] c"int bdrv_co_create_opts_simple(BlockDriver *, const char *, QemuOpts *, Error **)\00", align 1
@.str.17 = private unnamed_addr constant [5 x i8] c"size\00", align 1
@.str.18 = private unnamed_addr constant [14 x i8] c"preallocation\00", align 1
@PreallocMode_lookup = external constant %struct.QEnumLookup, align 8
@__func__.bdrv_co_create_opts_simple = private unnamed_addr constant [27 x i8] c"bdrv_co_create_opts_simple\00", align 1
@.str.19 = private unnamed_addr constant [36 x i8] c"Unsupported preallocation mode '%s'\00", align 1
@.str.20 = private unnamed_addr constant [7 x i8] c"driver\00", align 1
@.str.21 = private unnamed_addr constant [176 x i8] c"Protocol driver '%s' does not support creating new images, so an existing image must be selected as the target; however, opening the given target as an existing image failed: \00", align 1
@__PRETTY_FUNCTION__.bdrv_co_create_file = private unnamed_addr constant [60 x i8] c"int bdrv_co_create_file(const char *, QemuOpts *, Error **)\00", align 1
@__func__.bdrv_co_create_file = private unnamed_addr constant [20 x i8] c"bdrv_co_create_file\00", align 1
@.str.22 = private unnamed_addr constant [11 x i8] c"bs != NULL\00", align 1
@__PRETTY_FUNCTION__.bdrv_co_delete_file = private unnamed_addr constant [54 x i8] c"int bdrv_co_delete_file(BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_co_delete_file = private unnamed_addr constant [20 x i8] c"bdrv_co_delete_file\00", align 1
@.str.23 = private unnamed_addr constant [30 x i8] c"Block node '%s' is not opened\00", align 1
@.str.24 = private unnamed_addr constant [44 x i8] c"Driver '%s' does not support image deletion\00", align 1
@__PRETTY_FUNCTION__.bdrv_probe_blocksizes = private unnamed_addr constant [60 x i8] c"int bdrv_probe_blocksizes(BlockDriverState *, BlockSizes *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_probe_geometry = private unnamed_addr constant [58 x i8] c"int bdrv_probe_geometry(BlockDriverState *, HDGeometry *)\00", align 1
@.str.25 = private unnamed_addr constant [5 x i8] c"/tmp\00", align 1
@.str.26 = private unnamed_addr constant [9 x i8] c"/var/tmp\00", align 1
@.str.27 = private unnamed_addr constant [13 x i8] c"%s/vl.XXXXXX\00", align 1
@__func__.create_tmp_file = private unnamed_addr constant [16 x i8] c"create_tmp_file\00", align 1
@.str.28 = private unnamed_addr constant [35 x i8] c"Could not open temporary file '%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_find_protocol = private unnamed_addr constant [63 x i8] c"BlockDriver *bdrv_find_protocol(const char *, _Bool, Error **)\00", align 1
@bdrv_file = external global %struct.BlockDriver, align 8
@.str.29 = private unnamed_addr constant [10 x i8] c"p != NULL\00", align 1
@__func__.bdrv_find_protocol = private unnamed_addr constant [19 x i8] c"bdrv_find_protocol\00", align 1
@.str.30 = private unnamed_addr constant [22 x i8] c"Unknown protocol '%s'\00", align 1
@.str.31 = private unnamed_addr constant [8 x i8] c"threads\00", align 1
@.str.32 = private unnamed_addr constant [7 x i8] c"native\00", align 1
@.str.33 = private unnamed_addr constant [9 x i8] c"io_uring\00", align 1
@.str.34 = private unnamed_addr constant [4 x i8] c"off\00", align 1
@.str.35 = private unnamed_addr constant [7 x i8] c"ignore\00", align 1
@.str.36 = private unnamed_addr constant [3 x i8] c"on\00", align 1
@.str.37 = private unnamed_addr constant [6 x i8] c"unmap\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str.39 = private unnamed_addr constant [11 x i8] c"directsync\00", align 1
@.str.40 = private unnamed_addr constant [10 x i8] c"writeback\00", align 1
@.str.41 = private unnamed_addr constant [7 x i8] c"unsafe\00", align 1
@.str.42 = private unnamed_addr constant [13 x i8] c"writethrough\00", align 1
@child_of_bds = dso_local constant %struct.BdrvChildClass { i8 0, i8 1, ptr @bdrv_inherited_options, ptr null, ptr @bdrv_child_get_parent_desc, ptr null, ptr @bdrv_child_cb_inactivate, ptr @bdrv_child_cb_attach, ptr @bdrv_child_cb_detach, ptr @bdrv_child_cb_drained_begin, ptr @bdrv_child_cb_drained_end, ptr @bdrv_child_cb_drained_poll, ptr @bdrv_child_cb_update_filename, ptr @bdrv_child_cb_change_aio_ctx, ptr null, ptr null, ptr @child_of_bds_get_parent_aio_context }, align 8
@__PRETTY_FUNCTION__.bdrv_new_open_driver_opts = private unnamed_addr constant [97 x i8] c"BlockDriverState *bdrv_new_open_driver_opts(BlockDriver *, const char *, QDict *, int, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_new_open_driver = private unnamed_addr constant [83 x i8] c"BlockDriverState *bdrv_new_open_driver(BlockDriver *, const char *, int, Error **)\00", align 1
@.str.43 = private unnamed_addr constant [12 x i8] c"bdrv_common\00", align 1
@.str.44 = private unnamed_addr constant [10 x i8] c"node-name\00", align 1
@.str.45 = private unnamed_addr constant [35 x i8] c"Node name of the block device node\00", align 1
@.str.46 = private unnamed_addr constant [33 x i8] c"Block driver to use for the node\00", align 1
@.str.47 = private unnamed_addr constant [13 x i8] c"cache.direct\00", align 1
@.str.48 = private unnamed_addr constant [44 x i8] c"Bypass software writeback cache on the host\00", align 1
@.str.49 = private unnamed_addr constant [15 x i8] c"cache.no-flush\00", align 1
@.str.50 = private unnamed_addr constant [22 x i8] c"Ignore flush requests\00", align 1
@.str.51 = private unnamed_addr constant [10 x i8] c"read-only\00", align 1
@.str.52 = private unnamed_addr constant [33 x i8] c"Node is opened in read-only mode\00", align 1
@.str.53 = private unnamed_addr constant [15 x i8] c"auto-read-only\00", align 1
@.str.54 = private unnamed_addr constant [54 x i8] c"Node can become read-only if opening read-write fails\00", align 1
@.str.55 = private unnamed_addr constant [14 x i8] c"detect-zeroes\00", align 1
@.str.56 = private unnamed_addr constant [45 x i8] c"try to optimize zero writes (off, on, unmap)\00", align 1
@.str.57 = private unnamed_addr constant [8 x i8] c"discard\00", align 1
@.str.58 = private unnamed_addr constant [41 x i8] c"discard operation (ignore/off, unmap/on)\00", align 1
@.str.59 = private unnamed_addr constant [12 x i8] c"force-share\00", align 1
@.str.60 = private unnamed_addr constant [43 x i8] c"always accept other writers (default: off)\00", align 1
@bdrv_runtime_opts = dso_local global { ptr, ptr, i8, %union.anon.16, [10 x %struct.QemuOptDesc] } { ptr @.str.43, ptr null, i8 0, %union.anon.16 { %struct.QTailQLink { ptr null, ptr getelementptr (i8, ptr @bdrv_runtime_opts, i64 24) } }, [10 x %struct.QemuOptDesc] [%struct.QemuOptDesc { ptr @.str.44, i32 0, ptr @.str.45, ptr null }, %struct.QemuOptDesc { ptr @.str.20, i32 0, ptr @.str.46, ptr null }, %struct.QemuOptDesc { ptr @.str.47, i32 1, ptr @.str.48, ptr null }, %struct.QemuOptDesc { ptr @.str.49, i32 1, ptr @.str.50, ptr null }, %struct.QemuOptDesc { ptr @.str.51, i32 1, ptr @.str.52, ptr null }, %struct.QemuOptDesc { ptr @.str.53, i32 1, ptr @.str.54, ptr null }, %struct.QemuOptDesc { ptr @.str.55, i32 0, ptr @.str.56, ptr null }, %struct.QemuOptDesc { ptr @.str.57, i32 0, ptr @.str.58, ptr null }, %struct.QemuOptDesc { ptr @.str.59, i32 1, ptr @.str.60, ptr null }, %struct.QemuOptDesc zeroinitializer] }, align 8
@.str.62 = private unnamed_addr constant [19 x i8] c"simple-create-opts\00", align 1
@.str.63 = private unnamed_addr constant [18 x i8] c"Virtual disk size\00", align 1
@.str.64 = private unnamed_addr constant [41 x i8] c"Preallocation mode (allowed values: off)\00", align 1
@bdrv_create_opts_simple = dso_local global { ptr, ptr, i8, %union.anon.16, [3 x %struct.QemuOptDesc] } { ptr @.str.62, ptr null, i8 0, %union.anon.16 { %struct.QTailQLink { ptr null, ptr getelementptr (i8, ptr @bdrv_create_opts_simple, i64 24) } }, [3 x %struct.QemuOptDesc] [%struct.QemuOptDesc { ptr @.str.17, i32 3, ptr @.str.63, ptr null }, %struct.QemuOptDesc { ptr @.str.18, i32 0, ptr @.str.64, ptr null }, %struct.QemuOptDesc zeroinitializer] }, align 8
@bdrv_drv_set_perm_drv = dso_local global %struct.TransactionActionDrv { ptr @bdrv_drv_set_perm_abort, ptr @bdrv_drv_set_perm_commit, ptr null }, align 8
@__PRETTY_FUNCTION__.bdrv_get_cumulative_perm = private unnamed_addr constant [74 x i8] c"void bdrv_get_cumulative_perm(BlockDriverState *, uint64_t *, uint64_t *)\00", align 1
@.str.66 = private unnamed_addr constant [16 x i8] c"consistent read\00", align 1
@.str.67 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.68 = private unnamed_addr constant [16 x i8] c"write unchanged\00", align 1
@.str.69 = private unnamed_addr constant [7 x i8] c"resize\00", align 1
@__const.bdrv_perm_names.permissions = private unnamed_addr constant [5 x %struct.perm_name] [%struct.perm_name { i64 1, ptr @.str.66 }, %struct.perm_name { i64 2, ptr @.str.67 }, %struct.perm_name { i64 4, ptr @.str.68 }, %struct.perm_name { i64 8, ptr @.str.69 }, %struct.perm_name zeroinitializer], align 16
@.str.70 = private unnamed_addr constant [3 x i8] c", \00", align 1
@__PRETTY_FUNCTION__.bdrv_child_try_set_perm = private unnamed_addr constant [71 x i8] c"int bdrv_child_try_set_perm(BdrvChild *, uint64_t, uint64_t, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_refresh_perms = private unnamed_addr constant [72 x i8] c"int bdrv_child_refresh_perms(BlockDriverState *, BdrvChild *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_default_perms = private unnamed_addr constant [136 x i8] c"void bdrv_default_perms(BlockDriverState *, BdrvChild *, BdrvChildRole, BlockReopenQueue *, uint64_t, uint64_t, uint64_t *, uint64_t *)\00", align 1
@.str.71 = private unnamed_addr constant [67 x i8] c"!(role & (BDRV_CHILD_DATA | BDRV_CHILD_METADATA | BDRV_CHILD_COW))\00", align 1
@.str.72 = private unnamed_addr constant [50 x i8] c"!(role & (BDRV_CHILD_DATA | BDRV_CHILD_METADATA))\00", align 1
@__func__.bdrv_default_perms = private unnamed_addr constant [19 x i8] c"bdrv_default_perms\00", align 1
@bdrv_qapi_perm_to_blk_perm.permissions = internal constant [4 x i64] [i64 1, i64 2, i64 4, i64 8], align 16
@.str.73 = private unnamed_addr constant [34 x i8] c"qapi_perm < BLOCK_PERMISSION__MAX\00", align 1
@__PRETTY_FUNCTION__.bdrv_qapi_perm_to_blk_perm = private unnamed_addr constant [53 x i8] c"uint64_t bdrv_qapi_perm_to_blk_perm(BlockPermission)\00", align 1
@__PRETTY_FUNCTION__.bdrv_root_attach_child = private unnamed_addr constant [145 x i8] c"BdrvChild *bdrv_root_attach_child(BlockDriverState *, const char *, const BdrvChildClass *, BdrvChildRole, uint64_t, uint64_t, void *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_attach_child = private unnamed_addr constant [132 x i8] c"BdrvChild *bdrv_attach_child(BlockDriverState *, BlockDriverState *, const char *, const BdrvChildClass *, BdrvChildRole, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_root_unref_child = private unnamed_addr constant [40 x i8] c"void bdrv_root_unref_child(BdrvChild *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_unref_child = private unnamed_addr constant [55 x i8] c"void bdrv_unref_child(BlockDriverState *, BdrvChild *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_set_backing_hd_drained = private unnamed_addr constant [82 x i8] c"int bdrv_set_backing_hd_drained(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@.str.74 = private unnamed_addr constant [24 x i8] c"bs->quiesce_counter > 0\00", align 1
@.str.75 = private unnamed_addr constant [37 x i8] c"bs->backing->bs->quiesce_counter > 0\00", align 1
@__PRETTY_FUNCTION__.bdrv_set_backing_hd = private unnamed_addr constant [74 x i8] c"int bdrv_set_backing_hd(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_backing_file = private unnamed_addr constant [80 x i8] c"int bdrv_open_backing_file(BlockDriverState *, QDict *, const char *, Error **)\00", align 1
@.str.76 = private unnamed_addr constant [4 x i8] c"%s.\00", align 1
@.str.77 = private unnamed_addr constant [14 x i8] c"file.filename\00", align 1
@__func__.bdrv_open_backing_file = private unnamed_addr constant [23 x i8] c"bdrv_open_backing_file\00", align 1
@.str.78 = private unnamed_addr constant [37 x i8] c"Driver doesn't support backing files\00", align 1
@.str.79 = private unnamed_addr constant [30 x i8] c"Could not open backing file: \00", align 1
@__PRETTY_FUNCTION__.bdrv_open_child = private unnamed_addr constant [140 x i8] c"BdrvChild *bdrv_open_child(const char *, QDict *, const char *, BlockDriverState *, const BdrvChildClass *, BdrvChildRole, _Bool, Error **)\00", align 1
@.str.80 = private unnamed_addr constant [40 x i8] c"!parent->drv->filtered_child_is_backing\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_file_child = private unnamed_addr constant [92 x i8] c"int bdrv_open_file_child(const char *, QDict *, const char *, BlockDriverState *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_blockdev_ref = private unnamed_addr constant [66 x i8] c"BlockDriverState *bdrv_open_blockdev_ref(BlockdevRef *, Error **)\00", align 1
@.str.81 = private unnamed_addr constant [25 x i8] c"ref->type == QTYPE_QDICT\00", align 1
@error_abort = external global ptr, align 8
@__PRETTY_FUNCTION__.bdrv_open = private unnamed_addr constant [80 x i8] c"BlockDriverState *bdrv_open(const char *, const char *, QDict *, int, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_queue = private unnamed_addr constant [92 x i8] c"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *, BlockDriverState *, QDict *, _Bool)\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_queue_free = private unnamed_addr constant [48 x i8] c"void bdrv_reopen_queue_free(BlockReopenQueue *)\00", align 1
@.str.82 = private unnamed_addr constant [57 x i8] c"qemu_get_current_aio_context() == qemu_get_aio_context()\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_multiple = private unnamed_addr constant [55 x i8] c"int bdrv_reopen_multiple(BlockReopenQueue *, Error **)\00", align 1
@.str.83 = private unnamed_addr constant [17 x i8] c"bs_queue != NULL\00", align 1
@__func__.bdrv_reopen_multiple = private unnamed_addr constant [21 x i8] c"bdrv_reopen_multiple\00", align 1
@.str.84 = private unnamed_addr constant [21 x i8] c"Error flushing drive\00", align 1
@.str.85 = private unnamed_addr constant [40 x i8] c"bs_entry->state.bs->quiesce_counter > 0\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen = private unnamed_addr constant [62 x i8] c"int bdrv_reopen(BlockDriverState *, QDict *, _Bool, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_set_read_only = private unnamed_addr constant [67 x i8] c"int bdrv_reopen_set_read_only(BlockDriverState *, _Bool, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_close_all = private unnamed_addr constant [26 x i8] c"void bdrv_close_all(void)\00", align 1
@.str.86 = private unnamed_addr constant [23 x i8] c"job_next(NULL) == NULL\00", align 1
@.str.87 = private unnamed_addr constant [31 x i8] c"QTAILQ_EMPTY(&all_bdrv_states)\00", align 1
@__PRETTY_FUNCTION__.bdrv_drop_filter = private unnamed_addr constant [51 x i8] c"int bdrv_drop_filter(BlockDriverState *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_append = private unnamed_addr constant [66 x i8] c"int bdrv_append(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@.str.88 = private unnamed_addr constant [17 x i8] c"!bs_new->backing\00", align 1
@.str.89 = private unnamed_addr constant [8 x i8] c"backing\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_child_bs = private unnamed_addr constant [69 x i8] c"int bdrv_replace_child_bs(BdrvChild *, BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_insert_node = private unnamed_addr constant [17 x i8] c"bdrv_insert_node\00", align 1
@.str.90 = private unnamed_addr constant [24 x i8] c"driver is not specified\00", align 1
@.str.91 = private unnamed_addr constant [21 x i8] c"Unknown driver: '%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_insert_node = private unnamed_addr constant [79 x i8] c"BlockDriverState *bdrv_insert_node(BlockDriverState *, QDict *, int, Error **)\00", align 1
@.str.92 = private unnamed_addr constant [32 x i8] c"bdrv_get_aio_context(bs) == ctx\00", align 1
@.str.93 = private unnamed_addr constant [24 x i8] c"Could not create node: \00", align 1
@.str.94 = private unnamed_addr constant [25 x i8] c"Could not replace node: \00", align 1
@.str.95 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@__PRETTY_FUNCTION__.bdrv_find_overlay = private unnamed_addr constant [76 x i8] c"BlockDriverState *bdrv_find_overlay(BlockDriverState *, BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_find_base = private unnamed_addr constant [53 x i8] c"BlockDriverState *bdrv_find_base(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_freeze_backing_chain = private unnamed_addr constant [80 x i8] c"int bdrv_freeze_backing_chain(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_freeze_backing_chain = private unnamed_addr constant [26 x i8] c"bdrv_freeze_backing_chain\00", align 1
@.str.96 = private unnamed_addr constant [32 x i8] c"Cannot freeze '%s' link to '%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_unfreeze_backing_chain = private unnamed_addr constant [73 x i8] c"void bdrv_unfreeze_backing_chain(BlockDriverState *, BlockDriverState *)\00", align 1
@.str.97 = private unnamed_addr constant [14 x i8] c"child->frozen\00", align 1
@__PRETTY_FUNCTION__.bdrv_drop_intermediate = private unnamed_addr constant [81 x i8] c"int bdrv_drop_intermediate(BlockDriverState *, BlockDriverState *, const char *)\00", align 1
@__func__.bdrv_measure = private unnamed_addr constant [13 x i8] c"bdrv_measure\00", align 1
@.str.98 = private unnamed_addr constant [52 x i8] c"Block driver '%s' does not support size measurement\00", align 1
@__PRETTY_FUNCTION__.bdrv_iterate_format = private unnamed_addr constant [72 x i8] c"void bdrv_iterate_format(void (*)(void *, const char *), void *, _Bool)\00", align 1
@.str.99 = private unnamed_addr constant [10 x i8] c"node_name\00", align 1
@__PRETTY_FUNCTION__.bdrv_find_node = private unnamed_addr constant [47 x i8] c"BlockDriverState *bdrv_find_node(const char *)\00", align 1
@graph_bdrv_states = internal global %union.anon.20 { %struct.QTailQLink { ptr null, ptr @graph_bdrv_states } }, align 8
@__PRETTY_FUNCTION__.bdrv_named_nodes_list = private unnamed_addr constant [60 x i8] c"BlockDeviceInfoList *bdrv_named_nodes_list(_Bool, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_get_xdbg_block_graph = private unnamed_addr constant [52 x i8] c"XDbgBlockGraph *bdrv_get_xdbg_block_graph(Error **)\00", align 1
@job_mutex = external global %struct.QemuMutex, align 8
@__PRETTY_FUNCTION__.bdrv_lookup_bs = private unnamed_addr constant [71 x i8] c"BlockDriverState *bdrv_lookup_bs(const char *, const char *, Error **)\00", align 1
@__func__.bdrv_lookup_bs = private unnamed_addr constant [15 x i8] c"bdrv_lookup_bs\00", align 1
@.str.100 = private unnamed_addr constant [26 x i8] c"Device '%s' has no medium\00", align 1
@.str.101 = private unnamed_addr constant [43 x i8] c"Cannot find device='%s' nor node-name='%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_chain_contains = private unnamed_addr constant [66 x i8] c"_Bool bdrv_chain_contains(BlockDriverState *, BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_next_node = private unnamed_addr constant [53 x i8] c"BlockDriverState *bdrv_next_node(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_next_all_states = private unnamed_addr constant [59 x i8] c"BlockDriverState *bdrv_next_all_states(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_has_zero_init_1 = private unnamed_addr constant [45 x i8] c"int bdrv_has_zero_init_1(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_has_zero_init = private unnamed_addr constant [43 x i8] c"int bdrv_has_zero_init(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_debug_breakpoint = private unnamed_addr constant [74 x i8] c"int bdrv_debug_breakpoint(BlockDriverState *, const char *, const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_debug_remove_breakpoint = private unnamed_addr constant [67 x i8] c"int bdrv_debug_remove_breakpoint(BlockDriverState *, const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_debug_resume = private unnamed_addr constant [56 x i8] c"int bdrv_debug_resume(BlockDriverState *, const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_debug_is_suspended = private unnamed_addr constant [64 x i8] c"_Bool bdrv_debug_is_suspended(BlockDriverState *, const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_find_backing_image = private unnamed_addr constant [76 x i8] c"BlockDriverState *bdrv_find_backing_image(BlockDriverState *, const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_activate = private unnamed_addr constant [48 x i8] c"int bdrv_activate(BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_activate = private unnamed_addr constant [14 x i8] c"bdrv_activate\00", align 1
@.str.102 = private unnamed_addr constant [37 x i8] c"Could not refresh total sector count\00", align 1
@.str.103 = private unnamed_addr constant [36 x i8] c"!(bs->open_flags & BDRV_O_INACTIVE)\00", align 1
@__PRETTY_FUNCTION__.bdrv_co_invalidate_cache = private unnamed_addr constant [59 x i8] c"int bdrv_co_invalidate_cache(BlockDriverState *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_activate_all = private unnamed_addr constant [33 x i8] c"void bdrv_activate_all(Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_inactivate_all = private unnamed_addr constant [30 x i8] c"int bdrv_inactivate_all(void)\00", align 1
@__PRETTY_FUNCTION__.bdrv_ref = private unnamed_addr constant [34 x i8] c"void bdrv_ref(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_unref = private unnamed_addr constant [36 x i8] c"void bdrv_unref(BlockDriverState *)\00", align 1
@.str.104 = private unnamed_addr constant [15 x i8] c"bs->refcnt > 0\00", align 1
@.str.105 = private unnamed_addr constant [23 x i8] c"bdrv_schedule_unref_bh\00", align 1
@__PRETTY_FUNCTION__.bdrv_op_is_blocked = private unnamed_addr constant [68 x i8] c"_Bool bdrv_op_is_blocked(BlockDriverState *, BlockOpType, Error **)\00", align 1
@.str.106 = private unnamed_addr constant [40 x i8] c"(int) op >= 0 && op < BLOCK_OP_TYPE_MAX\00", align 1
@.str.107 = private unnamed_addr constant [20 x i8] c"Node '%s' is busy: \00", align 1
@__PRETTY_FUNCTION__.bdrv_op_block = private unnamed_addr constant [61 x i8] c"void bdrv_op_block(BlockDriverState *, BlockOpType, Error *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_op_unblock = private unnamed_addr constant [63 x i8] c"void bdrv_op_unblock(BlockDriverState *, BlockOpType, Error *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_op_block_all = private unnamed_addr constant [52 x i8] c"void bdrv_op_block_all(BlockDriverState *, Error *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_op_unblock_all = private unnamed_addr constant [54 x i8] c"void bdrv_op_unblock_all(BlockDriverState *, Error *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_op_blocker_is_empty = private unnamed_addr constant [51 x i8] c"_Bool bdrv_op_blocker_is_empty(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_img_create = private unnamed_addr constant [117 x i8] c"void bdrv_img_create(const char *, const char *, const char *, const char *, char *, uint64_t, int, _Bool, Error **)\00", align 1
@__func__.bdrv_img_create = private unnamed_addr constant [16 x i8] c"bdrv_img_create\00", align 1
@.str.108 = private unnamed_addr constant [25 x i8] c"Unknown file format '%s'\00", align 1
@.str.109 = private unnamed_addr constant [51 x i8] c"Format driver '%s' does not support image creation\00", align 1
@.str.110 = private unnamed_addr constant [53 x i8] c"Protocol driver '%s' does not support image creation\00", align 1
@.str.111 = private unnamed_addr constant [43 x i8] c"The image size must be specified only once\00", align 1
@.str.112 = private unnamed_addr constant [13 x i8] c"backing_file\00", align 1
@.str.113 = private unnamed_addr constant [48 x i8] c"Backing file not supported for file format '%s'\00", align 1
@.str.114 = private unnamed_addr constant [12 x i8] c"backing_fmt\00", align 1
@.str.115 = private unnamed_addr constant [55 x i8] c"Backing file format not supported for file format '%s'\00", align 1
@.str.116 = private unnamed_addr constant [76 x i8] c"Error: Trying to create an image with the same filename as the backing file\00", align 1
@.str.117 = private unnamed_addr constant [45 x i8] c"Expected backing file name, got empty string\00", align 1
@.str.118 = private unnamed_addr constant [13 x i8] c"full_backing\00", align 1
@.str.119 = private unnamed_addr constant [31 x i8] c"Could not open backing image.\0A\00", align 1
@.str.120 = private unnamed_addr constant [46 x i8] c"Backing file specified without backing format\00", align 1
@.str.121 = private unnamed_addr constant [24 x i8] c"Detected format of %s.\0A\00", align 1
@.str.122 = private unnamed_addr constant [27 x i8] c"Could not get size of '%s'\00", align 1
@.str.123 = private unnamed_addr constant [38 x i8] c"Image creation needs a size parameter\00", align 1
@.str.124 = private unnamed_addr constant [25 x i8] c"Formatting '%s', fmt=%s \00", align 1
@.str.125 = private unnamed_addr constant [2 x i8] c" \00", align 1
@stdout = external global ptr, align 8
@.str.126 = private unnamed_addr constant [13 x i8] c"cluster_size\00", align 1
@.str.127 = private unnamed_addr constant [35 x i8] c" (try using a larger cluster size)\00", align 1
@.str.128 = private unnamed_addr constant [51 x i8] c"The image size is too large for file format '%s'%s\00", align 1
@__PRETTY_FUNCTION__.bdrv_co_lock = private unnamed_addr constant [38 x i8] c"void bdrv_co_lock(BlockDriverState *)\00", align 1
@.str.129 = private unnamed_addr constant [20 x i8] c"qemu_in_coroutine()\00", align 1
@__PRETTY_FUNCTION__.bdrv_co_unlock = private unnamed_addr constant [40 x i8] c"void bdrv_co_unlock(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_change_aio_context = private unnamed_addr constant [102 x i8] c"_Bool bdrv_child_change_aio_context(BdrvChild *, AioContext *, GHashTable *, Transaction *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_try_change_aio_context = private unnamed_addr constant [89 x i8] c"int bdrv_try_change_aio_context(BlockDriverState *, AioContext *, BdrvChild *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_add_aio_context_notifier = private unnamed_addr constant [113 x i8] c"void bdrv_add_aio_context_notifier(BlockDriverState *, void (*)(AioContext *, void *), void (*)(void *), void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_remove_aio_context_notifier = private unnamed_addr constant [116 x i8] c"void bdrv_remove_aio_context_notifier(BlockDriverState *, void (*)(AioContext *, void *), void (*)(void *), void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_amend_options = private unnamed_addr constant [108 x i8] c"int bdrv_amend_options(BlockDriverState *, QemuOpts *, BlockDriverAmendStatusCB *, void *, _Bool, Error **)\00", align 1
@__func__.bdrv_amend_options = private unnamed_addr constant [19 x i8] c"bdrv_amend_options\00", align 1
@.str.130 = private unnamed_addr constant [16 x i8] c"Node is ejected\00", align 1
@.str.131 = private unnamed_addr constant [52 x i8] c"Block driver '%s' does not support option amendment\00", align 1
@__PRETTY_FUNCTION__.bdrv_recurse_can_replace = private unnamed_addr constant [71 x i8] c"_Bool bdrv_recurse_can_replace(BlockDriverState *, BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.check_to_replace_node = private unnamed_addr constant [84 x i8] c"BlockDriverState *check_to_replace_node(BlockDriverState *, const char *, Error **)\00", align 1
@__func__.check_to_replace_node = private unnamed_addr constant [22 x i8] c"check_to_replace_node\00", align 1
@.str.132 = private unnamed_addr constant [40 x i8] c"Failed to find node with node-name='%s'\00", align 1
@.str.133 = private unnamed_addr constant [147 x i8] c"Cannot replace '%s' by a node mirrored from '%s', because it cannot be guaranteed that doing so would not lead to an abrupt change of visible data\00", align 1
@__PRETTY_FUNCTION__.bdrv_refresh_filename = private unnamed_addr constant [47 x i8] c"void bdrv_refresh_filename(BlockDriverState *)\00", align 1
@.str.134 = private unnamed_addr constant [32 x i8] c"QLIST_NEXT(child, next) == NULL\00", align 1
@.str.135 = private unnamed_addr constant [8 x i8] c"json:%s\00", align 1
@.str.136 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@__PRETTY_FUNCTION__.bdrv_dirname = private unnamed_addr constant [49 x i8] c"char *bdrv_dirname(BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_dirname = private unnamed_addr constant [13 x i8] c"bdrv_dirname\00", align 1
@.str.137 = private unnamed_addr constant [21 x i8] c"Node '%s' is ejected\00", align 1
@.str.138 = private unnamed_addr constant [46 x i8] c"Cannot generate a base directory for %s nodes\00", align 1
@__PRETTY_FUNCTION__.bdrv_add_child = private unnamed_addr constant [70 x i8] c"void bdrv_add_child(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_add_child = private unnamed_addr constant [15 x i8] c"bdrv_add_child\00", align 1
@.str.139 = private unnamed_addr constant [44 x i8] c"The node %s does not support adding a child\00", align 1
@.str.140 = private unnamed_addr constant [37 x i8] c"Cannot add a %s child to a %s parent\00", align 1
@.str.141 = private unnamed_addr constant [6 x i8] c"zoned\00", align 1
@.str.142 = private unnamed_addr constant [10 x i8] c"non-zoned\00", align 1
@.str.143 = private unnamed_addr constant [23 x i8] c"support zoned children\00", align 1
@.str.144 = private unnamed_addr constant [27 x i8] c"not support zoned children\00", align 1
@.str.145 = private unnamed_addr constant [33 x i8] c"The node %s already has a parent\00", align 1
@__PRETTY_FUNCTION__.bdrv_del_child = private unnamed_addr constant [63 x i8] c"void bdrv_del_child(BlockDriverState *, BdrvChild *, Error **)\00", align 1
@__func__.bdrv_del_child = private unnamed_addr constant [15 x i8] c"bdrv_del_child\00", align 1
@.str.146 = private unnamed_addr constant [46 x i8] c"The node %s does not support removing a child\00", align 1
@.str.147 = private unnamed_addr constant [43 x i8] c"The node %s does not have a child named %s\00", align 1
@__PRETTY_FUNCTION__.bdrv_make_empty = private unnamed_addr constant [43 x i8] c"int bdrv_make_empty(BdrvChild *, Error **)\00", align 1
@.str.148 = private unnamed_addr constant [54 x i8] c"c->perm & (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED)\00", align 1
@__func__.bdrv_make_empty = private unnamed_addr constant [16 x i8] c"bdrv_make_empty\00", align 1
@.str.149 = private unnamed_addr constant [35 x i8] c"%s does not support emptying nodes\00", align 1
@.str.150 = private unnamed_addr constant [19 x i8] c"Failed to empty %s\00", align 1
@.str.151 = private unnamed_addr constant [35 x i8] c"bs->backing->role & BDRV_CHILD_COW\00", align 1
@__PRETTY_FUNCTION__.bdrv_cow_child = private unnamed_addr constant [46 x i8] c"BdrvChild *bdrv_cow_child(BlockDriverState *)\00", align 1
@.str.152 = private unnamed_addr constant [27 x i8] c"!(bs->backing && bs->file)\00", align 1
@__PRETTY_FUNCTION__.bdrv_filter_child = private unnamed_addr constant [49 x i8] c"BdrvChild *bdrv_filter_child(BlockDriverState *)\00", align 1
@.str.153 = private unnamed_addr constant [30 x i8] c"c->role & BDRV_CHILD_FILTERED\00", align 1
@.str.154 = private unnamed_addr constant [29 x i8] c"!(cow_child && filter_child)\00", align 1
@__PRETTY_FUNCTION__.bdrv_filter_or_cow_child = private unnamed_addr constant [56 x i8] c"BdrvChild *bdrv_filter_or_cow_child(BlockDriverState *)\00", align 1
@.str.155 = private unnamed_addr constant [7 x i8] c"!found\00", align 1
@__PRETTY_FUNCTION__.bdrv_primary_child = private unnamed_addr constant [50 x i8] c"BdrvChild *bdrv_primary_child(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_skip_implicit_filters = private unnamed_addr constant [65 x i8] c"BlockDriverState *bdrv_skip_implicit_filters(BlockDriverState *)\00", align 1
@__func__.bdrv_bsc_invalidate_range = private unnamed_addr constant [26 x i8] c"bdrv_bsc_invalidate_range\00", align 1
@__func__.bdrv_bsc_fill = private unnamed_addr constant [14 x i8] c"bdrv_bsc_fill\00", align 1
@__func__.bdrv_can_set_read_only = private unnamed_addr constant [23 x i8] c"bdrv_can_set_read_only\00", align 1
@.str.156 = private unnamed_addr constant [53 x i8] c"Can't set node '%s' to r/o with copy-on-read enabled\00", align 1
@.str.157 = private unnamed_addr constant [23 x i8] c"Node '%s' is read only\00", align 1
@__PRETTY_FUNCTION__.bdrv_do_find_format = private unnamed_addr constant [47 x i8] c"BlockDriver *bdrv_do_find_format(const char *)\00", align 1
@bdrv_format_is_whitelisted.whitelist_rw = internal global [1 x ptr] zeroinitializer, align 8
@bdrv_format_is_whitelisted.whitelist_ro = internal global [1 x ptr] zeroinitializer, align 8
@__PRETTY_FUNCTION__.create_file_fallback_truncate = private unnamed_addr constant [73 x i8] c"int64_t create_file_fallback_truncate(BlockBackend *, int64_t, Error **)\00", align 1
@__func__.create_file_fallback_truncate = private unnamed_addr constant [30 x i8] c"create_file_fallback_truncate\00", align 1
@.str.158 = private unnamed_addr constant [46 x i8] c"Failed to inquire the new image file's length\00", align 1
@__PRETTY_FUNCTION__.create_file_fallback_zero_first_sector = private unnamed_addr constant [78 x i8] c"int create_file_fallback_zero_first_sector(BlockBackend *, int64_t, Error **)\00", align 1
@__func__.create_file_fallback_zero_first_sector = private unnamed_addr constant [39 x i8] c"create_file_fallback_zero_first_sector\00", align 1
@.str.159 = private unnamed_addr constant [45 x i8] c"Failed to clear the new image's first sector\00", align 1
@.str.160 = private unnamed_addr constant [25 x i8] c"!obj || obj->base.refcnt\00", align 1
@.str.161 = private unnamed_addr constant [105 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qapi/qmp/qobject.h\00", align 1
@__PRETTY_FUNCTION__.qobject_unref_impl = private unnamed_addr constant [35 x i8] c"void qobject_unref_impl(QObject *)\00", align 1
@__PRETTY_FUNCTION__.find_hdev_driver = private unnamed_addr constant [44 x i8] c"BlockDriver *find_hdev_driver(const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_do_find_protocol = private unnamed_addr constant [49 x i8] c"BlockDriver *bdrv_do_find_protocol(const char *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_inherited_options = private unnamed_addr constant [80 x i8] c"void bdrv_inherited_options(BdrvChildRole, _Bool, int *, QDict *, int, QDict *)\00", align 1
@.str.162 = private unnamed_addr constant [10 x i8] c"node '%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_cb_inactivate = private unnamed_addr constant [42 x i8] c"int bdrv_child_cb_inactivate(BdrvChild *)\00", align 1
@.str.163 = private unnamed_addr constant [33 x i8] c"bs->open_flags & BDRV_O_INACTIVE\00", align 1
@.str.164 = private unnamed_addr constant [32 x i8] c"!(child->role & BDRV_CHILD_COW)\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_cb_attach = private unnamed_addr constant [39 x i8] c"void bdrv_child_cb_attach(BdrvChild *)\00", align 1
@.str.165 = private unnamed_addr constant [34 x i8] c"child->role & BDRV_CHILD_FILTERED\00", align 1
@.str.166 = private unnamed_addr constant [13 x i8] c"!bs->backing\00", align 1
@.str.167 = private unnamed_addr constant [10 x i8] c"!bs->file\00", align 1
@.str.168 = private unnamed_addr constant [37 x i8] c"!(child->role & BDRV_CHILD_FILTERED)\00", align 1
@.str.169 = private unnamed_addr constant [26 x i8] c"bs->drv->supports_backing\00", align 1
@.str.170 = private unnamed_addr constant [36 x i8] c"!(child->role & BDRV_CHILD_PRIMARY)\00", align 1
@__PRETTY_FUNCTION__.bdrv_backing_attach = private unnamed_addr constant [38 x i8] c"void bdrv_backing_attach(BdrvChild *)\00", align 1
@.str.171 = private unnamed_addr constant [25 x i8] c"!parent->backing_blocker\00", align 1
@__func__.bdrv_backing_attach = private unnamed_addr constant [20 x i8] c"bdrv_backing_attach\00", align 1
@.str.172 = private unnamed_addr constant [35 x i8] c"node is used as backing hd of '%s'\00", align 1
@.str.173 = private unnamed_addr constant [18 x i8] c"child != bs->file\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_cb_detach = private unnamed_addr constant [39 x i8] c"void bdrv_child_cb_detach(BdrvChild *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_backing_detach = private unnamed_addr constant [38 x i8] c"void bdrv_backing_detach(BdrvChild *)\00", align 1
@.str.174 = private unnamed_addr constant [24 x i8] c"parent->backing_blocker\00", align 1
@__PRETTY_FUNCTION__.bdrv_backing_update_filename = private unnamed_addr constant [90 x i8] c"int bdrv_backing_update_filename(BdrvChild *, BlockDriverState *, const char *, Error **)\00", align 1
@__func__.bdrv_backing_update_filename = private unnamed_addr constant [29 x i8] c"bdrv_backing_update_filename\00", align 1
@.str.175 = private unnamed_addr constant [35 x i8] c"Could not update backing file link\00", align 1
@__PRETTY_FUNCTION__.update_options_from_flags = private unnamed_addr constant [45 x i8] c"void update_options_from_flags(QDict *, int)\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_driver = private unnamed_addr constant [94 x i8] c"int bdrv_open_driver(BlockDriverState *, BlockDriver *, const char *, QDict *, int, Error **)\00", align 1
@.str.176 = private unnamed_addr constant [45 x i8] c"!drv->bdrv_needs_filename || bs->filename[0]\00", align 1
@__func__.bdrv_open_driver = private unnamed_addr constant [17 x i8] c"bdrv_open_driver\00", align 1
@.str.177 = private unnamed_addr constant [20 x i8] c"Could not open '%s'\00", align 1
@.str.178 = private unnamed_addr constant [21 x i8] c"Could not open image\00", align 1
@.str.179 = private unnamed_addr constant [45 x i8] c"!(bs->supported_read_flags & ~BDRV_REQ_MASK)\00", align 1
@.str.180 = private unnamed_addr constant [46 x i8] c"!(bs->supported_write_flags & ~BDRV_REQ_MASK)\00", align 1
@.str.181 = private unnamed_addr constant [28 x i8] c"bdrv_opt_mem_align(bs) != 0\00", align 1
@.str.182 = private unnamed_addr constant [28 x i8] c"bdrv_min_mem_align(bs) != 0\00", align 1
@.str.183 = private unnamed_addr constant [40 x i8] c"is_power_of_2(bs->bl.request_alignment)\00", align 1
@__PRETTY_FUNCTION__.bdrv_assign_node_name = private unnamed_addr constant [71 x i8] c"void bdrv_assign_node_name(BlockDriverState *, const char *, Error **)\00", align 1
@__func__.bdrv_assign_node_name = private unnamed_addr constant [22 x i8] c"bdrv_assign_node_name\00", align 1
@.str.184 = private unnamed_addr constant [24 x i8] c"Invalid node-name: '%s'\00", align 1
@.str.185 = private unnamed_addr constant [45 x i8] c"node-name=%s is conflicting with a device id\00", align 1
@.str.186 = private unnamed_addr constant [36 x i8] c"Duplicate nodes with node-name='%s'\00", align 1
@.str.187 = private unnamed_addr constant [19 x i8] c"Node name too long\00", align 1
@__PRETTY_FUNCTION__.bdrv_drv_set_perm_abort = private unnamed_addr constant [37 x i8] c"void bdrv_drv_set_perm_abort(void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_drv_set_perm_commit = private unnamed_addr constant [38 x i8] c"void bdrv_drv_set_perm_commit(void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_set_perm = private unnamed_addr constant [73 x i8] c"void bdrv_child_set_perm(BdrvChild *, uint64_t, uint64_t, Transaction *)\00", align 1
@bdrv_child_set_pem_drv = internal global %struct.TransactionActionDrv { ptr @bdrv_child_set_perm_abort, ptr null, ptr @g_free }, align 8
@__PRETTY_FUNCTION__.bdrv_child_set_perm_abort = private unnamed_addr constant [39 x i8] c"void bdrv_child_set_perm_abort(void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_refresh_perms = private unnamed_addr constant [68 x i8] c"int bdrv_refresh_perms(BlockDriverState *, Transaction *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_topological_dfs = private unnamed_addr constant [73 x i8] c"GSList *bdrv_topological_dfs(GSList *, GHashTable *, BlockDriverState *)\00", align 1
@.str.188 = private unnamed_addr constant [6 x i8] c"!list\00", align 1
@__PRETTY_FUNCTION__.bdrv_do_refresh_perms = private unnamed_addr constant [81 x i8] c"int bdrv_do_refresh_perms(GSList *, BlockReopenQueue *, Transaction *, Error **)\00", align 1
@__PRETTY_FUNCTION__.bdrv_parent_perms_conflict = private unnamed_addr constant [63 x i8] c"_Bool bdrv_parent_perms_conflict(BlockDriverState *, Error **)\00", align 1
@.str.189 = private unnamed_addr constant [6 x i8] c"a->bs\00", align 1
@__PRETTY_FUNCTION__.bdrv_a_allow_b = private unnamed_addr constant [57 x i8] c"_Bool bdrv_a_allow_b(BdrvChild *, BdrvChild *, Error **)\00", align 1
@.str.190 = private unnamed_addr constant [15 x i8] c"a->bs == b->bs\00", align 1
@__func__.bdrv_a_allow_b = private unnamed_addr constant [15 x i8] c"bdrv_a_allow_b\00", align 1
@.str.191 = private unnamed_addr constant [157 x i8] c"Permission conflict on node '%s': permissions '%s' are both required by %s (uses node '%s' as '%s' child) and unshared by %s (uses node '%s' as '%s' child).\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_user_desc = private unnamed_addr constant [40 x i8] c"char *bdrv_child_user_desc(BdrvChild *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_node_refresh_perm = private unnamed_addr constant [92 x i8] c"int bdrv_node_refresh_perm(BlockDriverState *, BlockReopenQueue *, Transaction *, Error **)\00", align 1
@__func__.bdrv_node_refresh_perm = private unnamed_addr constant [23 x i8] c"bdrv_node_refresh_perm\00", align 1
@.str.192 = private unnamed_addr constant [24 x i8] c"Block node is read-only\00", align 1
@.str.193 = private unnamed_addr constant [58 x i8] c"Read-only block node '%s' cannot support read-write users\00", align 1
@.str.194 = private unnamed_addr constant [98 x i8] c"Cannot get 'write' permission without 'resize': Image size is not a multiple of request alignment\00", align 1
@.str.195 = private unnamed_addr constant [27 x i8] c"QLIST_EMPTY(&bs->children)\00", align 1
@__PRETTY_FUNCTION__.bdrv_drv_set_perm = private unnamed_addr constant [87 x i8] c"int bdrv_drv_set_perm(BlockDriverState *, uint64_t, uint64_t, Transaction *, Error **)\00", align 1
@.str.196 = private unnamed_addr constant [36 x i8] c"bs->drv && bs->drv->bdrv_child_perm\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_perm = private unnamed_addr constant [153 x i8] c"void bdrv_child_perm(BlockDriverState *, BlockDriverState *, BdrvChild *, BdrvChildRole, BlockReopenQueue *, uint64_t, uint64_t, uint64_t *, uint64_t *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_filter_default_perms = private unnamed_addr constant [143 x i8] c"void bdrv_filter_default_perms(BlockDriverState *, BdrvChild *, BdrvChildRole, BlockReopenQueue *, uint64_t, uint64_t, uint64_t *, uint64_t *)\00", align 1
@.str.197 = private unnamed_addr constant [22 x i8] c"role & BDRV_CHILD_COW\00", align 1
@__PRETTY_FUNCTION__.bdrv_default_perms_for_cow = private unnamed_addr constant [144 x i8] c"void bdrv_default_perms_for_cow(BlockDriverState *, BdrvChild *, BdrvChildRole, BlockReopenQueue *, uint64_t, uint64_t, uint64_t *, uint64_t *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_default_perms_for_storage = private unnamed_addr constant [148 x i8] c"void bdrv_default_perms_for_storage(BlockDriverState *, BdrvChild *, BdrvChildRole, BlockReopenQueue *, uint64_t, uint64_t, uint64_t *, uint64_t *)\00", align 1
@.str.198 = private unnamed_addr constant [47 x i8] c"role & (BDRV_CHILD_METADATA | BDRV_CHILD_DATA)\00", align 1
@.str.199 = private unnamed_addr constant [29 x i8] c"child_class->get_parent_desc\00", align 1
@__PRETTY_FUNCTION__.bdrv_attach_child_common = private unnamed_addr constant [162 x i8] c"BdrvChild *bdrv_attach_child_common(BlockDriverState *, const char *, const BdrvChildClass *, BdrvChildRole, uint64_t, uint64_t, void *, Transaction *, Error **)\00", align 1
@bdrv_attach_child_common_drv = internal global %struct.TransactionActionDrv { ptr @bdrv_attach_child_common_abort, ptr null, ptr @g_free }, align 8
@__PRETTY_FUNCTION__.bdrv_attach_child_common_abort = private unnamed_addr constant [44 x i8] c"void bdrv_attach_child_common_abort(void *)\00", align 1
@.str.200 = private unnamed_addr constant [12 x i8] c"ret == true\00", align 1
@.str.201 = private unnamed_addr constant [15 x i8] c"parent_bs->drv\00", align 1
@__PRETTY_FUNCTION__.bdrv_attach_child_noperm = private unnamed_addr constant [154 x i8] c"BdrvChild *bdrv_attach_child_noperm(BlockDriverState *, BlockDriverState *, const char *, const BdrvChildClass *, BdrvChildRole, Transaction *, Error **)\00", align 1
@__func__.bdrv_attach_child_noperm = private unnamed_addr constant [25 x i8] c"bdrv_attach_child_noperm\00", align 1
@.str.202 = private unnamed_addr constant [52 x i8] c"Making '%s' a %s child of '%s' would create a cycle\00", align 1
@.str.203 = private unnamed_addr constant [15 x i8] c"!child->frozen\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_child_noperm = private unnamed_addr constant [64 x i8] c"void bdrv_replace_child_noperm(BdrvChild *, BlockDriverState *)\00", align 1
@.str.204 = private unnamed_addr constant [34 x i8] c"!new_bs || child->quiesced_parent\00", align 1
@.str.205 = private unnamed_addr constant [17 x i8] c"old_bs != new_bs\00", align 1
@.str.206 = private unnamed_addr constant [61 x i8] c"bdrv_get_aio_context(old_bs) == bdrv_get_aio_context(new_bs)\00", align 1
@.str.207 = private unnamed_addr constant [11 x i8] c"!child->bs\00", align 1
@__PRETTY_FUNCTION__.bdrv_child_free = private unnamed_addr constant [34 x i8] c"void bdrv_child_free(BdrvChild *)\00", align 1
@.str.208 = private unnamed_addr constant [21 x i8] c"!child->next.le_prev\00", align 1
@bdrv_set_inherits_from_drv = internal global %struct.TransactionActionDrv { ptr @bdrv_set_inherits_from_abort, ptr null, ptr @g_free }, align 8
@__PRETTY_FUNCTION__.bdrv_set_file_or_backing_noperm = private unnamed_addr constant [108 x i8] c"int bdrv_set_file_or_backing_noperm(BlockDriverState *, BlockDriverState *, _Bool, Transaction *, Error **)\00", align 1
@__func__.bdrv_set_file_or_backing_noperm = private unnamed_addr constant [32 x i8] c"bdrv_set_file_or_backing_noperm\00", align 1
@.str.209 = private unnamed_addr constant [15 x i8] c"Node corrupted\00", align 1
@.str.210 = private unnamed_addr constant [49 x i8] c"Cannot change frozen '%s' link from '%s' to '%s'\00", align 1
@.str.211 = private unnamed_addr constant [56 x i8] c"Driver '%s' of node '%s' does not support backing files\00", align 1
@.str.212 = private unnamed_addr constant [56 x i8] c"Cannot set file child to format node without file child\00", align 1
@.str.213 = private unnamed_addr constant [27 x i8] c"child->bs->quiesce_counter\00", align 1
@.str.214 = private unnamed_addr constant [5 x i8] c"file\00", align 1
@.str.215 = private unnamed_addr constant [23 x i8] c"child->quiesced_parent\00", align 1
@__PRETTY_FUNCTION__.bdrv_remove_child = private unnamed_addr constant [51 x i8] c"void bdrv_remove_child(BdrvChild *, Transaction *)\00", align 1
@bdrv_remove_child_drv = internal global %struct.TransactionActionDrv { ptr null, ptr @bdrv_remove_child_commit, ptr null }, align 8
@__PRETTY_FUNCTION__.bdrv_remove_child_commit = private unnamed_addr constant [38 x i8] c"void bdrv_remove_child_commit(void *)\00", align 1
@.str.216 = private unnamed_addr constant [20 x i8] c"child_class != NULL\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_child_bs = private unnamed_addr constant [150 x i8] c"BlockDriverState *bdrv_open_child_bs(const char *, QDict *, const char *, BlockDriverState *, const BdrvChildClass *, BdrvChildRole, _Bool, Error **)\00", align 1
@__func__.bdrv_open_child_bs = private unnamed_addr constant [19 x i8] c"bdrv_open_child_bs\00", align 1
@.str.217 = private unnamed_addr constant [42 x i8] c"A block device must be specified for \22%s\22\00", align 1
@.str.218 = private unnamed_addr constant [59 x i8] c"QTYPE_NONE < obj->base.type && obj->base.type < QTYPE__MAX\00", align 1
@__PRETTY_FUNCTION__.qobject_type = private unnamed_addr constant [36 x i8] c"QType qobject_type(const QObject *)\00", align 1
@.str.219 = private unnamed_addr constant [23 x i8] c"!child_class || !flags\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_inherit = private unnamed_addr constant [147 x i8] c"BlockDriverState *bdrv_open_inherit(const char *, const char *, QDict *, int, BlockDriverState *, const BdrvChildClass *, BdrvChildRole, Error **)\00", align 1
@.str.220 = private unnamed_addr constant [24 x i8] c"!child_class == !parent\00", align 1
@.str.221 = private unnamed_addr constant [21 x i8] c"!qemu_in_coroutine()\00", align 1
@__func__.bdrv_open_inherit = private unnamed_addr constant [18 x i8] c"bdrv_open_inherit\00", align 1
@.str.222 = private unnamed_addr constant [84 x i8] c"Cannot reference an existing block device with additional options or a new filename\00", align 1
@.str.223 = private unnamed_addr constant [38 x i8] c"drvname || !(flags & BDRV_O_PROTOCOL)\00", align 1
@.str.224 = private unnamed_addr constant [64 x i8] c"Use of \22backing\22: \22\22 is deprecated; use \22backing\22: null instead\00", align 1
@.str.225 = private unnamed_addr constant [35 x i8] c"Must specify either driver or file\00", align 1
@.str.226 = private unnamed_addr constant [53 x i8] c"!!(flags & BDRV_O_PROTOCOL) == !!drv->bdrv_file_open\00", align 1
@.str.227 = private unnamed_addr constant [36 x i8] c"!(flags & BDRV_O_PROTOCOL) || !file\00", align 1
@.str.228 = private unnamed_addr constant [52 x i8] c"Block protocol '%s' doesn't support the option '%s'\00", align 1
@.str.229 = private unnamed_addr constant [51 x i8] c"Block format '%s' does not support the option '%s'\00", align 1
@__PRETTY_FUNCTION__.parse_json_protocol = private unnamed_addr constant [59 x i8] c"void parse_json_protocol(QDict *, const char **, Error **)\00", align 1
@__PRETTY_FUNCTION__.parse_json_filename = private unnamed_addr constant [51 x i8] c"QDict *parse_json_filename(const char *, Error **)\00", align 1
@.str.230 = private unnamed_addr constant [4 x i8] c"ret\00", align 1
@.str.231 = private unnamed_addr constant [35 x i8] c"Could not parse the JSON options: \00", align 1
@__func__.parse_json_filename = private unnamed_addr constant [20 x i8] c"parse_json_filename\00", align 1
@.str.232 = private unnamed_addr constant [26 x i8] c"Invalid JSON object given\00", align 1
@__PRETTY_FUNCTION__.bdrv_fill_options = private unnamed_addr constant [63 x i8] c"int bdrv_fill_options(QDict **, const char *, int *, Error **)\00", align 1
@__func__.bdrv_fill_options = private unnamed_addr constant [18 x i8] c"bdrv_fill_options\00", align 1
@.str.233 = private unnamed_addr constant [20 x i8] c"Unknown driver '%s'\00", align 1
@.str.234 = private unnamed_addr constant [61 x i8] c"Can't specify 'file' and 'filename' options at the same time\00", align 1
@.str.235 = private unnamed_addr constant [17 x i8] c"drv || !protocol\00", align 1
@__PRETTY_FUNCTION__.bdrv_temp_snapshot_options = private unnamed_addr constant [62 x i8] c"void bdrv_temp_snapshot_options(int *, QDict *, int, QDict *)\00", align 1
@__PRETTY_FUNCTION__.find_image_format = private unnamed_addr constant [78 x i8] c"int find_image_format(BlockBackend *, const char *, BlockDriver **, Error **)\00", align 1
@bdrv_raw = external global %struct.BlockDriver, align 8
@__func__.find_image_format = private unnamed_addr constant [18 x i8] c"find_image_format\00", align 1
@.str.236 = private unnamed_addr constant [48 x i8] c"Could not read image for determining its format\00", align 1
@.str.237 = private unnamed_addr constant [61 x i8] c"Could not determine image format: No compatible driver found\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_common = private unnamed_addr constant [76 x i8] c"int bdrv_open_common(BlockDriverState *, BlockBackend *, QDict *, Error **)\00", align 1
@.str.238 = private unnamed_addr constant [17 x i8] c"bs->file == NULL\00", align 1
@.str.239 = private unnamed_addr constant [42 x i8] c"options != NULL && bs->options != options\00", align 1
@.str.240 = private unnamed_addr constant [12 x i8] c"drv != NULL\00", align 1
@__func__.bdrv_open_common = private unnamed_addr constant [17 x i8] c"bdrv_open_common\00", align 1
@.str.241 = private unnamed_addr constant [54 x i8] c"force-share=on can only be used with read-only images\00", align 1
@.str.242 = private unnamed_addr constant [43 x i8] c"The '%s' block driver requires a file name\00", align 1
@.str.243 = private unnamed_addr constant [51 x i8] c"Driver '%s' can only be used for read-only devices\00", align 1
@.str.244 = private unnamed_addr constant [31 x i8] c"Driver '%s' is not whitelisted\00", align 1
@.str.245 = private unnamed_addr constant [37 x i8] c"qatomic_read(&bs->copy_on_read) == 0\00", align 1
@.str.246 = private unnamed_addr constant [43 x i8] c"Can't use copy-on-read on read-only device\00", align 1
@.str.247 = private unnamed_addr constant [23 x i8] c"Invalid discard option\00", align 1
@.str.248 = private unnamed_addr constant [37 x i8] c"!drv->bdrv_file_open || file == NULL\00", align 1
@__PRETTY_FUNCTION__.update_flags_from_options = private unnamed_addr constant [50 x i8] c"void update_flags_from_options(int *, QemuOpts *)\00", align 1
@trace_events_enabled_count = external global i32, align 4
@_TRACE_BDRV_OPEN_COMMON_DSTATE = external global i16, align 2
@message_with_timestamp = external global i8, align 1
@.str.249 = private unnamed_addr constant [79 x i8] c"%d@%zu.%06zu:bdrv_open_common bs %p filename \22%s\22 flags 0x%x format_name \22%s\22\0A\00", align 1
@.str.250 = private unnamed_addr constant [66 x i8] c"bdrv_open_common bs %p filename \22%s\22 flags 0x%x format_name \22%s\22\0A\00", align 1
@qemu_loglevel = external global i32, align 4
@BlockdevDetectZeroesOptions_lookup = external constant %struct.QEnumLookup, align 8
@__PRETTY_FUNCTION__.bdrv_parse_detect_zeroes = private unnamed_addr constant [80 x i8] c"BlockdevDetectZeroesOptions bdrv_parse_detect_zeroes(QemuOpts *, int, Error **)\00", align 1
@__func__.bdrv_parse_detect_zeroes = private unnamed_addr constant [25 x i8] c"bdrv_parse_detect_zeroes\00", align 1
@.str.251 = private unnamed_addr constant [89 x i8] c"setting detect-zeroes to unmap is not allowed without setting discard operation to unmap\00", align 1
@__PRETTY_FUNCTION__.bdrv_open_flags = private unnamed_addr constant [45 x i8] c"int bdrv_open_flags(BlockDriverState *, int)\00", align 1
@__PRETTY_FUNCTION__.bdrv_parent_cb_change_media = private unnamed_addr constant [60 x i8] c"void bdrv_parent_cb_change_media(BlockDriverState *, _Bool)\00", align 1
@__PRETTY_FUNCTION__.bdrv_append_temp_snapshot = private unnamed_addr constant [88 x i8] c"BlockDriverState *bdrv_append_temp_snapshot(BlockDriverState *, int, QDict *, Error **)\00", align 1
@__func__.bdrv_append_temp_snapshot = private unnamed_addr constant [26 x i8] c"bdrv_append_temp_snapshot\00", align 1
@.str.252 = private unnamed_addr constant [25 x i8] c"Could not get image size\00", align 1
@bdrv_qcow2 = external global %struct.BlockDriver, align 8
@.str.253 = private unnamed_addr constant [42 x i8] c"Could not create temporary overlay '%s': \00", align 1
@.str.254 = private unnamed_addr constant [12 x i8] c"file.driver\00", align 1
@.str.255 = private unnamed_addr constant [6 x i8] c"qcow2\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_queue_child = private unnamed_addr constant [158 x i8] c"BlockReopenQueue *bdrv_reopen_queue_child(BlockReopenQueue *, BlockDriverState *, QDict *, const BdrvChildClass *, BdrvChildRole, _Bool, QDict *, int, _Bool)\00", align 1
@.str.256 = private unnamed_addr constant [15 x i8] c"backing.driver\00", align 1
@__PRETTY_FUNCTION__.bdrv_join_options = private unnamed_addr constant [61 x i8] c"void bdrv_join_options(BlockDriverState *, QDict *, QDict *)\00", align 1
@.str.257 = private unnamed_addr constant [21 x i8] c"reopen_state != NULL\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_prepare = private unnamed_addr constant [88 x i8] c"int bdrv_reopen_prepare(BDRVReopenState *, BlockReopenQueue *, Transaction *, Error **)\00", align 1
@.str.258 = private unnamed_addr constant [30 x i8] c"reopen_state->bs->drv != NULL\00", align 1
@.str.259 = private unnamed_addr constant [33 x i8] c"old_flags == reopen_state->flags\00", align 1
@__func__.bdrv_reopen_prepare = private unnamed_addr constant [20 x i8] c"bdrv_reopen_prepare\00", align 1
@.str.260 = private unnamed_addr constant [44 x i8] c"failed while preparing to reopen image '%s'\00", align 1
@.str.261 = private unnamed_addr constant [69 x i8] c"Block format '%s' used by node '%s' does not support reopening files\00", align 1
@.str.262 = private unnamed_addr constant [28 x i8] c"backing is missing for '%s'\00", align 1
@.str.263 = private unnamed_addr constant [30 x i8] c"Cannot change the option '%s'\00", align 1
@__const.bdrv_reset_options_allowed.common_options = private unnamed_addr constant [8 x ptr] [ptr @.str.44, ptr @.str.57, ptr @.str.47, ptr @.str.49, ptr @.str.51, ptr @.str.53, ptr @.str.55, ptr null], align 16
@__func__.bdrv_reset_options_allowed = private unnamed_addr constant [27 x i8] c"bdrv_reset_options_allowed\00", align 1
@.str.264 = private unnamed_addr constant [49 x i8] c"Option '%s' cannot be reset to its default value\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_parse_file_or_backing = private unnamed_addr constant [89 x i8] c"int bdrv_reopen_parse_file_or_backing(BDRVReopenState *, _Bool, Transaction *, Error **)\00", align 1
@.str.265 = private unnamed_addr constant [11 x i8] c"is_backing\00", align 1
@__func__.bdrv_reopen_parse_file_or_backing = private unnamed_addr constant [34 x i8] c"bdrv_reopen_parse_file_or_backing\00", align 1
@.str.266 = private unnamed_addr constant [39 x i8] c"Cannot replace implicit %s child of %s\00", align 1
@.str.267 = private unnamed_addr constant [58 x i8] c"'%s' is a %s filter node that does not support a %s child\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_commit = private unnamed_addr constant [43 x i8] c"void bdrv_reopen_commit(BDRVReopenState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_reopen_abort = private unnamed_addr constant [42 x i8] c"void bdrv_reopen_abort(BDRVReopenState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_node_common = private unnamed_addr constant [93 x i8] c"int bdrv_replace_node_common(BlockDriverState *, BlockDriverState *, _Bool, _Bool, Error **)\00", align 1
@.str.268 = private unnamed_addr constant [22 x i8] c"from->quiesce_counter\00", align 1
@.str.269 = private unnamed_addr constant [20 x i8] c"to->quiesce_counter\00", align 1
@.str.270 = private unnamed_addr constant [55 x i8] c"bdrv_get_aio_context(from) == bdrv_get_aio_context(to)\00", align 1
@.str.271 = private unnamed_addr constant [30 x i8] c"bdrv_chain_contains(from, to)\00", align 1
@.str.272 = private unnamed_addr constant [11 x i8] c"from != to\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_node_noperm = private unnamed_addr constant [101 x i8] c"int bdrv_replace_node_noperm(BlockDriverState *, BlockDriverState *, _Bool, Transaction *, Error **)\00", align 1
@.str.273 = private unnamed_addr constant [14 x i8] c"c->bs == from\00", align 1
@__func__.bdrv_replace_node_noperm = private unnamed_addr constant [25 x i8] c"bdrv_replace_node_noperm\00", align 1
@.str.274 = private unnamed_addr constant [36 x i8] c"Should not change '%s' link to '%s'\00", align 1
@.str.275 = private unnamed_addr constant [32 x i8] c"Cannot change '%s' link to '%s'\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_child_tran = private unnamed_addr constant [77 x i8] c"void bdrv_replace_child_tran(BdrvChild *, BlockDriverState *, Transaction *)\00", align 1
@.str.276 = private unnamed_addr constant [35 x i8] c"!new_bs || new_bs->quiesce_counter\00", align 1
@bdrv_replace_child_drv = internal global %struct.TransactionActionDrv { ptr @bdrv_replace_child_abort, ptr @bdrv_replace_child_commit, ptr @g_free }, align 8
@__PRETTY_FUNCTION__.bdrv_replace_child_abort = private unnamed_addr constant [38 x i8] c"void bdrv_replace_child_abort(void *)\00", align 1
@.str.277 = private unnamed_addr constant [43 x i8] c"!bdrv_parent_drained_poll_single(s->child)\00", align 1
@.str.278 = private unnamed_addr constant [26 x i8] c"s->child->quiesced_parent\00", align 1
@__PRETTY_FUNCTION__.bdrv_replace_child_commit = private unnamed_addr constant [39 x i8] c"void bdrv_replace_child_commit(void *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_is_backing_chain_frozen = private unnamed_addr constant [85 x i8] c"_Bool bdrv_is_backing_chain_frozen(BlockDriverState *, BlockDriverState *, Error **)\00", align 1
@__func__.bdrv_is_backing_chain_frozen = private unnamed_addr constant [29 x i8] c"bdrv_is_backing_chain_frozen\00", align 1
@.str.279 = private unnamed_addr constant [42 x i8] c"Cannot change '%s' link from '%s' to '%s'\00", align 1
@__PRETTY_FUNCTION__.xdbg_graph_add_edge = private unnamed_addr constant [81 x i8] c"void xdbg_graph_add_edge(XDbgBlockGraphConstructor *, void *, const BdrvChild *)\00", align 1
@.str.280 = private unnamed_addr constant [100 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/thread.h\00", align 1
@__func__.qemu_mutex_lock = private unnamed_addr constant [16 x i8] c"qemu_mutex_lock\00", align 1
@qemu_mutex_lock_func = external global ptr, align 8
@__PRETTY_FUNCTION__.bdrv_find_debug_node = private unnamed_addr constant [59 x i8] c"BlockDriverState *bdrv_find_debug_node(BlockDriverState *)\00", align 1
@.str.281 = private unnamed_addr constant [38 x i8] c"bs->drv->bdrv_debug_remove_breakpoint\00", align 1
@__PRETTY_FUNCTION__.bdrv_has_bds_parent = private unnamed_addr constant [53 x i8] c"_Bool bdrv_has_bds_parent(BlockDriverState *, _Bool)\00", align 1
@__PRETTY_FUNCTION__.bdrv_inactivate_recurse = private unnamed_addr constant [48 x i8] c"int bdrv_inactivate_recurse(BlockDriverState *)\00", align 1
@_TRACE_BDRV_LOCK_MEDIUM_DSTATE = external global i16, align 2
@.str.282 = private unnamed_addr constant [47 x i8] c"%d@%zu.%06zu:bdrv_lock_medium bs %p locked %d\0A\00", align 1
@.str.283 = private unnamed_addr constant [34 x i8] c"bdrv_lock_medium bs %p locked %d\0A\00", align 1
@.str.284 = private unnamed_addr constant [29 x i8] c"bdrv_op_blocker_is_empty(bs)\00", align 1
@__PRETTY_FUNCTION__.bdrv_delete = private unnamed_addr constant [37 x i8] c"void bdrv_delete(BlockDriverState *)\00", align 1
@.str.285 = private unnamed_addr constant [12 x i8] c"!bs->refcnt\00", align 1
@__PRETTY_FUNCTION__.bdrv_close = private unnamed_addr constant [36 x i8] c"void bdrv_close(BlockDriverState *)\00", align 1
@__func__.bdrv_close = private unnamed_addr constant [11 x i8] c"bdrv_close\00", align 1
@.str.286 = private unnamed_addr constant [32 x i8] c"QLIST_EMPTY(&bs->dirty_bitmaps)\00", align 1
@__PRETTY_FUNCTION__.bdrv_change_aio_context = private unnamed_addr constant [103 x i8] c"_Bool bdrv_change_aio_context(BlockDriverState *, AioContext *, GHashTable *, Transaction *, Error **)\00", align 1
@set_aio_context = internal global %struct.TransactionActionDrv { ptr null, ptr @bdrv_set_aio_context_commit, ptr @bdrv_set_aio_context_clean }, align 8
@__PRETTY_FUNCTION__.bdrv_parent_change_aio_context = private unnamed_addr constant [103 x i8] c"_Bool bdrv_parent_change_aio_context(BdrvChild *, AioContext *, GHashTable *, Transaction *, Error **)\00", align 1
@__func__.bdrv_parent_change_aio_context = private unnamed_addr constant [31 x i8] c"bdrv_parent_change_aio_context\00", align 1
@.str.287 = private unnamed_addr constant [42 x i8] c"Changing iothreads is not supported by %s\00", align 1
@.str.288 = private unnamed_addr constant [15 x i8] c"!errp || *errp\00", align 1
@.str.289 = private unnamed_addr constant [27 x i8] c"!bs->walking_aio_notifiers\00", align 1
@__PRETTY_FUNCTION__.bdrv_detach_aio_context = private unnamed_addr constant [49 x i8] c"void bdrv_detach_aio_context(BlockDriverState *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_attach_aio_context = private unnamed_addr constant [63 x i8] c"void bdrv_attach_aio_context(BlockDriverState *, AioContext *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_do_remove_aio_context_notifier = private unnamed_addr constant [60 x i8] c"void bdrv_do_remove_aio_context_notifier(BdrvAioNotifier *)\00", align 1
@__PRETTY_FUNCTION__.bdrv_backing_overridden = private unnamed_addr constant [50 x i8] c"_Bool bdrv_backing_overridden(BlockDriverState *)\00", align 1
@.str.290 = private unnamed_addr constant [25 x i8] c"strlen(*option_name) > 0\00", align 1
@__PRETTY_FUNCTION__.append_strong_runtime_options = private unnamed_addr constant [65 x i8] c"_Bool append_strong_runtime_options(QDict *, BlockDriverState *)\00", align 1
@strong_options.global_options = internal constant [3 x ptr] [ptr @.str.20, ptr @.str.5, ptr null], align 16
@.str.291 = private unnamed_addr constant [32 x i8] c"!bs->drv || !bs->drv->is_filter\00", align 1
@__PRETTY_FUNCTION__.bdrv_do_skip_filters = private unnamed_addr constant [66 x i8] c"BlockDriverState *bdrv_do_skip_filters(BlockDriverState *, _Bool)\00", align 1
@.str.292 = private unnamed_addr constant [97 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/rcu.h\00", align 1
@__func__.rcu_read_lock = private unnamed_addr constant [14 x i8] c"rcu_read_lock\00", align 1
@rcu_gp_ctr = external global i64, align 8
@.str.293 = private unnamed_addr constant [25 x i8] c"p_rcu_reader->depth != 0\00", align 1
@__PRETTY_FUNCTION__.rcu_read_unlock = private unnamed_addr constant [27 x i8] c"void rcu_read_unlock(void)\00", align 1
@__func__.rcu_read_unlock = private unnamed_addr constant [16 x i8] c"rcu_read_unlock\00", align 1
@rcu_gp_event = external global %struct.QemuEvent, align 4
@__func__.bdrv_bsc_range_overlaps_locked = private unnamed_addr constant [31 x i8] c"bdrv_bsc_range_overlaps_locked\00", align 1
@.str.294 = private unnamed_addr constant [16 x i8] c"no_coroutine_fn\00", section "llvm.metadata"
@.str.295 = private unnamed_addr constant [112 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/sysemu/block-backend-io.h\00", section "llvm.metadata"
@.str.296 = private unnamed_addr constant [19 x i8] c"coroutine_mixed_fn\00", section "llvm.metadata"
@.str.297 = private unnamed_addr constant [16 x i8] c"../qemu/block.c\00", section "llvm.metadata"
@.str.298 = private unnamed_addr constant [105 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/graph-lock.h\00", section "llvm.metadata"
@.str.299 = private unnamed_addr constant [98 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/aio.h\00", section "llvm.metadata"
@.str.300 = private unnamed_addr constant [122 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/sysemu/block-backend-global-state.h\00", section "llvm.metadata"
@.str.301 = private unnamed_addr constant [107 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/block_int-io.h\00", section "llvm.metadata"
@.str.302 = private unnamed_addr constant [103 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/block-io.h\00", section "llvm.metadata"
@.str.303 = private unnamed_addr constant [108 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/qemu/coroutine-core.h\00", section "llvm.metadata"
@.str.304 = private unnamed_addr constant [113 x i8] c"/home/dtcxzyw/WorkSpace/Projects/compilers/llvm-opt-benchmark/bench/qemu/qemu/include/block/block-global-state.h\00", section "llvm.metadata"
@llvm.global.annotations = appending global [61 x { ptr, ptr, ptr, i32, ptr }] [{ ptr, ptr, ptr, i32, ptr } { ptr @blk_getlength, ptr @.str.294, ptr @.str.295, i32 81, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_getlength, ptr @.str.296, ptr @.str.295, i32 81, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_unref, ptr @.str.294, ptr @.str.297, i32 7245, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_open_child, ptr @.str.294, ptr @.str.297, i32 3774, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_graph_wrunlock, ptr @.str.294, ptr @.str.298, i32 130, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_open_driver, ptr @.str.294, ptr @.str.297, i32 1625, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_change_backing_file, ptr @.str.13, ptr @.str.297, i32 5773, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @aio_co_reschedule_self, ptr @.str.13, ptr @.str.299, i32 645, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @create_file_fallback_zero_first_sector, ptr @.str.13, ptr @.str.297, i32 604, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_create, ptr @.str.13, ptr @.str.297, i32 534, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_check, ptr @.str.13, ptr @.str.297, i32 5748, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @create_file_fallback_truncate, ptr @.str.13, ptr @.str.297, i32 563, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_debug_event, ptr @.str.13, ptr @.str.297, i32 6721, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_enter, ptr @.str.13, ptr @.str.297, i32 7561, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_graph_wrunlock_ctx, ptr @.str.294, ptr @.str.298, i32 140, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_get_info, ptr @.str.13, ptr @.str.297, i32 6662, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_is_inserted, ptr @.str.294, ptr @.str.295, i32 69, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_is_inserted, ptr @.str.296, ptr @.str.295, i32 69, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_create_opts_simple, ptr @.str.13, ptr @.str.297, i32 631, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_co_new_open, ptr @.str.13, ptr @.str.300, i32 40, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_refresh_total_sectors, ptr @.str.294, ptr @.str.301, i32 131, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_refresh_total_sectors, ptr @.str.296, ptr @.str.301, i32 131, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_is_inserted, ptr @.str.13, ptr @.str.297, i32 7184, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_delete_file_noerr, ptr @.str.13, ptr @.str.297, i32 770, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_has_zero_init, ptr @.str.296, ptr @.str.297, i32 6618, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_eject, ptr @.str.13, ptr @.str.297, i32 7208, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_activate, ptr @.str.294, ptr @.str.297, i32 6937, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_graph_wrlock, ptr @.str.294, ptr @.str.298, i32 120, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_flush, ptr @.str.294, ptr @.str.302, i32 372, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_flush, ptr @.str.296, ptr @.str.302, i32 372, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_open_blockdev_ref, ptr @.str.294, ptr @.str.297, i32 3835, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_lock, ptr @.str.13, ptr @.str.297, i32 7586, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_open, ptr @.str.294, ptr @.str.297, i32 4267, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_create_file, ptr @.str.13, ptr @.str.297, i32 693, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_invalidate_cache, ptr @.str.294, ptr @.str.302, i32 370, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_invalidate_cache, ptr @.str.296, ptr @.str.302, i32 370, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_open_inherit, ptr @.str.294, ptr @.str.297, i32 3962, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @qemu_co_mutex_unlock, ptr @.str.13, ptr @.str.303, i32 152, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_co_unref, ptr @.str.13, ptr @.str.300, i32 47, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_co_getlength, ptr @.str.13, ptr @.str.295, i32 80, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_nb_sectors, ptr @.str.13, ptr @.str.297, i32 6160, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_unlock, ptr @.str.13, ptr @.str.297, i32 7603, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_get_allocated_file_size, ptr @.str.13, ptr @.str.297, i32 6092, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_refresh_total_sectors, ptr @.str.13, ptr @.str.297, i32 1051, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_change_backing_file, ptr @.str.294, ptr @.str.302, i32 218, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_co_pwrite_zeroes, ptr @.str.13, ptr @.str.295, i32 190, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_invalidate_cache, ptr @.str.13, ptr @.str.297, i32 7012, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_getlength, ptr @.str.13, ptr @.str.297, i32 6204, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_nb_sectors, ptr @.str.296, ptr @.str.297, i32 6182, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_pread, ptr @.str.294, ptr @.str.295, i32 138, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_pread, ptr @.str.296, ptr @.str.295, i32 138, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_create, ptr @.str.294, ptr @.str.304, i32 65, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_getlength, ptr @.str.294, ptr @.str.302, i32 85, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_getlength, ptr @.str.296, ptr @.str.302, i32 85, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_delete_file, ptr @.str.13, ptr @.str.297, i32 742, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_leave, ptr @.str.13, ptr @.str.297, i32 7579, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @qemu_co_mutex_lock, ptr @.str.13, ptr @.str.303, i32 146, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_sum_allocated_file_size, ptr @.str.13, ptr @.str.297, i32 6068, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_co_truncate, ptr @.str.13, ptr @.str.295, i32 226, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @bdrv_co_lock_medium, ptr @.str.13, ptr @.str.297, i32 7223, ptr null }, { ptr, ptr, ptr, i32, ptr } { ptr @blk_unref, ptr @.str.294, ptr @.str.300, i32 46, ptr null }], section "llvm.metadata"

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_opt_mem_align(ptr noundef %bs) #0 {
entry:
  %retval = alloca i64, align 8
  %bs.addr = alloca ptr, align 8
  %_a5 = alloca i64, align 8
  %_b6 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 4096, ptr %_a5, align 8
  %call = call i64 @qemu_real_host_page_size()
  store i64 %call, ptr %_b6, align 8
  %3 = load i64, ptr %_a5, align 8
  %4 = load i64, ptr %_b6, align 8
  %cmp = icmp ugt i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %5 = load i64, ptr %_a5, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %6 = load i64, ptr %_b6, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %7 = load i64, ptr %tmp, align 8
  store i64 %7, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  br label %do.body

do.body:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.body
  %8 = load ptr, ptr %bs.addr, align 8
  %bl = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 17
  %opt_mem_alignment = getelementptr inbounds %struct.BlockLimits, ptr %bl, i32 0, i32 10
  %9 = load i64, ptr %opt_mem_alignment, align 8
  store i64 %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end, %cond.end
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @qemu_real_host_page_size() #0 {
entry:
  %call = call i32 @getpagesize() #12
  %conv = sext i32 %call to i64
  ret i64 %conv
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_min_mem_align(ptr noundef %bs) #0 {
entry:
  %retval = alloca i64, align 8
  %bs.addr = alloca ptr, align 8
  %_a7 = alloca i64, align 8
  %_b8 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 4096, ptr %_a7, align 8
  %call = call i64 @qemu_real_host_page_size()
  store i64 %call, ptr %_b8, align 8
  %3 = load i64, ptr %_a7, align 8
  %4 = load i64, ptr %_b8, align 8
  %cmp = icmp ugt i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %5 = load i64, ptr %_a7, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %6 = load i64, ptr %_b8, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ %6, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %7 = load i64, ptr %tmp, align 8
  store i64 %7, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  br label %do.body

do.body:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.body
  %8 = load ptr, ptr %bs.addr, align 8
  %bl = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 17
  %min_mem_alignment = getelementptr inbounds %struct.BlockLimits, ptr %bl, i32 0, i32 9
  %9 = load i64, ptr %min_mem_alignment, align 8
  store i64 %9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %do.end, %cond.end
  %10 = load i64, ptr %retval, align 8
  ret i64 %10
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @path_has_protocol(ptr noundef %path) #0 {
entry:
  %path.addr = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %1 = load ptr, ptr %path.addr, align 8
  %call = call i64 @strcspn(ptr noundef %1, ptr noundef @.str) #13
  %add.ptr = getelementptr i8, ptr %0, i64 %call
  store ptr %add.ptr, ptr %p, align 8
  %2 = load ptr, ptr %p, align 8
  %3 = load i8, ptr %2, align 1
  %conv = sext i8 %3 to i32
  %cmp = icmp eq i32 %conv, 58
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strcspn(ptr noundef, ptr noundef) #1

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @path_is_absolute(ptr noundef %path) #0 {
entry:
  %path.addr = alloca ptr, align 8
  store ptr %path, ptr %path.addr, align 8
  %0 = load ptr, ptr %path.addr, align 8
  %1 = load i8, ptr %0, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 47
  %conv1 = zext i1 %cmp to i32
  ret i32 %conv1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @path_combine(ptr noundef %base_path, ptr noundef %filename) #0 {
entry:
  %retval = alloca ptr, align 8
  %base_path.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %protocol_stripped = alloca ptr, align 8
  %p = alloca ptr, align 8
  %p1 = alloca ptr, align 8
  %result = alloca ptr, align 8
  %len = alloca i32, align 4
  store ptr %base_path, ptr %base_path.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr null, ptr %protocol_stripped, align 8
  %0 = load ptr, ptr %filename.addr, align 8
  %call = call i32 @path_is_absolute(ptr noundef %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %filename.addr, align 8
  %call1 = call noalias ptr @g_strdup(ptr noundef %1)
  store ptr %call1, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %base_path.addr, align 8
  %call2 = call i32 @path_has_protocol(ptr noundef %2)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.end9

if.then4:                                         ; preds = %if.end
  %3 = load ptr, ptr %base_path.addr, align 8
  %call5 = call ptr @strchr(ptr noundef %3, i32 noundef 58) #13
  store ptr %call5, ptr %protocol_stripped, align 8
  %4 = load ptr, ptr %protocol_stripped, align 8
  %tobool6 = icmp ne ptr %4, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.then4
  %5 = load ptr, ptr %protocol_stripped, align 8
  %incdec.ptr = getelementptr i8, ptr %5, i32 1
  store ptr %incdec.ptr, ptr %protocol_stripped, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.then4
  br label %if.end9

if.end9:                                          ; preds = %if.end8, %if.end
  %6 = load ptr, ptr %protocol_stripped, align 8
  %tobool10 = icmp ne ptr %6, null
  br i1 %tobool10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end9
  br label %cond.end

cond.false:                                       ; preds = %if.end9
  %7 = load ptr, ptr %base_path.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %6, %cond.true ], [ %7, %cond.false ]
  store ptr %cond, ptr %p, align 8
  %8 = load ptr, ptr %base_path.addr, align 8
  %call11 = call ptr @strrchr(ptr noundef %8, i32 noundef 47) #13
  store ptr %call11, ptr %p1, align 8
  %9 = load ptr, ptr %p1, align 8
  %tobool12 = icmp ne ptr %9, null
  br i1 %tobool12, label %if.then13, label %if.else

if.then13:                                        ; preds = %cond.end
  %10 = load ptr, ptr %p1, align 8
  %incdec.ptr14 = getelementptr i8, ptr %10, i32 1
  store ptr %incdec.ptr14, ptr %p1, align 8
  br label %if.end15

if.else:                                          ; preds = %cond.end
  %11 = load ptr, ptr %base_path.addr, align 8
  store ptr %11, ptr %p1, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.else, %if.then13
  %12 = load ptr, ptr %p1, align 8
  %13 = load ptr, ptr %p, align 8
  %cmp = icmp ugt ptr %12, %13
  br i1 %cmp, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end15
  %14 = load ptr, ptr %p1, align 8
  store ptr %14, ptr %p, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end15
  %15 = load ptr, ptr %p, align 8
  %16 = load ptr, ptr %base_path.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %15 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %16 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  store i32 %conv, ptr %len, align 4
  %17 = load i32, ptr %len, align 4
  %conv18 = sext i32 %17 to i64
  %18 = load ptr, ptr %filename.addr, align 8
  %call19 = call i64 @strlen(ptr noundef %18) #13
  %add = add i64 %conv18, %call19
  %add20 = add i64 %add, 1
  %call21 = call noalias ptr @g_malloc(i64 noundef %add20) #14
  store ptr %call21, ptr %result, align 8
  %19 = load ptr, ptr %result, align 8
  %20 = load ptr, ptr %base_path.addr, align 8
  %21 = load i32, ptr %len, align 4
  %conv22 = sext i32 %21 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %19, ptr align 1 %20, i64 %conv22, i1 false)
  %22 = load ptr, ptr %result, align 8
  %23 = load i32, ptr %len, align 4
  %idx.ext = sext i32 %23 to i64
  %add.ptr = getelementptr i8, ptr %22, i64 %idx.ext
  %24 = load ptr, ptr %filename.addr, align 8
  %call23 = call ptr @strcpy(ptr noundef %add.ptr, ptr noundef %24) #15
  %25 = load ptr, ptr %result, align 8
  store ptr %25, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end17, %if.then
  %26 = load ptr, ptr %retval, align 8
  ret ptr %26
}

declare noalias ptr @g_strdup(ptr noundef) #2

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strchr(ptr noundef, i32 noundef) #1

; Function Attrs: nounwind willreturn memory(read)
declare ptr @strrchr(ptr noundef, i32 noundef) #1

; Function Attrs: allocsize(0)
declare noalias ptr @g_malloc(i64 noundef) #3

; Function Attrs: nounwind willreturn memory(read)
declare i64 @strlen(ptr noundef) #1

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #4

; Function Attrs: nounwind
declare ptr @strcpy(ptr noundef, ptr noundef) #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_parse_filename_strip_prefix(ptr noundef %filename, ptr noundef %prefix, ptr noundef %options) #0 {
entry:
  %filename.addr = alloca ptr, align 8
  %prefix.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %fat_filename = alloca ptr, align 8
  %_obj9 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp16 = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %prefix, ptr %prefix.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  %0 = load ptr, ptr %filename.addr, align 8
  %1 = load ptr, ptr %prefix.addr, align 8
  %call = call i32 @strstart(ptr noundef %0, ptr noundef %1, ptr noundef %filename.addr)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end19

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %filename.addr, align 8
  %call1 = call i32 @path_has_protocol(ptr noundef %2)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then3, label %if.else17

if.then3:                                         ; preds = %if.then
  %3 = load ptr, ptr %filename.addr, align 8
  %call4 = call i32 @path_is_absolute(ptr noundef %3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.else, label %if.then6

if.then6:                                         ; preds = %if.then3
  br label %if.end

if.else:                                          ; preds = %if.then3
  call void @__assert_fail(ptr noundef @.str.1, ptr noundef @.str.2, i32 noundef 253, ptr noundef @__PRETTY_FUNCTION__.bdrv_parse_filename_strip_prefix) #16
  unreachable

if.end:                                           ; preds = %if.then6
  %call7 = call ptr @g_string_new(ptr noundef @.str.3)
  store ptr %call7, ptr %fat_filename, align 8
  %4 = load ptr, ptr %fat_filename, align 8
  %5 = load ptr, ptr %filename.addr, align 8
  %call8 = call ptr @g_string_append(ptr noundef %4, ptr noundef %5)
  %6 = load ptr, ptr %fat_filename, align 8
  %str = getelementptr inbounds %struct._GString, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %str, align 8
  %call9 = call i32 @path_has_protocol(ptr noundef %7)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.else12, label %if.then11

if.then11:                                        ; preds = %if.end
  br label %if.end13

if.else12:                                        ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.4, ptr noundef @.str.2, i32 noundef 260, ptr noundef @__PRETTY_FUNCTION__.bdrv_parse_filename_strip_prefix) #16
  unreachable

if.end13:                                         ; preds = %if.then11
  %8 = load ptr, ptr %options.addr, align 8
  %9 = load ptr, ptr %fat_filename, align 8
  %call14 = call ptr @qstring_from_gstring(ptr noundef %9)
  store ptr %call14, ptr %_obj9, align 8
  %10 = load ptr, ptr %_obj9, align 8
  %tobool15 = icmp ne ptr %10, null
  br i1 %tobool15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end13
  %11 = load ptr, ptr %_obj9, align 8
  %base = getelementptr inbounds %struct.QString, ptr %11, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %12 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %12, i64 0
  store ptr %add.ptr, ptr %tmp16, align 8
  %13 = load ptr, ptr %tmp16, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end13
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %13, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %14 = load ptr, ptr %tmp, align 8
  call void @qdict_put_obj(ptr noundef %8, ptr noundef @.str.5, ptr noundef %14)
  br label %if.end18

if.else17:                                        ; preds = %if.then
  %15 = load ptr, ptr %options.addr, align 8
  %16 = load ptr, ptr %filename.addr, align 8
  call void @qdict_put_str(ptr noundef %15, ptr noundef @.str.5, ptr noundef %16)
  br label %if.end18

if.end18:                                         ; preds = %if.else17, %cond.end
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %entry
  ret void
}

declare i32 @strstart(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: noreturn nounwind
declare void @__assert_fail(ptr noundef, ptr noundef, i32 noundef, ptr noundef) #6

declare ptr @g_string_new(ptr noundef) #2

declare ptr @g_string_append(ptr noundef, ptr noundef) #2

declare void @qdict_put_obj(ptr noundef, ptr noundef, ptr noundef) #2

declare ptr @qstring_from_gstring(ptr noundef) #2

declare void @qdict_put_str(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_is_read_only(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %open_flags, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_apply_auto_read_only(ptr noundef %bs, ptr noundef %errmsg, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %errmsg.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %errmsg, ptr %errmsg.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store i32 0, ptr %ret, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %open_flags, align 8
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %open_flags1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %open_flags1, align 8
  %and2 = and i32 %3, 131072
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %fail

if.end5:                                          ; preds = %if.end
  %4 = load ptr, ptr %bs.addr, align 8
  %call = call i32 @bdrv_can_set_read_only(ptr noundef %4, i1 noundef zeroext true, i1 noundef zeroext false, ptr noundef null)
  store i32 %call, ptr %ret, align 4
  %5 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end5
  br label %fail

if.end7:                                          ; preds = %if.end5
  %6 = load ptr, ptr %bs.addr, align 8
  %open_flags8 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %open_flags8, align 8
  %and9 = and i32 %7, -3
  store i32 %and9, ptr %open_flags8, align 8
  store i32 0, ptr %retval, align 4
  br label %return

fail:                                             ; preds = %if.then6, %if.then4
  %8 = load ptr, ptr %errp.addr, align 8
  %9 = load ptr, ptr %errmsg.addr, align 8
  %tobool10 = icmp ne ptr %9, null
  br i1 %tobool10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %fail
  br label %cond.end

cond.false:                                       ; preds = %fail
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %9, %cond.true ], [ @.str.7, %cond.false ]
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %8, ptr noundef @.str.2, i32 noundef 340, ptr noundef @__func__.bdrv_apply_auto_read_only, ptr noundef @.str.6, ptr noundef %cond)
  store i32 -13, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.end7, %if.then
  %10 = load i32, ptr %retval, align 4
  ret i32 %10
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_can_set_read_only(ptr noundef %bs, i1 noundef zeroext %read_only, i1 noundef zeroext %ignore_allow_rdw, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %read_only.addr = alloca i8, align 1
  %ignore_allow_rdw.addr = alloca i8, align 1
  %errp.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %frombool = zext i1 %read_only to i8
  store i8 %frombool, ptr %read_only.addr, align 1
  %frombool1 = zext i1 %ignore_allow_rdw to i8
  store i8 %frombool1, ptr %ignore_allow_rdw.addr, align 1
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %copy_on_read = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 42
  %1 = load i32, ptr %copy_on_read, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %do.end
  %2 = load i8, ptr %read_only.addr, align 1
  %tobool2 = trunc i8 %2 to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr %errp.addr, align 8
  %4 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_get_device_or_node_name(ptr noundef %4)
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %3, ptr noundef @.str.2, i32 noundef 291, ptr noundef @__func__.bdrv_can_set_read_only, ptr noundef @.str.156, ptr noundef %call)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %do.end
  %5 = load i8, ptr %read_only.addr, align 1
  %tobool3 = trunc i8 %5 to i1
  br i1 %tobool3, label %if.end10, label %land.lhs.true4

land.lhs.true4:                                   ; preds = %if.end
  %6 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 0
  %7 = load i32, ptr %open_flags, align 8
  %and = and i32 %7, 8192
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool5, label %if.end10, label %land.lhs.true6

land.lhs.true6:                                   ; preds = %land.lhs.true4
  %8 = load i8, ptr %ignore_allow_rdw.addr, align 1
  %tobool7 = trunc i8 %8 to i1
  br i1 %tobool7, label %if.end10, label %if.then8

if.then8:                                         ; preds = %land.lhs.true6
  %9 = load ptr, ptr %errp.addr, align 8
  %10 = load ptr, ptr %bs.addr, align 8
  %call9 = call ptr @bdrv_get_device_or_node_name(ptr noundef %10)
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %9, ptr noundef @.str.2, i32 noundef 300, ptr noundef @__func__.bdrv_can_set_read_only, ptr noundef @.str.157, ptr noundef %call9)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %land.lhs.true6, %land.lhs.true4, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.then8, %if.then
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

declare void @error_setg_internal(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef, ...) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_full_backing_filename_from_filename(ptr noundef %backed, ptr noundef %backing, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %backed.addr = alloca ptr, align 8
  %backing.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  store ptr %backed, ptr %backed.addr, align 8
  store ptr %backing, ptr %backing.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %backing.addr, align 8
  %arrayidx = getelementptr i8, ptr %0, i64 0
  %1 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %backing.addr, align 8
  %call = call i32 @path_has_protocol(ptr noundef %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then4, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %3 = load ptr, ptr %backing.addr, align 8
  %call2 = call i32 @path_is_absolute(ptr noundef %3)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then4, label %if.else6

if.then4:                                         ; preds = %lor.lhs.false, %if.else
  %4 = load ptr, ptr %backing.addr, align 8
  %call5 = call noalias ptr @g_strdup(ptr noundef %4)
  store ptr %call5, ptr %retval, align 8
  br label %return

if.else6:                                         ; preds = %lor.lhs.false
  %5 = load ptr, ptr %backed.addr, align 8
  %arrayidx7 = getelementptr i8, ptr %5, i64 0
  %6 = load i8, ptr %arrayidx7, align 1
  %conv8 = sext i8 %6 to i32
  %cmp9 = icmp eq i32 %conv8, 0
  br i1 %cmp9, label %if.then14, label %lor.lhs.false11

lor.lhs.false11:                                  ; preds = %if.else6
  %7 = load ptr, ptr %backed.addr, align 8
  %call12 = call i32 @strstart(ptr noundef %7, ptr noundef @.str.8, ptr noundef null)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %lor.lhs.false11, %if.else6
  %8 = load ptr, ptr %errp.addr, align 8
  %9 = load ptr, ptr %backed.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %8, ptr noundef @.str.2, i32 noundef 363, ptr noundef @__func__.bdrv_get_full_backing_filename_from_filename, ptr noundef @.str.9, ptr noundef %9)
  store ptr null, ptr %retval, align 8
  br label %return

if.else15:                                        ; preds = %lor.lhs.false11
  %10 = load ptr, ptr %backed.addr, align 8
  %11 = load ptr, ptr %backing.addr, align 8
  %call16 = call ptr @path_combine(ptr noundef %10, ptr noundef %11)
  store ptr %call16, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else15, %if.then14, %if.then4, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_full_backing_filename(ptr noundef %bs, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 399, ptr noundef @__PRETTY_FUNCTION__.bdrv_get_full_backing_filename) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %1 = load ptr, ptr %bs.addr, align 8
  %backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 12
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %backing_file, i64 0, i64 0
  %2 = load ptr, ptr %errp.addr, align 8
  %call1 = call ptr @bdrv_make_absolute_filename(ptr noundef %0, ptr noundef %arraydecay, ptr noundef %2)
  ret ptr %call1
}

declare zeroext i1 @qemu_in_main_thread() #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_make_absolute_filename(ptr noundef %relative_to, ptr noundef %filename, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %relative_to.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %dir = alloca ptr, align 8
  %full_name = alloca ptr, align 8
  store ptr %relative_to, ptr %relative_to.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %filename.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %filename.addr, align 8
  %arrayidx = getelementptr i8, ptr %1, i64 0
  %2 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %3 = load ptr, ptr %filename.addr, align 8
  %call = call i32 @path_has_protocol(ptr noundef %3)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.then6, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %if.else
  %4 = load ptr, ptr %filename.addr, align 8
  %call4 = call i32 @path_is_absolute(ptr noundef %4)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %lor.lhs.false3, %if.else
  %5 = load ptr, ptr %filename.addr, align 8
  %call7 = call noalias ptr @g_strdup(ptr noundef %5)
  store ptr %call7, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false3
  br label %if.end8

if.end8:                                          ; preds = %if.end
  %6 = load ptr, ptr %relative_to.addr, align 8
  %7 = load ptr, ptr %errp.addr, align 8
  %call9 = call ptr @bdrv_dirname(ptr noundef %6, ptr noundef %7)
  store ptr %call9, ptr %dir, align 8
  %8 = load ptr, ptr %dir, align 8
  %tobool10 = icmp ne ptr %8, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end8
  store ptr null, ptr %retval, align 8
  br label %return

if.end12:                                         ; preds = %if.end8
  %9 = load ptr, ptr %dir, align 8
  %10 = load ptr, ptr %filename.addr, align 8
  %call13 = call noalias ptr (ptr, ...) @g_strconcat(ptr noundef %9, ptr noundef %10, ptr noundef null)
  store ptr %call13, ptr %full_name, align 8
  %11 = load ptr, ptr %dir, align 8
  call void @g_free(ptr noundef %11)
  %12 = load ptr, ptr %full_name, align 8
  store ptr %12, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then11, %if.then6, %if.then
  %13 = load ptr, ptr %retval, align 8
  ret ptr %13
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_register(ptr noundef %bdrv) #0 {
entry:
  %bdrv.addr = alloca ptr, align 8
  store ptr %bdrv, ptr %bdrv.addr, align 8
  %0 = load ptr, ptr %bdrv.addr, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %format_name, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.11, ptr noundef @.str.2, i32 noundef 405, ptr noundef @__PRETTY_FUNCTION__.bdrv_register) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.body
  br label %if.end3

if.else2:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 406, ptr noundef @__PRETTY_FUNCTION__.bdrv_register) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  br label %do.end

do.end:                                           ; preds = %if.end3
  br label %do.body4

do.body4:                                         ; preds = %do.end
  %2 = load ptr, ptr @bdrv_drivers, align 8
  %3 = load ptr, ptr %bdrv.addr, align 8
  %list = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 61
  %le_next = getelementptr inbounds %struct.anon.9, ptr %list, i32 0, i32 0
  store ptr %2, ptr %le_next, align 8
  %cmp = icmp ne ptr %2, null
  br i1 %cmp, label %if.then5, label %if.end9

if.then5:                                         ; preds = %do.body4
  %4 = load ptr, ptr %bdrv.addr, align 8
  %list6 = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 61
  %le_next7 = getelementptr inbounds %struct.anon.9, ptr %list6, i32 0, i32 0
  %5 = load ptr, ptr @bdrv_drivers, align 8
  %list8 = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 61
  %le_prev = getelementptr inbounds %struct.anon.9, ptr %list8, i32 0, i32 1
  store ptr %le_next7, ptr %le_prev, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.then5, %do.body4
  %6 = load ptr, ptr %bdrv.addr, align 8
  store ptr %6, ptr @bdrv_drivers, align 8
  %7 = load ptr, ptr %bdrv.addr, align 8
  %list10 = getelementptr inbounds %struct.BlockDriver, ptr %7, i32 0, i32 61
  %le_prev11 = getelementptr inbounds %struct.anon.9, ptr %list10, i32 0, i32 1
  store ptr @bdrv_drivers, ptr %le_prev11, align 8
  br label %do.end12

do.end12:                                         ; preds = %if.end9
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_new() #0 {
entry:
  %bs = alloca ptr, align 8
  %i = alloca i32, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 415, ptr noundef @__PRETTY_FUNCTION__.bdrv_new) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 17144) #17
  store ptr %call1, ptr %bs, align 8
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %0 = load ptr, ptr %bs, align 8
  %dirty_bitmaps = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 40
  %lh_first = getelementptr inbounds %struct.anon.5, ptr %dirty_bitmaps, i32 0, i32 0
  store ptr null, ptr %lh_first, align 8
  br label %do.end3

do.end3:                                          ; preds = %do.body2
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end3
  %1 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %1, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body4

do.body4:                                         ; preds = %for.body
  %2 = load ptr, ptr %bs, align 8
  %op_blockers = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 27
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr [16 x %struct.anon.2], ptr %op_blockers, i64 0, i64 %idxprom
  %lh_first5 = getelementptr inbounds %struct.anon.2, ptr %arrayidx, i32 0, i32 0
  store ptr null, ptr %lh_first5, align 8
  br label %do.end6

do.end6:                                          ; preds = %do.body4
  br label %for.inc

for.inc:                                          ; preds = %do.end6
  %4 = load i32, ptr %i, align 4
  %inc = add i32 %4, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !5

for.end:                                          ; preds = %for.cond
  %5 = load ptr, ptr %bs, align 8
  %reqs_lock = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 48
  call void @qemu_mutex_init(ptr noundef %reqs_lock)
  %6 = load ptr, ptr %bs, align 8
  %dirty_bitmap_mutex = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 39
  call void @qemu_mutex_init(ptr noundef %dirty_bitmap_mutex)
  %7 = load ptr, ptr %bs, align 8
  %refcnt = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 26
  store i32 1, ptr %refcnt, align 8
  %call7 = call ptr @qemu_get_aio_context()
  %8 = load ptr, ptr %bs, align 8
  %aio_context = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 8
  store ptr %call7, ptr %aio_context, align 8
  %9 = load ptr, ptr %bs, align 8
  %flush_queue = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 50
  call void @qemu_co_queue_init(ptr noundef %flush_queue)
  %10 = load ptr, ptr %bs, align 8
  %bsc_modify_lock = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 54
  call void @qemu_co_mutex_init(ptr noundef %bsc_modify_lock)
  %call8 = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 40) #17
  %11 = load ptr, ptr %bs, align 8
  %block_status_cache = getelementptr inbounds %struct.BlockDriverState, ptr %11, i32 0, i32 55
  store ptr %call8, ptr %block_status_cache, align 8
  store i32 0, ptr %i, align 4
  br label %for.cond9

for.cond9:                                        ; preds = %for.inc12, %for.end
  %12 = load i32, ptr %i, align 4
  %13 = load i32, ptr @bdrv_drain_all_count, align 4
  %cmp10 = icmp ult i32 %12, %13
  br i1 %cmp10, label %for.body11, label %for.end14

for.body11:                                       ; preds = %for.cond9
  %14 = load ptr, ptr %bs, align 8
  call void @bdrv_drained_begin(ptr noundef %14)
  br label %for.inc12

for.inc12:                                        ; preds = %for.body11
  %15 = load i32, ptr %i, align 4
  %inc13 = add i32 %15, 1
  store i32 %inc13, ptr %i, align 4
  br label %for.cond9, !llvm.loop !7

for.end14:                                        ; preds = %for.cond9
  br label %do.body15

do.body15:                                        ; preds = %for.end14
  %16 = load ptr, ptr %bs, align 8
  %bs_list = getelementptr inbounds %struct.BlockDriverState, ptr %16, i32 0, i32 24
  store ptr null, ptr %bs_list, align 8
  %17 = load ptr, ptr getelementptr inbounds (%struct.QTailQLink, ptr @all_bdrv_states, i32 0, i32 1), align 8
  %18 = load ptr, ptr %bs, align 8
  %bs_list16 = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 24
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %bs_list16, i32 0, i32 1
  store ptr %17, ptr %tql_prev, align 8
  %19 = load ptr, ptr %bs, align 8
  %20 = load ptr, ptr getelementptr inbounds (%struct.QTailQLink, ptr @all_bdrv_states, i32 0, i32 1), align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %20, i32 0, i32 0
  store ptr %19, ptr %tql_next, align 8
  %21 = load ptr, ptr %bs, align 8
  %bs_list17 = getelementptr inbounds %struct.BlockDriverState, ptr %21, i32 0, i32 24
  store ptr %bs_list17, ptr getelementptr inbounds (%struct.QTailQLink, ptr @all_bdrv_states, i32 0, i32 1), align 8
  br label %do.end18

do.end18:                                         ; preds = %do.body15
  %22 = load ptr, ptr %bs, align 8
  ret ptr %22
}

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_malloc0_n(i64 noundef, i64 noundef) #7

declare void @qemu_mutex_init(ptr noundef) #2

declare ptr @qemu_get_aio_context() #2

declare void @qemu_co_queue_init(ptr noundef) #2

declare void @qemu_co_mutex_init(ptr noundef) #2

declare void @bdrv_drained_begin(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_format(ptr noundef %format_name) #0 {
entry:
  %retval = alloca ptr, align 8
  %format_name.addr = alloca ptr, align 8
  %drv1 = alloca ptr, align 8
  %i = alloca i32, align 4
  %local_err = alloca ptr, align 8
  %rv = alloca i32, align 4
  store ptr %format_name, ptr %format_name.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 460, ptr noundef @__PRETTY_FUNCTION__.bdrv_find_format) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %format_name.addr, align 8
  %call1 = call ptr @bdrv_do_find_format(ptr noundef %0)
  store ptr %call1, ptr %drv1, align 8
  %1 = load ptr, ptr %drv1, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  %2 = load ptr, ptr %drv1, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %do.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %3 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, ptr %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr [0 x %struct.anon.12], ptr @block_driver_modules, i64 0, i64 %idxprom
  %format_name4 = getelementptr inbounds %struct.anon.12, ptr %arrayidx, i32 0, i32 0
  %5 = load ptr, ptr %format_name4, align 8
  %6 = load ptr, ptr %format_name.addr, align 8
  %call5 = call i32 @strcmp(ptr noundef %5, ptr noundef %6) #13
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end19, label %if.then7

if.then7:                                         ; preds = %for.body
  store ptr null, ptr %local_err, align 8
  %7 = load i32, ptr %i, align 4
  %idxprom8 = sext i32 %7 to i64
  %arrayidx9 = getelementptr [0 x %struct.anon.12], ptr @block_driver_modules, i64 0, i64 %idxprom8
  %library_name = getelementptr inbounds %struct.anon.12, ptr %arrayidx9, i32 0, i32 2
  %8 = load ptr, ptr %library_name, align 8
  %call10 = call i32 @module_load(ptr noundef @.str.12, ptr noundef %8, ptr noundef %local_err)
  store i32 %call10, ptr %rv, align 4
  %9 = load i32, ptr %rv, align 4
  %cmp11 = icmp sgt i32 %9, 0
  br i1 %cmp11, label %if.then12, label %if.else14

if.then12:                                        ; preds = %if.then7
  %10 = load ptr, ptr %format_name.addr, align 8
  %call13 = call ptr @bdrv_do_find_format(ptr noundef %10)
  store ptr %call13, ptr %retval, align 8
  br label %return

if.else14:                                        ; preds = %if.then7
  %11 = load i32, ptr %rv, align 4
  %cmp15 = icmp slt i32 %11, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.else14
  %12 = load ptr, ptr %local_err, align 8
  call void @error_report_err(ptr noundef %12)
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.else14
  br label %if.end18

if.end18:                                         ; preds = %if.end17
  br label %for.end

if.end19:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end19
  %13 = load i32, ptr %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !8

for.end:                                          ; preds = %if.end18, %for.cond
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then12, %if.then2
  %14 = load ptr, ptr %retval, align 8
  ret ptr %14
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_do_find_format(ptr noundef %format_name) #0 {
entry:
  %retval = alloca ptr, align 8
  %format_name.addr = alloca ptr, align 8
  %drv1 = alloca ptr, align 8
  store ptr %format_name, ptr %format_name.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 444, ptr noundef @__PRETTY_FUNCTION__.bdrv_do_find_format) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr @bdrv_drivers, align 8
  store ptr %0, ptr %drv1, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %1 = load ptr, ptr %drv1, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %drv1, align 8
  %format_name1 = getelementptr inbounds %struct.BlockDriver, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %format_name1, align 8
  %4 = load ptr, ptr %format_name.addr, align 8
  %call2 = call i32 @strcmp(ptr noundef %3, ptr noundef %4) #13
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %for.body
  %5 = load ptr, ptr %drv1, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end5
  %6 = load ptr, ptr %drv1, align 8
  %list = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 61
  %le_next = getelementptr inbounds %struct.anon.9, ptr %list, i32 0, i32 0
  %7 = load ptr, ptr %le_next, align 8
  store ptr %7, ptr %drv1, align 8
  br label %for.cond, !llvm.loop !9

for.end:                                          ; preds = %for.cond
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then4
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind willreturn memory(read)
declare i32 @strcmp(ptr noundef, ptr noundef) #1

declare i32 @module_load(ptr noundef, ptr noundef, ptr noundef) #2

declare void @error_report_err(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_is_whitelisted(ptr noundef %drv, i1 noundef zeroext %read_only) #0 {
entry:
  %drv.addr = alloca ptr, align 8
  %read_only.addr = alloca i8, align 1
  store ptr %drv, ptr %drv.addr, align 8
  %frombool = zext i1 %read_only to i8
  store i8 %frombool, ptr %read_only.addr, align 1
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 517, ptr noundef @__PRETTY_FUNCTION__.bdrv_is_whitelisted) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %drv.addr, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %format_name, align 8
  %2 = load i8, ptr %read_only.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call1 = call i32 @bdrv_format_is_whitelisted(ptr noundef %1, i1 noundef zeroext %tobool)
  ret i32 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_format_is_whitelisted(ptr noundef %format_name, i1 noundef zeroext %read_only) #0 {
entry:
  %retval = alloca i32, align 4
  %format_name.addr = alloca ptr, align 8
  %read_only.addr = alloca i8, align 1
  %p = alloca ptr, align 8
  store ptr %format_name, ptr %format_name.addr, align 8
  %frombool = zext i1 %read_only to i8
  store i8 %frombool, ptr %read_only.addr, align 1
  %0 = load ptr, ptr @bdrv_format_is_whitelisted.whitelist_rw, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr @bdrv_format_is_whitelisted.whitelist_ro, align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i32 1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store ptr @bdrv_format_is_whitelisted.whitelist_rw, ptr %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load ptr, ptr %p, align 8
  %3 = load ptr, ptr %2, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %format_name.addr, align 8
  %5 = load ptr, ptr %p, align 8
  %6 = load ptr, ptr %5, align 8
  %call = call i32 @strcmp(ptr noundef %4, ptr noundef %6) #13
  %tobool3 = icmp ne i32 %call, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %for.body
  store i32 1, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end5
  %7 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr ptr, ptr %7, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  br label %for.cond, !llvm.loop !10

for.end:                                          ; preds = %for.cond
  %8 = load i8, ptr %read_only.addr, align 1
  %tobool6 = trunc i8 %8 to i1
  br i1 %tobool6, label %if.then7, label %if.end18

if.then7:                                         ; preds = %for.end
  store ptr @bdrv_format_is_whitelisted.whitelist_ro, ptr %p, align 8
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc15, %if.then7
  %9 = load ptr, ptr %p, align 8
  %10 = load ptr, ptr %9, align 8
  %tobool9 = icmp ne ptr %10, null
  br i1 %tobool9, label %for.body10, label %for.end17

for.body10:                                       ; preds = %for.cond8
  %11 = load ptr, ptr %format_name.addr, align 8
  %12 = load ptr, ptr %p, align 8
  %13 = load ptr, ptr %12, align 8
  %call11 = call i32 @strcmp(ptr noundef %11, ptr noundef %13) #13
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %for.body10
  store i32 1, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %for.body10
  br label %for.inc15

for.inc15:                                        ; preds = %if.end14
  %14 = load ptr, ptr %p, align 8
  %incdec.ptr16 = getelementptr ptr, ptr %14, i32 1
  store ptr %incdec.ptr16, ptr %p, align 8
  br label %for.cond8, !llvm.loop !11

for.end17:                                        ; preds = %for.cond8
  br label %if.end18

if.end18:                                         ; preds = %for.end17, %for.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then13, %if.then4, %if.then
  %15 = load i32, ptr %retval, align 4
  ret i32 %15
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_uses_whitelist() #0 {
entry:
  %0 = load i32, ptr @use_bdrv_whitelist, align 4
  %tobool = icmp ne i32 %0, 0
  ret i1 %tobool
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_create(ptr noundef %drv, ptr noundef %filename, ptr noundef %opts, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %drv.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %opts.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %_auto_errp_prop = alloca %struct.ErrorPropagator, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %drv, ptr %drv.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %opts, ptr %opts.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 538, ptr noundef @__PRETTY_FUNCTION__.bdrv_co_create) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %local_err = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i32 0, i32 0
  store ptr null, ptr %local_err, align 8
  %errp1 = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i32 0, i32 1
  %0 = load ptr, ptr %errp.addr, align 8
  store ptr %0, ptr %errp1, align 8
  br label %do.body2

do.body2:                                         ; preds = %do.end
  %1 = load ptr, ptr %errp.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %do.body2
  %2 = load ptr, ptr %errp.addr, align 8
  %cmp = icmp eq ptr %2, @error_fatal
  br i1 %cmp, label %if.then3, label %if.end5

if.then3:                                         ; preds = %lor.lhs.false, %do.body2
  %local_err4 = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i32 0, i32 0
  store ptr %local_err4, ptr %errp.addr, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then3, %lor.lhs.false
  br label %do.cond

do.cond:                                          ; preds = %if.end5
  br label %do.end6

do.end6:                                          ; preds = %do.cond
  %3 = load ptr, ptr %drv.addr, align 8
  %bdrv_co_create_opts = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 27
  %4 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_create_opts, ptr @.str.13, ptr @.str.14, i32 259, ptr null)
  %5 = load ptr, ptr %4, align 8
  %tobool7 = icmp ne ptr %5, null
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %do.end6
  %6 = load ptr, ptr %errp.addr, align 8
  %7 = load ptr, ptr %drv.addr, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %format_name, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %6, ptr noundef @.str.2, i32 noundef 543, ptr noundef @__func__.bdrv_co_create, ptr noundef @.str.15, ptr noundef %8)
  store i32 -95, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end9:                                          ; preds = %do.end6
  %9 = load ptr, ptr %drv.addr, align 8
  %bdrv_co_create_opts10 = getelementptr inbounds %struct.BlockDriver, ptr %9, i32 0, i32 27
  %10 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_create_opts10, ptr @.str.13, ptr @.str.14, i32 259, ptr null)
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %drv.addr, align 8
  %13 = load ptr, ptr %filename.addr, align 8
  %14 = load ptr, ptr %opts.addr, align 8
  %15 = load ptr, ptr %errp.addr, align 8
  %call11 = call i32 %11(ptr noundef %12, ptr noundef %13, ptr noundef %14, ptr noundef %15)
  store i32 %call11, ptr %ret, align 4
  %16 = load i32, ptr %ret, align 4
  %cmp12 = icmp slt i32 %16, 0
  br i1 %cmp12, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %if.end9
  %17 = load ptr, ptr %errp.addr, align 8
  %18 = load ptr, ptr %17, align 8
  %tobool13 = icmp ne ptr %18, null
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %land.lhs.true
  %19 = load ptr, ptr %errp.addr, align 8
  %20 = load i32, ptr %ret, align 4
  %sub = sub i32 0, %20
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %19, ptr noundef @.str.2, i32 noundef 549, ptr noundef @__func__.bdrv_co_create, i32 noundef %sub, ptr noundef @.str.16)
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %land.lhs.true, %if.end9
  %21 = load i32, ptr %ret, align 4
  store i32 %21, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end15, %if.then8
  call void @glib_auto_cleanup_ErrorPropagator(ptr noundef %_auto_errp_prop)
  %22 = load i32, ptr %retval, align 4
  ret i32 %22
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_auto_cleanup_ErrorPropagator(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  call void @error_propagator_cleanup(ptr noundef %0)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare ptr @llvm.ptr.annotation.p0.p0(ptr, ptr, ptr, i32, ptr) #8

declare void @error_setg_errno_internal(ptr noundef, ptr noundef, i32 noundef, ptr noundef, i32 noundef, ptr noundef, ...) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_create_opts_simple(ptr noundef %drv, ptr noundef %filename, ptr noundef %opts, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %drv.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %opts.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %options = alloca ptr, align 8
  %size = alloca i64, align 8
  %buf = alloca ptr, align 8
  %prealloc = alloca i32, align 4
  %local_err = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %drv, ptr %drv.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %opts, ptr %opts.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store i64 0, ptr %size, align 8
  store ptr null, ptr %buf, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 644, ptr noundef @__PRETTY_FUNCTION__.bdrv_co_create_opts_simple) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %opts.addr, align 8
  %call1 = call i64 @qemu_opt_get_size_del(ptr noundef %0, ptr noundef @.str.17, i64 noundef 0)
  store i64 %call1, ptr %size, align 8
  %1 = load ptr, ptr %opts.addr, align 8
  %call2 = call ptr @qemu_opt_get_del(ptr noundef %1, ptr noundef @.str.18)
  store ptr %call2, ptr %buf, align 8
  %2 = load ptr, ptr %buf, align 8
  %call3 = call i32 @qapi_enum_parse(ptr noundef @PreallocMode_lookup, ptr noundef %2, i32 noundef 0, ptr noundef %local_err)
  store i32 %call3, ptr %prealloc, align 4
  %3 = load ptr, ptr %buf, align 8
  call void @g_free(ptr noundef %3)
  %4 = load ptr, ptr %local_err, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %do.end
  %5 = load ptr, ptr %errp.addr, align 8
  %6 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %5, ptr noundef %6)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %do.end
  %7 = load i32, ptr %prealloc, align 4
  %cmp = icmp ne i32 %7, 0
  br i1 %cmp, label %if.then6, label %if.end8

if.then6:                                         ; preds = %if.end5
  %8 = load ptr, ptr %errp.addr, align 8
  %9 = load i32, ptr %prealloc, align 4
  %call7 = call ptr @qapi_enum_lookup(ptr noundef @PreallocMode_lookup, i32 noundef %9)
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %8, ptr noundef @.str.2, i32 noundef 658, ptr noundef @__func__.bdrv_co_create_opts_simple, ptr noundef @.str.19, ptr noundef %call7)
  store i32 -95, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end5
  %call9 = call ptr @qdict_new()
  store ptr %call9, ptr %options, align 8
  %10 = load ptr, ptr %options, align 8
  %11 = load ptr, ptr %drv.addr, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %format_name, align 8
  call void @qdict_put_str(ptr noundef %10, ptr noundef @.str.20, ptr noundef %12)
  %13 = load ptr, ptr %filename.addr, align 8
  %14 = load ptr, ptr %options, align 8
  %15 = load ptr, ptr %errp.addr, align 8
  %call10 = call ptr @blk_co_new_open(ptr noundef %13, ptr noundef null, ptr noundef %14, i32 noundef 6, ptr noundef %15)
  store ptr %call10, ptr %blk, align 8
  %16 = load ptr, ptr %blk, align 8
  %tobool11 = icmp ne ptr %16, null
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %if.end8
  %17 = load ptr, ptr %errp.addr, align 8
  %18 = load ptr, ptr %drv.addr, align 8
  %format_name13 = getelementptr inbounds %struct.BlockDriver, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %format_name13, align 8
  call void (ptr, ptr, ...) @error_prepend(ptr noundef %17, ptr noundef @.str.21, ptr noundef %19)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end8
  %20 = load ptr, ptr %blk, align 8
  %21 = load i64, ptr %size, align 8
  %22 = load ptr, ptr %errp.addr, align 8
  %call15 = call i64 @create_file_fallback_truncate(ptr noundef %20, i64 noundef %21, ptr noundef %22)
  store i64 %call15, ptr %size, align 8
  %23 = load i64, ptr %size, align 8
  %cmp16 = icmp slt i64 %23, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  %24 = load i64, ptr %size, align 8
  %conv = trunc i64 %24 to i32
  store i32 %conv, ptr %ret, align 4
  br label %out

if.end18:                                         ; preds = %if.end14
  %25 = load ptr, ptr %blk, align 8
  %26 = load i64, ptr %size, align 8
  %27 = load ptr, ptr %errp.addr, align 8
  %call19 = call i32 @create_file_fallback_zero_first_sector(ptr noundef %25, i64 noundef %26, ptr noundef %27)
  store i32 %call19, ptr %ret, align 4
  %28 = load i32, ptr %ret, align 4
  %cmp20 = icmp slt i32 %28, 0
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end18
  br label %out

if.end23:                                         ; preds = %if.end18
  store i32 0, ptr %ret, align 4
  br label %out

out:                                              ; preds = %if.end23, %if.then22, %if.then17
  %29 = load ptr, ptr %blk, align 8
  call void @blk_co_unref(ptr noundef %29)
  %30 = load i32, ptr %ret, align 4
  store i32 %30, ptr %retval, align 4
  br label %return

return:                                           ; preds = %out, %if.then12, %if.then6, %if.then4
  %31 = load i32, ptr %retval, align 4
  ret i32 %31
}

declare i64 @qemu_opt_get_size_del(ptr noundef, ptr noundef, i64 noundef) #2

declare ptr @qemu_opt_get_del(ptr noundef, ptr noundef) #2

declare i32 @qapi_enum_parse(ptr noundef, ptr noundef, i32 noundef, ptr noundef) #2

declare void @g_free(ptr noundef) #2

declare void @error_propagate(ptr noundef, ptr noundef) #2

declare ptr @qapi_enum_lookup(ptr noundef, i32 noundef) #2

declare ptr @qdict_new() #2

declare ptr @blk_co_new_open(ptr noundef, ptr noundef, ptr noundef, i32 noundef, ptr noundef) #2

declare void @error_prepend(ptr noundef, ptr noundef, ...) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @create_file_fallback_truncate(ptr noundef %blk, i64 noundef %minimum_size, ptr noundef %errp) #0 {
entry:
  %retval = alloca i64, align 8
  %blk.addr = alloca ptr, align 8
  %minimum_size.addr = alloca i64, align 8
  %errp.addr = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %size = alloca i64, align 8
  %ret = alloca i32, align 4
  store ptr %blk, ptr %blk.addr, align 8
  store i64 %minimum_size, ptr %minimum_size.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 570, ptr noundef @__PRETTY_FUNCTION__.create_file_fallback_truncate) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %blk.addr, align 8
  %1 = load i64, ptr %minimum_size.addr, align 8
  %call1 = call i32 @blk_co_truncate(ptr noundef %0, i64 noundef %1, i1 noundef zeroext false, i32 noundef 0, i32 noundef 0, ptr noundef %local_err)
  store i32 %call1, ptr %ret, align 4
  %2 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %do.end
  %3 = load i32, ptr %ret, align 4
  %cmp2 = icmp ne i32 %3, -95
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %land.lhs.true
  %4 = load ptr, ptr %errp.addr, align 8
  %5 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %4, ptr noundef %5)
  %6 = load i32, ptr %ret, align 4
  %conv = sext i32 %6 to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

if.end4:                                          ; preds = %land.lhs.true, %do.end
  %7 = load ptr, ptr %blk.addr, align 8
  %call5 = call i64 @blk_co_getlength(ptr noundef %7)
  store i64 %call5, ptr %size, align 8
  %8 = load i64, ptr %size, align 8
  %cmp6 = icmp slt i64 %8, 0
  br i1 %cmp6, label %if.then8, label %if.end10

if.then8:                                         ; preds = %if.end4
  %9 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %9)
  %10 = load ptr, ptr %errp.addr, align 8
  %11 = load i64, ptr %size, align 8
  %sub = sub i64 0, %11
  %conv9 = trunc i64 %sub to i32
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %10, ptr noundef @.str.2, i32 noundef 583, ptr noundef @__func__.create_file_fallback_truncate, i32 noundef %conv9, ptr noundef @.str.158)
  %12 = load i64, ptr %size, align 8
  store i64 %12, ptr %retval, align 8
  br label %return

if.end10:                                         ; preds = %if.end4
  %13 = load i64, ptr %size, align 8
  %14 = load i64, ptr %minimum_size.addr, align 8
  %cmp11 = icmp slt i64 %13, %14
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %15 = load ptr, ptr %errp.addr, align 8
  %16 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %15, ptr noundef %16)
  store i64 -95, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end10
  %17 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %17)
  store ptr null, ptr %local_err, align 8
  %18 = load i64, ptr %size, align 8
  store i64 %18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %if.then13, %if.then8, %if.then3
  %19 = load i64, ptr %retval, align 8
  ret i64 %19
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @create_file_fallback_zero_first_sector(ptr noundef %blk, i64 noundef %current_size, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %blk.addr = alloca ptr, align 8
  %current_size.addr = alloca i64, align 8
  %errp.addr = alloca ptr, align 8
  %bytes_to_clear = alloca i64, align 8
  %ret = alloca i32, align 4
  %_a10 = alloca i64, align 8
  %_b11 = alloca i64, align 8
  %tmp = alloca i64, align 8
  store ptr %blk, ptr %blk.addr, align 8
  store i64 %current_size, ptr %current_size.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 611, ptr noundef @__PRETTY_FUNCTION__.create_file_fallback_zero_first_sector) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load i64, ptr %current_size.addr, align 8
  store i64 %0, ptr %_a10, align 8
  store i64 512, ptr %_b11, align 8
  %1 = load i64, ptr %_a10, align 8
  %2 = load i64, ptr %_b11, align 8
  %cmp = icmp ult i64 %1, %2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  %3 = load i64, ptr %_a10, align 8
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %4 = load i64, ptr %_b11, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %3, %cond.true ], [ %4, %cond.false ]
  store i64 %cond, ptr %tmp, align 8
  %5 = load i64, ptr %tmp, align 8
  store i64 %5, ptr %bytes_to_clear, align 8
  %6 = load i64, ptr %bytes_to_clear, align 8
  %tobool = icmp ne i64 %6, 0
  br i1 %tobool, label %if.then1, label %if.end6

if.then1:                                         ; preds = %cond.end
  %7 = load ptr, ptr %blk.addr, align 8
  %8 = load i64, ptr %bytes_to_clear, align 8
  %call2 = call i32 @blk_co_pwrite_zeroes(ptr noundef %7, i64 noundef 0, i64 noundef %8, i32 noundef 4)
  store i32 %call2, ptr %ret, align 4
  %9 = load i32, ptr %ret, align 4
  %cmp3 = icmp slt i32 %9, 0
  br i1 %cmp3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then1
  %10 = load ptr, ptr %errp.addr, align 8
  %11 = load i32, ptr %ret, align 4
  %sub = sub i32 0, %11
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %10, ptr noundef @.str.2, i32 noundef 618, ptr noundef @__func__.create_file_fallback_zero_first_sector, i32 noundef %sub, ptr noundef @.str.159)
  %12 = load i32, ptr %ret, align 4
  store i32 %12, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.then1
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %cond.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end6, %if.then4
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

declare void @blk_co_unref(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_create_file(ptr noundef %filename, ptr noundef %opts, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %filename.addr = alloca ptr, align 8
  %opts.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %protocol_opts = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %qdict = alloca ptr, align 8
  %ret = alloca i32, align 4
  %_obj12 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp14 = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %opts, ptr %opts.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 701, ptr noundef @__PRETTY_FUNCTION__.bdrv_co_create_file) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %filename.addr, align 8
  %1 = load ptr, ptr %errp.addr, align 8
  %call1 = call ptr @bdrv_find_protocol(ptr noundef %0, i1 noundef zeroext true, ptr noundef %1)
  store ptr %call1, ptr %drv, align 8
  %2 = load ptr, ptr %drv, align 8
  %cmp = icmp eq ptr %2, null
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  store i32 -2, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %do.end
  %3 = load ptr, ptr %drv, align 8
  %create_opts = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 9
  %4 = load ptr, ptr %create_opts, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end3
  %5 = load ptr, ptr %errp.addr, align 8
  %6 = load ptr, ptr %drv, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %format_name, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %5, ptr noundef @.str.2, i32 noundef 710, ptr noundef @__func__.bdrv_co_create_file, ptr noundef @.str.15, ptr noundef %7)
  store i32 -95, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end3
  %8 = load ptr, ptr %opts.addr, align 8
  %call6 = call ptr @qemu_opts_to_qdict(ptr noundef %8, ptr noundef null)
  store ptr %call6, ptr %qdict, align 8
  %9 = load ptr, ptr %drv, align 8
  %create_opts7 = getelementptr inbounds %struct.BlockDriver, ptr %9, i32 0, i32 9
  %10 = load ptr, ptr %create_opts7, align 8
  %11 = load ptr, ptr %qdict, align 8
  %12 = load ptr, ptr %errp.addr, align 8
  %call8 = call ptr @qemu_opts_from_qdict(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store ptr %call8, ptr %protocol_opts, align 8
  %13 = load ptr, ptr %protocol_opts, align 8
  %cmp9 = icmp eq ptr %13, null
  br i1 %cmp9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end5
  store i32 -22, ptr %ret, align 4
  br label %out

if.end11:                                         ; preds = %if.end5
  %14 = load ptr, ptr %drv, align 8
  %15 = load ptr, ptr %filename.addr, align 8
  %16 = load ptr, ptr %protocol_opts, align 8
  %17 = load ptr, ptr %errp.addr, align 8
  %call12 = call i32 @bdrv_co_create(ptr noundef %14, ptr noundef %15, ptr noundef %16, ptr noundef %17)
  store i32 %call12, ptr %ret, align 4
  br label %out

out:                                              ; preds = %if.end11, %if.then10
  %18 = load ptr, ptr %protocol_opts, align 8
  call void @qemu_opts_del(ptr noundef %18)
  %19 = load ptr, ptr %qdict, align 8
  store ptr %19, ptr %_obj12, align 8
  %20 = load ptr, ptr %_obj12, align 8
  %tobool13 = icmp ne ptr %20, null
  br i1 %tobool13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %out
  %21 = load ptr, ptr %_obj12, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %21, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %22 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %22, i64 0
  store ptr %add.ptr, ptr %tmp14, align 8
  %23 = load ptr, ptr %tmp14, align 8
  br label %cond.end

cond.false:                                       ; preds = %out
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %23, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %24 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %24)
  %25 = load i32, ptr %ret, align 4
  store i32 %25, ptr %retval, align 4
  br label %return

return:                                           ; preds = %cond.end, %if.then4, %if.then2
  %26 = load i32, ptr %retval, align 4
  ret i32 %26
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_protocol(ptr noundef %filename, i1 noundef zeroext %allow_protocol_prefix, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %allow_protocol_prefix.addr = alloca i8, align 1
  %errp.addr = alloca ptr, align 8
  %drv1 = alloca ptr, align 8
  %protocol = alloca [128 x i8], align 16
  %len = alloca i32, align 4
  %p = alloca ptr, align 8
  %i = alloca i32, align 4
  %rv = alloca i32, align 4
  store ptr %filename, ptr %filename.addr, align 8
  %frombool = zext i1 %allow_protocol_prefix to i8
  store i8 %frombool, ptr %allow_protocol_prefix.addr, align 1
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 927, ptr noundef @__PRETTY_FUNCTION__.bdrv_find_protocol) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %filename.addr, align 8
  %call1 = call ptr @find_hdev_driver(ptr noundef %0)
  store ptr %call1, ptr %drv1, align 8
  %1 = load ptr, ptr %drv1, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  %2 = load ptr, ptr %drv1, align 8
  store ptr %2, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %do.end
  %3 = load ptr, ptr %filename.addr, align 8
  %call4 = call i32 @path_has_protocol(ptr noundef %3)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %lor.lhs.false, label %if.then7

lor.lhs.false:                                    ; preds = %if.end3
  %4 = load i8, ptr %allow_protocol_prefix.addr, align 1
  %tobool6 = trunc i8 %4 to i1
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %lor.lhs.false, %if.end3
  store ptr @bdrv_file, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %lor.lhs.false
  %5 = load ptr, ptr %filename.addr, align 8
  %call9 = call ptr @strchr(ptr noundef %5, i32 noundef 58) #13
  store ptr %call9, ptr %p, align 8
  %6 = load ptr, ptr %p, align 8
  %cmp = icmp ne ptr %6, null
  br i1 %cmp, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.end8
  br label %if.end12

if.else11:                                        ; preds = %if.end8
  call void @__assert_fail(ptr noundef @.str.29, ptr noundef @.str.2, i32 noundef 947, ptr noundef @__PRETTY_FUNCTION__.bdrv_find_protocol) #16
  unreachable

if.end12:                                         ; preds = %if.then10
  %7 = load ptr, ptr %p, align 8
  %8 = load ptr, ptr %filename.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint ptr %7 to i64
  %sub.ptr.rhs.cast = ptrtoint ptr %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  store i32 %conv, ptr %len, align 4
  %9 = load i32, ptr %len, align 4
  %conv13 = sext i32 %9 to i64
  %cmp14 = icmp ugt i64 %conv13, 127
  br i1 %cmp14, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end12
  store i32 127, ptr %len, align 4
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %if.end12
  %arraydecay = getelementptr inbounds [128 x i8], ptr %protocol, i64 0, i64 0
  %10 = load ptr, ptr %filename.addr, align 8
  %11 = load i32, ptr %len, align 4
  %conv18 = sext i32 %11 to i64
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %arraydecay, ptr align 1 %10, i64 %conv18, i1 false)
  %12 = load i32, ptr %len, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr [128 x i8], ptr %protocol, i64 0, i64 %idxprom
  store i8 0, ptr %arrayidx, align 1
  %arraydecay19 = getelementptr inbounds [128 x i8], ptr %protocol, i64 0, i64 0
  %call20 = call ptr @bdrv_do_find_protocol(ptr noundef %arraydecay19)
  store ptr %call20, ptr %drv1, align 8
  %13 = load ptr, ptr %drv1, align 8
  %tobool21 = icmp ne ptr %13, null
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end17
  %14 = load ptr, ptr %drv1, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

if.end23:                                         ; preds = %if.end17
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end23
  %15 = load i32, ptr %i, align 4
  %cmp24 = icmp slt i32 %15, 0
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load i32, ptr %i, align 4
  %idxprom26 = sext i32 %16 to i64
  %arrayidx27 = getelementptr [0 x %struct.anon.12], ptr @block_driver_modules, i64 0, i64 %idxprom26
  %protocol_name = getelementptr inbounds %struct.anon.12, ptr %arrayidx27, i32 0, i32 1
  %17 = load ptr, ptr %protocol_name, align 8
  %tobool28 = icmp ne ptr %17, null
  br i1 %tobool28, label %land.lhs.true, label %if.end50

land.lhs.true:                                    ; preds = %for.body
  %18 = load i32, ptr %i, align 4
  %idxprom29 = sext i32 %18 to i64
  %arrayidx30 = getelementptr [0 x %struct.anon.12], ptr @block_driver_modules, i64 0, i64 %idxprom29
  %protocol_name31 = getelementptr inbounds %struct.anon.12, ptr %arrayidx30, i32 0, i32 1
  %19 = load ptr, ptr %protocol_name31, align 8
  %arraydecay32 = getelementptr inbounds [128 x i8], ptr %protocol, i64 0, i64 0
  %call33 = call i32 @strcmp(ptr noundef %19, ptr noundef %arraydecay32) #13
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.end50, label %if.then35

if.then35:                                        ; preds = %land.lhs.true
  %20 = load i32, ptr %i, align 4
  %idxprom36 = sext i32 %20 to i64
  %arrayidx37 = getelementptr [0 x %struct.anon.12], ptr @block_driver_modules, i64 0, i64 %idxprom36
  %library_name = getelementptr inbounds %struct.anon.12, ptr %arrayidx37, i32 0, i32 2
  %21 = load ptr, ptr %library_name, align 8
  %22 = load ptr, ptr %errp.addr, align 8
  %call38 = call i32 @module_load(ptr noundef @.str.12, ptr noundef %21, ptr noundef %22)
  store i32 %call38, ptr %rv, align 4
  %23 = load i32, ptr %rv, align 4
  %cmp39 = icmp sgt i32 %23, 0
  br i1 %cmp39, label %if.then41, label %if.else44

if.then41:                                        ; preds = %if.then35
  %arraydecay42 = getelementptr inbounds [128 x i8], ptr %protocol, i64 0, i64 0
  %call43 = call ptr @bdrv_do_find_protocol(ptr noundef %arraydecay42)
  store ptr %call43, ptr %drv1, align 8
  br label %if.end49

if.else44:                                        ; preds = %if.then35
  %24 = load i32, ptr %rv, align 4
  %cmp45 = icmp slt i32 %24, 0
  br i1 %cmp45, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.else44
  store ptr null, ptr %retval, align 8
  br label %return

if.end48:                                         ; preds = %if.else44
  br label %if.end49

if.end49:                                         ; preds = %if.end48, %if.then41
  br label %for.end

if.end50:                                         ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end50
  %25 = load i32, ptr %i, align 4
  %inc = add i32 %25, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !12

for.end:                                          ; preds = %if.end49, %for.cond
  %26 = load ptr, ptr %drv1, align 8
  %tobool51 = icmp ne ptr %26, null
  br i1 %tobool51, label %if.end54, label %if.then52

if.then52:                                        ; preds = %for.end
  %27 = load ptr, ptr %errp.addr, align 8
  %arraydecay53 = getelementptr inbounds [128 x i8], ptr %protocol, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %27, ptr noundef @.str.2, i32 noundef 973, ptr noundef @__func__.bdrv_find_protocol, ptr noundef @.str.30, ptr noundef %arraydecay53)
  br label %if.end54

if.end54:                                         ; preds = %if.then52, %for.end
  %28 = load ptr, ptr %drv1, align 8
  store ptr %28, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end54, %if.then47, %if.then22, %if.then7, %if.then2
  %29 = load ptr, ptr %retval, align 8
  ret ptr %29
}

declare ptr @qemu_opts_to_qdict(ptr noundef, ptr noundef) #2

declare ptr @qemu_opts_from_qdict(ptr noundef, ptr noundef, ptr noundef) #2

declare void @qemu_opts_del(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @qobject_unref_impl(ptr noundef %obj) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load ptr, ptr %obj.addr, align 8
  %base = getelementptr inbounds %struct.QObject, ptr %1, i32 0, i32 0
  %refcnt = getelementptr inbounds %struct.QObjectBase_, ptr %base, i32 0, i32 1
  %2 = load i64, ptr %refcnt, align 8
  %tobool1 = icmp ne i64 %2, 0
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  call void @__assert_fail(ptr noundef @.str.160, ptr noundef @.str.161, i32 noundef 97, ptr noundef @__PRETTY_FUNCTION__.qobject_unref_impl) #16
  unreachable

if.end:                                           ; preds = %if.then
  %3 = load ptr, ptr %obj.addr, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %obj.addr, align 8
  %base3 = getelementptr inbounds %struct.QObject, ptr %4, i32 0, i32 0
  %refcnt4 = getelementptr inbounds %struct.QObjectBase_, ptr %base3, i32 0, i32 1
  %5 = load i64, ptr %refcnt4, align 8
  %dec = add i64 %5, -1
  store i64 %dec, ptr %refcnt4, align 8
  %cmp = icmp eq i64 %dec, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %land.lhs.true
  %6 = load ptr, ptr %obj.addr, align 8
  call void @qobject_destroy(ptr noundef %6)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %land.lhs.true, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_delete_file(ptr noundef %bs, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %do.end
  br label %if.end

if.else:                                          ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.22, ptr noundef @.str.2, i32 noundef 748, ptr noundef @__PRETTY_FUNCTION__.bdrv_co_delete_file) #16
  unreachable

if.end:                                           ; preds = %if.then
  call void @assert_bdrv_graph_readable()
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  %3 = load ptr, ptr %errp.addr, align 8
  %4 = load ptr, ptr %bs.addr, align 8
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 11
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %filename, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %3, ptr noundef @.str.2, i32 noundef 752, ptr noundef @__func__.bdrv_co_delete_file, ptr noundef @.str.23, ptr noundef %arraydecay)
  store i32 -123, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %if.end
  %5 = load ptr, ptr %bs.addr, align 8
  %drv3 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %drv3, align 8
  %bdrv_co_delete_file = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 84
  %7 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_delete_file, ptr @.str.13, ptr @.str.14, i32 679, ptr null)
  %8 = load ptr, ptr %7, align 8
  %tobool4 = icmp ne ptr %8, null
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end2
  %9 = load ptr, ptr %errp.addr, align 8
  %10 = load ptr, ptr %bs.addr, align 8
  %drv6 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 6
  %11 = load ptr, ptr %drv6, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %format_name, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %9, ptr noundef @.str.2, i32 noundef 758, ptr noundef @__func__.bdrv_co_delete_file, ptr noundef @.str.24, ptr noundef %12)
  store i32 -95, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end2
  %13 = load ptr, ptr %bs.addr, align 8
  %drv8 = getelementptr inbounds %struct.BlockDriverState, ptr %13, i32 0, i32 6
  %14 = load ptr, ptr %drv8, align 8
  %bdrv_co_delete_file9 = getelementptr inbounds %struct.BlockDriver, ptr %14, i32 0, i32 84
  %15 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_delete_file9, ptr @.str.13, ptr @.str.14, i32 679, ptr null)
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %bs.addr, align 8
  %call = call i32 %16(ptr noundef %17, ptr noundef %local_err)
  store i32 %call, ptr %ret, align 4
  %18 = load i32, ptr %ret, align 4
  %cmp10 = icmp slt i32 %18, 0
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end7
  %19 = load ptr, ptr %errp.addr, align 8
  %20 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %19, ptr noundef %20)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end7
  %21 = load i32, ptr %ret, align 4
  store i32 %21, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then5, %if.then1
  %22 = load i32, ptr %retval, align 4
  ret i32 %22
}

declare void @assert_bdrv_graph_readable() #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_delete_file_noerr(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  br label %if.end5

if.end:                                           ; preds = %do.end
  %1 = load ptr, ptr %bs.addr, align 8
  %call = call i32 @bdrv_co_delete_file(ptr noundef %1, ptr noundef %local_err)
  store i32 %call, ptr %ret, align 4
  %2 = load i32, ptr %ret, align 4
  %cmp = icmp eq i32 %2, -95
  br i1 %cmp, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.end
  %3 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %3)
  br label %if.end5

if.else:                                          ; preds = %if.end
  %4 = load i32, ptr %ret, align 4
  %cmp2 = icmp slt i32 %4, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.else
  %5 = load ptr, ptr %local_err, align 8
  call void @error_report_err(ptr noundef %5)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.else
  br label %if.end5

if.end5:                                          ; preds = %if.end4, %if.then1, %if.then
  ret void
}

declare void @error_free(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_probe_blocksizes(ptr noundef %bs, ptr noundef %bsz) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %bsz.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %filtered = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %bsz, ptr %bsz.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  %2 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_filter_bs(ptr noundef %2)
  store ptr %call, ptr %filtered, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call2 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 803, ptr noundef @__PRETTY_FUNCTION__.bdrv_probe_blocksizes) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %3 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %land.lhs.true, label %if.else7

land.lhs.true:                                    ; preds = %do.end
  %4 = load ptr, ptr %drv, align 8
  %bdrv_probe_blocksizes = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 51
  %5 = load ptr, ptr %bdrv_probe_blocksizes, align 8
  %tobool3 = icmp ne ptr %5, null
  br i1 %tobool3, label %if.then4, label %if.else7

if.then4:                                         ; preds = %land.lhs.true
  %6 = load ptr, ptr %drv, align 8
  %bdrv_probe_blocksizes5 = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 51
  %7 = load ptr, ptr %bdrv_probe_blocksizes5, align 8
  %8 = load ptr, ptr %bs.addr, align 8
  %9 = load ptr, ptr %bsz.addr, align 8
  %call6 = call i32 %7(ptr noundef %8, ptr noundef %9)
  store i32 %call6, ptr %retval, align 4
  br label %return

if.else7:                                         ; preds = %land.lhs.true, %do.end
  %10 = load ptr, ptr %filtered, align 8
  %tobool8 = icmp ne ptr %10, null
  br i1 %tobool8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.else7
  %11 = load ptr, ptr %filtered, align 8
  %12 = load ptr, ptr %bsz.addr, align 8
  %call10 = call i32 @bdrv_probe_blocksizes(ptr noundef %11, ptr noundef %12)
  store i32 %call10, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %if.else7
  br label %if.end12

if.end12:                                         ; preds = %if.end11
  store i32 -95, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end12, %if.then9, %if.then4
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_filter_bs(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_filter_child(ptr noundef %0)
  %call1 = call ptr @child_bs(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_probe_geometry(ptr noundef %bs, ptr noundef %geo) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %geo.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %filtered = alloca ptr, align 8
  %graph_lockable_auto13 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %geo, ptr %geo.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 825, ptr noundef @__PRETTY_FUNCTION__.bdrv_probe_geometry) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call2 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call2, ptr %graph_lockable_auto13, align 8
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %do.end
  %3 = load ptr, ptr %drv, align 8
  %bdrv_probe_geometry = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 52
  %4 = load ptr, ptr %bdrv_probe_geometry, align 8
  %tobool3 = icmp ne ptr %4, null
  br i1 %tobool3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %land.lhs.true
  %5 = load ptr, ptr %drv, align 8
  %bdrv_probe_geometry5 = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 52
  %6 = load ptr, ptr %bdrv_probe_geometry5, align 8
  %7 = load ptr, ptr %bs.addr, align 8
  %8 = load ptr, ptr %geo.addr, align 8
  %call6 = call i32 %6(ptr noundef %7, ptr noundef %8)
  store i32 %call6, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end7:                                          ; preds = %land.lhs.true, %do.end
  %9 = load ptr, ptr %bs.addr, align 8
  %call8 = call ptr @bdrv_filter_bs(ptr noundef %9)
  store ptr %call8, ptr %filtered, align 8
  %10 = load ptr, ptr %filtered, align 8
  %tobool9 = icmp ne ptr %10, null
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end7
  %11 = load ptr, ptr %filtered, align 8
  %12 = load ptr, ptr %geo.addr, align 8
  %call11 = call i32 @bdrv_probe_geometry(ptr noundef %11, ptr noundef %12)
  store i32 %call11, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end12:                                         ; preds = %if.end7
  store i32 -95, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.then10, %if.then4
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto13)
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @graph_lockable_auto_lock_mainloop(ptr noundef %x) #0 {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  call void @bdrv_graph_rdlock_main_loop()
  %0 = load ptr, ptr %x.addr, align 8
  ret ptr %0
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %1 = load ptr, ptr %0, align 8
  call void @glib_autoptr_clear_GraphLockableMainloop(ptr noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @create_tmp_file(ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %fd = alloca i32, align 4
  %tmpdir = alloca ptr, align 8
  %filename = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %filename, align 8
  %call = call ptr @g_get_tmp_dir()
  store ptr %call, ptr %tmpdir, align 8
  %0 = load ptr, ptr %tmpdir, align 8
  %call1 = call i32 @g_strcmp0(ptr noundef %0, ptr noundef @.str.25)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr @.str.26, ptr %tmpdir, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load ptr, ptr %tmpdir, align 8
  %call2 = call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef @.str.27, ptr noundef %1)
  store ptr %call2, ptr %filename, align 8
  %2 = load ptr, ptr %filename, align 8
  %call3 = call i32 @g_mkstemp(ptr noundef %2)
  store i32 %call3, ptr %fd, align 4
  %3 = load i32, ptr %fd, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %4 = load ptr, ptr %errp.addr, align 8
  %call5 = call ptr @__errno_location() #12
  %5 = load i32, ptr %call5, align 4
  %6 = load ptr, ptr %filename, align 8
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %4, ptr noundef @.str.2, i32 noundef 872, ptr noundef @__func__.create_tmp_file, i32 noundef %5, ptr noundef @.str.28, ptr noundef %6)
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end6:                                          ; preds = %if.end
  %7 = load i32, ptr %fd, align 4
  %call7 = call i32 @close(i32 noundef %7)
  %call8 = call ptr @g_steal_pointer(ptr noundef %filename)
  store ptr %call8, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end6, %if.then4
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %filename)
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @g_autoptr_cleanup_generic_gfree(ptr noundef %p) #0 {
entry:
  %p.addr = alloca ptr, align 8
  %pp = alloca ptr, align 8
  store ptr %p, ptr %p.addr, align 8
  %0 = load ptr, ptr %p.addr, align 8
  store ptr %0, ptr %pp, align 8
  %1 = load ptr, ptr %pp, align 8
  %2 = load ptr, ptr %1, align 8
  call void @g_free(ptr noundef %2)
  ret void
}

declare ptr @g_get_tmp_dir() #2

declare i32 @g_strcmp0(ptr noundef, ptr noundef) #2

declare noalias ptr @g_strdup_printf(ptr noundef, ...) #2

declare i32 @g_mkstemp(ptr noundef) #2

; Function Attrs: nounwind willreturn memory(none)
declare ptr @__errno_location() #9

declare i32 @close(i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @g_steal_pointer(ptr noundef %pp) #0 {
entry:
  %pp.addr = alloca ptr, align 8
  %ptr = alloca ptr, align 8
  %ref = alloca ptr, align 8
  store ptr %pp, ptr %pp.addr, align 8
  %0 = load ptr, ptr %pp.addr, align 8
  store ptr %0, ptr %ptr, align 8
  %1 = load ptr, ptr %ptr, align 8
  %2 = load ptr, ptr %1, align 8
  store ptr %2, ptr %ref, align 8
  %3 = load ptr, ptr %ptr, align 8
  store ptr null, ptr %3, align 8
  %4 = load ptr, ptr %ref, align 8
  ret ptr %4
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @find_hdev_driver(ptr noundef %filename) #0 {
entry:
  %filename.addr = alloca ptr, align 8
  %score_max = alloca i32, align 4
  %score = alloca i32, align 4
  %drv = alloca ptr, align 8
  %d = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store i32 0, ptr %score_max, align 4
  store ptr null, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 888, ptr noundef @__PRETTY_FUNCTION__.find_hdev_driver) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr @bdrv_drivers, align 8
  store ptr %0, ptr %d, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %1 = load ptr, ptr %d, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %d, align 8
  %bdrv_probe_device = getelementptr inbounds %struct.BlockDriver, ptr %2, i32 0, i32 16
  %3 = load ptr, ptr %bdrv_probe_device, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then2, label %if.end7

if.then2:                                         ; preds = %for.body
  %4 = load ptr, ptr %d, align 8
  %bdrv_probe_device3 = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 16
  %5 = load ptr, ptr %bdrv_probe_device3, align 8
  %6 = load ptr, ptr %filename.addr, align 8
  %call4 = call i32 %5(ptr noundef %6)
  store i32 %call4, ptr %score, align 4
  %7 = load i32, ptr %score, align 4
  %8 = load i32, ptr %score_max, align 4
  %cmp = icmp sgt i32 %7, %8
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.then2
  %9 = load i32, ptr %score, align 4
  store i32 %9, ptr %score_max, align 4
  %10 = load ptr, ptr %d, align 8
  store ptr %10, ptr %drv, align 8
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.then2
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %11 = load ptr, ptr %d, align 8
  %list = getelementptr inbounds %struct.BlockDriver, ptr %11, i32 0, i32 61
  %le_next = getelementptr inbounds %struct.anon.9, ptr %list, i32 0, i32 0
  %12 = load ptr, ptr %le_next, align 8
  store ptr %12, ptr %d, align 8
  br label %for.cond, !llvm.loop !13

for.end:                                          ; preds = %for.cond
  %13 = load ptr, ptr %drv, align 8
  ret ptr %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_do_find_protocol(ptr noundef %protocol) #0 {
entry:
  %retval = alloca ptr, align 8
  %protocol.addr = alloca ptr, align 8
  %drv1 = alloca ptr, align 8
  store ptr %protocol, ptr %protocol.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 906, ptr noundef @__PRETTY_FUNCTION__.bdrv_do_find_protocol) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr @bdrv_drivers, align 8
  store ptr %0, ptr %drv1, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %1 = load ptr, ptr %drv1, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %drv1, align 8
  %protocol_name = getelementptr inbounds %struct.BlockDriver, ptr %2, i32 0, i32 8
  %3 = load ptr, ptr %protocol_name, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %for.body
  %4 = load ptr, ptr %drv1, align 8
  %protocol_name2 = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 8
  %5 = load ptr, ptr %protocol_name2, align 8
  %6 = load ptr, ptr %protocol.addr, align 8
  %call3 = call i32 @strcmp(ptr noundef %5, ptr noundef %6) #13
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %land.lhs.true
  %7 = load ptr, ptr %drv1, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

if.end6:                                          ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %8 = load ptr, ptr %drv1, align 8
  %list = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 61
  %le_next = getelementptr inbounds %struct.anon.9, ptr %list, i32 0, i32 0
  %9 = load ptr, ptr %le_next, align 8
  store ptr %9, ptr %drv1, align 8
  br label %for.cond, !llvm.loop !14

for.end:                                          ; preds = %for.cond
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then5
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_probe_all(ptr noundef %buf, i32 noundef %buf_size, ptr noundef %filename) #0 {
entry:
  %buf.addr = alloca ptr, align 8
  %buf_size.addr = alloca i32, align 4
  %filename.addr = alloca ptr, align 8
  %score_max = alloca i32, align 4
  %score = alloca i32, align 4
  %drv = alloca ptr, align 8
  %d = alloca ptr, align 8
  store ptr %buf, ptr %buf.addr, align 8
  store i32 %buf_size, ptr %buf_size.addr, align 4
  store ptr %filename, ptr %filename.addr, align 8
  store i32 0, ptr %score_max, align 4
  store ptr null, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr @bdrv_drivers, align 8
  store ptr %0, ptr %d, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %1 = load ptr, ptr %d, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %d, align 8
  %bdrv_probe = getelementptr inbounds %struct.BlockDriver, ptr %2, i32 0, i32 62
  %3 = load ptr, ptr %bdrv_probe, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then, label %if.end4

if.then:                                          ; preds = %for.body
  %4 = load ptr, ptr %d, align 8
  %bdrv_probe2 = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 62
  %5 = load ptr, ptr %bdrv_probe2, align 8
  %6 = load ptr, ptr %buf.addr, align 8
  %7 = load i32, ptr %buf_size.addr, align 4
  %8 = load ptr, ptr %filename.addr, align 8
  %call = call i32 %5(ptr noundef %6, i32 noundef %7, ptr noundef %8)
  store i32 %call, ptr %score, align 4
  %9 = load i32, ptr %score, align 4
  %10 = load i32, ptr %score_max, align 4
  %cmp = icmp sgt i32 %9, %10
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %11 = load i32, ptr %score, align 4
  store i32 %11, ptr %score_max, align 4
  %12 = load ptr, ptr %d, align 8
  store ptr %12, ptr %drv, align 8
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  br label %if.end4

if.end4:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end4
  %13 = load ptr, ptr %d, align 8
  %list = getelementptr inbounds %struct.BlockDriver, ptr %13, i32 0, i32 61
  %le_next = getelementptr inbounds %struct.anon.9, ptr %list, i32 0, i32 0
  %14 = load ptr, ptr %le_next, align 8
  store ptr %14, ptr %d, align 8
  br label %for.cond, !llvm.loop !15

for.end:                                          ; preds = %for.cond
  %15 = load ptr, ptr %drv, align 8
  ret ptr %15
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_refresh_total_sectors(ptr noundef %bs, i64 noundef %hint) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %hint.addr = alloca i64, align 8
  %drv = alloca ptr, align 8
  %length = alloca i64, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store i64 %hint, ptr %hint.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  call void @assert_bdrv_graph_readable()
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  store i32 -123, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end
  %3 = load ptr, ptr %bs.addr, align 8
  %call = call zeroext i1 @bdrv_is_sg(ptr noundef %3)
  br i1 %call, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load ptr, ptr %drv, align 8
  %bdrv_co_getlength = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 88
  %5 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_getlength, ptr @.str.13, ptr @.str.14, i32 714, ptr null)
  %6 = load ptr, ptr %5, align 8
  %tobool4 = icmp ne ptr %6, null
  br i1 %tobool4, label %if.then5, label %if.end10

if.then5:                                         ; preds = %if.end3
  %7 = load ptr, ptr %drv, align 8
  %bdrv_co_getlength6 = getelementptr inbounds %struct.BlockDriver, ptr %7, i32 0, i32 88
  %8 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_getlength6, ptr @.str.13, ptr @.str.14, i32 714, ptr null)
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %bs.addr, align 8
  %call7 = call i64 %9(ptr noundef %10)
  store i64 %call7, ptr %length, align 8
  %11 = load i64, ptr %length, align 8
  %cmp = icmp slt i64 %11, 0
  br i1 %cmp, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.then5
  %12 = load i64, ptr %length, align 8
  %conv = trunc i64 %12 to i32
  store i32 %conv, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %if.then5
  %13 = load i64, ptr %length, align 8
  %add = add i64 %13, 512
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 512
  store i64 %div, ptr %hint.addr, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.end3
  %14 = load i64, ptr %hint.addr, align 8
  %15 = load ptr, ptr %bs.addr, align 8
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 37
  store i64 %14, ptr %total_sectors, align 8
  %16 = load ptr, ptr %bs.addr, align 8
  %total_sectors11 = getelementptr inbounds %struct.BlockDriverState, ptr %16, i32 0, i32 37
  %17 = load i64, ptr %total_sectors11, align 8
  %mul = mul i64 %17, 512
  %cmp12 = icmp ugt i64 %mul, 9223372035781033984
  br i1 %cmp12, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end10
  store i32 -27, ptr %retval, align 4
  br label %return

if.end15:                                         ; preds = %if.end10
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end15, %if.then14, %if.then8, %if.then2, %if.then
  %18 = load i32, ptr %retval, align 4
  ret i32 %18
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_is_sg(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %sg = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 2
  %1 = load i8, ptr %sg, align 1
  %tobool = trunc i8 %1 to i1
  ret i1 %tobool
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_parse_aio(ptr noundef %mode, ptr noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %mode.addr = alloca ptr, align 8
  %flags.addr = alloca ptr, align 8
  store ptr %mode, ptr %mode.addr, align 8
  store ptr %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %mode.addr, align 8
  %call = call i32 @strcmp(ptr noundef %0, ptr noundef @.str.31) #13
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end11

if.else:                                          ; preds = %entry
  %1 = load ptr, ptr %mode.addr, align 8
  %call1 = call i32 @strcmp(ptr noundef %1, ptr noundef @.str.32) #13
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.else4, label %if.then3

if.then3:                                         ; preds = %if.else
  %2 = load ptr, ptr %flags.addr, align 8
  %3 = load i32, ptr %2, align 4
  %or = or i32 %3, 128
  store i32 %or, ptr %2, align 4
  br label %if.end10

if.else4:                                         ; preds = %if.else
  %4 = load ptr, ptr %mode.addr, align 8
  %call5 = call i32 @strcmp(ptr noundef %4, ptr noundef @.str.33) #13
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.else9, label %if.then7

if.then7:                                         ; preds = %if.else4
  %5 = load ptr, ptr %flags.addr, align 8
  %6 = load i32, ptr %5, align 4
  %or8 = or i32 %6, 262144
  store i32 %or8, ptr %5, align 4
  br label %if.end

if.else9:                                         ; preds = %if.else4
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then7
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then3
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.then
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end11, %if.else9
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_parse_discard_flags(ptr noundef %mode, ptr noundef %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %mode.addr = alloca ptr, align 8
  %flags.addr = alloca ptr, align 8
  store ptr %mode, ptr %mode.addr, align 8
  store ptr %flags, ptr %flags.addr, align 8
  %0 = load ptr, ptr %flags.addr, align 8
  %1 = load i32, ptr %0, align 4
  %and = and i32 %1, -16385
  store i32 %and, ptr %0, align 4
  %2 = load ptr, ptr %mode.addr, align 8
  %call = call i32 @strcmp(ptr noundef %2, ptr noundef @.str.34) #13
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %mode.addr, align 8
  %call1 = call i32 @strcmp(ptr noundef %3, ptr noundef @.str.35) #13
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end10

if.else:                                          ; preds = %lor.lhs.false
  %4 = load ptr, ptr %mode.addr, align 8
  %call3 = call i32 @strcmp(ptr noundef %4, ptr noundef @.str.36) #13
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %lor.lhs.false5, label %if.then8

lor.lhs.false5:                                   ; preds = %if.else
  %5 = load ptr, ptr %mode.addr, align 8
  %call6 = call i32 @strcmp(ptr noundef %5, ptr noundef @.str.37) #13
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.else9, label %if.then8

if.then8:                                         ; preds = %lor.lhs.false5, %if.else
  %6 = load ptr, ptr %flags.addr, align 8
  %7 = load i32, ptr %6, align 4
  %or = or i32 %7, 16384
  store i32 %or, ptr %6, align 4
  br label %if.end

if.else9:                                         ; preds = %lor.lhs.false5
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then8
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end10, %if.else9
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_parse_cache_mode(ptr noundef %mode, ptr noundef %flags, ptr noundef %writethrough) #0 {
entry:
  %retval = alloca i32, align 4
  %mode.addr = alloca ptr, align 8
  %flags.addr = alloca ptr, align 8
  %writethrough.addr = alloca ptr, align 8
  store ptr %mode, ptr %mode.addr, align 8
  store ptr %flags, ptr %flags.addr, align 8
  store ptr %writethrough, ptr %writethrough.addr, align 8
  %0 = load ptr, ptr %flags.addr, align 8
  %1 = load i32, ptr %0, align 4
  %and = and i32 %1, -545
  store i32 %and, ptr %0, align 4
  %2 = load ptr, ptr %mode.addr, align 8
  %call = call i32 @strcmp(ptr noundef %2, ptr noundef @.str.34) #13
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %3 = load ptr, ptr %mode.addr, align 8
  %call1 = call i32 @strcmp(ptr noundef %3, ptr noundef @.str.38) #13
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load ptr, ptr %writethrough.addr, align 8
  store i8 0, ptr %4, align 1
  %5 = load ptr, ptr %flags.addr, align 8
  %6 = load i32, ptr %5, align 4
  %or = or i32 %6, 32
  store i32 %or, ptr %5, align 4
  br label %if.end24

if.else:                                          ; preds = %lor.lhs.false
  %7 = load ptr, ptr %mode.addr, align 8
  %call3 = call i32 @strcmp(ptr noundef %7, ptr noundef @.str.39) #13
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.else7, label %if.then5

if.then5:                                         ; preds = %if.else
  %8 = load ptr, ptr %writethrough.addr, align 8
  store i8 1, ptr %8, align 1
  %9 = load ptr, ptr %flags.addr, align 8
  %10 = load i32, ptr %9, align 4
  %or6 = or i32 %10, 32
  store i32 %or6, ptr %9, align 4
  br label %if.end23

if.else7:                                         ; preds = %if.else
  %11 = load ptr, ptr %mode.addr, align 8
  %call8 = call i32 @strcmp(ptr noundef %11, ptr noundef @.str.40) #13
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.else11, label %if.then10

if.then10:                                        ; preds = %if.else7
  %12 = load ptr, ptr %writethrough.addr, align 8
  store i8 0, ptr %12, align 1
  br label %if.end22

if.else11:                                        ; preds = %if.else7
  %13 = load ptr, ptr %mode.addr, align 8
  %call12 = call i32 @strcmp(ptr noundef %13, ptr noundef @.str.41) #13
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.else16, label %if.then14

if.then14:                                        ; preds = %if.else11
  %14 = load ptr, ptr %writethrough.addr, align 8
  store i8 0, ptr %14, align 1
  %15 = load ptr, ptr %flags.addr, align 8
  %16 = load i32, ptr %15, align 4
  %or15 = or i32 %16, 512
  store i32 %or15, ptr %15, align 4
  br label %if.end21

if.else16:                                        ; preds = %if.else11
  %17 = load ptr, ptr %mode.addr, align 8
  %call17 = call i32 @strcmp(ptr noundef %17, ptr noundef @.str.42) #13
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.else20, label %if.then19

if.then19:                                        ; preds = %if.else16
  %18 = load ptr, ptr %writethrough.addr, align 8
  store i8 1, ptr %18, align 1
  br label %if.end

if.else20:                                        ; preds = %if.else16
  store i32 -1, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %if.then19
  br label %if.end21

if.end21:                                         ; preds = %if.end, %if.then14
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.then10
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then5
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end24, %if.else20
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @child_of_bds_get_parent_aio_context(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %bs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %2 = load ptr, ptr %bs, align 8
  %call = call ptr @bdrv_get_aio_context(ptr noundef %2)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_aio_context(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  %1 = load ptr, ptr %bs.addr, align 8
  %aio_context = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 8
  %2 = load ptr, ptr %aio_context, align 8
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %call = call ptr @qemu_get_aio_context()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %2, %cond.true ], [ %call, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_inherited_options(i32 noundef %role, i1 noundef zeroext %parent_is_format, ptr noundef %child_flags, ptr noundef %child_options, i32 noundef %parent_flags, ptr noundef %parent_options) #0 {
entry:
  %role.addr = alloca i32, align 4
  %parent_is_format.addr = alloca i8, align 1
  %child_flags.addr = alloca ptr, align 8
  %child_options.addr = alloca ptr, align 8
  %parent_flags.addr = alloca i32, align 4
  %parent_options.addr = alloca ptr, align 8
  %flags = alloca i32, align 4
  store i32 %role, ptr %role.addr, align 4
  %frombool = zext i1 %parent_is_format to i8
  store i8 %frombool, ptr %parent_is_format.addr, align 1
  store ptr %child_flags, ptr %child_flags.addr, align 8
  store ptr %child_options, ptr %child_options.addr, align 8
  store i32 %parent_flags, ptr %parent_flags.addr, align 4
  store ptr %parent_options, ptr %parent_options.addr, align 8
  %0 = load i32, ptr %parent_flags.addr, align 4
  store i32 %0, ptr %flags, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1349, ptr noundef @__PRETTY_FUNCTION__.bdrv_inherited_options) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load i8, ptr %parent_is_format.addr, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end7, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.end
  %2 = load i32, ptr %role.addr, align 4
  %and = and i32 %2, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true2, label %if.end7

land.lhs.true2:                                   ; preds = %land.lhs.true
  %3 = load i32, ptr %role.addr, align 4
  %and3 = and i32 %3, 6
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %land.lhs.true2
  %4 = load i32, ptr %flags, align 4
  %and6 = and i32 %4, -32769
  store i32 %and6, ptr %flags, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %land.lhs.true2, %land.lhs.true, %do.end
  %5 = load i8, ptr %parent_is_format.addr, align 1
  %tobool8 = trunc i8 %5 to i1
  br i1 %tobool8, label %land.lhs.true9, label %lor.lhs.false

land.lhs.true9:                                   ; preds = %if.end7
  %6 = load i32, ptr %role.addr, align 4
  %and10 = and i32 %6, 8
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %lor.lhs.false, label %if.then14

lor.lhs.false:                                    ; preds = %land.lhs.true9, %if.end7
  %7 = load i32, ptr %role.addr, align 4
  %and12 = and i32 %7, 2
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %lor.lhs.false, %land.lhs.true9
  %8 = load i32, ptr %flags, align 4
  %or = or i32 %8, 32768
  store i32 %or, ptr %flags, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %lor.lhs.false
  %9 = load ptr, ptr %child_options.addr, align 8
  %10 = load ptr, ptr %parent_options.addr, align 8
  call void @qdict_copy_default(ptr noundef %9, ptr noundef %10, ptr noundef @.str.47)
  %11 = load ptr, ptr %child_options.addr, align 8
  %12 = load ptr, ptr %parent_options.addr, align 8
  call void @qdict_copy_default(ptr noundef %11, ptr noundef %12, ptr noundef @.str.49)
  %13 = load ptr, ptr %child_options.addr, align 8
  %14 = load ptr, ptr %parent_options.addr, align 8
  call void @qdict_copy_default(ptr noundef %13, ptr noundef %14, ptr noundef @.str.59)
  %15 = load i32, ptr %role.addr, align 4
  %and16 = and i32 %15, 8
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.end15
  %16 = load ptr, ptr %child_options.addr, align 8
  call void @qdict_set_default_str(ptr noundef %16, ptr noundef @.str.51, ptr noundef @.str.36)
  %17 = load ptr, ptr %child_options.addr, align 8
  call void @qdict_set_default_str(ptr noundef %17, ptr noundef @.str.53, ptr noundef @.str.34)
  br label %if.end20

if.else19:                                        ; preds = %if.end15
  %18 = load ptr, ptr %child_options.addr, align 8
  %19 = load ptr, ptr %parent_options.addr, align 8
  call void @qdict_copy_default(ptr noundef %18, ptr noundef %19, ptr noundef @.str.51)
  %20 = load ptr, ptr %child_options.addr, align 8
  %21 = load ptr, ptr %parent_options.addr, align 8
  call void @qdict_copy_default(ptr noundef %20, ptr noundef %21, ptr noundef @.str.53)
  br label %if.end20

if.end20:                                         ; preds = %if.else19, %if.then18
  %22 = load ptr, ptr %child_options.addr, align 8
  call void @qdict_set_default_str(ptr noundef %22, ptr noundef @.str.57, ptr noundef @.str.37)
  %23 = load i32, ptr %flags, align 4
  %and21 = and i32 %23, -1289
  store i32 %and21, ptr %flags, align 4
  %24 = load i32, ptr %role.addr, align 4
  %and22 = and i32 %24, 2
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end20
  %25 = load i32, ptr %flags, align 4
  %and25 = and i32 %25, -65537
  store i32 %and25, ptr %flags, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end20
  %26 = load i32, ptr %role.addr, align 4
  %and27 = and i32 %26, 8
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end26
  %27 = load i32, ptr %flags, align 4
  %and30 = and i32 %27, -17
  store i32 %and30, ptr %flags, align 4
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end26
  %28 = load i32, ptr %flags, align 4
  %29 = load ptr, ptr %child_flags.addr, align 8
  store i32 %28, ptr %29, align 4
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_child_get_parent_desc(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %parent = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %parent, align 8
  %2 = load ptr, ptr %parent, align 8
  %call = call ptr @bdrv_get_node_name(ptr noundef %2)
  %call1 = call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef @.str.162, ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_child_cb_inactivate(ptr noundef %child) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %bs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1223, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_inactivate) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %bs, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 0
  %3 = load i32, ptr %open_flags, align 8
  %and = and i32 %3, 2048
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.end
  br label %if.end3

if.else2:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.163, ptr noundef @.str.2, i32 noundef 1224, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_inactivate) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  ret i32 0
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_cb_attach(ptr noundef %child) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %bs, align 8
  call void @assert_bdrv_graph_writable()
  br label %do.body

do.body:                                          ; preds = %entry
  %2 = load ptr, ptr %bs, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %3 = load ptr, ptr %lh_first, align 8
  %4 = load ptr, ptr %child.addr, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  store ptr %3, ptr %le_next, align 8
  %cmp = icmp ne ptr %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %5 = load ptr, ptr %child.addr, align 8
  %next1 = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 9
  %le_next2 = getelementptr inbounds %struct.anon.14, ptr %next1, i32 0, i32 0
  %6 = load ptr, ptr %bs, align 8
  %children3 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 29
  %lh_first4 = getelementptr inbounds %struct.anon.3, ptr %children3, i32 0, i32 0
  %7 = load ptr, ptr %lh_first4, align 8
  %next5 = getelementptr inbounds %struct.BdrvChild, ptr %7, i32 0, i32 9
  %le_prev = getelementptr inbounds %struct.anon.14, ptr %next5, i32 0, i32 1
  store ptr %le_next2, ptr %le_prev, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  %8 = load ptr, ptr %child.addr, align 8
  %9 = load ptr, ptr %bs, align 8
  %children6 = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 29
  %lh_first7 = getelementptr inbounds %struct.anon.3, ptr %children6, i32 0, i32 0
  store ptr %8, ptr %lh_first7, align 8
  %10 = load ptr, ptr %bs, align 8
  %children8 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 29
  %lh_first9 = getelementptr inbounds %struct.anon.3, ptr %children8, i32 0, i32 0
  %11 = load ptr, ptr %child.addr, align 8
  %next10 = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 9
  %le_prev11 = getelementptr inbounds %struct.anon.14, ptr %next10, i32 0, i32 1
  store ptr %lh_first9, ptr %le_prev11, align 8
  br label %do.end

do.end:                                           ; preds = %if.end
  %12 = load ptr, ptr %bs, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 6
  %13 = load ptr, ptr %drv, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %13, i32 0, i32 2
  %14 = load i8, ptr %is_filter, align 4
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %if.then13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %15 = load ptr, ptr %child.addr, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %15, i32 0, i32 3
  %16 = load i32, ptr %role, align 8
  %and = and i32 %16, 4
  %tobool12 = icmp ne i32 %and, 0
  br i1 %tobool12, label %if.then13, label %if.else52

if.then13:                                        ; preds = %lor.lhs.false, %do.end
  %17 = load ptr, ptr %child.addr, align 8
  %role14 = getelementptr inbounds %struct.BdrvChild, ptr %17, i32 0, i32 3
  %18 = load i32, ptr %role14, align 8
  %and15 = and i32 %18, 8
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.else, label %if.then17

if.then17:                                        ; preds = %if.then13
  br label %if.end18

if.else:                                          ; preds = %if.then13
  call void @__assert_fail(ptr noundef @.str.164, ptr noundef @.str.2, i32 noundef 1437, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #16
  unreachable

if.end18:                                         ; preds = %if.then17
  %19 = load ptr, ptr %child.addr, align 8
  %role19 = getelementptr inbounds %struct.BdrvChild, ptr %19, i32 0, i32 3
  %20 = load i32, ptr %role19, align 8
  %and20 = and i32 %20, 16
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.then22, label %if.else44

if.then22:                                        ; preds = %if.end18
  %21 = load ptr, ptr %child.addr, align 8
  %role23 = getelementptr inbounds %struct.BdrvChild, ptr %21, i32 0, i32 3
  %22 = load i32, ptr %role23, align 8
  %and24 = and i32 %22, 4
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.then22
  br label %if.end28

if.else27:                                        ; preds = %if.then22
  call void @__assert_fail(ptr noundef @.str.165, ptr noundef @.str.2, i32 noundef 1439, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #16
  unreachable

if.end28:                                         ; preds = %if.then26
  %23 = load ptr, ptr %bs, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %23, i32 0, i32 30
  %24 = load ptr, ptr %backing, align 8
  %tobool29 = icmp ne ptr %24, null
  br i1 %tobool29, label %if.else31, label %if.then30

if.then30:                                        ; preds = %if.end28
  br label %if.end32

if.else31:                                        ; preds = %if.end28
  call void @__assert_fail(ptr noundef @.str.166, ptr noundef @.str.2, i32 noundef 1440, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #16
  unreachable

if.end32:                                         ; preds = %if.then30
  %25 = load ptr, ptr %bs, align 8
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %25, i32 0, i32 31
  %26 = load ptr, ptr %file, align 8
  %tobool33 = icmp ne ptr %26, null
  br i1 %tobool33, label %if.else35, label %if.then34

if.then34:                                        ; preds = %if.end32
  br label %if.end36

if.else35:                                        ; preds = %if.end32
  call void @__assert_fail(ptr noundef @.str.167, ptr noundef @.str.2, i32 noundef 1441, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #16
  unreachable

if.end36:                                         ; preds = %if.then34
  %27 = load ptr, ptr %bs, align 8
  %drv37 = getelementptr inbounds %struct.BlockDriverState, ptr %27, i32 0, i32 6
  %28 = load ptr, ptr %drv37, align 8
  %filtered_child_is_backing = getelementptr inbounds %struct.BlockDriver, ptr %28, i32 0, i32 3
  %29 = load i8, ptr %filtered_child_is_backing, align 1
  %tobool38 = trunc i8 %29 to i1
  br i1 %tobool38, label %if.then39, label %if.else41

if.then39:                                        ; preds = %if.end36
  %30 = load ptr, ptr %child.addr, align 8
  %31 = load ptr, ptr %bs, align 8
  %backing40 = getelementptr inbounds %struct.BlockDriverState, ptr %31, i32 0, i32 30
  store ptr %30, ptr %backing40, align 8
  br label %if.end43

if.else41:                                        ; preds = %if.end36
  %32 = load ptr, ptr %child.addr, align 8
  %33 = load ptr, ptr %bs, align 8
  %file42 = getelementptr inbounds %struct.BlockDriverState, ptr %33, i32 0, i32 31
  store ptr %32, ptr %file42, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.else41, %if.then39
  br label %if.end51

if.else44:                                        ; preds = %if.end18
  %34 = load ptr, ptr %child.addr, align 8
  %role45 = getelementptr inbounds %struct.BdrvChild, ptr %34, i32 0, i32 3
  %35 = load i32, ptr %role45, align 8
  %and46 = and i32 %35, 4
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.else49, label %if.then48

if.then48:                                        ; preds = %if.else44
  br label %if.end50

if.else49:                                        ; preds = %if.else44
  call void @__assert_fail(ptr noundef @.str.168, ptr noundef @.str.2, i32 noundef 1449, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #16
  unreachable

if.end50:                                         ; preds = %if.then48
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %if.end43
  br label %if.end87

if.else52:                                        ; preds = %lor.lhs.false
  %36 = load ptr, ptr %child.addr, align 8
  %role53 = getelementptr inbounds %struct.BdrvChild, ptr %36, i32 0, i32 3
  %37 = load i32, ptr %role53, align 8
  %and54 = and i32 %37, 8
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.then56, label %if.else74

if.then56:                                        ; preds = %if.else52
  %38 = load ptr, ptr %bs, align 8
  %drv57 = getelementptr inbounds %struct.BlockDriverState, ptr %38, i32 0, i32 6
  %39 = load ptr, ptr %drv57, align 8
  %supports_backing = getelementptr inbounds %struct.BlockDriver, ptr %39, i32 0, i32 7
  %40 = load i8, ptr %supports_backing, align 1
  %tobool58 = trunc i8 %40 to i1
  br i1 %tobool58, label %if.then59, label %if.else60

if.then59:                                        ; preds = %if.then56
  br label %if.end61

if.else60:                                        ; preds = %if.then56
  call void @__assert_fail(ptr noundef @.str.169, ptr noundef @.str.2, i32 noundef 1452, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #16
  unreachable

if.end61:                                         ; preds = %if.then59
  %41 = load ptr, ptr %child.addr, align 8
  %role62 = getelementptr inbounds %struct.BdrvChild, ptr %41, i32 0, i32 3
  %42 = load i32, ptr %role62, align 8
  %and63 = and i32 %42, 16
  %tobool64 = icmp ne i32 %and63, 0
  br i1 %tobool64, label %if.else66, label %if.then65

if.then65:                                        ; preds = %if.end61
  br label %if.end67

if.else66:                                        ; preds = %if.end61
  call void @__assert_fail(ptr noundef @.str.170, ptr noundef @.str.2, i32 noundef 1453, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #16
  unreachable

if.end67:                                         ; preds = %if.then65
  %43 = load ptr, ptr %bs, align 8
  %backing68 = getelementptr inbounds %struct.BlockDriverState, ptr %43, i32 0, i32 30
  %44 = load ptr, ptr %backing68, align 8
  %tobool69 = icmp ne ptr %44, null
  br i1 %tobool69, label %if.else71, label %if.then70

if.then70:                                        ; preds = %if.end67
  br label %if.end72

if.else71:                                        ; preds = %if.end67
  call void @__assert_fail(ptr noundef @.str.166, ptr noundef @.str.2, i32 noundef 1454, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #16
  unreachable

if.end72:                                         ; preds = %if.then70
  %45 = load ptr, ptr %child.addr, align 8
  %46 = load ptr, ptr %bs, align 8
  %backing73 = getelementptr inbounds %struct.BlockDriverState, ptr %46, i32 0, i32 30
  store ptr %45, ptr %backing73, align 8
  %47 = load ptr, ptr %child.addr, align 8
  call void @bdrv_backing_attach(ptr noundef %47)
  br label %if.end86

if.else74:                                        ; preds = %if.else52
  %48 = load ptr, ptr %child.addr, align 8
  %role75 = getelementptr inbounds %struct.BdrvChild, ptr %48, i32 0, i32 3
  %49 = load i32, ptr %role75, align 8
  %and76 = and i32 %49, 16
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %if.then78, label %if.end85

if.then78:                                        ; preds = %if.else74
  %50 = load ptr, ptr %bs, align 8
  %file79 = getelementptr inbounds %struct.BlockDriverState, ptr %50, i32 0, i32 31
  %51 = load ptr, ptr %file79, align 8
  %tobool80 = icmp ne ptr %51, null
  br i1 %tobool80, label %if.else82, label %if.then81

if.then81:                                        ; preds = %if.then78
  br label %if.end83

if.else82:                                        ; preds = %if.then78
  call void @__assert_fail(ptr noundef @.str.167, ptr noundef @.str.2, i32 noundef 1458, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_attach) #16
  unreachable

if.end83:                                         ; preds = %if.then81
  %52 = load ptr, ptr %child.addr, align 8
  %53 = load ptr, ptr %bs, align 8
  %file84 = getelementptr inbounds %struct.BlockDriverState, ptr %53, i32 0, i32 31
  store ptr %52, ptr %file84, align 8
  br label %if.end85

if.end85:                                         ; preds = %if.end83, %if.else74
  br label %if.end86

if.end86:                                         ; preds = %if.end85, %if.end72
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %if.end51
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_cb_detach(ptr noundef %child) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %bs, align 8
  %2 = load ptr, ptr %child.addr, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %2, i32 0, i32 3
  %3 = load i32, ptr %role, align 8
  %and = and i32 %3, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %child.addr, align 8
  call void @bdrv_backing_detach(ptr noundef %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @assert_bdrv_graph_writable()
  br label %do.body

do.body:                                          ; preds = %if.end
  %5 = load ptr, ptr %child.addr, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %6 = load ptr, ptr %le_next, align 8
  %cmp = icmp ne ptr %6, null
  br i1 %cmp, label %if.then1, label %if.end7

if.then1:                                         ; preds = %do.body
  %7 = load ptr, ptr %child.addr, align 8
  %next2 = getelementptr inbounds %struct.BdrvChild, ptr %7, i32 0, i32 9
  %le_prev = getelementptr inbounds %struct.anon.14, ptr %next2, i32 0, i32 1
  %8 = load ptr, ptr %le_prev, align 8
  %9 = load ptr, ptr %child.addr, align 8
  %next3 = getelementptr inbounds %struct.BdrvChild, ptr %9, i32 0, i32 9
  %le_next4 = getelementptr inbounds %struct.anon.14, ptr %next3, i32 0, i32 0
  %10 = load ptr, ptr %le_next4, align 8
  %next5 = getelementptr inbounds %struct.BdrvChild, ptr %10, i32 0, i32 9
  %le_prev6 = getelementptr inbounds %struct.anon.14, ptr %next5, i32 0, i32 1
  store ptr %8, ptr %le_prev6, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then1, %do.body
  %11 = load ptr, ptr %child.addr, align 8
  %next8 = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 9
  %le_next9 = getelementptr inbounds %struct.anon.14, ptr %next8, i32 0, i32 0
  %12 = load ptr, ptr %le_next9, align 8
  %13 = load ptr, ptr %child.addr, align 8
  %next10 = getelementptr inbounds %struct.BdrvChild, ptr %13, i32 0, i32 9
  %le_prev11 = getelementptr inbounds %struct.anon.14, ptr %next10, i32 0, i32 1
  %14 = load ptr, ptr %le_prev11, align 8
  store ptr %12, ptr %14, align 8
  %15 = load ptr, ptr %child.addr, align 8
  %next12 = getelementptr inbounds %struct.BdrvChild, ptr %15, i32 0, i32 9
  %le_next13 = getelementptr inbounds %struct.anon.14, ptr %next12, i32 0, i32 0
  store ptr null, ptr %le_next13, align 8
  %16 = load ptr, ptr %child.addr, align 8
  %next14 = getelementptr inbounds %struct.BdrvChild, ptr %16, i32 0, i32 9
  %le_prev15 = getelementptr inbounds %struct.anon.14, ptr %next14, i32 0, i32 1
  store ptr null, ptr %le_prev15, align 8
  br label %do.end

do.end:                                           ; preds = %if.end7
  %17 = load ptr, ptr %child.addr, align 8
  %18 = load ptr, ptr %bs, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 30
  %19 = load ptr, ptr %backing, align 8
  %cmp16 = icmp eq ptr %17, %19
  br i1 %cmp16, label %if.then17, label %if.else22

if.then17:                                        ; preds = %do.end
  %20 = load ptr, ptr %child.addr, align 8
  %21 = load ptr, ptr %bs, align 8
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %21, i32 0, i32 31
  %22 = load ptr, ptr %file, align 8
  %cmp18 = icmp ne ptr %20, %22
  br i1 %cmp18, label %if.then19, label %if.else

if.then19:                                        ; preds = %if.then17
  br label %if.end20

if.else:                                          ; preds = %if.then17
  call void @__assert_fail(ptr noundef @.str.173, ptr noundef @.str.2, i32 noundef 1474, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_cb_detach) #16
  unreachable

if.end20:                                         ; preds = %if.then19
  %23 = load ptr, ptr %bs, align 8
  %backing21 = getelementptr inbounds %struct.BlockDriverState, ptr %23, i32 0, i32 30
  store ptr null, ptr %backing21, align 8
  br label %if.end28

if.else22:                                        ; preds = %do.end
  %24 = load ptr, ptr %child.addr, align 8
  %25 = load ptr, ptr %bs, align 8
  %file23 = getelementptr inbounds %struct.BlockDriverState, ptr %25, i32 0, i32 31
  %26 = load ptr, ptr %file23, align 8
  %cmp24 = icmp eq ptr %24, %26
  br i1 %cmp24, label %if.then25, label %if.end27

if.then25:                                        ; preds = %if.else22
  %27 = load ptr, ptr %bs, align 8
  %file26 = getelementptr inbounds %struct.BlockDriverState, ptr %27, i32 0, i32 31
  store ptr null, ptr %file26, align 8
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %if.else22
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end20
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_cb_drained_begin(ptr noundef %child) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %bs, align 8
  %2 = load ptr, ptr %bs, align 8
  call void @bdrv_do_drained_begin_quiesce(ptr noundef %2, ptr noundef null)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_cb_drained_end(ptr noundef %child) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %bs, align 8
  %2 = load ptr, ptr %bs, align 8
  call void @bdrv_drained_end(ptr noundef %2)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_child_cb_drained_poll(ptr noundef %child) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %bs, align 8
  %2 = load ptr, ptr %bs, align 8
  %call = call zeroext i1 @bdrv_drain_poll(ptr noundef %2, ptr noundef null, i1 noundef zeroext false)
  ret i1 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_child_cb_update_filename(ptr noundef %c, ptr noundef %base, ptr noundef %filename, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %base.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %base, ptr %base.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 3
  %1 = load i32, ptr %role, align 8
  %and = and i32 %1, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load ptr, ptr %c.addr, align 8
  %3 = load ptr, ptr %base.addr, align 8
  %4 = load ptr, ptr %filename.addr, align 8
  %5 = load ptr, ptr %errp.addr, align 8
  %call = call i32 @bdrv_backing_update_filename(ptr noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5)
  store i32 %call, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, ptr %retval, align 4
  ret i32 %6
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_child_cb_change_aio_ctx(ptr noundef %child, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %visited.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %visited, ptr %visited.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %bs, align 8
  %2 = load ptr, ptr %bs, align 8
  %3 = load ptr, ptr %ctx.addr, align 8
  %4 = load ptr, ptr %visited.addr, align 8
  %5 = load ptr, ptr %tran.addr, align 8
  %6 = load ptr, ptr %errp.addr, align 8
  %call = call zeroext i1 @bdrv_change_aio_context(ptr noundef %2, ptr noundef %3, ptr noundef %4, ptr noundef %5, ptr noundef %6)
  ret i1 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_child_get_parent_aio_context(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %c.addr, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %klass, align 8
  %get_parent_aio_context = getelementptr inbounds %struct.BdrvChildClass, ptr %1, i32 0, i32 16
  %2 = load ptr, ptr %get_parent_aio_context, align 8
  %3 = load ptr, ptr %c.addr, align 8
  %call = call ptr %2(ptr noundef %3)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_new_open_driver_opts(ptr noundef %drv, ptr noundef %node_name, ptr noundef %options, i32 noundef %flags, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %drv.addr = alloca ptr, align 8
  %node_name.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %errp.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %ret = alloca i32, align 4
  %_obj14 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp13 = alloca ptr, align 8
  %_obj15 = alloca ptr, align 8
  %tmp19 = alloca ptr, align 8
  %__mptr22 = alloca ptr, align 8
  %tmp24 = alloca ptr, align 8
  store ptr %drv, ptr %drv.addr, align 8
  store ptr %node_name, ptr %node_name.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1739, ptr noundef @__PRETTY_FUNCTION__.bdrv_new_open_driver_opts) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @bdrv_new()
  store ptr %call1, ptr %bs, align 8
  %0 = load i32, ptr %flags.addr, align 4
  %1 = load ptr, ptr %bs, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 0
  store i32 %0, ptr %open_flags, align 8
  %2 = load ptr, ptr %options.addr, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %call2 = call ptr @qdict_new()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %2, %cond.true ], [ %call2, %cond.false ]
  %3 = load ptr, ptr %bs, align 8
  %options3 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 33
  store ptr %cond, ptr %options3, align 8
  %4 = load ptr, ptr %bs, align 8
  %options4 = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 33
  %5 = load ptr, ptr %options4, align 8
  %call5 = call ptr @qdict_clone_shallow(ptr noundef %5)
  %6 = load ptr, ptr %bs, align 8
  %explicit_options = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 34
  store ptr %call5, ptr %explicit_options, align 8
  %7 = load ptr, ptr %bs, align 8
  %opaque = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 7
  store ptr null, ptr %opaque, align 8
  %8 = load ptr, ptr %bs, align 8
  %options6 = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 33
  %9 = load ptr, ptr %options6, align 8
  %10 = load i32, ptr %flags.addr, align 4
  call void @update_options_from_flags(ptr noundef %9, i32 noundef %10)
  %11 = load ptr, ptr %bs, align 8
  %12 = load ptr, ptr %drv.addr, align 8
  %13 = load ptr, ptr %node_name.addr, align 8
  %14 = load ptr, ptr %bs, align 8
  %options7 = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 33
  %15 = load ptr, ptr %options7, align 8
  %16 = load i32, ptr %flags.addr, align 4
  %17 = load ptr, ptr %errp.addr, align 8
  %call8 = call i32 @bdrv_open_driver(ptr noundef %11, ptr noundef %12, ptr noundef %13, ptr noundef %15, i32 noundef %16, ptr noundef %17)
  store i32 %call8, ptr %ret, align 4
  %18 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %18, 0
  br i1 %cmp, label %if.then9, label %if.end30

if.then9:                                         ; preds = %cond.end
  %19 = load ptr, ptr %bs, align 8
  %explicit_options10 = getelementptr inbounds %struct.BlockDriverState, ptr %19, i32 0, i32 34
  %20 = load ptr, ptr %explicit_options10, align 8
  store ptr %20, ptr %_obj14, align 8
  %21 = load ptr, ptr %_obj14, align 8
  %tobool11 = icmp ne ptr %21, null
  br i1 %tobool11, label %cond.true12, label %cond.false14

cond.true12:                                      ; preds = %if.then9
  %22 = load ptr, ptr %_obj14, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %22, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %23 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %23, i64 0
  store ptr %add.ptr, ptr %tmp13, align 8
  %24 = load ptr, ptr %tmp13, align 8
  br label %cond.end15

cond.false14:                                     ; preds = %if.then9
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false14, %cond.true12
  %cond16 = phi ptr [ %24, %cond.true12 ], [ null, %cond.false14 ]
  store ptr %cond16, ptr %tmp, align 8
  %25 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %25)
  %26 = load ptr, ptr %bs, align 8
  %explicit_options17 = getelementptr inbounds %struct.BlockDriverState, ptr %26, i32 0, i32 34
  store ptr null, ptr %explicit_options17, align 8
  %27 = load ptr, ptr %bs, align 8
  %options18 = getelementptr inbounds %struct.BlockDriverState, ptr %27, i32 0, i32 33
  %28 = load ptr, ptr %options18, align 8
  store ptr %28, ptr %_obj15, align 8
  %29 = load ptr, ptr %_obj15, align 8
  %tobool20 = icmp ne ptr %29, null
  br i1 %tobool20, label %cond.true21, label %cond.false26

cond.true21:                                      ; preds = %cond.end15
  %30 = load ptr, ptr %_obj15, align 8
  %base23 = getelementptr inbounds %struct.QDict, ptr %30, i32 0, i32 0
  store ptr %base23, ptr %__mptr22, align 8
  %31 = load ptr, ptr %__mptr22, align 8
  %add.ptr25 = getelementptr i8, ptr %31, i64 0
  store ptr %add.ptr25, ptr %tmp24, align 8
  %32 = load ptr, ptr %tmp24, align 8
  br label %cond.end27

cond.false26:                                     ; preds = %cond.end15
  br label %cond.end27

cond.end27:                                       ; preds = %cond.false26, %cond.true21
  %cond28 = phi ptr [ %32, %cond.true21 ], [ null, %cond.false26 ]
  store ptr %cond28, ptr %tmp19, align 8
  %33 = load ptr, ptr %tmp19, align 8
  call void @qobject_unref_impl(ptr noundef %33)
  %34 = load ptr, ptr %bs, align 8
  %options29 = getelementptr inbounds %struct.BlockDriverState, ptr %34, i32 0, i32 33
  store ptr null, ptr %options29, align 8
  %35 = load ptr, ptr %bs, align 8
  call void @bdrv_unref(ptr noundef %35)
  store ptr null, ptr %retval, align 8
  br label %return

if.end30:                                         ; preds = %cond.end
  %36 = load ptr, ptr %bs, align 8
  store ptr %36, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end30, %cond.end27
  %37 = load ptr, ptr %retval, align 8
  ret ptr %37
}

declare ptr @qdict_clone_shallow(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @update_options_from_flags(ptr noundef %options, i32 noundef %flags) #0 {
entry:
  %options.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  store ptr %options, ptr %options.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1558, ptr noundef @__PRETTY_FUNCTION__.update_options_from_flags) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %options.addr, align 8
  %call1 = call i32 @qdict_haskey(ptr noundef %0, ptr noundef @.str.47)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end4, label %if.then2

if.then2:                                         ; preds = %do.end
  %1 = load ptr, ptr %options.addr, align 8
  %2 = load i32, ptr %flags.addr, align 4
  %and = and i32 %2, 32
  %tobool3 = icmp ne i32 %and, 0
  call void @qdict_put_bool(ptr noundef %1, ptr noundef @.str.47, i1 noundef zeroext %tobool3)
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %do.end
  %3 = load ptr, ptr %options.addr, align 8
  %call5 = call i32 @qdict_haskey(ptr noundef %3, ptr noundef @.str.49)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end10, label %if.then7

if.then7:                                         ; preds = %if.end4
  %4 = load ptr, ptr %options.addr, align 8
  %5 = load i32, ptr %flags.addr, align 4
  %and8 = and i32 %5, 512
  %tobool9 = icmp ne i32 %and8, 0
  call void @qdict_put_bool(ptr noundef %4, ptr noundef @.str.49, i1 noundef zeroext %tobool9)
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end4
  %6 = load ptr, ptr %options.addr, align 8
  %call11 = call i32 @qdict_haskey(ptr noundef %6, ptr noundef @.str.51)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.end16, label %if.then13

if.then13:                                        ; preds = %if.end10
  %7 = load ptr, ptr %options.addr, align 8
  %8 = load i32, ptr %flags.addr, align 4
  %and14 = and i32 %8, 2
  %tobool15 = icmp ne i32 %and14, 0
  %lnot = xor i1 %tobool15, true
  call void @qdict_put_bool(ptr noundef %7, ptr noundef @.str.51, i1 noundef zeroext %lnot)
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end10
  %9 = load ptr, ptr %options.addr, align 8
  %call17 = call i32 @qdict_haskey(ptr noundef %9, ptr noundef @.str.53)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end22, label %if.then19

if.then19:                                        ; preds = %if.end16
  %10 = load ptr, ptr %options.addr, align 8
  %11 = load i32, ptr %flags.addr, align 4
  %and20 = and i32 %11, 131072
  %tobool21 = icmp ne i32 %and20, 0
  call void @qdict_put_bool(ptr noundef %10, ptr noundef @.str.53, i1 noundef zeroext %tobool21)
  br label %if.end22

if.end22:                                         ; preds = %if.then19, %if.end16
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_open_driver(ptr noundef %bs, ptr noundef %drv, ptr noundef %node_name, ptr noundef %options, i32 noundef %open_flags, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %drv.addr = alloca ptr, align 8
  %node_name.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %open_flags.addr = alloca i32, align 4
  %errp.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %drv, ptr %drv.addr, align 8
  store ptr %node_name, ptr %node_name.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store i32 %open_flags, ptr %open_flags.addr, align 4
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1631, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_driver) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %1 = load ptr, ptr %node_name.addr, align 8
  call void @bdrv_assign_node_name(ptr noundef %0, ptr noundef %1, ptr noundef %local_err)
  %2 = load ptr, ptr %local_err, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then1, label %if.end2

if.then1:                                         ; preds = %do.end
  %3 = load ptr, ptr %errp.addr, align 8
  %4 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %3, ptr noundef %4)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %do.end
  %5 = load ptr, ptr %drv.addr, align 8
  %6 = load ptr, ptr %bs.addr, align 8
  %drv3 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 6
  store ptr %5, ptr %drv3, align 8
  %7 = load ptr, ptr %drv.addr, align 8
  %instance_size = getelementptr inbounds %struct.BlockDriver, ptr %7, i32 0, i32 1
  %8 = load i32, ptr %instance_size, align 8
  %conv = sext i32 %8 to i64
  %call4 = call noalias ptr @g_malloc0(i64 noundef %conv) #14
  %9 = load ptr, ptr %bs.addr, align 8
  %opaque = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 7
  store ptr %call4, ptr %opaque, align 8
  %10 = load ptr, ptr %drv.addr, align 8
  %bdrv_file_open = getelementptr inbounds %struct.BlockDriver, ptr %10, i32 0, i32 24
  %11 = load ptr, ptr %bdrv_file_open, align 8
  %tobool5 = icmp ne ptr %11, null
  br i1 %tobool5, label %if.then6, label %if.else15

if.then6:                                         ; preds = %if.end2
  %12 = load ptr, ptr %drv.addr, align 8
  %bdrv_needs_filename = getelementptr inbounds %struct.BlockDriver, ptr %12, i32 0, i32 6
  %13 = load i8, ptr %bdrv_needs_filename, align 8
  %tobool7 = trunc i8 %13 to i1
  br i1 %tobool7, label %lor.lhs.false, label %if.then10

lor.lhs.false:                                    ; preds = %if.then6
  %14 = load ptr, ptr %bs.addr, align 8
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 11
  %arrayidx = getelementptr [4096 x i8], ptr %filename, i64 0, i64 0
  %15 = load i8, ptr %arrayidx, align 1
  %conv8 = sext i8 %15 to i32
  %tobool9 = icmp ne i32 %conv8, 0
  br i1 %tobool9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %lor.lhs.false, %if.then6
  br label %if.end12

if.else11:                                        ; preds = %lor.lhs.false
  call void @__assert_fail(ptr noundef @.str.176, ptr noundef @.str.2, i32 noundef 1643, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_driver) #16
  unreachable

if.end12:                                         ; preds = %if.then10
  %16 = load ptr, ptr %drv.addr, align 8
  %bdrv_file_open13 = getelementptr inbounds %struct.BlockDriver, ptr %16, i32 0, i32 24
  %17 = load ptr, ptr %bdrv_file_open13, align 8
  %18 = load ptr, ptr %bs.addr, align 8
  %19 = load ptr, ptr %options.addr, align 8
  %20 = load i32, ptr %open_flags.addr, align 4
  %call14 = call i32 %17(ptr noundef %18, ptr noundef %19, i32 noundef %20, ptr noundef %local_err)
  store i32 %call14, ptr %ret, align 4
  br label %if.end22

if.else15:                                        ; preds = %if.end2
  %21 = load ptr, ptr %drv.addr, align 8
  %bdrv_open = getelementptr inbounds %struct.BlockDriver, ptr %21, i32 0, i32 23
  %22 = load ptr, ptr %bdrv_open, align 8
  %tobool16 = icmp ne ptr %22, null
  br i1 %tobool16, label %if.then17, label %if.else20

if.then17:                                        ; preds = %if.else15
  %23 = load ptr, ptr %drv.addr, align 8
  %bdrv_open18 = getelementptr inbounds %struct.BlockDriver, ptr %23, i32 0, i32 23
  %24 = load ptr, ptr %bdrv_open18, align 8
  %25 = load ptr, ptr %bs.addr, align 8
  %26 = load ptr, ptr %options.addr, align 8
  %27 = load i32, ptr %open_flags.addr, align 4
  %call19 = call i32 %24(ptr noundef %25, ptr noundef %26, i32 noundef %27, ptr noundef %local_err)
  store i32 %call19, ptr %ret, align 4
  br label %if.end21

if.else20:                                        ; preds = %if.else15
  store i32 0, ptr %ret, align 4
  br label %if.end21

if.end21:                                         ; preds = %if.else20, %if.then17
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end12
  %28 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %28, 0
  br i1 %cmp, label %if.then24, label %if.end37

if.then24:                                        ; preds = %if.end22
  %29 = load ptr, ptr %local_err, align 8
  %tobool25 = icmp ne ptr %29, null
  br i1 %tobool25, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.then24
  %30 = load ptr, ptr %errp.addr, align 8
  %31 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %30, ptr noundef %31)
  br label %if.end36

if.else27:                                        ; preds = %if.then24
  %32 = load ptr, ptr %bs.addr, align 8
  %filename28 = getelementptr inbounds %struct.BlockDriverState, ptr %32, i32 0, i32 11
  %arrayidx29 = getelementptr [4096 x i8], ptr %filename28, i64 0, i64 0
  %33 = load i8, ptr %arrayidx29, align 1
  %tobool30 = icmp ne i8 %33, 0
  br i1 %tobool30, label %if.then31, label %if.else33

if.then31:                                        ; preds = %if.else27
  %34 = load ptr, ptr %errp.addr, align 8
  %35 = load i32, ptr %ret, align 4
  %sub = sub i32 0, %35
  %36 = load ptr, ptr %bs.addr, align 8
  %filename32 = getelementptr inbounds %struct.BlockDriverState, ptr %36, i32 0, i32 11
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %filename32, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %34, ptr noundef @.str.2, i32 noundef 1655, ptr noundef @__func__.bdrv_open_driver, i32 noundef %sub, ptr noundef @.str.177, ptr noundef %arraydecay)
  br label %if.end35

if.else33:                                        ; preds = %if.else27
  %37 = load ptr, ptr %errp.addr, align 8
  %38 = load i32, ptr %ret, align 4
  %sub34 = sub i32 0, %38
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %37, ptr noundef @.str.2, i32 noundef 1657, ptr noundef @__func__.bdrv_open_driver, i32 noundef %sub34, ptr noundef @.str.178)
  br label %if.end35

if.end35:                                         ; preds = %if.else33, %if.then31
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then26
  br label %open_failed

if.end37:                                         ; preds = %if.end22
  %39 = load ptr, ptr %bs.addr, align 8
  %supported_read_flags = getelementptr inbounds %struct.BlockDriverState, ptr %39, i32 0, i32 18
  %40 = load i32, ptr %supported_read_flags, align 8
  %and = and i32 %40, -2048
  %tobool38 = icmp ne i32 %and, 0
  br i1 %tobool38, label %if.else40, label %if.then39

if.then39:                                        ; preds = %if.end37
  br label %if.end41

if.else40:                                        ; preds = %if.end37
  call void @__assert_fail(ptr noundef @.str.179, ptr noundef @.str.2, i32 noundef 1662, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_driver) #16
  unreachable

if.end41:                                         ; preds = %if.then39
  %41 = load ptr, ptr %bs.addr, align 8
  %supported_write_flags = getelementptr inbounds %struct.BlockDriverState, ptr %41, i32 0, i32 19
  %42 = load i32, ptr %supported_write_flags, align 4
  %and42 = and i32 %42, -2048
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.else45, label %if.then44

if.then44:                                        ; preds = %if.end41
  br label %if.end46

if.else45:                                        ; preds = %if.end41
  call void @__assert_fail(ptr noundef @.str.180, ptr noundef @.str.2, i32 noundef 1663, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_driver) #16
  unreachable

if.end46:                                         ; preds = %if.then44
  %43 = load ptr, ptr %bs.addr, align 8
  %supported_read_flags47 = getelementptr inbounds %struct.BlockDriverState, ptr %43, i32 0, i32 18
  %44 = load i32, ptr %supported_read_flags47, align 8
  %or = or i32 %44, 8
  store i32 %or, ptr %supported_read_flags47, align 8
  %45 = load ptr, ptr %bs.addr, align 8
  %supported_write_flags48 = getelementptr inbounds %struct.BlockDriverState, ptr %45, i32 0, i32 19
  %46 = load i32, ptr %supported_write_flags48, align 4
  %or49 = or i32 %46, 8
  store i32 %or49, ptr %supported_write_flags48, align 4
  %47 = load ptr, ptr %bs.addr, align 8
  %call50 = call ptr @bdrv_get_aio_context(ptr noundef %47)
  store ptr %call50, ptr %ctx, align 8
  %48 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %48)
  %49 = load ptr, ptr %bs.addr, align 8
  %50 = load ptr, ptr %bs.addr, align 8
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %50, i32 0, i32 37
  %51 = load i64, ptr %total_sectors, align 8
  %call51 = call i32 @bdrv_refresh_total_sectors(ptr noundef %49, i64 noundef %51)
  store i32 %call51, ptr %ret, align 4
  %52 = load i32, ptr %ret, align 4
  %cmp52 = icmp slt i32 %52, 0
  br i1 %cmp52, label %if.then54, label %if.end56

if.then54:                                        ; preds = %if.end46
  %53 = load ptr, ptr %errp.addr, align 8
  %54 = load i32, ptr %ret, align 4
  %sub55 = sub i32 0, %54
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %53, ptr noundef @.str.2, i32 noundef 1682, ptr noundef @__func__.bdrv_open_driver, i32 noundef %sub55, ptr noundef @.str.102)
  %55 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %55)
  %56 = load i32, ptr %ret, align 4
  store i32 %56, ptr %retval, align 4
  br label %return

if.end56:                                         ; preds = %if.end46
  call void @bdrv_graph_rdlock_main_loop()
  %57 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_refresh_limits(ptr noundef %57, ptr noundef null, ptr noundef %local_err)
  call void @bdrv_graph_rdunlock_main_loop()
  %58 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %58)
  %59 = load ptr, ptr %local_err, align 8
  %tobool57 = icmp ne ptr %59, null
  br i1 %tobool57, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.end56
  %60 = load ptr, ptr %errp.addr, align 8
  %61 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %60, ptr noundef %61)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end59:                                         ; preds = %if.end56
  %62 = load ptr, ptr %bs.addr, align 8
  %call60 = call i64 @bdrv_opt_mem_align(ptr noundef %62)
  %cmp61 = icmp ne i64 %call60, 0
  br i1 %cmp61, label %if.then63, label %if.else64

if.then63:                                        ; preds = %if.end59
  br label %if.end65

if.else64:                                        ; preds = %if.end59
  call void @__assert_fail(ptr noundef @.str.181, ptr noundef @.str.2, i32 noundef 1697, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_driver) #16
  unreachable

if.end65:                                         ; preds = %if.then63
  %63 = load ptr, ptr %bs.addr, align 8
  %call66 = call i64 @bdrv_min_mem_align(ptr noundef %63)
  %cmp67 = icmp ne i64 %call66, 0
  br i1 %cmp67, label %if.then69, label %if.else70

if.then69:                                        ; preds = %if.end65
  br label %if.end71

if.else70:                                        ; preds = %if.end65
  call void @__assert_fail(ptr noundef @.str.182, ptr noundef @.str.2, i32 noundef 1698, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_driver) #16
  unreachable

if.end71:                                         ; preds = %if.then69
  %64 = load ptr, ptr %bs.addr, align 8
  %bl = getelementptr inbounds %struct.BlockDriverState, ptr %64, i32 0, i32 17
  %request_alignment = getelementptr inbounds %struct.BlockLimits, ptr %bl, i32 0, i32 0
  %65 = load i32, ptr %request_alignment, align 8
  %conv72 = zext i32 %65 to i64
  %call73 = call zeroext i1 @is_power_of_2(i64 noundef %conv72)
  br i1 %call73, label %if.then74, label %if.else75

if.then74:                                        ; preds = %if.end71
  br label %if.end76

if.else75:                                        ; preds = %if.end71
  call void @__assert_fail(ptr noundef @.str.183, ptr noundef @.str.2, i32 noundef 1699, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_driver) #16
  unreachable

if.end76:                                         ; preds = %if.then74
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end76
  %66 = load i32, ptr %i, align 4
  %67 = load ptr, ptr %bs.addr, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %67, i32 0, i32 46
  %68 = load i32, ptr %quiesce_counter, align 8
  %cmp77 = icmp slt i32 %66, %68
  br i1 %cmp77, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %69 = load ptr, ptr %drv.addr, align 8
  %bdrv_drain_begin = getelementptr inbounds %struct.BlockDriver, ptr %69, i32 0, i32 49
  %70 = load ptr, ptr %bdrv_drain_begin, align 8
  %tobool79 = icmp ne ptr %70, null
  br i1 %tobool79, label %if.then80, label %if.end82

if.then80:                                        ; preds = %for.body
  %71 = load ptr, ptr %drv.addr, align 8
  %bdrv_drain_begin81 = getelementptr inbounds %struct.BlockDriver, ptr %71, i32 0, i32 49
  %72 = load ptr, ptr %bdrv_drain_begin81, align 8
  %73 = load ptr, ptr %bs.addr, align 8
  call void %72(ptr noundef %73)
  br label %if.end82

if.end82:                                         ; preds = %if.then80, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end82
  %74 = load i32, ptr %i, align 4
  %inc = add i32 %74, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !16

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

open_failed:                                      ; preds = %if.end36
  %75 = load ptr, ptr %bs.addr, align 8
  %drv83 = getelementptr inbounds %struct.BlockDriverState, ptr %75, i32 0, i32 6
  store ptr null, ptr %drv83, align 8
  call void @bdrv_graph_wrlock(ptr noundef null)
  %76 = load ptr, ptr %bs.addr, align 8
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %76, i32 0, i32 31
  %77 = load ptr, ptr %file, align 8
  %cmp84 = icmp ne ptr %77, null
  br i1 %cmp84, label %if.then86, label %if.end93

if.then86:                                        ; preds = %open_failed
  %78 = load ptr, ptr %bs.addr, align 8
  %79 = load ptr, ptr %bs.addr, align 8
  %file87 = getelementptr inbounds %struct.BlockDriverState, ptr %79, i32 0, i32 31
  %80 = load ptr, ptr %file87, align 8
  call void @bdrv_unref_child(ptr noundef %78, ptr noundef %80)
  %81 = load ptr, ptr %bs.addr, align 8
  %file88 = getelementptr inbounds %struct.BlockDriverState, ptr %81, i32 0, i32 31
  %82 = load ptr, ptr %file88, align 8
  %tobool89 = icmp ne ptr %82, null
  br i1 %tobool89, label %if.else91, label %if.then90

if.then90:                                        ; preds = %if.then86
  br label %if.end92

if.else91:                                        ; preds = %if.then86
  call void @__assert_fail(ptr noundef @.str.167, ptr noundef @.str.2, i32 noundef 1714, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_driver) #16
  unreachable

if.end92:                                         ; preds = %if.then90
  br label %if.end93

if.end93:                                         ; preds = %if.end92, %open_failed
  call void @bdrv_graph_wrunlock(ptr noundef null)
  %83 = load ptr, ptr %bs.addr, align 8
  %opaque94 = getelementptr inbounds %struct.BlockDriverState, ptr %83, i32 0, i32 7
  %84 = load ptr, ptr %opaque94, align 8
  call void @g_free(ptr noundef %84)
  %85 = load ptr, ptr %bs.addr, align 8
  %opaque95 = getelementptr inbounds %struct.BlockDriverState, ptr %85, i32 0, i32 7
  store ptr null, ptr %opaque95, align 8
  %86 = load i32, ptr %ret, align 4
  store i32 %86, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end93, %for.end, %if.then58, %if.then54, %if.then1
  %87 = load i32, ptr %retval, align 4
  ret i32 %87
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_unref(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7247, ptr noundef @__PRETTY_FUNCTION__.bdrv_unref) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %do.end
  br label %if.end9

if.end2:                                          ; preds = %do.end
  %1 = load ptr, ptr %bs.addr, align 8
  %refcnt = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 26
  %2 = load i32, ptr %refcnt, align 8
  %cmp = icmp sgt i32 %2, 0
  br i1 %cmp, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.end2
  br label %if.end5

if.else4:                                         ; preds = %if.end2
  call void @__assert_fail(ptr noundef @.str.104, ptr noundef @.str.2, i32 noundef 7251, ptr noundef @__PRETTY_FUNCTION__.bdrv_unref) #16
  unreachable

if.end5:                                          ; preds = %if.then3
  %3 = load ptr, ptr %bs.addr, align 8
  %refcnt6 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 26
  %4 = load i32, ptr %refcnt6, align 8
  %dec = add i32 %4, -1
  store i32 %dec, ptr %refcnt6, align 8
  %cmp7 = icmp eq i32 %dec, 0
  br i1 %cmp7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %5 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_delete(ptr noundef %5)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end5, %if.then1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_new_open_driver(ptr noundef %drv, ptr noundef %node_name, i32 noundef %flags, ptr noundef %errp) #0 {
entry:
  %drv.addr = alloca ptr, align 8
  %node_name.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %errp.addr = alloca ptr, align 8
  store ptr %drv, ptr %drv.addr, align 8
  store ptr %node_name, ptr %node_name.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1766, ptr noundef @__PRETTY_FUNCTION__.bdrv_new_open_driver) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %drv.addr, align 8
  %1 = load ptr, ptr %node_name.addr, align 8
  %2 = load i32, ptr %flags.addr, align 4
  %3 = load ptr, ptr %errp.addr, align 8
  %call1 = call ptr @bdrv_new_open_driver_opts(ptr noundef %0, ptr noundef %1, ptr noundef null, i32 noundef %2, ptr noundef %3)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_is_writable(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call zeroext i1 @bdrv_is_writable_after_reopen(ptr noundef %0, ptr noundef null)
  ret i1 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_is_writable_after_reopen(ptr noundef %bs, ptr noundef %q) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  %flags = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  %0 = load ptr, ptr %q.addr, align 8
  %1 = load ptr, ptr %bs.addr, align 8
  %call = call i32 @bdrv_reopen_get_flags(ptr noundef %0, ptr noundef %1)
  store i32 %call, ptr %flags, align 4
  %2 = load i32, ptr %flags, align 4
  %and = and i32 %2, 2050
  %cmp = icmp eq i32 %and, 2
  ret i1 %cmp
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_drv_set_perm_abort(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %bs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2359, ptr noundef @__PRETTY_FUNCTION__.bdrv_drv_set_perm_abort) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load ptr, ptr %bs, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %bdrv_abort_perm_update = getelementptr inbounds %struct.BlockDriver, ptr %2, i32 0, i32 57
  %3 = load ptr, ptr %bdrv_abort_perm_update, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then1, label %if.end4

if.then1:                                         ; preds = %do.end
  %4 = load ptr, ptr %bs, align 8
  %drv2 = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 6
  %5 = load ptr, ptr %drv2, align 8
  %bdrv_abort_perm_update3 = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 57
  %6 = load ptr, ptr %bdrv_abort_perm_update3, align 8
  %7 = load ptr, ptr %bs, align 8
  call void %6(ptr noundef %7)
  br label %if.end4

if.end4:                                          ; preds = %if.then1, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_drv_set_perm_commit(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %cumulative_perms = alloca i64, align 8
  %cumulative_shared_perms = alloca i64, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %bs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2347, ptr noundef @__PRETTY_FUNCTION__.bdrv_drv_set_perm_commit) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load ptr, ptr %bs, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %bdrv_set_perm = getelementptr inbounds %struct.BlockDriver, ptr %2, i32 0, i32 56
  %3 = load ptr, ptr %bdrv_set_perm, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then1, label %if.end4

if.then1:                                         ; preds = %do.end
  %4 = load ptr, ptr %bs, align 8
  call void @bdrv_get_cumulative_perm(ptr noundef %4, ptr noundef %cumulative_perms, ptr noundef %cumulative_shared_perms)
  %5 = load ptr, ptr %bs, align 8
  %drv2 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %drv2, align 8
  %bdrv_set_perm3 = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 56
  %7 = load ptr, ptr %bdrv_set_perm3, align 8
  %8 = load ptr, ptr %bs, align 8
  %9 = load i64, ptr %cumulative_perms, align 8
  %10 = load i64, ptr %cumulative_shared_perms, align 8
  call void %7(ptr noundef %8, i64 noundef %9, i64 noundef %10)
  br label %if.end4

if.end4:                                          ; preds = %if.then1, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_get_cumulative_perm(ptr noundef %bs, ptr noundef %perm, ptr noundef %shared_perm) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %perm.addr = alloca ptr, align 8
  %shared_perm.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %cumulative_perms = alloca i64, align 8
  %cumulative_shared_perms = alloca i64, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %perm, ptr %perm.addr, align 8
  store ptr %shared_perm, ptr %shared_perm.addr, align 8
  store i64 0, ptr %cumulative_perms, align 8
  store i64 15, ptr %cumulative_shared_perms, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2620, ptr noundef @__PRETTY_FUNCTION__.bdrv_get_cumulative_perm) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %1 = load ptr, ptr %lh_first, align 8
  store ptr %1, ptr %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %2 = load ptr, ptr %c, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %c, align 8
  %perm1 = getelementptr inbounds %struct.BdrvChild, ptr %3, i32 0, i32 5
  %4 = load i64, ptr %perm1, align 8
  %5 = load i64, ptr %cumulative_perms, align 8
  %or = or i64 %5, %4
  store i64 %or, ptr %cumulative_perms, align 8
  %6 = load ptr, ptr %c, align 8
  %shared_perm2 = getelementptr inbounds %struct.BdrvChild, ptr %6, i32 0, i32 6
  %7 = load i64, ptr %shared_perm2, align 8
  %8 = load i64, ptr %cumulative_shared_perms, align 8
  %and = and i64 %8, %7
  store i64 %and, ptr %cumulative_shared_perms, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load ptr, ptr %c, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %9, i32 0, i32 10
  %le_next = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %10 = load ptr, ptr %le_next, align 8
  store ptr %10, ptr %c, align 8
  br label %for.cond, !llvm.loop !17

for.end:                                          ; preds = %for.cond
  %11 = load i64, ptr %cumulative_perms, align 8
  %12 = load ptr, ptr %perm.addr, align 8
  store i64 %11, ptr %12, align 8
  %13 = load i64, ptr %cumulative_shared_perms, align 8
  %14 = load ptr, ptr %shared_perm.addr, align 8
  store i64 %13, ptr %14, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_perm_names(i64 noundef %perm) #0 {
entry:
  %perm.addr = alloca i64, align 8
  %permissions = alloca [5 x %struct.perm_name], align 16
  %result = alloca ptr, align 8
  %p = alloca ptr, align 8
  store i64 %perm, ptr %perm.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %permissions, ptr align 16 @__const.bdrv_perm_names.permissions, i64 80, i1 false)
  %call = call ptr @g_string_sized_new(i64 noundef 30)
  store ptr %call, ptr %result, align 8
  %arraydecay = getelementptr inbounds [5 x %struct.perm_name], ptr %permissions, i64 0, i64 0
  store ptr %arraydecay, ptr %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load ptr, ptr %p, align 8
  %name = getelementptr inbounds %struct.perm_name, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %name, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64, ptr %perm.addr, align 8
  %3 = load ptr, ptr %p, align 8
  %perm1 = getelementptr inbounds %struct.perm_name, ptr %3, i32 0, i32 0
  %4 = load i64, ptr %perm1, align 8
  %and = and i64 %2, %4
  %tobool2 = icmp ne i64 %and, 0
  br i1 %tobool2, label %if.then, label %if.end7

if.then:                                          ; preds = %for.body
  %5 = load ptr, ptr %result, align 8
  %len = getelementptr inbounds %struct._GString, ptr %5, i32 0, i32 1
  %6 = load i64, ptr %len, align 8
  %cmp = icmp ugt i64 %6, 0
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %7 = load ptr, ptr %result, align 8
  %call4 = call ptr @g_string_append(ptr noundef %7, ptr noundef @.str.70)
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  %8 = load ptr, ptr %result, align 8
  %9 = load ptr, ptr %p, align 8
  %name5 = getelementptr inbounds %struct.perm_name, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %name5, align 8
  %call6 = call ptr @g_string_append(ptr noundef %8, ptr noundef %10)
  br label %if.end7

if.end7:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %11 = load ptr, ptr %p, align 8
  %incdec.ptr = getelementptr %struct.perm_name, ptr %11, i32 1
  store ptr %incdec.ptr, ptr %p, align 8
  br label %for.cond, !llvm.loop !18

for.end:                                          ; preds = %for.cond
  %12 = load ptr, ptr %result, align 8
  %call8 = call ptr @g_string_free(ptr noundef %12, i32 noundef 0)
  ret ptr %call8
}

declare ptr @g_string_sized_new(i64 noundef) #2

declare ptr @g_string_free(ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_child_try_set_perm(ptr noundef %c, i64 noundef %perm, i64 noundef %shared, ptr noundef %errp) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %perm.addr = alloca i64, align 8
  %shared.addr = alloca i64, align 8
  %errp.addr = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %tran = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store i64 %perm, ptr %perm.addr, align 8
  store i64 %shared, ptr %shared.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %local_err, align 8
  %call = call ptr @tran_new()
  store ptr %call, ptr %tran, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2694, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_try_set_perm) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %c.addr, align 8
  %1 = load i64, ptr %perm.addr, align 8
  %2 = load i64, ptr %shared.addr, align 8
  %3 = load ptr, ptr %tran, align 8
  call void @bdrv_child_set_perm(ptr noundef %0, i64 noundef %1, i64 noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %c.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %bs, align 8
  %6 = load ptr, ptr %tran, align 8
  %call2 = call i32 @bdrv_refresh_perms(ptr noundef %5, ptr noundef %6, ptr noundef %local_err)
  store i32 %call2, ptr %ret, align 4
  %7 = load ptr, ptr %tran, align 8
  %8 = load i32, ptr %ret, align 4
  call void @tran_finalize(ptr noundef %7, i32 noundef %8)
  %9 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %9, 0
  br i1 %cmp, label %if.then3, label %if.end11

if.then3:                                         ; preds = %do.end
  %10 = load i64, ptr %perm.addr, align 8
  %11 = load ptr, ptr %c.addr, align 8
  %perm4 = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 5
  %12 = load i64, ptr %perm4, align 8
  %not = xor i64 %12, -1
  %and = and i64 %10, %not
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then3
  %13 = load ptr, ptr %c.addr, align 8
  %shared_perm = getelementptr inbounds %struct.BdrvChild, ptr %13, i32 0, i32 6
  %14 = load i64, ptr %shared_perm, align 8
  %15 = load i64, ptr %shared.addr, align 8
  %not5 = xor i64 %15, -1
  %and6 = and i64 %14, %not5
  %tobool7 = icmp ne i64 %and6, 0
  br i1 %tobool7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %lor.lhs.false, %if.then3
  %16 = load ptr, ptr %errp.addr, align 8
  %17 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %16, ptr noundef %17)
  br label %if.end10

if.else9:                                         ; preds = %lor.lhs.false
  %18 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %18)
  store i32 0, ptr %ret, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.else9, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %do.end
  %19 = load i32, ptr %ret, align 4
  ret i32 %19
}

declare ptr @tran_new() #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_set_perm(ptr noundef %c, i64 noundef %perm, i64 noundef %shared, ptr noundef %tran) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %perm.addr = alloca i64, align 8
  %shared.addr = alloca i64, align 8
  %tran.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %.compoundliteral = alloca %struct.BdrvChildSetPermState, align 8
  store ptr %c, ptr %c.addr, align 8
  store i64 %perm, ptr %perm.addr, align 8
  store i64 %shared, ptr %shared.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  %call = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 24) #17
  store ptr %call, ptr %s, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2329, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_set_perm) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %s, align 8
  %child = getelementptr inbounds %struct.BdrvChildSetPermState, ptr %.compoundliteral, i32 0, i32 0
  %1 = load ptr, ptr %c.addr, align 8
  store ptr %1, ptr %child, align 8
  %old_perm = getelementptr inbounds %struct.BdrvChildSetPermState, ptr %.compoundliteral, i32 0, i32 1
  %2 = load ptr, ptr %c.addr, align 8
  %perm2 = getelementptr inbounds %struct.BdrvChild, ptr %2, i32 0, i32 5
  %3 = load i64, ptr %perm2, align 8
  store i64 %3, ptr %old_perm, align 8
  %old_shared_perm = getelementptr inbounds %struct.BdrvChildSetPermState, ptr %.compoundliteral, i32 0, i32 2
  %4 = load ptr, ptr %c.addr, align 8
  %shared_perm = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 6
  %5 = load i64, ptr %shared_perm, align 8
  store i64 %5, ptr %old_shared_perm, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %.compoundliteral, i64 24, i1 false)
  %6 = load i64, ptr %perm.addr, align 8
  %7 = load ptr, ptr %c.addr, align 8
  %perm3 = getelementptr inbounds %struct.BdrvChild, ptr %7, i32 0, i32 5
  store i64 %6, ptr %perm3, align 8
  %8 = load i64, ptr %shared.addr, align 8
  %9 = load ptr, ptr %c.addr, align 8
  %shared_perm4 = getelementptr inbounds %struct.BdrvChild, ptr %9, i32 0, i32 6
  store i64 %8, ptr %shared_perm4, align 8
  %10 = load ptr, ptr %tran.addr, align 8
  %11 = load ptr, ptr %s, align 8
  call void @tran_add(ptr noundef %10, ptr noundef @bdrv_child_set_pem_drv, ptr noundef %11)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_refresh_perms(ptr noundef %bs, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %local_tran = alloca ptr, align 8
  %list = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %local_tran, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_topological_dfs(ptr noundef null, ptr noundef null, ptr noundef %0)
  store ptr %call, ptr %list, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2672, ptr noundef @__PRETTY_FUNCTION__.bdrv_refresh_perms) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  %1 = load ptr, ptr %tran.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end4, label %if.then2

if.then2:                                         ; preds = %do.end
  %call3 = call ptr @tran_new()
  store ptr %call3, ptr %local_tran, align 8
  store ptr %call3, ptr %tran.addr, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %do.end
  %2 = load ptr, ptr %list, align 8
  %3 = load ptr, ptr %tran.addr, align 8
  %4 = load ptr, ptr %errp.addr, align 8
  %call5 = call i32 @bdrv_do_refresh_perms(ptr noundef %2, ptr noundef null, ptr noundef %3, ptr noundef %4)
  store i32 %call5, ptr %ret, align 4
  %5 = load ptr, ptr %local_tran, align 8
  %tobool6 = icmp ne ptr %5, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %6 = load ptr, ptr %local_tran, align 8
  %7 = load i32, ptr %ret, align 4
  call void @tran_finalize(ptr noundef %6, i32 noundef %7)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.end4
  %8 = load i32, ptr %ret, align 4
  call void @glib_autoptr_cleanup_GSList(ptr noundef %list)
  ret i32 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @tran_finalize(ptr noundef %tran, i32 noundef %ret) #0 {
entry:
  %tran.addr = alloca ptr, align 8
  %ret.addr = alloca i32, align 4
  store ptr %tran, ptr %tran.addr, align 8
  store i32 %ret, ptr %ret.addr, align 4
  %0 = load i32, ptr %ret.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %tran.addr, align 8
  call void @tran_abort(ptr noundef %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load ptr, ptr %tran.addr, align 8
  call void @tran_commit(ptr noundef %2)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_child_refresh_perms(ptr noundef %bs, ptr noundef %c, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %parent_perms = alloca i64, align 8
  %parent_shared = alloca i64, align 8
  %perms = alloca i64, align 8
  %shared = alloca i64, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2726, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_refresh_perms) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_get_cumulative_perm(ptr noundef %0, ptr noundef %parent_perms, ptr noundef %parent_shared)
  %1 = load ptr, ptr %bs.addr, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %bs1 = getelementptr inbounds %struct.BdrvChild, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %bs1, align 8
  %4 = load ptr, ptr %c.addr, align 8
  %5 = load ptr, ptr %c.addr, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 3
  %6 = load i32, ptr %role, align 8
  %7 = load i64, ptr %parent_perms, align 8
  %8 = load i64, ptr %parent_shared, align 8
  call void @bdrv_child_perm(ptr noundef %1, ptr noundef %3, ptr noundef %4, i32 noundef %6, ptr noundef null, i64 noundef %7, i64 noundef %8, ptr noundef %perms, ptr noundef %shared)
  %9 = load ptr, ptr %c.addr, align 8
  %10 = load i64, ptr %perms, align 8
  %11 = load i64, ptr %shared, align 8
  %12 = load ptr, ptr %errp.addr, align 8
  %call2 = call i32 @bdrv_child_try_set_perm(ptr noundef %9, i64 noundef %10, i64 noundef %11, ptr noundef %12)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_perm(ptr noundef %bs, ptr noundef %child_bs, ptr noundef %c, i32 noundef %role, ptr noundef %reopen_queue, i64 noundef %parent_perm, i64 noundef %parent_shared, ptr noundef %nperm, ptr noundef %nshared) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %child_bs.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %role.addr = alloca i32, align 4
  %reopen_queue.addr = alloca ptr, align 8
  %parent_perm.addr = alloca i64, align 8
  %parent_shared.addr = alloca i64, align 8
  %nperm.addr = alloca ptr, align 8
  %nshared.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %child_bs, ptr %child_bs.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store i32 %role, ptr %role.addr, align 4
  store ptr %reopen_queue, ptr %reopen_queue.addr, align 8
  store i64 %parent_perm, ptr %parent_perm.addr, align 8
  store i64 %parent_shared, ptr %parent_shared.addr, align 8
  store ptr %nperm, ptr %nperm.addr, align 8
  store ptr %nshared, ptr %nshared.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv1, align 8
  %bdrv_child_perm = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 58
  %4 = load ptr, ptr %bdrv_child_perm, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  call void @__assert_fail(ptr noundef @.str.196, ptr noundef @.str.2, i32 noundef 2257, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_perm) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then3, label %if.else4

if.then3:                                         ; preds = %do.body
  br label %if.end5

if.else4:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2258, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_perm) #16
  unreachable

if.end5:                                          ; preds = %if.then3
  br label %do.end

do.end:                                           ; preds = %if.end5
  %5 = load ptr, ptr %bs.addr, align 8
  %drv6 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %drv6, align 8
  %bdrv_child_perm7 = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 58
  %7 = load ptr, ptr %bdrv_child_perm7, align 8
  %8 = load ptr, ptr %bs.addr, align 8
  %9 = load ptr, ptr %c.addr, align 8
  %10 = load i32, ptr %role.addr, align 4
  %11 = load ptr, ptr %reopen_queue.addr, align 8
  %12 = load i64, ptr %parent_perm.addr, align 8
  %13 = load i64, ptr %parent_shared.addr, align 8
  %14 = load ptr, ptr %nperm.addr, align 8
  %15 = load ptr, ptr %nshared.addr, align 8
  call void %7(ptr noundef %8, ptr noundef %9, i32 noundef %10, ptr noundef %11, i64 noundef %12, i64 noundef %13, ptr noundef %14, ptr noundef %15)
  %16 = load ptr, ptr %child_bs.addr, align 8
  %tobool8 = icmp ne ptr %16, null
  br i1 %tobool8, label %land.lhs.true9, label %if.end12

land.lhs.true9:                                   ; preds = %do.end
  %17 = load ptr, ptr %child_bs.addr, align 8
  %force_share = getelementptr inbounds %struct.BlockDriverState, ptr %17, i32 0, i32 4
  %18 = load i8, ptr %force_share, align 1
  %tobool10 = trunc i8 %18 to i1
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %land.lhs.true9
  %19 = load ptr, ptr %nshared.addr, align 8
  store i64 15, ptr %19, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %land.lhs.true9, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_default_perms(ptr noundef %bs, ptr noundef %c, i32 noundef %role, ptr noundef %reopen_queue, i64 noundef %perm, i64 noundef %shared, ptr noundef %nperm, ptr noundef %nshared) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %role.addr = alloca i32, align 4
  %reopen_queue.addr = alloca ptr, align 8
  %perm.addr = alloca i64, align 8
  %shared.addr = alloca i64, align 8
  %nperm.addr = alloca ptr, align 8
  %nshared.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store i32 %role, ptr %role.addr, align 4
  store ptr %reopen_queue, ptr %reopen_queue.addr, align 8
  store i64 %perm, ptr %perm.addr, align 8
  store i64 %shared, ptr %shared.addr, align 8
  store ptr %nperm, ptr %nperm.addr, align 8
  store ptr %nshared, ptr %nshared.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2872, ptr noundef @__PRETTY_FUNCTION__.bdrv_default_perms) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load i32, ptr %role.addr, align 4
  %and = and i32 %0, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then1, label %if.else7

if.then1:                                         ; preds = %do.end
  %1 = load i32, ptr %role.addr, align 4
  %and2 = and i32 %1, 11
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.else5, label %if.then4

if.then4:                                         ; preds = %if.then1
  br label %if.end6

if.else5:                                         ; preds = %if.then1
  call void @__assert_fail(ptr noundef @.str.71, ptr noundef @.str.2, i32 noundef 2875, ptr noundef @__PRETTY_FUNCTION__.bdrv_default_perms) #16
  unreachable

if.end6:                                          ; preds = %if.then4
  %2 = load ptr, ptr %bs.addr, align 8
  %3 = load ptr, ptr %c.addr, align 8
  %4 = load i32, ptr %role.addr, align 4
  %5 = load ptr, ptr %reopen_queue.addr, align 8
  %6 = load i64, ptr %perm.addr, align 8
  %7 = load i64, ptr %shared.addr, align 8
  %8 = load ptr, ptr %nperm.addr, align 8
  %9 = load ptr, ptr %nshared.addr, align 8
  call void @bdrv_filter_default_perms(ptr noundef %2, ptr noundef %3, i32 noundef %4, ptr noundef %5, i64 noundef %6, i64 noundef %7, ptr noundef %8, ptr noundef %9)
  br label %if.end25

if.else7:                                         ; preds = %do.end
  %10 = load i32, ptr %role.addr, align 4
  %and8 = and i32 %10, 8
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then10, label %if.else16

if.then10:                                        ; preds = %if.else7
  %11 = load i32, ptr %role.addr, align 4
  %and11 = and i32 %11, 3
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.else14, label %if.then13

if.then13:                                        ; preds = %if.then10
  br label %if.end15

if.else14:                                        ; preds = %if.then10
  call void @__assert_fail(ptr noundef @.str.72, ptr noundef @.str.2, i32 noundef 2879, ptr noundef @__PRETTY_FUNCTION__.bdrv_default_perms) #16
  unreachable

if.end15:                                         ; preds = %if.then13
  %12 = load ptr, ptr %bs.addr, align 8
  %13 = load ptr, ptr %c.addr, align 8
  %14 = load i32, ptr %role.addr, align 4
  %15 = load ptr, ptr %reopen_queue.addr, align 8
  %16 = load i64, ptr %perm.addr, align 8
  %17 = load i64, ptr %shared.addr, align 8
  %18 = load ptr, ptr %nperm.addr, align 8
  %19 = load ptr, ptr %nshared.addr, align 8
  call void @bdrv_default_perms_for_cow(ptr noundef %12, ptr noundef %13, i32 noundef %14, ptr noundef %15, i64 noundef %16, i64 noundef %17, ptr noundef %18, ptr noundef %19)
  br label %if.end24

if.else16:                                        ; preds = %if.else7
  %20 = load i32, ptr %role.addr, align 4
  %and17 = and i32 %20, 3
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then19, label %if.else20

if.then19:                                        ; preds = %if.else16
  %21 = load ptr, ptr %bs.addr, align 8
  %22 = load ptr, ptr %c.addr, align 8
  %23 = load i32, ptr %role.addr, align 4
  %24 = load ptr, ptr %reopen_queue.addr, align 8
  %25 = load i64, ptr %perm.addr, align 8
  %26 = load i64, ptr %shared.addr, align 8
  %27 = load ptr, ptr %nperm.addr, align 8
  %28 = load ptr, ptr %nshared.addr, align 8
  call void @bdrv_default_perms_for_storage(ptr noundef %21, ptr noundef %22, i32 noundef %23, ptr noundef %24, i64 noundef %25, i64 noundef %26, ptr noundef %27, ptr noundef %28)
  br label %if.end23

if.else20:                                        ; preds = %if.else16
  br label %do.body21

do.body21:                                        ; preds = %if.else20
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.2, i32 noundef 2886, ptr noundef @__func__.bdrv_default_perms, ptr noundef null) #18
  unreachable

do.end22:                                         ; No predecessors!
  br label %if.end23

if.end23:                                         ; preds = %do.end22, %if.then19
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.end15
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.end6
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_filter_default_perms(ptr noundef %bs, ptr noundef %c, i32 noundef %role, ptr noundef %reopen_queue, i64 noundef %perm, i64 noundef %shared, ptr noundef %nperm, ptr noundef %nshared) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %role.addr = alloca i32, align 4
  %reopen_queue.addr = alloca ptr, align 8
  %perm.addr = alloca i64, align 8
  %shared.addr = alloca i64, align 8
  %nperm.addr = alloca ptr, align 8
  %nshared.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store i32 %role, ptr %role.addr, align 4
  store ptr %reopen_queue, ptr %reopen_queue.addr, align 8
  store i64 %perm, ptr %perm.addr, align 8
  store i64 %shared, ptr %shared.addr, align 8
  store ptr %nperm, ptr %nperm.addr, align 8
  store ptr %nshared, ptr %nshared.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2746, ptr noundef @__PRETTY_FUNCTION__.bdrv_filter_default_perms) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load i64, ptr %perm.addr, align 8
  %and = and i64 %0, 15
  %1 = load ptr, ptr %nperm.addr, align 8
  store i64 %and, ptr %1, align 8
  %2 = load i64, ptr %shared.addr, align 8
  %and1 = and i64 %2, 15
  %or = or i64 %and1, 0
  %3 = load ptr, ptr %nshared.addr, align 8
  store i64 %or, ptr %3, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_default_perms_for_cow(ptr noundef %bs, ptr noundef %c, i32 noundef %role, ptr noundef %reopen_queue, i64 noundef %perm, i64 noundef %shared, ptr noundef %nperm, ptr noundef %nshared) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %role.addr = alloca i32, align 4
  %reopen_queue.addr = alloca ptr, align 8
  %perm.addr = alloca i64, align 8
  %shared.addr = alloca i64, align 8
  %nperm.addr = alloca ptr, align 8
  %nshared.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store i32 %role, ptr %role.addr, align 4
  store ptr %reopen_queue, ptr %reopen_queue.addr, align 8
  store i64 %perm, ptr %perm.addr, align 8
  store i64 %shared, ptr %shared.addr, align 8
  store ptr %nperm, ptr %nperm.addr, align 8
  store ptr %nshared, ptr %nshared.addr, align 8
  %0 = load i32, ptr %role.addr, align 4
  %and = and i32 %0, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.197, ptr noundef @.str.2, i32 noundef 2757, ptr noundef @__PRETTY_FUNCTION__.bdrv_default_perms_for_cow) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.body
  br label %if.end3

if.else2:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2758, ptr noundef @__PRETTY_FUNCTION__.bdrv_default_perms_for_cow) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  br label %do.end

do.end:                                           ; preds = %if.end3
  %1 = load i64, ptr %perm.addr, align 8
  %and4 = and i64 %1, 1
  store i64 %and4, ptr %perm.addr, align 8
  %2 = load i64, ptr %shared.addr, align 8
  %and5 = and i64 %2, 2
  %tobool6 = icmp ne i64 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.else8

if.then7:                                         ; preds = %do.end
  store i64 10, ptr %shared.addr, align 8
  br label %if.end9

if.else8:                                         ; preds = %do.end
  store i64 0, ptr %shared.addr, align 8
  br label %if.end9

if.end9:                                          ; preds = %if.else8, %if.then7
  %3 = load i64, ptr %shared.addr, align 8
  %or = or i64 %3, 5
  store i64 %or, ptr %shared.addr, align 8
  %4 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %open_flags, align 8
  %and10 = and i32 %5, 2048
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end9
  %6 = load i64, ptr %shared.addr, align 8
  %or13 = or i64 %6, 10
  store i64 %or13, ptr %shared.addr, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end9
  %7 = load i64, ptr %perm.addr, align 8
  %8 = load ptr, ptr %nperm.addr, align 8
  store i64 %7, ptr %8, align 8
  %9 = load i64, ptr %shared.addr, align 8
  %10 = load ptr, ptr %nshared.addr, align 8
  store i64 %9, ptr %10, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_default_perms_for_storage(ptr noundef %bs, ptr noundef %c, i32 noundef %role, ptr noundef %reopen_queue, i64 noundef %perm, i64 noundef %shared, ptr noundef %nperm, ptr noundef %nshared) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %c.addr = alloca ptr, align 8
  %role.addr = alloca i32, align 4
  %reopen_queue.addr = alloca ptr, align 8
  %perm.addr = alloca i64, align 8
  %shared.addr = alloca i64, align 8
  %nperm.addr = alloca ptr, align 8
  %nshared.addr = alloca ptr, align 8
  %flags = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %c, ptr %c.addr, align 8
  store i32 %role, ptr %role.addr, align 4
  store ptr %reopen_queue, ptr %reopen_queue.addr, align 8
  store i64 %perm, ptr %perm.addr, align 8
  store i64 %shared, ptr %shared.addr, align 8
  store ptr %nperm, ptr %nperm.addr, align 8
  store ptr %nshared, ptr %nshared.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2795, ptr noundef @__PRETTY_FUNCTION__.bdrv_default_perms_for_storage) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load i32, ptr %role.addr, align 4
  %and = and i32 %0, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.end
  br label %if.end3

if.else2:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.198, ptr noundef @.str.2, i32 noundef 2796, ptr noundef @__PRETTY_FUNCTION__.bdrv_default_perms_for_storage) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  %1 = load ptr, ptr %reopen_queue.addr, align 8
  %2 = load ptr, ptr %bs.addr, align 8
  %call4 = call i32 @bdrv_reopen_get_flags(ptr noundef %1, ptr noundef %2)
  store i32 %call4, ptr %flags, align 4
  %3 = load ptr, ptr %bs.addr, align 8
  %4 = load ptr, ptr %c.addr, align 8
  %5 = load i32, ptr %role.addr, align 4
  %6 = load ptr, ptr %reopen_queue.addr, align 8
  %7 = load i64, ptr %perm.addr, align 8
  %8 = load i64, ptr %shared.addr, align 8
  call void @bdrv_filter_default_perms(ptr noundef %3, ptr noundef %4, i32 noundef %5, ptr noundef %6, i64 noundef %7, i64 noundef %8, ptr noundef %perm.addr, ptr noundef %shared.addr)
  %9 = load i32, ptr %role.addr, align 4
  %and5 = and i32 %9, 2
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end17

if.then7:                                         ; preds = %if.end3
  %10 = load ptr, ptr %bs.addr, align 8
  %11 = load ptr, ptr %reopen_queue.addr, align 8
  %call8 = call zeroext i1 @bdrv_is_writable_after_reopen(ptr noundef %10, ptr noundef %11)
  br i1 %call8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.then7
  %12 = load i64, ptr %perm.addr, align 8
  %or = or i64 %12, 10
  store i64 %or, ptr %perm.addr, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.then7
  %13 = load i32, ptr %flags, align 4
  %and11 = and i32 %13, 65536
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.end15, label %if.then13

if.then13:                                        ; preds = %if.end10
  %14 = load i64, ptr %perm.addr, align 8
  %or14 = or i64 %14, 1
  store i64 %or14, ptr %perm.addr, align 8
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end10
  %15 = load i64, ptr %shared.addr, align 8
  %and16 = and i64 %15, -11
  store i64 %and16, ptr %shared.addr, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.end15, %if.end3
  %16 = load i32, ptr %role.addr, align 4
  %and18 = and i32 %16, 1
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %if.then20, label %if.end32

if.then20:                                        ; preds = %if.end17
  %17 = load i64, ptr %shared.addr, align 8
  %and21 = and i64 %17, -9
  store i64 %and21, ptr %shared.addr, align 8
  %18 = load i64, ptr %perm.addr, align 8
  %and22 = and i64 %18, 4
  %tobool23 = icmp ne i64 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.then20
  %19 = load i64, ptr %perm.addr, align 8
  %or25 = or i64 %19, 2
  store i64 %or25, ptr %perm.addr, align 8
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.then20
  %20 = load i64, ptr %perm.addr, align 8
  %and27 = and i64 %20, 2
  %tobool28 = icmp ne i64 %and27, 0
  br i1 %tobool28, label %if.then29, label %if.end31

if.then29:                                        ; preds = %if.end26
  %21 = load i64, ptr %perm.addr, align 8
  %or30 = or i64 %21, 8
  store i64 %or30, ptr %perm.addr, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then29, %if.end26
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.end17
  %22 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %22, i32 0, i32 0
  %23 = load i32, ptr %open_flags, align 8
  %and33 = and i32 %23, 2048
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %if.then35, label %if.end37

if.then35:                                        ; preds = %if.end32
  %24 = load i64, ptr %shared.addr, align 8
  %or36 = or i64 %24, 10
  store i64 %or36, ptr %shared.addr, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then35, %if.end32
  %25 = load i64, ptr %perm.addr, align 8
  %26 = load ptr, ptr %nperm.addr, align 8
  store i64 %25, ptr %26, align 8
  %27 = load i64, ptr %shared.addr, align 8
  %28 = load ptr, ptr %nshared.addr, align 8
  store i64 %27, ptr %28, align 8
  ret void
}

; Function Attrs: noreturn
declare void @g_assertion_message_expr(ptr noundef, ptr noundef, i32 noundef, ptr noundef, ptr noundef) #10

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_qapi_perm_to_blk_perm(i32 noundef %qapi_perm) #0 {
entry:
  %qapi_perm.addr = alloca i32, align 4
  store i32 %qapi_perm, ptr %qapi_perm.addr, align 4
  %0 = load i32, ptr %qapi_perm.addr, align 4
  %cmp = icmp ult i32 %0, 4
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.73, ptr noundef @.str.2, i32 noundef 2902, ptr noundef @__PRETTY_FUNCTION__.bdrv_qapi_perm_to_blk_perm) #16
  unreachable

if.end:                                           ; preds = %if.then
  %1 = load i32, ptr %qapi_perm.addr, align 4
  %idxprom = zext i32 %1 to i64
  %arrayidx = getelementptr [4 x i64], ptr @bdrv_qapi_perm_to_blk_perm.permissions, i64 0, i64 %idxprom
  %2 = load i64, ptr %arrayidx, align 8
  ret i64 %2
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_root_attach_child(ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, i64 noundef %perm, i64 noundef %shared_perm, ptr noundef %opaque, ptr noundef %errp) #0 {
entry:
  %child_bs.addr = alloca ptr, align 8
  %child_name.addr = alloca ptr, align 8
  %child_class.addr = alloca ptr, align 8
  %child_role.addr = alloca i32, align 4
  %perm.addr = alloca i64, align 8
  %shared_perm.addr = alloca i64, align 8
  %opaque.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %child = alloca ptr, align 8
  %tran = alloca ptr, align 8
  store ptr %child_bs, ptr %child_bs.addr, align 8
  store ptr %child_name, ptr %child_name.addr, align 8
  store ptr %child_class, ptr %child_class.addr, align 8
  store i32 %child_role, ptr %child_role.addr, align 4
  store i64 %perm, ptr %perm.addr, align 8
  store i64 %shared_perm, ptr %shared_perm.addr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %call = call ptr @tran_new()
  store ptr %call, ptr %tran, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3220, ptr noundef @__PRETTY_FUNCTION__.bdrv_root_attach_child) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %child_bs.addr, align 8
  %1 = load ptr, ptr %child_name.addr, align 8
  %2 = load ptr, ptr %child_class.addr, align 8
  %3 = load i32, ptr %child_role.addr, align 4
  %4 = load i64, ptr %perm.addr, align 8
  %5 = load i64, ptr %shared_perm.addr, align 8
  %6 = load ptr, ptr %opaque.addr, align 8
  %7 = load ptr, ptr %tran, align 8
  %8 = load ptr, ptr %errp.addr, align 8
  %call2 = call ptr @bdrv_attach_child_common(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3, i64 noundef %4, i64 noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8)
  store ptr %call2, ptr %child, align 8
  %9 = load ptr, ptr %child, align 8
  %tobool = icmp ne ptr %9, null
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %do.end
  store i32 -22, ptr %ret, align 4
  br label %out

if.end4:                                          ; preds = %do.end
  %10 = load ptr, ptr %child_bs.addr, align 8
  %11 = load ptr, ptr %tran, align 8
  %12 = load ptr, ptr %errp.addr, align 8
  %call5 = call i32 @bdrv_refresh_perms(ptr noundef %10, ptr noundef %11, ptr noundef %12)
  store i32 %call5, ptr %ret, align 4
  br label %out

out:                                              ; preds = %if.end4, %if.then3
  %13 = load ptr, ptr %tran, align 8
  %14 = load i32, ptr %ret, align 4
  call void @tran_finalize(ptr noundef %13, i32 noundef %14)
  %15 = load ptr, ptr %child_bs.addr, align 8
  call void @bdrv_schedule_unref(ptr noundef %15)
  %16 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %16, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %out
  br label %cond.end

cond.false:                                       ; preds = %out
  %17 = load ptr, ptr %child, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %17, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_attach_child_common(ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, i64 noundef %perm, i64 noundef %shared_perm, ptr noundef %opaque, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %child_bs.addr = alloca ptr, align 8
  %child_name.addr = alloca ptr, align 8
  %child_class.addr = alloca ptr, align 8
  %child_role.addr = alloca i32, align 4
  %perm.addr = alloca i64, align 8
  %shared_perm.addr = alloca i64, align 8
  %opaque.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %new_child = alloca ptr, align 8
  %parent_ctx = alloca ptr, align 8
  %new_child_ctx = alloca ptr, align 8
  %child_ctx = alloca ptr, align 8
  %.compoundliteral = alloca %struct.BdrvChild, align 8
  %local_err = alloca ptr, align 8
  %ret = alloca i32, align 4
  %aio_ctx_tran = alloca ptr, align 8
  %visited = alloca ptr, align 8
  %ret_child = alloca i8, align 1
  %s = alloca ptr, align 8
  %.compoundliteral42 = alloca %struct.BdrvAttachChildCommonState, align 8
  store ptr %child_bs, ptr %child_bs.addr, align 8
  store ptr %child_name, ptr %child_name.addr, align 8
  store ptr %child_class, ptr %child_class.addr, align 8
  store i32 %child_role, ptr %child_role.addr, align 4
  store i64 %perm, ptr %perm.addr, align 8
  store i64 %shared_perm, ptr %shared_perm.addr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %child_bs.addr, align 8
  %call = call ptr @bdrv_get_aio_context(ptr noundef %0)
  store ptr %call, ptr %child_ctx, align 8
  %1 = load ptr, ptr %child_class.addr, align 8
  %get_parent_desc = getelementptr inbounds %struct.BdrvChildClass, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %get_parent_desc, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.199, ptr noundef @.str.2, i32 noundef 3068, ptr noundef @__PRETTY_FUNCTION__.bdrv_attach_child_common) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %do.body
  br label %if.end4

if.else3:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3069, ptr noundef @__PRETTY_FUNCTION__.bdrv_attach_child_common) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  br label %do.end

do.end:                                           ; preds = %if.end4
  %call5 = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 96) #17
  store ptr %call5, ptr %new_child, align 8
  %3 = load ptr, ptr %new_child, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 0
  store ptr null, ptr %bs, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 1
  %4 = load ptr, ptr %child_name.addr, align 8
  %call6 = call noalias ptr @g_strdup(ptr noundef %4)
  store ptr %call6, ptr %name, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 2
  %5 = load ptr, ptr %child_class.addr, align 8
  store ptr %5, ptr %klass, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 3
  %6 = load i32, ptr %child_role.addr, align 4
  store i32 %6, ptr %role, align 8
  %opaque7 = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 4
  %7 = load ptr, ptr %opaque.addr, align 8
  store ptr %7, ptr %opaque7, align 8
  %perm8 = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 5
  %8 = load i64, ptr %perm.addr, align 8
  store i64 %8, ptr %perm8, align 8
  %shared_perm9 = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 6
  %9 = load i64, ptr %shared_perm.addr, align 8
  store i64 %9, ptr %shared_perm9, align 8
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 7
  store i8 0, ptr %frozen, align 8
  %quiesced_parent = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 8
  store i8 0, ptr %quiesced_parent, align 1
  %next = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 9
  call void @llvm.memset.p0.i64(ptr align 8 %next, i8 0, i64 16, i1 false)
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %.compoundliteral, i32 0, i32 10
  call void @llvm.memset.p0.i64(ptr align 8 %next_parent, i8 0, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %3, ptr align 8 %.compoundliteral, i64 96, i1 false)
  %10 = load ptr, ptr %new_child, align 8
  %call10 = call ptr @bdrv_child_get_parent_aio_context(ptr noundef %10)
  store ptr %call10, ptr %parent_ctx, align 8
  %11 = load ptr, ptr %child_ctx, align 8
  %12 = load ptr, ptr %parent_ctx, align 8
  %cmp = icmp ne ptr %11, %12
  br i1 %cmp, label %if.then11, label %if.end35

if.then11:                                        ; preds = %do.end
  store ptr null, ptr %local_err, align 8
  %13 = load ptr, ptr %child_bs.addr, align 8
  %14 = load ptr, ptr %parent_ctx, align 8
  %call12 = call i32 @bdrv_try_change_aio_context(ptr noundef %13, ptr noundef %14, ptr noundef null, ptr noundef %local_err)
  store i32 %call12, ptr %ret, align 4
  %15 = load i32, ptr %ret, align 4
  %cmp13 = icmp slt i32 %15, 0
  br i1 %cmp13, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.then11
  %16 = load ptr, ptr %child_class.addr, align 8
  %change_aio_ctx = getelementptr inbounds %struct.BdrvChildClass, ptr %16, i32 0, i32 13
  %17 = load ptr, ptr %change_aio_ctx, align 8
  %tobool14 = icmp ne ptr %17, null
  br i1 %tobool14, label %if.then15, label %if.end30

if.then15:                                        ; preds = %land.lhs.true
  %call16 = call ptr @tran_new()
  store ptr %call16, ptr %aio_ctx_tran, align 8
  %call17 = call ptr @g_hash_table_new(ptr noundef null, ptr noundef null)
  store ptr %call17, ptr %visited, align 8
  %18 = load ptr, ptr %visited, align 8
  %19 = load ptr, ptr %new_child, align 8
  %call18 = call i32 @g_hash_table_add(ptr noundef %18, ptr noundef %19)
  %20 = load ptr, ptr %child_class.addr, align 8
  %change_aio_ctx19 = getelementptr inbounds %struct.BdrvChildClass, ptr %20, i32 0, i32 13
  %21 = load ptr, ptr %change_aio_ctx19, align 8
  %22 = load ptr, ptr %new_child, align 8
  %23 = load ptr, ptr %child_ctx, align 8
  %24 = load ptr, ptr %visited, align 8
  %25 = load ptr, ptr %aio_ctx_tran, align 8
  %call20 = call zeroext i1 %21(ptr noundef %22, ptr noundef %23, ptr noundef %24, ptr noundef %25, ptr noundef null)
  %frombool = zext i1 %call20 to i8
  store i8 %frombool, ptr %ret_child, align 1
  %26 = load i8, ptr %ret_child, align 1
  %tobool21 = trunc i8 %26 to i1
  %conv = zext i1 %tobool21 to i32
  %cmp22 = icmp eq i32 %conv, 1
  br i1 %cmp22, label %if.then24, label %if.end25

if.then24:                                        ; preds = %if.then15
  %27 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %27)
  store i32 0, ptr %ret, align 4
  br label %if.end25

if.end25:                                         ; preds = %if.then24, %if.then15
  %28 = load ptr, ptr %aio_ctx_tran, align 8
  %29 = load i8, ptr %ret_child, align 1
  %tobool26 = trunc i8 %29 to i1
  %conv27 = zext i1 %tobool26 to i32
  %cmp28 = icmp eq i32 %conv27, 1
  %cond = select i1 %cmp28, i32 0, i32 -1
  call void @tran_finalize(ptr noundef %28, i32 noundef %cond)
  %30 = load ptr, ptr %visited, align 8
  call void @g_hash_table_destroy(ptr noundef %30)
  br label %if.end30

if.end30:                                         ; preds = %if.end25, %land.lhs.true, %if.then11
  %31 = load i32, ptr %ret, align 4
  %cmp31 = icmp slt i32 %31, 0
  br i1 %cmp31, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end30
  %32 = load ptr, ptr %errp.addr, align 8
  %33 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %32, ptr noundef %33)
  %34 = load ptr, ptr %new_child, align 8
  call void @bdrv_child_free(ptr noundef %34)
  store ptr null, ptr %retval, align 8
  br label %return

if.end34:                                         ; preds = %if.end30
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %do.end
  %35 = load ptr, ptr %child_bs.addr, align 8
  %call36 = call ptr @bdrv_get_aio_context(ptr noundef %35)
  store ptr %call36, ptr %new_child_ctx, align 8
  %36 = load ptr, ptr %new_child_ctx, align 8
  %37 = load ptr, ptr %child_ctx, align 8
  %cmp37 = icmp ne ptr %36, %37
  br i1 %cmp37, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end35
  %38 = load ptr, ptr %child_ctx, align 8
  call void @aio_context_release(ptr noundef %38)
  %39 = load ptr, ptr %new_child_ctx, align 8
  call void @aio_context_acquire(ptr noundef %39)
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %if.end35
  %40 = load ptr, ptr %child_bs.addr, align 8
  call void @bdrv_ref(ptr noundef %40)
  %41 = load ptr, ptr %new_child, align 8
  call void @bdrv_parent_drained_begin_single(ptr noundef %41)
  %42 = load ptr, ptr %new_child, align 8
  %43 = load ptr, ptr %child_bs.addr, align 8
  call void @bdrv_replace_child_noperm(ptr noundef %42, ptr noundef %43)
  %call41 = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 24) #17
  store ptr %call41, ptr %s, align 8
  %44 = load ptr, ptr %s, align 8
  %child = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %.compoundliteral42, i32 0, i32 0
  %45 = load ptr, ptr %new_child, align 8
  store ptr %45, ptr %child, align 8
  %old_parent_ctx = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %.compoundliteral42, i32 0, i32 1
  %46 = load ptr, ptr %parent_ctx, align 8
  store ptr %46, ptr %old_parent_ctx, align 8
  %old_child_ctx = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %.compoundliteral42, i32 0, i32 2
  %47 = load ptr, ptr %child_ctx, align 8
  store ptr %47, ptr %old_child_ctx, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %44, ptr align 8 %.compoundliteral42, i64 24, i1 false)
  %48 = load ptr, ptr %tran.addr, align 8
  %49 = load ptr, ptr %s, align 8
  call void @tran_add(ptr noundef %48, ptr noundef @bdrv_attach_child_common_drv, ptr noundef %49)
  %50 = load ptr, ptr %new_child_ctx, align 8
  %51 = load ptr, ptr %child_ctx, align 8
  %cmp43 = icmp ne ptr %50, %51
  br i1 %cmp43, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.end40
  %52 = load ptr, ptr %new_child_ctx, align 8
  call void @aio_context_release(ptr noundef %52)
  %53 = load ptr, ptr %child_ctx, align 8
  call void @aio_context_acquire(ptr noundef %53)
  br label %if.end46

if.end46:                                         ; preds = %if.then45, %if.end40
  %54 = load ptr, ptr %new_child, align 8
  store ptr %54, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end46, %if.then33
  %55 = load ptr, ptr %retval, align 8
  ret ptr %55
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_schedule_unref(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %call = call ptr @qemu_get_aio_context()
  %1 = load ptr, ptr %bs.addr, align 8
  call void @aio_bh_schedule_oneshot_full(ptr noundef %call, ptr noundef @bdrv_schedule_unref_bh, ptr noundef %1, ptr noundef @.str.105)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_attach_child(ptr noundef %parent_bs, ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, ptr noundef %errp) #0 {
entry:
  %parent_bs.addr = alloca ptr, align 8
  %child_bs.addr = alloca ptr, align 8
  %child_name.addr = alloca ptr, align 8
  %child_class.addr = alloca ptr, align 8
  %child_role.addr = alloca i32, align 4
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %child = alloca ptr, align 8
  %tran = alloca ptr, align 8
  store ptr %parent_bs, ptr %parent_bs.addr, align 8
  store ptr %child_bs, ptr %child_bs.addr, align 8
  store ptr %child_name, ptr %child_name.addr, align 8
  store ptr %child_class, ptr %child_class.addr, align 8
  store i32 %child_role, ptr %child_role.addr, align 4
  store ptr %errp, ptr %errp.addr, align 8
  %call = call ptr @tran_new()
  store ptr %call, ptr %tran, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3262, ptr noundef @__PRETTY_FUNCTION__.bdrv_attach_child) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %parent_bs.addr, align 8
  %1 = load ptr, ptr %child_bs.addr, align 8
  %2 = load ptr, ptr %child_name.addr, align 8
  %3 = load ptr, ptr %child_class.addr, align 8
  %4 = load i32, ptr %child_role.addr, align 4
  %5 = load ptr, ptr %tran, align 8
  %6 = load ptr, ptr %errp.addr, align 8
  %call2 = call ptr @bdrv_attach_child_noperm(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, i32 noundef %4, ptr noundef %5, ptr noundef %6)
  store ptr %call2, ptr %child, align 8
  %7 = load ptr, ptr %child, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %if.end4, label %if.then3

if.then3:                                         ; preds = %do.end
  store i32 -22, ptr %ret, align 4
  br label %out

if.end4:                                          ; preds = %do.end
  %8 = load ptr, ptr %parent_bs.addr, align 8
  %9 = load ptr, ptr %tran, align 8
  %10 = load ptr, ptr %errp.addr, align 8
  %call5 = call i32 @bdrv_refresh_perms(ptr noundef %8, ptr noundef %9, ptr noundef %10)
  store i32 %call5, ptr %ret, align 4
  %11 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %11, 0
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end4
  br label %out

if.end7:                                          ; preds = %if.end4
  br label %out

out:                                              ; preds = %if.end7, %if.then6, %if.then3
  %12 = load ptr, ptr %tran, align 8
  %13 = load i32, ptr %ret, align 4
  call void @tran_finalize(ptr noundef %12, i32 noundef %13)
  %14 = load ptr, ptr %child_bs.addr, align 8
  call void @bdrv_schedule_unref(ptr noundef %14)
  %15 = load i32, ptr %ret, align 4
  %cmp8 = icmp slt i32 %15, 0
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %out
  br label %cond.end

cond.false:                                       ; preds = %out
  %16 = load ptr, ptr %child, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ null, %cond.true ], [ %16, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_attach_child_noperm(ptr noundef %parent_bs, ptr noundef %child_bs, ptr noundef %child_name, ptr noundef %child_class, i32 noundef %child_role, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %parent_bs.addr = alloca ptr, align 8
  %child_bs.addr = alloca ptr, align 8
  %child_name.addr = alloca ptr, align 8
  %child_class.addr = alloca ptr, align 8
  %child_role.addr = alloca i32, align 4
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %perm = alloca i64, align 8
  %shared_perm = alloca i64, align 8
  store ptr %parent_bs, ptr %parent_bs.addr, align 8
  store ptr %child_bs, ptr %child_bs.addr, align 8
  store ptr %child_name, ptr %child_name.addr, align 8
  store ptr %child_class, ptr %child_class.addr, align 8
  store i32 %child_role, ptr %child_role.addr, align 4
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %parent_bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.201, ptr noundef @.str.2, i32 noundef 3181, ptr noundef @__PRETTY_FUNCTION__.bdrv_attach_child_noperm) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.body
  br label %if.end3

if.else2:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3182, ptr noundef @__PRETTY_FUNCTION__.bdrv_attach_child_noperm) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  br label %do.end

do.end:                                           ; preds = %if.end3
  %2 = load ptr, ptr %child_bs.addr, align 8
  %3 = load ptr, ptr %parent_bs.addr, align 8
  %call4 = call zeroext i1 @bdrv_recurse_has_child(ptr noundef %2, ptr noundef %3)
  br i1 %call4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %do.end
  %4 = load ptr, ptr %errp.addr, align 8
  %5 = load ptr, ptr %child_bs.addr, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  %6 = load ptr, ptr %child_name.addr, align 8
  %7 = load ptr, ptr %parent_bs.addr, align 8
  %node_name6 = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 22
  %arraydecay7 = getelementptr inbounds [32 x i8], ptr %node_name6, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %4, ptr noundef @.str.2, i32 noundef 3186, ptr noundef @__func__.bdrv_attach_child_noperm, ptr noundef @.str.202, ptr noundef %arraydecay, ptr noundef %6, ptr noundef %arraydecay7)
  store ptr null, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %do.end
  %8 = load ptr, ptr %parent_bs.addr, align 8
  call void @bdrv_get_cumulative_perm(ptr noundef %8, ptr noundef %perm, ptr noundef %shared_perm)
  %9 = load ptr, ptr %parent_bs.addr, align 8
  %10 = load ptr, ptr %child_bs.addr, align 8
  %11 = load i32, ptr %child_role.addr, align 4
  %12 = load i64, ptr %perm, align 8
  %13 = load i64, ptr %shared_perm, align 8
  call void @bdrv_child_perm(ptr noundef %9, ptr noundef %10, ptr noundef null, i32 noundef %11, ptr noundef null, i64 noundef %12, i64 noundef %13, ptr noundef %perm, ptr noundef %shared_perm)
  %14 = load ptr, ptr %child_bs.addr, align 8
  %15 = load ptr, ptr %child_name.addr, align 8
  %16 = load ptr, ptr %child_class.addr, align 8
  %17 = load i32, ptr %child_role.addr, align 4
  %18 = load i64, ptr %perm, align 8
  %19 = load i64, ptr %shared_perm, align 8
  %20 = load ptr, ptr %parent_bs.addr, align 8
  %21 = load ptr, ptr %tran.addr, align 8
  %22 = load ptr, ptr %errp.addr, align 8
  %call9 = call ptr @bdrv_attach_child_common(ptr noundef %14, ptr noundef %15, ptr noundef %16, i32 noundef %17, i64 noundef %18, i64 noundef %19, ptr noundef %20, ptr noundef %21, ptr noundef %22)
  store ptr %call9, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end8, %if.then5
  %23 = load ptr, ptr %retval, align 8
  ret ptr %23
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_root_unref_child(ptr noundef %child) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %child_bs = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %bs, align 8
  store ptr %1, ptr %child_bs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3289, ptr noundef @__PRETTY_FUNCTION__.bdrv_root_unref_child) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %child.addr, align 8
  call void @bdrv_replace_child_noperm(ptr noundef %2, ptr noundef null)
  %3 = load ptr, ptr %child.addr, align 8
  call void @bdrv_child_free(ptr noundef %3)
  %4 = load ptr, ptr %child_bs, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then1, label %if.end5

if.then1:                                         ; preds = %do.end
  %5 = load ptr, ptr %child_bs, align 8
  %call2 = call i32 @bdrv_refresh_perms(ptr noundef %5, ptr noundef null, ptr noundef null)
  %6 = load ptr, ptr %child_bs, align 8
  %call3 = call ptr @qemu_get_aio_context()
  %call4 = call i32 @bdrv_try_change_aio_context(ptr noundef %6, ptr noundef %call3, ptr noundef null, ptr noundef null)
  br label %if.end5

if.end5:                                          ; preds = %if.then1, %do.end
  %7 = load ptr, ptr %child_bs, align 8
  call void @bdrv_schedule_unref(ptr noundef %7)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_replace_child_noperm(ptr noundef %child, ptr noundef %new_bs) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %new_bs.addr = alloca ptr, align 8
  %old_bs = alloca ptr, align 8
  %new_bs_quiesce_counter = alloca i32, align 4
  store ptr %child, ptr %child.addr, align 8
  store ptr %new_bs, ptr %new_bs.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %bs, align 8
  store ptr %1, ptr %old_bs, align 8
  %2 = load ptr, ptr %child.addr, align 8
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %2, i32 0, i32 7
  %3 = load i8, ptr %frozen, align 8
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.203, ptr noundef @.str.2, i32 noundef 2919, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_noperm) #16
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load ptr, ptr %new_bs.addr, align 8
  %tobool1 = icmp ne ptr %4, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %if.end
  %5 = load ptr, ptr %child.addr, align 8
  %quiesced_parent = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 8
  %6 = load i8, ptr %quiesced_parent, align 1
  %tobool2 = trunc i8 %6 to i1
  br i1 %tobool2, label %if.then3, label %if.else4

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  br label %if.end5

if.else4:                                         ; preds = %lor.lhs.false
  call void @__assert_fail(ptr noundef @.str.204, ptr noundef @.str.2, i32 noundef 2941, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_noperm) #16
  unreachable

if.end5:                                          ; preds = %if.then3
  %7 = load ptr, ptr %old_bs, align 8
  %8 = load ptr, ptr %new_bs.addr, align 8
  %cmp = icmp ne ptr %7, %8
  br i1 %cmp, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.end5
  br label %if.end8

if.else7:                                         ; preds = %if.end5
  call void @__assert_fail(ptr noundef @.str.205, ptr noundef @.str.2, i32 noundef 2942, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_noperm) #16
  unreachable

if.end8:                                          ; preds = %if.then6
  br label %do.body

do.body:                                          ; preds = %if.end8
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then9, label %if.else10

if.then9:                                         ; preds = %do.body
  br label %if.end11

if.else10:                                        ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2943, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_noperm) #16
  unreachable

if.end11:                                         ; preds = %if.then9
  br label %do.end

do.end:                                           ; preds = %if.end11
  %9 = load ptr, ptr %old_bs, align 8
  %tobool12 = icmp ne ptr %9, null
  br i1 %tobool12, label %land.lhs.true, label %if.end21

land.lhs.true:                                    ; preds = %do.end
  %10 = load ptr, ptr %new_bs.addr, align 8
  %tobool13 = icmp ne ptr %10, null
  br i1 %tobool13, label %if.then14, label %if.end21

if.then14:                                        ; preds = %land.lhs.true
  %11 = load ptr, ptr %old_bs, align 8
  %call15 = call ptr @bdrv_get_aio_context(ptr noundef %11)
  %12 = load ptr, ptr %new_bs.addr, align 8
  %call16 = call ptr @bdrv_get_aio_context(ptr noundef %12)
  %cmp17 = icmp eq ptr %call15, %call16
  br i1 %cmp17, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.then14
  br label %if.end20

if.else19:                                        ; preds = %if.then14
  call void @__assert_fail(ptr noundef @.str.206, ptr noundef @.str.2, i32 noundef 2946, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_noperm) #16
  unreachable

if.end20:                                         ; preds = %if.then18
  br label %if.end21

if.end21:                                         ; preds = %if.end20, %land.lhs.true, %do.end
  %13 = load ptr, ptr %old_bs, align 8
  %tobool22 = icmp ne ptr %13, null
  br i1 %tobool22, label %if.then23, label %if.end47

if.then23:                                        ; preds = %if.end21
  %14 = load ptr, ptr %child.addr, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %klass, align 8
  %detach = getelementptr inbounds %struct.BdrvChildClass, ptr %15, i32 0, i32 8
  %16 = load ptr, ptr %detach, align 8
  %tobool24 = icmp ne ptr %16, null
  br i1 %tobool24, label %if.then25, label %if.end28

if.then25:                                        ; preds = %if.then23
  %17 = load ptr, ptr %child.addr, align 8
  %klass26 = getelementptr inbounds %struct.BdrvChild, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %klass26, align 8
  %detach27 = getelementptr inbounds %struct.BdrvChildClass, ptr %18, i32 0, i32 8
  %19 = load ptr, ptr %detach27, align 8
  %20 = load ptr, ptr %child.addr, align 8
  call void %19(ptr noundef %20)
  br label %if.end28

if.end28:                                         ; preds = %if.then25, %if.then23
  br label %do.body29

do.body29:                                        ; preds = %if.end28
  %21 = load ptr, ptr %child.addr, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %21, i32 0, i32 10
  %le_next = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %22 = load ptr, ptr %le_next, align 8
  %cmp30 = icmp ne ptr %22, null
  br i1 %cmp30, label %if.then31, label %if.end37

if.then31:                                        ; preds = %do.body29
  %23 = load ptr, ptr %child.addr, align 8
  %next_parent32 = getelementptr inbounds %struct.BdrvChild, ptr %23, i32 0, i32 10
  %le_prev = getelementptr inbounds %struct.anon.15, ptr %next_parent32, i32 0, i32 1
  %24 = load ptr, ptr %le_prev, align 8
  %25 = load ptr, ptr %child.addr, align 8
  %next_parent33 = getelementptr inbounds %struct.BdrvChild, ptr %25, i32 0, i32 10
  %le_next34 = getelementptr inbounds %struct.anon.15, ptr %next_parent33, i32 0, i32 0
  %26 = load ptr, ptr %le_next34, align 8
  %next_parent35 = getelementptr inbounds %struct.BdrvChild, ptr %26, i32 0, i32 10
  %le_prev36 = getelementptr inbounds %struct.anon.15, ptr %next_parent35, i32 0, i32 1
  store ptr %24, ptr %le_prev36, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then31, %do.body29
  %27 = load ptr, ptr %child.addr, align 8
  %next_parent38 = getelementptr inbounds %struct.BdrvChild, ptr %27, i32 0, i32 10
  %le_next39 = getelementptr inbounds %struct.anon.15, ptr %next_parent38, i32 0, i32 0
  %28 = load ptr, ptr %le_next39, align 8
  %29 = load ptr, ptr %child.addr, align 8
  %next_parent40 = getelementptr inbounds %struct.BdrvChild, ptr %29, i32 0, i32 10
  %le_prev41 = getelementptr inbounds %struct.anon.15, ptr %next_parent40, i32 0, i32 1
  %30 = load ptr, ptr %le_prev41, align 8
  store ptr %28, ptr %30, align 8
  %31 = load ptr, ptr %child.addr, align 8
  %next_parent42 = getelementptr inbounds %struct.BdrvChild, ptr %31, i32 0, i32 10
  %le_next43 = getelementptr inbounds %struct.anon.15, ptr %next_parent42, i32 0, i32 0
  store ptr null, ptr %le_next43, align 8
  %32 = load ptr, ptr %child.addr, align 8
  %next_parent44 = getelementptr inbounds %struct.BdrvChild, ptr %32, i32 0, i32 10
  %le_prev45 = getelementptr inbounds %struct.anon.15, ptr %next_parent44, i32 0, i32 1
  store ptr null, ptr %le_prev45, align 8
  br label %do.end46

do.end46:                                         ; preds = %if.end37
  br label %if.end47

if.end47:                                         ; preds = %do.end46, %if.end21
  %33 = load ptr, ptr %new_bs.addr, align 8
  %34 = load ptr, ptr %child.addr, align 8
  %bs48 = getelementptr inbounds %struct.BdrvChild, ptr %34, i32 0, i32 0
  store ptr %33, ptr %bs48, align 8
  %35 = load ptr, ptr %new_bs.addr, align 8
  %tobool49 = icmp ne ptr %35, null
  br i1 %tobool49, label %if.then50, label %if.end76

if.then50:                                        ; preds = %if.end47
  br label %do.body51

do.body51:                                        ; preds = %if.then50
  %36 = load ptr, ptr %new_bs.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %36, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %37 = load ptr, ptr %lh_first, align 8
  %38 = load ptr, ptr %child.addr, align 8
  %next_parent52 = getelementptr inbounds %struct.BdrvChild, ptr %38, i32 0, i32 10
  %le_next53 = getelementptr inbounds %struct.anon.15, ptr %next_parent52, i32 0, i32 0
  store ptr %37, ptr %le_next53, align 8
  %cmp54 = icmp ne ptr %37, null
  br i1 %cmp54, label %if.then55, label %if.end62

if.then55:                                        ; preds = %do.body51
  %39 = load ptr, ptr %child.addr, align 8
  %next_parent56 = getelementptr inbounds %struct.BdrvChild, ptr %39, i32 0, i32 10
  %le_next57 = getelementptr inbounds %struct.anon.15, ptr %next_parent56, i32 0, i32 0
  %40 = load ptr, ptr %new_bs.addr, align 8
  %parents58 = getelementptr inbounds %struct.BlockDriverState, ptr %40, i32 0, i32 32
  %lh_first59 = getelementptr inbounds %struct.anon.4, ptr %parents58, i32 0, i32 0
  %41 = load ptr, ptr %lh_first59, align 8
  %next_parent60 = getelementptr inbounds %struct.BdrvChild, ptr %41, i32 0, i32 10
  %le_prev61 = getelementptr inbounds %struct.anon.15, ptr %next_parent60, i32 0, i32 1
  store ptr %le_next57, ptr %le_prev61, align 8
  br label %if.end62

if.end62:                                         ; preds = %if.then55, %do.body51
  %42 = load ptr, ptr %child.addr, align 8
  %43 = load ptr, ptr %new_bs.addr, align 8
  %parents63 = getelementptr inbounds %struct.BlockDriverState, ptr %43, i32 0, i32 32
  %lh_first64 = getelementptr inbounds %struct.anon.4, ptr %parents63, i32 0, i32 0
  store ptr %42, ptr %lh_first64, align 8
  %44 = load ptr, ptr %new_bs.addr, align 8
  %parents65 = getelementptr inbounds %struct.BlockDriverState, ptr %44, i32 0, i32 32
  %lh_first66 = getelementptr inbounds %struct.anon.4, ptr %parents65, i32 0, i32 0
  %45 = load ptr, ptr %child.addr, align 8
  %next_parent67 = getelementptr inbounds %struct.BdrvChild, ptr %45, i32 0, i32 10
  %le_prev68 = getelementptr inbounds %struct.anon.15, ptr %next_parent67, i32 0, i32 1
  store ptr %lh_first66, ptr %le_prev68, align 8
  br label %do.end69

do.end69:                                         ; preds = %if.end62
  %46 = load ptr, ptr %child.addr, align 8
  %klass70 = getelementptr inbounds %struct.BdrvChild, ptr %46, i32 0, i32 2
  %47 = load ptr, ptr %klass70, align 8
  %attach = getelementptr inbounds %struct.BdrvChildClass, ptr %47, i32 0, i32 7
  %48 = load ptr, ptr %attach, align 8
  %tobool71 = icmp ne ptr %48, null
  br i1 %tobool71, label %if.then72, label %if.end75

if.then72:                                        ; preds = %do.end69
  %49 = load ptr, ptr %child.addr, align 8
  %klass73 = getelementptr inbounds %struct.BdrvChild, ptr %49, i32 0, i32 2
  %50 = load ptr, ptr %klass73, align 8
  %attach74 = getelementptr inbounds %struct.BdrvChildClass, ptr %50, i32 0, i32 7
  %51 = load ptr, ptr %attach74, align 8
  %52 = load ptr, ptr %child.addr, align 8
  call void %51(ptr noundef %52)
  br label %if.end75

if.end75:                                         ; preds = %if.then72, %do.end69
  br label %if.end76

if.end76:                                         ; preds = %if.end75, %if.end47
  %53 = load ptr, ptr %new_bs.addr, align 8
  %tobool77 = icmp ne ptr %53, null
  br i1 %tobool77, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end76
  %54 = load ptr, ptr %new_bs.addr, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %54, i32 0, i32 46
  %55 = load i32, ptr %quiesce_counter, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end76
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %55, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, ptr %new_bs_quiesce_counter, align 4
  %56 = load i32, ptr %new_bs_quiesce_counter, align 4
  %tobool78 = icmp ne i32 %56, 0
  br i1 %tobool78, label %if.end83, label %land.lhs.true79

land.lhs.true79:                                  ; preds = %cond.end
  %57 = load ptr, ptr %child.addr, align 8
  %quiesced_parent80 = getelementptr inbounds %struct.BdrvChild, ptr %57, i32 0, i32 8
  %58 = load i8, ptr %quiesced_parent80, align 1
  %tobool81 = trunc i8 %58 to i1
  br i1 %tobool81, label %if.then82, label %if.end83

if.then82:                                        ; preds = %land.lhs.true79
  %59 = load ptr, ptr %child.addr, align 8
  call void @bdrv_parent_drained_end_single(ptr noundef %59)
  br label %if.end83

if.end83:                                         ; preds = %if.then82, %land.lhs.true79, %cond.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_free(ptr noundef %child) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %graph_lockable_auto18 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  store ptr %child, ptr %child.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %bs, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.207, ptr noundef @.str.2, i32 noundef 2984, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_free) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.body
  br label %if.end3

if.else2:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2985, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_free) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  br label %do.end

do.end:                                           ; preds = %if.end3
  %call4 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call4, ptr %graph_lockable_auto18, align 8
  %2 = load ptr, ptr %child.addr, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %2, i32 0, i32 9
  %le_prev = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 1
  %3 = load ptr, ptr %le_prev, align 8
  %tobool5 = icmp ne ptr %3, null
  br i1 %tobool5, label %if.else7, label %if.then6

if.then6:                                         ; preds = %do.end
  br label %if.end8

if.else7:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.208, ptr noundef @.str.2, i32 noundef 2988, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_free) #16
  unreachable

if.end8:                                          ; preds = %if.then6
  %4 = load ptr, ptr %child.addr, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 1
  %5 = load ptr, ptr %name, align 8
  call void @g_free(ptr noundef %5)
  %6 = load ptr, ptr %child.addr, align 8
  call void @g_free(ptr noundef %6)
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto18)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_try_change_aio_context(ptr noundef %bs, ptr noundef %ctx, ptr noundef %ignore_child, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %ignore_child.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %tran = alloca ptr, align 8
  %visited = alloca ptr, align 8
  %ret = alloca i32, align 4
  %old_context = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %ignore_child, ptr %ignore_child.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_get_aio_context(ptr noundef %0)
  store ptr %call, ptr %old_context, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7831, ptr noundef @__PRETTY_FUNCTION__.bdrv_try_change_aio_context) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call2 = call ptr @tran_new()
  store ptr %call2, ptr %tran, align 8
  %call3 = call ptr @g_hash_table_new(ptr noundef null, ptr noundef null)
  store ptr %call3, ptr %visited, align 8
  %1 = load ptr, ptr %ignore_child.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then4, label %if.end6

if.then4:                                         ; preds = %do.end
  %2 = load ptr, ptr %visited, align 8
  %3 = load ptr, ptr %ignore_child.addr, align 8
  %call5 = call i32 @g_hash_table_add(ptr noundef %2, ptr noundef %3)
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %do.end
  %4 = load ptr, ptr %bs.addr, align 8
  %5 = load ptr, ptr %ctx.addr, align 8
  %6 = load ptr, ptr %visited, align 8
  %7 = load ptr, ptr %tran, align 8
  %8 = load ptr, ptr %errp.addr, align 8
  %call7 = call zeroext i1 @bdrv_change_aio_context(ptr noundef %4, ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8)
  %conv = zext i1 %call7 to i32
  store i32 %conv, ptr %ret, align 4
  %9 = load ptr, ptr %visited, align 8
  call void @g_hash_table_destroy(ptr noundef %9)
  %10 = load i32, ptr %ret, align 4
  %tobool8 = icmp ne i32 %10, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  %11 = load ptr, ptr %tran, align 8
  call void @tran_abort(ptr noundef %11)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %call11 = call ptr @qemu_get_aio_context()
  %12 = load ptr, ptr %old_context, align 8
  %cmp = icmp ne ptr %call11, %12
  br i1 %cmp, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end10
  %13 = load ptr, ptr %old_context, align 8
  call void @aio_context_release(ptr noundef %13)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end10
  %call15 = call ptr @qemu_get_aio_context()
  %14 = load ptr, ptr %ctx.addr, align 8
  %cmp16 = icmp ne ptr %call15, %14
  br i1 %cmp16, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  %15 = load ptr, ptr %ctx.addr, align 8
  call void @aio_context_acquire(ptr noundef %15)
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %if.end14
  %16 = load ptr, ptr %tran, align 8
  call void @tran_commit(ptr noundef %16)
  %call20 = call ptr @qemu_get_aio_context()
  %17 = load ptr, ptr %ctx.addr, align 8
  %cmp21 = icmp ne ptr %call20, %17
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end19
  %18 = load ptr, ptr %ctx.addr, align 8
  call void @aio_context_release(ptr noundef %18)
  br label %if.end24

if.end24:                                         ; preds = %if.then23, %if.end19
  %call25 = call ptr @qemu_get_aio_context()
  %19 = load ptr, ptr %old_context, align 8
  %cmp26 = icmp ne ptr %call25, %19
  br i1 %cmp26, label %if.then28, label %if.end29

if.then28:                                        ; preds = %if.end24
  %20 = load ptr, ptr %old_context, align 8
  call void @aio_context_acquire(ptr noundef %20)
  br label %if.end29

if.end29:                                         ; preds = %if.then28, %if.end24
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end29, %if.then9
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_unref_child(ptr noundef %parent, ptr noundef %child) #0 {
entry:
  %parent.addr = alloca ptr, align 8
  %child.addr = alloca ptr, align 8
  store ptr %parent, ptr %parent.addr, align 8
  store ptr %child, ptr %child.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3382, ptr noundef @__PRETTY_FUNCTION__.bdrv_unref_child) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %child.addr, align 8
  %cmp = icmp eq ptr %0, null
  br i1 %cmp, label %if.then1, label %if.end2

if.then1:                                         ; preds = %do.end
  br label %return

if.end2:                                          ; preds = %do.end
  %1 = load ptr, ptr %parent.addr, align 8
  %2 = load ptr, ptr %child.addr, align 8
  call void @bdrv_unset_inherits_from(ptr noundef %1, ptr noundef %2, ptr noundef null)
  %3 = load ptr, ptr %child.addr, align 8
  call void @bdrv_root_unref_child(ptr noundef %3)
  br label %return

return:                                           ; preds = %if.end2, %if.then1
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_unset_inherits_from(ptr noundef %root, ptr noundef %child, ptr noundef %tran) #0 {
entry:
  %root.addr = alloca ptr, align 8
  %child.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %root, ptr %root.addr, align 8
  store ptr %child, ptr %child.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %bs, align 8
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 28
  %2 = load ptr, ptr %inherits_from, align 8
  %3 = load ptr, ptr %root.addr, align 8
  %cmp = icmp eq ptr %2, %3
  br i1 %cmp, label %if.then, label %if.end10

if.then:                                          ; preds = %entry
  %4 = load ptr, ptr %root.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %5 = load ptr, ptr %lh_first, align 8
  store ptr %5, ptr %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %6 = load ptr, ptr %c, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %c, align 8
  %8 = load ptr, ptr %child.addr, align 8
  %cmp1 = icmp ne ptr %7, %8
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %9 = load ptr, ptr %c, align 8
  %bs2 = getelementptr inbounds %struct.BdrvChild, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %bs2, align 8
  %11 = load ptr, ptr %child.addr, align 8
  %bs3 = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %bs3, align 8
  %cmp4 = icmp eq ptr %10, %12
  br i1 %cmp4, label %if.then5, label %if.end

if.then5:                                         ; preds = %land.lhs.true
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %13 = load ptr, ptr %c, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %13, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %14 = load ptr, ptr %le_next, align 8
  store ptr %14, ptr %c, align 8
  br label %for.cond, !llvm.loop !19

for.end:                                          ; preds = %if.then5, %for.cond
  %15 = load ptr, ptr %c, align 8
  %cmp6 = icmp eq ptr %15, null
  br i1 %cmp6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %for.end
  %16 = load ptr, ptr %child.addr, align 8
  %bs8 = getelementptr inbounds %struct.BdrvChild, ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %bs8, align 8
  %18 = load ptr, ptr %tran.addr, align 8
  call void @bdrv_set_inherits_from(ptr noundef %17, ptr noundef null, ptr noundef %18)
  br label %if.end9

if.end9:                                          ; preds = %if.then7, %for.end
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %entry
  %19 = load ptr, ptr %child.addr, align 8
  %bs11 = getelementptr inbounds %struct.BdrvChild, ptr %19, i32 0, i32 0
  %20 = load ptr, ptr %bs11, align 8
  %children12 = getelementptr inbounds %struct.BlockDriverState, ptr %20, i32 0, i32 29
  %lh_first13 = getelementptr inbounds %struct.anon.3, ptr %children12, i32 0, i32 0
  %21 = load ptr, ptr %lh_first13, align 8
  store ptr %21, ptr %c, align 8
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc17, %if.end10
  %22 = load ptr, ptr %c, align 8
  %tobool15 = icmp ne ptr %22, null
  br i1 %tobool15, label %for.body16, label %for.end20

for.body16:                                       ; preds = %for.cond14
  %23 = load ptr, ptr %root.addr, align 8
  %24 = load ptr, ptr %c, align 8
  %25 = load ptr, ptr %tran.addr, align 8
  call void @bdrv_unset_inherits_from(ptr noundef %23, ptr noundef %24, ptr noundef %25)
  br label %for.inc17

for.inc17:                                        ; preds = %for.body16
  %26 = load ptr, ptr %c, align 8
  %next18 = getelementptr inbounds %struct.BdrvChild, ptr %26, i32 0, i32 9
  %le_next19 = getelementptr inbounds %struct.anon.14, ptr %next18, i32 0, i32 0
  %27 = load ptr, ptr %le_next19, align 8
  store ptr %27, ptr %c, align 8
  br label %for.cond14, !llvm.loop !20

for.end20:                                        ; preds = %for.cond14
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_set_backing_hd_drained(ptr noundef %bs, ptr noundef %backing_hd, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %backing_hd.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %tran = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %backing_hd, ptr %backing_hd.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %call = call ptr @tran_new()
  store ptr %call, ptr %tran, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3548, ptr noundef @__PRETTY_FUNCTION__.bdrv_set_backing_hd_drained) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 46
  %1 = load i32, ptr %quiesce_counter, align 8
  %cmp = icmp sgt i32 %1, 0
  br i1 %cmp, label %if.then2, label %if.else3

if.then2:                                         ; preds = %do.end
  br label %if.end4

if.else3:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.74, ptr noundef @.str.2, i32 noundef 3549, ptr noundef @__PRETTY_FUNCTION__.bdrv_set_backing_hd_drained) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  %2 = load ptr, ptr %bs.addr, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 30
  %3 = load ptr, ptr %backing, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then5, label %if.end13

if.then5:                                         ; preds = %if.end4
  %4 = load ptr, ptr %bs.addr, align 8
  %backing6 = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 30
  %5 = load ptr, ptr %backing6, align 8
  %bs7 = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %bs7, align 8
  %quiesce_counter8 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 46
  %7 = load i32, ptr %quiesce_counter8, align 8
  %cmp9 = icmp sgt i32 %7, 0
  br i1 %cmp9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.then5
  br label %if.end12

if.else11:                                        ; preds = %if.then5
  call void @__assert_fail(ptr noundef @.str.75, ptr noundef @.str.2, i32 noundef 3551, ptr noundef @__PRETTY_FUNCTION__.bdrv_set_backing_hd_drained) #16
  unreachable

if.end12:                                         ; preds = %if.then10
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %if.end4
  %8 = load ptr, ptr %bs.addr, align 8
  %9 = load ptr, ptr %backing_hd.addr, align 8
  %10 = load ptr, ptr %tran, align 8
  %11 = load ptr, ptr %errp.addr, align 8
  %call14 = call i32 @bdrv_set_file_or_backing_noperm(ptr noundef %8, ptr noundef %9, i1 noundef zeroext true, ptr noundef %10, ptr noundef %11)
  store i32 %call14, ptr %ret, align 4
  %12 = load i32, ptr %ret, align 4
  %cmp15 = icmp slt i32 %12, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end13
  br label %out

if.end17:                                         ; preds = %if.end13
  %13 = load ptr, ptr %bs.addr, align 8
  %14 = load ptr, ptr %tran, align 8
  %15 = load ptr, ptr %errp.addr, align 8
  %call18 = call i32 @bdrv_refresh_perms(ptr noundef %13, ptr noundef %14, ptr noundef %15)
  store i32 %call18, ptr %ret, align 4
  br label %out

out:                                              ; preds = %if.end17, %if.then16
  %16 = load ptr, ptr %tran, align 8
  %17 = load i32, ptr %ret, align 4
  call void @tran_finalize(ptr noundef %16, i32 noundef %17)
  %18 = load i32, ptr %ret, align 4
  ret i32 %18
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_set_file_or_backing_noperm(ptr noundef %parent_bs, ptr noundef %child_bs, i1 noundef zeroext %is_backing, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %parent_bs.addr = alloca ptr, align 8
  %child_bs.addr = alloca ptr, align 8
  %is_backing.addr = alloca i8, align 1
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %update_inherits_from = alloca i8, align 1
  %child = alloca ptr, align 8
  %role = alloca i32, align 4
  store ptr %parent_bs, ptr %parent_bs.addr, align 8
  store ptr %child_bs, ptr %child_bs.addr, align 8
  %frombool = zext i1 %is_backing to i8
  store i8 %frombool, ptr %is_backing.addr, align 1
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %child_bs.addr, align 8
  %1 = load ptr, ptr %parent_bs.addr, align 8
  %call = call zeroext i1 @bdrv_inherits_from_recursive(ptr noundef %0, ptr noundef %1)
  %frombool1 = zext i1 %call to i8
  store i8 %frombool1, ptr %update_inherits_from, align 1
  %2 = load i8, ptr %is_backing.addr, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load ptr, ptr %parent_bs.addr, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 30
  %4 = load ptr, ptr %backing, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load ptr, ptr %parent_bs.addr, align 8
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 31
  %6 = load ptr, ptr %file, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %6, %cond.false ]
  store ptr %cond, ptr %child, align 8
  br label %do.body

do.body:                                          ; preds = %cond.end
  %call2 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3457, ptr noundef @__PRETTY_FUNCTION__.bdrv_set_file_or_backing_noperm) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %7 = load ptr, ptr %parent_bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 6
  %8 = load ptr, ptr %drv, align 8
  %tobool3 = icmp ne ptr %8, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %do.end
  %9 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %9, ptr noundef @.str.2, i32 noundef 3465, ptr noundef @__func__.bdrv_set_file_or_backing_noperm, ptr noundef @.str.209)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %do.end
  %10 = load ptr, ptr %child, align 8
  %tobool6 = icmp ne ptr %10, null
  br i1 %tobool6, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %if.end5
  %11 = load ptr, ptr %child, align 8
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 7
  %12 = load i8, ptr %frozen, align 8
  %tobool7 = trunc i8 %12 to i1
  br i1 %tobool7, label %if.then8, label %if.end11

if.then8:                                         ; preds = %land.lhs.true
  %13 = load ptr, ptr %errp.addr, align 8
  %14 = load ptr, ptr %child, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %name, align 8
  %16 = load ptr, ptr %parent_bs.addr, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %16, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  %17 = load ptr, ptr %child, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %17, i32 0, i32 0
  %18 = load ptr, ptr %bs, align 8
  %node_name9 = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 22
  %arraydecay10 = getelementptr inbounds [32 x i8], ptr %node_name9, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %13, ptr noundef @.str.2, i32 noundef 3471, ptr noundef @__func__.bdrv_set_file_or_backing_noperm, ptr noundef @.str.210, ptr noundef %15, ptr noundef %arraydecay, ptr noundef %arraydecay10)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end11:                                         ; preds = %land.lhs.true, %if.end5
  %19 = load i8, ptr %is_backing.addr, align 1
  %tobool12 = trunc i8 %19 to i1
  br i1 %tobool12, label %land.lhs.true13, label %if.end23

land.lhs.true13:                                  ; preds = %if.end11
  %20 = load ptr, ptr %parent_bs.addr, align 8
  %drv14 = getelementptr inbounds %struct.BlockDriverState, ptr %20, i32 0, i32 6
  %21 = load ptr, ptr %drv14, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %21, i32 0, i32 2
  %22 = load i8, ptr %is_filter, align 4
  %tobool15 = trunc i8 %22 to i1
  br i1 %tobool15, label %if.end23, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %land.lhs.true13
  %23 = load ptr, ptr %parent_bs.addr, align 8
  %drv17 = getelementptr inbounds %struct.BlockDriverState, ptr %23, i32 0, i32 6
  %24 = load ptr, ptr %drv17, align 8
  %supports_backing = getelementptr inbounds %struct.BlockDriver, ptr %24, i32 0, i32 7
  %25 = load i8, ptr %supports_backing, align 1
  %tobool18 = trunc i8 %25 to i1
  br i1 %tobool18, label %if.end23, label %if.then19

if.then19:                                        ; preds = %land.lhs.true16
  %26 = load ptr, ptr %errp.addr, align 8
  %27 = load ptr, ptr %parent_bs.addr, align 8
  %drv20 = getelementptr inbounds %struct.BlockDriverState, ptr %27, i32 0, i32 6
  %28 = load ptr, ptr %drv20, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %28, i32 0, i32 0
  %29 = load ptr, ptr %format_name, align 8
  %30 = load ptr, ptr %parent_bs.addr, align 8
  %node_name21 = getelementptr inbounds %struct.BlockDriverState, ptr %30, i32 0, i32 22
  %arraydecay22 = getelementptr inbounds [32 x i8], ptr %node_name21, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %26, ptr noundef @.str.2, i32 noundef 3479, ptr noundef @__func__.bdrv_set_file_or_backing_noperm, ptr noundef @.str.211, ptr noundef %29, ptr noundef %arraydecay22)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %land.lhs.true16, %land.lhs.true13, %if.end11
  %31 = load ptr, ptr %parent_bs.addr, align 8
  %drv24 = getelementptr inbounds %struct.BlockDriverState, ptr %31, i32 0, i32 6
  %32 = load ptr, ptr %drv24, align 8
  %is_filter25 = getelementptr inbounds %struct.BlockDriver, ptr %32, i32 0, i32 2
  %33 = load i8, ptr %is_filter25, align 4
  %tobool26 = trunc i8 %33 to i1
  br i1 %tobool26, label %if.then27, label %if.else28

if.then27:                                        ; preds = %if.end23
  store i32 20, ptr %role, align 4
  br label %if.end37

if.else28:                                        ; preds = %if.end23
  %34 = load i8, ptr %is_backing.addr, align 1
  %tobool29 = trunc i8 %34 to i1
  br i1 %tobool29, label %if.then30, label %if.else31

if.then30:                                        ; preds = %if.else28
  store i32 8, ptr %role, align 4
  br label %if.end36

if.else31:                                        ; preds = %if.else28
  %35 = load ptr, ptr %child, align 8
  %tobool32 = icmp ne ptr %35, null
  br i1 %tobool32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.else31
  %36 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %36, ptr noundef @.str.2, i32 noundef 3494, ptr noundef @__func__.bdrv_set_file_or_backing_noperm, ptr noundef @.str.212)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.else31
  %37 = load ptr, ptr %child, align 8
  %role35 = getelementptr inbounds %struct.BdrvChild, ptr %37, i32 0, i32 3
  %38 = load i32, ptr %role35, align 8
  store i32 %38, ptr %role, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.end34, %if.then30
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then27
  %39 = load ptr, ptr %child, align 8
  %tobool38 = icmp ne ptr %39, null
  br i1 %tobool38, label %if.then39, label %if.end45

if.then39:                                        ; preds = %if.end37
  %40 = load ptr, ptr %child, align 8
  %bs40 = getelementptr inbounds %struct.BdrvChild, ptr %40, i32 0, i32 0
  %41 = load ptr, ptr %bs40, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %41, i32 0, i32 46
  %42 = load i32, ptr %quiesce_counter, align 8
  %tobool41 = icmp ne i32 %42, 0
  br i1 %tobool41, label %if.then42, label %if.else43

if.then42:                                        ; preds = %if.then39
  br label %if.end44

if.else43:                                        ; preds = %if.then39
  call void @__assert_fail(ptr noundef @.str.213, ptr noundef @.str.2, i32 noundef 3501, ptr noundef @__PRETTY_FUNCTION__.bdrv_set_file_or_backing_noperm) #16
  unreachable

if.end44:                                         ; preds = %if.then42
  %43 = load ptr, ptr %parent_bs.addr, align 8
  %44 = load ptr, ptr %child, align 8
  %45 = load ptr, ptr %tran.addr, align 8
  call void @bdrv_unset_inherits_from(ptr noundef %43, ptr noundef %44, ptr noundef %45)
  %46 = load ptr, ptr %child, align 8
  %47 = load ptr, ptr %tran.addr, align 8
  call void @bdrv_remove_child(ptr noundef %46, ptr noundef %47)
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.end37
  %48 = load ptr, ptr %child_bs.addr, align 8
  %tobool46 = icmp ne ptr %48, null
  br i1 %tobool46, label %if.end48, label %if.then47

if.then47:                                        ; preds = %if.end45
  br label %out

if.end48:                                         ; preds = %if.end45
  %49 = load ptr, ptr %parent_bs.addr, align 8
  %50 = load ptr, ptr %child_bs.addr, align 8
  %51 = load i8, ptr %is_backing.addr, align 1
  %tobool49 = trunc i8 %51 to i1
  %cond50 = select i1 %tobool49, ptr @.str.89, ptr @.str.214
  %52 = load i32, ptr %role, align 4
  %53 = load ptr, ptr %tran.addr, align 8
  %54 = load ptr, ptr %errp.addr, align 8
  %call51 = call ptr @bdrv_attach_child_noperm(ptr noundef %49, ptr noundef %50, ptr noundef %cond50, ptr noundef @child_of_bds, i32 noundef %52, ptr noundef %53, ptr noundef %54)
  store ptr %call51, ptr %child, align 8
  %55 = load ptr, ptr %child, align 8
  %tobool52 = icmp ne ptr %55, null
  br i1 %tobool52, label %if.end54, label %if.then53

if.then53:                                        ; preds = %if.end48
  store i32 -22, ptr %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.end48
  %56 = load i8, ptr %update_inherits_from, align 1
  %tobool55 = trunc i8 %56 to i1
  br i1 %tobool55, label %if.then56, label %if.end57

if.then56:                                        ; preds = %if.end54
  %57 = load ptr, ptr %child_bs.addr, align 8
  %58 = load ptr, ptr %parent_bs.addr, align 8
  %59 = load ptr, ptr %tran.addr, align 8
  call void @bdrv_set_inherits_from(ptr noundef %57, ptr noundef %58, ptr noundef %59)
  br label %if.end57

if.end57:                                         ; preds = %if.then56, %if.end54
  br label %out

out:                                              ; preds = %if.end57, %if.then47
  %60 = load ptr, ptr %parent_bs.addr, align 8
  %61 = load ptr, ptr %tran.addr, align 8
  call void @bdrv_refresh_limits(ptr noundef %60, ptr noundef %61, ptr noundef null)
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %out, %if.then53, %if.then33, %if.then19, %if.then8, %if.then4
  %62 = load i32, ptr %retval, align 4
  ret i32 %62
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_set_backing_hd(ptr noundef %bs, ptr noundef %backing_hd, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %backing_hd.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %drain_bs = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %backing_hd, ptr %backing_hd.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3570, ptr noundef @__PRETTY_FUNCTION__.bdrv_set_backing_hd) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  call void @bdrv_graph_rdlock_main_loop()
  %0 = load ptr, ptr %bs.addr, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 30
  %1 = load ptr, ptr %backing, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %backing1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 30
  %3 = load ptr, ptr %backing1, align 8
  %bs2 = getelementptr inbounds %struct.BdrvChild, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %bs2, align 8
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %5 = load ptr, ptr %bs.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %5, %cond.false ]
  store ptr %cond, ptr %drain_bs, align 8
  call void @bdrv_graph_rdunlock_main_loop()
  %6 = load ptr, ptr %drain_bs, align 8
  call void @bdrv_ref(ptr noundef %6)
  %7 = load ptr, ptr %drain_bs, align 8
  call void @bdrv_drained_begin(ptr noundef %7)
  %8 = load ptr, ptr %backing_hd.addr, align 8
  call void @bdrv_graph_wrlock(ptr noundef %8)
  %9 = load ptr, ptr %bs.addr, align 8
  %10 = load ptr, ptr %backing_hd.addr, align 8
  %11 = load ptr, ptr %errp.addr, align 8
  %call3 = call i32 @bdrv_set_backing_hd_drained(ptr noundef %9, ptr noundef %10, ptr noundef %11)
  store i32 %call3, ptr %ret, align 4
  %12 = load ptr, ptr %backing_hd.addr, align 8
  call void @bdrv_graph_wrunlock(ptr noundef %12)
  %13 = load ptr, ptr %drain_bs, align 8
  call void @bdrv_drained_end(ptr noundef %13)
  %14 = load ptr, ptr %drain_bs, align 8
  call void @bdrv_unref(ptr noundef %14)
  %15 = load i32, ptr %ret, align 4
  ret i32 %15
}

declare void @bdrv_graph_rdlock_main_loop() #2

declare void @bdrv_graph_rdunlock_main_loop() #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_ref(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7238, ptr noundef @__PRETTY_FUNCTION__.bdrv_ref) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %refcnt = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 26
  %1 = load i32, ptr %refcnt, align 8
  %inc = add i32 %1, 1
  store i32 %inc, ptr %refcnt, align 8
  ret void
}

declare void @bdrv_graph_wrlock(ptr noundef) #2

declare void @bdrv_graph_wrunlock(ptr noundef) #2

declare void @bdrv_drained_end(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_open_backing_file(ptr noundef %bs, ptr noundef %parent_options, ptr noundef %bdref_key, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %parent_options.addr = alloca ptr, align 8
  %bdref_key.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %backing_filename = alloca ptr, align 8
  %bdref_key_dot = alloca ptr, align 8
  %reference = alloca ptr, align 8
  %ret = alloca i32, align 4
  %implicit_backing = alloca i8, align 1
  %backing_hd = alloca ptr, align 8
  %backing_hd_ctx = alloca ptr, align 8
  %options = alloca ptr, align 8
  %tmp_parent_options = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %graph_lockable_auto19 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %_obj20 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp21 = alloca ptr, align 8
  %_obj21 = alloca ptr, align 8
  %tmp35 = alloca ptr, align 8
  %__mptr38 = alloca ptr, align 8
  %tmp40 = alloca ptr, align 8
  %_obj22 = alloca ptr, align 8
  %tmp53 = alloca ptr, align 8
  %__mptr56 = alloca ptr, align 8
  %tmp58 = alloca ptr, align 8
  %_obj23 = alloca ptr, align 8
  %tmp95 = alloca ptr, align 8
  %__mptr98 = alloca ptr, align 8
  %tmp100 = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %parent_options, ptr %parent_options.addr, align 8
  store ptr %bdref_key, ptr %bdref_key.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %backing_filename, align 8
  store ptr null, ptr %reference, align 8
  store i32 0, ptr %ret, align 4
  store i8 0, ptr %implicit_backing, align 1
  store ptr null, ptr %tmp_parent_options, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3613, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_backing_file) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call1, ptr %graph_lockable_auto19, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 30
  %1 = load ptr, ptr %backing, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  br label %free_exit

if.end3:                                          ; preds = %do.end
  %2 = load ptr, ptr %parent_options.addr, align 8
  %cmp4 = icmp eq ptr %2, null
  br i1 %cmp4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  %call6 = call ptr @qdict_new()
  store ptr %call6, ptr %tmp_parent_options, align 8
  %3 = load ptr, ptr %tmp_parent_options, align 8
  store ptr %3, ptr %parent_options.addr, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  %4 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 0
  %5 = load i32, ptr %open_flags, align 8
  %and = and i32 %5, -257
  store i32 %and, ptr %open_flags, align 8
  %6 = load ptr, ptr %bdref_key.addr, align 8
  %call8 = call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef @.str.76, ptr noundef %6)
  store ptr %call8, ptr %bdref_key_dot, align 8
  %7 = load ptr, ptr %parent_options.addr, align 8
  %8 = load ptr, ptr %bdref_key_dot, align 8
  call void @qdict_extract_subqdict(ptr noundef %7, ptr noundef %options, ptr noundef %8)
  %9 = load ptr, ptr %bdref_key_dot, align 8
  call void @g_free(ptr noundef %9)
  %10 = load ptr, ptr %parent_options.addr, align 8
  %11 = load ptr, ptr %bdref_key.addr, align 8
  %call9 = call ptr @qdict_get_try_str(ptr noundef %10, ptr noundef %11)
  store ptr %call9, ptr %reference, align 8
  %12 = load ptr, ptr %reference, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.then12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end7
  %13 = load ptr, ptr %options, align 8
  %call10 = call i32 @qdict_haskey(ptr noundef %13, ptr noundef @.str.77)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.else13

if.then12:                                        ; preds = %lor.lhs.false, %if.end7
  br label %if.end47

if.else13:                                        ; preds = %lor.lhs.false
  %14 = load ptr, ptr %bs.addr, align 8
  %backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 12
  %arrayidx = getelementptr [4096 x i8], ptr %backing_file, i64 0, i64 0
  %15 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %15 to i32
  %cmp14 = icmp eq i32 %conv, 0
  br i1 %cmp14, label %land.lhs.true, label %if.else22

land.lhs.true:                                    ; preds = %if.else13
  %16 = load ptr, ptr %options, align 8
  %call16 = call i64 @qdict_size(ptr noundef %16)
  %cmp17 = icmp eq i64 %call16, 0
  br i1 %cmp17, label %if.then19, label %if.else22

if.then19:                                        ; preds = %land.lhs.true
  %17 = load ptr, ptr %options, align 8
  store ptr %17, ptr %_obj20, align 8
  %18 = load ptr, ptr %_obj20, align 8
  %tobool20 = icmp ne ptr %18, null
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then19
  %19 = load ptr, ptr %_obj20, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %19, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %20 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %20, i64 0
  store ptr %add.ptr, ptr %tmp21, align 8
  %21 = load ptr, ptr %tmp21, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then19
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %21, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %22 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %22)
  br label %free_exit

if.else22:                                        ; preds = %land.lhs.true, %if.else13
  %23 = load ptr, ptr %options, align 8
  %call23 = call i64 @qdict_size(ptr noundef %23)
  %cmp24 = icmp eq i64 %call23, 0
  br i1 %cmp24, label %if.then26, label %if.end31

if.then26:                                        ; preds = %if.else22
  %24 = load ptr, ptr %bs.addr, align 8
  %auto_backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %24, i32 0, i32 13
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %auto_backing_file, i64 0, i64 0
  %25 = load ptr, ptr %bs.addr, align 8
  %backing_file27 = getelementptr inbounds %struct.BlockDriverState, ptr %25, i32 0, i32 12
  %arraydecay28 = getelementptr inbounds [4096 x i8], ptr %backing_file27, i64 0, i64 0
  %call29 = call i32 @strcmp(ptr noundef %arraydecay, ptr noundef %arraydecay28) #13
  %tobool30 = icmp ne i32 %call29, 0
  %lnot = xor i1 %tobool30, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, ptr %implicit_backing, align 1
  br label %if.end31

if.end31:                                         ; preds = %if.then26, %if.else22
  %26 = load ptr, ptr %bs.addr, align 8
  %call32 = call ptr @bdrv_get_full_backing_filename(ptr noundef %26, ptr noundef %local_err)
  store ptr %call32, ptr %backing_filename, align 8
  %27 = load ptr, ptr %local_err, align 8
  %tobool33 = icmp ne ptr %27, null
  br i1 %tobool33, label %if.then34, label %if.end45

if.then34:                                        ; preds = %if.end31
  store i32 -22, ptr %ret, align 4
  %28 = load ptr, ptr %errp.addr, align 8
  %29 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %28, ptr noundef %29)
  %30 = load ptr, ptr %options, align 8
  store ptr %30, ptr %_obj21, align 8
  %31 = load ptr, ptr %_obj21, align 8
  %tobool36 = icmp ne ptr %31, null
  br i1 %tobool36, label %cond.true37, label %cond.false42

cond.true37:                                      ; preds = %if.then34
  %32 = load ptr, ptr %_obj21, align 8
  %base39 = getelementptr inbounds %struct.QDict, ptr %32, i32 0, i32 0
  store ptr %base39, ptr %__mptr38, align 8
  %33 = load ptr, ptr %__mptr38, align 8
  %add.ptr41 = getelementptr i8, ptr %33, i64 0
  store ptr %add.ptr41, ptr %tmp40, align 8
  %34 = load ptr, ptr %tmp40, align 8
  br label %cond.end43

cond.false42:                                     ; preds = %if.then34
  br label %cond.end43

cond.end43:                                       ; preds = %cond.false42, %cond.true37
  %cond44 = phi ptr [ %34, %cond.true37 ], [ null, %cond.false42 ]
  store ptr %cond44, ptr %tmp35, align 8
  %35 = load ptr, ptr %tmp35, align 8
  call void @qobject_unref_impl(ptr noundef %35)
  br label %free_exit

if.end45:                                         ; preds = %if.end31
  br label %if.end46

if.end46:                                         ; preds = %if.end45
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.then12
  %36 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %36, i32 0, i32 6
  %37 = load ptr, ptr %drv, align 8
  %tobool48 = icmp ne ptr %37, null
  br i1 %tobool48, label %lor.lhs.false49, label %if.then52

lor.lhs.false49:                                  ; preds = %if.end47
  %38 = load ptr, ptr %bs.addr, align 8
  %drv50 = getelementptr inbounds %struct.BlockDriverState, ptr %38, i32 0, i32 6
  %39 = load ptr, ptr %drv50, align 8
  %supports_backing = getelementptr inbounds %struct.BlockDriver, ptr %39, i32 0, i32 7
  %40 = load i8, ptr %supports_backing, align 1
  %tobool51 = trunc i8 %40 to i1
  br i1 %tobool51, label %if.end63, label %if.then52

if.then52:                                        ; preds = %lor.lhs.false49, %if.end47
  store i32 -22, ptr %ret, align 4
  %41 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %41, ptr noundef @.str.2, i32 noundef 3667, ptr noundef @__func__.bdrv_open_backing_file, ptr noundef @.str.78)
  %42 = load ptr, ptr %options, align 8
  store ptr %42, ptr %_obj22, align 8
  %43 = load ptr, ptr %_obj22, align 8
  %tobool54 = icmp ne ptr %43, null
  br i1 %tobool54, label %cond.true55, label %cond.false60

cond.true55:                                      ; preds = %if.then52
  %44 = load ptr, ptr %_obj22, align 8
  %base57 = getelementptr inbounds %struct.QDict, ptr %44, i32 0, i32 0
  store ptr %base57, ptr %__mptr56, align 8
  %45 = load ptr, ptr %__mptr56, align 8
  %add.ptr59 = getelementptr i8, ptr %45, i64 0
  store ptr %add.ptr59, ptr %tmp58, align 8
  %46 = load ptr, ptr %tmp58, align 8
  br label %cond.end61

cond.false60:                                     ; preds = %if.then52
  br label %cond.end61

cond.end61:                                       ; preds = %cond.false60, %cond.true55
  %cond62 = phi ptr [ %46, %cond.true55 ], [ null, %cond.false60 ]
  store ptr %cond62, ptr %tmp53, align 8
  %47 = load ptr, ptr %tmp53, align 8
  call void @qobject_unref_impl(ptr noundef %47)
  br label %free_exit

if.end63:                                         ; preds = %lor.lhs.false49
  %48 = load ptr, ptr %reference, align 8
  %tobool64 = icmp ne ptr %48, null
  br i1 %tobool64, label %if.end76, label %land.lhs.true65

land.lhs.true65:                                  ; preds = %if.end63
  %49 = load ptr, ptr %bs.addr, align 8
  %backing_format = getelementptr inbounds %struct.BlockDriverState, ptr %49, i32 0, i32 14
  %arrayidx66 = getelementptr [16 x i8], ptr %backing_format, i64 0, i64 0
  %50 = load i8, ptr %arrayidx66, align 1
  %conv67 = sext i8 %50 to i32
  %cmp68 = icmp ne i32 %conv67, 0
  br i1 %cmp68, label %land.lhs.true70, label %if.end76

land.lhs.true70:                                  ; preds = %land.lhs.true65
  %51 = load ptr, ptr %options, align 8
  %call71 = call i32 @qdict_haskey(ptr noundef %51, ptr noundef @.str.20)
  %tobool72 = icmp ne i32 %call71, 0
  br i1 %tobool72, label %if.end76, label %if.then73

if.then73:                                        ; preds = %land.lhs.true70
  %52 = load ptr, ptr %options, align 8
  %53 = load ptr, ptr %bs.addr, align 8
  %backing_format74 = getelementptr inbounds %struct.BlockDriverState, ptr %53, i32 0, i32 14
  %arraydecay75 = getelementptr inbounds [16 x i8], ptr %backing_format74, i64 0, i64 0
  call void @qdict_put_str(ptr noundef %52, ptr noundef @.str.20, ptr noundef %arraydecay75)
  br label %if.end76

if.end76:                                         ; preds = %if.then73, %land.lhs.true70, %land.lhs.true65, %if.end63
  %54 = load ptr, ptr %backing_filename, align 8
  %55 = load ptr, ptr %reference, align 8
  %56 = load ptr, ptr %options, align 8
  %57 = load ptr, ptr %bs.addr, align 8
  %58 = load ptr, ptr %bs.addr, align 8
  %call77 = call i32 @bdrv_backing_role(ptr noundef %58)
  %59 = load ptr, ptr %errp.addr, align 8
  %call78 = call ptr @bdrv_open_inherit(ptr noundef %54, ptr noundef %55, ptr noundef %56, i32 noundef 0, ptr noundef %57, ptr noundef @child_of_bds, i32 noundef %call77, ptr noundef %59)
  store ptr %call78, ptr %backing_hd, align 8
  %60 = load ptr, ptr %backing_hd, align 8
  %tobool79 = icmp ne ptr %60, null
  br i1 %tobool79, label %if.end82, label %if.then80

if.then80:                                        ; preds = %if.end76
  %61 = load ptr, ptr %bs.addr, align 8
  %open_flags81 = getelementptr inbounds %struct.BlockDriverState, ptr %61, i32 0, i32 0
  %62 = load i32, ptr %open_flags81, align 8
  %or = or i32 %62, 256
  store i32 %or, ptr %open_flags81, align 8
  %63 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, ...) @error_prepend(ptr noundef %63, ptr noundef @.str.79)
  store i32 -22, ptr %ret, align 4
  br label %free_exit

if.end82:                                         ; preds = %if.end76
  %64 = load i8, ptr %implicit_backing, align 1
  %tobool83 = trunc i8 %64 to i1
  br i1 %tobool83, label %if.then84, label %if.end88

if.then84:                                        ; preds = %if.end82
  %65 = load ptr, ptr %backing_hd, align 8
  call void @bdrv_refresh_filename(ptr noundef %65)
  %66 = load ptr, ptr %bs.addr, align 8
  %auto_backing_file85 = getelementptr inbounds %struct.BlockDriverState, ptr %66, i32 0, i32 13
  %arraydecay86 = getelementptr inbounds [4096 x i8], ptr %auto_backing_file85, i64 0, i64 0
  %67 = load ptr, ptr %backing_hd, align 8
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %67, i32 0, i32 11
  %arraydecay87 = getelementptr inbounds [4096 x i8], ptr %filename, i64 0, i64 0
  call void @pstrcpy(ptr noundef %arraydecay86, i32 noundef 4096, ptr noundef %arraydecay87)
  br label %if.end88

if.end88:                                         ; preds = %if.then84, %if.end82
  %68 = load ptr, ptr %backing_hd, align 8
  %call89 = call ptr @bdrv_get_aio_context(ptr noundef %68)
  store ptr %call89, ptr %backing_hd_ctx, align 8
  %69 = load ptr, ptr %backing_hd_ctx, align 8
  call void @aio_context_acquire(ptr noundef %69)
  %70 = load ptr, ptr %bs.addr, align 8
  %71 = load ptr, ptr %backing_hd, align 8
  %72 = load ptr, ptr %errp.addr, align 8
  %call90 = call i32 @bdrv_set_backing_hd(ptr noundef %70, ptr noundef %71, ptr noundef %72)
  store i32 %call90, ptr %ret, align 4
  %73 = load ptr, ptr %backing_hd, align 8
  call void @bdrv_unref(ptr noundef %73)
  %74 = load ptr, ptr %backing_hd_ctx, align 8
  call void @aio_context_release(ptr noundef %74)
  %75 = load i32, ptr %ret, align 4
  %cmp91 = icmp slt i32 %75, 0
  br i1 %cmp91, label %if.then93, label %if.end94

if.then93:                                        ; preds = %if.end88
  br label %free_exit

if.end94:                                         ; preds = %if.end88
  %76 = load ptr, ptr %parent_options.addr, align 8
  %77 = load ptr, ptr %bdref_key.addr, align 8
  call void @qdict_del(ptr noundef %76, ptr noundef %77)
  br label %free_exit

free_exit:                                        ; preds = %if.end94, %if.then93, %if.then80, %cond.end61, %cond.end43, %cond.end, %if.then2
  %78 = load ptr, ptr %backing_filename, align 8
  call void @g_free(ptr noundef %78)
  %79 = load ptr, ptr %tmp_parent_options, align 8
  store ptr %79, ptr %_obj23, align 8
  %80 = load ptr, ptr %_obj23, align 8
  %tobool96 = icmp ne ptr %80, null
  br i1 %tobool96, label %cond.true97, label %cond.false102

cond.true97:                                      ; preds = %free_exit
  %81 = load ptr, ptr %_obj23, align 8
  %base99 = getelementptr inbounds %struct.QDict, ptr %81, i32 0, i32 0
  store ptr %base99, ptr %__mptr98, align 8
  %82 = load ptr, ptr %__mptr98, align 8
  %add.ptr101 = getelementptr i8, ptr %82, i64 0
  store ptr %add.ptr101, ptr %tmp100, align 8
  %83 = load ptr, ptr %tmp100, align 8
  br label %cond.end103

cond.false102:                                    ; preds = %free_exit
  br label %cond.end103

cond.end103:                                      ; preds = %cond.false102, %cond.true97
  %cond104 = phi ptr [ %83, %cond.true97 ], [ null, %cond.false102 ]
  store ptr %cond104, ptr %tmp95, align 8
  %84 = load ptr, ptr %tmp95, align 8
  call void @qobject_unref_impl(ptr noundef %84)
  %85 = load i32, ptr %ret, align 4
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto19)
  ret i32 %85
}

declare void @qdict_extract_subqdict(ptr noundef, ptr noundef, ptr noundef) #2

declare ptr @qdict_get_try_str(ptr noundef, ptr noundef) #2

declare i32 @qdict_haskey(ptr noundef, ptr noundef) #2

declare i64 @qdict_size(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_open_inherit(ptr noundef %filename, ptr noundef %reference, ptr noundef %options, i32 noundef %flags, ptr noundef %parent, ptr noundef %child_class, i32 noundef %child_role, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %parent.addr = alloca ptr, align 8
  %child_class.addr = alloca ptr, align 8
  %child_role.addr = alloca i32, align 4
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %file = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %child = alloca ptr, align 8
  %drvname = alloca ptr, align 8
  %backing = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %snapshot_options = alloca ptr, align 8
  %snapshot_flags = alloca i32, align 4
  %ctx = alloca ptr, align 8
  %graph_lockable_auto27 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %options_non_empty = alloca i8, align 1
  %_obj28 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp25 = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %parent_is_format = alloca i8, align 1
  %file_bs = alloca ptr, align 8
  %child_key_dot = alloca ptr, align 8
  %entry206 = alloca ptr, align 8
  %_obj29 = alloca ptr, align 8
  %tmp217 = alloca ptr, align 8
  %__mptr220 = alloca ptr, align 8
  %tmp222 = alloca ptr, align 8
  %snapshot_bs = alloca ptr, align 8
  %_obj30 = alloca ptr, align 8
  %tmp234 = alloca ptr, align 8
  %__mptr237 = alloca ptr, align 8
  %tmp239 = alloca ptr, align 8
  %_obj31 = alloca ptr, align 8
  %tmp245 = alloca ptr, align 8
  %__mptr248 = alloca ptr, align 8
  %tmp250 = alloca ptr, align 8
  %_obj32 = alloca ptr, align 8
  %tmp256 = alloca ptr, align 8
  %__mptr259 = alloca ptr, align 8
  %tmp261 = alloca ptr, align 8
  %_obj33 = alloca ptr, align 8
  %tmp266 = alloca ptr, align 8
  %__mptr269 = alloca ptr, align 8
  %tmp271 = alloca ptr, align 8
  %_obj34 = alloca ptr, align 8
  %tmp278 = alloca ptr, align 8
  %__mptr281 = alloca ptr, align 8
  %tmp283 = alloca ptr, align 8
  %_obj35 = alloca ptr, align 8
  %tmp288 = alloca ptr, align 8
  %__mptr291 = alloca ptr, align 8
  %tmp293 = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %parent, ptr %parent.addr, align 8
  store ptr %child_class, ptr %child_class.addr, align 8
  store i32 %child_role, ptr %child_role.addr, align 4
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %file, align 8
  store ptr null, ptr %drv, align 8
  store ptr null, ptr %local_err, align 8
  store ptr null, ptr %snapshot_options, align 8
  store i32 0, ptr %snapshot_flags, align 4
  %call = call ptr @qemu_get_aio_context()
  store ptr %call, ptr %ctx, align 8
  %0 = load ptr, ptr %child_class.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, ptr %flags.addr, align 4
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  call void @__assert_fail(ptr noundef @.str.219, ptr noundef @.str.2, i32 noundef 3979, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_inherit) #16
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load ptr, ptr %child_class.addr, align 8
  %tobool2 = icmp ne ptr %2, null
  %lnot = xor i1 %tobool2, true
  %lnot.ext = zext i1 %lnot to i32
  %3 = load ptr, ptr %parent.addr, align 8
  %tobool3 = icmp ne ptr %3, null
  %lnot4 = xor i1 %tobool3, true
  %lnot.ext5 = zext i1 %lnot4 to i32
  %cmp = icmp eq i32 %lnot.ext, %lnot.ext5
  br i1 %cmp, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.end
  br label %if.end8

if.else7:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.220, ptr noundef @.str.2, i32 noundef 3980, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_inherit) #16
  unreachable

if.end8:                                          ; preds = %if.then6
  br label %do.body

do.body:                                          ; preds = %if.end8
  %call9 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call9, label %if.then10, label %if.else11

if.then10:                                        ; preds = %do.body
  br label %if.end12

if.else11:                                        ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3981, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_inherit) #16
  unreachable

if.end12:                                         ; preds = %if.then10
  br label %do.end

do.end:                                           ; preds = %if.end12
  %call13 = call zeroext i1 @qemu_in_coroutine()
  br i1 %call13, label %if.else15, label %if.then14

if.then14:                                        ; preds = %do.end
  br label %if.end16

if.else15:                                        ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.221, ptr noundef @.str.2, i32 noundef 3982, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_inherit) #16
  unreachable

if.end16:                                         ; preds = %if.then14
  %call17 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call17, ptr %graph_lockable_auto27, align 8
  %4 = load ptr, ptr %reference.addr, align 8
  %tobool18 = icmp ne ptr %4, null
  br i1 %tobool18, label %if.then19, label %if.end38

if.then19:                                        ; preds = %if.end16
  %5 = load ptr, ptr %options.addr, align 8
  %tobool20 = icmp ne ptr %5, null
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then19
  %6 = load ptr, ptr %options.addr, align 8
  %call21 = call i64 @qdict_size(ptr noundef %6)
  br label %cond.end

cond.false:                                       ; preds = %if.then19
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call21, %cond.true ], [ 0, %cond.false ]
  %tobool22 = icmp ne i64 %cond, 0
  %frombool = zext i1 %tobool22 to i8
  store i8 %frombool, ptr %options_non_empty, align 1
  %7 = load ptr, ptr %options.addr, align 8
  store ptr %7, ptr %_obj28, align 8
  %8 = load ptr, ptr %_obj28, align 8
  %tobool23 = icmp ne ptr %8, null
  br i1 %tobool23, label %cond.true24, label %cond.false26

cond.true24:                                      ; preds = %cond.end
  %9 = load ptr, ptr %_obj28, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %9, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %10 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %10, i64 0
  store ptr %add.ptr, ptr %tmp25, align 8
  %11 = load ptr, ptr %tmp25, align 8
  br label %cond.end27

cond.false26:                                     ; preds = %cond.end
  br label %cond.end27

cond.end27:                                       ; preds = %cond.false26, %cond.true24
  %cond28 = phi ptr [ %11, %cond.true24 ], [ null, %cond.false26 ]
  store ptr %cond28, ptr %tmp, align 8
  %12 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %12)
  %13 = load ptr, ptr %filename.addr, align 8
  %tobool29 = icmp ne ptr %13, null
  br i1 %tobool29, label %if.then32, label %lor.lhs.false30

lor.lhs.false30:                                  ; preds = %cond.end27
  %14 = load i8, ptr %options_non_empty, align 1
  %tobool31 = trunc i8 %14 to i1
  br i1 %tobool31, label %if.then32, label %if.end33

if.then32:                                        ; preds = %lor.lhs.false30, %cond.end27
  %15 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %15, ptr noundef @.str.2, i32 noundef 3993, ptr noundef @__func__.bdrv_open_inherit, ptr noundef @.str.222)
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end33:                                         ; preds = %lor.lhs.false30
  %16 = load ptr, ptr %reference.addr, align 8
  %17 = load ptr, ptr %reference.addr, align 8
  %18 = load ptr, ptr %errp.addr, align 8
  %call34 = call ptr @bdrv_lookup_bs(ptr noundef %16, ptr noundef %17, ptr noundef %18)
  store ptr %call34, ptr %bs, align 8
  %19 = load ptr, ptr %bs, align 8
  %tobool35 = icmp ne ptr %19, null
  br i1 %tobool35, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.end33
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end37:                                         ; preds = %if.end33
  %20 = load ptr, ptr %bs, align 8
  call void @bdrv_ref(ptr noundef %20)
  %21 = load ptr, ptr %bs, align 8
  store ptr %21, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end38:                                         ; preds = %if.end16
  %call39 = call ptr @bdrv_new()
  store ptr %call39, ptr %bs, align 8
  %22 = load ptr, ptr %options.addr, align 8
  %cmp40 = icmp eq ptr %22, null
  br i1 %cmp40, label %if.then41, label %if.end43

if.then41:                                        ; preds = %if.end38
  %call42 = call ptr @qdict_new()
  store ptr %call42, ptr %options.addr, align 8
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %if.end38
  %23 = load ptr, ptr %options.addr, align 8
  call void @parse_json_protocol(ptr noundef %23, ptr noundef %filename.addr, ptr noundef %local_err)
  %24 = load ptr, ptr %local_err, align 8
  %tobool44 = icmp ne ptr %24, null
  br i1 %tobool44, label %if.then45, label %if.end46

if.then45:                                        ; preds = %if.end43
  br label %fail

if.end46:                                         ; preds = %if.end43
  %25 = load ptr, ptr %options.addr, align 8
  %call47 = call ptr @qdict_clone_shallow(ptr noundef %25)
  %26 = load ptr, ptr %bs, align 8
  %explicit_options = getelementptr inbounds %struct.BlockDriverState, ptr %26, i32 0, i32 34
  store ptr %call47, ptr %explicit_options, align 8
  %27 = load ptr, ptr %child_class.addr, align 8
  %tobool48 = icmp ne ptr %27, null
  br i1 %tobool48, label %if.then49, label %if.end60

if.then49:                                        ; preds = %if.end46
  %28 = load ptr, ptr %parent.addr, align 8
  %drv50 = getelementptr inbounds %struct.BlockDriverState, ptr %28, i32 0, i32 6
  %29 = load ptr, ptr %drv50, align 8
  %tobool51 = icmp ne ptr %29, null
  br i1 %tobool51, label %if.then52, label %if.else56

if.then52:                                        ; preds = %if.then49
  %30 = load ptr, ptr %parent.addr, align 8
  %drv53 = getelementptr inbounds %struct.BlockDriverState, ptr %30, i32 0, i32 6
  %31 = load ptr, ptr %drv53, align 8
  %is_format = getelementptr inbounds %struct.BlockDriver, ptr %31, i32 0, i32 4
  %32 = load i8, ptr %is_format, align 2
  %tobool54 = trunc i8 %32 to i1
  %frombool55 = zext i1 %tobool54 to i8
  store i8 %frombool55, ptr %parent_is_format, align 1
  br label %if.end57

if.else56:                                        ; preds = %if.then49
  store i8 1, ptr %parent_is_format, align 1
  br label %if.end57

if.end57:                                         ; preds = %if.else56, %if.then52
  %33 = load ptr, ptr %parent.addr, align 8
  %34 = load ptr, ptr %bs, align 8
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %34, i32 0, i32 28
  store ptr %33, ptr %inherits_from, align 8
  %35 = load ptr, ptr %child_class.addr, align 8
  %inherit_options = getelementptr inbounds %struct.BdrvChildClass, ptr %35, i32 0, i32 2
  %36 = load ptr, ptr %inherit_options, align 8
  %37 = load i32, ptr %child_role.addr, align 4
  %38 = load i8, ptr %parent_is_format, align 1
  %tobool58 = trunc i8 %38 to i1
  %39 = load ptr, ptr %options.addr, align 8
  %40 = load ptr, ptr %parent.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %40, i32 0, i32 0
  %41 = load i32, ptr %open_flags, align 8
  %42 = load ptr, ptr %parent.addr, align 8
  %options59 = getelementptr inbounds %struct.BlockDriverState, ptr %42, i32 0, i32 33
  %43 = load ptr, ptr %options59, align 8
  call void %36(i32 noundef %37, i1 noundef zeroext %tobool58, ptr noundef %flags.addr, ptr noundef %39, i32 noundef %41, ptr noundef %43)
  br label %if.end60

if.end60:                                         ; preds = %if.end57, %if.end46
  %44 = load ptr, ptr %filename.addr, align 8
  %call61 = call i32 @bdrv_fill_options(ptr noundef %options.addr, ptr noundef %44, ptr noundef %flags.addr, ptr noundef %local_err)
  store i32 %call61, ptr %ret, align 4
  %45 = load i32, ptr %ret, align 4
  %cmp62 = icmp slt i32 %45, 0
  br i1 %cmp62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.end60
  br label %fail

if.end64:                                         ; preds = %if.end60
  %46 = load ptr, ptr %options.addr, align 8
  %call65 = call ptr @qdict_get_try_str(ptr noundef %46, ptr noundef @.str.51)
  %call66 = call i32 @g_strcmp0(ptr noundef %call65, ptr noundef @.str.36)
  %tobool67 = icmp ne i32 %call66, 0
  br i1 %tobool67, label %land.lhs.true, label %if.else70

land.lhs.true:                                    ; preds = %if.end64
  %47 = load ptr, ptr %options.addr, align 8
  %call68 = call zeroext i1 @qdict_get_try_bool(ptr noundef %47, ptr noundef @.str.51, i1 noundef zeroext false)
  br i1 %call68, label %if.else70, label %if.then69

if.then69:                                        ; preds = %land.lhs.true
  %48 = load i32, ptr %flags.addr, align 4
  %or = or i32 %48, 8194
  store i32 %or, ptr %flags.addr, align 4
  br label %if.end71

if.else70:                                        ; preds = %land.lhs.true, %if.end64
  %49 = load i32, ptr %flags.addr, align 4
  %and = and i32 %49, -3
  store i32 %and, ptr %flags.addr, align 4
  br label %if.end71

if.end71:                                         ; preds = %if.else70, %if.then69
  %50 = load i32, ptr %flags.addr, align 4
  %and72 = and i32 %50, 8
  %tobool73 = icmp ne i32 %and72, 0
  br i1 %tobool73, label %if.then74, label %if.end76

if.then74:                                        ; preds = %if.end71
  %call75 = call ptr @qdict_new()
  store ptr %call75, ptr %snapshot_options, align 8
  %51 = load ptr, ptr %snapshot_options, align 8
  %52 = load i32, ptr %flags.addr, align 4
  %53 = load ptr, ptr %options.addr, align 8
  call void @bdrv_temp_snapshot_options(ptr noundef %snapshot_flags, ptr noundef %51, i32 noundef %52, ptr noundef %53)
  %54 = load ptr, ptr %options.addr, align 8
  call void @qdict_del(ptr noundef %54, ptr noundef @.str.51)
  %55 = load ptr, ptr %options.addr, align 8
  %56 = load i32, ptr %flags.addr, align 4
  %57 = load ptr, ptr %options.addr, align 8
  call void @bdrv_inherited_options(i32 noundef 8, i1 noundef zeroext true, ptr noundef %flags.addr, ptr noundef %55, i32 noundef %56, ptr noundef %57)
  br label %if.end76

if.end76:                                         ; preds = %if.then74, %if.end71
  %58 = load i32, ptr %flags.addr, align 4
  %59 = load ptr, ptr %bs, align 8
  %open_flags77 = getelementptr inbounds %struct.BlockDriverState, ptr %59, i32 0, i32 0
  store i32 %58, ptr %open_flags77, align 8
  %60 = load ptr, ptr %options.addr, align 8
  %61 = load ptr, ptr %bs, align 8
  %options78 = getelementptr inbounds %struct.BlockDriverState, ptr %61, i32 0, i32 33
  store ptr %60, ptr %options78, align 8
  %62 = load ptr, ptr %options.addr, align 8
  %call79 = call ptr @qdict_clone_shallow(ptr noundef %62)
  store ptr %call79, ptr %options.addr, align 8
  %63 = load ptr, ptr %options.addr, align 8
  %call80 = call ptr @qdict_get_try_str(ptr noundef %63, ptr noundef @.str.20)
  store ptr %call80, ptr %drvname, align 8
  %64 = load ptr, ptr %drvname, align 8
  %tobool81 = icmp ne ptr %64, null
  br i1 %tobool81, label %if.then82, label %if.end87

if.then82:                                        ; preds = %if.end76
  %65 = load ptr, ptr %drvname, align 8
  %call83 = call ptr @bdrv_find_format(ptr noundef %65)
  store ptr %call83, ptr %drv, align 8
  %66 = load ptr, ptr %drv, align 8
  %tobool84 = icmp ne ptr %66, null
  br i1 %tobool84, label %if.end86, label %if.then85

if.then85:                                        ; preds = %if.then82
  %67 = load ptr, ptr %errp.addr, align 8
  %68 = load ptr, ptr %drvname, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %67, ptr noundef @.str.2, i32 noundef 4080, ptr noundef @__func__.bdrv_open_inherit, ptr noundef @.str.91, ptr noundef %68)
  br label %fail

if.end86:                                         ; preds = %if.then82
  br label %if.end87

if.end87:                                         ; preds = %if.end86, %if.end76
  %69 = load ptr, ptr %drvname, align 8
  %tobool88 = icmp ne ptr %69, null
  br i1 %tobool88, label %if.then92, label %lor.lhs.false89

lor.lhs.false89:                                  ; preds = %if.end87
  %70 = load i32, ptr %flags.addr, align 4
  %and90 = and i32 %70, 32768
  %tobool91 = icmp ne i32 %and90, 0
  br i1 %tobool91, label %if.else93, label %if.then92

if.then92:                                        ; preds = %lor.lhs.false89, %if.end87
  br label %if.end94

if.else93:                                        ; preds = %lor.lhs.false89
  call void @__assert_fail(ptr noundef @.str.223, ptr noundef @.str.2, i32 noundef 4085, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_inherit) #16
  unreachable

if.end94:                                         ; preds = %if.then92
  %71 = load ptr, ptr %options.addr, align 8
  %call95 = call ptr @qdict_get_try_str(ptr noundef %71, ptr noundef @.str.89)
  store ptr %call95, ptr %backing, align 8
  %72 = load ptr, ptr %options.addr, align 8
  %call96 = call ptr @qdict_get(ptr noundef %72, ptr noundef @.str.89)
  %call97 = call ptr @qobject_check_type(ptr noundef %call96, i32 noundef 1)
  %cmp98 = icmp ne ptr %call97, null
  br i1 %cmp98, label %if.then104, label %lor.lhs.false99

lor.lhs.false99:                                  ; preds = %if.end94
  %73 = load ptr, ptr %backing, align 8
  %tobool100 = icmp ne ptr %73, null
  br i1 %tobool100, label %land.lhs.true101, label %if.end111

land.lhs.true101:                                 ; preds = %lor.lhs.false99
  %74 = load ptr, ptr %backing, align 8
  %75 = load i8, ptr %74, align 1
  %conv = sext i8 %75 to i32
  %cmp102 = icmp eq i32 %conv, 0
  br i1 %cmp102, label %if.then104, label %if.end111

if.then104:                                       ; preds = %land.lhs.true101, %if.end94
  %76 = load ptr, ptr %backing, align 8
  %tobool105 = icmp ne ptr %76, null
  br i1 %tobool105, label %if.then106, label %if.end107

if.then106:                                       ; preds = %if.then104
  call void (ptr, ...) @warn_report(ptr noundef @.str.224)
  br label %if.end107

if.end107:                                        ; preds = %if.then106, %if.then104
  %77 = load i32, ptr %flags.addr, align 4
  %or108 = or i32 %77, 256
  store i32 %or108, ptr %flags.addr, align 4
  %78 = load ptr, ptr %bs, align 8
  %explicit_options109 = getelementptr inbounds %struct.BlockDriverState, ptr %78, i32 0, i32 34
  %79 = load ptr, ptr %explicit_options109, align 8
  call void @qdict_del(ptr noundef %79, ptr noundef @.str.89)
  %80 = load ptr, ptr %bs, align 8
  %options110 = getelementptr inbounds %struct.BlockDriverState, ptr %80, i32 0, i32 33
  %81 = load ptr, ptr %options110, align 8
  call void @qdict_del(ptr noundef %81, ptr noundef @.str.89)
  %82 = load ptr, ptr %options.addr, align 8
  call void @qdict_del(ptr noundef %82, ptr noundef @.str.89)
  br label %if.end111

if.end111:                                        ; preds = %if.end107, %land.lhs.true101, %lor.lhs.false99
  %83 = load i32, ptr %flags.addr, align 4
  %and112 = and i32 %83, 32768
  %cmp113 = icmp eq i32 %and112, 0
  br i1 %cmp113, label %if.then115, label %if.end131

if.then115:                                       ; preds = %if.end111
  %84 = load ptr, ptr %filename.addr, align 8
  %85 = load ptr, ptr %options.addr, align 8
  %86 = load ptr, ptr %bs, align 8
  %call116 = call ptr @bdrv_open_child_bs(ptr noundef %84, ptr noundef %85, ptr noundef @.str.214, ptr noundef %86, ptr noundef @child_of_bds, i32 noundef 19, i1 noundef zeroext true, ptr noundef %local_err)
  store ptr %call116, ptr %file_bs, align 8
  %87 = load ptr, ptr %local_err, align 8
  %tobool117 = icmp ne ptr %87, null
  br i1 %tobool117, label %if.then118, label %if.end119

if.then118:                                       ; preds = %if.then115
  br label %fail

if.end119:                                        ; preds = %if.then115
  %88 = load ptr, ptr %file_bs, align 8
  %cmp120 = icmp ne ptr %88, null
  br i1 %cmp120, label %if.then122, label %if.end130

if.then122:                                       ; preds = %if.end119
  %89 = load ptr, ptr %file_bs, align 8
  %call123 = call ptr @bdrv_get_aio_context(ptr noundef %89)
  store ptr %call123, ptr %ctx, align 8
  %90 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %90)
  %91 = load ptr, ptr %ctx, align 8
  %call124 = call ptr @blk_new(ptr noundef %91, i64 noundef 0, i64 noundef 15)
  store ptr %call124, ptr %file, align 8
  %92 = load ptr, ptr %file, align 8
  %93 = load ptr, ptr %file_bs, align 8
  %call125 = call i32 @blk_insert_bs(ptr noundef %92, ptr noundef %93, ptr noundef %local_err)
  %94 = load ptr, ptr %file_bs, align 8
  call void @bdrv_unref(ptr noundef %94)
  %95 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %95)
  %96 = load ptr, ptr %local_err, align 8
  %tobool126 = icmp ne ptr %96, null
  br i1 %tobool126, label %if.then127, label %if.end128

if.then127:                                       ; preds = %if.then122
  br label %fail

if.end128:                                        ; preds = %if.then122
  %97 = load ptr, ptr %options.addr, align 8
  %98 = load ptr, ptr %file_bs, align 8
  %call129 = call ptr @bdrv_get_node_name(ptr noundef %98)
  call void @qdict_put_str(ptr noundef %97, ptr noundef @.str.214, ptr noundef %call129)
  br label %if.end130

if.end130:                                        ; preds = %if.end128, %if.end119
  br label %if.end131

if.end131:                                        ; preds = %if.end130, %if.end111
  %99 = load ptr, ptr %drv, align 8
  %tobool132 = icmp ne ptr %99, null
  %lnot133 = xor i1 %tobool132, true
  %100 = load ptr, ptr %bs, align 8
  %probed = getelementptr inbounds %struct.BlockDriverState, ptr %100, i32 0, i32 3
  %frombool135 = zext i1 %lnot133 to i8
  store i8 %frombool135, ptr %probed, align 2
  %101 = load ptr, ptr %drv, align 8
  %tobool136 = icmp ne ptr %101, null
  br i1 %tobool136, label %if.else147, label %land.lhs.true137

land.lhs.true137:                                 ; preds = %if.end131
  %102 = load ptr, ptr %file, align 8
  %tobool138 = icmp ne ptr %102, null
  br i1 %tobool138, label %if.then139, label %if.else147

if.then139:                                       ; preds = %land.lhs.true137
  %103 = load ptr, ptr %file, align 8
  %104 = load ptr, ptr %filename.addr, align 8
  %call140 = call i32 @find_image_format(ptr noundef %103, ptr noundef %104, ptr noundef %drv, ptr noundef %local_err)
  store i32 %call140, ptr %ret, align 4
  %105 = load i32, ptr %ret, align 4
  %cmp141 = icmp slt i32 %105, 0
  br i1 %cmp141, label %if.then143, label %if.end144

if.then143:                                       ; preds = %if.then139
  br label %fail

if.end144:                                        ; preds = %if.then139
  %106 = load ptr, ptr %bs, align 8
  %options145 = getelementptr inbounds %struct.BlockDriverState, ptr %106, i32 0, i32 33
  %107 = load ptr, ptr %options145, align 8
  %108 = load ptr, ptr %drv, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %108, i32 0, i32 0
  %109 = load ptr, ptr %format_name, align 8
  call void @qdict_put_str(ptr noundef %107, ptr noundef @.str.20, ptr noundef %109)
  %110 = load ptr, ptr %options.addr, align 8
  %111 = load ptr, ptr %drv, align 8
  %format_name146 = getelementptr inbounds %struct.BlockDriver, ptr %111, i32 0, i32 0
  %112 = load ptr, ptr %format_name146, align 8
  call void @qdict_put_str(ptr noundef %110, ptr noundef @.str.20, ptr noundef %112)
  br label %if.end151

if.else147:                                       ; preds = %land.lhs.true137, %if.end131
  %113 = load ptr, ptr %drv, align 8
  %tobool148 = icmp ne ptr %113, null
  br i1 %tobool148, label %if.end150, label %if.then149

if.then149:                                       ; preds = %if.else147
  %114 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %114, ptr noundef @.str.2, i32 noundef 4154, ptr noundef @__func__.bdrv_open_inherit, ptr noundef @.str.225)
  br label %fail

if.end150:                                        ; preds = %if.else147
  br label %if.end151

if.end151:                                        ; preds = %if.end150, %if.end144
  %115 = load i32, ptr %flags.addr, align 4
  %and152 = and i32 %115, 32768
  %tobool153 = icmp ne i32 %and152, 0
  %lnot154 = xor i1 %tobool153, true
  %lnot156 = xor i1 %lnot154, true
  %lnot.ext157 = zext i1 %lnot156 to i32
  %116 = load ptr, ptr %drv, align 8
  %bdrv_file_open = getelementptr inbounds %struct.BlockDriver, ptr %116, i32 0, i32 24
  %117 = load ptr, ptr %bdrv_file_open, align 8
  %tobool158 = icmp ne ptr %117, null
  %lnot159 = xor i1 %tobool158, true
  %lnot161 = xor i1 %lnot159, true
  %lnot.ext162 = zext i1 %lnot161 to i32
  %cmp163 = icmp eq i32 %lnot.ext157, %lnot.ext162
  br i1 %cmp163, label %if.then165, label %if.else166

if.then165:                                       ; preds = %if.end151
  br label %if.end167

if.else166:                                       ; preds = %if.end151
  call void @__assert_fail(ptr noundef @.str.226, ptr noundef @.str.2, i32 noundef 4159, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_inherit) #16
  unreachable

if.end167:                                        ; preds = %if.then165
  %118 = load i32, ptr %flags.addr, align 4
  %and168 = and i32 %118, 32768
  %tobool169 = icmp ne i32 %and168, 0
  br i1 %tobool169, label %lor.lhs.false170, label %if.then172

lor.lhs.false170:                                 ; preds = %if.end167
  %119 = load ptr, ptr %file, align 8
  %tobool171 = icmp ne ptr %119, null
  br i1 %tobool171, label %if.else173, label %if.then172

if.then172:                                       ; preds = %lor.lhs.false170, %if.end167
  br label %if.end174

if.else173:                                       ; preds = %lor.lhs.false170
  call void @__assert_fail(ptr noundef @.str.227, ptr noundef @.str.2, i32 noundef 4162, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_inherit) #16
  unreachable

if.end174:                                        ; preds = %if.then172
  %120 = load ptr, ptr %bs, align 8
  %121 = load ptr, ptr %file, align 8
  %122 = load ptr, ptr %options.addr, align 8
  %call175 = call i32 @bdrv_open_common(ptr noundef %120, ptr noundef %121, ptr noundef %122, ptr noundef %local_err)
  store i32 %call175, ptr %ret, align 4
  %123 = load i32, ptr %ret, align 4
  %cmp176 = icmp slt i32 %123, 0
  br i1 %cmp176, label %if.then178, label %if.end179

if.then178:                                       ; preds = %if.end174
  br label %fail

if.end179:                                        ; preds = %if.end174
  %124 = load ptr, ptr %bs, align 8
  %call180 = call ptr @bdrv_get_aio_context(ptr noundef %124)
  store ptr %call180, ptr %ctx, align 8
  %125 = load ptr, ptr %file, align 8
  %tobool181 = icmp ne ptr %125, null
  br i1 %tobool181, label %if.then182, label %if.end183

if.then182:                                       ; preds = %if.end179
  %126 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %126)
  %127 = load ptr, ptr %file, align 8
  call void @blk_unref(ptr noundef %127)
  %128 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %128)
  store ptr null, ptr %file, align 8
  br label %if.end183

if.end183:                                        ; preds = %if.then182, %if.end179
  %129 = load i32, ptr %flags.addr, align 4
  %and184 = and i32 %129, 256
  %cmp185 = icmp eq i32 %and184, 0
  br i1 %cmp185, label %if.then187, label %if.end193

if.then187:                                       ; preds = %if.end183
  %130 = load ptr, ptr %bs, align 8
  %131 = load ptr, ptr %options.addr, align 8
  %call188 = call i32 @bdrv_open_backing_file(ptr noundef %130, ptr noundef %131, ptr noundef @.str.89, ptr noundef %local_err)
  store i32 %call188, ptr %ret, align 4
  %132 = load i32, ptr %ret, align 4
  %cmp189 = icmp slt i32 %132, 0
  br i1 %cmp189, label %if.then191, label %if.end192

if.then191:                                       ; preds = %if.then187
  br label %close_and_fail

if.end192:                                        ; preds = %if.then187
  br label %if.end193

if.end193:                                        ; preds = %if.end192, %if.end183
  %133 = load ptr, ptr %bs, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %133, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %134 = load ptr, ptr %lh_first, align 8
  store ptr %134, ptr %child, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end193
  %135 = load ptr, ptr %child, align 8
  %tobool194 = icmp ne ptr %135, null
  br i1 %tobool194, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %136 = load ptr, ptr %child, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %136, i32 0, i32 1
  %137 = load ptr, ptr %name, align 8
  %call195 = call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef @.str.76, ptr noundef %137)
  store ptr %call195, ptr %child_key_dot, align 8
  %138 = load ptr, ptr %bs, align 8
  %explicit_options196 = getelementptr inbounds %struct.BlockDriverState, ptr %138, i32 0, i32 34
  %139 = load ptr, ptr %explicit_options196, align 8
  %140 = load ptr, ptr %child_key_dot, align 8
  call void @qdict_extract_subqdict(ptr noundef %139, ptr noundef null, ptr noundef %140)
  %141 = load ptr, ptr %bs, align 8
  %options197 = getelementptr inbounds %struct.BlockDriverState, ptr %141, i32 0, i32 33
  %142 = load ptr, ptr %options197, align 8
  %143 = load ptr, ptr %child_key_dot, align 8
  call void @qdict_extract_subqdict(ptr noundef %142, ptr noundef null, ptr noundef %143)
  %144 = load ptr, ptr %bs, align 8
  %explicit_options198 = getelementptr inbounds %struct.BlockDriverState, ptr %144, i32 0, i32 34
  %145 = load ptr, ptr %explicit_options198, align 8
  %146 = load ptr, ptr %child, align 8
  %name199 = getelementptr inbounds %struct.BdrvChild, ptr %146, i32 0, i32 1
  %147 = load ptr, ptr %name199, align 8
  call void @qdict_del(ptr noundef %145, ptr noundef %147)
  %148 = load ptr, ptr %bs, align 8
  %options200 = getelementptr inbounds %struct.BlockDriverState, ptr %148, i32 0, i32 33
  %149 = load ptr, ptr %options200, align 8
  %150 = load ptr, ptr %child, align 8
  %name201 = getelementptr inbounds %struct.BdrvChild, ptr %150, i32 0, i32 1
  %151 = load ptr, ptr %name201, align 8
  call void @qdict_del(ptr noundef %149, ptr noundef %151)
  %152 = load ptr, ptr %child_key_dot, align 8
  call void @g_free(ptr noundef %152)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %153 = load ptr, ptr %child, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %153, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %154 = load ptr, ptr %le_next, align 8
  store ptr %154, ptr %child, align 8
  br label %for.cond, !llvm.loop !21

for.end:                                          ; preds = %for.cond
  %155 = load ptr, ptr %options.addr, align 8
  %call202 = call i64 @qdict_size(ptr noundef %155)
  %cmp203 = icmp ne i64 %call202, 0
  br i1 %cmp203, label %if.then205, label %if.end216

if.then205:                                       ; preds = %for.end
  %156 = load ptr, ptr %options.addr, align 8
  %call207 = call ptr @qdict_first(ptr noundef %156)
  store ptr %call207, ptr %entry206, align 8
  %157 = load i32, ptr %flags.addr, align 4
  %and208 = and i32 %157, 32768
  %tobool209 = icmp ne i32 %and208, 0
  br i1 %tobool209, label %if.then210, label %if.else212

if.then210:                                       ; preds = %if.then205
  %158 = load ptr, ptr %errp.addr, align 8
  %159 = load ptr, ptr %drv, align 8
  %format_name211 = getelementptr inbounds %struct.BlockDriver, ptr %159, i32 0, i32 0
  %160 = load ptr, ptr %format_name211, align 8
  %161 = load ptr, ptr %entry206, align 8
  %key = getelementptr inbounds %struct.QDictEntry, ptr %161, i32 0, i32 0
  %162 = load ptr, ptr %key, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %158, ptr noundef @.str.2, i32 noundef 4205, ptr noundef @__func__.bdrv_open_inherit, ptr noundef @.str.228, ptr noundef %160, ptr noundef %162)
  br label %if.end215

if.else212:                                       ; preds = %if.then205
  %163 = load ptr, ptr %errp.addr, align 8
  %164 = load ptr, ptr %drv, align 8
  %format_name213 = getelementptr inbounds %struct.BlockDriver, ptr %164, i32 0, i32 0
  %165 = load ptr, ptr %format_name213, align 8
  %166 = load ptr, ptr %entry206, align 8
  %key214 = getelementptr inbounds %struct.QDictEntry, ptr %166, i32 0, i32 0
  %167 = load ptr, ptr %key214, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %163, ptr noundef @.str.2, i32 noundef 4209, ptr noundef @__func__.bdrv_open_inherit, ptr noundef @.str.229, ptr noundef %165, ptr noundef %167)
  br label %if.end215

if.end215:                                        ; preds = %if.else212, %if.then210
  br label %close_and_fail

if.end216:                                        ; preds = %for.end
  %168 = load ptr, ptr %bs, align 8
  call void @bdrv_parent_cb_change_media(ptr noundef %168, i1 noundef zeroext true)
  %169 = load ptr, ptr %options.addr, align 8
  store ptr %169, ptr %_obj29, align 8
  %170 = load ptr, ptr %_obj29, align 8
  %tobool218 = icmp ne ptr %170, null
  br i1 %tobool218, label %cond.true219, label %cond.false224

cond.true219:                                     ; preds = %if.end216
  %171 = load ptr, ptr %_obj29, align 8
  %base221 = getelementptr inbounds %struct.QDict, ptr %171, i32 0, i32 0
  store ptr %base221, ptr %__mptr220, align 8
  %172 = load ptr, ptr %__mptr220, align 8
  %add.ptr223 = getelementptr i8, ptr %172, i64 0
  store ptr %add.ptr223, ptr %tmp222, align 8
  %173 = load ptr, ptr %tmp222, align 8
  br label %cond.end225

cond.false224:                                    ; preds = %if.end216
  br label %cond.end225

cond.end225:                                      ; preds = %cond.false224, %cond.true219
  %cond226 = phi ptr [ %173, %cond.true219 ], [ null, %cond.false224 ]
  store ptr %cond226, ptr %tmp217, align 8
  %174 = load ptr, ptr %tmp217, align 8
  call void @qobject_unref_impl(ptr noundef %174)
  store ptr null, ptr %options.addr, align 8
  %175 = load i32, ptr %snapshot_flags, align 4
  %tobool227 = icmp ne i32 %175, 0
  br i1 %tobool227, label %if.then228, label %if.end233

if.then228:                                       ; preds = %cond.end225
  %176 = load ptr, ptr %bs, align 8
  %177 = load i32, ptr %snapshot_flags, align 4
  %178 = load ptr, ptr %snapshot_options, align 8
  %call229 = call ptr @bdrv_append_temp_snapshot(ptr noundef %176, i32 noundef %177, ptr noundef %178, ptr noundef %local_err)
  store ptr %call229, ptr %snapshot_bs, align 8
  store ptr null, ptr %snapshot_options, align 8
  %179 = load ptr, ptr %local_err, align 8
  %tobool230 = icmp ne ptr %179, null
  br i1 %tobool230, label %if.then231, label %if.end232

if.then231:                                       ; preds = %if.then228
  br label %close_and_fail

if.end232:                                        ; preds = %if.then228
  %180 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %180)
  %181 = load ptr, ptr %bs, align 8
  call void @bdrv_unref(ptr noundef %181)
  %182 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %182)
  %183 = load ptr, ptr %snapshot_bs, align 8
  store ptr %183, ptr %bs, align 8
  br label %if.end233

if.end233:                                        ; preds = %if.end232, %cond.end225
  %184 = load ptr, ptr %bs, align 8
  store ptr %184, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

fail:                                             ; preds = %if.then178, %if.then149, %if.then143, %if.then127, %if.then118, %if.then85, %if.then63, %if.then45
  %185 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %185)
  %186 = load ptr, ptr %file, align 8
  call void @blk_unref(ptr noundef %186)
  %187 = load ptr, ptr %snapshot_options, align 8
  store ptr %187, ptr %_obj30, align 8
  %188 = load ptr, ptr %_obj30, align 8
  %tobool235 = icmp ne ptr %188, null
  br i1 %tobool235, label %cond.true236, label %cond.false241

cond.true236:                                     ; preds = %fail
  %189 = load ptr, ptr %_obj30, align 8
  %base238 = getelementptr inbounds %struct.QDict, ptr %189, i32 0, i32 0
  store ptr %base238, ptr %__mptr237, align 8
  %190 = load ptr, ptr %__mptr237, align 8
  %add.ptr240 = getelementptr i8, ptr %190, i64 0
  store ptr %add.ptr240, ptr %tmp239, align 8
  %191 = load ptr, ptr %tmp239, align 8
  br label %cond.end242

cond.false241:                                    ; preds = %fail
  br label %cond.end242

cond.end242:                                      ; preds = %cond.false241, %cond.true236
  %cond243 = phi ptr [ %191, %cond.true236 ], [ null, %cond.false241 ]
  store ptr %cond243, ptr %tmp234, align 8
  %192 = load ptr, ptr %tmp234, align 8
  call void @qobject_unref_impl(ptr noundef %192)
  %193 = load ptr, ptr %bs, align 8
  %explicit_options244 = getelementptr inbounds %struct.BlockDriverState, ptr %193, i32 0, i32 34
  %194 = load ptr, ptr %explicit_options244, align 8
  store ptr %194, ptr %_obj31, align 8
  %195 = load ptr, ptr %_obj31, align 8
  %tobool246 = icmp ne ptr %195, null
  br i1 %tobool246, label %cond.true247, label %cond.false252

cond.true247:                                     ; preds = %cond.end242
  %196 = load ptr, ptr %_obj31, align 8
  %base249 = getelementptr inbounds %struct.QDict, ptr %196, i32 0, i32 0
  store ptr %base249, ptr %__mptr248, align 8
  %197 = load ptr, ptr %__mptr248, align 8
  %add.ptr251 = getelementptr i8, ptr %197, i64 0
  store ptr %add.ptr251, ptr %tmp250, align 8
  %198 = load ptr, ptr %tmp250, align 8
  br label %cond.end253

cond.false252:                                    ; preds = %cond.end242
  br label %cond.end253

cond.end253:                                      ; preds = %cond.false252, %cond.true247
  %cond254 = phi ptr [ %198, %cond.true247 ], [ null, %cond.false252 ]
  store ptr %cond254, ptr %tmp245, align 8
  %199 = load ptr, ptr %tmp245, align 8
  call void @qobject_unref_impl(ptr noundef %199)
  %200 = load ptr, ptr %bs, align 8
  %options255 = getelementptr inbounds %struct.BlockDriverState, ptr %200, i32 0, i32 33
  %201 = load ptr, ptr %options255, align 8
  store ptr %201, ptr %_obj32, align 8
  %202 = load ptr, ptr %_obj32, align 8
  %tobool257 = icmp ne ptr %202, null
  br i1 %tobool257, label %cond.true258, label %cond.false263

cond.true258:                                     ; preds = %cond.end253
  %203 = load ptr, ptr %_obj32, align 8
  %base260 = getelementptr inbounds %struct.QDict, ptr %203, i32 0, i32 0
  store ptr %base260, ptr %__mptr259, align 8
  %204 = load ptr, ptr %__mptr259, align 8
  %add.ptr262 = getelementptr i8, ptr %204, i64 0
  store ptr %add.ptr262, ptr %tmp261, align 8
  %205 = load ptr, ptr %tmp261, align 8
  br label %cond.end264

cond.false263:                                    ; preds = %cond.end253
  br label %cond.end264

cond.end264:                                      ; preds = %cond.false263, %cond.true258
  %cond265 = phi ptr [ %205, %cond.true258 ], [ null, %cond.false263 ]
  store ptr %cond265, ptr %tmp256, align 8
  %206 = load ptr, ptr %tmp256, align 8
  call void @qobject_unref_impl(ptr noundef %206)
  %207 = load ptr, ptr %options.addr, align 8
  store ptr %207, ptr %_obj33, align 8
  %208 = load ptr, ptr %_obj33, align 8
  %tobool267 = icmp ne ptr %208, null
  br i1 %tobool267, label %cond.true268, label %cond.false273

cond.true268:                                     ; preds = %cond.end264
  %209 = load ptr, ptr %_obj33, align 8
  %base270 = getelementptr inbounds %struct.QDict, ptr %209, i32 0, i32 0
  store ptr %base270, ptr %__mptr269, align 8
  %210 = load ptr, ptr %__mptr269, align 8
  %add.ptr272 = getelementptr i8, ptr %210, i64 0
  store ptr %add.ptr272, ptr %tmp271, align 8
  %211 = load ptr, ptr %tmp271, align 8
  br label %cond.end274

cond.false273:                                    ; preds = %cond.end264
  br label %cond.end274

cond.end274:                                      ; preds = %cond.false273, %cond.true268
  %cond275 = phi ptr [ %211, %cond.true268 ], [ null, %cond.false273 ]
  store ptr %cond275, ptr %tmp266, align 8
  %212 = load ptr, ptr %tmp266, align 8
  call void @qobject_unref_impl(ptr noundef %212)
  %213 = load ptr, ptr %bs, align 8
  %options276 = getelementptr inbounds %struct.BlockDriverState, ptr %213, i32 0, i32 33
  store ptr null, ptr %options276, align 8
  %214 = load ptr, ptr %bs, align 8
  %explicit_options277 = getelementptr inbounds %struct.BlockDriverState, ptr %214, i32 0, i32 34
  store ptr null, ptr %explicit_options277, align 8
  %215 = load ptr, ptr %bs, align 8
  call void @bdrv_unref(ptr noundef %215)
  %216 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %216)
  %217 = load ptr, ptr %errp.addr, align 8
  %218 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %217, ptr noundef %218)
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

close_and_fail:                                   ; preds = %if.then231, %if.end215, %if.then191
  %219 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %219)
  %220 = load ptr, ptr %bs, align 8
  call void @bdrv_unref(ptr noundef %220)
  %221 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %221)
  %222 = load ptr, ptr %snapshot_options, align 8
  store ptr %222, ptr %_obj34, align 8
  %223 = load ptr, ptr %_obj34, align 8
  %tobool279 = icmp ne ptr %223, null
  br i1 %tobool279, label %cond.true280, label %cond.false285

cond.true280:                                     ; preds = %close_and_fail
  %224 = load ptr, ptr %_obj34, align 8
  %base282 = getelementptr inbounds %struct.QDict, ptr %224, i32 0, i32 0
  store ptr %base282, ptr %__mptr281, align 8
  %225 = load ptr, ptr %__mptr281, align 8
  %add.ptr284 = getelementptr i8, ptr %225, i64 0
  store ptr %add.ptr284, ptr %tmp283, align 8
  %226 = load ptr, ptr %tmp283, align 8
  br label %cond.end286

cond.false285:                                    ; preds = %close_and_fail
  br label %cond.end286

cond.end286:                                      ; preds = %cond.false285, %cond.true280
  %cond287 = phi ptr [ %226, %cond.true280 ], [ null, %cond.false285 ]
  store ptr %cond287, ptr %tmp278, align 8
  %227 = load ptr, ptr %tmp278, align 8
  call void @qobject_unref_impl(ptr noundef %227)
  %228 = load ptr, ptr %options.addr, align 8
  store ptr %228, ptr %_obj35, align 8
  %229 = load ptr, ptr %_obj35, align 8
  %tobool289 = icmp ne ptr %229, null
  br i1 %tobool289, label %cond.true290, label %cond.false295

cond.true290:                                     ; preds = %cond.end286
  %230 = load ptr, ptr %_obj35, align 8
  %base292 = getelementptr inbounds %struct.QDict, ptr %230, i32 0, i32 0
  store ptr %base292, ptr %__mptr291, align 8
  %231 = load ptr, ptr %__mptr291, align 8
  %add.ptr294 = getelementptr i8, ptr %231, i64 0
  store ptr %add.ptr294, ptr %tmp293, align 8
  %232 = load ptr, ptr %tmp293, align 8
  br label %cond.end296

cond.false295:                                    ; preds = %cond.end286
  br label %cond.end296

cond.end296:                                      ; preds = %cond.false295, %cond.true290
  %cond297 = phi ptr [ %232, %cond.true290 ], [ null, %cond.false295 ]
  store ptr %cond297, ptr %tmp288, align 8
  %233 = load ptr, ptr %tmp288, align 8
  call void @qobject_unref_impl(ptr noundef %233)
  %234 = load ptr, ptr %errp.addr, align 8
  %235 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %234, ptr noundef %235)
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %cond.end296, %cond.end274, %if.end233, %if.end37, %if.then36, %if.then32
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto27)
  %236 = load ptr, ptr %retval, align 8
  ret ptr %236
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_backing_role(ptr noundef %bs) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv1, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 2
  %4 = load i8, ptr %is_filter, align 4
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  store i32 20, ptr %retval, align 4
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  store i32 8, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load i32, ptr %retval, align 4
  ret i32 %5
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_refresh_filename(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %child = alloca ptr, align 8
  %primary_child_bs = alloca ptr, align 8
  %opts = alloca ptr, align 8
  %backing_overridden = alloca i8, align 1
  %generate_json_filename = alloca i8, align 1
  %_obj69 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp23 = alloca ptr, align 8
  %_o = alloca ptr, align 8
  %_obj70 = alloca ptr, align 8
  %tmp26 = alloca ptr, align 8
  %__mptr29 = alloca ptr, align 8
  %tmp31 = alloca ptr, align 8
  %tmp36 = alloca ptr, align 8
  %_obj72 = alloca ptr, align 8
  %_o66 = alloca ptr, align 8
  %_obj71 = alloca ptr, align 8
  %tmp69 = alloca ptr, align 8
  %__mptr72 = alloca ptr, align 8
  %tmp74 = alloca ptr, align 8
  %tmp79 = alloca ptr, align 8
  %tmp80 = alloca ptr, align 8
  %__mptr83 = alloca ptr, align 8
  %tmp85 = alloca ptr, align 8
  %_obj73 = alloca ptr, align 8
  %tmp103 = alloca ptr, align 8
  %__mptr106 = alloca ptr, align 8
  %tmp108 = alloca ptr, align 8
  %json = alloca ptr, align 8
  %_obj74 = alloca ptr, align 8
  %tmp154 = alloca ptr, align 8
  %__mptr157 = alloca ptr, align 8
  %tmp159 = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 8175, ptr noundef @__PRETTY_FUNCTION__.bdrv_refresh_filename) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %do.end
  br label %if.end179

if.end3:                                          ; preds = %do.end
  %3 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %4 = load ptr, ptr %lh_first, align 8
  store ptr %4, ptr %child, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %5 = load ptr, ptr %child, align 8
  %tobool4 = icmp ne ptr %5, null
  br i1 %tobool4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %child, align 8
  %bs5 = getelementptr inbounds %struct.BdrvChild, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %bs5, align 8
  call void @bdrv_refresh_filename(ptr noundef %7)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load ptr, ptr %child, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %8, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %9 = load ptr, ptr %le_next, align 8
  store ptr %9, ptr %child, align 8
  br label %for.cond, !llvm.loop !22

for.end:                                          ; preds = %for.cond
  %10 = load ptr, ptr %bs.addr, align 8
  %implicit = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 5
  %11 = load i8, ptr %implicit, align 8
  %tobool6 = trunc i8 %11 to i1
  br i1 %tobool6, label %if.then7, label %if.end38

if.then7:                                         ; preds = %for.end
  %12 = load ptr, ptr %bs.addr, align 8
  %children8 = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 29
  %lh_first9 = getelementptr inbounds %struct.anon.3, ptr %children8, i32 0, i32 0
  %13 = load ptr, ptr %lh_first9, align 8
  store ptr %13, ptr %child, align 8
  %14 = load ptr, ptr %child, align 8
  %next10 = getelementptr inbounds %struct.BdrvChild, ptr %14, i32 0, i32 9
  %le_next11 = getelementptr inbounds %struct.anon.14, ptr %next10, i32 0, i32 0
  %15 = load ptr, ptr %le_next11, align 8
  %cmp = icmp eq ptr %15, null
  br i1 %cmp, label %if.then12, label %if.else13

if.then12:                                        ; preds = %if.then7
  br label %if.end14

if.else13:                                        ; preds = %if.then7
  call void @__assert_fail(ptr noundef @.str.134, ptr noundef @.str.2, i32 noundef 8190, ptr noundef @__PRETTY_FUNCTION__.bdrv_refresh_filename) #16
  unreachable

if.end14:                                         ; preds = %if.then12
  %16 = load ptr, ptr %bs.addr, align 8
  %exact_filename = getelementptr inbounds %struct.BlockDriverState, ptr %16, i32 0, i32 16
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %exact_filename, i64 0, i64 0
  %17 = load ptr, ptr %child, align 8
  %bs15 = getelementptr inbounds %struct.BdrvChild, ptr %17, i32 0, i32 0
  %18 = load ptr, ptr %bs15, align 8
  %exact_filename16 = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 16
  %arraydecay17 = getelementptr inbounds [4096 x i8], ptr %exact_filename16, i64 0, i64 0
  call void @pstrcpy(ptr noundef %arraydecay, i32 noundef 4096, ptr noundef %arraydecay17)
  %19 = load ptr, ptr %bs.addr, align 8
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %19, i32 0, i32 11
  %arraydecay18 = getelementptr inbounds [4096 x i8], ptr %filename, i64 0, i64 0
  %20 = load ptr, ptr %child, align 8
  %bs19 = getelementptr inbounds %struct.BdrvChild, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %bs19, align 8
  %filename20 = getelementptr inbounds %struct.BlockDriverState, ptr %21, i32 0, i32 11
  %arraydecay21 = getelementptr inbounds [4096 x i8], ptr %filename20, i64 0, i64 0
  call void @pstrcpy(ptr noundef %arraydecay18, i32 noundef 4096, ptr noundef %arraydecay21)
  %22 = load ptr, ptr %bs.addr, align 8
  %full_open_options = getelementptr inbounds %struct.BlockDriverState, ptr %22, i32 0, i32 15
  %23 = load ptr, ptr %full_open_options, align 8
  store ptr %23, ptr %_obj69, align 8
  %24 = load ptr, ptr %_obj69, align 8
  %tobool22 = icmp ne ptr %24, null
  br i1 %tobool22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end14
  %25 = load ptr, ptr %_obj69, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %25, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %26 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %26, i64 0
  store ptr %add.ptr, ptr %tmp23, align 8
  %27 = load ptr, ptr %tmp23, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end14
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %27, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %28 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %28)
  %29 = load ptr, ptr %child, align 8
  %bs24 = getelementptr inbounds %struct.BdrvChild, ptr %29, i32 0, i32 0
  %30 = load ptr, ptr %bs24, align 8
  %full_open_options25 = getelementptr inbounds %struct.BlockDriverState, ptr %30, i32 0, i32 15
  %31 = load ptr, ptr %full_open_options25, align 8
  store ptr %31, ptr %_o, align 8
  %32 = load ptr, ptr %_o, align 8
  store ptr %32, ptr %_obj70, align 8
  %33 = load ptr, ptr %_obj70, align 8
  %tobool27 = icmp ne ptr %33, null
  br i1 %tobool27, label %cond.true28, label %cond.false33

cond.true28:                                      ; preds = %cond.end
  %34 = load ptr, ptr %_obj70, align 8
  %base30 = getelementptr inbounds %struct.QDict, ptr %34, i32 0, i32 0
  store ptr %base30, ptr %__mptr29, align 8
  %35 = load ptr, ptr %__mptr29, align 8
  %add.ptr32 = getelementptr i8, ptr %35, i64 0
  store ptr %add.ptr32, ptr %tmp31, align 8
  %36 = load ptr, ptr %tmp31, align 8
  br label %cond.end34

cond.false33:                                     ; preds = %cond.end
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false33, %cond.true28
  %cond35 = phi ptr [ %36, %cond.true28 ], [ null, %cond.false33 ]
  store ptr %cond35, ptr %tmp26, align 8
  %37 = load ptr, ptr %tmp26, align 8
  call void @qobject_ref_impl(ptr noundef %37)
  %38 = load ptr, ptr %_o, align 8
  store ptr %38, ptr %tmp36, align 8
  %39 = load ptr, ptr %tmp36, align 8
  %40 = load ptr, ptr %bs.addr, align 8
  %full_open_options37 = getelementptr inbounds %struct.BlockDriverState, ptr %40, i32 0, i32 15
  store ptr %39, ptr %full_open_options37, align 8
  br label %if.end179

if.end38:                                         ; preds = %for.end
  %41 = load ptr, ptr %bs.addr, align 8
  %call39 = call zeroext i1 @bdrv_backing_overridden(ptr noundef %41)
  %frombool = zext i1 %call39 to i8
  store i8 %frombool, ptr %backing_overridden, align 1
  %42 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %42, i32 0, i32 0
  %43 = load i32, ptr %open_flags, align 8
  %and = and i32 %43, 65536
  %tobool40 = icmp ne i32 %and, 0
  br i1 %tobool40, label %if.then41, label %if.end42

if.then41:                                        ; preds = %if.end38
  store i8 0, ptr %backing_overridden, align 1
  br label %if.end42

if.end42:                                         ; preds = %if.then41, %if.end38
  %call43 = call ptr @qdict_new()
  store ptr %call43, ptr %opts, align 8
  %44 = load ptr, ptr %opts, align 8
  %45 = load ptr, ptr %bs.addr, align 8
  %call44 = call zeroext i1 @append_strong_runtime_options(ptr noundef %44, ptr noundef %45)
  %frombool45 = zext i1 %call44 to i8
  store i8 %frombool45, ptr %generate_json_filename, align 1
  %46 = load i8, ptr %backing_overridden, align 1
  %tobool46 = trunc i8 %46 to i1
  %conv = zext i1 %tobool46 to i32
  %47 = load i8, ptr %generate_json_filename, align 1
  %tobool47 = trunc i8 %47 to i1
  %conv48 = zext i1 %tobool47 to i32
  %or = or i32 %conv48, %conv
  %tobool49 = icmp ne i32 %or, 0
  %frombool50 = zext i1 %tobool49 to i8
  store i8 %frombool50, ptr %generate_json_filename, align 1
  %48 = load ptr, ptr %drv, align 8
  %bdrv_gather_child_options = getelementptr inbounds %struct.BlockDriver, ptr %48, i32 0, i32 31
  %49 = load ptr, ptr %bdrv_gather_child_options, align 8
  %tobool51 = icmp ne ptr %49, null
  br i1 %tobool51, label %if.then52, label %if.else55

if.then52:                                        ; preds = %if.end42
  %50 = load ptr, ptr %drv, align 8
  %bdrv_gather_child_options53 = getelementptr inbounds %struct.BlockDriver, ptr %50, i32 0, i32 31
  %51 = load ptr, ptr %bdrv_gather_child_options53, align 8
  %52 = load ptr, ptr %bs.addr, align 8
  %53 = load ptr, ptr %opts, align 8
  %54 = load i8, ptr %backing_overridden, align 1
  %tobool54 = trunc i8 %54 to i1
  call void %51(ptr noundef %52, ptr noundef %53, i1 noundef zeroext %tobool54)
  br label %if.end101

if.else55:                                        ; preds = %if.end42
  %55 = load ptr, ptr %bs.addr, align 8
  %children56 = getelementptr inbounds %struct.BlockDriverState, ptr %55, i32 0, i32 29
  %lh_first57 = getelementptr inbounds %struct.anon.3, ptr %children56, i32 0, i32 0
  %56 = load ptr, ptr %lh_first57, align 8
  store ptr %56, ptr %child, align 8
  br label %for.cond58

for.cond58:                                       ; preds = %for.inc90, %if.else55
  %57 = load ptr, ptr %child, align 8
  %tobool59 = icmp ne ptr %57, null
  br i1 %tobool59, label %for.body60, label %for.end93

for.body60:                                       ; preds = %for.cond58
  %58 = load ptr, ptr %child, align 8
  %59 = load ptr, ptr %bs.addr, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %59, i32 0, i32 30
  %60 = load ptr, ptr %backing, align 8
  %cmp61 = icmp eq ptr %58, %60
  br i1 %cmp61, label %land.lhs.true, label %if.end65

land.lhs.true:                                    ; preds = %for.body60
  %61 = load i8, ptr %backing_overridden, align 1
  %tobool63 = trunc i8 %61 to i1
  br i1 %tobool63, label %if.end65, label %if.then64

if.then64:                                        ; preds = %land.lhs.true
  br label %for.inc90

if.end65:                                         ; preds = %land.lhs.true, %for.body60
  %62 = load ptr, ptr %opts, align 8
  %63 = load ptr, ptr %child, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %63, i32 0, i32 1
  %64 = load ptr, ptr %name, align 8
  %65 = load ptr, ptr %child, align 8
  %bs67 = getelementptr inbounds %struct.BdrvChild, ptr %65, i32 0, i32 0
  %66 = load ptr, ptr %bs67, align 8
  %full_open_options68 = getelementptr inbounds %struct.BlockDriverState, ptr %66, i32 0, i32 15
  %67 = load ptr, ptr %full_open_options68, align 8
  store ptr %67, ptr %_o66, align 8
  %68 = load ptr, ptr %_o66, align 8
  store ptr %68, ptr %_obj71, align 8
  %69 = load ptr, ptr %_obj71, align 8
  %tobool70 = icmp ne ptr %69, null
  br i1 %tobool70, label %cond.true71, label %cond.false76

cond.true71:                                      ; preds = %if.end65
  %70 = load ptr, ptr %_obj71, align 8
  %base73 = getelementptr inbounds %struct.QDict, ptr %70, i32 0, i32 0
  store ptr %base73, ptr %__mptr72, align 8
  %71 = load ptr, ptr %__mptr72, align 8
  %add.ptr75 = getelementptr i8, ptr %71, i64 0
  store ptr %add.ptr75, ptr %tmp74, align 8
  %72 = load ptr, ptr %tmp74, align 8
  br label %cond.end77

cond.false76:                                     ; preds = %if.end65
  br label %cond.end77

cond.end77:                                       ; preds = %cond.false76, %cond.true71
  %cond78 = phi ptr [ %72, %cond.true71 ], [ null, %cond.false76 ]
  store ptr %cond78, ptr %tmp69, align 8
  %73 = load ptr, ptr %tmp69, align 8
  call void @qobject_ref_impl(ptr noundef %73)
  %74 = load ptr, ptr %_o66, align 8
  store ptr %74, ptr %tmp79, align 8
  %75 = load ptr, ptr %tmp79, align 8
  store ptr %75, ptr %_obj72, align 8
  %76 = load ptr, ptr %_obj72, align 8
  %tobool81 = icmp ne ptr %76, null
  br i1 %tobool81, label %cond.true82, label %cond.false87

cond.true82:                                      ; preds = %cond.end77
  %77 = load ptr, ptr %_obj72, align 8
  %base84 = getelementptr inbounds %struct.QDict, ptr %77, i32 0, i32 0
  store ptr %base84, ptr %__mptr83, align 8
  %78 = load ptr, ptr %__mptr83, align 8
  %add.ptr86 = getelementptr i8, ptr %78, i64 0
  store ptr %add.ptr86, ptr %tmp85, align 8
  %79 = load ptr, ptr %tmp85, align 8
  br label %cond.end88

cond.false87:                                     ; preds = %cond.end77
  br label %cond.end88

cond.end88:                                       ; preds = %cond.false87, %cond.true82
  %cond89 = phi ptr [ %79, %cond.true82 ], [ null, %cond.false87 ]
  store ptr %cond89, ptr %tmp80, align 8
  %80 = load ptr, ptr %tmp80, align 8
  call void @qdict_put_obj(ptr noundef %62, ptr noundef %64, ptr noundef %80)
  br label %for.inc90

for.inc90:                                        ; preds = %cond.end88, %if.then64
  %81 = load ptr, ptr %child, align 8
  %next91 = getelementptr inbounds %struct.BdrvChild, ptr %81, i32 0, i32 9
  %le_next92 = getelementptr inbounds %struct.anon.14, ptr %next91, i32 0, i32 0
  %82 = load ptr, ptr %le_next92, align 8
  store ptr %82, ptr %child, align 8
  br label %for.cond58, !llvm.loop !23

for.end93:                                        ; preds = %for.cond58
  %83 = load i8, ptr %backing_overridden, align 1
  %tobool94 = trunc i8 %83 to i1
  br i1 %tobool94, label %land.lhs.true96, label %if.end100

land.lhs.true96:                                  ; preds = %for.end93
  %84 = load ptr, ptr %bs.addr, align 8
  %backing97 = getelementptr inbounds %struct.BlockDriverState, ptr %84, i32 0, i32 30
  %85 = load ptr, ptr %backing97, align 8
  %tobool98 = icmp ne ptr %85, null
  br i1 %tobool98, label %if.end100, label %if.then99

if.then99:                                        ; preds = %land.lhs.true96
  %86 = load ptr, ptr %opts, align 8
  call void @qdict_put_null(ptr noundef %86, ptr noundef @.str.89)
  br label %if.end100

if.end100:                                        ; preds = %if.then99, %land.lhs.true96, %for.end93
  br label %if.end101

if.end101:                                        ; preds = %if.end100, %if.then52
  %87 = load ptr, ptr %bs.addr, align 8
  %full_open_options102 = getelementptr inbounds %struct.BlockDriverState, ptr %87, i32 0, i32 15
  %88 = load ptr, ptr %full_open_options102, align 8
  store ptr %88, ptr %_obj73, align 8
  %89 = load ptr, ptr %_obj73, align 8
  %tobool104 = icmp ne ptr %89, null
  br i1 %tobool104, label %cond.true105, label %cond.false110

cond.true105:                                     ; preds = %if.end101
  %90 = load ptr, ptr %_obj73, align 8
  %base107 = getelementptr inbounds %struct.QDict, ptr %90, i32 0, i32 0
  store ptr %base107, ptr %__mptr106, align 8
  %91 = load ptr, ptr %__mptr106, align 8
  %add.ptr109 = getelementptr i8, ptr %91, i64 0
  store ptr %add.ptr109, ptr %tmp108, align 8
  %92 = load ptr, ptr %tmp108, align 8
  br label %cond.end111

cond.false110:                                    ; preds = %if.end101
  br label %cond.end111

cond.end111:                                      ; preds = %cond.false110, %cond.true105
  %cond112 = phi ptr [ %92, %cond.true105 ], [ null, %cond.false110 ]
  store ptr %cond112, ptr %tmp103, align 8
  %93 = load ptr, ptr %tmp103, align 8
  call void @qobject_unref_impl(ptr noundef %93)
  %94 = load ptr, ptr %opts, align 8
  %95 = load ptr, ptr %bs.addr, align 8
  %full_open_options113 = getelementptr inbounds %struct.BlockDriverState, ptr %95, i32 0, i32 15
  store ptr %94, ptr %full_open_options113, align 8
  %96 = load ptr, ptr %bs.addr, align 8
  %call114 = call ptr @bdrv_primary_bs(ptr noundef %96)
  store ptr %call114, ptr %primary_child_bs, align 8
  %97 = load ptr, ptr %drv, align 8
  %bdrv_refresh_filename = getelementptr inbounds %struct.BlockDriver, ptr %97, i32 0, i32 30
  %98 = load ptr, ptr %bdrv_refresh_filename, align 8
  %tobool115 = icmp ne ptr %98, null
  br i1 %tobool115, label %if.then116, label %if.else119

if.then116:                                       ; preds = %cond.end111
  %99 = load ptr, ptr %bs.addr, align 8
  %exact_filename117 = getelementptr inbounds %struct.BlockDriverState, ptr %99, i32 0, i32 16
  %arrayidx = getelementptr [4096 x i8], ptr %exact_filename117, i64 0, i64 0
  store i8 0, ptr %arrayidx, align 8
  %100 = load ptr, ptr %drv, align 8
  %bdrv_refresh_filename118 = getelementptr inbounds %struct.BlockDriver, ptr %100, i32 0, i32 30
  %101 = load ptr, ptr %bdrv_refresh_filename118, align 8
  %102 = load ptr, ptr %bs.addr, align 8
  call void %101(ptr noundef %102)
  br label %if.end143

if.else119:                                       ; preds = %cond.end111
  %103 = load ptr, ptr %primary_child_bs, align 8
  %tobool120 = icmp ne ptr %103, null
  br i1 %tobool120, label %if.then121, label %if.end142

if.then121:                                       ; preds = %if.else119
  %104 = load ptr, ptr %bs.addr, align 8
  %exact_filename122 = getelementptr inbounds %struct.BlockDriverState, ptr %104, i32 0, i32 16
  %arrayidx123 = getelementptr [4096 x i8], ptr %exact_filename122, i64 0, i64 0
  store i8 0, ptr %arrayidx123, align 8
  %105 = load ptr, ptr %primary_child_bs, align 8
  %exact_filename124 = getelementptr inbounds %struct.BlockDriverState, ptr %105, i32 0, i32 16
  %arrayidx125 = getelementptr [4096 x i8], ptr %exact_filename124, i64 0, i64 0
  %106 = load i8, ptr %arrayidx125, align 8
  %conv126 = sext i8 %106 to i32
  %tobool127 = icmp ne i32 %conv126, 0
  br i1 %tobool127, label %land.lhs.true128, label %if.end141

land.lhs.true128:                                 ; preds = %if.then121
  %107 = load ptr, ptr %primary_child_bs, align 8
  %drv129 = getelementptr inbounds %struct.BlockDriverState, ptr %107, i32 0, i32 6
  %108 = load ptr, ptr %drv129, align 8
  %bdrv_file_open = getelementptr inbounds %struct.BlockDriver, ptr %108, i32 0, i32 24
  %109 = load ptr, ptr %bdrv_file_open, align 8
  %tobool130 = icmp ne ptr %109, null
  br i1 %tobool130, label %land.lhs.true131, label %if.end141

land.lhs.true131:                                 ; preds = %land.lhs.true128
  %110 = load ptr, ptr %drv, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %110, i32 0, i32 2
  %111 = load i8, ptr %is_filter, align 4
  %tobool132 = trunc i8 %111 to i1
  br i1 %tobool132, label %if.end141, label %land.lhs.true133

land.lhs.true133:                                 ; preds = %land.lhs.true131
  %112 = load i8, ptr %generate_json_filename, align 1
  %tobool134 = trunc i8 %112 to i1
  br i1 %tobool134, label %if.end141, label %if.then135

if.then135:                                       ; preds = %land.lhs.true133
  %113 = load ptr, ptr %bs.addr, align 8
  %exact_filename136 = getelementptr inbounds %struct.BlockDriverState, ptr %113, i32 0, i32 16
  %arraydecay137 = getelementptr inbounds [4096 x i8], ptr %exact_filename136, i64 0, i64 0
  %114 = load ptr, ptr %primary_child_bs, align 8
  %exact_filename138 = getelementptr inbounds %struct.BlockDriverState, ptr %114, i32 0, i32 16
  %arraydecay139 = getelementptr inbounds [4096 x i8], ptr %exact_filename138, i64 0, i64 0
  %call140 = call ptr @strcpy(ptr noundef %arraydecay137, ptr noundef %arraydecay139) #15
  br label %if.end141

if.end141:                                        ; preds = %if.then135, %land.lhs.true133, %land.lhs.true131, %land.lhs.true128, %if.then121
  br label %if.end142

if.end142:                                        ; preds = %if.end141, %if.else119
  br label %if.end143

if.end143:                                        ; preds = %if.end142, %if.then116
  %115 = load ptr, ptr %bs.addr, align 8
  %exact_filename144 = getelementptr inbounds %struct.BlockDriverState, ptr %115, i32 0, i32 16
  %arrayidx145 = getelementptr [4096 x i8], ptr %exact_filename144, i64 0, i64 0
  %116 = load i8, ptr %arrayidx145, align 8
  %tobool146 = icmp ne i8 %116, 0
  br i1 %tobool146, label %if.then147, label %if.else152

if.then147:                                       ; preds = %if.end143
  %117 = load ptr, ptr %bs.addr, align 8
  %filename148 = getelementptr inbounds %struct.BlockDriverState, ptr %117, i32 0, i32 11
  %arraydecay149 = getelementptr inbounds [4096 x i8], ptr %filename148, i64 0, i64 0
  %118 = load ptr, ptr %bs.addr, align 8
  %exact_filename150 = getelementptr inbounds %struct.BlockDriverState, ptr %118, i32 0, i32 16
  %arraydecay151 = getelementptr inbounds [4096 x i8], ptr %exact_filename150, i64 0, i64 0
  call void @pstrcpy(ptr noundef %arraydecay149, i32 noundef 4096, ptr noundef %arraydecay151)
  br label %if.end179

if.else152:                                       ; preds = %if.end143
  %119 = load ptr, ptr %bs.addr, align 8
  %full_open_options153 = getelementptr inbounds %struct.BlockDriverState, ptr %119, i32 0, i32 15
  %120 = load ptr, ptr %full_open_options153, align 8
  store ptr %120, ptr %_obj74, align 8
  %121 = load ptr, ptr %_obj74, align 8
  %tobool155 = icmp ne ptr %121, null
  br i1 %tobool155, label %cond.true156, label %cond.false161

cond.true156:                                     ; preds = %if.else152
  %122 = load ptr, ptr %_obj74, align 8
  %base158 = getelementptr inbounds %struct.QDict, ptr %122, i32 0, i32 0
  store ptr %base158, ptr %__mptr157, align 8
  %123 = load ptr, ptr %__mptr157, align 8
  %add.ptr160 = getelementptr i8, ptr %123, i64 0
  store ptr %add.ptr160, ptr %tmp159, align 8
  %124 = load ptr, ptr %tmp159, align 8
  br label %cond.end162

cond.false161:                                    ; preds = %if.else152
  br label %cond.end162

cond.end162:                                      ; preds = %cond.false161, %cond.true156
  %cond163 = phi ptr [ %124, %cond.true156 ], [ null, %cond.false161 ]
  store ptr %cond163, ptr %tmp154, align 8
  %125 = load ptr, ptr %tmp154, align 8
  %call164 = call ptr @qobject_to_json(ptr noundef %125)
  store ptr %call164, ptr %json, align 8
  %126 = load ptr, ptr %bs.addr, align 8
  %filename165 = getelementptr inbounds %struct.BlockDriverState, ptr %126, i32 0, i32 11
  %arraydecay166 = getelementptr inbounds [4096 x i8], ptr %filename165, i64 0, i64 0
  %127 = load ptr, ptr %json, align 8
  %str = getelementptr inbounds %struct._GString, ptr %127, i32 0, i32 0
  %128 = load ptr, ptr %str, align 8
  %call167 = call i32 (ptr, i64, ptr, ...) @snprintf(ptr noundef %arraydecay166, i64 noundef 4096, ptr noundef @.str.135, ptr noundef %128) #15
  %conv168 = sext i32 %call167 to i64
  %cmp169 = icmp uge i64 %conv168, 4096
  br i1 %cmp169, label %if.then171, label %if.end177

if.then171:                                       ; preds = %cond.end162
  %129 = load ptr, ptr %bs.addr, align 8
  %filename172 = getelementptr inbounds %struct.BlockDriverState, ptr %129, i32 0, i32 11
  %arraydecay173 = getelementptr inbounds [4096 x i8], ptr %filename172, i64 0, i64 0
  %add.ptr174 = getelementptr i8, ptr %arraydecay173, i64 4096
  %add.ptr175 = getelementptr i8, ptr %add.ptr174, i64 -4
  %call176 = call ptr @strcpy(ptr noundef %add.ptr175, ptr noundef @.str.136) #15
  br label %if.end177

if.end177:                                        ; preds = %if.then171, %cond.end162
  %130 = load ptr, ptr %json, align 8
  %call178 = call ptr @g_string_free(ptr noundef %130, i32 noundef 1)
  br label %if.end179

if.end179:                                        ; preds = %if.end177, %if.then147, %cond.end34, %if.then2
  ret void
}

declare void @pstrcpy(ptr noundef, i32 noundef, ptr noundef) #2

declare void @aio_context_acquire(ptr noundef) #2

declare void @aio_context_release(ptr noundef) #2

declare void @qdict_del(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_open_child(ptr noundef %filename, ptr noundef %options, ptr noundef %bdref_key, ptr noundef %parent, ptr noundef %child_class, i32 noundef %child_role, i1 noundef zeroext %allow_none, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %bdref_key.addr = alloca ptr, align 8
  %parent.addr = alloca ptr, align 8
  %child_class.addr = alloca ptr, align 8
  %child_role.addr = alloca i32, align 4
  %allow_none.addr = alloca i8, align 1
  %errp.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %child = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store ptr %bdref_key, ptr %bdref_key.addr, align 8
  store ptr %parent, ptr %parent.addr, align 8
  store ptr %child_class, ptr %child_class.addr, align 8
  store i32 %child_role, ptr %child_role.addr, align 4
  %frombool = zext i1 %allow_none to i8
  store i8 %frombool, ptr %allow_none.addr, align 1
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3785, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_child) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %filename.addr, align 8
  %1 = load ptr, ptr %options.addr, align 8
  %2 = load ptr, ptr %bdref_key.addr, align 8
  %3 = load ptr, ptr %parent.addr, align 8
  %4 = load ptr, ptr %child_class.addr, align 8
  %5 = load i32, ptr %child_role.addr, align 4
  %6 = load i8, ptr %allow_none.addr, align 1
  %tobool = trunc i8 %6 to i1
  %7 = load ptr, ptr %errp.addr, align 8
  %call1 = call ptr @bdrv_open_child_bs(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef %3, ptr noundef %4, i32 noundef %5, i1 noundef zeroext %tobool, ptr noundef %7)
  store ptr %call1, ptr %bs, align 8
  %8 = load ptr, ptr %bs, align 8
  %cmp = icmp eq ptr %8, null
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %do.end
  call void @bdrv_graph_wrlock(ptr noundef null)
  %9 = load ptr, ptr %bs, align 8
  %call4 = call ptr @bdrv_get_aio_context(ptr noundef %9)
  store ptr %call4, ptr %ctx, align 8
  %10 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %10)
  %11 = load ptr, ptr %parent.addr, align 8
  %12 = load ptr, ptr %bs, align 8
  %13 = load ptr, ptr %bdref_key.addr, align 8
  %14 = load ptr, ptr %child_class.addr, align 8
  %15 = load i32, ptr %child_role.addr, align 4
  %16 = load ptr, ptr %errp.addr, align 8
  %call5 = call ptr @bdrv_attach_child(ptr noundef %11, ptr noundef %12, ptr noundef %13, ptr noundef %14, i32 noundef %15, ptr noundef %16)
  store ptr %call5, ptr %child, align 8
  %17 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %17)
  call void @bdrv_graph_wrunlock(ptr noundef null)
  %18 = load ptr, ptr %child, align 8
  store ptr %18, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2
  %19 = load ptr, ptr %retval, align 8
  ret ptr %19
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_open_child_bs(ptr noundef %filename, ptr noundef %options, ptr noundef %bdref_key, ptr noundef %parent, ptr noundef %child_class, i32 noundef %child_role, i1 noundef zeroext %allow_none, ptr noundef %errp) #0 {
entry:
  %filename.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %bdref_key.addr = alloca ptr, align 8
  %parent.addr = alloca ptr, align 8
  %child_class.addr = alloca ptr, align 8
  %child_role.addr = alloca i32, align 4
  %allow_none.addr = alloca i8, align 1
  %errp.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %image_options = alloca ptr, align 8
  %bdref_key_dot = alloca ptr, align 8
  %reference = alloca ptr, align 8
  %_obj24 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp11 = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store ptr %bdref_key, ptr %bdref_key.addr, align 8
  store ptr %parent, ptr %parent.addr, align 8
  store ptr %child_class, ptr %child_class.addr, align 8
  store i32 %child_role, ptr %child_role.addr, align 4
  %frombool = zext i1 %allow_none to i8
  store i8 %frombool, ptr %allow_none.addr, align 1
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %bs, align 8
  %0 = load ptr, ptr %child_class.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.216, ptr noundef @.str.2, i32 noundef 3722, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_child_bs) #16
  unreachable

if.end:                                           ; preds = %if.then
  %1 = load ptr, ptr %bdref_key.addr, align 8
  %call = call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef @.str.76, ptr noundef %1)
  store ptr %call, ptr %bdref_key_dot, align 8
  %2 = load ptr, ptr %options.addr, align 8
  %3 = load ptr, ptr %bdref_key_dot, align 8
  call void @qdict_extract_subqdict(ptr noundef %2, ptr noundef %image_options, ptr noundef %3)
  %4 = load ptr, ptr %bdref_key_dot, align 8
  call void @g_free(ptr noundef %4)
  %5 = load ptr, ptr %options.addr, align 8
  %6 = load ptr, ptr %bdref_key.addr, align 8
  %call1 = call ptr @qdict_get_try_str(ptr noundef %5, ptr noundef %6)
  store ptr %call1, ptr %reference, align 8
  %7 = load ptr, ptr %filename.addr, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %if.end12, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %8 = load ptr, ptr %reference, align 8
  %tobool2 = icmp ne ptr %8, null
  br i1 %tobool2, label %if.end12, label %land.lhs.true3

land.lhs.true3:                                   ; preds = %land.lhs.true
  %9 = load ptr, ptr %image_options, align 8
  %call4 = call i64 @qdict_size(ptr noundef %9)
  %tobool5 = icmp ne i64 %call4, 0
  br i1 %tobool5, label %if.end12, label %if.then6

if.then6:                                         ; preds = %land.lhs.true3
  %10 = load i8, ptr %allow_none.addr, align 1
  %tobool7 = trunc i8 %10 to i1
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %if.then6
  %11 = load ptr, ptr %errp.addr, align 8
  %12 = load ptr, ptr %bdref_key.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %11, ptr noundef @.str.2, i32 noundef 3739, ptr noundef @__func__.bdrv_open_child_bs, ptr noundef @.str.217, ptr noundef %12)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.then6
  %13 = load ptr, ptr %image_options, align 8
  store ptr %13, ptr %_obj24, align 8
  %14 = load ptr, ptr %_obj24, align 8
  %tobool10 = icmp ne ptr %14, null
  br i1 %tobool10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end9
  %15 = load ptr, ptr %_obj24, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %15, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %16 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %16, i64 0
  store ptr %add.ptr, ptr %tmp11, align 8
  %17 = load ptr, ptr %tmp11, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %17, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %18 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %18)
  br label %done

if.end12:                                         ; preds = %land.lhs.true3, %land.lhs.true, %if.end
  %19 = load ptr, ptr %filename.addr, align 8
  %20 = load ptr, ptr %reference, align 8
  %21 = load ptr, ptr %image_options, align 8
  %22 = load ptr, ptr %parent.addr, align 8
  %23 = load ptr, ptr %child_class.addr, align 8
  %24 = load i32, ptr %child_role.addr, align 4
  %25 = load ptr, ptr %errp.addr, align 8
  %call13 = call ptr @bdrv_open_inherit(ptr noundef %19, ptr noundef %20, ptr noundef %21, i32 noundef 0, ptr noundef %22, ptr noundef %23, i32 noundef %24, ptr noundef %25)
  store ptr %call13, ptr %bs, align 8
  %26 = load ptr, ptr %bs, align 8
  %tobool14 = icmp ne ptr %26, null
  br i1 %tobool14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.end12
  br label %done

if.end16:                                         ; preds = %if.end12
  br label %done

done:                                             ; preds = %if.end16, %if.then15, %cond.end
  %27 = load ptr, ptr %options.addr, align 8
  %28 = load ptr, ptr %bdref_key.addr, align 8
  call void @qdict_del(ptr noundef %27, ptr noundef %28)
  %29 = load ptr, ptr %bs, align 8
  ret ptr %29
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_open_file_child(ptr noundef %filename, ptr noundef %options, ptr noundef %bdref_key, ptr noundef %parent, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %filename.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %bdref_key.addr = alloca ptr, align 8
  %parent.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %role = alloca i32, align 4
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store ptr %bdref_key, ptr %bdref_key.addr, align 8
  store ptr %parent, ptr %parent.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %parent.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %filtered_child_is_backing = getelementptr inbounds %struct.BlockDriver, ptr %1, i32 0, i32 3
  %2 = load i8, ptr %filtered_child_is_backing, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.80, ptr noundef @.str.2, i32 noundef 3818, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_file_child) #16
  unreachable

if.end:                                           ; preds = %if.then
  %3 = load ptr, ptr %parent.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv1, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 2
  %5 = load i8, ptr %is_filter, align 4
  %tobool2 = trunc i8 %5 to i1
  %cond = select i1 %tobool2, i32 20, i32 19
  store i32 %cond, ptr %role, align 4
  %6 = load ptr, ptr %filename.addr, align 8
  %7 = load ptr, ptr %options.addr, align 8
  %8 = load ptr, ptr %bdref_key.addr, align 8
  %9 = load ptr, ptr %parent.addr, align 8
  %10 = load i32, ptr %role, align 4
  %11 = load ptr, ptr %errp.addr, align 8
  %call = call ptr @bdrv_open_child(ptr noundef %6, ptr noundef %7, ptr noundef %8, ptr noundef %9, ptr noundef @child_of_bds, i32 noundef %10, i1 noundef zeroext false, ptr noundef %11)
  %tobool3 = icmp ne ptr %call, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i32 -22, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end5, %if.then4
  %12 = load i32, ptr %retval, align 4
  ret i32 %12
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_open_blockdev_ref(ptr noundef %ref, ptr noundef %errp) #0 {
entry:
  %ref.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %obj = alloca ptr, align 8
  %qdict = alloca ptr, align 8
  %reference = alloca ptr, align 8
  %v = alloca ptr, align 8
  %options = alloca ptr, align 8
  %_obj25 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp14 = alloca ptr, align 8
  store ptr %ref, ptr %ref.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %bs, align 8
  store ptr null, ptr %obj, align 8
  store ptr null, ptr %qdict, align 8
  store ptr null, ptr %reference, align 8
  store ptr null, ptr %v, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3843, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_blockdev_ref) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %ref.addr, align 8
  %type = getelementptr inbounds %struct.BlockdevRef, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  %cmp = icmp eq i32 %1, 3
  br i1 %cmp, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.end
  %2 = load ptr, ptr %ref.addr, align 8
  %u = getelementptr inbounds %struct.BlockdevRef, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %u, align 8
  store ptr %3, ptr %reference, align 8
  br label %if.end12

if.else2:                                         ; preds = %do.end
  %4 = load ptr, ptr %ref.addr, align 8
  %u3 = getelementptr inbounds %struct.BlockdevRef, ptr %4, i32 0, i32 1
  store ptr %u3, ptr %options, align 8
  %5 = load ptr, ptr %ref.addr, align 8
  %type4 = getelementptr inbounds %struct.BlockdevRef, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %type4, align 8
  %cmp5 = icmp eq i32 %6, 4
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.else2
  br label %if.end8

if.else7:                                         ; preds = %if.else2
  call void @__assert_fail(ptr noundef @.str.81, ptr noundef @.str.2, i32 noundef 3849, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_blockdev_ref) #16
  unreachable

if.end8:                                          ; preds = %if.then6
  %call9 = call ptr @qobject_output_visitor_new(ptr noundef %obj)
  store ptr %call9, ptr %v, align 8
  %7 = load ptr, ptr %v, align 8
  %call10 = call zeroext i1 @visit_type_BlockdevOptions(ptr noundef %7, ptr noundef null, ptr noundef %options, ptr noundef @error_abort)
  %8 = load ptr, ptr %v, align 8
  call void @visit_complete(ptr noundef %8, ptr noundef %obj)
  %9 = load ptr, ptr %obj, align 8
  %call11 = call ptr @qobject_check_type(ptr noundef %9, i32 noundef 4)
  store ptr %call11, ptr %qdict, align 8
  %10 = load ptr, ptr %qdict, align 8
  call void @qdict_flatten(ptr noundef %10)
  %11 = load ptr, ptr %qdict, align 8
  call void @qdict_set_default_str(ptr noundef %11, ptr noundef @.str.47, ptr noundef @.str.34)
  %12 = load ptr, ptr %qdict, align 8
  call void @qdict_set_default_str(ptr noundef %12, ptr noundef @.str.49, ptr noundef @.str.34)
  %13 = load ptr, ptr %qdict, align 8
  call void @qdict_set_default_str(ptr noundef %13, ptr noundef @.str.51, ptr noundef @.str.34)
  %14 = load ptr, ptr %qdict, align 8
  call void @qdict_set_default_str(ptr noundef %14, ptr noundef @.str.53, ptr noundef @.str.34)
  br label %if.end12

if.end12:                                         ; preds = %if.end8, %if.then1
  %15 = load ptr, ptr %reference, align 8
  %16 = load ptr, ptr %qdict, align 8
  %17 = load ptr, ptr %errp.addr, align 8
  %call13 = call ptr @bdrv_open_inherit(ptr noundef null, ptr noundef %15, ptr noundef %16, i32 noundef 0, ptr noundef null, ptr noundef null, i32 noundef 0, ptr noundef %17)
  store ptr %call13, ptr %bs, align 8
  store ptr null, ptr %obj, align 8
  %18 = load ptr, ptr %obj, align 8
  store ptr %18, ptr %_obj25, align 8
  %19 = load ptr, ptr %_obj25, align 8
  %tobool = icmp ne ptr %19, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end12
  %20 = load ptr, ptr %_obj25, align 8
  %base = getelementptr inbounds %struct.QObject, ptr %20, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %21 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %21, i64 0
  store ptr %add.ptr, ptr %tmp14, align 8
  %22 = load ptr, ptr %tmp14, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end12
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %22, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %23 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %23)
  %24 = load ptr, ptr %v, align 8
  call void @visit_free(ptr noundef %24)
  %25 = load ptr, ptr %bs, align 8
  ret ptr %25
}

declare ptr @qobject_output_visitor_new(ptr noundef) #2

declare zeroext i1 @visit_type_BlockdevOptions(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #2

declare void @visit_complete(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @qobject_check_type(ptr noundef %obj, i32 noundef %type) #0 {
entry:
  %retval = alloca ptr, align 8
  %obj.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  store ptr %obj, ptr %obj.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  %0 = load ptr, ptr %obj.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %obj.addr, align 8
  %call = call i32 @qobject_type(ptr noundef %1)
  %2 = load i32, ptr %type.addr, align 4
  %cmp = icmp eq i32 %call, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %3 = load ptr, ptr %obj.addr, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

declare void @qdict_flatten(ptr noundef) #2

declare void @qdict_set_default_str(ptr noundef, ptr noundef, ptr noundef) #2

declare void @visit_free(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_open(ptr noundef %filename, ptr noundef %reference, ptr noundef %options, i32 noundef %flags, ptr noundef %errp) #0 {
entry:
  %filename.addr = alloca ptr, align 8
  %reference.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %errp.addr = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %reference, ptr %reference.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 4270, ptr noundef @__PRETTY_FUNCTION__.bdrv_open) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %filename.addr, align 8
  %1 = load ptr, ptr %reference.addr, align 8
  %2 = load ptr, ptr %options.addr, align 8
  %3 = load i32, ptr %flags.addr, align 4
  %4 = load ptr, ptr %errp.addr, align 8
  %call1 = call ptr @bdrv_open_inherit(ptr noundef %0, ptr noundef %1, ptr noundef %2, i32 noundef %3, ptr noundef null, ptr noundef null, i32 noundef 0, ptr noundef %4)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_reopen_queue(ptr noundef %bs_queue, ptr noundef %bs, ptr noundef %options, i1 noundef zeroext %keep_old_opts) #0 {
entry:
  %bs_queue.addr = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %keep_old_opts.addr = alloca i8, align 1
  %graph_lockable_auto41 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  store ptr %bs_queue, ptr %bs_queue.addr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  %frombool = zext i1 %keep_old_opts to i8
  store i8 %frombool, ptr %keep_old_opts.addr, align 1
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 4530, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_queue) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call1, ptr %graph_lockable_auto41, align 8
  %0 = load ptr, ptr %bs_queue.addr, align 8
  %1 = load ptr, ptr %bs.addr, align 8
  %2 = load ptr, ptr %options.addr, align 8
  %3 = load i8, ptr %keep_old_opts.addr, align 1
  %tobool = trunc i8 %3 to i1
  %call2 = call ptr @bdrv_reopen_queue_child(ptr noundef %0, ptr noundef %1, ptr noundef %2, ptr noundef null, i32 noundef 0, i1 noundef zeroext false, ptr noundef null, i32 noundef 0, i1 noundef zeroext %tobool)
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto41)
  ret ptr %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_reopen_queue_child(ptr noundef %bs_queue, ptr noundef %bs, ptr noundef %options, ptr noundef %klass, i32 noundef %role, i1 noundef zeroext %parent_is_format, ptr noundef %parent_options, i32 noundef %parent_flags, i1 noundef zeroext %keep_old_opts) #0 {
entry:
  %bs_queue.addr = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %klass.addr = alloca ptr, align 8
  %role.addr = alloca i32, align 4
  %parent_is_format.addr = alloca i8, align 1
  %parent_options.addr = alloca ptr, align 8
  %parent_flags.addr = alloca i32, align 4
  %keep_old_opts.addr = alloca i8, align 1
  %bs_entry = alloca ptr, align 8
  %child = alloca ptr, align 8
  %old_options = alloca ptr, align 8
  %explicit_options = alloca ptr, align 8
  %options_copy = alloca ptr, align 8
  %flags = alloca i32, align 4
  %opts = alloca ptr, align 8
  %_obj36 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp30 = alloca ptr, align 8
  %_obj37 = alloca ptr, align 8
  %tmp46 = alloca ptr, align 8
  %__mptr49 = alloca ptr, align 8
  %tmp51 = alloca ptr, align 8
  %_obj38 = alloca ptr, align 8
  %tmp60 = alloca ptr, align 8
  %__mptr63 = alloca ptr, align 8
  %tmp65 = alloca ptr, align 8
  %_obj39 = alloca ptr, align 8
  %tmp89 = alloca ptr, align 8
  %__mptr92 = alloca ptr, align 8
  %tmp94 = alloca ptr, align 8
  %_obj40 = alloca ptr, align 8
  %tmp101 = alloca ptr, align 8
  %__mptr104 = alloca ptr, align 8
  %tmp106 = alloca ptr, align 8
  %new_child_options = alloca ptr, align 8
  %child_keep_old = alloca i8, align 1
  %childref = alloca ptr, align 8
  %child_key_dot = alloca ptr, align 8
  store ptr %bs_queue, ptr %bs_queue.addr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store ptr %klass, ptr %klass.addr, align 8
  store i32 %role, ptr %role.addr, align 4
  %frombool = zext i1 %parent_is_format to i8
  store i8 %frombool, ptr %parent_is_format.addr, align 1
  store ptr %parent_options, ptr %parent_options.addr, align 8
  store i32 %parent_flags, ptr %parent_flags.addr, align 4
  %frombool1 = zext i1 %keep_old_opts to i8
  store i8 %frombool1, ptr %keep_old_opts.addr, align 1
  %0 = load ptr, ptr %bs.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.22, ptr noundef @.str.2, i32 noundef 4375, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_queue_child) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then2, label %if.else3

if.then2:                                         ; preds = %do.body
  br label %if.end4

if.else3:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 4383, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_queue_child) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  br label %do.end

do.end:                                           ; preds = %if.end4
  %1 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_drained_begin(ptr noundef %1)
  %2 = load ptr, ptr %bs_queue.addr, align 8
  %cmp5 = icmp eq ptr %2, null
  br i1 %cmp5, label %if.then6, label %if.end10

if.then6:                                         ; preds = %do.end
  %call7 = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 16) #17
  store ptr %call7, ptr %bs_queue.addr, align 8
  br label %do.body8

do.body8:                                         ; preds = %if.then6
  %3 = load ptr, ptr %bs_queue.addr, align 8
  store ptr null, ptr %3, align 8
  %4 = load ptr, ptr %bs_queue.addr, align 8
  %5 = load ptr, ptr %bs_queue.addr, align 8
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %5, i32 0, i32 1
  store ptr %4, ptr %tql_prev, align 8
  br label %do.end9

do.end9:                                          ; preds = %do.body8
  br label %if.end10

if.end10:                                         ; preds = %do.end9, %do.end
  %6 = load ptr, ptr %options.addr, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.end13, label %if.then11

if.then11:                                        ; preds = %if.end10
  %call12 = call ptr @qdict_new()
  store ptr %call12, ptr %options.addr, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end10
  %7 = load ptr, ptr %bs_queue.addr, align 8
  %8 = load ptr, ptr %7, align 8
  store ptr %8, ptr %bs_entry, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end13
  %9 = load ptr, ptr %bs_entry, align 8
  %tobool14 = icmp ne ptr %9, null
  br i1 %tobool14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %bs.addr, align 8
  %11 = load ptr, ptr %bs_entry, align 8
  %state = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %11, i32 0, i32 1
  %bs15 = getelementptr inbounds %struct.BDRVReopenState, ptr %state, i32 0, i32 0
  %12 = load ptr, ptr %bs15, align 8
  %cmp16 = icmp eq ptr %10, %12
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.body
  br label %for.end

if.end18:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end18
  %13 = load ptr, ptr %bs_entry, align 8
  %entry19 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %entry19, align 8
  store ptr %14, ptr %bs_entry, align 8
  br label %for.cond, !llvm.loop !24

for.end:                                          ; preds = %if.then17, %for.cond
  %15 = load ptr, ptr %bs_entry, align 8
  %tobool20 = icmp ne ptr %15, null
  br i1 %tobool20, label %if.then22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %16 = load i8, ptr %keep_old_opts.addr, align 1
  %tobool21 = trunc i8 %16 to i1
  br i1 %tobool21, label %if.then22, label %if.end34

if.then22:                                        ; preds = %lor.lhs.false, %for.end
  %17 = load ptr, ptr %bs_entry, align 8
  %tobool23 = icmp ne ptr %17, null
  br i1 %tobool23, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then22
  %18 = load ptr, ptr %bs_entry, align 8
  %state24 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %18, i32 0, i32 1
  %explicit_options25 = getelementptr inbounds %struct.BDRVReopenState, ptr %state24, i32 0, i32 7
  %19 = load ptr, ptr %explicit_options25, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then22
  %20 = load ptr, ptr %bs.addr, align 8
  %explicit_options26 = getelementptr inbounds %struct.BlockDriverState, ptr %20, i32 0, i32 34
  %21 = load ptr, ptr %explicit_options26, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %19, %cond.true ], [ %21, %cond.false ]
  %call27 = call ptr @qdict_clone_shallow(ptr noundef %cond)
  store ptr %call27, ptr %old_options, align 8
  %22 = load ptr, ptr %bs.addr, align 8
  %23 = load ptr, ptr %options.addr, align 8
  %24 = load ptr, ptr %old_options, align 8
  call void @bdrv_join_options(ptr noundef %22, ptr noundef %23, ptr noundef %24)
  %25 = load ptr, ptr %old_options, align 8
  store ptr %25, ptr %_obj36, align 8
  %26 = load ptr, ptr %_obj36, align 8
  %tobool28 = icmp ne ptr %26, null
  br i1 %tobool28, label %cond.true29, label %cond.false31

cond.true29:                                      ; preds = %cond.end
  %27 = load ptr, ptr %_obj36, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %27, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %28 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %28, i64 0
  store ptr %add.ptr, ptr %tmp30, align 8
  %29 = load ptr, ptr %tmp30, align 8
  br label %cond.end32

cond.false31:                                     ; preds = %cond.end
  br label %cond.end32

cond.end32:                                       ; preds = %cond.false31, %cond.true29
  %cond33 = phi ptr [ %29, %cond.true29 ], [ null, %cond.false31 ]
  store ptr %cond33, ptr %tmp, align 8
  %30 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %30)
  br label %if.end34

if.end34:                                         ; preds = %cond.end32, %lor.lhs.false
  %31 = load ptr, ptr %options.addr, align 8
  %call35 = call ptr @qdict_clone_shallow(ptr noundef %31)
  store ptr %call35, ptr %explicit_options, align 8
  %32 = load ptr, ptr %parent_options.addr, align 8
  %tobool36 = icmp ne ptr %32, null
  br i1 %tobool36, label %if.then37, label %if.else39

if.then37:                                        ; preds = %if.end34
  store i32 0, ptr %flags, align 4
  %33 = load ptr, ptr %klass.addr, align 8
  %inherit_options = getelementptr inbounds %struct.BdrvChildClass, ptr %33, i32 0, i32 2
  %34 = load ptr, ptr %inherit_options, align 8
  %35 = load i32, ptr %role.addr, align 4
  %36 = load i8, ptr %parent_is_format.addr, align 1
  %tobool38 = trunc i8 %36 to i1
  %37 = load ptr, ptr %options.addr, align 8
  %38 = load i32, ptr %parent_flags.addr, align 4
  %39 = load ptr, ptr %parent_options.addr, align 8
  call void %34(i32 noundef %35, i1 noundef zeroext %tobool38, ptr noundef %flags, ptr noundef %37, i32 noundef %38, ptr noundef %39)
  br label %if.end41

if.else39:                                        ; preds = %if.end34
  %40 = load ptr, ptr %bs.addr, align 8
  %call40 = call i32 @bdrv_get_flags(ptr noundef %40)
  store i32 %call40, ptr %flags, align 4
  br label %if.end41

if.end41:                                         ; preds = %if.else39, %if.then37
  %41 = load i8, ptr %keep_old_opts.addr, align 1
  %tobool42 = trunc i8 %41 to i1
  br i1 %tobool42, label %if.then43, label %if.end56

if.then43:                                        ; preds = %if.end41
  %42 = load ptr, ptr %bs.addr, align 8
  %options44 = getelementptr inbounds %struct.BlockDriverState, ptr %42, i32 0, i32 33
  %43 = load ptr, ptr %options44, align 8
  %call45 = call ptr @qdict_clone_shallow(ptr noundef %43)
  store ptr %call45, ptr %old_options, align 8
  %44 = load ptr, ptr %bs.addr, align 8
  %45 = load ptr, ptr %options.addr, align 8
  %46 = load ptr, ptr %old_options, align 8
  call void @bdrv_join_options(ptr noundef %44, ptr noundef %45, ptr noundef %46)
  %47 = load ptr, ptr %old_options, align 8
  store ptr %47, ptr %_obj37, align 8
  %48 = load ptr, ptr %_obj37, align 8
  %tobool47 = icmp ne ptr %48, null
  br i1 %tobool47, label %cond.true48, label %cond.false53

cond.true48:                                      ; preds = %if.then43
  %49 = load ptr, ptr %_obj37, align 8
  %base50 = getelementptr inbounds %struct.QDict, ptr %49, i32 0, i32 0
  store ptr %base50, ptr %__mptr49, align 8
  %50 = load ptr, ptr %__mptr49, align 8
  %add.ptr52 = getelementptr i8, ptr %50, i64 0
  store ptr %add.ptr52, ptr %tmp51, align 8
  %51 = load ptr, ptr %tmp51, align 8
  br label %cond.end54

cond.false53:                                     ; preds = %if.then43
  br label %cond.end54

cond.end54:                                       ; preds = %cond.false53, %cond.true48
  %cond55 = phi ptr [ %51, %cond.true48 ], [ null, %cond.false53 ]
  store ptr %cond55, ptr %tmp46, align 8
  %52 = load ptr, ptr %tmp46, align 8
  call void @qobject_unref_impl(ptr noundef %52)
  br label %if.end56

if.end56:                                         ; preds = %cond.end54, %if.end41
  %53 = load ptr, ptr %options.addr, align 8
  %call57 = call ptr @qdict_clone_shallow(ptr noundef %53)
  store ptr %call57, ptr %options_copy, align 8
  %call58 = call ptr @qemu_opts_create(ptr noundef @bdrv_runtime_opts, ptr noundef null, i32 noundef 0, ptr noundef @error_abort)
  store ptr %call58, ptr %opts, align 8
  %54 = load ptr, ptr %opts, align 8
  %55 = load ptr, ptr %options_copy, align 8
  %call59 = call zeroext i1 @qemu_opts_absorb_qdict(ptr noundef %54, ptr noundef %55, ptr noundef null)
  %56 = load ptr, ptr %opts, align 8
  call void @update_flags_from_options(ptr noundef %flags, ptr noundef %56)
  %57 = load ptr, ptr %opts, align 8
  call void @qemu_opts_del(ptr noundef %57)
  %58 = load ptr, ptr %options_copy, align 8
  store ptr %58, ptr %_obj38, align 8
  %59 = load ptr, ptr %_obj38, align 8
  %tobool61 = icmp ne ptr %59, null
  br i1 %tobool61, label %cond.true62, label %cond.false67

cond.true62:                                      ; preds = %if.end56
  %60 = load ptr, ptr %_obj38, align 8
  %base64 = getelementptr inbounds %struct.QDict, ptr %60, i32 0, i32 0
  store ptr %base64, ptr %__mptr63, align 8
  %61 = load ptr, ptr %__mptr63, align 8
  %add.ptr66 = getelementptr i8, ptr %61, i64 0
  store ptr %add.ptr66, ptr %tmp65, align 8
  %62 = load ptr, ptr %tmp65, align 8
  br label %cond.end68

cond.false67:                                     ; preds = %if.end56
  br label %cond.end68

cond.end68:                                       ; preds = %cond.false67, %cond.true62
  %cond69 = phi ptr [ %62, %cond.true62 ], [ null, %cond.false67 ]
  store ptr %cond69, ptr %tmp60, align 8
  %63 = load ptr, ptr %tmp60, align 8
  call void @qobject_unref_impl(ptr noundef %63)
  %64 = load i32, ptr %flags, align 4
  %and = and i32 %64, -32769
  store i32 %and, ptr %flags, align 4
  %65 = load i32, ptr %flags, align 4
  %and70 = and i32 %65, 2
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %if.then72, label %if.end73

if.then72:                                        ; preds = %cond.end68
  %66 = load i32, ptr %flags, align 4
  %or = or i32 %66, 8192
  store i32 %or, ptr %flags, align 4
  br label %if.end73

if.end73:                                         ; preds = %if.then72, %cond.end68
  %67 = load ptr, ptr %bs_entry, align 8
  %tobool74 = icmp ne ptr %67, null
  br i1 %tobool74, label %if.else86, label %if.then75

if.then75:                                        ; preds = %if.end73
  %call76 = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 88) #17
  store ptr %call76, ptr %bs_entry, align 8
  br label %do.body77

do.body77:                                        ; preds = %if.then75
  %68 = load ptr, ptr %bs_entry, align 8
  %entry78 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %68, i32 0, i32 2
  store ptr null, ptr %entry78, align 8
  %69 = load ptr, ptr %bs_queue.addr, align 8
  %tql_prev79 = getelementptr inbounds %struct.QTailQLink, ptr %69, i32 0, i32 1
  %70 = load ptr, ptr %tql_prev79, align 8
  %71 = load ptr, ptr %bs_entry, align 8
  %entry80 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %71, i32 0, i32 2
  %tql_prev81 = getelementptr inbounds %struct.QTailQLink, ptr %entry80, i32 0, i32 1
  store ptr %70, ptr %tql_prev81, align 8
  %72 = load ptr, ptr %bs_entry, align 8
  %73 = load ptr, ptr %bs_queue.addr, align 8
  %tql_prev82 = getelementptr inbounds %struct.QTailQLink, ptr %73, i32 0, i32 1
  %74 = load ptr, ptr %tql_prev82, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %74, i32 0, i32 0
  store ptr %72, ptr %tql_next, align 8
  %75 = load ptr, ptr %bs_entry, align 8
  %entry83 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %75, i32 0, i32 2
  %76 = load ptr, ptr %bs_queue.addr, align 8
  %tql_prev84 = getelementptr inbounds %struct.QTailQLink, ptr %76, i32 0, i32 1
  store ptr %entry83, ptr %tql_prev84, align 8
  br label %do.end85

do.end85:                                         ; preds = %do.body77
  br label %if.end111

if.else86:                                        ; preds = %if.end73
  %77 = load ptr, ptr %bs_entry, align 8
  %state87 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %77, i32 0, i32 1
  %options88 = getelementptr inbounds %struct.BDRVReopenState, ptr %state87, i32 0, i32 6
  %78 = load ptr, ptr %options88, align 8
  store ptr %78, ptr %_obj39, align 8
  %79 = load ptr, ptr %_obj39, align 8
  %tobool90 = icmp ne ptr %79, null
  br i1 %tobool90, label %cond.true91, label %cond.false96

cond.true91:                                      ; preds = %if.else86
  %80 = load ptr, ptr %_obj39, align 8
  %base93 = getelementptr inbounds %struct.QDict, ptr %80, i32 0, i32 0
  store ptr %base93, ptr %__mptr92, align 8
  %81 = load ptr, ptr %__mptr92, align 8
  %add.ptr95 = getelementptr i8, ptr %81, i64 0
  store ptr %add.ptr95, ptr %tmp94, align 8
  %82 = load ptr, ptr %tmp94, align 8
  br label %cond.end97

cond.false96:                                     ; preds = %if.else86
  br label %cond.end97

cond.end97:                                       ; preds = %cond.false96, %cond.true91
  %cond98 = phi ptr [ %82, %cond.true91 ], [ null, %cond.false96 ]
  store ptr %cond98, ptr %tmp89, align 8
  %83 = load ptr, ptr %tmp89, align 8
  call void @qobject_unref_impl(ptr noundef %83)
  %84 = load ptr, ptr %bs_entry, align 8
  %state99 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %84, i32 0, i32 1
  %explicit_options100 = getelementptr inbounds %struct.BDRVReopenState, ptr %state99, i32 0, i32 7
  %85 = load ptr, ptr %explicit_options100, align 8
  store ptr %85, ptr %_obj40, align 8
  %86 = load ptr, ptr %_obj40, align 8
  %tobool102 = icmp ne ptr %86, null
  br i1 %tobool102, label %cond.true103, label %cond.false108

cond.true103:                                     ; preds = %cond.end97
  %87 = load ptr, ptr %_obj40, align 8
  %base105 = getelementptr inbounds %struct.QDict, ptr %87, i32 0, i32 0
  store ptr %base105, ptr %__mptr104, align 8
  %88 = load ptr, ptr %__mptr104, align 8
  %add.ptr107 = getelementptr i8, ptr %88, i64 0
  store ptr %add.ptr107, ptr %tmp106, align 8
  %89 = load ptr, ptr %tmp106, align 8
  br label %cond.end109

cond.false108:                                    ; preds = %cond.end97
  br label %cond.end109

cond.end109:                                      ; preds = %cond.false108, %cond.true103
  %cond110 = phi ptr [ %89, %cond.true103 ], [ null, %cond.false108 ]
  store ptr %cond110, ptr %tmp101, align 8
  %90 = load ptr, ptr %tmp101, align 8
  call void @qobject_unref_impl(ptr noundef %90)
  br label %if.end111

if.end111:                                        ; preds = %cond.end109, %do.end85
  %91 = load ptr, ptr %bs.addr, align 8
  %92 = load ptr, ptr %bs_entry, align 8
  %state112 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %92, i32 0, i32 1
  %bs113 = getelementptr inbounds %struct.BDRVReopenState, ptr %state112, i32 0, i32 0
  store ptr %91, ptr %bs113, align 8
  %93 = load ptr, ptr %options.addr, align 8
  %94 = load ptr, ptr %bs_entry, align 8
  %state114 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %94, i32 0, i32 1
  %options115 = getelementptr inbounds %struct.BDRVReopenState, ptr %state114, i32 0, i32 6
  store ptr %93, ptr %options115, align 8
  %95 = load ptr, ptr %explicit_options, align 8
  %96 = load ptr, ptr %bs_entry, align 8
  %state116 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %96, i32 0, i32 1
  %explicit_options117 = getelementptr inbounds %struct.BDRVReopenState, ptr %state116, i32 0, i32 7
  store ptr %95, ptr %explicit_options117, align 8
  %97 = load i32, ptr %flags, align 4
  %98 = load ptr, ptr %bs_entry, align 8
  %state118 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %98, i32 0, i32 1
  %flags119 = getelementptr inbounds %struct.BDRVReopenState, ptr %state118, i32 0, i32 1
  store i32 %97, ptr %flags119, align 8
  %99 = load i8, ptr %keep_old_opts.addr, align 1
  %tobool120 = trunc i8 %99 to i1
  br i1 %tobool120, label %if.end128, label %if.then121

if.then121:                                       ; preds = %if.end111
  %100 = load ptr, ptr %options.addr, align 8
  %call122 = call i32 @qdict_haskey(ptr noundef %100, ptr noundef @.str.89)
  %tobool123 = icmp ne i32 %call122, 0
  br i1 %tobool123, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.then121
  %101 = load ptr, ptr %options.addr, align 8
  %call124 = call i32 @qdict_haskey(ptr noundef %101, ptr noundef @.str.256)
  %tobool125 = icmp ne i32 %call124, 0
  %lnot = xor i1 %tobool125, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then121
  %102 = phi i1 [ false, %if.then121 ], [ %lnot, %land.rhs ]
  %103 = load ptr, ptr %bs_entry, align 8
  %state126 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %103, i32 0, i32 1
  %backing_missing = getelementptr inbounds %struct.BDRVReopenState, ptr %state126, i32 0, i32 3
  %frombool127 = zext i1 %102 to i8
  store i8 %frombool127, ptr %backing_missing, align 8
  br label %if.end128

if.end128:                                        ; preds = %land.end, %if.end111
  %104 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %104, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %105 = load ptr, ptr %lh_first, align 8
  store ptr %105, ptr %child, align 8
  br label %for.cond129

for.cond129:                                      ; preds = %for.inc158, %if.end128
  %106 = load ptr, ptr %child, align 8
  %tobool130 = icmp ne ptr %106, null
  br i1 %tobool130, label %for.body131, label %for.end159

for.body131:                                      ; preds = %for.cond129
  store ptr null, ptr %new_child_options, align 8
  %107 = load i8, ptr %keep_old_opts.addr, align 1
  %tobool132 = trunc i8 %107 to i1
  %frombool133 = zext i1 %tobool132 to i8
  store i8 %frombool133, ptr %child_keep_old, align 1
  %108 = load ptr, ptr %child, align 8
  %bs134 = getelementptr inbounds %struct.BdrvChild, ptr %108, i32 0, i32 0
  %109 = load ptr, ptr %bs134, align 8
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %109, i32 0, i32 28
  %110 = load ptr, ptr %inherits_from, align 8
  %111 = load ptr, ptr %bs.addr, align 8
  %cmp135 = icmp ne ptr %110, %111
  br i1 %cmp135, label %if.then136, label %if.end137

if.then136:                                       ; preds = %for.body131
  br label %for.inc158

if.end137:                                        ; preds = %for.body131
  %112 = load ptr, ptr %options.addr, align 8
  %113 = load ptr, ptr %child, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %113, i32 0, i32 1
  %114 = load ptr, ptr %name, align 8
  %call138 = call i32 @qdict_haskey(ptr noundef %112, ptr noundef %114)
  %tobool139 = icmp ne i32 %call138, 0
  br i1 %tobool139, label %if.then140, label %if.else148

if.then140:                                       ; preds = %if.end137
  %115 = load ptr, ptr %options.addr, align 8
  %116 = load ptr, ptr %child, align 8
  %name141 = getelementptr inbounds %struct.BdrvChild, ptr %116, i32 0, i32 1
  %117 = load ptr, ptr %name141, align 8
  %call142 = call ptr @qdict_get_try_str(ptr noundef %115, ptr noundef %117)
  store ptr %call142, ptr %childref, align 8
  %118 = load ptr, ptr %childref, align 8
  %119 = load ptr, ptr %child, align 8
  %bs143 = getelementptr inbounds %struct.BdrvChild, ptr %119, i32 0, i32 0
  %120 = load ptr, ptr %bs143, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %120, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  %call144 = call i32 @g_strcmp0(ptr noundef %118, ptr noundef %arraydecay)
  %tobool145 = icmp ne i32 %call144, 0
  br i1 %tobool145, label %if.then146, label %if.end147

if.then146:                                       ; preds = %if.then140
  br label %for.inc158

if.end147:                                        ; preds = %if.then140
  store i8 1, ptr %child_keep_old, align 1
  br label %if.end151

if.else148:                                       ; preds = %if.end137
  %121 = load ptr, ptr %child, align 8
  %name149 = getelementptr inbounds %struct.BdrvChild, ptr %121, i32 0, i32 1
  %122 = load ptr, ptr %name149, align 8
  %call150 = call noalias ptr (ptr, ...) @g_strdup_printf(ptr noundef @.str.76, ptr noundef %122)
  store ptr %call150, ptr %child_key_dot, align 8
  %123 = load ptr, ptr %explicit_options, align 8
  %124 = load ptr, ptr %child_key_dot, align 8
  call void @qdict_extract_subqdict(ptr noundef %123, ptr noundef null, ptr noundef %124)
  %125 = load ptr, ptr %options.addr, align 8
  %126 = load ptr, ptr %child_key_dot, align 8
  call void @qdict_extract_subqdict(ptr noundef %125, ptr noundef %new_child_options, ptr noundef %126)
  %127 = load ptr, ptr %child_key_dot, align 8
  call void @g_free(ptr noundef %127)
  br label %if.end151

if.end151:                                        ; preds = %if.else148, %if.end147
  %128 = load ptr, ptr %bs_queue.addr, align 8
  %129 = load ptr, ptr %child, align 8
  %bs152 = getelementptr inbounds %struct.BdrvChild, ptr %129, i32 0, i32 0
  %130 = load ptr, ptr %bs152, align 8
  %131 = load ptr, ptr %new_child_options, align 8
  %132 = load ptr, ptr %child, align 8
  %klass153 = getelementptr inbounds %struct.BdrvChild, ptr %132, i32 0, i32 2
  %133 = load ptr, ptr %klass153, align 8
  %134 = load ptr, ptr %child, align 8
  %role154 = getelementptr inbounds %struct.BdrvChild, ptr %134, i32 0, i32 3
  %135 = load i32, ptr %role154, align 8
  %136 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %136, i32 0, i32 6
  %137 = load ptr, ptr %drv, align 8
  %is_format = getelementptr inbounds %struct.BlockDriver, ptr %137, i32 0, i32 4
  %138 = load i8, ptr %is_format, align 2
  %tobool155 = trunc i8 %138 to i1
  %139 = load ptr, ptr %options.addr, align 8
  %140 = load i32, ptr %flags, align 4
  %141 = load i8, ptr %child_keep_old, align 1
  %tobool156 = trunc i8 %141 to i1
  %call157 = call ptr @bdrv_reopen_queue_child(ptr noundef %128, ptr noundef %130, ptr noundef %131, ptr noundef %133, i32 noundef %135, i1 noundef zeroext %tobool155, ptr noundef %139, i32 noundef %140, i1 noundef zeroext %tobool156)
  br label %for.inc158

for.inc158:                                       ; preds = %if.end151, %if.then146, %if.then136
  %142 = load ptr, ptr %child, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %142, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %143 = load ptr, ptr %le_next, align 8
  store ptr %143, ptr %child, align 8
  br label %for.cond129, !llvm.loop !25

for.end159:                                       ; preds = %for.cond129
  %144 = load ptr, ptr %bs_queue.addr, align 8
  ret ptr %144
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_reopen_queue_free(ptr noundef %bs_queue) #0 {
entry:
  %bs_queue.addr = alloca ptr, align 8
  %bs_entry = alloca ptr, align 8
  %next = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %_obj42 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp9 = alloca ptr, align 8
  %_obj43 = alloca ptr, align 8
  %tmp11 = alloca ptr, align 8
  %__mptr14 = alloca ptr, align 8
  %tmp16 = alloca ptr, align 8
  store ptr %bs_queue, ptr %bs_queue.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 4539, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_queue_free) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs_queue.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then1, label %if.end21

if.then1:                                         ; preds = %do.end
  %1 = load ptr, ptr %bs_queue.addr, align 8
  %2 = load ptr, ptr %1, align 8
  store ptr %2, ptr %bs_entry, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then1
  %3 = load ptr, ptr %bs_entry, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %4 = load ptr, ptr %bs_entry, align 8
  %entry3 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %entry3, align 8
  store ptr %5, ptr %next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %6 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %6, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %7 = load ptr, ptr %bs_entry, align 8
  %state = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %7, i32 0, i32 1
  %bs = getelementptr inbounds %struct.BDRVReopenState, ptr %state, i32 0, i32 0
  %8 = load ptr, ptr %bs, align 8
  %call4 = call ptr @bdrv_get_aio_context(ptr noundef %8)
  store ptr %call4, ptr %ctx, align 8
  %9 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %9)
  %10 = load ptr, ptr %bs_entry, align 8
  %state5 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %10, i32 0, i32 1
  %bs6 = getelementptr inbounds %struct.BDRVReopenState, ptr %state5, i32 0, i32 0
  %11 = load ptr, ptr %bs6, align 8
  call void @bdrv_drained_end(ptr noundef %11)
  %12 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %12)
  %13 = load ptr, ptr %bs_entry, align 8
  %state7 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %13, i32 0, i32 1
  %explicit_options = getelementptr inbounds %struct.BDRVReopenState, ptr %state7, i32 0, i32 7
  %14 = load ptr, ptr %explicit_options, align 8
  store ptr %14, ptr %_obj42, align 8
  %15 = load ptr, ptr %_obj42, align 8
  %tobool8 = icmp ne ptr %15, null
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %16 = load ptr, ptr %_obj42, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %16, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %17 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %17, i64 0
  store ptr %add.ptr, ptr %tmp9, align 8
  %18 = load ptr, ptr %tmp9, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %18, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %19 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %19)
  %20 = load ptr, ptr %bs_entry, align 8
  %state10 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %20, i32 0, i32 1
  %options = getelementptr inbounds %struct.BDRVReopenState, ptr %state10, i32 0, i32 6
  %21 = load ptr, ptr %options, align 8
  store ptr %21, ptr %_obj43, align 8
  %22 = load ptr, ptr %_obj43, align 8
  %tobool12 = icmp ne ptr %22, null
  br i1 %tobool12, label %cond.true13, label %cond.false18

cond.true13:                                      ; preds = %cond.end
  %23 = load ptr, ptr %_obj43, align 8
  %base15 = getelementptr inbounds %struct.QDict, ptr %23, i32 0, i32 0
  store ptr %base15, ptr %__mptr14, align 8
  %24 = load ptr, ptr %__mptr14, align 8
  %add.ptr17 = getelementptr i8, ptr %24, i64 0
  store ptr %add.ptr17, ptr %tmp16, align 8
  %25 = load ptr, ptr %tmp16, align 8
  br label %cond.end19

cond.false18:                                     ; preds = %cond.end
  br label %cond.end19

cond.end19:                                       ; preds = %cond.false18, %cond.true13
  %cond20 = phi ptr [ %25, %cond.true13 ], [ null, %cond.false18 ]
  store ptr %cond20, ptr %tmp11, align 8
  %26 = load ptr, ptr %tmp11, align 8
  call void @qobject_unref_impl(ptr noundef %26)
  %27 = load ptr, ptr %bs_entry, align 8
  call void @g_free(ptr noundef %27)
  br label %for.inc

for.inc:                                          ; preds = %cond.end19
  %28 = load ptr, ptr %next, align 8
  store ptr %28, ptr %bs_entry, align 8
  br label %for.cond, !llvm.loop !26

for.end:                                          ; preds = %land.end
  %29 = load ptr, ptr %bs_queue.addr, align 8
  call void @g_free(ptr noundef %29)
  br label %if.end21

if.end21:                                         ; preds = %for.end, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_reopen_multiple(ptr noundef %bs_queue, ptr noundef %errp) #0 {
entry:
  %bs_queue.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %bs_entry = alloca ptr, align 8
  %next = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %tran = alloca ptr, align 8
  %refresh_list = alloca ptr, align 8
  %state42 = alloca ptr, align 8
  %bs83 = alloca ptr, align 8
  store ptr %bs_queue, ptr %bs_queue.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store i32 -1, ptr %ret, align 4
  %call = call ptr @tran_new()
  store ptr %call, ptr %tran, align 8
  store ptr null, ptr %refresh_list, align 8
  %call1 = call ptr @qemu_get_current_aio_context()
  %call2 = call ptr @qemu_get_aio_context()
  %cmp = icmp eq ptr %call1, %call2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.82, ptr noundef @.str.2, i32 noundef 4584, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_multiple) #16
  unreachable

if.end:                                           ; preds = %if.then
  %0 = load ptr, ptr %bs_queue.addr, align 8
  %cmp3 = icmp ne ptr %0, null
  br i1 %cmp3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.end
  br label %if.end6

if.else5:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.83, ptr noundef @.str.2, i32 noundef 4585, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_multiple) #16
  unreachable

if.end6:                                          ; preds = %if.then4
  br label %do.body

do.body:                                          ; preds = %if.end6
  %call7 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %do.body
  br label %if.end10

if.else9:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 4586, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_multiple) #16
  unreachable

if.end10:                                         ; preds = %if.then8
  br label %do.cond

do.cond:                                          ; preds = %if.end10
  br label %do.end

do.end:                                           ; preds = %do.cond
  %1 = load ptr, ptr %bs_queue.addr, align 8
  %2 = load ptr, ptr %1, align 8
  store ptr %2, ptr %bs_entry, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %3 = load ptr, ptr %bs_entry, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %bs_entry, align 8
  %state = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %4, i32 0, i32 1
  %bs = getelementptr inbounds %struct.BDRVReopenState, ptr %state, i32 0, i32 0
  %5 = load ptr, ptr %bs, align 8
  %call11 = call ptr @bdrv_get_aio_context(ptr noundef %5)
  store ptr %call11, ptr %ctx, align 8
  %6 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %6)
  %7 = load ptr, ptr %bs_entry, align 8
  %state12 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %7, i32 0, i32 1
  %bs13 = getelementptr inbounds %struct.BDRVReopenState, ptr %state12, i32 0, i32 0
  %8 = load ptr, ptr %bs13, align 8
  %call14 = call i32 @bdrv_flush(ptr noundef %8)
  store i32 %call14, ptr %ret, align 4
  %9 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %9)
  %10 = load i32, ptr %ret, align 4
  %cmp15 = icmp slt i32 %10, 0
  br i1 %cmp15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %for.body
  %11 = load ptr, ptr %errp.addr, align 8
  %12 = load i32, ptr %ret, align 4
  %sub = sub i32 0, %12
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %11, ptr noundef @.str.2, i32 noundef 4594, ptr noundef @__func__.bdrv_reopen_multiple, i32 noundef %sub, ptr noundef @.str.84)
  br label %abort

if.end17:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %13 = load ptr, ptr %bs_entry, align 8
  %entry18 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %13, i32 0, i32 2
  %14 = load ptr, ptr %entry18, align 8
  store ptr %14, ptr %bs_entry, align 8
  br label %for.cond, !llvm.loop !27

for.end:                                          ; preds = %for.cond
  %15 = load ptr, ptr %bs_queue.addr, align 8
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %bs_entry, align 8
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc36, %for.end
  %17 = load ptr, ptr %bs_entry, align 8
  %tobool20 = icmp ne ptr %17, null
  br i1 %tobool20, label %for.body21, label %for.end38

for.body21:                                       ; preds = %for.cond19
  %18 = load ptr, ptr %bs_entry, align 8
  %state22 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %18, i32 0, i32 1
  %bs23 = getelementptr inbounds %struct.BDRVReopenState, ptr %state22, i32 0, i32 0
  %19 = load ptr, ptr %bs23, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %19, i32 0, i32 46
  %20 = load i32, ptr %quiesce_counter, align 8
  %cmp24 = icmp sgt i32 %20, 0
  br i1 %cmp24, label %if.then25, label %if.else26

if.then25:                                        ; preds = %for.body21
  br label %if.end27

if.else26:                                        ; preds = %for.body21
  call void @__assert_fail(ptr noundef @.str.85, ptr noundef @.str.2, i32 noundef 4600, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_multiple) #16
  unreachable

if.end27:                                         ; preds = %if.then25
  %21 = load ptr, ptr %bs_entry, align 8
  %state28 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %21, i32 0, i32 1
  %bs29 = getelementptr inbounds %struct.BDRVReopenState, ptr %state28, i32 0, i32 0
  %22 = load ptr, ptr %bs29, align 8
  %call30 = call ptr @bdrv_get_aio_context(ptr noundef %22)
  store ptr %call30, ptr %ctx, align 8
  %23 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %23)
  %24 = load ptr, ptr %bs_entry, align 8
  %state31 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %24, i32 0, i32 1
  %25 = load ptr, ptr %bs_queue.addr, align 8
  %26 = load ptr, ptr %tran, align 8
  %27 = load ptr, ptr %errp.addr, align 8
  %call32 = call i32 @bdrv_reopen_prepare(ptr noundef %state31, ptr noundef %25, ptr noundef %26, ptr noundef %27)
  store i32 %call32, ptr %ret, align 4
  %28 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %28)
  %29 = load i32, ptr %ret, align 4
  %cmp33 = icmp slt i32 %29, 0
  br i1 %cmp33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end27
  br label %abort

if.end35:                                         ; preds = %if.end27
  %30 = load ptr, ptr %bs_entry, align 8
  %prepared = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %30, i32 0, i32 0
  store i8 1, ptr %prepared, align 8
  br label %for.inc36

for.inc36:                                        ; preds = %if.end35
  %31 = load ptr, ptr %bs_entry, align 8
  %entry37 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %31, i32 0, i32 2
  %32 = load ptr, ptr %entry37, align 8
  store ptr %32, ptr %bs_entry, align 8
  br label %for.cond19, !llvm.loop !28

for.end38:                                        ; preds = %for.cond19
  %33 = load ptr, ptr %bs_queue.addr, align 8
  %34 = load ptr, ptr %33, align 8
  store ptr %34, ptr %bs_entry, align 8
  br label %for.cond39

for.cond39:                                       ; preds = %for.inc56, %for.end38
  %35 = load ptr, ptr %bs_entry, align 8
  %tobool40 = icmp ne ptr %35, null
  br i1 %tobool40, label %for.body41, label %for.end58

for.body41:                                       ; preds = %for.cond39
  %36 = load ptr, ptr %bs_entry, align 8
  %state43 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %36, i32 0, i32 1
  store ptr %state43, ptr %state42, align 8
  %37 = load ptr, ptr %refresh_list, align 8
  %38 = load ptr, ptr %state42, align 8
  %bs44 = getelementptr inbounds %struct.BDRVReopenState, ptr %38, i32 0, i32 0
  %39 = load ptr, ptr %bs44, align 8
  %call45 = call ptr @g_slist_prepend(ptr noundef %37, ptr noundef %39)
  store ptr %call45, ptr %refresh_list, align 8
  %40 = load ptr, ptr %state42, align 8
  %old_backing_bs = getelementptr inbounds %struct.BDRVReopenState, ptr %40, i32 0, i32 4
  %41 = load ptr, ptr %old_backing_bs, align 8
  %tobool46 = icmp ne ptr %41, null
  br i1 %tobool46, label %if.then47, label %if.end50

if.then47:                                        ; preds = %for.body41
  %42 = load ptr, ptr %refresh_list, align 8
  %43 = load ptr, ptr %state42, align 8
  %old_backing_bs48 = getelementptr inbounds %struct.BDRVReopenState, ptr %43, i32 0, i32 4
  %44 = load ptr, ptr %old_backing_bs48, align 8
  %call49 = call ptr @g_slist_prepend(ptr noundef %42, ptr noundef %44)
  store ptr %call49, ptr %refresh_list, align 8
  br label %if.end50

if.end50:                                         ; preds = %if.then47, %for.body41
  %45 = load ptr, ptr %state42, align 8
  %old_file_bs = getelementptr inbounds %struct.BDRVReopenState, ptr %45, i32 0, i32 5
  %46 = load ptr, ptr %old_file_bs, align 8
  %tobool51 = icmp ne ptr %46, null
  br i1 %tobool51, label %if.then52, label %if.end55

if.then52:                                        ; preds = %if.end50
  %47 = load ptr, ptr %refresh_list, align 8
  %48 = load ptr, ptr %state42, align 8
  %old_file_bs53 = getelementptr inbounds %struct.BDRVReopenState, ptr %48, i32 0, i32 5
  %49 = load ptr, ptr %old_file_bs53, align 8
  %call54 = call ptr @g_slist_prepend(ptr noundef %47, ptr noundef %49)
  store ptr %call54, ptr %refresh_list, align 8
  br label %if.end55

if.end55:                                         ; preds = %if.then52, %if.end50
  br label %for.inc56

for.inc56:                                        ; preds = %if.end55
  %50 = load ptr, ptr %bs_entry, align 8
  %entry57 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %50, i32 0, i32 2
  %51 = load ptr, ptr %entry57, align 8
  store ptr %51, ptr %bs_entry, align 8
  br label %for.cond39, !llvm.loop !29

for.end58:                                        ; preds = %for.cond39
  call void @bdrv_graph_rdlock_main_loop()
  %52 = load ptr, ptr %refresh_list, align 8
  %53 = load ptr, ptr %bs_queue.addr, align 8
  %54 = load ptr, ptr %tran, align 8
  %55 = load ptr, ptr %errp.addr, align 8
  %call59 = call i32 @bdrv_list_refresh_perms(ptr noundef %52, ptr noundef %53, ptr noundef %54, ptr noundef %55)
  store i32 %call59, ptr %ret, align 4
  call void @bdrv_graph_rdunlock_main_loop()
  %56 = load i32, ptr %ret, align 4
  %cmp60 = icmp slt i32 %56, 0
  br i1 %cmp60, label %if.then61, label %if.end62

if.then61:                                        ; preds = %for.end58
  br label %abort

if.end62:                                         ; preds = %for.end58
  %57 = load ptr, ptr %bs_queue.addr, align 8
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %57, i32 0, i32 1
  %58 = load ptr, ptr %tql_prev, align 8
  %tql_prev63 = getelementptr inbounds %struct.QTailQLink, ptr %58, i32 0, i32 1
  %59 = load ptr, ptr %tql_prev63, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %59, i32 0, i32 0
  %60 = load ptr, ptr %tql_next, align 8
  store ptr %60, ptr %bs_entry, align 8
  br label %for.cond64

for.cond64:                                       ; preds = %for.inc71, %if.end62
  %61 = load ptr, ptr %bs_entry, align 8
  %tobool65 = icmp ne ptr %61, null
  br i1 %tobool65, label %for.body66, label %for.end76

for.body66:                                       ; preds = %for.cond64
  %62 = load ptr, ptr %bs_entry, align 8
  %state67 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %62, i32 0, i32 1
  %bs68 = getelementptr inbounds %struct.BDRVReopenState, ptr %state67, i32 0, i32 0
  %63 = load ptr, ptr %bs68, align 8
  %call69 = call ptr @bdrv_get_aio_context(ptr noundef %63)
  store ptr %call69, ptr %ctx, align 8
  %64 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %64)
  %65 = load ptr, ptr %bs_entry, align 8
  %state70 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %65, i32 0, i32 1
  call void @bdrv_reopen_commit(ptr noundef %state70)
  %66 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %66)
  br label %for.inc71

for.inc71:                                        ; preds = %for.body66
  %67 = load ptr, ptr %bs_entry, align 8
  %entry72 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %67, i32 0, i32 2
  %tql_prev73 = getelementptr inbounds %struct.QTailQLink, ptr %entry72, i32 0, i32 1
  %68 = load ptr, ptr %tql_prev73, align 8
  %tql_prev74 = getelementptr inbounds %struct.QTailQLink, ptr %68, i32 0, i32 1
  %69 = load ptr, ptr %tql_prev74, align 8
  %tql_next75 = getelementptr inbounds %struct.QTailQLink, ptr %69, i32 0, i32 0
  %70 = load ptr, ptr %tql_next75, align 8
  store ptr %70, ptr %bs_entry, align 8
  br label %for.cond64, !llvm.loop !30

for.end76:                                        ; preds = %for.cond64
  call void @bdrv_graph_wrlock(ptr noundef null)
  %71 = load ptr, ptr %tran, align 8
  call void @tran_commit(ptr noundef %71)
  call void @bdrv_graph_wrunlock(ptr noundef null)
  %72 = load ptr, ptr %bs_queue.addr, align 8
  %tql_prev77 = getelementptr inbounds %struct.QTailQLink, ptr %72, i32 0, i32 1
  %73 = load ptr, ptr %tql_prev77, align 8
  %tql_prev78 = getelementptr inbounds %struct.QTailQLink, ptr %73, i32 0, i32 1
  %74 = load ptr, ptr %tql_prev78, align 8
  %tql_next79 = getelementptr inbounds %struct.QTailQLink, ptr %74, i32 0, i32 0
  %75 = load ptr, ptr %tql_next79, align 8
  store ptr %75, ptr %bs_entry, align 8
  br label %for.cond80

for.cond80:                                       ; preds = %for.inc93, %for.end76
  %76 = load ptr, ptr %bs_entry, align 8
  %tobool81 = icmp ne ptr %76, null
  br i1 %tobool81, label %for.body82, label %for.end98

for.body82:                                       ; preds = %for.cond80
  %77 = load ptr, ptr %bs_entry, align 8
  %state84 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %77, i32 0, i32 1
  %bs85 = getelementptr inbounds %struct.BDRVReopenState, ptr %state84, i32 0, i32 0
  %78 = load ptr, ptr %bs85, align 8
  store ptr %78, ptr %bs83, align 8
  %79 = load ptr, ptr %bs83, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %79, i32 0, i32 6
  %80 = load ptr, ptr %drv, align 8
  %bdrv_reopen_commit_post = getelementptr inbounds %struct.BlockDriver, ptr %80, i32 0, i32 20
  %81 = load ptr, ptr %bdrv_reopen_commit_post, align 8
  %tobool86 = icmp ne ptr %81, null
  br i1 %tobool86, label %if.then87, label %if.end92

if.then87:                                        ; preds = %for.body82
  %82 = load ptr, ptr %bs83, align 8
  %call88 = call ptr @bdrv_get_aio_context(ptr noundef %82)
  store ptr %call88, ptr %ctx, align 8
  %83 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %83)
  %84 = load ptr, ptr %bs83, align 8
  %drv89 = getelementptr inbounds %struct.BlockDriverState, ptr %84, i32 0, i32 6
  %85 = load ptr, ptr %drv89, align 8
  %bdrv_reopen_commit_post90 = getelementptr inbounds %struct.BlockDriver, ptr %85, i32 0, i32 20
  %86 = load ptr, ptr %bdrv_reopen_commit_post90, align 8
  %87 = load ptr, ptr %bs_entry, align 8
  %state91 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %87, i32 0, i32 1
  call void %86(ptr noundef %state91)
  %88 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %88)
  br label %if.end92

if.end92:                                         ; preds = %if.then87, %for.body82
  br label %for.inc93

for.inc93:                                        ; preds = %if.end92
  %89 = load ptr, ptr %bs_entry, align 8
  %entry94 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %89, i32 0, i32 2
  %tql_prev95 = getelementptr inbounds %struct.QTailQLink, ptr %entry94, i32 0, i32 1
  %90 = load ptr, ptr %tql_prev95, align 8
  %tql_prev96 = getelementptr inbounds %struct.QTailQLink, ptr %90, i32 0, i32 1
  %91 = load ptr, ptr %tql_prev96, align 8
  %tql_next97 = getelementptr inbounds %struct.QTailQLink, ptr %91, i32 0, i32 0
  %92 = load ptr, ptr %tql_next97, align 8
  store ptr %92, ptr %bs_entry, align 8
  br label %for.cond80, !llvm.loop !31

for.end98:                                        ; preds = %for.cond80
  store i32 0, ptr %ret, align 4
  br label %cleanup

abort:                                            ; preds = %if.then61, %if.then34, %if.then16
  call void @bdrv_graph_wrlock(ptr noundef null)
  %93 = load ptr, ptr %tran, align 8
  call void @tran_abort(ptr noundef %93)
  call void @bdrv_graph_wrunlock(ptr noundef null)
  %94 = load ptr, ptr %bs_queue.addr, align 8
  %95 = load ptr, ptr %94, align 8
  store ptr %95, ptr %bs_entry, align 8
  br label %for.cond99

for.cond99:                                       ; preds = %for.inc111, %abort
  %96 = load ptr, ptr %bs_entry, align 8
  %tobool100 = icmp ne ptr %96, null
  br i1 %tobool100, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond99
  %97 = load ptr, ptr %bs_entry, align 8
  %entry101 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %97, i32 0, i32 2
  %98 = load ptr, ptr %entry101, align 8
  store ptr %98, ptr %next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond99
  %99 = phi i1 [ false, %for.cond99 ], [ true, %land.rhs ]
  br i1 %99, label %for.body102, label %for.end112

for.body102:                                      ; preds = %land.end
  %100 = load ptr, ptr %bs_entry, align 8
  %prepared103 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %100, i32 0, i32 0
  %101 = load i8, ptr %prepared103, align 8
  %tobool104 = trunc i8 %101 to i1
  br i1 %tobool104, label %if.then105, label %if.end110

if.then105:                                       ; preds = %for.body102
  %102 = load ptr, ptr %bs_entry, align 8
  %state106 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %102, i32 0, i32 1
  %bs107 = getelementptr inbounds %struct.BDRVReopenState, ptr %state106, i32 0, i32 0
  %103 = load ptr, ptr %bs107, align 8
  %call108 = call ptr @bdrv_get_aio_context(ptr noundef %103)
  store ptr %call108, ptr %ctx, align 8
  %104 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %104)
  %105 = load ptr, ptr %bs_entry, align 8
  %state109 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %105, i32 0, i32 1
  call void @bdrv_reopen_abort(ptr noundef %state109)
  %106 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %106)
  br label %if.end110

if.end110:                                        ; preds = %if.then105, %for.body102
  br label %for.inc111

for.inc111:                                       ; preds = %if.end110
  %107 = load ptr, ptr %next, align 8
  store ptr %107, ptr %bs_entry, align 8
  br label %for.cond99, !llvm.loop !32

for.end112:                                       ; preds = %land.end
  br label %cleanup

cleanup:                                          ; preds = %for.end112, %for.end98
  %108 = load ptr, ptr %bs_queue.addr, align 8
  call void @bdrv_reopen_queue_free(ptr noundef %108)
  %109 = load i32, ptr %ret, align 4
  call void @glib_autoptr_cleanup_GSList(ptr noundef %refresh_list)
  ret i32 %109
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_cleanup_GSList(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %1 = load ptr, ptr %0, align 8
  call void @glib_autoptr_clear_GSList(ptr noundef %1)
  ret void
}

declare ptr @qemu_get_current_aio_context() #2

declare i32 @bdrv_flush(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_reopen_prepare(ptr noundef %reopen_state, ptr noundef %queue, ptr noundef %change_child_tran, ptr noundef %errp) #0 {
entry:
  %reopen_state.addr = alloca ptr, align 8
  %queue.addr = alloca ptr, align 8
  %change_child_tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %old_flags = alloca i32, align 4
  %local_err = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %opts = alloca ptr, align 8
  %orig_reopen_opts = alloca ptr, align 8
  %discard = alloca ptr, align 8
  %read_only = alloca i8, align 1
  %drv_prepared = alloca i8, align 1
  %entry96 = alloca ptr, align 8
  %graph_lockable_auto44 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %new = alloca ptr, align 8
  %old = alloca ptr, align 8
  %child = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %_obj45 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp139 = alloca ptr, align 8
  %_o = alloca ptr, align 8
  %_obj46 = alloca ptr, align 8
  %tmp140 = alloca ptr, align 8
  %__mptr143 = alloca ptr, align 8
  %tmp145 = alloca ptr, align 8
  %tmp150 = alloca ptr, align 8
  %_obj47 = alloca ptr, align 8
  %tmp163 = alloca ptr, align 8
  %__mptr166 = alloca ptr, align 8
  %tmp168 = alloca ptr, align 8
  store ptr %reopen_state, ptr %reopen_state.addr, align 8
  store ptr %queue, ptr %queue.addr, align 8
  store ptr %change_child_tran, ptr %change_child_tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store i32 -1, ptr %ret, align 4
  store ptr null, ptr %local_err, align 8
  store ptr null, ptr %discard, align 8
  store i8 0, ptr %drv_prepared, align 1
  %0 = load ptr, ptr %reopen_state.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.257, ptr noundef @.str.2, i32 noundef 4914, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_prepare) #16
  unreachable

if.end:                                           ; preds = %if.then
  %1 = load ptr, ptr %reopen_state.addr, align 8
  %bs = getelementptr inbounds %struct.BDRVReopenState, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %bs, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv1, align 8
  %cmp2 = icmp ne ptr %3, null
  br i1 %cmp2, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.end
  br label %if.end5

if.else4:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.258, ptr noundef @.str.2, i32 noundef 4915, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_prepare) #16
  unreachable

if.end5:                                          ; preds = %if.then3
  br label %do.body

do.body:                                          ; preds = %if.end5
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then6, label %if.else7

if.then6:                                         ; preds = %do.body
  br label %if.end8

if.else7:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 4916, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_prepare) #16
  unreachable

if.end8:                                          ; preds = %if.then6
  br label %do.end

do.end:                                           ; preds = %if.end8
  %4 = load ptr, ptr %reopen_state.addr, align 8
  %bs9 = getelementptr inbounds %struct.BDRVReopenState, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %bs9, align 8
  %drv10 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %drv10, align 8
  store ptr %6, ptr %drv, align 8
  %7 = load ptr, ptr %reopen_state.addr, align 8
  %options = getelementptr inbounds %struct.BDRVReopenState, ptr %7, i32 0, i32 6
  %8 = load ptr, ptr %options, align 8
  %call11 = call ptr @qdict_clone_shallow(ptr noundef %8)
  store ptr %call11, ptr %orig_reopen_opts, align 8
  %call12 = call ptr @qemu_opts_create(ptr noundef @bdrv_runtime_opts, ptr noundef null, i32 noundef 0, ptr noundef @error_abort)
  store ptr %call12, ptr %opts, align 8
  %9 = load ptr, ptr %opts, align 8
  %10 = load ptr, ptr %reopen_state.addr, align 8
  %options13 = getelementptr inbounds %struct.BDRVReopenState, ptr %10, i32 0, i32 6
  %11 = load ptr, ptr %options13, align 8
  %12 = load ptr, ptr %errp.addr, align 8
  %call14 = call zeroext i1 @qemu_opts_absorb_qdict(ptr noundef %9, ptr noundef %11, ptr noundef %12)
  br i1 %call14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %do.end
  store i32 -22, ptr %ret, align 4
  br label %error

if.end16:                                         ; preds = %do.end
  %13 = load ptr, ptr %reopen_state.addr, align 8
  %flags = getelementptr inbounds %struct.BDRVReopenState, ptr %13, i32 0, i32 1
  %14 = load i32, ptr %flags, align 8
  store i32 %14, ptr %old_flags, align 4
  %15 = load ptr, ptr %reopen_state.addr, align 8
  %flags17 = getelementptr inbounds %struct.BDRVReopenState, ptr %15, i32 0, i32 1
  %16 = load ptr, ptr %opts, align 8
  call void @update_flags_from_options(ptr noundef %flags17, ptr noundef %16)
  %17 = load i32, ptr %old_flags, align 4
  %18 = load ptr, ptr %reopen_state.addr, align 8
  %flags18 = getelementptr inbounds %struct.BDRVReopenState, ptr %18, i32 0, i32 1
  %19 = load i32, ptr %flags18, align 8
  %cmp19 = icmp eq i32 %17, %19
  br i1 %cmp19, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.end16
  br label %if.end22

if.else21:                                        ; preds = %if.end16
  call void @__assert_fail(ptr noundef @.str.259, ptr noundef @.str.2, i32 noundef 4936, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_prepare) #16
  unreachable

if.end22:                                         ; preds = %if.then20
  %20 = load ptr, ptr %opts, align 8
  %call23 = call ptr @qemu_opt_get_del(ptr noundef %20, ptr noundef @.str.57)
  store ptr %call23, ptr %discard, align 8
  %21 = load ptr, ptr %discard, align 8
  %cmp24 = icmp ne ptr %21, null
  br i1 %cmp24, label %if.then25, label %if.end31

if.then25:                                        ; preds = %if.end22
  %22 = load ptr, ptr %discard, align 8
  %23 = load ptr, ptr %reopen_state.addr, align 8
  %flags26 = getelementptr inbounds %struct.BDRVReopenState, ptr %23, i32 0, i32 1
  %call27 = call i32 @bdrv_parse_discard_flags(ptr noundef %22, ptr noundef %flags26)
  %cmp28 = icmp ne i32 %call27, 0
  br i1 %cmp28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.then25
  %24 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %24, ptr noundef @.str.2, i32 noundef 4941, ptr noundef @__func__.bdrv_reopen_prepare, ptr noundef @.str.247)
  store i32 -22, ptr %ret, align 4
  br label %error

if.end30:                                         ; preds = %if.then25
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.end22
  %25 = load ptr, ptr %opts, align 8
  %26 = load ptr, ptr %reopen_state.addr, align 8
  %flags32 = getelementptr inbounds %struct.BDRVReopenState, ptr %26, i32 0, i32 1
  %27 = load i32, ptr %flags32, align 8
  %call33 = call i32 @bdrv_parse_detect_zeroes(ptr noundef %25, i32 noundef %27, ptr noundef %local_err)
  %28 = load ptr, ptr %reopen_state.addr, align 8
  %detect_zeroes = getelementptr inbounds %struct.BDRVReopenState, ptr %28, i32 0, i32 2
  store i32 %call33, ptr %detect_zeroes, align 4
  %29 = load ptr, ptr %local_err, align 8
  %tobool = icmp ne ptr %29, null
  br i1 %tobool, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end31
  %30 = load ptr, ptr %errp.addr, align 8
  %31 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %30, ptr noundef %31)
  store i32 -22, ptr %ret, align 4
  br label %error

if.end35:                                         ; preds = %if.end31
  %32 = load ptr, ptr %opts, align 8
  %33 = load ptr, ptr %reopen_state.addr, align 8
  %options36 = getelementptr inbounds %struct.BDRVReopenState, ptr %33, i32 0, i32 6
  %34 = load ptr, ptr %options36, align 8
  %call37 = call ptr @qemu_opts_to_qdict(ptr noundef %32, ptr noundef %34)
  %35 = load ptr, ptr %reopen_state.addr, align 8
  %flags38 = getelementptr inbounds %struct.BDRVReopenState, ptr %35, i32 0, i32 1
  %36 = load i32, ptr %flags38, align 8
  %and = and i32 %36, 2
  %tobool39 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool39, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, ptr %read_only, align 1
  call void @bdrv_graph_rdlock_main_loop()
  %37 = load ptr, ptr %reopen_state.addr, align 8
  %bs40 = getelementptr inbounds %struct.BDRVReopenState, ptr %37, i32 0, i32 0
  %38 = load ptr, ptr %bs40, align 8
  %39 = load i8, ptr %read_only, align 1
  %tobool41 = trunc i8 %39 to i1
  %call42 = call i32 @bdrv_can_set_read_only(ptr noundef %38, i1 noundef zeroext %tobool41, i1 noundef zeroext true, ptr noundef %local_err)
  store i32 %call42, ptr %ret, align 4
  call void @bdrv_graph_rdunlock_main_loop()
  %40 = load ptr, ptr %local_err, align 8
  %tobool43 = icmp ne ptr %40, null
  br i1 %tobool43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %if.end35
  %41 = load ptr, ptr %errp.addr, align 8
  %42 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %41, ptr noundef %42)
  br label %error

if.end45:                                         ; preds = %if.end35
  %43 = load ptr, ptr %drv, align 8
  %bdrv_reopen_prepare = getelementptr inbounds %struct.BlockDriver, ptr %43, i32 0, i32 18
  %44 = load ptr, ptr %bdrv_reopen_prepare, align 8
  %tobool46 = icmp ne ptr %44, null
  br i1 %tobool46, label %if.then47, label %if.else65

if.then47:                                        ; preds = %if.end45
  %45 = load ptr, ptr %reopen_state.addr, align 8
  %bs48 = getelementptr inbounds %struct.BDRVReopenState, ptr %45, i32 0, i32 0
  %46 = load ptr, ptr %bs48, align 8
  %47 = load ptr, ptr %reopen_state.addr, align 8
  %options49 = getelementptr inbounds %struct.BDRVReopenState, ptr %47, i32 0, i32 6
  %48 = load ptr, ptr %options49, align 8
  %49 = load ptr, ptr %errp.addr, align 8
  %call50 = call i32 @bdrv_reset_options_allowed(ptr noundef %46, ptr noundef %48, ptr noundef %49)
  store i32 %call50, ptr %ret, align 4
  %50 = load i32, ptr %ret, align 4
  %tobool51 = icmp ne i32 %50, 0
  br i1 %tobool51, label %if.then52, label %if.end53

if.then52:                                        ; preds = %if.then47
  br label %error

if.end53:                                         ; preds = %if.then47
  %51 = load ptr, ptr %drv, align 8
  %bdrv_reopen_prepare54 = getelementptr inbounds %struct.BlockDriver, ptr %51, i32 0, i32 18
  %52 = load ptr, ptr %bdrv_reopen_prepare54, align 8
  %53 = load ptr, ptr %reopen_state.addr, align 8
  %54 = load ptr, ptr %queue.addr, align 8
  %call55 = call i32 %52(ptr noundef %53, ptr noundef %54, ptr noundef %local_err)
  store i32 %call55, ptr %ret, align 4
  %55 = load i32, ptr %ret, align 4
  %tobool56 = icmp ne i32 %55, 0
  br i1 %tobool56, label %if.then57, label %if.end64

if.then57:                                        ; preds = %if.end53
  %56 = load ptr, ptr %local_err, align 8
  %cmp58 = icmp ne ptr %56, null
  br i1 %cmp58, label %if.then59, label %if.else60

if.then59:                                        ; preds = %if.then57
  %57 = load ptr, ptr %errp.addr, align 8
  %58 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %57, ptr noundef %58)
  br label %if.end63

if.else60:                                        ; preds = %if.then57
  call void @bdrv_graph_rdlock_main_loop()
  %59 = load ptr, ptr %reopen_state.addr, align 8
  %bs61 = getelementptr inbounds %struct.BDRVReopenState, ptr %59, i32 0, i32 0
  %60 = load ptr, ptr %bs61, align 8
  call void @bdrv_refresh_filename(ptr noundef %60)
  call void @bdrv_graph_rdunlock_main_loop()
  %61 = load ptr, ptr %errp.addr, align 8
  %62 = load ptr, ptr %reopen_state.addr, align 8
  %bs62 = getelementptr inbounds %struct.BDRVReopenState, ptr %62, i32 0, i32 0
  %63 = load ptr, ptr %bs62, align 8
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %63, i32 0, i32 11
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %filename, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %61, ptr noundef @.str.2, i32 noundef 4994, ptr noundef @__func__.bdrv_reopen_prepare, ptr noundef @.str.260, ptr noundef %arraydecay)
  br label %if.end63

if.end63:                                         ; preds = %if.else60, %if.then59
  br label %error

if.end64:                                         ; preds = %if.end53
  br label %if.end68

if.else65:                                        ; preds = %if.end45
  call void @bdrv_graph_rdlock_main_loop()
  %64 = load ptr, ptr %errp.addr, align 8
  %65 = load ptr, ptr %drv, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %65, i32 0, i32 0
  %66 = load ptr, ptr %format_name, align 8
  %67 = load ptr, ptr %reopen_state.addr, align 8
  %bs66 = getelementptr inbounds %struct.BDRVReopenState, ptr %67, i32 0, i32 0
  %68 = load ptr, ptr %bs66, align 8
  %call67 = call ptr @bdrv_get_device_or_node_name(ptr noundef %68)
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %64, ptr noundef @.str.2, i32 noundef 5004, ptr noundef @__func__.bdrv_reopen_prepare, ptr noundef @.str.261, ptr noundef %66, ptr noundef %call67)
  call void @bdrv_graph_rdunlock_main_loop()
  store i32 -1, ptr %ret, align 4
  br label %error

if.end68:                                         ; preds = %if.end64
  store i8 1, ptr %drv_prepared, align 1
  call void @bdrv_graph_rdlock_main_loop()
  %69 = load ptr, ptr %drv, align 8
  %supports_backing = getelementptr inbounds %struct.BlockDriver, ptr %69, i32 0, i32 7
  %70 = load i8, ptr %supports_backing, align 1
  %tobool69 = trunc i8 %70 to i1
  br i1 %tobool69, label %land.lhs.true, label %if.end79

land.lhs.true:                                    ; preds = %if.end68
  %71 = load ptr, ptr %reopen_state.addr, align 8
  %backing_missing = getelementptr inbounds %struct.BDRVReopenState, ptr %71, i32 0, i32 3
  %72 = load i8, ptr %backing_missing, align 8
  %tobool70 = trunc i8 %72 to i1
  br i1 %tobool70, label %land.lhs.true71, label %if.end79

land.lhs.true71:                                  ; preds = %land.lhs.true
  %73 = load ptr, ptr %reopen_state.addr, align 8
  %bs72 = getelementptr inbounds %struct.BDRVReopenState, ptr %73, i32 0, i32 0
  %74 = load ptr, ptr %bs72, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %74, i32 0, i32 30
  %75 = load ptr, ptr %backing, align 8
  %tobool73 = icmp ne ptr %75, null
  br i1 %tobool73, label %if.then76, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true71
  %76 = load ptr, ptr %reopen_state.addr, align 8
  %bs74 = getelementptr inbounds %struct.BDRVReopenState, ptr %76, i32 0, i32 0
  %77 = load ptr, ptr %bs74, align 8
  %backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %77, i32 0, i32 12
  %arrayidx = getelementptr [4096 x i8], ptr %backing_file, i64 0, i64 0
  %78 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %78 to i32
  %tobool75 = icmp ne i32 %conv, 0
  br i1 %tobool75, label %if.then76, label %if.end79

if.then76:                                        ; preds = %lor.lhs.false, %land.lhs.true71
  %79 = load ptr, ptr %errp.addr, align 8
  %80 = load ptr, ptr %reopen_state.addr, align 8
  %bs77 = getelementptr inbounds %struct.BDRVReopenState, ptr %80, i32 0, i32 0
  %81 = load ptr, ptr %bs77, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %81, i32 0, i32 22
  %arraydecay78 = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %79, ptr noundef @.str.2, i32 noundef 5021, ptr noundef @__func__.bdrv_reopen_prepare, ptr noundef @.str.262, ptr noundef %arraydecay78)
  call void @bdrv_graph_rdunlock_main_loop()
  store i32 -22, ptr %ret, align 4
  br label %error

if.end79:                                         ; preds = %lor.lhs.false, %land.lhs.true, %if.end68
  call void @bdrv_graph_rdunlock_main_loop()
  %82 = load ptr, ptr %reopen_state.addr, align 8
  %83 = load ptr, ptr %change_child_tran.addr, align 8
  %84 = load ptr, ptr %errp.addr, align 8
  %call80 = call i32 @bdrv_reopen_parse_file_or_backing(ptr noundef %82, i1 noundef zeroext true, ptr noundef %83, ptr noundef %84)
  store i32 %call80, ptr %ret, align 4
  %85 = load i32, ptr %ret, align 4
  %cmp81 = icmp slt i32 %85, 0
  br i1 %cmp81, label %if.then83, label %if.end84

if.then83:                                        ; preds = %if.end79
  br label %error

if.end84:                                         ; preds = %if.end79
  %86 = load ptr, ptr %reopen_state.addr, align 8
  %options85 = getelementptr inbounds %struct.BDRVReopenState, ptr %86, i32 0, i32 6
  %87 = load ptr, ptr %options85, align 8
  call void @qdict_del(ptr noundef %87, ptr noundef @.str.89)
  %88 = load ptr, ptr %reopen_state.addr, align 8
  %89 = load ptr, ptr %change_child_tran.addr, align 8
  %90 = load ptr, ptr %errp.addr, align 8
  %call86 = call i32 @bdrv_reopen_parse_file_or_backing(ptr noundef %88, i1 noundef zeroext false, ptr noundef %89, ptr noundef %90)
  store i32 %call86, ptr %ret, align 4
  %91 = load i32, ptr %ret, align 4
  %cmp87 = icmp slt i32 %91, 0
  br i1 %cmp87, label %if.then89, label %if.end90

if.then89:                                        ; preds = %if.end84
  br label %error

if.end90:                                         ; preds = %if.end84
  %92 = load ptr, ptr %reopen_state.addr, align 8
  %options91 = getelementptr inbounds %struct.BDRVReopenState, ptr %92, i32 0, i32 6
  %93 = load ptr, ptr %options91, align 8
  call void @qdict_del(ptr noundef %93, ptr noundef @.str.214)
  %94 = load ptr, ptr %reopen_state.addr, align 8
  %options92 = getelementptr inbounds %struct.BDRVReopenState, ptr %94, i32 0, i32 6
  %95 = load ptr, ptr %options92, align 8
  %call93 = call i64 @qdict_size(ptr noundef %95)
  %tobool94 = icmp ne i64 %call93, 0
  br i1 %tobool94, label %if.then95, label %if.end136

if.then95:                                        ; preds = %if.end90
  %96 = load ptr, ptr %reopen_state.addr, align 8
  %options97 = getelementptr inbounds %struct.BDRVReopenState, ptr %96, i32 0, i32 6
  %97 = load ptr, ptr %options97, align 8
  %call98 = call ptr @qdict_first(ptr noundef %97)
  store ptr %call98, ptr %entry96, align 8
  %call99 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call99, ptr %graph_lockable_auto44, align 8
  br label %do.body100

do.body100:                                       ; preds = %do.cond, %if.then95
  %98 = load ptr, ptr %entry96, align 8
  %value = getelementptr inbounds %struct.QDictEntry, ptr %98, i32 0, i32 1
  %99 = load ptr, ptr %value, align 8
  store ptr %99, ptr %new, align 8
  %100 = load ptr, ptr %reopen_state.addr, align 8
  %bs101 = getelementptr inbounds %struct.BDRVReopenState, ptr %100, i32 0, i32 0
  %101 = load ptr, ptr %bs101, align 8
  %options102 = getelementptr inbounds %struct.BlockDriverState, ptr %101, i32 0, i32 33
  %102 = load ptr, ptr %options102, align 8
  %103 = load ptr, ptr %entry96, align 8
  %key = getelementptr inbounds %struct.QDictEntry, ptr %103, i32 0, i32 0
  %104 = load ptr, ptr %key, align 8
  %call103 = call ptr @qdict_get(ptr noundef %102, ptr noundef %104)
  store ptr %call103, ptr %old, align 8
  %105 = load ptr, ptr %new, align 8
  %call104 = call i32 @qobject_type(ptr noundef %105)
  %cmp105 = icmp eq i32 %call104, 3
  br i1 %cmp105, label %if.then107, label %if.end127

if.then107:                                       ; preds = %do.body100
  %106 = load ptr, ptr %reopen_state.addr, align 8
  %bs108 = getelementptr inbounds %struct.BDRVReopenState, ptr %106, i32 0, i32 0
  %107 = load ptr, ptr %bs108, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %107, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %108 = load ptr, ptr %lh_first, align 8
  store ptr %108, ptr %child, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then107
  %109 = load ptr, ptr %child, align 8
  %tobool109 = icmp ne ptr %109, null
  br i1 %tobool109, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %110 = load ptr, ptr %child, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %110, i32 0, i32 1
  %111 = load ptr, ptr %name, align 8
  %112 = load ptr, ptr %entry96, align 8
  %key110 = getelementptr inbounds %struct.QDictEntry, ptr %112, i32 0, i32 0
  %113 = load ptr, ptr %key110, align 8
  %call111 = call i32 @strcmp(ptr noundef %111, ptr noundef %113) #13
  %tobool112 = icmp ne i32 %call111, 0
  br i1 %tobool112, label %if.end114, label %if.then113

if.then113:                                       ; preds = %for.body
  br label %for.end

if.end114:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end114
  %114 = load ptr, ptr %child, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %114, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %115 = load ptr, ptr %le_next, align 8
  store ptr %115, ptr %child, align 8
  br label %for.cond, !llvm.loop !33

for.end:                                          ; preds = %if.then113, %for.cond
  %116 = load ptr, ptr %child, align 8
  %tobool115 = icmp ne ptr %116, null
  br i1 %tobool115, label %if.then116, label %if.end126

if.then116:                                       ; preds = %for.end
  %117 = load ptr, ptr %child, align 8
  %bs117 = getelementptr inbounds %struct.BdrvChild, ptr %117, i32 0, i32 0
  %118 = load ptr, ptr %bs117, align 8
  %node_name118 = getelementptr inbounds %struct.BlockDriverState, ptr %118, i32 0, i32 22
  %arraydecay119 = getelementptr inbounds [32 x i8], ptr %node_name118, i64 0, i64 0
  %119 = load ptr, ptr %new, align 8
  %call120 = call ptr @qobject_check_type(ptr noundef %119, i32 noundef 3)
  %call121 = call ptr @qstring_get_str(ptr noundef %call120)
  %call122 = call i32 @strcmp(ptr noundef %arraydecay119, ptr noundef %call121) #13
  %tobool123 = icmp ne i32 %call122, 0
  br i1 %tobool123, label %if.end125, label %if.then124

if.then124:                                       ; preds = %if.then116
  br label %do.cond

if.end125:                                        ; preds = %if.then116
  br label %if.end126

if.end126:                                        ; preds = %if.end125, %for.end
  br label %if.end127

if.end127:                                        ; preds = %if.end126, %do.body100
  %120 = load ptr, ptr %new, align 8
  %121 = load ptr, ptr %old, align 8
  %call128 = call zeroext i1 @qobject_is_equal(ptr noundef %120, ptr noundef %121)
  br i1 %call128, label %if.end131, label %if.then129

if.then129:                                       ; preds = %if.end127
  %122 = load ptr, ptr %errp.addr, align 8
  %123 = load ptr, ptr %entry96, align 8
  %key130 = getelementptr inbounds %struct.QDictEntry, ptr %123, i32 0, i32 0
  %124 = load ptr, ptr %key130, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %122, ptr noundef @.str.2, i32 noundef 5095, ptr noundef @__func__.bdrv_reopen_prepare, ptr noundef @.str.263, ptr noundef %124)
  store i32 -22, ptr %ret, align 4
  store i32 4, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end131:                                        ; preds = %if.end127
  br label %do.cond

do.cond:                                          ; preds = %if.end131, %if.then124
  %125 = load ptr, ptr %reopen_state.addr, align 8
  %options132 = getelementptr inbounds %struct.BDRVReopenState, ptr %125, i32 0, i32 6
  %126 = load ptr, ptr %options132, align 8
  %127 = load ptr, ptr %entry96, align 8
  %call133 = call ptr @qdict_next(ptr noundef %126, ptr noundef %127)
  store ptr %call133, ptr %entry96, align 8
  %tobool134 = icmp ne ptr %call133, null
  br i1 %tobool134, label %do.body100, label %do.end135, !llvm.loop !34

do.end135:                                        ; preds = %do.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %do.end135, %if.then129
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto44)
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 4, label %error
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %if.end136

if.end136:                                        ; preds = %cleanup.cont, %if.end90
  store i32 0, ptr %ret, align 4
  %128 = load ptr, ptr %reopen_state.addr, align 8
  %options137 = getelementptr inbounds %struct.BDRVReopenState, ptr %128, i32 0, i32 6
  %129 = load ptr, ptr %options137, align 8
  store ptr %129, ptr %_obj45, align 8
  %130 = load ptr, ptr %_obj45, align 8
  %tobool138 = icmp ne ptr %130, null
  br i1 %tobool138, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end136
  %131 = load ptr, ptr %_obj45, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %131, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %132 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %132, i64 0
  store ptr %add.ptr, ptr %tmp139, align 8
  %133 = load ptr, ptr %tmp139, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end136
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %133, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %134 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %134)
  %135 = load ptr, ptr %orig_reopen_opts, align 8
  store ptr %135, ptr %_o, align 8
  %136 = load ptr, ptr %_o, align 8
  store ptr %136, ptr %_obj46, align 8
  %137 = load ptr, ptr %_obj46, align 8
  %tobool141 = icmp ne ptr %137, null
  br i1 %tobool141, label %cond.true142, label %cond.false147

cond.true142:                                     ; preds = %cond.end
  %138 = load ptr, ptr %_obj46, align 8
  %base144 = getelementptr inbounds %struct.QDict, ptr %138, i32 0, i32 0
  store ptr %base144, ptr %__mptr143, align 8
  %139 = load ptr, ptr %__mptr143, align 8
  %add.ptr146 = getelementptr i8, ptr %139, i64 0
  store ptr %add.ptr146, ptr %tmp145, align 8
  %140 = load ptr, ptr %tmp145, align 8
  br label %cond.end148

cond.false147:                                    ; preds = %cond.end
  br label %cond.end148

cond.end148:                                      ; preds = %cond.false147, %cond.true142
  %cond149 = phi ptr [ %140, %cond.true142 ], [ null, %cond.false147 ]
  store ptr %cond149, ptr %tmp140, align 8
  %141 = load ptr, ptr %tmp140, align 8
  call void @qobject_ref_impl(ptr noundef %141)
  %142 = load ptr, ptr %_o, align 8
  store ptr %142, ptr %tmp150, align 8
  %143 = load ptr, ptr %tmp150, align 8
  %144 = load ptr, ptr %reopen_state.addr, align 8
  %options151 = getelementptr inbounds %struct.BDRVReopenState, ptr %144, i32 0, i32 6
  store ptr %143, ptr %options151, align 8
  br label %error

error:                                            ; preds = %cond.end148, %cleanup, %if.then89, %if.then83, %if.then76, %if.else65, %if.end63, %if.then52, %if.then44, %if.then34, %if.then29, %if.then15
  %145 = load i32, ptr %ret, align 4
  %cmp152 = icmp slt i32 %145, 0
  br i1 %cmp152, label %land.lhs.true154, label %if.end162

land.lhs.true154:                                 ; preds = %error
  %146 = load i8, ptr %drv_prepared, align 1
  %tobool155 = trunc i8 %146 to i1
  br i1 %tobool155, label %if.then157, label %if.end162

if.then157:                                       ; preds = %land.lhs.true154
  %147 = load ptr, ptr %drv, align 8
  %bdrv_reopen_abort = getelementptr inbounds %struct.BlockDriver, ptr %147, i32 0, i32 21
  %148 = load ptr, ptr %bdrv_reopen_abort, align 8
  %tobool158 = icmp ne ptr %148, null
  br i1 %tobool158, label %if.then159, label %if.end161

if.then159:                                       ; preds = %if.then157
  %149 = load ptr, ptr %drv, align 8
  %bdrv_reopen_abort160 = getelementptr inbounds %struct.BlockDriver, ptr %149, i32 0, i32 21
  %150 = load ptr, ptr %bdrv_reopen_abort160, align 8
  %151 = load ptr, ptr %reopen_state.addr, align 8
  call void %150(ptr noundef %151)
  br label %if.end161

if.end161:                                        ; preds = %if.then159, %if.then157
  br label %if.end162

if.end162:                                        ; preds = %if.end161, %land.lhs.true154, %error
  %152 = load ptr, ptr %opts, align 8
  call void @qemu_opts_del(ptr noundef %152)
  %153 = load ptr, ptr %orig_reopen_opts, align 8
  store ptr %153, ptr %_obj47, align 8
  %154 = load ptr, ptr %_obj47, align 8
  %tobool164 = icmp ne ptr %154, null
  br i1 %tobool164, label %cond.true165, label %cond.false170

cond.true165:                                     ; preds = %if.end162
  %155 = load ptr, ptr %_obj47, align 8
  %base167 = getelementptr inbounds %struct.QDict, ptr %155, i32 0, i32 0
  store ptr %base167, ptr %__mptr166, align 8
  %156 = load ptr, ptr %__mptr166, align 8
  %add.ptr169 = getelementptr i8, ptr %156, i64 0
  store ptr %add.ptr169, ptr %tmp168, align 8
  %157 = load ptr, ptr %tmp168, align 8
  br label %cond.end171

cond.false170:                                    ; preds = %if.end162
  br label %cond.end171

cond.end171:                                      ; preds = %cond.false170, %cond.true165
  %cond172 = phi ptr [ %157, %cond.true165 ], [ null, %cond.false170 ]
  store ptr %cond172, ptr %tmp163, align 8
  %158 = load ptr, ptr %tmp163, align 8
  call void @qobject_unref_impl(ptr noundef %158)
  %159 = load ptr, ptr %discard, align 8
  call void @g_free(ptr noundef %159)
  %160 = load i32, ptr %ret, align 4
  ret i32 %160

unreachable:                                      ; preds = %cleanup
  unreachable
}

declare ptr @g_slist_prepend(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_list_refresh_perms(ptr noundef %list, ptr noundef %q, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %list.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %found = alloca ptr, align 8
  %refresh_list = alloca ptr, align 8
  store ptr %list, ptr %list.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %call = call ptr @g_hash_table_new(ptr noundef null, ptr noundef null)
  store ptr %call, ptr %found, align 8
  store ptr null, ptr %refresh_list, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load ptr, ptr %list.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %refresh_list, align 8
  %2 = load ptr, ptr %found, align 8
  %3 = load ptr, ptr %list.addr, align 8
  %data = getelementptr inbounds %struct._GSList, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %data, align 8
  %call1 = call ptr @bdrv_topological_dfs(ptr noundef %1, ptr noundef %2, ptr noundef %4)
  store ptr %call1, ptr %refresh_list, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load ptr, ptr %list.addr, align 8
  %next = getelementptr inbounds %struct._GSList, ptr %5, i32 0, i32 1
  %6 = load ptr, ptr %next, align 8
  store ptr %6, ptr %list.addr, align 8
  br label %for.cond, !llvm.loop !35

for.end:                                          ; preds = %for.cond
  %7 = load ptr, ptr %refresh_list, align 8
  %8 = load ptr, ptr %q.addr, align 8
  %9 = load ptr, ptr %tran.addr, align 8
  %10 = load ptr, ptr %errp.addr, align 8
  %call2 = call i32 @bdrv_do_refresh_perms(ptr noundef %7, ptr noundef %8, ptr noundef %9, ptr noundef %10)
  call void @glib_autoptr_cleanup_GSList(ptr noundef %refresh_list)
  call void @glib_autoptr_cleanup_GHashTable(ptr noundef %found)
  ret i32 %call2
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_reopen_commit(ptr noundef %reopen_state) #0 {
entry:
  %reopen_state.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %child = alloca ptr, align 8
  %graph_lockable_auto48 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %_obj49 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp15 = alloca ptr, align 8
  %_obj50 = alloca ptr, align 8
  %tmp16 = alloca ptr, align 8
  %__mptr19 = alloca ptr, align 8
  %tmp21 = alloca ptr, align 8
  %_o = alloca ptr, align 8
  %_obj51 = alloca ptr, align 8
  %tmp27 = alloca ptr, align 8
  %__mptr30 = alloca ptr, align 8
  %tmp32 = alloca ptr, align 8
  %tmp37 = alloca ptr, align 8
  %_o38 = alloca ptr, align 8
  %_obj52 = alloca ptr, align 8
  %tmp40 = alloca ptr, align 8
  %__mptr43 = alloca ptr, align 8
  %tmp45 = alloca ptr, align 8
  %tmp50 = alloca ptr, align 8
  store ptr %reopen_state, ptr %reopen_state.addr, align 8
  %0 = load ptr, ptr %reopen_state.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.257, ptr noundef @.str.2, i32 noundef 5135, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_commit) #16
  unreachable

if.end:                                           ; preds = %if.then
  %1 = load ptr, ptr %reopen_state.addr, align 8
  %bs1 = getelementptr inbounds %struct.BDRVReopenState, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %bs1, align 8
  store ptr %2, ptr %bs, align 8
  %3 = load ptr, ptr %bs, align 8
  %drv2 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv2, align 8
  store ptr %4, ptr %drv, align 8
  %5 = load ptr, ptr %drv, align 8
  %cmp3 = icmp ne ptr %5, null
  br i1 %cmp3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.end
  br label %if.end6

if.else5:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.240, ptr noundef @.str.2, i32 noundef 5138, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_commit) #16
  unreachable

if.end6:                                          ; preds = %if.then4
  br label %do.body

do.body:                                          ; preds = %if.end6
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then7, label %if.else8

if.then7:                                         ; preds = %do.body
  br label %if.end9

if.else8:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5139, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_commit) #16
  unreachable

if.end9:                                          ; preds = %if.then7
  br label %do.end

do.end:                                           ; preds = %if.end9
  %6 = load ptr, ptr %drv, align 8
  %bdrv_reopen_commit = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 19
  %7 = load ptr, ptr %bdrv_reopen_commit, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %if.then10, label %if.end12

if.then10:                                        ; preds = %do.end
  %8 = load ptr, ptr %drv, align 8
  %bdrv_reopen_commit11 = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 19
  %9 = load ptr, ptr %bdrv_reopen_commit11, align 8
  %10 = load ptr, ptr %reopen_state.addr, align 8
  call void %9(ptr noundef %10)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %do.end
  %call13 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call13, ptr %graph_lockable_auto48, align 8
  %11 = load ptr, ptr %bs, align 8
  %explicit_options = getelementptr inbounds %struct.BlockDriverState, ptr %11, i32 0, i32 34
  %12 = load ptr, ptr %explicit_options, align 8
  store ptr %12, ptr %_obj49, align 8
  %13 = load ptr, ptr %_obj49, align 8
  %tobool14 = icmp ne ptr %13, null
  br i1 %tobool14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end12
  %14 = load ptr, ptr %_obj49, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %14, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %15 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %15, i64 0
  store ptr %add.ptr, ptr %tmp15, align 8
  %16 = load ptr, ptr %tmp15, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end12
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %16, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %17 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %17)
  %18 = load ptr, ptr %bs, align 8
  %options = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 33
  %19 = load ptr, ptr %options, align 8
  store ptr %19, ptr %_obj50, align 8
  %20 = load ptr, ptr %_obj50, align 8
  %tobool17 = icmp ne ptr %20, null
  br i1 %tobool17, label %cond.true18, label %cond.false23

cond.true18:                                      ; preds = %cond.end
  %21 = load ptr, ptr %_obj50, align 8
  %base20 = getelementptr inbounds %struct.QDict, ptr %21, i32 0, i32 0
  store ptr %base20, ptr %__mptr19, align 8
  %22 = load ptr, ptr %__mptr19, align 8
  %add.ptr22 = getelementptr i8, ptr %22, i64 0
  store ptr %add.ptr22, ptr %tmp21, align 8
  %23 = load ptr, ptr %tmp21, align 8
  br label %cond.end24

cond.false23:                                     ; preds = %cond.end
  br label %cond.end24

cond.end24:                                       ; preds = %cond.false23, %cond.true18
  %cond25 = phi ptr [ %23, %cond.true18 ], [ null, %cond.false23 ]
  store ptr %cond25, ptr %tmp16, align 8
  %24 = load ptr, ptr %tmp16, align 8
  call void @qobject_unref_impl(ptr noundef %24)
  %25 = load ptr, ptr %reopen_state.addr, align 8
  %explicit_options26 = getelementptr inbounds %struct.BDRVReopenState, ptr %25, i32 0, i32 7
  %26 = load ptr, ptr %explicit_options26, align 8
  store ptr %26, ptr %_o, align 8
  %27 = load ptr, ptr %_o, align 8
  store ptr %27, ptr %_obj51, align 8
  %28 = load ptr, ptr %_obj51, align 8
  %tobool28 = icmp ne ptr %28, null
  br i1 %tobool28, label %cond.true29, label %cond.false34

cond.true29:                                      ; preds = %cond.end24
  %29 = load ptr, ptr %_obj51, align 8
  %base31 = getelementptr inbounds %struct.QDict, ptr %29, i32 0, i32 0
  store ptr %base31, ptr %__mptr30, align 8
  %30 = load ptr, ptr %__mptr30, align 8
  %add.ptr33 = getelementptr i8, ptr %30, i64 0
  store ptr %add.ptr33, ptr %tmp32, align 8
  %31 = load ptr, ptr %tmp32, align 8
  br label %cond.end35

cond.false34:                                     ; preds = %cond.end24
  br label %cond.end35

cond.end35:                                       ; preds = %cond.false34, %cond.true29
  %cond36 = phi ptr [ %31, %cond.true29 ], [ null, %cond.false34 ]
  store ptr %cond36, ptr %tmp27, align 8
  %32 = load ptr, ptr %tmp27, align 8
  call void @qobject_ref_impl(ptr noundef %32)
  %33 = load ptr, ptr %_o, align 8
  store ptr %33, ptr %tmp37, align 8
  %34 = load ptr, ptr %reopen_state.addr, align 8
  %options39 = getelementptr inbounds %struct.BDRVReopenState, ptr %34, i32 0, i32 6
  %35 = load ptr, ptr %options39, align 8
  store ptr %35, ptr %_o38, align 8
  %36 = load ptr, ptr %_o38, align 8
  store ptr %36, ptr %_obj52, align 8
  %37 = load ptr, ptr %_obj52, align 8
  %tobool41 = icmp ne ptr %37, null
  br i1 %tobool41, label %cond.true42, label %cond.false47

cond.true42:                                      ; preds = %cond.end35
  %38 = load ptr, ptr %_obj52, align 8
  %base44 = getelementptr inbounds %struct.QDict, ptr %38, i32 0, i32 0
  store ptr %base44, ptr %__mptr43, align 8
  %39 = load ptr, ptr %__mptr43, align 8
  %add.ptr46 = getelementptr i8, ptr %39, i64 0
  store ptr %add.ptr46, ptr %tmp45, align 8
  %40 = load ptr, ptr %tmp45, align 8
  br label %cond.end48

cond.false47:                                     ; preds = %cond.end35
  br label %cond.end48

cond.end48:                                       ; preds = %cond.false47, %cond.true42
  %cond49 = phi ptr [ %40, %cond.true42 ], [ null, %cond.false47 ]
  store ptr %cond49, ptr %tmp40, align 8
  %41 = load ptr, ptr %tmp40, align 8
  call void @qobject_ref_impl(ptr noundef %41)
  %42 = load ptr, ptr %_o38, align 8
  store ptr %42, ptr %tmp50, align 8
  %43 = load ptr, ptr %reopen_state.addr, align 8
  %explicit_options51 = getelementptr inbounds %struct.BDRVReopenState, ptr %43, i32 0, i32 7
  %44 = load ptr, ptr %explicit_options51, align 8
  %45 = load ptr, ptr %bs, align 8
  %explicit_options52 = getelementptr inbounds %struct.BlockDriverState, ptr %45, i32 0, i32 34
  store ptr %44, ptr %explicit_options52, align 8
  %46 = load ptr, ptr %reopen_state.addr, align 8
  %options53 = getelementptr inbounds %struct.BDRVReopenState, ptr %46, i32 0, i32 6
  %47 = load ptr, ptr %options53, align 8
  %48 = load ptr, ptr %bs, align 8
  %options54 = getelementptr inbounds %struct.BlockDriverState, ptr %48, i32 0, i32 33
  store ptr %47, ptr %options54, align 8
  %49 = load ptr, ptr %reopen_state.addr, align 8
  %flags = getelementptr inbounds %struct.BDRVReopenState, ptr %49, i32 0, i32 1
  %50 = load i32, ptr %flags, align 8
  %51 = load ptr, ptr %bs, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %51, i32 0, i32 0
  store i32 %50, ptr %open_flags, align 8
  %52 = load ptr, ptr %reopen_state.addr, align 8
  %detect_zeroes = getelementptr inbounds %struct.BDRVReopenState, ptr %52, i32 0, i32 2
  %53 = load i32, ptr %detect_zeroes, align 4
  %54 = load ptr, ptr %bs, align 8
  %detect_zeroes55 = getelementptr inbounds %struct.BlockDriverState, ptr %54, i32 0, i32 35
  store i32 %53, ptr %detect_zeroes55, align 8
  %55 = load ptr, ptr %bs, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %55, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %56 = load ptr, ptr %lh_first, align 8
  store ptr %56, ptr %child, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end48
  %57 = load ptr, ptr %child, align 8
  %tobool56 = icmp ne ptr %57, null
  br i1 %tobool56, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %58 = load ptr, ptr %bs, align 8
  %explicit_options57 = getelementptr inbounds %struct.BlockDriverState, ptr %58, i32 0, i32 34
  %59 = load ptr, ptr %explicit_options57, align 8
  %60 = load ptr, ptr %child, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %60, i32 0, i32 1
  %61 = load ptr, ptr %name, align 8
  call void @qdict_del(ptr noundef %59, ptr noundef %61)
  %62 = load ptr, ptr %bs, align 8
  %options58 = getelementptr inbounds %struct.BlockDriverState, ptr %62, i32 0, i32 33
  %63 = load ptr, ptr %options58, align 8
  %64 = load ptr, ptr %child, align 8
  %name59 = getelementptr inbounds %struct.BdrvChild, ptr %64, i32 0, i32 1
  %65 = load ptr, ptr %name59, align 8
  call void @qdict_del(ptr noundef %63, ptr noundef %65)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %66 = load ptr, ptr %child, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %66, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %67 = load ptr, ptr %le_next, align 8
  store ptr %67, ptr %child, align 8
  br label %for.cond, !llvm.loop !36

for.end:                                          ; preds = %for.cond
  %68 = load ptr, ptr %bs, align 8
  %explicit_options60 = getelementptr inbounds %struct.BlockDriverState, ptr %68, i32 0, i32 34
  %69 = load ptr, ptr %explicit_options60, align 8
  call void @qdict_del(ptr noundef %69, ptr noundef @.str.89)
  %70 = load ptr, ptr %bs, align 8
  %options61 = getelementptr inbounds %struct.BlockDriverState, ptr %70, i32 0, i32 33
  %71 = load ptr, ptr %options61, align 8
  call void @qdict_del(ptr noundef %71, ptr noundef @.str.89)
  %72 = load ptr, ptr %bs, align 8
  call void @bdrv_refresh_limits(ptr noundef %72, ptr noundef null, ptr noundef null)
  %73 = load ptr, ptr %bs, align 8
  %74 = load ptr, ptr %bs, align 8
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %74, i32 0, i32 37
  %75 = load i64, ptr %total_sectors, align 8
  %call62 = call i32 @bdrv_refresh_total_sectors(ptr noundef %73, i64 noundef %75)
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto48)
  ret void
}

declare void @tran_commit(ptr noundef) #2

declare void @tran_abort(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_reopen_abort(ptr noundef %reopen_state) #0 {
entry:
  %reopen_state.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  store ptr %reopen_state, ptr %reopen_state.addr, align 8
  %0 = load ptr, ptr %reopen_state.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.257, ptr noundef @.str.2, i32 noundef 5181, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_abort) #16
  unreachable

if.end:                                           ; preds = %if.then
  %1 = load ptr, ptr %reopen_state.addr, align 8
  %bs = getelementptr inbounds %struct.BDRVReopenState, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %bs, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv1, align 8
  store ptr %3, ptr %drv, align 8
  %4 = load ptr, ptr %drv, align 8
  %cmp2 = icmp ne ptr %4, null
  br i1 %cmp2, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.end
  br label %if.end5

if.else4:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.240, ptr noundef @.str.2, i32 noundef 5183, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_abort) #16
  unreachable

if.end5:                                          ; preds = %if.then3
  br label %do.body

do.body:                                          ; preds = %if.end5
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then6, label %if.else7

if.then6:                                         ; preds = %do.body
  br label %if.end8

if.else7:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5184, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_abort) #16
  unreachable

if.end8:                                          ; preds = %if.then6
  br label %do.end

do.end:                                           ; preds = %if.end8
  %5 = load ptr, ptr %drv, align 8
  %bdrv_reopen_abort = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 21
  %6 = load ptr, ptr %bdrv_reopen_abort, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.then9, label %if.end11

if.then9:                                         ; preds = %do.end
  %7 = load ptr, ptr %drv, align 8
  %bdrv_reopen_abort10 = getelementptr inbounds %struct.BlockDriver, ptr %7, i32 0, i32 21
  %8 = load ptr, ptr %bdrv_reopen_abort10, align 8
  %9 = load ptr, ptr %reopen_state.addr, align 8
  call void %8(ptr noundef %9)
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_reopen(ptr noundef %bs, ptr noundef %opts, i1 noundef zeroext %keep_old_opts, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %opts.addr = alloca ptr, align 8
  %keep_old_opts.addr = alloca i8, align 1
  %errp.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %queue = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %opts, ptr %opts.addr, align 8
  %frombool = zext i1 %keep_old_opts to i8
  store i8 %frombool, ptr %keep_old_opts.addr, align 1
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_get_aio_context(ptr noundef %0)
  store ptr %call, ptr %ctx, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 4698, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load ptr, ptr %bs.addr, align 8
  %2 = load ptr, ptr %opts.addr, align 8
  %3 = load i8, ptr %keep_old_opts.addr, align 1
  %tobool = trunc i8 %3 to i1
  %call2 = call ptr @bdrv_reopen_queue(ptr noundef null, ptr noundef %1, ptr noundef %2, i1 noundef zeroext %tobool)
  store ptr %call2, ptr %queue, align 8
  %4 = load ptr, ptr %ctx, align 8
  %call3 = call ptr @qemu_get_aio_context()
  %cmp = icmp ne ptr %4, %call3
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %do.end
  %5 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %5)
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %do.end
  %6 = load ptr, ptr %queue, align 8
  %7 = load ptr, ptr %errp.addr, align 8
  %call6 = call i32 @bdrv_reopen_multiple(ptr noundef %6, ptr noundef %7)
  store i32 %call6, ptr %ret, align 4
  %8 = load ptr, ptr %ctx, align 8
  %call7 = call ptr @qemu_get_aio_context()
  %cmp8 = icmp ne ptr %8, %call7
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end5
  %9 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %9)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end5
  %10 = load i32, ptr %ret, align 4
  ret i32 %10
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_reopen_set_read_only(ptr noundef %bs, i1 noundef zeroext %read_only, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %read_only.addr = alloca i8, align 1
  %errp.addr = alloca ptr, align 8
  %opts = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %frombool = zext i1 %read_only to i8
  store i8 %frombool, ptr %read_only.addr, align 1
  store ptr %errp, ptr %errp.addr, align 8
  %call = call ptr @qdict_new()
  store ptr %call, ptr %opts, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 4719, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_set_read_only) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %opts, align 8
  %1 = load i8, ptr %read_only.addr, align 1
  %tobool = trunc i8 %1 to i1
  call void @qdict_put_bool(ptr noundef %0, ptr noundef @.str.51, i1 noundef zeroext %tobool)
  %2 = load ptr, ptr %bs.addr, align 8
  %3 = load ptr, ptr %opts, align 8
  %4 = load ptr, ptr %errp.addr, align 8
  %call2 = call i32 @bdrv_reopen(ptr noundef %2, ptr noundef %3, i1 noundef zeroext true, ptr noundef %4)
  ret i32 %call2
}

declare void @qdict_put_bool(ptr noundef, ptr noundef, i1 noundef zeroext) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_close_all() #0 {
entry:
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5259, ptr noundef @__PRETTY_FUNCTION__.bdrv_close_all) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @job_next(ptr noundef null)
  %cmp = icmp eq ptr %call1, null
  br i1 %cmp, label %if.then2, label %if.else3

if.then2:                                         ; preds = %do.end
  br label %if.end4

if.else3:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.86, ptr noundef @.str.2, i32 noundef 5260, ptr noundef @__PRETTY_FUNCTION__.bdrv_close_all) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  call void @bdrv_drain_all()
  call void @blk_remove_all_bs()
  call void @blockdev_close_all_bdrv_states()
  %0 = load ptr, ptr @all_bdrv_states, align 8
  %cmp5 = icmp eq ptr %0, null
  br i1 %cmp5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.end4
  br label %if.end8

if.else7:                                         ; preds = %if.end4
  call void @__assert_fail(ptr noundef @.str.87, ptr noundef @.str.2, i32 noundef 5269, ptr noundef @__PRETTY_FUNCTION__.bdrv_close_all) #16
  unreachable

if.end8:                                          ; preds = %if.then6
  ret void
}

declare ptr @job_next(ptr noundef) #2

declare void @bdrv_drain_all() #2

declare void @blk_remove_all_bs() #2

declare void @blockdev_close_all_bdrv_states() #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_replace_node(ptr noundef %from, ptr noundef %to, ptr noundef %errp) #0 {
entry:
  %from.addr = alloca ptr, align 8
  %to.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  store ptr %from, ptr %from.addr, align 8
  store ptr %to, ptr %to.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %from.addr, align 8
  %1 = load ptr, ptr %to.addr, align 8
  %2 = load ptr, ptr %errp.addr, align 8
  %call = call i32 @bdrv_replace_node_common(ptr noundef %0, ptr noundef %1, i1 noundef zeroext true, i1 noundef zeroext false, ptr noundef %2)
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_replace_node_common(ptr noundef %from, ptr noundef %to, i1 noundef zeroext %auto_skip, i1 noundef zeroext %detach_subchain, ptr noundef %errp) #0 {
entry:
  %from.addr = alloca ptr, align 8
  %to.addr = alloca ptr, align 8
  %auto_skip.addr = alloca i8, align 1
  %detach_subchain.addr = alloca i8, align 1
  %errp.addr = alloca ptr, align 8
  %tran = alloca ptr, align 8
  %refresh_list = alloca ptr, align 8
  %to_cow_parent = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %from, ptr %from.addr, align 8
  store ptr %to, ptr %to.addr, align 8
  %frombool = zext i1 %auto_skip to i8
  store i8 %frombool, ptr %auto_skip.addr, align 1
  %frombool1 = zext i1 %detach_subchain to i8
  store i8 %frombool1, ptr %detach_subchain.addr, align 1
  store ptr %errp, ptr %errp.addr, align 8
  %call = call ptr @tran_new()
  store ptr %call, ptr %tran, align 8
  store ptr null, ptr %refresh_list, align 8
  store ptr null, ptr %to_cow_parent, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call2 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5446, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_node_common) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  %0 = load ptr, ptr %from.addr, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 46
  %1 = load i32, ptr %quiesce_counter, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then3, label %if.else4

if.then3:                                         ; preds = %do.end
  br label %if.end5

if.else4:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.268, ptr noundef @.str.2, i32 noundef 5448, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_node_common) #16
  unreachable

if.end5:                                          ; preds = %if.then3
  %2 = load ptr, ptr %to.addr, align 8
  %quiesce_counter6 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 46
  %3 = load i32, ptr %quiesce_counter6, align 8
  %tobool7 = icmp ne i32 %3, 0
  br i1 %tobool7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %if.end5
  br label %if.end10

if.else9:                                         ; preds = %if.end5
  call void @__assert_fail(ptr noundef @.str.269, ptr noundef @.str.2, i32 noundef 5449, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_node_common) #16
  unreachable

if.end10:                                         ; preds = %if.then8
  %4 = load ptr, ptr %from.addr, align 8
  %call11 = call ptr @bdrv_get_aio_context(ptr noundef %4)
  %5 = load ptr, ptr %to.addr, align 8
  %call12 = call ptr @bdrv_get_aio_context(ptr noundef %5)
  %cmp = icmp eq ptr %call11, %call12
  br i1 %cmp, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.end10
  br label %if.end15

if.else14:                                        ; preds = %if.end10
  call void @__assert_fail(ptr noundef @.str.270, ptr noundef @.str.2, i32 noundef 5450, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_node_common) #16
  unreachable

if.end15:                                         ; preds = %if.then13
  %6 = load i8, ptr %detach_subchain.addr, align 1
  %tobool16 = trunc i8 %6 to i1
  br i1 %tobool16, label %if.then17, label %if.end29

if.then17:                                        ; preds = %if.end15
  %7 = load ptr, ptr %from.addr, align 8
  %8 = load ptr, ptr %to.addr, align 8
  %call18 = call zeroext i1 @bdrv_chain_contains(ptr noundef %7, ptr noundef %8)
  br i1 %call18, label %if.then19, label %if.else20

if.then19:                                        ; preds = %if.then17
  br label %if.end21

if.else20:                                        ; preds = %if.then17
  call void @__assert_fail(ptr noundef @.str.271, ptr noundef @.str.2, i32 noundef 5453, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_node_common) #16
  unreachable

if.end21:                                         ; preds = %if.then19
  %9 = load ptr, ptr %from.addr, align 8
  %10 = load ptr, ptr %to.addr, align 8
  %cmp22 = icmp ne ptr %9, %10
  br i1 %cmp22, label %if.then23, label %if.else24

if.then23:                                        ; preds = %if.end21
  br label %if.end25

if.else24:                                        ; preds = %if.end21
  call void @__assert_fail(ptr noundef @.str.272, ptr noundef @.str.2, i32 noundef 5454, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_node_common) #16
  unreachable

if.end25:                                         ; preds = %if.then23
  %11 = load ptr, ptr %from.addr, align 8
  store ptr %11, ptr %to_cow_parent, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end25
  %12 = load ptr, ptr %to_cow_parent, align 8
  %call26 = call ptr @bdrv_filter_or_cow_bs(ptr noundef %12)
  %13 = load ptr, ptr %to.addr, align 8
  %cmp27 = icmp ne ptr %call26, %13
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load ptr, ptr %to_cow_parent, align 8
  %call28 = call ptr @bdrv_filter_or_cow_bs(ptr noundef %14)
  store ptr %call28, ptr %to_cow_parent, align 8
  br label %for.cond, !llvm.loop !37

for.end:                                          ; preds = %for.cond
  br label %if.end29

if.end29:                                         ; preds = %for.end, %if.end15
  %15 = load ptr, ptr %from.addr, align 8
  %16 = load ptr, ptr %to.addr, align 8
  %17 = load i8, ptr %auto_skip.addr, align 1
  %tobool30 = trunc i8 %17 to i1
  %18 = load ptr, ptr %tran, align 8
  %19 = load ptr, ptr %errp.addr, align 8
  %call31 = call i32 @bdrv_replace_node_noperm(ptr noundef %15, ptr noundef %16, i1 noundef zeroext %tobool30, ptr noundef %18, ptr noundef %19)
  store i32 %call31, ptr %ret, align 4
  %20 = load i32, ptr %ret, align 4
  %cmp32 = icmp slt i32 %20, 0
  br i1 %cmp32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end29
  br label %out

if.end34:                                         ; preds = %if.end29
  %21 = load i8, ptr %detach_subchain.addr, align 1
  %tobool35 = trunc i8 %21 to i1
  br i1 %tobool35, label %if.then36, label %if.end38

if.then36:                                        ; preds = %if.end34
  %22 = load ptr, ptr %to_cow_parent, align 8
  %call37 = call ptr @bdrv_filter_or_cow_child(ptr noundef %22)
  %23 = load ptr, ptr %tran, align 8
  call void @bdrv_remove_child(ptr noundef %call37, ptr noundef %23)
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %if.end34
  %24 = load ptr, ptr %refresh_list, align 8
  %25 = load ptr, ptr %to.addr, align 8
  %call39 = call ptr @g_slist_prepend(ptr noundef %24, ptr noundef %25)
  store ptr %call39, ptr %refresh_list, align 8
  %26 = load ptr, ptr %refresh_list, align 8
  %27 = load ptr, ptr %from.addr, align 8
  %call40 = call ptr @g_slist_prepend(ptr noundef %26, ptr noundef %27)
  store ptr %call40, ptr %refresh_list, align 8
  %28 = load ptr, ptr %refresh_list, align 8
  %29 = load ptr, ptr %tran, align 8
  %30 = load ptr, ptr %errp.addr, align 8
  %call41 = call i32 @bdrv_list_refresh_perms(ptr noundef %28, ptr noundef null, ptr noundef %29, ptr noundef %30)
  store i32 %call41, ptr %ret, align 4
  %31 = load i32, ptr %ret, align 4
  %cmp42 = icmp slt i32 %31, 0
  br i1 %cmp42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end38
  br label %out

if.end44:                                         ; preds = %if.end38
  store i32 0, ptr %ret, align 4
  br label %out

out:                                              ; preds = %if.end44, %if.then43, %if.then33
  %32 = load ptr, ptr %tran, align 8
  %33 = load i32, ptr %ret, align 4
  call void @tran_finalize(ptr noundef %32, i32 noundef %33)
  %34 = load i32, ptr %ret, align 4
  call void @glib_autoptr_cleanup_GSList(ptr noundef %refresh_list)
  ret i32 %34
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_drop_filter(ptr noundef %bs, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %child_bs = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5505, ptr noundef @__PRETTY_FUNCTION__.bdrv_drop_filter) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  call void @bdrv_graph_rdlock_main_loop()
  %0 = load ptr, ptr %bs.addr, align 8
  %call1 = call ptr @bdrv_filter_or_cow_bs(ptr noundef %0)
  store ptr %call1, ptr %child_bs, align 8
  call void @bdrv_graph_rdunlock_main_loop()
  %1 = load ptr, ptr %child_bs, align 8
  call void @bdrv_drained_begin(ptr noundef %1)
  %2 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_graph_wrlock(ptr noundef %2)
  %3 = load ptr, ptr %bs.addr, align 8
  %4 = load ptr, ptr %child_bs, align 8
  %5 = load ptr, ptr %errp.addr, align 8
  %call2 = call i32 @bdrv_replace_node_common(ptr noundef %3, ptr noundef %4, i1 noundef zeroext true, i1 noundef zeroext true, ptr noundef %5)
  store i32 %call2, ptr %ret, align 4
  %6 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_graph_wrunlock(ptr noundef %6)
  %7 = load ptr, ptr %child_bs, align 8
  call void @bdrv_drained_end(ptr noundef %7)
  %8 = load i32, ptr %ret, align 4
  ret i32 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_filter_or_cow_bs(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_filter_or_cow_child(ptr noundef %0)
  %call1 = call ptr @child_bs(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_append(ptr noundef %bs_new, ptr noundef %bs_top, ptr noundef %errp) #0 {
entry:
  %bs_new.addr = alloca ptr, align 8
  %bs_top.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %child = alloca ptr, align 8
  %tran = alloca ptr, align 8
  %old_context = alloca ptr, align 8
  %new_context = alloca ptr, align 8
  store ptr %bs_new, ptr %bs_new.addr, align 8
  store ptr %bs_top, ptr %bs_top.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %call = call ptr @tran_new()
  store ptr %call, ptr %tran, align 8
  store ptr null, ptr %new_context, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5542, ptr noundef @__PRETTY_FUNCTION__.bdrv_append) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  call void @bdrv_graph_rdlock_main_loop()
  %0 = load ptr, ptr %bs_new.addr, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 30
  %1 = load ptr, ptr %backing, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.else3, label %if.then2

if.then2:                                         ; preds = %do.end
  br label %if.end4

if.else3:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.88, ptr noundef @.str.2, i32 noundef 5545, ptr noundef @__PRETTY_FUNCTION__.bdrv_append) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  call void @bdrv_graph_rdunlock_main_loop()
  %2 = load ptr, ptr %bs_top.addr, align 8
  %call5 = call ptr @bdrv_get_aio_context(ptr noundef %2)
  store ptr %call5, ptr %old_context, align 8
  %3 = load ptr, ptr %bs_top.addr, align 8
  call void @bdrv_drained_begin(ptr noundef %3)
  %4 = load ptr, ptr %bs_new.addr, align 8
  %call6 = call ptr @bdrv_get_aio_context(ptr noundef %4)
  store ptr %call6, ptr %new_context, align 8
  %5 = load ptr, ptr %old_context, align 8
  call void @aio_context_release(ptr noundef %5)
  %6 = load ptr, ptr %new_context, align 8
  call void @aio_context_acquire(ptr noundef %6)
  %7 = load ptr, ptr %bs_new.addr, align 8
  call void @bdrv_drained_begin(ptr noundef %7)
  %8 = load ptr, ptr %new_context, align 8
  call void @aio_context_release(ptr noundef %8)
  %9 = load ptr, ptr %old_context, align 8
  call void @aio_context_acquire(ptr noundef %9)
  store ptr null, ptr %new_context, align 8
  %10 = load ptr, ptr %bs_top.addr, align 8
  call void @bdrv_graph_wrlock(ptr noundef %10)
  %11 = load ptr, ptr %bs_new.addr, align 8
  %12 = load ptr, ptr %bs_top.addr, align 8
  %13 = load ptr, ptr %bs_new.addr, align 8
  %call7 = call i32 @bdrv_backing_role(ptr noundef %13)
  %14 = load ptr, ptr %tran, align 8
  %15 = load ptr, ptr %errp.addr, align 8
  %call8 = call ptr @bdrv_attach_child_noperm(ptr noundef %11, ptr noundef %12, ptr noundef @.str.89, ptr noundef @child_of_bds, i32 noundef %call7, ptr noundef %14, ptr noundef %15)
  store ptr %call8, ptr %child, align 8
  %16 = load ptr, ptr %child, align 8
  %tobool9 = icmp ne ptr %16, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end4
  store i32 -22, ptr %ret, align 4
  br label %out

if.end11:                                         ; preds = %if.end4
  %17 = load ptr, ptr %bs_top.addr, align 8
  %call12 = call ptr @bdrv_get_aio_context(ptr noundef %17)
  store ptr %call12, ptr %new_context, align 8
  %18 = load ptr, ptr %old_context, align 8
  %19 = load ptr, ptr %new_context, align 8
  %cmp = icmp ne ptr %18, %19
  br i1 %cmp, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  %20 = load ptr, ptr %old_context, align 8
  call void @aio_context_release(ptr noundef %20)
  %21 = load ptr, ptr %new_context, align 8
  call void @aio_context_acquire(ptr noundef %21)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end11
  %22 = load ptr, ptr %bs_top.addr, align 8
  %23 = load ptr, ptr %bs_new.addr, align 8
  %24 = load ptr, ptr %tran, align 8
  %25 = load ptr, ptr %errp.addr, align 8
  %call15 = call i32 @bdrv_replace_node_noperm(ptr noundef %22, ptr noundef %23, i1 noundef zeroext true, ptr noundef %24, ptr noundef %25)
  store i32 %call15, ptr %ret, align 4
  %26 = load i32, ptr %ret, align 4
  %cmp16 = icmp slt i32 %26, 0
  br i1 %cmp16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  br label %out

if.end18:                                         ; preds = %if.end14
  %27 = load ptr, ptr %bs_new.addr, align 8
  %28 = load ptr, ptr %tran, align 8
  %29 = load ptr, ptr %errp.addr, align 8
  %call19 = call i32 @bdrv_refresh_perms(ptr noundef %27, ptr noundef %28, ptr noundef %29)
  store i32 %call19, ptr %ret, align 4
  br label %out

out:                                              ; preds = %if.end18, %if.then17, %if.then10
  %30 = load ptr, ptr %tran, align 8
  %31 = load i32, ptr %ret, align 4
  call void @tran_finalize(ptr noundef %30, i32 noundef %31)
  %32 = load ptr, ptr %bs_top.addr, align 8
  call void @bdrv_refresh_limits(ptr noundef %32, ptr noundef null, ptr noundef null)
  %33 = load ptr, ptr %bs_top.addr, align 8
  call void @bdrv_graph_wrunlock(ptr noundef %33)
  %34 = load ptr, ptr %bs_top.addr, align 8
  call void @bdrv_drained_end(ptr noundef %34)
  %35 = load ptr, ptr %bs_new.addr, align 8
  call void @bdrv_drained_end(ptr noundef %35)
  %36 = load ptr, ptr %new_context, align 8
  %tobool20 = icmp ne ptr %36, null
  br i1 %tobool20, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %out
  %37 = load ptr, ptr %old_context, align 8
  %38 = load ptr, ptr %new_context, align 8
  %cmp21 = icmp ne ptr %37, %38
  br i1 %cmp21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %land.lhs.true
  %39 = load ptr, ptr %new_context, align 8
  call void @aio_context_release(ptr noundef %39)
  %40 = load ptr, ptr %old_context, align 8
  call void @aio_context_acquire(ptr noundef %40)
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %land.lhs.true, %out
  %41 = load i32, ptr %ret, align 4
  ret i32 %41
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_replace_node_noperm(ptr noundef %from, ptr noundef %to, i1 noundef zeroext %auto_skip, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %from.addr = alloca ptr, align 8
  %to.addr = alloca ptr, align 8
  %auto_skip.addr = alloca i8, align 1
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %from, ptr %from.addr, align 8
  store ptr %to, ptr %to.addr, align 8
  %frombool = zext i1 %auto_skip to i8
  store i8 %frombool, ptr %auto_skip.addr, align 1
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5398, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_node_noperm) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %from.addr, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 46
  %1 = load i32, ptr %quiesce_counter, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.end
  br label %if.end3

if.else2:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.268, ptr noundef @.str.2, i32 noundef 5400, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_node_noperm) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  %2 = load ptr, ptr %to.addr, align 8
  %quiesce_counter4 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 46
  %3 = load i32, ptr %quiesce_counter4, align 8
  %tobool5 = icmp ne i32 %3, 0
  br i1 %tobool5, label %if.then6, label %if.else7

if.then6:                                         ; preds = %if.end3
  br label %if.end8

if.else7:                                         ; preds = %if.end3
  call void @__assert_fail(ptr noundef @.str.269, ptr noundef @.str.2, i32 noundef 5401, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_node_noperm) #16
  unreachable

if.end8:                                          ; preds = %if.then6
  %4 = load ptr, ptr %from.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %5 = load ptr, ptr %lh_first, align 8
  store ptr %5, ptr %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end8
  %6 = load ptr, ptr %c, align 8
  %tobool9 = icmp ne ptr %6, null
  br i1 %tobool9, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %7 = load ptr, ptr %c, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %7, i32 0, i32 10
  %le_next = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %8 = load ptr, ptr %le_next, align 8
  store ptr %8, ptr %next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %9 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %9, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %10 = load ptr, ptr %c, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %bs, align 8
  %12 = load ptr, ptr %from.addr, align 8
  %cmp = icmp eq ptr %11, %12
  br i1 %cmp, label %if.then10, label %if.else11

if.then10:                                        ; preds = %for.body
  br label %if.end12

if.else11:                                        ; preds = %for.body
  call void @__assert_fail(ptr noundef @.str.273, ptr noundef @.str.2, i32 noundef 5404, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_node_noperm) #16
  unreachable

if.end12:                                         ; preds = %if.then10
  %13 = load ptr, ptr %c, align 8
  %14 = load ptr, ptr %to.addr, align 8
  %call13 = call zeroext i1 @should_update_child(ptr noundef %13, ptr noundef %14)
  br i1 %call13, label %if.end18, label %if.then14

if.then14:                                        ; preds = %if.end12
  %15 = load i8, ptr %auto_skip.addr, align 1
  %tobool15 = trunc i8 %15 to i1
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then14
  br label %for.inc

if.end17:                                         ; preds = %if.then14
  %16 = load ptr, ptr %errp.addr, align 8
  %17 = load ptr, ptr %c, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %17, i32 0, i32 1
  %18 = load ptr, ptr %name, align 8
  %19 = load ptr, ptr %from.addr, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %19, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %16, ptr noundef @.str.2, i32 noundef 5410, ptr noundef @__func__.bdrv_replace_node_noperm, ptr noundef @.str.274, ptr noundef %18, ptr noundef %arraydecay)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end12
  %20 = load ptr, ptr %c, align 8
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %20, i32 0, i32 7
  %21 = load i8, ptr %frozen, align 8
  %tobool19 = trunc i8 %21 to i1
  br i1 %tobool19, label %if.then20, label %if.end24

if.then20:                                        ; preds = %if.end18
  %22 = load ptr, ptr %errp.addr, align 8
  %23 = load ptr, ptr %c, align 8
  %name21 = getelementptr inbounds %struct.BdrvChild, ptr %23, i32 0, i32 1
  %24 = load ptr, ptr %name21, align 8
  %25 = load ptr, ptr %from.addr, align 8
  %node_name22 = getelementptr inbounds %struct.BlockDriverState, ptr %25, i32 0, i32 22
  %arraydecay23 = getelementptr inbounds [32 x i8], ptr %node_name22, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %22, ptr noundef @.str.2, i32 noundef 5415, ptr noundef @__func__.bdrv_replace_node_noperm, ptr noundef @.str.275, ptr noundef %24, ptr noundef %arraydecay23)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end24:                                         ; preds = %if.end18
  %26 = load ptr, ptr %c, align 8
  %27 = load ptr, ptr %to.addr, align 8
  %28 = load ptr, ptr %tran.addr, align 8
  call void @bdrv_replace_child_tran(ptr noundef %26, ptr noundef %27, ptr noundef %28)
  br label %for.inc

for.inc:                                          ; preds = %if.end24, %if.then16
  %29 = load ptr, ptr %next, align 8
  store ptr %29, ptr %c, align 8
  br label %for.cond, !llvm.loop !38

for.end:                                          ; preds = %land.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then20, %if.end17
  %30 = load i32, ptr %retval, align 4
  ret i32 %30
}

declare void @bdrv_refresh_limits(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_replace_child_bs(ptr noundef %child, ptr noundef %new_bs, ptr noundef %errp) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %new_bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %tran = alloca ptr, align 8
  %refresh_list = alloca ptr, align 8
  %old_bs = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  store ptr %new_bs, ptr %new_bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %call = call ptr @tran_new()
  store ptr %call, ptr %tran, align 8
  store ptr null, ptr %refresh_list, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %bs, align 8
  store ptr %1, ptr %old_bs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5618, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_bs) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  %2 = load ptr, ptr %old_bs, align 8
  call void @bdrv_ref(ptr noundef %2)
  %3 = load ptr, ptr %old_bs, align 8
  call void @bdrv_drained_begin(ptr noundef %3)
  %4 = load ptr, ptr %new_bs.addr, align 8
  call void @bdrv_drained_begin(ptr noundef %4)
  %5 = load ptr, ptr %new_bs.addr, align 8
  call void @bdrv_graph_wrlock(ptr noundef %5)
  %6 = load ptr, ptr %child.addr, align 8
  %7 = load ptr, ptr %new_bs.addr, align 8
  %8 = load ptr, ptr %tran, align 8
  call void @bdrv_replace_child_tran(ptr noundef %6, ptr noundef %7, ptr noundef %8)
  %9 = load ptr, ptr %refresh_list, align 8
  %10 = load ptr, ptr %old_bs, align 8
  %call2 = call ptr @g_slist_prepend(ptr noundef %9, ptr noundef %10)
  store ptr %call2, ptr %refresh_list, align 8
  %11 = load ptr, ptr %refresh_list, align 8
  %12 = load ptr, ptr %new_bs.addr, align 8
  %call3 = call ptr @g_slist_prepend(ptr noundef %11, ptr noundef %12)
  store ptr %call3, ptr %refresh_list, align 8
  %13 = load ptr, ptr %refresh_list, align 8
  %14 = load ptr, ptr %tran, align 8
  %15 = load ptr, ptr %errp.addr, align 8
  %call4 = call i32 @bdrv_list_refresh_perms(ptr noundef %13, ptr noundef null, ptr noundef %14, ptr noundef %15)
  store i32 %call4, ptr %ret, align 4
  %16 = load ptr, ptr %tran, align 8
  %17 = load i32, ptr %ret, align 4
  call void @tran_finalize(ptr noundef %16, i32 noundef %17)
  %18 = load ptr, ptr %new_bs.addr, align 8
  call void @bdrv_graph_wrunlock(ptr noundef %18)
  %19 = load ptr, ptr %old_bs, align 8
  call void @bdrv_drained_end(ptr noundef %19)
  %20 = load ptr, ptr %new_bs.addr, align 8
  call void @bdrv_drained_end(ptr noundef %20)
  %21 = load ptr, ptr %old_bs, align 8
  call void @bdrv_unref(ptr noundef %21)
  %22 = load i32, ptr %ret, align 4
  call void @glib_autoptr_cleanup_GSList(ptr noundef %refresh_list)
  ret i32 %22
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_replace_child_tran(ptr noundef %child, ptr noundef %new_bs, ptr noundef %tran) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %new_bs.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %.compoundliteral = alloca %struct.BdrvReplaceChildState, align 8
  store ptr %child, ptr %child.addr, align 8
  store ptr %new_bs, ptr %new_bs.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  %call = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 16) #17
  store ptr %call, ptr %s, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %quiesced_parent = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 8
  %1 = load i8, ptr %quiesced_parent, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.215, ptr noundef @.str.2, i32 noundef 2464, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_tran) #16
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load ptr, ptr %new_bs.addr, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %if.end
  %3 = load ptr, ptr %new_bs.addr, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 46
  %4 = load i32, ptr %quiesce_counter, align 8
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then3, label %if.else4

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  br label %if.end5

if.else4:                                         ; preds = %lor.lhs.false
  call void @__assert_fail(ptr noundef @.str.276, ptr noundef @.str.2, i32 noundef 2465, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_tran) #16
  unreachable

if.end5:                                          ; preds = %if.then3
  %5 = load ptr, ptr %s, align 8
  %child6 = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %.compoundliteral, i32 0, i32 0
  %6 = load ptr, ptr %child.addr, align 8
  store ptr %6, ptr %child6, align 8
  %old_bs = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %.compoundliteral, i32 0, i32 1
  %7 = load ptr, ptr %child.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %bs, align 8
  store ptr %8, ptr %old_bs, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %5, ptr align 8 %.compoundliteral, i64 16, i1 false)
  %9 = load ptr, ptr %tran.addr, align 8
  %10 = load ptr, ptr %s, align 8
  call void @tran_add(ptr noundef %9, ptr noundef @bdrv_replace_child_drv, ptr noundef %10)
  %11 = load ptr, ptr %new_bs.addr, align 8
  %tobool7 = icmp ne ptr %11, null
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end5
  %12 = load ptr, ptr %new_bs.addr, align 8
  call void @bdrv_ref(ptr noundef %12)
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end5
  %13 = load ptr, ptr %child.addr, align 8
  %14 = load ptr, ptr %new_bs.addr, align 8
  call void @bdrv_replace_child_noperm(ptr noundef %13, ptr noundef %14)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_insert_node(ptr noundef %bs, ptr noundef %options, i32 noundef %flags, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %errp.addr = alloca ptr, align 8
  %_auto_errp_prop = alloca %struct.ErrorPropagator, align 8
  %ret = alloca i32, align 4
  %ctx = alloca ptr, align 8
  %new_node_bs = alloca ptr, align 8
  %drvname = alloca ptr, align 8
  %node_name = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %_obj56 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp34 = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %errp, ptr %errp.addr, align 8
  %local_err = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i32 0, i32 0
  store ptr null, ptr %local_err, align 8
  %errp1 = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i32 0, i32 1
  %0 = load ptr, ptr %errp.addr, align 8
  store ptr %0, ptr %errp1, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load ptr, ptr %errp.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %do.body
  %2 = load ptr, ptr %errp.addr, align 8
  %cmp = icmp eq ptr %2, @error_fatal
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %do.body
  %local_err2 = getelementptr inbounds %struct.ErrorPropagator, ptr %_auto_errp_prop, i32 0, i32 0
  store ptr %local_err2, ptr %errp.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  %3 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_get_aio_context(ptr noundef %3)
  store ptr %call, ptr %ctx, align 8
  store ptr null, ptr %new_node_bs, align 8
  %4 = load ptr, ptr %options.addr, align 8
  %call3 = call ptr @qdict_get_try_str(ptr noundef %4, ptr noundef @.str.20)
  store ptr %call3, ptr %drvname, align 8
  %5 = load ptr, ptr %drvname, align 8
  %tobool4 = icmp ne ptr %5, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %do.end
  %6 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %6, ptr noundef @.str.2, i32 noundef 5686, ptr noundef @__func__.bdrv_insert_node, ptr noundef @.str.90)
  br label %fail

if.end6:                                          ; preds = %do.end
  %7 = load ptr, ptr %drvname, align 8
  %call7 = call ptr @bdrv_find_format(ptr noundef %7)
  store ptr %call7, ptr %drv, align 8
  %8 = load ptr, ptr %drv, align 8
  %tobool8 = icmp ne ptr %8, null
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end6
  %9 = load ptr, ptr %errp.addr, align 8
  %10 = load ptr, ptr %drvname, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %9, ptr noundef @.str.2, i32 noundef 5692, ptr noundef @__func__.bdrv_insert_node, ptr noundef @.str.91, ptr noundef %10)
  br label %fail

if.end10:                                         ; preds = %if.end6
  %11 = load ptr, ptr %options.addr, align 8
  %call11 = call ptr @qdict_get_try_str(ptr noundef %11, ptr noundef @.str.44)
  store ptr %call11, ptr %node_name, align 8
  br label %do.body12

do.body12:                                        ; preds = %if.end10
  %call13 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call13, label %if.then14, label %if.else

if.then14:                                        ; preds = %do.body12
  br label %if.end15

if.else:                                          ; preds = %do.body12
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5698, ptr noundef @__PRETTY_FUNCTION__.bdrv_insert_node) #16
  unreachable

if.end15:                                         ; preds = %if.then14
  br label %do.cond16

do.cond16:                                        ; preds = %if.end15
  br label %do.end17

do.end17:                                         ; preds = %do.cond16
  %12 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %12)
  %call18 = call ptr @qemu_get_aio_context()
  call void @aio_context_acquire(ptr noundef %call18)
  %13 = load ptr, ptr %drv, align 8
  %14 = load ptr, ptr %node_name, align 8
  %15 = load ptr, ptr %options.addr, align 8
  %16 = load i32, ptr %flags.addr, align 4
  %17 = load ptr, ptr %errp.addr, align 8
  %call19 = call ptr @bdrv_new_open_driver_opts(ptr noundef %13, ptr noundef %14, ptr noundef %15, i32 noundef %16, ptr noundef %17)
  store ptr %call19, ptr %new_node_bs, align 8
  %call20 = call ptr @qemu_get_aio_context()
  call void @aio_context_release(ptr noundef %call20)
  %18 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %18)
  %19 = load ptr, ptr %bs.addr, align 8
  %call21 = call ptr @bdrv_get_aio_context(ptr noundef %19)
  %20 = load ptr, ptr %ctx, align 8
  %cmp22 = icmp eq ptr %call21, %20
  br i1 %cmp22, label %if.then23, label %if.else24

if.then23:                                        ; preds = %do.end17
  br label %if.end25

if.else24:                                        ; preds = %do.end17
  call void @__assert_fail(ptr noundef @.str.92, ptr noundef @.str.2, i32 noundef 5706, ptr noundef @__PRETTY_FUNCTION__.bdrv_insert_node) #16
  unreachable

if.end25:                                         ; preds = %if.then23
  store ptr null, ptr %options.addr, align 8
  %21 = load ptr, ptr %new_node_bs, align 8
  %tobool26 = icmp ne ptr %21, null
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.end25
  %22 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, ...) @error_prepend(ptr noundef %22, ptr noundef @.str.93)
  br label %fail

if.end28:                                         ; preds = %if.end25
  %23 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_ref(ptr noundef %23)
  %24 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_drained_begin(ptr noundef %24)
  %25 = load ptr, ptr %new_node_bs, align 8
  call void @bdrv_drained_begin(ptr noundef %25)
  %26 = load ptr, ptr %new_node_bs, align 8
  call void @bdrv_graph_wrlock(ptr noundef %26)
  %27 = load ptr, ptr %bs.addr, align 8
  %28 = load ptr, ptr %new_node_bs, align 8
  %29 = load ptr, ptr %errp.addr, align 8
  %call29 = call i32 @bdrv_replace_node(ptr noundef %27, ptr noundef %28, ptr noundef %29)
  store i32 %call29, ptr %ret, align 4
  %30 = load ptr, ptr %new_node_bs, align 8
  call void @bdrv_graph_wrunlock(ptr noundef %30)
  %31 = load ptr, ptr %new_node_bs, align 8
  call void @bdrv_drained_end(ptr noundef %31)
  %32 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_drained_end(ptr noundef %32)
  %33 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_unref(ptr noundef %33)
  %34 = load i32, ptr %ret, align 4
  %cmp30 = icmp slt i32 %34, 0
  br i1 %cmp30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %if.end28
  %35 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, ...) @error_prepend(ptr noundef %35, ptr noundef @.str.94)
  br label %fail

if.end32:                                         ; preds = %if.end28
  %36 = load ptr, ptr %new_node_bs, align 8
  store ptr %36, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

fail:                                             ; preds = %if.then31, %if.then27, %if.then9, %if.then5
  %37 = load ptr, ptr %options.addr, align 8
  store ptr %37, ptr %_obj56, align 8
  %38 = load ptr, ptr %_obj56, align 8
  %tobool33 = icmp ne ptr %38, null
  br i1 %tobool33, label %cond.true, label %cond.false

cond.true:                                        ; preds = %fail
  %39 = load ptr, ptr %_obj56, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %39, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %40 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %40, i64 0
  store ptr %add.ptr, ptr %tmp34, align 8
  %41 = load ptr, ptr %tmp34, align 8
  br label %cond.end

cond.false:                                       ; preds = %fail
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %41, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %42 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %42)
  %43 = load ptr, ptr %new_node_bs, align 8
  call void @bdrv_unref(ptr noundef %43)
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %cond.end, %if.end32
  call void @glib_auto_cleanup_ErrorPropagator(ptr noundef %_auto_errp_prop)
  %44 = load ptr, ptr %retval, align 8
  ret ptr %44
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_check(ptr noundef %bs, ptr noundef %res, i32 noundef %fix) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %res.addr = alloca ptr, align 8
  %fix.addr = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %res, ptr %res.addr, align 8
  store i32 %fix, ptr %fix.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  call void @assert_bdrv_graph_readable()
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  store i32 -123, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv1, align 8
  %bdrv_co_check = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 106
  %4 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_check, ptr @.str.13, ptr @.str.14, i32 773, ptr null)
  %5 = load ptr, ptr %4, align 8
  %cmp2 = icmp eq ptr %5, null
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -95, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %if.end
  %6 = load ptr, ptr %res.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %6, i8 0, i64 64, i1 false)
  %7 = load ptr, ptr %bs.addr, align 8
  %drv5 = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 6
  %8 = load ptr, ptr %drv5, align 8
  %bdrv_co_check6 = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 106
  %9 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_check6, ptr @.str.13, ptr @.str.14, i32 773, ptr null)
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %bs.addr, align 8
  %12 = load ptr, ptr %res.addr, align 8
  %13 = load i32, ptr %fix.addr, align 4
  %call = call i32 %10(ptr noundef %11, ptr noundef %12, i32 noundef %13)
  store i32 %call, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr nocapture writeonly, i8, i64, i1 immarg) #11

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_change_backing_file(ptr noundef %bs, ptr noundef %backing_file, ptr noundef %backing_fmt, i1 noundef zeroext %require) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %backing_file.addr = alloca ptr, align 8
  %backing_fmt.addr = alloca ptr, align 8
  %require.addr = alloca i8, align 1
  %drv = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %backing_file, ptr %backing_file.addr, align 8
  store ptr %backing_fmt, ptr %backing_fmt.addr, align 8
  %frombool = zext i1 %require to i8
  store i8 %frombool, ptr %require.addr, align 1
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  store i32 -123, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end
  %3 = load ptr, ptr %backing_fmt.addr, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %land.lhs.true, label %if.end5

land.lhs.true:                                    ; preds = %if.end
  %4 = load ptr, ptr %backing_file.addr, align 8
  %tobool3 = icmp ne ptr %4, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %land.lhs.true
  store i32 -22, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %land.lhs.true, %if.end
  %5 = load i8, ptr %require.addr, align 1
  %tobool6 = trunc i8 %5 to i1
  br i1 %tobool6, label %land.lhs.true7, label %if.end12

land.lhs.true7:                                   ; preds = %if.end5
  %6 = load ptr, ptr %backing_file.addr, align 8
  %tobool8 = icmp ne ptr %6, null
  br i1 %tobool8, label %land.lhs.true9, label %if.end12

land.lhs.true9:                                   ; preds = %land.lhs.true7
  %7 = load ptr, ptr %backing_fmt.addr, align 8
  %tobool10 = icmp ne ptr %7, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %land.lhs.true9
  store i32 -22, ptr %retval, align 4
  br label %return

if.end12:                                         ; preds = %land.lhs.true9, %land.lhs.true7, %if.end5
  %8 = load ptr, ptr %drv, align 8
  %bdrv_co_change_backing_file = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 40
  %9 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_change_backing_file, ptr @.str.13, ptr @.str.14, i32 334, ptr null)
  %10 = load ptr, ptr %9, align 8
  %cmp = icmp ne ptr %10, null
  br i1 %cmp, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end12
  %11 = load ptr, ptr %drv, align 8
  %bdrv_co_change_backing_file14 = getelementptr inbounds %struct.BlockDriver, ptr %11, i32 0, i32 40
  %12 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_change_backing_file14, ptr @.str.13, ptr @.str.14, i32 334, ptr null)
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %bs.addr, align 8
  %15 = load ptr, ptr %backing_file.addr, align 8
  %16 = load ptr, ptr %backing_fmt.addr, align 8
  %call = call i32 %13(ptr noundef %14, ptr noundef %15, ptr noundef %16)
  store i32 %call, ptr %ret, align 4
  br label %if.end15

if.else:                                          ; preds = %if.end12
  store i32 -95, ptr %ret, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.else, %if.then13
  %17 = load i32, ptr %ret, align 4
  %cmp16 = icmp eq i32 %17, 0
  br i1 %cmp16, label %if.then17, label %if.end32

if.then17:                                        ; preds = %if.end15
  %18 = load ptr, ptr %bs.addr, align 8
  %backing_file18 = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 12
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %backing_file18, i64 0, i64 0
  %19 = load ptr, ptr %backing_file.addr, align 8
  %tobool19 = icmp ne ptr %19, null
  br i1 %tobool19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then17
  br label %cond.end

cond.false:                                       ; preds = %if.then17
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %19, %cond.true ], [ @.str.95, %cond.false ]
  call void @pstrcpy(ptr noundef %arraydecay, i32 noundef 4096, ptr noundef %cond)
  %20 = load ptr, ptr %bs.addr, align 8
  %backing_format = getelementptr inbounds %struct.BlockDriverState, ptr %20, i32 0, i32 14
  %arraydecay20 = getelementptr inbounds [16 x i8], ptr %backing_format, i64 0, i64 0
  %21 = load ptr, ptr %backing_fmt.addr, align 8
  %tobool21 = icmp ne ptr %21, null
  br i1 %tobool21, label %cond.true22, label %cond.false23

cond.true22:                                      ; preds = %cond.end
  br label %cond.end24

cond.false23:                                     ; preds = %cond.end
  br label %cond.end24

cond.end24:                                       ; preds = %cond.false23, %cond.true22
  %cond25 = phi ptr [ %21, %cond.true22 ], [ @.str.95, %cond.false23 ]
  call void @pstrcpy(ptr noundef %arraydecay20, i32 noundef 16, ptr noundef %cond25)
  %22 = load ptr, ptr %bs.addr, align 8
  %auto_backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %22, i32 0, i32 13
  %arraydecay26 = getelementptr inbounds [4096 x i8], ptr %auto_backing_file, i64 0, i64 0
  %23 = load ptr, ptr %backing_file.addr, align 8
  %tobool27 = icmp ne ptr %23, null
  br i1 %tobool27, label %cond.true28, label %cond.false29

cond.true28:                                      ; preds = %cond.end24
  br label %cond.end30

cond.false29:                                     ; preds = %cond.end24
  br label %cond.end30

cond.end30:                                       ; preds = %cond.false29, %cond.true28
  %cond31 = phi ptr [ %23, %cond.true28 ], [ @.str.95, %cond.false29 ]
  call void @pstrcpy(ptr noundef %arraydecay26, i32 noundef 4096, ptr noundef %cond31)
  br label %if.end32

if.end32:                                         ; preds = %cond.end30, %if.end15
  %24 = load i32, ptr %ret, align 4
  store i32 %24, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end32, %if.then11, %if.then4, %if.then
  %25 = load i32, ptr %retval, align 4
  ret i32 %25
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_overlay(ptr noundef %active, ptr noundef %bs) #0 {
entry:
  %retval = alloca ptr, align 8
  %active.addr = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %active, ptr %active.addr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5823, ptr noundef @__PRETTY_FUNCTION__.bdrv_find_overlay) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %call1 = call ptr @bdrv_skip_filters(ptr noundef %0)
  store ptr %call1, ptr %bs.addr, align 8
  %1 = load ptr, ptr %active.addr, align 8
  %call2 = call ptr @bdrv_skip_filters(ptr noundef %1)
  store ptr %call2, ptr %active.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end5, %do.end
  %2 = load ptr, ptr %active.addr, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load ptr, ptr %active.addr, align 8
  %call3 = call ptr @bdrv_backing_chain_next(ptr noundef %3)
  store ptr %call3, ptr %next, align 8
  %4 = load ptr, ptr %bs.addr, align 8
  %5 = load ptr, ptr %next, align 8
  %cmp = icmp eq ptr %4, %5
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %while.body
  %6 = load ptr, ptr %active.addr, align 8
  store ptr %6, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %while.body
  %7 = load ptr, ptr %next, align 8
  store ptr %7, ptr %active.addr, align 8
  br label %while.cond, !llvm.loop !39

while.end:                                        ; preds = %while.cond
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then4
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_skip_filters(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_do_skip_filters(ptr noundef %0, i1 noundef zeroext false)
  ret ptr %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_backing_chain_next(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_skip_filters(ptr noundef %0)
  %call1 = call ptr @bdrv_cow_bs(ptr noundef %call)
  %call2 = call ptr @bdrv_skip_filters(ptr noundef %call1)
  ret ptr %call2
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_base(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5842, ptr noundef @__PRETTY_FUNCTION__.bdrv_find_base) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %call1 = call ptr @bdrv_find_overlay(ptr noundef %0, ptr noundef null)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_freeze_backing_chain(ptr noundef %bs, ptr noundef %base, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %base.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %i = alloca ptr, align 8
  %child = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %base, ptr %base.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5887, ptr noundef @__PRETTY_FUNCTION__.bdrv_freeze_backing_chain) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %1 = load ptr, ptr %base.addr, align 8
  %2 = load ptr, ptr %errp.addr, align 8
  %call1 = call zeroext i1 @bdrv_is_backing_chain_frozen(ptr noundef %0, ptr noundef %1, ptr noundef %2)
  br i1 %call1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %do.end
  %3 = load ptr, ptr %bs.addr, align 8
  store ptr %3, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %4 = load ptr, ptr %i, align 8
  %5 = load ptr, ptr %base.addr, align 8
  %cmp = icmp ne ptr %4, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load ptr, ptr %i, align 8
  %call4 = call ptr @bdrv_filter_or_cow_child(ptr noundef %6)
  store ptr %call4, ptr %child, align 8
  %7 = load ptr, ptr %child, align 8
  %tobool = icmp ne ptr %7, null
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %for.body
  %8 = load ptr, ptr %child, align 8
  %bs5 = getelementptr inbounds %struct.BdrvChild, ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %bs5, align 8
  %never_freeze = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 53
  %10 = load i8, ptr %never_freeze, align 8
  %tobool6 = trunc i8 %10 to i1
  br i1 %tobool6, label %if.then7, label %if.end9

if.then7:                                         ; preds = %land.lhs.true
  %11 = load ptr, ptr %errp.addr, align 8
  %12 = load ptr, ptr %child, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %name, align 8
  %14 = load ptr, ptr %child, align 8
  %bs8 = getelementptr inbounds %struct.BdrvChild, ptr %14, i32 0, i32 0
  %15 = load ptr, ptr %bs8, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %11, ptr noundef @.str.2, i32 noundef 5897, ptr noundef @__func__.bdrv_freeze_backing_chain, ptr noundef @.str.96, ptr noundef %13, ptr noundef %arraydecay)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %16 = load ptr, ptr %child, align 8
  %call10 = call ptr @child_bs(ptr noundef %16)
  store ptr %call10, ptr %i, align 8
  br label %for.cond, !llvm.loop !40

for.end:                                          ; preds = %for.cond
  %17 = load ptr, ptr %bs.addr, align 8
  store ptr %17, ptr %i, align 8
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc18, %for.end
  %18 = load ptr, ptr %i, align 8
  %19 = load ptr, ptr %base.addr, align 8
  %cmp12 = icmp ne ptr %18, %19
  br i1 %cmp12, label %for.body13, label %for.end20

for.body13:                                       ; preds = %for.cond11
  %20 = load ptr, ptr %i, align 8
  %call14 = call ptr @bdrv_filter_or_cow_child(ptr noundef %20)
  store ptr %call14, ptr %child, align 8
  %21 = load ptr, ptr %child, align 8
  %tobool15 = icmp ne ptr %21, null
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %for.body13
  %22 = load ptr, ptr %child, align 8
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %22, i32 0, i32 7
  store i8 1, ptr %frozen, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %for.body13
  br label %for.inc18

for.inc18:                                        ; preds = %if.end17
  %23 = load ptr, ptr %child, align 8
  %call19 = call ptr @child_bs(ptr noundef %23)
  store ptr %call19, ptr %i, align 8
  br label %for.cond11, !llvm.loop !41

for.end20:                                        ; preds = %for.cond11
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end20, %if.then7, %if.then2
  %24 = load i32, ptr %retval, align 4
  ret i32 %24
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_is_backing_chain_frozen(ptr noundef %bs, ptr noundef %base, ptr noundef %errp) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %base.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %i = alloca ptr, align 8
  %child = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %base, ptr %base.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5859, ptr noundef @__PRETTY_FUNCTION__.bdrv_is_backing_chain_frozen) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  store ptr %0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %1 = load ptr, ptr %i, align 8
  %2 = load ptr, ptr %base.addr, align 8
  %cmp = icmp ne ptr %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %i, align 8
  %call1 = call ptr @bdrv_filter_or_cow_child(ptr noundef %3)
  store ptr %call1, ptr %child, align 8
  %4 = load ptr, ptr %child, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %for.body
  %5 = load ptr, ptr %child, align 8
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 7
  %6 = load i8, ptr %frozen, align 8
  %tobool2 = trunc i8 %6 to i1
  br i1 %tobool2, label %if.then3, label %if.end7

if.then3:                                         ; preds = %land.lhs.true
  %7 = load ptr, ptr %errp.addr, align 8
  %8 = load ptr, ptr %child, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %name, align 8
  %10 = load ptr, ptr %i, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  %11 = load ptr, ptr %child, align 8
  %bs4 = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %bs4, align 8
  %node_name5 = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 22
  %arraydecay6 = getelementptr inbounds [32 x i8], ptr %node_name5, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %7, ptr noundef @.str.2, i32 noundef 5866, ptr noundef @__func__.bdrv_is_backing_chain_frozen, ptr noundef @.str.279, ptr noundef %9, ptr noundef %arraydecay, ptr noundef %arraydecay6)
  store i1 true, ptr %retval, align 1
  br label %return

if.end7:                                          ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %13 = load ptr, ptr %child, align 8
  %call8 = call ptr @child_bs(ptr noundef %13)
  store ptr %call8, ptr %i, align 8
  br label %for.cond, !llvm.loop !42

for.end:                                          ; preds = %for.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then3
  %14 = load i1, ptr %retval, align 1
  ret i1 %14
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_filter_or_cow_child(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %cow_child = alloca ptr, align 8
  %filter_child = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_cow_child(ptr noundef %0)
  store ptr %call, ptr %cow_child, align 8
  %1 = load ptr, ptr %bs.addr, align 8
  %call1 = call ptr @bdrv_filter_child(ptr noundef %1)
  store ptr %call1, ptr %filter_child, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %2 = load ptr, ptr %cow_child, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %do.end
  %3 = load ptr, ptr %filter_child, align 8
  %tobool2 = icmp ne ptr %3, null
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true, %do.end
  br label %if.end

if.else:                                          ; preds = %land.lhs.true
  call void @__assert_fail(ptr noundef @.str.154, ptr noundef @.str.2, i32 noundef 8484, ptr noundef @__PRETTY_FUNCTION__.bdrv_filter_or_cow_child) #16
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load ptr, ptr %cow_child, align 8
  %tobool3 = icmp ne ptr %4, null
  br i1 %tobool3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %5 = load ptr, ptr %filter_child, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ %5, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @child_bs(ptr noundef %child) #0 {
entry:
  %child.addr = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load ptr, ptr %child.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %bs, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %2, %cond.true ], [ null, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_unfreeze_backing_chain(ptr noundef %bs, ptr noundef %base) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %base.addr = alloca ptr, align 8
  %i = alloca ptr, align 8
  %child = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %base, ptr %base.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5923, ptr noundef @__PRETTY_FUNCTION__.bdrv_unfreeze_backing_chain) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  store ptr %0, ptr %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %1 = load ptr, ptr %i, align 8
  %2 = load ptr, ptr %base.addr, align 8
  %cmp = icmp ne ptr %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %i, align 8
  %call1 = call ptr @bdrv_filter_or_cow_child(ptr noundef %3)
  store ptr %call1, ptr %child, align 8
  %4 = load ptr, ptr %child, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %if.then2, label %if.end8

if.then2:                                         ; preds = %for.body
  %5 = load ptr, ptr %child, align 8
  %frozen = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 7
  %6 = load i8, ptr %frozen, align 8
  %tobool3 = trunc i8 %6 to i1
  br i1 %tobool3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.then2
  br label %if.end6

if.else5:                                         ; preds = %if.then2
  call void @__assert_fail(ptr noundef @.str.97, ptr noundef @.str.2, i32 noundef 5928, ptr noundef @__PRETTY_FUNCTION__.bdrv_unfreeze_backing_chain) #16
  unreachable

if.end6:                                          ; preds = %if.then4
  %7 = load ptr, ptr %child, align 8
  %frozen7 = getelementptr inbounds %struct.BdrvChild, ptr %7, i32 0, i32 7
  store i8 0, ptr %frozen7, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.end6, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end8
  %8 = load ptr, ptr %child, align 8
  %call9 = call ptr @child_bs(ptr noundef %8)
  store ptr %call9, ptr %i, align 8
  br label %for.cond, !llvm.loop !43

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_drop_intermediate(ptr noundef %top, ptr noundef %base, ptr noundef %backing_file_str) #0 {
entry:
  %top.addr = alloca ptr, align 8
  %base.addr = alloca ptr, align 8
  %backing_file_str.addr = alloca ptr, align 8
  %explicit_top = alloca ptr, align 8
  %update_inherits_from = alloca i8, align 1
  %c = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %ret = alloca i32, align 4
  %updated_children = alloca ptr, align 8
  %p = alloca ptr, align 8
  store ptr %top, ptr %top.addr, align 8
  store ptr %base, ptr %base.addr, align 8
  store ptr %backing_file_str, ptr %backing_file_str.addr, align 8
  %0 = load ptr, ptr %top.addr, align 8
  store ptr %0, ptr %explicit_top, align 8
  store ptr null, ptr %local_err, align 8
  store i32 -5, ptr %ret, align 4
  store ptr null, ptr %updated_children, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5974, ptr noundef @__PRETTY_FUNCTION__.bdrv_drop_intermediate) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  %1 = load ptr, ptr %top.addr, align 8
  call void @bdrv_ref(ptr noundef %1)
  %2 = load ptr, ptr %base.addr, align 8
  call void @bdrv_drained_begin(ptr noundef %2)
  %3 = load ptr, ptr %base.addr, align 8
  call void @bdrv_graph_wrlock(ptr noundef %3)
  %4 = load ptr, ptr %top.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 6
  %5 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %do.end
  %6 = load ptr, ptr %base.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 6
  %7 = load ptr, ptr %drv1, align 8
  %tobool2 = icmp ne ptr %7, null
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %do.end
  br label %exit_wrlock

if.end4:                                          ; preds = %lor.lhs.false
  %8 = load ptr, ptr %top.addr, align 8
  %9 = load ptr, ptr %base.addr, align 8
  %call5 = call zeroext i1 @bdrv_chain_contains(ptr noundef %8, ptr noundef %9)
  br i1 %call5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end4
  br label %exit_wrlock

if.end7:                                          ; preds = %if.end4
  %10 = load ptr, ptr %explicit_top, align 8
  %call8 = call ptr @bdrv_skip_implicit_filters(ptr noundef %10)
  store ptr %call8, ptr %explicit_top, align 8
  %11 = load ptr, ptr %base.addr, align 8
  %12 = load ptr, ptr %explicit_top, align 8
  %call9 = call zeroext i1 @bdrv_inherits_from_recursive(ptr noundef %11, ptr noundef %12)
  %frombool = zext i1 %call9 to i8
  store i8 %frombool, ptr %update_inherits_from, align 1
  %13 = load ptr, ptr %backing_file_str.addr, align 8
  %tobool10 = icmp ne ptr %13, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %if.end7
  %14 = load ptr, ptr %base.addr, align 8
  call void @bdrv_refresh_filename(ptr noundef %14)
  %15 = load ptr, ptr %base.addr, align 8
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 11
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %filename, i64 0, i64 0
  store ptr %arraydecay, ptr %backing_file_str.addr, align 8
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %if.end7
  %16 = load ptr, ptr %top.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %16, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %17 = load ptr, ptr %lh_first, align 8
  store ptr %17, ptr %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end12
  %18 = load ptr, ptr %c, align 8
  %tobool13 = icmp ne ptr %18, null
  br i1 %tobool13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %19 = load ptr, ptr %updated_children, align 8
  %20 = load ptr, ptr %c, align 8
  %call14 = call ptr @g_slist_prepend(ptr noundef %19, ptr noundef %20)
  store ptr %call14, ptr %updated_children, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load ptr, ptr %c, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %21, i32 0, i32 10
  %le_next = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %22 = load ptr, ptr %le_next, align 8
  store ptr %22, ptr %c, align 8
  br label %for.cond, !llvm.loop !44

for.end:                                          ; preds = %for.cond
  %23 = load ptr, ptr %top.addr, align 8
  %24 = load ptr, ptr %base.addr, align 8
  %call15 = call i32 @bdrv_replace_node_common(ptr noundef %23, ptr noundef %24, i1 noundef zeroext false, i1 noundef zeroext false, ptr noundef %local_err)
  %25 = load ptr, ptr %base.addr, align 8
  call void @bdrv_graph_wrunlock(ptr noundef %25)
  %26 = load ptr, ptr %local_err, align 8
  %tobool16 = icmp ne ptr %26, null
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.end
  %27 = load ptr, ptr %local_err, align 8
  call void @error_report_err(ptr noundef %27)
  br label %exit

if.end18:                                         ; preds = %for.end
  %28 = load ptr, ptr %updated_children, align 8
  store ptr %28, ptr %p, align 8
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc30, %if.end18
  %29 = load ptr, ptr %p, align 8
  %tobool20 = icmp ne ptr %29, null
  br i1 %tobool20, label %for.body21, label %for.end31

for.body21:                                       ; preds = %for.cond19
  %30 = load ptr, ptr %p, align 8
  %data = getelementptr inbounds %struct._GSList, ptr %30, i32 0, i32 0
  %31 = load ptr, ptr %data, align 8
  store ptr %31, ptr %c, align 8
  %32 = load ptr, ptr %c, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %32, i32 0, i32 2
  %33 = load ptr, ptr %klass, align 8
  %update_filename = getelementptr inbounds %struct.BdrvChildClass, ptr %33, i32 0, i32 12
  %34 = load ptr, ptr %update_filename, align 8
  %tobool22 = icmp ne ptr %34, null
  br i1 %tobool22, label %if.then23, label %if.end29

if.then23:                                        ; preds = %for.body21
  %35 = load ptr, ptr %c, align 8
  %klass24 = getelementptr inbounds %struct.BdrvChild, ptr %35, i32 0, i32 2
  %36 = load ptr, ptr %klass24, align 8
  %update_filename25 = getelementptr inbounds %struct.BdrvChildClass, ptr %36, i32 0, i32 12
  %37 = load ptr, ptr %update_filename25, align 8
  %38 = load ptr, ptr %c, align 8
  %39 = load ptr, ptr %base.addr, align 8
  %40 = load ptr, ptr %backing_file_str.addr, align 8
  %call26 = call i32 %37(ptr noundef %38, ptr noundef %39, ptr noundef %40, ptr noundef %local_err)
  store i32 %call26, ptr %ret, align 4
  %41 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %41, 0
  br i1 %cmp, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.then23
  %42 = load ptr, ptr %local_err, align 8
  call void @error_report_err(ptr noundef %42)
  br label %exit

if.end28:                                         ; preds = %if.then23
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %for.body21
  br label %for.inc30

for.inc30:                                        ; preds = %if.end29
  %43 = load ptr, ptr %p, align 8
  %next = getelementptr inbounds %struct._GSList, ptr %43, i32 0, i32 1
  %44 = load ptr, ptr %next, align 8
  store ptr %44, ptr %p, align 8
  br label %for.cond19, !llvm.loop !45

for.end31:                                        ; preds = %for.cond19
  %45 = load i8, ptr %update_inherits_from, align 1
  %tobool32 = trunc i8 %45 to i1
  br i1 %tobool32, label %if.then33, label %if.end35

if.then33:                                        ; preds = %for.end31
  %46 = load ptr, ptr %explicit_top, align 8
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %46, i32 0, i32 28
  %47 = load ptr, ptr %inherits_from, align 8
  %48 = load ptr, ptr %base.addr, align 8
  %inherits_from34 = getelementptr inbounds %struct.BlockDriverState, ptr %48, i32 0, i32 28
  store ptr %47, ptr %inherits_from34, align 8
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %for.end31
  store i32 0, ptr %ret, align 4
  br label %exit

exit_wrlock:                                      ; preds = %if.then6, %if.then3
  %49 = load ptr, ptr %base.addr, align 8
  call void @bdrv_graph_wrunlock(ptr noundef %49)
  br label %exit

exit:                                             ; preds = %exit_wrlock, %if.end35, %if.then27, %if.then17
  %50 = load ptr, ptr %base.addr, align 8
  call void @bdrv_drained_end(ptr noundef %50)
  %51 = load ptr, ptr %top.addr, align 8
  call void @bdrv_unref(ptr noundef %51)
  %52 = load i32, ptr %ret, align 4
  call void @glib_autoptr_cleanup_GSList(ptr noundef %updated_children)
  ret i32 %52
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_chain_contains(ptr noundef %top, ptr noundef %base) #0 {
entry:
  %top.addr = alloca ptr, align 8
  %base.addr = alloca ptr, align 8
  store ptr %top, ptr %top.addr, align 8
  store ptr %base, ptr %base.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6537, ptr noundef @__PRETTY_FUNCTION__.bdrv_chain_contains) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %do.end
  %0 = load ptr, ptr %top.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %1 = load ptr, ptr %top.addr, align 8
  %2 = load ptr, ptr %base.addr, align 8
  %cmp = icmp ne ptr %1, %2
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %3 = phi i1 [ false, %while.cond ], [ %cmp, %land.rhs ]
  br i1 %3, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %4 = load ptr, ptr %top.addr, align 8
  %call1 = call ptr @bdrv_filter_or_cow_bs(ptr noundef %4)
  store ptr %call1, ptr %top.addr, align 8
  br label %while.cond, !llvm.loop !46

while.end:                                        ; preds = %land.end
  %5 = load ptr, ptr %top.addr, align 8
  %cmp2 = icmp ne ptr %5, null
  ret i1 %cmp2
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_skip_implicit_filters(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 8555, ptr noundef @__PRETTY_FUNCTION__.bdrv_skip_implicit_filters) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %call1 = call ptr @bdrv_do_skip_filters(ptr noundef %0, i1 noundef zeroext true)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_inherits_from_recursive(ptr noundef %child, ptr noundef %parent) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %parent.addr = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  store ptr %parent, ptr %parent.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load ptr, ptr %child.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %1 = load ptr, ptr %child.addr, align 8
  %2 = load ptr, ptr %parent.addr, align 8
  %cmp = icmp ne ptr %1, %2
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %3 = phi i1 [ false, %while.cond ], [ %cmp, %land.rhs ]
  br i1 %3, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %4 = load ptr, ptr %child.addr, align 8
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 28
  %5 = load ptr, ptr %inherits_from, align 8
  store ptr %5, ptr %child.addr, align 8
  br label %while.cond, !llvm.loop !47

while.end:                                        ; preds = %land.end
  %6 = load ptr, ptr %child.addr, align 8
  %cmp1 = icmp ne ptr %6, null
  ret i1 %cmp1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_co_get_allocated_file_size(ptr noundef %bs) #0 {
entry:
  %retval = alloca i64, align 8
  %bs.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  call void @assert_bdrv_graph_readable()
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  store i64 -123, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %3 = load ptr, ptr %drv, align 8
  %bdrv_co_get_allocated_file_size = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 89
  %4 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_get_allocated_file_size, ptr @.str.13, ptr @.str.14, i32 717, ptr null)
  %5 = load ptr, ptr %4, align 8
  %tobool2 = icmp ne ptr %5, null
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %drv, align 8
  %bdrv_co_get_allocated_file_size4 = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 89
  %7 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_get_allocated_file_size4, ptr @.str.13, ptr @.str.14, i32 717, ptr null)
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %bs.addr, align 8
  %call = call i64 %8(ptr noundef %9)
  store i64 %call, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %10 = load ptr, ptr %drv, align 8
  %bdrv_file_open = getelementptr inbounds %struct.BlockDriver, ptr %10, i32 0, i32 24
  %11 = load ptr, ptr %bdrv_file_open, align 8
  %tobool6 = icmp ne ptr %11, null
  br i1 %tobool6, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end5
  store i64 -95, ptr %retval, align 8
  br label %return

if.else:                                          ; preds = %if.end5
  %12 = load ptr, ptr %drv, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %12, i32 0, i32 2
  %13 = load i8, ptr %is_filter, align 4
  %tobool8 = trunc i8 %13 to i1
  br i1 %tobool8, label %if.then9, label %if.else12

if.then9:                                         ; preds = %if.else
  %14 = load ptr, ptr %bs.addr, align 8
  %call10 = call ptr @bdrv_filter_bs(ptr noundef %14)
  %call11 = call i64 @bdrv_co_get_allocated_file_size(ptr noundef %call10)
  store i64 %call11, ptr %retval, align 8
  br label %return

if.else12:                                        ; preds = %if.else
  %15 = load ptr, ptr %bs.addr, align 8
  %call13 = call i64 @bdrv_sum_allocated_file_size(ptr noundef %15)
  store i64 %call13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.else12, %if.then9, %if.then7, %if.then3, %if.then
  %16 = load i64, ptr %retval, align 8
  ret i64 %16
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @bdrv_sum_allocated_file_size(ptr noundef %bs) #0 {
entry:
  %retval = alloca i64, align 8
  %bs.addr = alloca ptr, align 8
  %child = alloca ptr, align 8
  %child_size = alloca i64, align 8
  %sum = alloca i64, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store i64 0, ptr %sum, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %1 = load ptr, ptr %lh_first, align 8
  store ptr %1, ptr %child, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load ptr, ptr %child, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %child, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %role, align 8
  %and = and i32 %4, 7
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.end4

if.then:                                          ; preds = %for.body
  %5 = load ptr, ptr %child, align 8
  %bs2 = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %bs2, align 8
  %call = call i64 @bdrv_co_get_allocated_file_size(ptr noundef %6)
  store i64 %call, ptr %child_size, align 8
  %7 = load i64, ptr %child_size, align 8
  %cmp = icmp slt i64 %7, 0
  br i1 %cmp, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %8 = load i64, ptr %child_size, align 8
  store i64 %8, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %if.then
  %9 = load i64, ptr %child_size, align 8
  %10 = load i64, ptr %sum, align 8
  %add = add i64 %10, %9
  store i64 %add, ptr %sum, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end4
  %11 = load ptr, ptr %child, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %12 = load ptr, ptr %le_next, align 8
  store ptr %12, ptr %child, align 8
  br label %for.cond, !llvm.loop !48

for.end:                                          ; preds = %for.cond
  %13 = load i64, ptr %sum, align 8
  store i64 %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then3
  %14 = load i64, ptr %retval, align 8
  ret i64 %14
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_measure(ptr noundef %drv, ptr noundef %opts, ptr noundef %in_bs, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %drv.addr = alloca ptr, align 8
  %opts.addr = alloca ptr, align 8
  %in_bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  store ptr %drv, ptr %drv.addr, align 8
  store ptr %opts, ptr %opts.addr, align 8
  store ptr %in_bs, ptr %in_bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %drv.addr, align 8
  %bdrv_measure = getelementptr inbounds %struct.BlockDriver, ptr %0, i32 0, i32 90
  %1 = load ptr, ptr %bdrv_measure, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  %2 = load ptr, ptr %errp.addr, align 8
  %3 = load ptr, ptr %drv.addr, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %format_name, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %2, ptr noundef @.str.2, i32 noundef 6150, ptr noundef @__func__.bdrv_measure, ptr noundef @.str.98, ptr noundef %4)
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %5 = load ptr, ptr %drv.addr, align 8
  %bdrv_measure1 = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 90
  %6 = load ptr, ptr %bdrv_measure1, align 8
  %7 = load ptr, ptr %opts.addr, align 8
  %8 = load ptr, ptr %in_bs.addr, align 8
  %9 = load ptr, ptr %errp.addr, align 8
  %call = call ptr %6(ptr noundef %7, ptr noundef %8, ptr noundef %9)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load ptr, ptr %retval, align 8
  ret ptr %10
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_co_nb_sectors(ptr noundef %bs) #0 {
entry:
  %retval = alloca i64, align 8
  %bs.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  call void @assert_bdrv_graph_readable()
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  store i64 -123, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %3 = load ptr, ptr %bs.addr, align 8
  %bl = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 17
  %has_variable_length = getelementptr inbounds %struct.BlockLimits, ptr %bl, i32 0, i32 12
  %4 = load i8, ptr %has_variable_length, align 4
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %bs.addr, align 8
  %6 = load ptr, ptr %bs.addr, align 8
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 37
  %7 = load i64, ptr %total_sectors, align 8
  %call = call i32 @bdrv_co_refresh_total_sectors(ptr noundef %5, i64 noundef %7)
  store i32 %call, ptr %ret, align 4
  %8 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %8, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then3
  %9 = load i32, ptr %ret, align 4
  %conv = sext i32 %9 to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.then3
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %if.end
  %10 = load ptr, ptr %bs.addr, align 8
  %total_sectors7 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 37
  %11 = load i64, ptr %total_sectors7, align 8
  store i64 %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_nb_sectors(ptr noundef %bs) #0 {
entry:
  %retval = alloca i64, align 8
  %bs.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  store i64 -123, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %3 = load ptr, ptr %bs.addr, align 8
  %bl = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 17
  %has_variable_length = getelementptr inbounds %struct.BlockLimits, ptr %bl, i32 0, i32 12
  %4 = load i8, ptr %has_variable_length, align 4
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %5 = load ptr, ptr %bs.addr, align 8
  %6 = load ptr, ptr %bs.addr, align 8
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 37
  %7 = load i64, ptr %total_sectors, align 8
  %call = call i32 @bdrv_refresh_total_sectors(ptr noundef %5, i64 noundef %7)
  store i32 %call, ptr %ret, align 4
  %8 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %8, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then3
  %9 = load i32, ptr %ret, align 4
  %conv = sext i32 %9 to i64
  store i64 %conv, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.then3
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %if.end
  %10 = load ptr, ptr %bs.addr, align 8
  %total_sectors7 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 37
  %11 = load i64, ptr %total_sectors7, align 8
  store i64 %11, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then
  %12 = load i64, ptr %retval, align 8
  ret i64 %12
}

declare i32 @bdrv_refresh_total_sectors(ptr noundef, i64 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i64 @bdrv_co_getlength(ptr noundef %bs) #0 {
entry:
  %retval = alloca i64, align 8
  %bs.addr = alloca ptr, align 8
  %ret = alloca i64, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  call void @assert_bdrv_graph_readable()
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call i64 @bdrv_co_nb_sectors(ptr noundef %0)
  store i64 %call, ptr %ret, align 8
  %1 = load i64, ptr %ret, align 8
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  %2 = load i64, ptr %ret, align 8
  store i64 %2, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %do.end
  %3 = load i64, ptr %ret, align 8
  %cmp1 = icmp ugt i64 %3, 18014398509481983
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i64 -27, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %if.end
  %4 = load i64, ptr %ret, align 8
  %mul = mul i64 %4, 512
  store i64 %mul, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end3, %if.then2, %if.then
  %5 = load i64, ptr %retval, align 8
  ret i64 %5
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_supports_compressed_writes(ptr noundef %bs) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %filtered = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv1, align 8
  %call = call zeroext i1 @block_driver_can_compress(ptr noundef %3)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %do.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load ptr, ptr %bs.addr, align 8
  %call2 = call ptr @bdrv_filter_bs(ptr noundef %4)
  store ptr %call2, ptr %filtered, align 8
  %5 = load ptr, ptr %filtered, align 8
  %tobool3 = icmp ne ptr %5, null
  br i1 %tobool3, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %6 = load ptr, ptr %filtered, align 8
  %call5 = call zeroext i1 @bdrv_supports_compressed_writes(ptr noundef %6)
  store i1 %call5, ptr %retval, align 1
  br label %return

if.end6:                                          ; preds = %if.end
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end6, %if.then4, %if.then
  %7 = load i1, ptr %retval, align 1
  ret i1 %7
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @block_driver_can_compress(ptr noundef %drv) #0 {
entry:
  %drv.addr = alloca ptr, align 8
  store ptr %drv, ptr %drv.addr, align 8
  %0 = load ptr, ptr %drv.addr, align 8
  %bdrv_co_pwritev_compressed = getelementptr inbounds %struct.BlockDriver, ptr %0, i32 0, i32 91
  %1 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_pwritev_compressed, ptr @.str.13, ptr @.str.14, i32 723, ptr null)
  %2 = load ptr, ptr %1, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %3 = load ptr, ptr %drv.addr, align 8
  %bdrv_co_pwritev_compressed_part = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 92
  %4 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_pwritev_compressed_part, ptr @.str.13, ptr @.str.14, i32 727, ptr null)
  %5 = load ptr, ptr %4, align 8
  %tobool1 = icmp ne ptr %5, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %6 = phi i1 [ true, %entry ], [ %tobool1, %lor.rhs ]
  ret i1 %6
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_format_name(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv1, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %format_name, align 8
  br label %cond.end

cond.false:                                       ; preds = %do.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %4, %cond.true ], [ null, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_iterate_format(ptr noundef %it, ptr noundef %opaque, i1 noundef zeroext %read_only) #0 {
entry:
  %it.addr = alloca ptr, align 8
  %opaque.addr = alloca ptr, align 8
  %read_only.addr = alloca i8, align 1
  %drv = alloca ptr, align 8
  %count = alloca i32, align 4
  %i = alloca i32, align 4
  %formats = alloca ptr, align 8
  %found = alloca i8, align 1
  %format_name29 = alloca ptr, align 8
  %found35 = alloca i8, align 1
  %j = alloca i32, align 4
  store ptr %it, ptr %it.addr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %frombool = zext i1 %read_only to i8
  store i8 %frombool, ptr %read_only.addr, align 1
  store i32 0, ptr %count, align 4
  store ptr null, ptr %formats, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6269, ptr noundef @__PRETTY_FUNCTION__.bdrv_iterate_format) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr @bdrv_drivers, align 8
  store ptr %0, ptr %drv, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %drv, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %format_name, align 8
  %tobool1 = icmp ne ptr %3, null
  br i1 %tobool1, label %if.then2, label %if.end25

if.then2:                                         ; preds = %for.body
  store i8 0, ptr %found, align 1
  %4 = load i32, ptr @use_bdrv_whitelist, align 4
  %tobool3 = icmp ne i32 %4, 0
  br i1 %tobool3, label %land.lhs.true, label %if.end8

land.lhs.true:                                    ; preds = %if.then2
  %5 = load ptr, ptr %drv, align 8
  %6 = load i8, ptr %read_only.addr, align 1
  %tobool4 = trunc i8 %6 to i1
  %call5 = call i32 @bdrv_is_whitelisted(ptr noundef %5, i1 noundef zeroext %tobool4)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %land.lhs.true
  br label %for.inc

if.end8:                                          ; preds = %land.lhs.true, %if.then2
  %7 = load i32, ptr %count, align 4
  store i32 %7, ptr %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end8
  %8 = load ptr, ptr %formats, align 8
  %tobool9 = icmp ne ptr %8, null
  br i1 %tobool9, label %land.lhs.true10, label %land.end

land.lhs.true10:                                  ; preds = %while.cond
  %9 = load i32, ptr %i, align 4
  %tobool11 = icmp ne i32 %9, 0
  br i1 %tobool11, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true10
  %10 = load i8, ptr %found, align 1
  %tobool12 = trunc i8 %10 to i1
  %lnot = xor i1 %tobool12, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true10, %while.cond
  %11 = phi i1 [ false, %land.lhs.true10 ], [ false, %while.cond ], [ %lnot, %land.rhs ]
  br i1 %11, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %12 = load ptr, ptr %formats, align 8
  %13 = load i32, ptr %i, align 4
  %dec = add i32 %13, -1
  store i32 %dec, ptr %i, align 4
  %idxprom = sext i32 %dec to i64
  %arrayidx = getelementptr ptr, ptr %12, i64 %idxprom
  %14 = load ptr, ptr %arrayidx, align 8
  %15 = load ptr, ptr %drv, align 8
  %format_name13 = getelementptr inbounds %struct.BlockDriver, ptr %15, i32 0, i32 0
  %16 = load ptr, ptr %format_name13, align 8
  %call14 = call i32 @strcmp(ptr noundef %14, ptr noundef %16) #13
  %tobool15 = icmp ne i32 %call14, 0
  %lnot16 = xor i1 %tobool15, true
  %frombool17 = zext i1 %lnot16 to i8
  store i8 %frombool17, ptr %found, align 1
  br label %while.cond, !llvm.loop !49

while.end:                                        ; preds = %land.end
  %17 = load i8, ptr %found, align 1
  %tobool18 = trunc i8 %17 to i1
  br i1 %tobool18, label %if.end24, label %if.then19

if.then19:                                        ; preds = %while.end
  %18 = load ptr, ptr %formats, align 8
  %19 = load i32, ptr %count, align 4
  %add = add i32 %19, 1
  %conv = sext i32 %add to i64
  %call20 = call ptr @g_realloc_n(ptr noundef %18, i64 noundef %conv, i64 noundef 8)
  store ptr %call20, ptr %formats, align 8
  %20 = load ptr, ptr %drv, align 8
  %format_name21 = getelementptr inbounds %struct.BlockDriver, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %format_name21, align 8
  %22 = load ptr, ptr %formats, align 8
  %23 = load i32, ptr %count, align 4
  %inc = add i32 %23, 1
  store i32 %inc, ptr %count, align 4
  %idxprom22 = sext i32 %23 to i64
  %arrayidx23 = getelementptr ptr, ptr %22, i64 %idxprom22
  store ptr %21, ptr %arrayidx23, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.then19, %while.end
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end25, %if.then7
  %24 = load ptr, ptr %drv, align 8
  %list = getelementptr inbounds %struct.BlockDriver, ptr %24, i32 0, i32 61
  %le_next = getelementptr inbounds %struct.anon.9, ptr %list, i32 0, i32 0
  %25 = load ptr, ptr %le_next, align 8
  store ptr %25, ptr %drv, align 8
  br label %for.cond, !llvm.loop !50

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %i, align 4
  br label %for.cond26

for.cond26:                                       ; preds = %for.inc70, %for.end
  %26 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %26, 0
  br i1 %cmp, label %for.body28, label %for.end72

for.body28:                                       ; preds = %for.cond26
  %27 = load i32, ptr %i, align 4
  %idxprom30 = sext i32 %27 to i64
  %arrayidx31 = getelementptr [0 x %struct.anon.12], ptr @block_driver_modules, i64 0, i64 %idxprom30
  %format_name32 = getelementptr inbounds %struct.anon.12, ptr %arrayidx31, i32 0, i32 0
  %28 = load ptr, ptr %format_name32, align 8
  store ptr %28, ptr %format_name29, align 8
  %29 = load ptr, ptr %format_name29, align 8
  %tobool33 = icmp ne ptr %29, null
  br i1 %tobool33, label %if.then34, label %if.end69

if.then34:                                        ; preds = %for.body28
  store i8 0, ptr %found35, align 1
  %30 = load i32, ptr %count, align 4
  store i32 %30, ptr %j, align 4
  %31 = load i32, ptr @use_bdrv_whitelist, align 4
  %tobool36 = icmp ne i32 %31, 0
  br i1 %tobool36, label %land.lhs.true37, label %if.end42

land.lhs.true37:                                  ; preds = %if.then34
  %32 = load ptr, ptr %format_name29, align 8
  %33 = load i8, ptr %read_only.addr, align 1
  %tobool38 = trunc i8 %33 to i1
  %call39 = call i32 @bdrv_format_is_whitelisted(ptr noundef %32, i1 noundef zeroext %tobool38)
  %tobool40 = icmp ne i32 %call39, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %land.lhs.true37
  br label %for.inc70

if.end42:                                         ; preds = %land.lhs.true37, %if.then34
  br label %while.cond43

while.cond43:                                     ; preds = %while.body51, %if.end42
  %34 = load ptr, ptr %formats, align 8
  %tobool44 = icmp ne ptr %34, null
  br i1 %tobool44, label %land.lhs.true45, label %land.end50

land.lhs.true45:                                  ; preds = %while.cond43
  %35 = load i32, ptr %j, align 4
  %tobool46 = icmp ne i32 %35, 0
  br i1 %tobool46, label %land.rhs47, label %land.end50

land.rhs47:                                       ; preds = %land.lhs.true45
  %36 = load i8, ptr %found35, align 1
  %tobool48 = trunc i8 %36 to i1
  %lnot49 = xor i1 %tobool48, true
  br label %land.end50

land.end50:                                       ; preds = %land.rhs47, %land.lhs.true45, %while.cond43
  %37 = phi i1 [ false, %land.lhs.true45 ], [ false, %while.cond43 ], [ %lnot49, %land.rhs47 ]
  br i1 %37, label %while.body51, label %while.end59

while.body51:                                     ; preds = %land.end50
  %38 = load ptr, ptr %formats, align 8
  %39 = load i32, ptr %j, align 4
  %dec52 = add i32 %39, -1
  store i32 %dec52, ptr %j, align 4
  %idxprom53 = sext i32 %dec52 to i64
  %arrayidx54 = getelementptr ptr, ptr %38, i64 %idxprom53
  %40 = load ptr, ptr %arrayidx54, align 8
  %41 = load ptr, ptr %format_name29, align 8
  %call55 = call i32 @strcmp(ptr noundef %40, ptr noundef %41) #13
  %tobool56 = icmp ne i32 %call55, 0
  %lnot57 = xor i1 %tobool56, true
  %frombool58 = zext i1 %lnot57 to i8
  store i8 %frombool58, ptr %found35, align 1
  br label %while.cond43, !llvm.loop !51

while.end59:                                      ; preds = %land.end50
  %42 = load i8, ptr %found35, align 1
  %tobool60 = trunc i8 %42 to i1
  br i1 %tobool60, label %if.end68, label %if.then61

if.then61:                                        ; preds = %while.end59
  %43 = load ptr, ptr %formats, align 8
  %44 = load i32, ptr %count, align 4
  %add62 = add i32 %44, 1
  %conv63 = sext i32 %add62 to i64
  %call64 = call ptr @g_realloc_n(ptr noundef %43, i64 noundef %conv63, i64 noundef 8)
  store ptr %call64, ptr %formats, align 8
  %45 = load ptr, ptr %format_name29, align 8
  %46 = load ptr, ptr %formats, align 8
  %47 = load i32, ptr %count, align 4
  %inc65 = add i32 %47, 1
  store i32 %inc65, ptr %count, align 4
  %idxprom66 = sext i32 %47 to i64
  %arrayidx67 = getelementptr ptr, ptr %46, i64 %idxprom66
  store ptr %45, ptr %arrayidx67, align 8
  br label %if.end68

if.end68:                                         ; preds = %if.then61, %while.end59
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %for.body28
  br label %for.inc70

for.inc70:                                        ; preds = %if.end69, %if.then41
  %48 = load i32, ptr %i, align 4
  %inc71 = add i32 %48, 1
  store i32 %inc71, ptr %i, align 4
  br label %for.cond26, !llvm.loop !52

for.end72:                                        ; preds = %for.cond26
  %49 = load ptr, ptr %formats, align 8
  %50 = load i32, ptr %count, align 4
  %conv73 = sext i32 %50 to i64
  call void @qsort(ptr noundef %49, i64 noundef %conv73, i64 noundef 8, ptr noundef @qsort_strcmp)
  store i32 0, ptr %i, align 4
  br label %for.cond74

for.cond74:                                       ; preds = %for.inc80, %for.end72
  %51 = load i32, ptr %i, align 4
  %52 = load i32, ptr %count, align 4
  %cmp75 = icmp slt i32 %51, %52
  br i1 %cmp75, label %for.body77, label %for.end82

for.body77:                                       ; preds = %for.cond74
  %53 = load ptr, ptr %it.addr, align 8
  %54 = load ptr, ptr %opaque.addr, align 8
  %55 = load ptr, ptr %formats, align 8
  %56 = load i32, ptr %i, align 4
  %idxprom78 = sext i32 %56 to i64
  %arrayidx79 = getelementptr ptr, ptr %55, i64 %idxprom78
  %57 = load ptr, ptr %arrayidx79, align 8
  call void %53(ptr noundef %54, ptr noundef %57)
  br label %for.inc80

for.inc80:                                        ; preds = %for.body77
  %58 = load i32, ptr %i, align 4
  %inc81 = add i32 %58, 1
  store i32 %inc81, ptr %i, align 4
  br label %for.cond74, !llvm.loop !53

for.end82:                                        ; preds = %for.cond74
  %59 = load ptr, ptr %formats, align 8
  call void @g_free(ptr noundef %59)
  ret void
}

declare ptr @g_realloc_n(ptr noundef, i64 noundef, i64 noundef) #2

declare void @qsort(ptr noundef, i64 noundef, i64 noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @qsort_strcmp(ptr noundef %a, ptr noundef %b) #0 {
entry:
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %1 = load ptr, ptr %0, align 8
  %2 = load ptr, ptr %b.addr, align 8
  %3 = load ptr, ptr %2, align 8
  %call = call i32 @strcmp(ptr noundef %1, ptr noundef %3) #13
  ret i32 %call
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_node(ptr noundef %node_name) #0 {
entry:
  %retval = alloca ptr, align 8
  %node_name.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %node_name, ptr %node_name.addr, align 8
  %0 = load ptr, ptr %node_name.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.99, ptr noundef @.str.2, i32 noundef 6328, ptr noundef @__PRETTY_FUNCTION__.bdrv_find_node) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.body
  br label %if.end3

if.else2:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6329, ptr noundef @__PRETTY_FUNCTION__.bdrv_find_node) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  br label %do.end

do.end:                                           ; preds = %if.end3
  %1 = load ptr, ptr @graph_bdrv_states, align 8
  store ptr %1, ptr %bs, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %2 = load ptr, ptr %bs, align 8
  %tobool4 = icmp ne ptr %2, null
  br i1 %tobool4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %node_name.addr, align 8
  %4 = load ptr, ptr %bs, align 8
  %node_name5 = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name5, i64 0, i64 0
  %call6 = call i32 @strcmp(ptr noundef %3, ptr noundef %arraydecay) #13
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end9, label %if.then8

if.then8:                                         ; preds = %for.body
  %5 = load ptr, ptr %bs, align 8
  store ptr %5, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %6 = load ptr, ptr %bs, align 8
  %node_list = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 23
  %7 = load ptr, ptr %node_list, align 8
  store ptr %7, ptr %bs, align 8
  br label %for.cond, !llvm.loop !54

for.end:                                          ; preds = %for.cond
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then8
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_named_nodes_list(i1 noundef zeroext %flat, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %flat.addr = alloca i8, align 1
  %errp.addr = alloca ptr, align 8
  %list = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %graph_lockable_auto57 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %info = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %_tmp = alloca ptr, align 8
  %frombool = zext i1 %flat to i8
  store i8 %frombool, ptr %flat.addr, align 1
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6346, ptr noundef @__PRETTY_FUNCTION__.bdrv_named_nodes_list) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call1, ptr %graph_lockable_auto57, align 8
  store ptr null, ptr %list, align 8
  %0 = load ptr, ptr @graph_bdrv_states, align 8
  store ptr %0, ptr %bs, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %1 = load ptr, ptr %bs, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load ptr, ptr %bs, align 8
  %3 = load i8, ptr %flat.addr, align 1
  %tobool2 = trunc i8 %3 to i1
  %4 = load ptr, ptr %errp.addr, align 8
  %call3 = call ptr @bdrv_block_device_info(ptr noundef null, ptr noundef %2, i1 noundef zeroext %tobool2, ptr noundef %4)
  store ptr %call3, ptr %info, align 8
  %5 = load ptr, ptr %info, align 8
  %tobool4 = icmp ne ptr %5, null
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %for.body
  %6 = load ptr, ptr %list, align 8
  call void @qapi_free_BlockDeviceInfoList(ptr noundef %6)
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end6:                                          ; preds = %for.body
  br label %do.body7

do.body7:                                         ; preds = %if.end6
  %call8 = call noalias ptr @g_malloc(i64 noundef 16) #14
  store ptr %call8, ptr %_tmp, align 8
  %7 = load ptr, ptr %info, align 8
  %8 = load ptr, ptr %_tmp, align 8
  %value = getelementptr inbounds %struct.BlockDeviceInfoList, ptr %8, i32 0, i32 1
  store ptr %7, ptr %value, align 8
  %9 = load ptr, ptr %list, align 8
  %10 = load ptr, ptr %_tmp, align 8
  %next = getelementptr inbounds %struct.BlockDeviceInfoList, ptr %10, i32 0, i32 0
  store ptr %9, ptr %next, align 8
  %11 = load ptr, ptr %_tmp, align 8
  store ptr %11, ptr %list, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body7
  br label %do.end9

do.end9:                                          ; preds = %do.cond
  br label %for.inc

for.inc:                                          ; preds = %do.end9
  %12 = load ptr, ptr %bs, align 8
  %node_list = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 23
  %13 = load ptr, ptr %node_list, align 8
  store ptr %13, ptr %bs, align 8
  br label %for.cond, !llvm.loop !55

for.end:                                          ; preds = %for.cond
  %14 = load ptr, ptr %list, align 8
  store ptr %14, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then5
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto57)
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

declare ptr @bdrv_block_device_info(ptr noundef, ptr noundef, i1 noundef zeroext, ptr noundef) #2

declare void @qapi_free_BlockDeviceInfoList(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_xdbg_block_graph(ptr noundef %errp) #0 {
entry:
  %errp.addr = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %job = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %child = alloca ptr, align 8
  %gr = alloca ptr, align 8
  %allocated_name = alloca ptr, align 8
  %name = alloca ptr, align 8
  %qemu_lockable_auto58 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.QemuLockable, align 8
  %el = alloca ptr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %call = call ptr @xdbg_graph_new()
  store ptr %call, ptr %gr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6455, ptr noundef @__PRETTY_FUNCTION__.bdrv_get_xdbg_block_graph) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call2 = call ptr @blk_all_next(ptr noundef null)
  store ptr %call2, ptr %blk, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %0 = load ptr, ptr %blk, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store ptr null, ptr %allocated_name, align 8
  %1 = load ptr, ptr %blk, align 8
  %call3 = call ptr @blk_name(ptr noundef %1)
  store ptr %call3, ptr %name, align 8
  %2 = load ptr, ptr %name, align 8
  %3 = load i8, ptr %2, align 1
  %tobool4 = icmp ne i8 %3, 0
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %for.body
  %4 = load ptr, ptr %blk, align 8
  %call6 = call ptr @blk_get_attached_dev_id(ptr noundef %4)
  store ptr %call6, ptr %allocated_name, align 8
  store ptr %call6, ptr %name, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %for.body
  %5 = load ptr, ptr %gr, align 8
  %6 = load ptr, ptr %blk, align 8
  %7 = load ptr, ptr %name, align 8
  call void @xdbg_graph_add_node(ptr noundef %5, ptr noundef %6, i32 noundef 0, ptr noundef %7)
  %8 = load ptr, ptr %allocated_name, align 8
  call void @g_free(ptr noundef %8)
  %9 = load ptr, ptr %blk, align 8
  %call8 = call ptr @blk_root(ptr noundef %9)
  %tobool9 = icmp ne ptr %call8, null
  br i1 %tobool9, label %if.then10, label %if.end12

if.then10:                                        ; preds = %if.end7
  %10 = load ptr, ptr %gr, align 8
  %11 = load ptr, ptr %blk, align 8
  %12 = load ptr, ptr %blk, align 8
  %call11 = call ptr @blk_root(ptr noundef %12)
  call void @xdbg_graph_add_edge(ptr noundef %10, ptr noundef %11, ptr noundef %call11)
  br label %if.end12

if.end12:                                         ; preds = %if.then10, %if.end7
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %13 = load ptr, ptr %blk, align 8
  %call13 = call ptr @blk_all_next(ptr noundef %13)
  store ptr %call13, ptr %blk, align 8
  br label %for.cond, !llvm.loop !56

for.end:                                          ; preds = %for.cond
  %object = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 0
  store ptr @job_mutex, ptr %object, align 8
  %lock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 1
  store ptr @qemu_mutex_lock, ptr %lock, align 8
  %unlock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral, i32 0, i32 2
  store ptr @qemu_mutex_unlock, ptr %unlock, align 8
  %call14 = call ptr @qemu_lockable_auto_lock(ptr noundef %.compoundliteral)
  store ptr %call14, ptr %qemu_lockable_auto58, align 8
  br label %for.cond15

for.cond15:                                       ; preds = %for.inc31, %for.end
  %14 = load ptr, ptr %qemu_lockable_auto58, align 8
  %tobool16 = icmp ne ptr %14, null
  br i1 %tobool16, label %for.body17, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond15
  call void @glib_autoptr_cleanup_QemuLockable(ptr noundef %qemu_lockable_auto58)
  br label %for.end32

for.body17:                                       ; preds = %for.cond15
  %call18 = call ptr @block_job_next_locked(ptr noundef null)
  store ptr %call18, ptr %job, align 8
  br label %for.cond19

for.cond19:                                       ; preds = %for.inc28, %for.body17
  %15 = load ptr, ptr %job, align 8
  %tobool20 = icmp ne ptr %15, null
  br i1 %tobool20, label %for.body21, label %for.end30

for.body21:                                       ; preds = %for.cond19
  %16 = load ptr, ptr %gr, align 8
  %17 = load ptr, ptr %job, align 8
  %18 = load ptr, ptr %job, align 8
  %job22 = getelementptr inbounds %struct.BlockJob, ptr %18, i32 0, i32 0
  %id = getelementptr inbounds %struct.Job, ptr %job22, i32 0, i32 0
  %19 = load ptr, ptr %id, align 8
  call void @xdbg_graph_add_node(ptr noundef %16, ptr noundef %17, i32 noundef 1, ptr noundef %19)
  %20 = load ptr, ptr %job, align 8
  %nodes = getelementptr inbounds %struct.BlockJob, ptr %20, i32 0, i32 10
  %21 = load ptr, ptr %nodes, align 8
  store ptr %21, ptr %el, align 8
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc26, %for.body21
  %22 = load ptr, ptr %el, align 8
  %tobool24 = icmp ne ptr %22, null
  br i1 %tobool24, label %for.body25, label %for.end27

for.body25:                                       ; preds = %for.cond23
  %23 = load ptr, ptr %gr, align 8
  %24 = load ptr, ptr %job, align 8
  %25 = load ptr, ptr %el, align 8
  %data = getelementptr inbounds %struct._GSList, ptr %25, i32 0, i32 0
  %26 = load ptr, ptr %data, align 8
  call void @xdbg_graph_add_edge(ptr noundef %23, ptr noundef %24, ptr noundef %26)
  br label %for.inc26

for.inc26:                                        ; preds = %for.body25
  %27 = load ptr, ptr %el, align 8
  %next = getelementptr inbounds %struct._GSList, ptr %27, i32 0, i32 1
  %28 = load ptr, ptr %next, align 8
  store ptr %28, ptr %el, align 8
  br label %for.cond23, !llvm.loop !57

for.end27:                                        ; preds = %for.cond23
  br label %for.inc28

for.inc28:                                        ; preds = %for.end27
  %29 = load ptr, ptr %job, align 8
  %call29 = call ptr @block_job_next_locked(ptr noundef %29)
  store ptr %call29, ptr %job, align 8
  br label %for.cond19, !llvm.loop !58

for.end30:                                        ; preds = %for.cond19
  br label %for.inc31

for.inc31:                                        ; preds = %for.end30
  %30 = load ptr, ptr %qemu_lockable_auto58, align 8
  call void @qemu_lockable_auto_unlock(ptr noundef %30)
  store ptr null, ptr %qemu_lockable_auto58, align 8
  br label %for.cond15, !llvm.loop !59

for.end32:                                        ; preds = %for.cond.cleanup
  %31 = load ptr, ptr @graph_bdrv_states, align 8
  store ptr %31, ptr %bs, align 8
  br label %for.cond33

for.cond33:                                       ; preds = %for.inc42, %for.end32
  %32 = load ptr, ptr %bs, align 8
  %tobool34 = icmp ne ptr %32, null
  br i1 %tobool34, label %for.body35, label %for.end43

for.body35:                                       ; preds = %for.cond33
  %33 = load ptr, ptr %gr, align 8
  %34 = load ptr, ptr %bs, align 8
  %35 = load ptr, ptr %bs, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %35, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  call void @xdbg_graph_add_node(ptr noundef %33, ptr noundef %34, i32 noundef 2, ptr noundef %arraydecay)
  %36 = load ptr, ptr %bs, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %36, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %37 = load ptr, ptr %lh_first, align 8
  store ptr %37, ptr %child, align 8
  br label %for.cond36

for.cond36:                                       ; preds = %for.inc39, %for.body35
  %38 = load ptr, ptr %child, align 8
  %tobool37 = icmp ne ptr %38, null
  br i1 %tobool37, label %for.body38, label %for.end41

for.body38:                                       ; preds = %for.cond36
  %39 = load ptr, ptr %gr, align 8
  %40 = load ptr, ptr %bs, align 8
  %41 = load ptr, ptr %child, align 8
  call void @xdbg_graph_add_edge(ptr noundef %39, ptr noundef %40, ptr noundef %41)
  br label %for.inc39

for.inc39:                                        ; preds = %for.body38
  %42 = load ptr, ptr %child, align 8
  %next40 = getelementptr inbounds %struct.BdrvChild, ptr %42, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next40, i32 0, i32 0
  %43 = load ptr, ptr %le_next, align 8
  store ptr %43, ptr %child, align 8
  br label %for.cond36, !llvm.loop !60

for.end41:                                        ; preds = %for.cond36
  br label %for.inc42

for.inc42:                                        ; preds = %for.end41
  %44 = load ptr, ptr %bs, align 8
  %node_list = getelementptr inbounds %struct.BlockDriverState, ptr %44, i32 0, i32 23
  %45 = load ptr, ptr %node_list, align 8
  store ptr %45, ptr %bs, align 8
  br label %for.cond33, !llvm.loop !61

for.end43:                                        ; preds = %for.cond33
  %46 = load ptr, ptr %gr, align 8
  %call44 = call ptr @xdbg_graph_finalize(ptr noundef %46)
  ret ptr %call44
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @xdbg_graph_new() #0 {
entry:
  %gr = alloca ptr, align 8
  %call = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 16) #17
  store ptr %call, ptr %gr, align 8
  %call1 = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 16) #17
  %0 = load ptr, ptr %gr, align 8
  %graph = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %0, i32 0, i32 0
  store ptr %call1, ptr %graph, align 8
  %call2 = call ptr @g_hash_table_new(ptr noundef null, ptr noundef null)
  %1 = load ptr, ptr %gr, align 8
  %graph_nodes = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %1, i32 0, i32 1
  store ptr %call2, ptr %graph_nodes, align 8
  %2 = load ptr, ptr %gr, align 8
  ret ptr %2
}

declare ptr @blk_all_next(ptr noundef) #2

declare ptr @blk_name(ptr noundef) #2

declare ptr @blk_get_attached_dev_id(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @xdbg_graph_add_node(ptr noundef %gr, ptr noundef %node, i32 noundef %type, ptr noundef %name) #0 {
entry:
  %gr.addr = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  %type.addr = alloca i32, align 4
  %name.addr = alloca ptr, align 8
  %n = alloca ptr, align 8
  %_tmp = alloca ptr, align 8
  store ptr %gr, ptr %gr.addr, align 8
  store ptr %node, ptr %node.addr, align 8
  store i32 %type, ptr %type.addr, align 4
  store ptr %name, ptr %name.addr, align 8
  %call = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 24) #17
  store ptr %call, ptr %n, align 8
  %0 = load ptr, ptr %gr.addr, align 8
  %1 = load ptr, ptr %node.addr, align 8
  %call1 = call i64 @xdbg_graph_node_num(ptr noundef %0, ptr noundef %1)
  %2 = load ptr, ptr %n, align 8
  %id = getelementptr inbounds %struct.XDbgBlockGraphNode, ptr %2, i32 0, i32 0
  store i64 %call1, ptr %id, align 8
  %3 = load i32, ptr %type.addr, align 4
  %4 = load ptr, ptr %n, align 8
  %type2 = getelementptr inbounds %struct.XDbgBlockGraphNode, ptr %4, i32 0, i32 1
  store i32 %3, ptr %type2, align 8
  %5 = load ptr, ptr %name.addr, align 8
  %call3 = call noalias ptr @g_strdup(ptr noundef %5)
  %6 = load ptr, ptr %n, align 8
  %name4 = getelementptr inbounds %struct.XDbgBlockGraphNode, ptr %6, i32 0, i32 2
  store ptr %call3, ptr %name4, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call5 = call noalias ptr @g_malloc(i64 noundef 16) #14
  store ptr %call5, ptr %_tmp, align 8
  %7 = load ptr, ptr %n, align 8
  %8 = load ptr, ptr %_tmp, align 8
  %value = getelementptr inbounds %struct.XDbgBlockGraphNodeList, ptr %8, i32 0, i32 1
  store ptr %7, ptr %value, align 8
  %9 = load ptr, ptr %gr.addr, align 8
  %graph = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %graph, align 8
  %nodes = getelementptr inbounds %struct.XDbgBlockGraph, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %nodes, align 8
  %12 = load ptr, ptr %_tmp, align 8
  %next = getelementptr inbounds %struct.XDbgBlockGraphNodeList, ptr %12, i32 0, i32 0
  store ptr %11, ptr %next, align 8
  %13 = load ptr, ptr %_tmp, align 8
  %14 = load ptr, ptr %gr.addr, align 8
  %graph6 = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %14, i32 0, i32 0
  %15 = load ptr, ptr %graph6, align 8
  %nodes7 = getelementptr inbounds %struct.XDbgBlockGraph, ptr %15, i32 0, i32 0
  store ptr %13, ptr %nodes7, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  ret void
}

declare ptr @blk_root(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @xdbg_graph_add_edge(ptr noundef %gr, ptr noundef %parent, ptr noundef %child) #0 {
entry:
  %gr.addr = alloca ptr, align 8
  %parent.addr = alloca ptr, align 8
  %child.addr = alloca ptr, align 8
  %qapi_perm = alloca i32, align 4
  %edge = alloca ptr, align 8
  %flag = alloca i64, align 8
  %_tmp = alloca ptr, align 8
  %_tmp20 = alloca ptr, align 8
  %_tmp29 = alloca ptr, align 8
  store ptr %gr, ptr %gr.addr, align 8
  store ptr %parent, ptr %parent.addr, align 8
  store ptr %child, ptr %child.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6424, ptr noundef @__PRETTY_FUNCTION__.xdbg_graph_add_edge) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 40) #17
  store ptr %call1, ptr %edge, align 8
  %0 = load ptr, ptr %gr.addr, align 8
  %1 = load ptr, ptr %parent.addr, align 8
  %call2 = call i64 @xdbg_graph_node_num(ptr noundef %0, ptr noundef %1)
  %2 = load ptr, ptr %edge, align 8
  %parent3 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %2, i32 0, i32 0
  store i64 %call2, ptr %parent3, align 8
  %3 = load ptr, ptr %gr.addr, align 8
  %4 = load ptr, ptr %child.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %bs, align 8
  %call4 = call i64 @xdbg_graph_node_num(ptr noundef %3, ptr noundef %5)
  %6 = load ptr, ptr %edge, align 8
  %child5 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %6, i32 0, i32 1
  store i64 %call4, ptr %child5, align 8
  %7 = load ptr, ptr %child.addr, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %7, i32 0, i32 1
  %8 = load ptr, ptr %name, align 8
  %call6 = call noalias ptr @g_strdup(ptr noundef %8)
  %9 = load ptr, ptr %edge, align 8
  %name7 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %9, i32 0, i32 2
  store ptr %call6, ptr %name7, align 8
  store i32 0, ptr %qapi_perm, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %10 = load i32, ptr %qapi_perm, align 4
  %cmp = icmp ult i32 %10, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load i32, ptr %qapi_perm, align 4
  %call8 = call i64 @bdrv_qapi_perm_to_blk_perm(i32 noundef %11)
  store i64 %call8, ptr %flag, align 8
  %12 = load i64, ptr %flag, align 8
  %13 = load ptr, ptr %child.addr, align 8
  %perm = getelementptr inbounds %struct.BdrvChild, ptr %13, i32 0, i32 5
  %14 = load i64, ptr %perm, align 8
  %and = and i64 %12, %14
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then9, label %if.end15

if.then9:                                         ; preds = %for.body
  br label %do.body10

do.body10:                                        ; preds = %if.then9
  %call11 = call noalias ptr @g_malloc(i64 noundef 16) #14
  store ptr %call11, ptr %_tmp, align 8
  %15 = load i32, ptr %qapi_perm, align 4
  %16 = load ptr, ptr %_tmp, align 8
  %value = getelementptr inbounds %struct.BlockPermissionList, ptr %16, i32 0, i32 1
  store i32 %15, ptr %value, align 8
  %17 = load ptr, ptr %edge, align 8
  %perm12 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %17, i32 0, i32 3
  %18 = load ptr, ptr %perm12, align 8
  %19 = load ptr, ptr %_tmp, align 8
  %next = getelementptr inbounds %struct.BlockPermissionList, ptr %19, i32 0, i32 0
  store ptr %18, ptr %next, align 8
  %20 = load ptr, ptr %_tmp, align 8
  %21 = load ptr, ptr %edge, align 8
  %perm13 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %21, i32 0, i32 3
  store ptr %20, ptr %perm13, align 8
  br label %do.end14

do.end14:                                         ; preds = %do.body10
  br label %if.end15

if.end15:                                         ; preds = %do.end14, %for.body
  %22 = load i64, ptr %flag, align 8
  %23 = load ptr, ptr %child.addr, align 8
  %shared_perm = getelementptr inbounds %struct.BdrvChild, ptr %23, i32 0, i32 6
  %24 = load i64, ptr %shared_perm, align 8
  %and16 = and i64 %22, %24
  %tobool17 = icmp ne i64 %and16, 0
  br i1 %tobool17, label %if.then18, label %if.end27

if.then18:                                        ; preds = %if.end15
  br label %do.body19

do.body19:                                        ; preds = %if.then18
  %call21 = call noalias ptr @g_malloc(i64 noundef 16) #14
  store ptr %call21, ptr %_tmp20, align 8
  %25 = load i32, ptr %qapi_perm, align 4
  %26 = load ptr, ptr %_tmp20, align 8
  %value22 = getelementptr inbounds %struct.BlockPermissionList, ptr %26, i32 0, i32 1
  store i32 %25, ptr %value22, align 8
  %27 = load ptr, ptr %edge, align 8
  %shared_perm23 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %27, i32 0, i32 4
  %28 = load ptr, ptr %shared_perm23, align 8
  %29 = load ptr, ptr %_tmp20, align 8
  %next24 = getelementptr inbounds %struct.BlockPermissionList, ptr %29, i32 0, i32 0
  store ptr %28, ptr %next24, align 8
  %30 = load ptr, ptr %_tmp20, align 8
  %31 = load ptr, ptr %edge, align 8
  %shared_perm25 = getelementptr inbounds %struct.XDbgBlockGraphEdge, ptr %31, i32 0, i32 4
  store ptr %30, ptr %shared_perm25, align 8
  br label %do.end26

do.end26:                                         ; preds = %do.body19
  br label %if.end27

if.end27:                                         ; preds = %do.end26, %if.end15
  br label %for.inc

for.inc:                                          ; preds = %if.end27
  %32 = load i32, ptr %qapi_perm, align 4
  %inc = add i32 %32, 1
  store i32 %inc, ptr %qapi_perm, align 4
  br label %for.cond, !llvm.loop !62

for.end:                                          ; preds = %for.cond
  br label %do.body28

do.body28:                                        ; preds = %for.end
  %call30 = call noalias ptr @g_malloc(i64 noundef 16) #14
  store ptr %call30, ptr %_tmp29, align 8
  %33 = load ptr, ptr %edge, align 8
  %34 = load ptr, ptr %_tmp29, align 8
  %value31 = getelementptr inbounds %struct.XDbgBlockGraphEdgeList, ptr %34, i32 0, i32 1
  store ptr %33, ptr %value31, align 8
  %35 = load ptr, ptr %gr.addr, align 8
  %graph = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %35, i32 0, i32 0
  %36 = load ptr, ptr %graph, align 8
  %edges = getelementptr inbounds %struct.XDbgBlockGraph, ptr %36, i32 0, i32 1
  %37 = load ptr, ptr %edges, align 8
  %38 = load ptr, ptr %_tmp29, align 8
  %next32 = getelementptr inbounds %struct.XDbgBlockGraphEdgeList, ptr %38, i32 0, i32 0
  store ptr %37, ptr %next32, align 8
  %39 = load ptr, ptr %_tmp29, align 8
  %40 = load ptr, ptr %gr.addr, align 8
  %graph33 = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %40, i32 0, i32 0
  %41 = load ptr, ptr %graph33, align 8
  %edges34 = getelementptr inbounds %struct.XDbgBlockGraph, ptr %41, i32 0, i32 1
  store ptr %39, ptr %edges34, align 8
  br label %do.end35

do.end35:                                         ; preds = %do.body28
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @qemu_lockable_auto_lock(ptr noundef %x) #0 {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  call void @qemu_lockable_lock(ptr noundef %0)
  %1 = load ptr, ptr %x.addr, align 8
  ret ptr %1
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_mutex_lock(ptr noundef %mutex) #0 {
entry:
  %mutex.addr = alloca ptr, align 8
  %_f = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %atomic-temp = alloca ptr, align 8
  store ptr %mutex, ptr %mutex.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %do.end, %entry
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.280, i32 noundef 122, ptr noundef @__func__.qemu_mutex_lock, ptr noundef null) #18
  unreachable

do.end:                                           ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %0 = load atomic i64, ptr @qemu_mutex_lock_func monotonic, align 8
  store i64 %0, ptr %atomic-temp, align 8
  %1 = load ptr, ptr %atomic-temp, align 8
  store ptr %1, ptr %tmp, align 8
  %2 = load ptr, ptr %tmp, align 8
  store ptr %2, ptr %_f, align 8
  %3 = load ptr, ptr %_f, align 8
  %4 = load ptr, ptr %mutex.addr, align 8
  call void %3(ptr noundef %4, ptr noundef @.str.280, i32 noundef 122)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_mutex_unlock(ptr noundef %mutex) #0 {
entry:
  %mutex.addr = alloca ptr, align 8
  store ptr %mutex, ptr %mutex.addr, align 8
  %0 = load ptr, ptr %mutex.addr, align 8
  call void @qemu_mutex_unlock_impl(ptr noundef %0, ptr noundef @.str.280, i32 noundef 132)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_cleanup_QemuLockable(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %1 = load ptr, ptr %0, align 8
  call void @glib_autoptr_clear_QemuLockable(ptr noundef %1)
  ret void
}

declare ptr @block_job_next_locked(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_lockable_auto_unlock(ptr noundef %x) #0 {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %x.addr, align 8
  call void @qemu_lockable_unlock(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @xdbg_graph_finalize(ptr noundef %gr) #0 {
entry:
  %gr.addr = alloca ptr, align 8
  %graph = alloca ptr, align 8
  store ptr %gr, ptr %gr.addr, align 8
  %0 = load ptr, ptr %gr.addr, align 8
  %graph1 = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %graph1, align 8
  store ptr %1, ptr %graph, align 8
  %2 = load ptr, ptr %gr.addr, align 8
  %graph_nodes = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %2, i32 0, i32 1
  %3 = load ptr, ptr %graph_nodes, align 8
  call void @g_hash_table_destroy(ptr noundef %3)
  %4 = load ptr, ptr %gr.addr, align 8
  call void @g_free(ptr noundef %4)
  %5 = load ptr, ptr %graph, align 8
  ret ptr %5
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_lookup_bs(ptr noundef %device, ptr noundef %node_name, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %device.addr = alloca ptr, align 8
  %node_name.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %blk = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %device, ptr %device.addr, align 8
  store ptr %node_name, ptr %node_name.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6503, ptr noundef @__PRETTY_FUNCTION__.bdrv_lookup_bs) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %device.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then1, label %if.end10

if.then1:                                         ; preds = %do.end
  %1 = load ptr, ptr %device.addr, align 8
  %call2 = call ptr @blk_by_name(ptr noundef %1)
  store ptr %call2, ptr %blk, align 8
  %2 = load ptr, ptr %blk, align 8
  %tobool3 = icmp ne ptr %2, null
  br i1 %tobool3, label %if.then4, label %if.end9

if.then4:                                         ; preds = %if.then1
  %3 = load ptr, ptr %blk, align 8
  %call5 = call ptr @blk_bs(ptr noundef %3)
  store ptr %call5, ptr %bs, align 8
  %4 = load ptr, ptr %bs, align 8
  %tobool6 = icmp ne ptr %4, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.then4
  %5 = load ptr, ptr %errp.addr, align 8
  %6 = load ptr, ptr %device.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %5, ptr noundef @.str.2, i32 noundef 6511, ptr noundef @__func__.bdrv_lookup_bs, ptr noundef @.str.100, ptr noundef %6)
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %if.then4
  %7 = load ptr, ptr %bs, align 8
  store ptr %7, ptr %retval, align 8
  br label %return

if.end9:                                          ; preds = %if.then1
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %do.end
  %8 = load ptr, ptr %node_name.addr, align 8
  %tobool11 = icmp ne ptr %8, null
  br i1 %tobool11, label %if.then12, label %if.end17

if.then12:                                        ; preds = %if.end10
  %9 = load ptr, ptr %node_name.addr, align 8
  %call13 = call ptr @bdrv_find_node(ptr noundef %9)
  store ptr %call13, ptr %bs, align 8
  %10 = load ptr, ptr %bs, align 8
  %tobool14 = icmp ne ptr %10, null
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.then12
  %11 = load ptr, ptr %bs, align 8
  store ptr %11, ptr %retval, align 8
  br label %return

if.end16:                                         ; preds = %if.then12
  br label %if.end17

if.end17:                                         ; preds = %if.end16, %if.end10
  %12 = load ptr, ptr %errp.addr, align 8
  %13 = load ptr, ptr %device.addr, align 8
  %tobool18 = icmp ne ptr %13, null
  br i1 %tobool18, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end17
  %14 = load ptr, ptr %device.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end17
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %14, %cond.true ], [ @.str.95, %cond.false ]
  %15 = load ptr, ptr %node_name.addr, align 8
  %tobool19 = icmp ne ptr %15, null
  br i1 %tobool19, label %cond.true20, label %cond.false21

cond.true20:                                      ; preds = %cond.end
  %16 = load ptr, ptr %node_name.addr, align 8
  br label %cond.end22

cond.false21:                                     ; preds = %cond.end
  br label %cond.end22

cond.end22:                                       ; preds = %cond.false21, %cond.true20
  %cond23 = phi ptr [ %16, %cond.true20 ], [ @.str.95, %cond.false21 ]
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %12, ptr noundef @.str.2, i32 noundef 6528, ptr noundef @__func__.bdrv_lookup_bs, ptr noundef @.str.101, ptr noundef %cond, ptr noundef %cond23)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %cond.end22, %if.then15, %if.end8
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

declare ptr @blk_by_name(ptr noundef) #2

declare ptr @blk_bs(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_next_node(ptr noundef %bs) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6548, ptr noundef @__PRETTY_FUNCTION__.bdrv_next_node) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %do.end
  %1 = load ptr, ptr @graph_bdrv_states, align 8
  store ptr %1, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %node_list = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 23
  %3 = load ptr, ptr %node_list, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end2, %if.then1
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_next_all_states(ptr noundef %bs) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6557, ptr noundef @__PRETTY_FUNCTION__.bdrv_next_all_states) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %do.end
  %1 = load ptr, ptr @all_bdrv_states, align 8
  store ptr %1, ptr %retval, align 8
  br label %return

if.end2:                                          ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %bs_list = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 24
  %3 = load ptr, ptr %bs_list, align 8
  store ptr %3, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end2, %if.then1
  %4 = load ptr, ptr %retval, align 8
  ret ptr %4
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_node_name(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  ret ptr %arraydecay
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_parent_name(ptr noundef %bs) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %name = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %1 = load ptr, ptr %lh_first, align 8
  store ptr %1, ptr %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %2 = load ptr, ptr %c, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %c, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %klass, align 8
  %get_name = getelementptr inbounds %struct.BdrvChildClass, ptr %4, i32 0, i32 15
  %5 = load ptr, ptr %get_name, align 8
  %tobool1 = icmp ne ptr %5, null
  br i1 %tobool1, label %if.then, label %if.end7

if.then:                                          ; preds = %for.body
  %6 = load ptr, ptr %c, align 8
  %klass2 = getelementptr inbounds %struct.BdrvChild, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %klass2, align 8
  %get_name3 = getelementptr inbounds %struct.BdrvChildClass, ptr %7, i32 0, i32 15
  %8 = load ptr, ptr %get_name3, align 8
  %9 = load ptr, ptr %c, align 8
  %call = call ptr %8(ptr noundef %9)
  store ptr %call, ptr %name, align 8
  %10 = load ptr, ptr %name, align 8
  %tobool4 = icmp ne ptr %10, null
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %11 = load ptr, ptr %name, align 8
  %12 = load i8, ptr %11, align 1
  %conv = sext i8 %12 to i32
  %tobool5 = icmp ne i32 %conv, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %land.lhs.true
  %13 = load ptr, ptr %name, align 8
  store ptr %13, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %14 = load ptr, ptr %c, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %14, i32 0, i32 10
  %le_next = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %15 = load ptr, ptr %le_next, align 8
  store ptr %15, ptr %c, align 8
  br label %for.cond, !llvm.loop !63

for.end:                                          ; preds = %for.cond
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %for.end, %if.then6
  %16 = load ptr, ptr %retval, align 8
  ret ptr %16
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_device_name(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_get_parent_name(ptr noundef %0)
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  br label %cond.end

cond.false:                                       ; preds = %do.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call, %cond.true ], [ @.str.95, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_device_or_node_name(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_get_parent_name(ptr noundef %0)
  %tobool = icmp ne ptr %call, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %1 = load ptr, ptr %bs.addr, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %call, %cond.true ], [ %arraydecay, %cond.false ]
  ret ptr %cond
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_get_flags(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %open_flags, align 8
  ret i32 %1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_has_zero_init_1(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6614, ptr noundef @__PRETTY_FUNCTION__.bdrv_has_zero_init_1) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  ret i32 1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_has_zero_init(ptr noundef %bs) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %filtered = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6621, ptr noundef @__PRETTY_FUNCTION__.bdrv_has_zero_init) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %do.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %call3 = call ptr @bdrv_cow_child(ptr noundef %2)
  %tobool4 = icmp ne ptr %call3, null
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end2
  store i32 0, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end2
  %3 = load ptr, ptr %bs.addr, align 8
  %drv7 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv7, align 8
  %bdrv_has_zero_init = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 46
  %5 = load ptr, ptr %bdrv_has_zero_init, align 8
  %tobool8 = icmp ne ptr %5, null
  br i1 %tobool8, label %if.then9, label %if.end13

if.then9:                                         ; preds = %if.end6
  %6 = load ptr, ptr %bs.addr, align 8
  %drv10 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 6
  %7 = load ptr, ptr %drv10, align 8
  %bdrv_has_zero_init11 = getelementptr inbounds %struct.BlockDriver, ptr %7, i32 0, i32 46
  %8 = load ptr, ptr %bdrv_has_zero_init11, align 8
  %9 = load ptr, ptr %bs.addr, align 8
  %call12 = call i32 %8(ptr noundef %9)
  store i32 %call12, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end6
  %10 = load ptr, ptr %bs.addr, align 8
  %call14 = call ptr @bdrv_filter_bs(ptr noundef %10)
  store ptr %call14, ptr %filtered, align 8
  %11 = load ptr, ptr %filtered, align 8
  %tobool15 = icmp ne ptr %11, null
  br i1 %tobool15, label %if.then16, label %if.end18

if.then16:                                        ; preds = %if.end13
  %12 = load ptr, ptr %filtered, align 8
  %call17 = call i32 @bdrv_has_zero_init(ptr noundef %12)
  store i32 %call17, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.end13
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end18, %if.then16, %if.then9, %if.then5, %if.then1
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_cow_child(ptr noundef %bs) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %do.end
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %do.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %bs.addr, align 8
  %drv2 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv2, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 2
  %5 = load i8, ptr %is_filter, align 4
  %tobool3 = trunc i8 %5 to i1
  br i1 %tobool3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %6 = load ptr, ptr %bs.addr, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 30
  %7 = load ptr, ptr %backing, align 8
  %tobool6 = icmp ne ptr %7, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end5
  store ptr null, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end5
  %8 = load ptr, ptr %bs.addr, align 8
  %backing9 = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 30
  %9 = load ptr, ptr %backing9, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %9, i32 0, i32 3
  %10 = load i32, ptr %role, align 8
  %and = and i32 %10, 8
  %tobool10 = icmp ne i32 %and, 0
  br i1 %tobool10, label %if.then11, label %if.else

if.then11:                                        ; preds = %if.end8
  br label %if.end12

if.else:                                          ; preds = %if.end8
  call void @__assert_fail(ptr noundef @.str.151, ptr noundef @.str.2, i32 noundef 8438, ptr noundef @__PRETTY_FUNCTION__.bdrv_cow_child) #16
  unreachable

if.end12:                                         ; preds = %if.then11
  %11 = load ptr, ptr %bs.addr, align 8
  %backing13 = getelementptr inbounds %struct.BlockDriverState, ptr %11, i32 0, i32 30
  %12 = load ptr, ptr %backing13, align 8
  store ptr %12, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end12, %if.then7, %if.then4, %if.then
  %13 = load ptr, ptr %retval, align 8
  ret ptr %13
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_can_write_zeroes_with_unmap(ptr noundef %bs) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %open_flags, align 8
  %and = and i32 %1, 16384
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %supported_zero_flags = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 20
  %3 = load i32, ptr %supported_zero_flags, align 8
  %and1 = and i32 %3, 4
  %tobool2 = icmp ne i32 %and1, 0
  store i1 %tobool2, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i1, ptr %retval, align 1
  ret i1 %4
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_get_backing_filename(ptr noundef %bs, ptr noundef %filename, i32 noundef %filename_size) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %filename_size.addr = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store i32 %filename_size, ptr %filename_size.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %filename.addr, align 8
  %1 = load i32, ptr %filename_size.addr, align 4
  %2 = load ptr, ptr %bs.addr, align 8
  %backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 12
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %backing_file, i64 0, i64 0
  call void @pstrcpy(ptr noundef %0, i32 noundef %1, ptr noundef %arraydecay)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_get_info(ptr noundef %bs, ptr noundef %bdi) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %bdi.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %drv = alloca ptr, align 8
  %filtered = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %bdi, ptr %bdi.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  call void @assert_bdrv_graph_readable()
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  store i32 -123, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %do.end
  %3 = load ptr, ptr %drv, align 8
  %bdrv_co_get_info = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 93
  %4 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_get_info, ptr @.str.13, ptr @.str.14, i32 731, ptr null)
  %5 = load ptr, ptr %4, align 8
  %tobool2 = icmp ne ptr %5, null
  br i1 %tobool2, label %if.end8, label %if.then3

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_filter_bs(ptr noundef %6)
  store ptr %call, ptr %filtered, align 8
  %7 = load ptr, ptr %filtered, align 8
  %tobool4 = icmp ne ptr %7, null
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.then3
  %8 = load ptr, ptr %filtered, align 8
  %9 = load ptr, ptr %bdi.addr, align 8
  %call6 = call i32 @bdrv_co_get_info(ptr noundef %8, ptr noundef %9)
  store i32 %call6, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.then3
  store i32 -95, ptr %retval, align 4
  br label %return

if.end8:                                          ; preds = %if.end
  %10 = load ptr, ptr %bdi.addr, align 8
  call void @llvm.memset.p0.i64(ptr align 8 %10, i8 0, i64 24, i1 false)
  %11 = load ptr, ptr %drv, align 8
  %bdrv_co_get_info9 = getelementptr inbounds %struct.BlockDriver, ptr %11, i32 0, i32 93
  %12 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_get_info9, ptr @.str.13, ptr @.str.14, i32 731, ptr null)
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %bs.addr, align 8
  %15 = load ptr, ptr %bdi.addr, align 8
  %call10 = call i32 %13(ptr noundef %14, ptr noundef %15)
  store i32 %call10, ptr %ret, align 4
  %16 = load ptr, ptr %bdi.addr, align 8
  %subcluster_size = getelementptr inbounds %struct.BlockDriverInfo, ptr %16, i32 0, i32 1
  %17 = load i32, ptr %subcluster_size, align 4
  %cmp = icmp eq i32 %17, 0
  br i1 %cmp, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %18 = load ptr, ptr %bdi.addr, align 8
  %cluster_size = getelementptr inbounds %struct.BlockDriverInfo, ptr %18, i32 0, i32 0
  %19 = load i32, ptr %cluster_size, align 8
  %20 = load ptr, ptr %bdi.addr, align 8
  %subcluster_size12 = getelementptr inbounds %struct.BlockDriverInfo, ptr %20, i32 0, i32 1
  store i32 %19, ptr %subcluster_size12, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end8
  %21 = load i32, ptr %ret, align 4
  %cmp14 = icmp slt i32 %21, 0
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.end13
  %22 = load i32, ptr %ret, align 4
  store i32 %22, ptr %retval, align 4
  br label %return

if.end16:                                         ; preds = %if.end13
  %23 = load ptr, ptr %bdi.addr, align 8
  %cluster_size17 = getelementptr inbounds %struct.BlockDriverInfo, ptr %23, i32 0, i32 0
  %24 = load i32, ptr %cluster_size17, align 8
  %conv = sext i32 %24 to i64
  %cmp18 = icmp sgt i64 %conv, 1073741824
  br i1 %cmp18, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end16
  store i32 -22, ptr %retval, align 4
  br label %return

if.end21:                                         ; preds = %if.end16
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end21, %if.then20, %if.then15, %if.end7, %if.then5, %if.then
  %25 = load i32, ptr %retval, align 4
  ret i32 %25
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_specific_info(ptr noundef %bs, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %do.end
  %3 = load ptr, ptr %drv, align 8
  %bdrv_get_specific_info = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 94
  %4 = load ptr, ptr %bdrv_get_specific_info, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load ptr, ptr %drv, align 8
  %bdrv_get_specific_info3 = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 94
  %6 = load ptr, ptr %bdrv_get_specific_info3, align 8
  %7 = load ptr, ptr %bs.addr, align 8
  %8 = load ptr, ptr %errp.addr, align 8
  %call = call ptr %6(ptr noundef %7, ptr noundef %8)
  store ptr %call, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true, %do.end
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load ptr, ptr %retval, align 8
  ret ptr %9
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_get_specific_stats(ptr noundef %bs) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %do.end
  %3 = load ptr, ptr %drv, align 8
  %bdrv_get_specific_stats = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 95
  %4 = load ptr, ptr %bdrv_get_specific_stats, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %do.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %5 = load ptr, ptr %drv, align 8
  %bdrv_get_specific_stats3 = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 95
  %6 = load ptr, ptr %bdrv_get_specific_stats3, align 8
  %7 = load ptr, ptr %bs.addr, align 8
  %call = call ptr %6(ptr noundef %7)
  store ptr %call, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load ptr, ptr %retval, align 8
  ret ptr %8
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_debug_event(ptr noundef %bs, i32 noundef %event) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %event.addr = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store i32 %event, ptr %event.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  call void @assert_bdrv_graph_readable()
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %do.end
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %lor.lhs.false2, label %if.then

lor.lhs.false2:                                   ; preds = %lor.lhs.false
  %3 = load ptr, ptr %bs.addr, align 8
  %drv3 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv3, align 8
  %bdrv_co_debug_event = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 107
  %5 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_debug_event, ptr @.str.13, ptr @.str.14, i32 776, ptr null)
  %6 = load ptr, ptr %5, align 8
  %tobool4 = icmp ne ptr %6, null
  br i1 %tobool4, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false2, %lor.lhs.false, %do.end
  br label %return

if.end:                                           ; preds = %lor.lhs.false2
  %7 = load ptr, ptr %bs.addr, align 8
  %drv5 = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 6
  %8 = load ptr, ptr %drv5, align 8
  %bdrv_co_debug_event6 = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 107
  %9 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_debug_event6, ptr @.str.13, ptr @.str.14, i32 776, ptr null)
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %bs.addr, align 8
  %12 = load i32, ptr %event.addr, align 4
  call void %10(ptr noundef %11, i32 noundef %12)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_debug_breakpoint(ptr noundef %bs, ptr noundef %event, ptr noundef %tag) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %event.addr = alloca ptr, align 8
  %tag.addr = alloca ptr, align 8
  %graph_lockable_auto59 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %event, ptr %event.addr, align 8
  store ptr %tag, ptr %tag.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6752, ptr noundef @__PRETTY_FUNCTION__.bdrv_debug_breakpoint) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call1, ptr %graph_lockable_auto59, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %call2 = call ptr @bdrv_find_debug_node(ptr noundef %0)
  store ptr %call2, ptr %bs.addr, align 8
  %1 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then3, label %if.end5

if.then3:                                         ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv, align 8
  %bdrv_debug_breakpoint = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 41
  %4 = load ptr, ptr %bdrv_debug_breakpoint, align 8
  %5 = load ptr, ptr %bs.addr, align 8
  %6 = load ptr, ptr %event.addr, align 8
  %7 = load ptr, ptr %tag.addr, align 8
  %call4 = call i32 %4(ptr noundef %5, ptr noundef %6, ptr noundef %7)
  store i32 %call4, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end5:                                          ; preds = %do.end
  store i32 -95, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.then3
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto59)
  %8 = load i32, ptr %retval, align 4
  ret i32 %8
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_find_debug_node(ptr noundef %bs) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6736, ptr noundef @__PRETTY_FUNCTION__.bdrv_find_debug_node) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %do.end
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %while.cond
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %3 = load ptr, ptr %bs.addr, align 8
  %drv2 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv2, align 8
  %bdrv_debug_breakpoint = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 41
  %5 = load ptr, ptr %bdrv_debug_breakpoint, align 8
  %tobool3 = icmp ne ptr %5, null
  %lnot = xor i1 %tobool3, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %while.cond
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %while.cond ], [ %lnot, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %7 = load ptr, ptr %bs.addr, align 8
  %call4 = call ptr @bdrv_primary_bs(ptr noundef %7)
  store ptr %call4, ptr %bs.addr, align 8
  br label %while.cond, !llvm.loop !64

while.end:                                        ; preds = %land.end
  %8 = load ptr, ptr %bs.addr, align 8
  %tobool5 = icmp ne ptr %8, null
  br i1 %tobool5, label %land.lhs.true6, label %if.end19

land.lhs.true6:                                   ; preds = %while.end
  %9 = load ptr, ptr %bs.addr, align 8
  %drv7 = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 6
  %10 = load ptr, ptr %drv7, align 8
  %tobool8 = icmp ne ptr %10, null
  br i1 %tobool8, label %land.lhs.true9, label %if.end19

land.lhs.true9:                                   ; preds = %land.lhs.true6
  %11 = load ptr, ptr %bs.addr, align 8
  %drv10 = getelementptr inbounds %struct.BlockDriverState, ptr %11, i32 0, i32 6
  %12 = load ptr, ptr %drv10, align 8
  %bdrv_debug_breakpoint11 = getelementptr inbounds %struct.BlockDriver, ptr %12, i32 0, i32 41
  %13 = load ptr, ptr %bdrv_debug_breakpoint11, align 8
  %tobool12 = icmp ne ptr %13, null
  br i1 %tobool12, label %if.then13, label %if.end19

if.then13:                                        ; preds = %land.lhs.true9
  %14 = load ptr, ptr %bs.addr, align 8
  %drv14 = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 6
  %15 = load ptr, ptr %drv14, align 8
  %bdrv_debug_remove_breakpoint = getelementptr inbounds %struct.BlockDriver, ptr %15, i32 0, i32 42
  %16 = load ptr, ptr %bdrv_debug_remove_breakpoint, align 8
  %tobool15 = icmp ne ptr %16, null
  br i1 %tobool15, label %if.then16, label %if.else17

if.then16:                                        ; preds = %if.then13
  br label %if.end18

if.else17:                                        ; preds = %if.then13
  call void @__assert_fail(ptr noundef @.str.281, ptr noundef @.str.2, i32 noundef 6742, ptr noundef @__PRETTY_FUNCTION__.bdrv_find_debug_node) #16
  unreachable

if.end18:                                         ; preds = %if.then16
  %17 = load ptr, ptr %bs.addr, align 8
  store ptr %17, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %land.lhs.true9, %land.lhs.true6, %while.end
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.end18
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_debug_remove_breakpoint(ptr noundef %bs, ptr noundef %tag) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %tag.addr = alloca ptr, align 8
  %graph_lockable_auto60 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %tag, ptr %tag.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6765, ptr noundef @__PRETTY_FUNCTION__.bdrv_debug_remove_breakpoint) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call1, ptr %graph_lockable_auto60, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %call2 = call ptr @bdrv_find_debug_node(ptr noundef %0)
  store ptr %call2, ptr %bs.addr, align 8
  %1 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then3, label %if.end5

if.then3:                                         ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv, align 8
  %bdrv_debug_remove_breakpoint = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 42
  %4 = load ptr, ptr %bdrv_debug_remove_breakpoint, align 8
  %5 = load ptr, ptr %bs.addr, align 8
  %6 = load ptr, ptr %tag.addr, align 8
  %call4 = call i32 %4(ptr noundef %5, ptr noundef %6)
  store i32 %call4, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end5:                                          ; preds = %do.end
  store i32 -95, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end5, %if.then3
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto60)
  %7 = load i32, ptr %retval, align 4
  ret i32 %7
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_debug_resume(ptr noundef %bs, ptr noundef %tag) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %tag.addr = alloca ptr, align 8
  %graph_lockable_auto61 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %tag, ptr %tag.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6778, ptr noundef @__PRETTY_FUNCTION__.bdrv_debug_resume) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call1, ptr %graph_lockable_auto61, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %do.end
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool2 = icmp ne ptr %2, null
  br i1 %tobool2, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.rhs
  %3 = load ptr, ptr %bs.addr, align 8
  %drv3 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv3, align 8
  %bdrv_debug_resume = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 43
  %5 = load ptr, ptr %bdrv_debug_resume, align 8
  %tobool4 = icmp ne ptr %5, null
  %lnot = xor i1 %tobool4, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %6 = phi i1 [ true, %land.rhs ], [ %lnot, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %6, %lor.end ]
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %8 = load ptr, ptr %bs.addr, align 8
  %call5 = call ptr @bdrv_primary_bs(ptr noundef %8)
  store ptr %call5, ptr %bs.addr, align 8
  br label %while.cond, !llvm.loop !65

while.end:                                        ; preds = %land.end
  %9 = load ptr, ptr %bs.addr, align 8
  %tobool6 = icmp ne ptr %9, null
  br i1 %tobool6, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %while.end
  %10 = load ptr, ptr %bs.addr, align 8
  %drv7 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 6
  %11 = load ptr, ptr %drv7, align 8
  %tobool8 = icmp ne ptr %11, null
  br i1 %tobool8, label %land.lhs.true9, label %if.end17

land.lhs.true9:                                   ; preds = %land.lhs.true
  %12 = load ptr, ptr %bs.addr, align 8
  %drv10 = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 6
  %13 = load ptr, ptr %drv10, align 8
  %bdrv_debug_resume11 = getelementptr inbounds %struct.BlockDriver, ptr %13, i32 0, i32 43
  %14 = load ptr, ptr %bdrv_debug_resume11, align 8
  %tobool12 = icmp ne ptr %14, null
  br i1 %tobool12, label %if.then13, label %if.end17

if.then13:                                        ; preds = %land.lhs.true9
  %15 = load ptr, ptr %bs.addr, align 8
  %drv14 = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 6
  %16 = load ptr, ptr %drv14, align 8
  %bdrv_debug_resume15 = getelementptr inbounds %struct.BlockDriver, ptr %16, i32 0, i32 43
  %17 = load ptr, ptr %bdrv_debug_resume15, align 8
  %18 = load ptr, ptr %bs.addr, align 8
  %19 = load ptr, ptr %tag.addr, align 8
  %call16 = call i32 %17(ptr noundef %18, ptr noundef %19)
  store i32 %call16, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end17:                                         ; preds = %land.lhs.true9, %land.lhs.true, %while.end
  store i32 -95, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end17, %if.then13
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto61)
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_primary_bs(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_primary_child(ptr noundef %0)
  %call1 = call ptr @child_bs(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_debug_is_suspended(ptr noundef %bs, ptr noundef %tag) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %tag.addr = alloca ptr, align 8
  %graph_lockable_auto62 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %tag, ptr %tag.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6794, ptr noundef @__PRETTY_FUNCTION__.bdrv_debug_is_suspended) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call1, ptr %graph_lockable_auto62, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %do.end
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %while.cond
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool2 = icmp ne ptr %2, null
  br i1 %tobool2, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %3 = load ptr, ptr %bs.addr, align 8
  %drv3 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv3, align 8
  %bdrv_debug_is_suspended = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 44
  %5 = load ptr, ptr %bdrv_debug_is_suspended, align 8
  %tobool4 = icmp ne ptr %5, null
  %lnot = xor i1 %tobool4, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %while.cond
  %6 = phi i1 [ false, %land.lhs.true ], [ false, %while.cond ], [ %lnot, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %7 = load ptr, ptr %bs.addr, align 8
  %call5 = call ptr @bdrv_primary_bs(ptr noundef %7)
  store ptr %call5, ptr %bs.addr, align 8
  br label %while.cond, !llvm.loop !66

while.end:                                        ; preds = %land.end
  %8 = load ptr, ptr %bs.addr, align 8
  %tobool6 = icmp ne ptr %8, null
  br i1 %tobool6, label %land.lhs.true7, label %if.end18

land.lhs.true7:                                   ; preds = %while.end
  %9 = load ptr, ptr %bs.addr, align 8
  %drv8 = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 6
  %10 = load ptr, ptr %drv8, align 8
  %tobool9 = icmp ne ptr %10, null
  br i1 %tobool9, label %land.lhs.true10, label %if.end18

land.lhs.true10:                                  ; preds = %land.lhs.true7
  %11 = load ptr, ptr %bs.addr, align 8
  %drv11 = getelementptr inbounds %struct.BlockDriverState, ptr %11, i32 0, i32 6
  %12 = load ptr, ptr %drv11, align 8
  %bdrv_debug_is_suspended12 = getelementptr inbounds %struct.BlockDriver, ptr %12, i32 0, i32 44
  %13 = load ptr, ptr %bdrv_debug_is_suspended12, align 8
  %tobool13 = icmp ne ptr %13, null
  br i1 %tobool13, label %if.then14, label %if.end18

if.then14:                                        ; preds = %land.lhs.true10
  %14 = load ptr, ptr %bs.addr, align 8
  %drv15 = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 6
  %15 = load ptr, ptr %drv15, align 8
  %bdrv_debug_is_suspended16 = getelementptr inbounds %struct.BlockDriver, ptr %15, i32 0, i32 44
  %16 = load ptr, ptr %bdrv_debug_is_suspended16, align 8
  %17 = load ptr, ptr %bs.addr, align 8
  %18 = load ptr, ptr %tag.addr, align 8
  %call17 = call zeroext i1 %16(ptr noundef %17, ptr noundef %18)
  store i1 %call17, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end18:                                         ; preds = %land.lhs.true10, %land.lhs.true7, %while.end
  store i1 false, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end18, %if.then14
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto62)
  %19 = load i1, ptr %retval, align 1
  ret i1 %19
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_find_backing_image(ptr noundef %bs, ptr noundef %backing_file) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %backing_file.addr = alloca ptr, align 8
  %filename_full = alloca ptr, align 8
  %backing_file_full = alloca ptr, align 8
  %filename_tmp = alloca ptr, align 8
  %is_protocol = alloca i32, align 4
  %filenames_refreshed = alloca i8, align 1
  %curr_bs = alloca ptr, align 8
  %retval1 = alloca ptr, align 8
  %bs_below = alloca ptr, align 8
  %graph_lockable_auto63 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %cleanup.dest.slot = alloca i32, align 4
  %backing_file_full_ret = alloca ptr, align 8
  %equal = alloca i8, align 1
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %backing_file, ptr %backing_file.addr, align 8
  store ptr null, ptr %filename_full, align 8
  store ptr null, ptr %backing_file_full, align 8
  store ptr null, ptr %filename_tmp, align 8
  store i32 0, ptr %is_protocol, align 4
  store i8 0, ptr %filenames_refreshed, align 1
  store ptr null, ptr %curr_bs, align 8
  store ptr null, ptr %retval1, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6824, ptr noundef @__PRETTY_FUNCTION__.bdrv_find_backing_image) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call2 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call2, ptr %graph_lockable_auto63, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then6

lor.lhs.false:                                    ; preds = %do.end
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool3 = icmp ne ptr %2, null
  br i1 %tobool3, label %lor.lhs.false4, label %if.then6

lor.lhs.false4:                                   ; preds = %lor.lhs.false
  %3 = load ptr, ptr %backing_file.addr, align 8
  %tobool5 = icmp ne ptr %3, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %lor.lhs.false4, %lor.lhs.false, %do.end
  store ptr null, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end7:                                          ; preds = %lor.lhs.false4
  %call8 = call noalias ptr @g_malloc(i64 noundef 4096) #14
  store ptr %call8, ptr %filename_full, align 8
  %call9 = call noalias ptr @g_malloc(i64 noundef 4096) #14
  store ptr %call9, ptr %backing_file_full, align 8
  %4 = load ptr, ptr %backing_file.addr, align 8
  %call10 = call i32 @path_has_protocol(ptr noundef %4)
  store i32 %call10, ptr %is_protocol, align 4
  %5 = load ptr, ptr %bs.addr, align 8
  %call11 = call ptr @bdrv_skip_filters(ptr noundef %5)
  store ptr %call11, ptr %curr_bs, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %6 = load ptr, ptr %curr_bs, align 8
  %call12 = call ptr @bdrv_cow_child(ptr noundef %6)
  %cmp = icmp ne ptr %call12, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load ptr, ptr %curr_bs, align 8
  %call13 = call ptr @bdrv_backing_chain_next(ptr noundef %7)
  store ptr %call13, ptr %bs_below, align 8
  %8 = load ptr, ptr %curr_bs, align 8
  %call14 = call zeroext i1 @bdrv_backing_overridden(ptr noundef %8)
  br i1 %call14, label %if.then15, label %if.else23

if.then15:                                        ; preds = %for.body
  %9 = load i8, ptr %filenames_refreshed, align 1
  %tobool16 = trunc i8 %9 to i1
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.then15
  %10 = load ptr, ptr %bs_below, align 8
  call void @bdrv_refresh_filename(ptr noundef %10)
  store i8 1, ptr %filenames_refreshed, align 1
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %if.then15
  %11 = load ptr, ptr %backing_file.addr, align 8
  %12 = load ptr, ptr %bs_below, align 8
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 11
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %filename, i64 0, i64 0
  %call19 = call i32 @strcmp(ptr noundef %11, ptr noundef %arraydecay) #13
  %cmp20 = icmp eq i32 %call19, 0
  br i1 %cmp20, label %if.then21, label %if.end22

if.then21:                                        ; preds = %if.end18
  %13 = load ptr, ptr %bs_below, align 8
  store ptr %13, ptr %retval1, align 8
  br label %for.end

if.end22:                                         ; preds = %if.end18
  br label %if.end66

if.else23:                                        ; preds = %for.body
  %14 = load i32, ptr %is_protocol, align 4
  %tobool24 = icmp ne i32 %14, 0
  br i1 %tobool24, label %if.then30, label %lor.lhs.false25

lor.lhs.false25:                                  ; preds = %if.else23
  %15 = load ptr, ptr %curr_bs, align 8
  %backing_file26 = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 12
  %arraydecay27 = getelementptr inbounds [4096 x i8], ptr %backing_file26, i64 0, i64 0
  %call28 = call i32 @path_has_protocol(ptr noundef %arraydecay27)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then30, label %if.else46

if.then30:                                        ; preds = %lor.lhs.false25, %if.else23
  %16 = load ptr, ptr %backing_file.addr, align 8
  %17 = load ptr, ptr %curr_bs, align 8
  %backing_file31 = getelementptr inbounds %struct.BlockDriverState, ptr %17, i32 0, i32 12
  %arraydecay32 = getelementptr inbounds [4096 x i8], ptr %backing_file31, i64 0, i64 0
  %call33 = call i32 @strcmp(ptr noundef %16, ptr noundef %arraydecay32) #13
  %cmp34 = icmp eq i32 %call33, 0
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then30
  %18 = load ptr, ptr %bs_below, align 8
  store ptr %18, ptr %retval1, align 8
  br label %for.end

if.end36:                                         ; preds = %if.then30
  %19 = load ptr, ptr %curr_bs, align 8
  %call37 = call ptr @bdrv_get_full_backing_filename(ptr noundef %19, ptr noundef null)
  store ptr %call37, ptr %backing_file_full_ret, align 8
  %20 = load ptr, ptr %backing_file_full_ret, align 8
  %tobool38 = icmp ne ptr %20, null
  br i1 %tobool38, label %if.then39, label %if.end45

if.then39:                                        ; preds = %if.end36
  %21 = load ptr, ptr %backing_file.addr, align 8
  %22 = load ptr, ptr %backing_file_full_ret, align 8
  %call40 = call i32 @strcmp(ptr noundef %21, ptr noundef %22) #13
  %cmp41 = icmp eq i32 %call40, 0
  %frombool = zext i1 %cmp41 to i8
  store i8 %frombool, ptr %equal, align 1
  %23 = load ptr, ptr %backing_file_full_ret, align 8
  call void @g_free(ptr noundef %23)
  %24 = load i8, ptr %equal, align 1
  %tobool42 = trunc i8 %24 to i1
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.then39
  %25 = load ptr, ptr %bs_below, align 8
  store ptr %25, ptr %retval1, align 8
  br label %for.end

if.end44:                                         ; preds = %if.then39
  br label %if.end45

if.end45:                                         ; preds = %if.end44, %if.end36
  br label %if.end65

if.else46:                                        ; preds = %lor.lhs.false25
  %26 = load ptr, ptr %curr_bs, align 8
  %27 = load ptr, ptr %backing_file.addr, align 8
  %call47 = call ptr @bdrv_make_absolute_filename(ptr noundef %26, ptr noundef %27, ptr noundef null)
  store ptr %call47, ptr %filename_tmp, align 8
  %28 = load ptr, ptr %filename_tmp, align 8
  %tobool48 = icmp ne ptr %28, null
  br i1 %tobool48, label %lor.lhs.false49, label %if.then52

lor.lhs.false49:                                  ; preds = %if.else46
  %29 = load ptr, ptr %filename_tmp, align 8
  %30 = load ptr, ptr %filename_full, align 8
  %call50 = call ptr @realpath(ptr noundef %29, ptr noundef %30) #15
  %tobool51 = icmp ne ptr %call50, null
  br i1 %tobool51, label %if.end53, label %if.then52

if.then52:                                        ; preds = %lor.lhs.false49, %if.else46
  %31 = load ptr, ptr %filename_tmp, align 8
  call void @g_free(ptr noundef %31)
  br label %for.inc

if.end53:                                         ; preds = %lor.lhs.false49
  %32 = load ptr, ptr %filename_tmp, align 8
  call void @g_free(ptr noundef %32)
  %33 = load ptr, ptr %curr_bs, align 8
  %call54 = call ptr @bdrv_get_full_backing_filename(ptr noundef %33, ptr noundef null)
  store ptr %call54, ptr %filename_tmp, align 8
  %34 = load ptr, ptr %filename_tmp, align 8
  %tobool55 = icmp ne ptr %34, null
  br i1 %tobool55, label %lor.lhs.false56, label %if.then59

lor.lhs.false56:                                  ; preds = %if.end53
  %35 = load ptr, ptr %filename_tmp, align 8
  %36 = load ptr, ptr %backing_file_full, align 8
  %call57 = call ptr @realpath(ptr noundef %35, ptr noundef %36) #15
  %tobool58 = icmp ne ptr %call57, null
  br i1 %tobool58, label %if.end60, label %if.then59

if.then59:                                        ; preds = %lor.lhs.false56, %if.end53
  %37 = load ptr, ptr %filename_tmp, align 8
  call void @g_free(ptr noundef %37)
  br label %for.inc

if.end60:                                         ; preds = %lor.lhs.false56
  %38 = load ptr, ptr %filename_tmp, align 8
  call void @g_free(ptr noundef %38)
  %39 = load ptr, ptr %backing_file_full, align 8
  %40 = load ptr, ptr %filename_full, align 8
  %call61 = call i32 @strcmp(ptr noundef %39, ptr noundef %40) #13
  %cmp62 = icmp eq i32 %call61, 0
  br i1 %cmp62, label %if.then63, label %if.end64

if.then63:                                        ; preds = %if.end60
  %41 = load ptr, ptr %bs_below, align 8
  store ptr %41, ptr %retval1, align 8
  br label %for.end

if.end64:                                         ; preds = %if.end60
  br label %if.end65

if.end65:                                         ; preds = %if.end64, %if.end45
  br label %if.end66

if.end66:                                         ; preds = %if.end65, %if.end22
  br label %for.inc

for.inc:                                          ; preds = %if.end66, %if.then59, %if.then52
  %42 = load ptr, ptr %bs_below, align 8
  store ptr %42, ptr %curr_bs, align 8
  br label %for.cond, !llvm.loop !67

for.end:                                          ; preds = %if.then63, %if.then43, %if.then35, %if.then21, %for.cond
  %43 = load ptr, ptr %filename_full, align 8
  call void @g_free(ptr noundef %43)
  %44 = load ptr, ptr %backing_file_full, align 8
  call void @g_free(ptr noundef %44)
  %45 = load ptr, ptr %retval1, align 8
  store ptr %45, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then6
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto63)
  %46 = load ptr, ptr %retval, align 8
  ret ptr %46
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_backing_overridden(ptr noundef %bs) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 8142, ptr noundef @__PRETTY_FUNCTION__.bdrv_backing_overridden) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 30
  %1 = load ptr, ptr %backing, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then1, label %if.else7

if.then1:                                         ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %auto_backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 13
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %auto_backing_file, i64 0, i64 0
  %3 = load ptr, ptr %bs.addr, align 8
  %backing2 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 30
  %4 = load ptr, ptr %backing2, align 8
  %bs3 = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %bs3, align 8
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 11
  %arraydecay4 = getelementptr inbounds [4096 x i8], ptr %filename, i64 0, i64 0
  %call5 = call i32 @strcmp(ptr noundef %arraydecay, ptr noundef %arraydecay4) #13
  %tobool6 = icmp ne i32 %call5, 0
  store i1 %tobool6, ptr %retval, align 1
  br label %return

if.else7:                                         ; preds = %do.end
  %6 = load ptr, ptr %bs.addr, align 8
  %auto_backing_file8 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 13
  %arrayidx = getelementptr [4096 x i8], ptr %auto_backing_file8, i64 0, i64 0
  %7 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %7 to i32
  %cmp = icmp ne i32 %conv, 0
  store i1 %cmp, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.else7, %if.then1
  %8 = load i1, ptr %retval, align 1
  ret i1 %8
}

; Function Attrs: nounwind
declare ptr @realpath(ptr noundef, ptr noundef) #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_init() #0 {
entry:
  call void @module_call_init(i32 noundef 1)
  ret void
}

declare void @module_call_init(i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_init_with_whitelist() #0 {
entry:
  store i32 1, ptr @use_bdrv_whitelist, align 4
  call void @bdrv_init()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_activate(ptr noundef %bs, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %child = alloca ptr, align 8
  %parent = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %ret = alloca i32, align 4
  %bm = alloca ptr, align 8
  %graph_lockable_auto64 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 6944, ptr noundef @__PRETTY_FUNCTION__.bdrv_activate) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call1, ptr %graph_lockable_auto64, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %do.end
  store i32 -123, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end3:                                          ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %3 = load ptr, ptr %lh_first, align 8
  store ptr %3, ptr %child, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %4 = load ptr, ptr %child, align 8
  %tobool4 = icmp ne ptr %4, null
  br i1 %tobool4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %child, align 8
  %bs5 = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %bs5, align 8
  %call6 = call i32 @bdrv_activate(ptr noundef %6, ptr noundef %local_err)
  %7 = load ptr, ptr %local_err, align 8
  %tobool7 = icmp ne ptr %7, null
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %for.body
  %8 = load ptr, ptr %errp.addr, align 8
  %9 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %8, ptr noundef %9)
  store i32 -22, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end9:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %10 = load ptr, ptr %child, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %10, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %11 = load ptr, ptr %le_next, align 8
  store ptr %11, ptr %child, align 8
  br label %for.cond, !llvm.loop !68

for.end:                                          ; preds = %for.cond
  %12 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 0
  %13 = load i32, ptr %open_flags, align 8
  %and = and i32 %13, 2048
  %tobool10 = icmp ne i32 %and, 0
  br i1 %tobool10, label %if.then11, label %if.end37

if.then11:                                        ; preds = %for.end
  %14 = load ptr, ptr %bs.addr, align 8
  %open_flags12 = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 0
  %15 = load i32, ptr %open_flags12, align 8
  %and13 = and i32 %15, -2049
  store i32 %and13, ptr %open_flags12, align 8
  %16 = load ptr, ptr %bs.addr, align 8
  %17 = load ptr, ptr %errp.addr, align 8
  %call14 = call i32 @bdrv_refresh_perms(ptr noundef %16, ptr noundef null, ptr noundef %17)
  store i32 %call14, ptr %ret, align 4
  %18 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %18, 0
  br i1 %cmp, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.then11
  %19 = load ptr, ptr %bs.addr, align 8
  %open_flags16 = getelementptr inbounds %struct.BlockDriverState, ptr %19, i32 0, i32 0
  %20 = load i32, ptr %open_flags16, align 8
  %or = or i32 %20, 2048
  store i32 %or, ptr %open_flags16, align 8
  %21 = load i32, ptr %ret, align 4
  store i32 %21, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end17:                                         ; preds = %if.then11
  %22 = load ptr, ptr %bs.addr, align 8
  %23 = load ptr, ptr %errp.addr, align 8
  %call18 = call i32 @bdrv_invalidate_cache(ptr noundef %22, ptr noundef %23)
  store i32 %call18, ptr %ret, align 4
  %24 = load i32, ptr %ret, align 4
  %cmp19 = icmp slt i32 %24, 0
  br i1 %cmp19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %if.end17
  %25 = load ptr, ptr %bs.addr, align 8
  %open_flags21 = getelementptr inbounds %struct.BlockDriverState, ptr %25, i32 0, i32 0
  %26 = load i32, ptr %open_flags21, align 8
  %or22 = or i32 %26, 2048
  store i32 %or22, ptr %open_flags21, align 8
  %27 = load i32, ptr %ret, align 4
  store i32 %27, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end23:                                         ; preds = %if.end17
  %28 = load ptr, ptr %bs.addr, align 8
  %call24 = call ptr @bdrv_dirty_bitmap_first(ptr noundef %28)
  store ptr %call24, ptr %bm, align 8
  br label %for.cond25

for.cond25:                                       ; preds = %for.inc28, %if.end23
  %29 = load ptr, ptr %bm, align 8
  %tobool26 = icmp ne ptr %29, null
  br i1 %tobool26, label %for.body27, label %for.end30

for.body27:                                       ; preds = %for.cond25
  %30 = load ptr, ptr %bm, align 8
  call void @bdrv_dirty_bitmap_skip_store(ptr noundef %30, i1 noundef zeroext false)
  br label %for.inc28

for.inc28:                                        ; preds = %for.body27
  %31 = load ptr, ptr %bm, align 8
  %call29 = call ptr @bdrv_dirty_bitmap_next(ptr noundef %31)
  store ptr %call29, ptr %bm, align 8
  br label %for.cond25, !llvm.loop !69

for.end30:                                        ; preds = %for.cond25
  %32 = load ptr, ptr %bs.addr, align 8
  %33 = load ptr, ptr %bs.addr, align 8
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %33, i32 0, i32 37
  %34 = load i64, ptr %total_sectors, align 8
  %call31 = call i32 @bdrv_refresh_total_sectors(ptr noundef %32, i64 noundef %34)
  store i32 %call31, ptr %ret, align 4
  %35 = load i32, ptr %ret, align 4
  %cmp32 = icmp slt i32 %35, 0
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %for.end30
  %36 = load ptr, ptr %bs.addr, align 8
  %open_flags34 = getelementptr inbounds %struct.BlockDriverState, ptr %36, i32 0, i32 0
  %37 = load i32, ptr %open_flags34, align 8
  %or35 = or i32 %37, 2048
  store i32 %or35, ptr %open_flags34, align 8
  %38 = load ptr, ptr %errp.addr, align 8
  %39 = load i32, ptr %ret, align 4
  %sub = sub i32 0, %39
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %38, ptr noundef @.str.2, i32 noundef 6993, ptr noundef @__func__.bdrv_activate, i32 noundef %sub, ptr noundef @.str.102)
  %40 = load i32, ptr %ret, align 4
  store i32 %40, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end36:                                         ; preds = %for.end30
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %for.end
  %41 = load ptr, ptr %bs.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %41, i32 0, i32 32
  %lh_first38 = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %42 = load ptr, ptr %lh_first38, align 8
  store ptr %42, ptr %parent, align 8
  br label %for.cond39

for.cond39:                                       ; preds = %for.inc52, %if.end37
  %43 = load ptr, ptr %parent, align 8
  %tobool40 = icmp ne ptr %43, null
  br i1 %tobool40, label %for.body41, label %for.end54

for.body41:                                       ; preds = %for.cond39
  %44 = load ptr, ptr %parent, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %44, i32 0, i32 2
  %45 = load ptr, ptr %klass, align 8
  %activate = getelementptr inbounds %struct.BdrvChildClass, ptr %45, i32 0, i32 5
  %46 = load ptr, ptr %activate, align 8
  %tobool42 = icmp ne ptr %46, null
  br i1 %tobool42, label %if.then43, label %if.end51

if.then43:                                        ; preds = %for.body41
  %47 = load ptr, ptr %parent, align 8
  %klass44 = getelementptr inbounds %struct.BdrvChild, ptr %47, i32 0, i32 2
  %48 = load ptr, ptr %klass44, align 8
  %activate45 = getelementptr inbounds %struct.BdrvChildClass, ptr %48, i32 0, i32 5
  %49 = load ptr, ptr %activate45, align 8
  %50 = load ptr, ptr %parent, align 8
  call void %49(ptr noundef %50, ptr noundef %local_err)
  %51 = load ptr, ptr %local_err, align 8
  %tobool46 = icmp ne ptr %51, null
  br i1 %tobool46, label %if.then47, label %if.end50

if.then47:                                        ; preds = %if.then43
  %52 = load ptr, ptr %bs.addr, align 8
  %open_flags48 = getelementptr inbounds %struct.BlockDriverState, ptr %52, i32 0, i32 0
  %53 = load i32, ptr %open_flags48, align 8
  %or49 = or i32 %53, 2048
  store i32 %or49, ptr %open_flags48, align 8
  %54 = load ptr, ptr %errp.addr, align 8
  %55 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %54, ptr noundef %55)
  store i32 -22, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end50:                                         ; preds = %if.then43
  br label %if.end51

if.end51:                                         ; preds = %if.end50, %for.body41
  br label %for.inc52

for.inc52:                                        ; preds = %if.end51
  %56 = load ptr, ptr %parent, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %56, i32 0, i32 10
  %le_next53 = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %57 = load ptr, ptr %le_next53, align 8
  store ptr %57, ptr %parent, align 8
  br label %for.cond39, !llvm.loop !70

for.end54:                                        ; preds = %for.cond39
  store i32 0, ptr %retval, align 4
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end54, %if.then47, %if.then33, %if.then20, %if.then15, %if.then8, %if.then2
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto64)
  %58 = load i32, ptr %retval, align 4
  ret i32 %58
}

declare i32 @bdrv_invalidate_cache(ptr noundef, ptr noundef) #2

declare ptr @bdrv_dirty_bitmap_first(ptr noundef) #2

declare void @bdrv_dirty_bitmap_skip_store(ptr noundef, i1 noundef zeroext) #2

declare ptr @bdrv_dirty_bitmap_next(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_co_invalidate_cache(ptr noundef %bs, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 0
  %1 = load i32, ptr %open_flags, align 8
  %and = and i32 %1, 2048
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.end
  br label %if.end

if.else:                                          ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.103, ptr noundef @.str.2, i32 noundef 7017, ptr noundef @__PRETTY_FUNCTION__.bdrv_co_invalidate_cache) #16
  unreachable

if.end:                                           ; preds = %if.then
  call void @assert_bdrv_graph_readable()
  %2 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv, align 8
  %bdrv_co_invalidate_cache = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 82
  %4 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_invalidate_cache, ptr @.str.13, ptr @.str.14, i32 668, ptr null)
  %5 = load ptr, ptr %4, align 8
  %tobool1 = icmp ne ptr %5, null
  br i1 %tobool1, label %if.then2, label %if.end8

if.then2:                                         ; preds = %if.end
  %6 = load ptr, ptr %bs.addr, align 8
  %drv3 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 6
  %7 = load ptr, ptr %drv3, align 8
  %bdrv_co_invalidate_cache4 = getelementptr inbounds %struct.BlockDriver, ptr %7, i32 0, i32 82
  %8 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_invalidate_cache4, ptr @.str.13, ptr @.str.14, i32 668, ptr null)
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %bs.addr, align 8
  call void %9(ptr noundef %10, ptr noundef %local_err)
  %11 = load ptr, ptr %local_err, align 8
  %tobool5 = icmp ne ptr %11, null
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.then2
  %12 = load ptr, ptr %errp.addr, align 8
  %13 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %12, ptr noundef %13)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.then2
  br label %if.end8

if.end8:                                          ; preds = %if.end7, %if.end
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end8, %if.then6
  %14 = load i32, ptr %retval, align 4
  ret i32 %14
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_activate_all(ptr noundef %errp) #0 {
entry:
  %errp.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %it = alloca %struct.BdrvNextIterator, align 8
  %graph_lockable_auto65 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %aio_context = alloca ptr, align 8
  %ret = alloca i32, align 4
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7036, ptr noundef @__PRETTY_FUNCTION__.bdrv_activate_all) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call1, ptr %graph_lockable_auto65, align 8
  %call2 = call ptr @bdrv_first(ptr noundef %it)
  store ptr %call2, ptr %bs, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %0 = load ptr, ptr %bs, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %bs, align 8
  %call3 = call ptr @bdrv_get_aio_context(ptr noundef %1)
  store ptr %call3, ptr %aio_context, align 8
  %2 = load ptr, ptr %aio_context, align 8
  call void @aio_context_acquire(ptr noundef %2)
  %3 = load ptr, ptr %bs, align 8
  %4 = load ptr, ptr %errp.addr, align 8
  %call4 = call i32 @bdrv_activate(ptr noundef %3, ptr noundef %4)
  store i32 %call4, ptr %ret, align 4
  %5 = load ptr, ptr %aio_context, align 8
  call void @aio_context_release(ptr noundef %5)
  %6 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %6, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %for.body
  call void @bdrv_next_cleanup(ptr noundef %it)
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end6:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %call7 = call ptr @bdrv_next(ptr noundef %it)
  store ptr %call7, ptr %bs, align 8
  br label %for.cond, !llvm.loop !71

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then5
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto65)
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

declare ptr @bdrv_first(ptr noundef) #2

declare void @bdrv_next_cleanup(ptr noundef) #2

declare ptr @bdrv_next(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_inactivate_all() #0 {
entry:
  %bs = alloca ptr, align 8
  %it = alloca %struct.BdrvNextIterator, align 8
  %ret = alloca i32, align 4
  %aio_ctxs = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %graph_lockable_auto66 = alloca ptr, align 8
  %.compoundliteral = alloca %struct.GraphLockableMainloop, align 1
  %aio_context = alloca ptr, align 8
  %aio_context26 = alloca ptr, align 8
  store ptr null, ptr %bs, align 8
  store i32 0, ptr %ret, align 4
  store ptr null, ptr %aio_ctxs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7142, ptr noundef @__PRETTY_FUNCTION__.bdrv_inactivate_all) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call1 = call ptr @graph_lockable_auto_lock_mainloop(ptr noundef %.compoundliteral)
  store ptr %call1, ptr %graph_lockable_auto66, align 8
  %call2 = call ptr @bdrv_first(ptr noundef %it)
  store ptr %call2, ptr %bs, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %0 = load ptr, ptr %bs, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %bs, align 8
  %call3 = call ptr @bdrv_get_aio_context(ptr noundef %1)
  store ptr %call3, ptr %aio_context, align 8
  %2 = load ptr, ptr %aio_ctxs, align 8
  %3 = load ptr, ptr %aio_context, align 8
  %call4 = call ptr @g_slist_find(ptr noundef %2, ptr noundef %3)
  %tobool5 = icmp ne ptr %call4, null
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %for.body
  %4 = load ptr, ptr %aio_ctxs, align 8
  %5 = load ptr, ptr %aio_context, align 8
  %call7 = call ptr @g_slist_prepend(ptr noundef %4, ptr noundef %5)
  store ptr %call7, ptr %aio_ctxs, align 8
  %6 = load ptr, ptr %aio_context, align 8
  call void @aio_context_acquire(ptr noundef %6)
  br label %if.end8

if.end8:                                          ; preds = %if.then6, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end8
  %call9 = call ptr @bdrv_next(ptr noundef %it)
  store ptr %call9, ptr %bs, align 8
  br label %for.cond, !llvm.loop !72

for.end:                                          ; preds = %for.cond
  %call10 = call ptr @bdrv_first(ptr noundef %it)
  store ptr %call10, ptr %bs, align 8
  br label %for.cond11

for.cond11:                                       ; preds = %for.inc20, %for.end
  %7 = load ptr, ptr %bs, align 8
  %tobool12 = icmp ne ptr %7, null
  br i1 %tobool12, label %for.body13, label %for.end22

for.body13:                                       ; preds = %for.cond11
  %8 = load ptr, ptr %bs, align 8
  %call14 = call zeroext i1 @bdrv_has_bds_parent(ptr noundef %8, i1 noundef zeroext false)
  br i1 %call14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %for.body13
  br label %for.inc20

if.end16:                                         ; preds = %for.body13
  %9 = load ptr, ptr %bs, align 8
  %call17 = call i32 @bdrv_inactivate_recurse(ptr noundef %9)
  store i32 %call17, ptr %ret, align 4
  %10 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %10, 0
  br i1 %cmp, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end16
  call void @bdrv_next_cleanup(ptr noundef %it)
  br label %out

if.end19:                                         ; preds = %if.end16
  br label %for.inc20

for.inc20:                                        ; preds = %if.end19, %if.then15
  %call21 = call ptr @bdrv_next(ptr noundef %it)
  store ptr %call21, ptr %bs, align 8
  br label %for.cond11, !llvm.loop !73

for.end22:                                        ; preds = %for.cond11
  br label %out

out:                                              ; preds = %for.end22, %if.then18
  %11 = load ptr, ptr %aio_ctxs, align 8
  store ptr %11, ptr %ctx, align 8
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc27, %out
  %12 = load ptr, ptr %ctx, align 8
  %cmp24 = icmp ne ptr %12, null
  br i1 %cmp24, label %for.body25, label %for.end28

for.body25:                                       ; preds = %for.cond23
  %13 = load ptr, ptr %ctx, align 8
  %data = getelementptr inbounds %struct._GSList, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %data, align 8
  store ptr %14, ptr %aio_context26, align 8
  %15 = load ptr, ptr %aio_context26, align 8
  call void @aio_context_release(ptr noundef %15)
  br label %for.inc27

for.inc27:                                        ; preds = %for.body25
  %16 = load ptr, ptr %ctx, align 8
  %next = getelementptr inbounds %struct._GSList, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %next, align 8
  store ptr %17, ptr %ctx, align 8
  br label %for.cond23, !llvm.loop !74

for.end28:                                        ; preds = %for.cond23
  %18 = load ptr, ptr %aio_ctxs, align 8
  call void @g_slist_free(ptr noundef %18)
  %19 = load i32, ptr %ret, align 4
  call void @glib_autoptr_cleanup_GraphLockableMainloop(ptr noundef %graph_lockable_auto66)
  ret i32 %19
}

declare ptr @g_slist_find(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_has_bds_parent(ptr noundef %bs, i1 noundef zeroext %only_active) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %only_active.addr = alloca i8, align 1
  %parent = alloca ptr, align 8
  %parent_bs = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %frombool = zext i1 %only_active to i8
  store i8 %frombool, ptr %only_active.addr, align 1
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7057, ptr noundef @__PRETTY_FUNCTION__.bdrv_has_bds_parent) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %1 = load ptr, ptr %lh_first, align 8
  store ptr %1, ptr %parent, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %2 = load ptr, ptr %parent, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %parent, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %klass, align 8
  %parent_is_bds = getelementptr inbounds %struct.BdrvChildClass, ptr %4, i32 0, i32 1
  %5 = load i8, ptr %parent_is_bds, align 1
  %tobool1 = trunc i8 %5 to i1
  br i1 %tobool1, label %if.then2, label %if.end7

if.then2:                                         ; preds = %for.body
  %6 = load ptr, ptr %parent, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %6, i32 0, i32 4
  %7 = load ptr, ptr %opaque, align 8
  store ptr %7, ptr %parent_bs, align 8
  %8 = load i8, ptr %only_active.addr, align 1
  %tobool3 = trunc i8 %8 to i1
  br i1 %tobool3, label %lor.lhs.false, label %if.then5

lor.lhs.false:                                    ; preds = %if.then2
  %9 = load ptr, ptr %parent_bs, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %open_flags, align 8
  %and = and i32 %10, 2048
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %lor.lhs.false, %if.then2
  store i1 true, ptr %retval, align 1
  br label %return

if.end6:                                          ; preds = %lor.lhs.false
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end7
  %11 = load ptr, ptr %parent, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 10
  %le_next = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %12 = load ptr, ptr %le_next, align 8
  store ptr %12, ptr %parent, align 8
  br label %for.cond, !llvm.loop !75

for.end:                                          ; preds = %for.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then5
  %13 = load i1, ptr %retval, align 1
  ret i1 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_inactivate_recurse(ptr noundef %bs) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %child = alloca ptr, align 8
  %parent = alloca ptr, align 8
  %ret = alloca i32, align 4
  %cumulative_perms = alloca i64, align 8
  %cumulative_shared_perms = alloca i64, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7077, ptr noundef @__PRETTY_FUNCTION__.bdrv_inactivate_recurse) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %do.end
  store i32 -123, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %call3 = call zeroext i1 @bdrv_has_bds_parent(ptr noundef %2, i1 noundef zeroext true)
  br i1 %call3, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end2
  store i32 0, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.end2
  %3 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 0
  %4 = load i32, ptr %open_flags, align 8
  %and = and i32 %4, 2048
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %if.else8, label %if.then7

if.then7:                                         ; preds = %if.end5
  br label %if.end9

if.else8:                                         ; preds = %if.end5
  call void @__assert_fail(ptr noundef @.str.103, ptr noundef @.str.2, i32 noundef 7089, ptr noundef @__PRETTY_FUNCTION__.bdrv_inactivate_recurse) #16
  unreachable

if.end9:                                          ; preds = %if.then7
  %5 = load ptr, ptr %bs.addr, align 8
  %drv10 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %drv10, align 8
  %bdrv_inactivate = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 34
  %7 = load ptr, ptr %bdrv_inactivate, align 8
  %tobool11 = icmp ne ptr %7, null
  br i1 %tobool11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %if.end9
  %8 = load ptr, ptr %bs.addr, align 8
  %drv13 = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 6
  %9 = load ptr, ptr %drv13, align 8
  %bdrv_inactivate14 = getelementptr inbounds %struct.BlockDriver, ptr %9, i32 0, i32 34
  %10 = load ptr, ptr %bdrv_inactivate14, align 8
  %11 = load ptr, ptr %bs.addr, align 8
  %call15 = call i32 %10(ptr noundef %11)
  store i32 %call15, ptr %ret, align 4
  %12 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %12, 0
  br i1 %cmp, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.then12
  %13 = load i32, ptr %ret, align 4
  store i32 %13, ptr %retval, align 4
  br label %return

if.end17:                                         ; preds = %if.then12
  br label %if.end18

if.end18:                                         ; preds = %if.end17, %if.end9
  %14 = load ptr, ptr %bs.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %15 = load ptr, ptr %lh_first, align 8
  store ptr %15, ptr %parent, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end18
  %16 = load ptr, ptr %parent, align 8
  %tobool19 = icmp ne ptr %16, null
  br i1 %tobool19, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load ptr, ptr %parent, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %klass, align 8
  %inactivate = getelementptr inbounds %struct.BdrvChildClass, ptr %18, i32 0, i32 6
  %19 = load ptr, ptr %inactivate, align 8
  %tobool20 = icmp ne ptr %19, null
  br i1 %tobool20, label %if.then21, label %if.end28

if.then21:                                        ; preds = %for.body
  %20 = load ptr, ptr %parent, align 8
  %klass22 = getelementptr inbounds %struct.BdrvChild, ptr %20, i32 0, i32 2
  %21 = load ptr, ptr %klass22, align 8
  %inactivate23 = getelementptr inbounds %struct.BdrvChildClass, ptr %21, i32 0, i32 6
  %22 = load ptr, ptr %inactivate23, align 8
  %23 = load ptr, ptr %parent, align 8
  %call24 = call i32 %22(ptr noundef %23)
  store i32 %call24, ptr %ret, align 4
  %24 = load i32, ptr %ret, align 4
  %cmp25 = icmp slt i32 %24, 0
  br i1 %cmp25, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.then21
  %25 = load i32, ptr %ret, align 4
  store i32 %25, ptr %retval, align 4
  br label %return

if.end27:                                         ; preds = %if.then21
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end28
  %26 = load ptr, ptr %parent, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %26, i32 0, i32 10
  %le_next = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %27 = load ptr, ptr %le_next, align 8
  store ptr %27, ptr %parent, align 8
  br label %for.cond, !llvm.loop !76

for.end:                                          ; preds = %for.cond
  %28 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_get_cumulative_perm(ptr noundef %28, ptr noundef %cumulative_perms, ptr noundef %cumulative_shared_perms)
  %29 = load i64, ptr %cumulative_perms, align 8
  %and29 = and i64 %29, 6
  %tobool30 = icmp ne i64 %and29, 0
  br i1 %tobool30, label %if.then31, label %if.end32

if.then31:                                        ; preds = %for.end
  store i32 -1, ptr %retval, align 4
  br label %return

if.end32:                                         ; preds = %for.end
  %30 = load ptr, ptr %bs.addr, align 8
  %open_flags33 = getelementptr inbounds %struct.BlockDriverState, ptr %30, i32 0, i32 0
  %31 = load i32, ptr %open_flags33, align 8
  %or = or i32 %31, 2048
  store i32 %or, ptr %open_flags33, align 8
  %32 = load ptr, ptr %bs.addr, align 8
  %call34 = call i32 @bdrv_refresh_perms(ptr noundef %32, ptr noundef null, ptr noundef null)
  %33 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %33, i32 0, i32 29
  %lh_first35 = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %34 = load ptr, ptr %lh_first35, align 8
  store ptr %34, ptr %child, align 8
  br label %for.cond36

for.cond36:                                       ; preds = %for.inc44, %if.end32
  %35 = load ptr, ptr %child, align 8
  %tobool37 = icmp ne ptr %35, null
  br i1 %tobool37, label %for.body38, label %for.end46

for.body38:                                       ; preds = %for.cond36
  %36 = load ptr, ptr %child, align 8
  %bs39 = getelementptr inbounds %struct.BdrvChild, ptr %36, i32 0, i32 0
  %37 = load ptr, ptr %bs39, align 8
  %call40 = call i32 @bdrv_inactivate_recurse(ptr noundef %37)
  store i32 %call40, ptr %ret, align 4
  %38 = load i32, ptr %ret, align 4
  %cmp41 = icmp slt i32 %38, 0
  br i1 %cmp41, label %if.then42, label %if.end43

if.then42:                                        ; preds = %for.body38
  %39 = load i32, ptr %ret, align 4
  store i32 %39, ptr %retval, align 4
  br label %return

if.end43:                                         ; preds = %for.body38
  br label %for.inc44

for.inc44:                                        ; preds = %if.end43
  %40 = load ptr, ptr %child, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %40, i32 0, i32 9
  %le_next45 = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %41 = load ptr, ptr %le_next45, align 8
  store ptr %41, ptr %child, align 8
  br label %for.cond36, !llvm.loop !77

for.end46:                                        ; preds = %for.cond36
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end46, %if.then42, %if.then31, %if.then26, %if.then16, %if.then4, %if.then1
  %42 = load i32, ptr %retval, align 4
  ret i32 %42
}

declare void @g_slist_free(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_co_is_inserted(ptr noundef %bs) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %child = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  call void @assert_bdrv_graph_readable()
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %do.end
  %3 = load ptr, ptr %drv, align 8
  %bdrv_co_is_inserted = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 101
  %4 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_is_inserted, ptr @.str.13, ptr @.str.14, i32 754, ptr null)
  %5 = load ptr, ptr %4, align 8
  %tobool2 = icmp ne ptr %5, null
  br i1 %tobool2, label %if.then3, label %if.end5

if.then3:                                         ; preds = %if.end
  %6 = load ptr, ptr %drv, align 8
  %bdrv_co_is_inserted4 = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 101
  %7 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_is_inserted4, ptr @.str.13, ptr @.str.14, i32 754, ptr null)
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %bs.addr, align 8
  %call = call zeroext i1 %8(ptr noundef %9)
  store i1 %call, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.end
  %10 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %11 = load ptr, ptr %lh_first, align 8
  store ptr %11, ptr %child, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %12 = load ptr, ptr %child, align 8
  %tobool6 = icmp ne ptr %12, null
  br i1 %tobool6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load ptr, ptr %child, align 8
  %bs7 = getelementptr inbounds %struct.BdrvChild, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %bs7, align 8
  %call8 = call zeroext i1 @bdrv_co_is_inserted(ptr noundef %14)
  br i1 %call8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %for.body
  store i1 false, ptr %retval, align 1
  br label %return

if.end10:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end10
  %15 = load ptr, ptr %child, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %15, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %16 = load ptr, ptr %le_next, align 8
  store ptr %16, ptr %child, align 8
  br label %for.cond, !llvm.loop !78

for.end:                                          ; preds = %for.cond
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then9, %if.then3, %if.then
  %17 = load i1, ptr %retval, align 1
  ret i1 %17
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_eject(ptr noundef %bs, i1 noundef zeroext %eject_flag) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %eject_flag.addr = alloca i8, align 1
  %drv = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %frombool = zext i1 %eject_flag to i8
  store i8 %frombool, ptr %eject_flag.addr, align 1
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  call void @assert_bdrv_graph_readable()
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %do.end
  %3 = load ptr, ptr %drv, align 8
  %bdrv_co_eject = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 102
  %4 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_eject, ptr @.str.13, ptr @.str.14, i32 756, ptr null)
  %5 = load ptr, ptr %4, align 8
  %tobool2 = icmp ne ptr %5, null
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %6 = load ptr, ptr %drv, align 8
  %bdrv_co_eject3 = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 102
  %7 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_eject3, ptr @.str.13, ptr @.str.14, i32 756, ptr null)
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %bs.addr, align 8
  %10 = load i8, ptr %eject_flag.addr, align 1
  %tobool4 = trunc i8 %10 to i1
  call void %8(ptr noundef %9, i1 noundef zeroext %tobool4)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_lock_medium(ptr noundef %bs, i1 noundef zeroext %locked) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %locked.addr = alloca i8, align 1
  %drv = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %frombool = zext i1 %locked to i8
  store i8 %frombool, ptr %locked.addr, align 1
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  call void @assert_bdrv_graph_readable()
  %2 = load ptr, ptr %bs.addr, align 8
  %3 = load i8, ptr %locked.addr, align 1
  %tobool = trunc i8 %3 to i1
  call void @trace_bdrv_lock_medium(ptr noundef %2, i1 noundef zeroext %tobool)
  %4 = load ptr, ptr %drv, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %do.end
  %5 = load ptr, ptr %drv, align 8
  %bdrv_co_lock_medium = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 103
  %6 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_lock_medium, ptr @.str.13, ptr @.str.14, i32 758, ptr null)
  %7 = load ptr, ptr %6, align 8
  %tobool3 = icmp ne ptr %7, null
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load ptr, ptr %drv, align 8
  %bdrv_co_lock_medium4 = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 103
  %9 = call ptr @llvm.ptr.annotation.p0.p0(ptr %bdrv_co_lock_medium4, ptr @.str.13, ptr @.str.14, i32 758, ptr null)
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %bs.addr, align 8
  %12 = load i8, ptr %locked.addr, align 1
  %tobool5 = trunc i8 %12 to i1
  call void %10(ptr noundef %11, i1 noundef zeroext %tobool5)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %do.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_bdrv_lock_medium(ptr noundef %bs, i1 noundef zeroext %locked) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %locked.addr = alloca i8, align 1
  store ptr %bs, ptr %bs.addr, align 8
  %frombool = zext i1 %locked to i8
  store i8 %frombool, ptr %locked.addr, align 1
  %0 = load ptr, ptr %bs.addr, align 8
  %1 = load i8, ptr %locked.addr, align 1
  %tobool = trunc i8 %1 to i1
  call void @_nocheck__trace_bdrv_lock_medium(ptr noundef %0, i1 noundef zeroext %tobool)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_delete(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call zeroext i1 @bdrv_op_blocker_is_empty(ptr noundef %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.284, ptr noundef @.str.2, i32 noundef 5644, ptr noundef @__PRETTY_FUNCTION__.bdrv_delete) #16
  unreachable

if.end:                                           ; preds = %if.then
  %1 = load ptr, ptr %bs.addr, align 8
  %refcnt = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 26
  %2 = load i32, ptr %refcnt, align 8
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.else2, label %if.then1

if.then1:                                         ; preds = %if.end
  br label %if.end3

if.else2:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.285, ptr noundef @.str.2, i32 noundef 5645, ptr noundef @__PRETTY_FUNCTION__.bdrv_delete) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  br label %do.body

do.body:                                          ; preds = %if.end3
  %call4 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call4, label %if.then5, label %if.else6

if.then5:                                         ; preds = %do.body
  br label %if.end7

if.else6:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5646, ptr noundef @__PRETTY_FUNCTION__.bdrv_delete) #16
  unreachable

if.end7:                                          ; preds = %if.then5
  br label %do.end

do.end:                                           ; preds = %if.end7
  %3 = load ptr, ptr %bs.addr, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 22
  %arrayidx = getelementptr [32 x i8], ptr %node_name, i64 0, i64 0
  %4 = load i8, ptr %arrayidx, align 8
  %conv = sext i8 %4 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then9, label %if.end31

if.then9:                                         ; preds = %do.end
  br label %do.body10

do.body10:                                        ; preds = %if.then9
  %5 = load ptr, ptr %bs.addr, align 8
  %node_list = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 23
  %6 = load ptr, ptr %node_list, align 8
  %cmp11 = icmp ne ptr %6, null
  br i1 %cmp11, label %if.then13, label %if.else18

if.then13:                                        ; preds = %do.body10
  %7 = load ptr, ptr %bs.addr, align 8
  %node_list14 = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 23
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %node_list14, i32 0, i32 1
  %8 = load ptr, ptr %tql_prev, align 8
  %9 = load ptr, ptr %bs.addr, align 8
  %node_list15 = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 23
  %10 = load ptr, ptr %node_list15, align 8
  %node_list16 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 23
  %tql_prev17 = getelementptr inbounds %struct.QTailQLink, ptr %node_list16, i32 0, i32 1
  store ptr %8, ptr %tql_prev17, align 8
  br label %if.end21

if.else18:                                        ; preds = %do.body10
  %11 = load ptr, ptr %bs.addr, align 8
  %node_list19 = getelementptr inbounds %struct.BlockDriverState, ptr %11, i32 0, i32 23
  %tql_prev20 = getelementptr inbounds %struct.QTailQLink, ptr %node_list19, i32 0, i32 1
  %12 = load ptr, ptr %tql_prev20, align 8
  store ptr %12, ptr getelementptr inbounds (%struct.QTailQLink, ptr @graph_bdrv_states, i32 0, i32 1), align 8
  br label %if.end21

if.end21:                                         ; preds = %if.else18, %if.then13
  %13 = load ptr, ptr %bs.addr, align 8
  %node_list22 = getelementptr inbounds %struct.BlockDriverState, ptr %13, i32 0, i32 23
  %14 = load ptr, ptr %node_list22, align 8
  %15 = load ptr, ptr %bs.addr, align 8
  %node_list23 = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 23
  %tql_prev24 = getelementptr inbounds %struct.QTailQLink, ptr %node_list23, i32 0, i32 1
  %16 = load ptr, ptr %tql_prev24, align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %16, i32 0, i32 0
  store ptr %14, ptr %tql_next, align 8
  %17 = load ptr, ptr %bs.addr, align 8
  %node_list25 = getelementptr inbounds %struct.BlockDriverState, ptr %17, i32 0, i32 23
  %tql_prev26 = getelementptr inbounds %struct.QTailQLink, ptr %node_list25, i32 0, i32 1
  store ptr null, ptr %tql_prev26, align 8
  %18 = load ptr, ptr %bs.addr, align 8
  %node_list27 = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 23
  %tql_next28 = getelementptr inbounds %struct.QTailQLink, ptr %node_list27, i32 0, i32 0
  store ptr null, ptr %tql_next28, align 8
  %19 = load ptr, ptr %bs.addr, align 8
  %node_list29 = getelementptr inbounds %struct.BlockDriverState, ptr %19, i32 0, i32 23
  store ptr null, ptr %node_list29, align 8
  br label %do.end30

do.end30:                                         ; preds = %if.end21
  br label %if.end31

if.end31:                                         ; preds = %do.end30, %do.end
  br label %do.body32

do.body32:                                        ; preds = %if.end31
  %20 = load ptr, ptr %bs.addr, align 8
  %bs_list = getelementptr inbounds %struct.BlockDriverState, ptr %20, i32 0, i32 24
  %21 = load ptr, ptr %bs_list, align 8
  %cmp33 = icmp ne ptr %21, null
  br i1 %cmp33, label %if.then35, label %if.else41

if.then35:                                        ; preds = %do.body32
  %22 = load ptr, ptr %bs.addr, align 8
  %bs_list36 = getelementptr inbounds %struct.BlockDriverState, ptr %22, i32 0, i32 24
  %tql_prev37 = getelementptr inbounds %struct.QTailQLink, ptr %bs_list36, i32 0, i32 1
  %23 = load ptr, ptr %tql_prev37, align 8
  %24 = load ptr, ptr %bs.addr, align 8
  %bs_list38 = getelementptr inbounds %struct.BlockDriverState, ptr %24, i32 0, i32 24
  %25 = load ptr, ptr %bs_list38, align 8
  %bs_list39 = getelementptr inbounds %struct.BlockDriverState, ptr %25, i32 0, i32 24
  %tql_prev40 = getelementptr inbounds %struct.QTailQLink, ptr %bs_list39, i32 0, i32 1
  store ptr %23, ptr %tql_prev40, align 8
  br label %if.end44

if.else41:                                        ; preds = %do.body32
  %26 = load ptr, ptr %bs.addr, align 8
  %bs_list42 = getelementptr inbounds %struct.BlockDriverState, ptr %26, i32 0, i32 24
  %tql_prev43 = getelementptr inbounds %struct.QTailQLink, ptr %bs_list42, i32 0, i32 1
  %27 = load ptr, ptr %tql_prev43, align 8
  store ptr %27, ptr getelementptr inbounds (%struct.QTailQLink, ptr @all_bdrv_states, i32 0, i32 1), align 8
  br label %if.end44

if.end44:                                         ; preds = %if.else41, %if.then35
  %28 = load ptr, ptr %bs.addr, align 8
  %bs_list45 = getelementptr inbounds %struct.BlockDriverState, ptr %28, i32 0, i32 24
  %29 = load ptr, ptr %bs_list45, align 8
  %30 = load ptr, ptr %bs.addr, align 8
  %bs_list46 = getelementptr inbounds %struct.BlockDriverState, ptr %30, i32 0, i32 24
  %tql_prev47 = getelementptr inbounds %struct.QTailQLink, ptr %bs_list46, i32 0, i32 1
  %31 = load ptr, ptr %tql_prev47, align 8
  %tql_next48 = getelementptr inbounds %struct.QTailQLink, ptr %31, i32 0, i32 0
  store ptr %29, ptr %tql_next48, align 8
  %32 = load ptr, ptr %bs.addr, align 8
  %bs_list49 = getelementptr inbounds %struct.BlockDriverState, ptr %32, i32 0, i32 24
  %tql_prev50 = getelementptr inbounds %struct.QTailQLink, ptr %bs_list49, i32 0, i32 1
  store ptr null, ptr %tql_prev50, align 8
  %33 = load ptr, ptr %bs.addr, align 8
  %bs_list51 = getelementptr inbounds %struct.BlockDriverState, ptr %33, i32 0, i32 24
  %tql_next52 = getelementptr inbounds %struct.QTailQLink, ptr %bs_list51, i32 0, i32 0
  store ptr null, ptr %tql_next52, align 8
  %34 = load ptr, ptr %bs.addr, align 8
  %bs_list53 = getelementptr inbounds %struct.BlockDriverState, ptr %34, i32 0, i32 24
  store ptr null, ptr %bs_list53, align 8
  br label %do.end54

do.end54:                                         ; preds = %if.end44
  %35 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_close(ptr noundef %35)
  %36 = load ptr, ptr %bs.addr, align 8
  %reqs_lock = getelementptr inbounds %struct.BlockDriverState, ptr %36, i32 0, i32 48
  call void @qemu_mutex_destroy(ptr noundef %reqs_lock)
  %37 = load ptr, ptr %bs.addr, align 8
  call void @g_free(ptr noundef %37)
  ret void
}

declare void @aio_bh_schedule_oneshot_full(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_schedule_unref_bh(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %bs, align 8
  %1 = load ptr, ptr %bs, align 8
  %call = call ptr @bdrv_get_aio_context(ptr noundef %1)
  store ptr %call, ptr %ctx, align 8
  %2 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %2)
  %3 = load ptr, ptr %bs, align 8
  call void @bdrv_unref(ptr noundef %3)
  %4 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_op_is_blocked(ptr noundef %bs, i32 noundef %op, ptr noundef %errp) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %op.addr = alloca i32, align 4
  %errp.addr = alloca ptr, align 8
  %blocker = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store i32 %op, ptr %op.addr, align 4
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7291, ptr noundef @__PRETTY_FUNCTION__.bdrv_op_is_blocked) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load i32, ptr %op.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else3

land.lhs.true:                                    ; preds = %do.end
  %1 = load i32, ptr %op.addr, align 4
  %cmp1 = icmp ult i32 %1, 16
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %land.lhs.true
  br label %if.end4

if.else3:                                         ; preds = %land.lhs.true, %do.end
  call void @__assert_fail(ptr noundef @.str.106, ptr noundef @.str.2, i32 noundef 7293, ptr noundef @__PRETTY_FUNCTION__.bdrv_op_is_blocked) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  %2 = load ptr, ptr %bs.addr, align 8
  %op_blockers = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 27
  %3 = load i32, ptr %op.addr, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [16 x %struct.anon.2], ptr %op_blockers, i64 0, i64 %idxprom
  %lh_first = getelementptr inbounds %struct.anon.2, ptr %arrayidx, i32 0, i32 0
  %4 = load ptr, ptr %lh_first, align 8
  %cmp5 = icmp eq ptr %4, null
  br i1 %cmp5, label %if.end13, label %if.then6

if.then6:                                         ; preds = %if.end4
  %5 = load ptr, ptr %bs.addr, align 8
  %op_blockers7 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 27
  %6 = load i32, ptr %op.addr, align 4
  %idxprom8 = zext i32 %6 to i64
  %arrayidx9 = getelementptr [16 x %struct.anon.2], ptr %op_blockers7, i64 0, i64 %idxprom8
  %lh_first10 = getelementptr inbounds %struct.anon.2, ptr %arrayidx9, i32 0, i32 0
  %7 = load ptr, ptr %lh_first10, align 8
  store ptr %7, ptr %blocker, align 8
  %8 = load ptr, ptr %errp.addr, align 8
  %9 = load ptr, ptr %blocker, align 8
  %reason = getelementptr inbounds %struct.BdrvOpBlocker, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %reason, align 8
  %call11 = call ptr @error_copy(ptr noundef %10)
  %11 = load ptr, ptr %bs.addr, align 8
  %call12 = call ptr @bdrv_get_device_or_node_name(ptr noundef %11)
  call void (ptr, ptr, ptr, ...) @error_propagate_prepend(ptr noundef %8, ptr noundef %call11, ptr noundef @.str.107, ptr noundef %call12)
  store i1 true, ptr %retval, align 1
  br label %return

if.end13:                                         ; preds = %if.end4
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end13, %if.then6
  %12 = load i1, ptr %retval, align 1
  ret i1 %12
}

declare void @error_propagate_prepend(ptr noundef, ptr noundef, ptr noundef, ...) #2

declare ptr @error_copy(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_op_block(ptr noundef %bs, i32 noundef %op, ptr noundef %reason) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %op.addr = alloca i32, align 4
  %reason.addr = alloca ptr, align 8
  %blocker = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store i32 %op, ptr %op.addr, align 4
  store ptr %reason, ptr %reason.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7307, ptr noundef @__PRETTY_FUNCTION__.bdrv_op_block) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load i32, ptr %op.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else3

land.lhs.true:                                    ; preds = %do.end
  %1 = load i32, ptr %op.addr, align 4
  %cmp1 = icmp ult i32 %1, 16
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %land.lhs.true
  br label %if.end4

if.else3:                                         ; preds = %land.lhs.true, %do.end
  call void @__assert_fail(ptr noundef @.str.106, ptr noundef @.str.2, i32 noundef 7308, ptr noundef @__PRETTY_FUNCTION__.bdrv_op_block) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  %call5 = call noalias ptr @g_malloc0_n(i64 noundef 1, i64 noundef 24) #17
  store ptr %call5, ptr %blocker, align 8
  %2 = load ptr, ptr %reason.addr, align 8
  %3 = load ptr, ptr %blocker, align 8
  %reason6 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %3, i32 0, i32 0
  store ptr %2, ptr %reason6, align 8
  br label %do.body7

do.body7:                                         ; preds = %if.end4
  %4 = load ptr, ptr %bs.addr, align 8
  %op_blockers = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 27
  %5 = load i32, ptr %op.addr, align 4
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr [16 x %struct.anon.2], ptr %op_blockers, i64 0, i64 %idxprom
  %lh_first = getelementptr inbounds %struct.anon.2, ptr %arrayidx, i32 0, i32 0
  %6 = load ptr, ptr %lh_first, align 8
  %7 = load ptr, ptr %blocker, align 8
  %list = getelementptr inbounds %struct.BdrvOpBlocker, ptr %7, i32 0, i32 1
  %le_next = getelementptr inbounds %struct.anon.25, ptr %list, i32 0, i32 0
  store ptr %6, ptr %le_next, align 8
  %cmp8 = icmp ne ptr %6, null
  br i1 %cmp8, label %if.then9, label %if.end17

if.then9:                                         ; preds = %do.body7
  %8 = load ptr, ptr %blocker, align 8
  %list10 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %8, i32 0, i32 1
  %le_next11 = getelementptr inbounds %struct.anon.25, ptr %list10, i32 0, i32 0
  %9 = load ptr, ptr %bs.addr, align 8
  %op_blockers12 = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 27
  %10 = load i32, ptr %op.addr, align 4
  %idxprom13 = zext i32 %10 to i64
  %arrayidx14 = getelementptr [16 x %struct.anon.2], ptr %op_blockers12, i64 0, i64 %idxprom13
  %lh_first15 = getelementptr inbounds %struct.anon.2, ptr %arrayidx14, i32 0, i32 0
  %11 = load ptr, ptr %lh_first15, align 8
  %list16 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %11, i32 0, i32 1
  %le_prev = getelementptr inbounds %struct.anon.25, ptr %list16, i32 0, i32 1
  store ptr %le_next11, ptr %le_prev, align 8
  br label %if.end17

if.end17:                                         ; preds = %if.then9, %do.body7
  %12 = load ptr, ptr %blocker, align 8
  %13 = load ptr, ptr %bs.addr, align 8
  %op_blockers18 = getelementptr inbounds %struct.BlockDriverState, ptr %13, i32 0, i32 27
  %14 = load i32, ptr %op.addr, align 4
  %idxprom19 = zext i32 %14 to i64
  %arrayidx20 = getelementptr [16 x %struct.anon.2], ptr %op_blockers18, i64 0, i64 %idxprom19
  %lh_first21 = getelementptr inbounds %struct.anon.2, ptr %arrayidx20, i32 0, i32 0
  store ptr %12, ptr %lh_first21, align 8
  %15 = load ptr, ptr %bs.addr, align 8
  %op_blockers22 = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 27
  %16 = load i32, ptr %op.addr, align 4
  %idxprom23 = zext i32 %16 to i64
  %arrayidx24 = getelementptr [16 x %struct.anon.2], ptr %op_blockers22, i64 0, i64 %idxprom23
  %lh_first25 = getelementptr inbounds %struct.anon.2, ptr %arrayidx24, i32 0, i32 0
  %17 = load ptr, ptr %blocker, align 8
  %list26 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %17, i32 0, i32 1
  %le_prev27 = getelementptr inbounds %struct.anon.25, ptr %list26, i32 0, i32 1
  store ptr %lh_first25, ptr %le_prev27, align 8
  br label %do.end28

do.end28:                                         ; preds = %if.end17
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_op_unblock(ptr noundef %bs, i32 noundef %op, ptr noundef %reason) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %op.addr = alloca i32, align 4
  %reason.addr = alloca ptr, align 8
  %blocker = alloca ptr, align 8
  %next = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store i32 %op, ptr %op.addr, align 4
  store ptr %reason, ptr %reason.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7318, ptr noundef @__PRETTY_FUNCTION__.bdrv_op_unblock) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load i32, ptr %op.addr, align 4
  %cmp = icmp sge i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else3

land.lhs.true:                                    ; preds = %do.end
  %1 = load i32, ptr %op.addr, align 4
  %cmp1 = icmp ult i32 %1, 16
  br i1 %cmp1, label %if.then2, label %if.else3

if.then2:                                         ; preds = %land.lhs.true
  br label %if.end4

if.else3:                                         ; preds = %land.lhs.true, %do.end
  call void @__assert_fail(ptr noundef @.str.106, ptr noundef @.str.2, i32 noundef 7319, ptr noundef @__PRETTY_FUNCTION__.bdrv_op_unblock) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  %2 = load ptr, ptr %bs.addr, align 8
  %op_blockers = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 27
  %3 = load i32, ptr %op.addr, align 4
  %idxprom = zext i32 %3 to i64
  %arrayidx = getelementptr [16 x %struct.anon.2], ptr %op_blockers, i64 0, i64 %idxprom
  %lh_first = getelementptr inbounds %struct.anon.2, ptr %arrayidx, i32 0, i32 0
  %4 = load ptr, ptr %lh_first, align 8
  store ptr %4, ptr %blocker, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end4
  %5 = load ptr, ptr %blocker, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %6 = load ptr, ptr %blocker, align 8
  %list = getelementptr inbounds %struct.BdrvOpBlocker, ptr %6, i32 0, i32 1
  %le_next = getelementptr inbounds %struct.anon.25, ptr %list, i32 0, i32 0
  %7 = load ptr, ptr %le_next, align 8
  store ptr %7, ptr %next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %8 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %8, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %9 = load ptr, ptr %blocker, align 8
  %reason5 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %reason5, align 8
  %11 = load ptr, ptr %reason.addr, align 8
  %cmp6 = icmp eq ptr %10, %11
  br i1 %cmp6, label %if.then7, label %if.end28

if.then7:                                         ; preds = %for.body
  br label %do.body8

do.body8:                                         ; preds = %if.then7
  %12 = load ptr, ptr %blocker, align 8
  %list9 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %12, i32 0, i32 1
  %le_next10 = getelementptr inbounds %struct.anon.25, ptr %list9, i32 0, i32 0
  %13 = load ptr, ptr %le_next10, align 8
  %cmp11 = icmp ne ptr %13, null
  br i1 %cmp11, label %if.then12, label %if.end18

if.then12:                                        ; preds = %do.body8
  %14 = load ptr, ptr %blocker, align 8
  %list13 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %14, i32 0, i32 1
  %le_prev = getelementptr inbounds %struct.anon.25, ptr %list13, i32 0, i32 1
  %15 = load ptr, ptr %le_prev, align 8
  %16 = load ptr, ptr %blocker, align 8
  %list14 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %16, i32 0, i32 1
  %le_next15 = getelementptr inbounds %struct.anon.25, ptr %list14, i32 0, i32 0
  %17 = load ptr, ptr %le_next15, align 8
  %list16 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %17, i32 0, i32 1
  %le_prev17 = getelementptr inbounds %struct.anon.25, ptr %list16, i32 0, i32 1
  store ptr %15, ptr %le_prev17, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then12, %do.body8
  %18 = load ptr, ptr %blocker, align 8
  %list19 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %18, i32 0, i32 1
  %le_next20 = getelementptr inbounds %struct.anon.25, ptr %list19, i32 0, i32 0
  %19 = load ptr, ptr %le_next20, align 8
  %20 = load ptr, ptr %blocker, align 8
  %list21 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %20, i32 0, i32 1
  %le_prev22 = getelementptr inbounds %struct.anon.25, ptr %list21, i32 0, i32 1
  %21 = load ptr, ptr %le_prev22, align 8
  store ptr %19, ptr %21, align 8
  %22 = load ptr, ptr %blocker, align 8
  %list23 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %22, i32 0, i32 1
  %le_next24 = getelementptr inbounds %struct.anon.25, ptr %list23, i32 0, i32 0
  store ptr null, ptr %le_next24, align 8
  %23 = load ptr, ptr %blocker, align 8
  %list25 = getelementptr inbounds %struct.BdrvOpBlocker, ptr %23, i32 0, i32 1
  %le_prev26 = getelementptr inbounds %struct.anon.25, ptr %list25, i32 0, i32 1
  store ptr null, ptr %le_prev26, align 8
  br label %do.end27

do.end27:                                         ; preds = %if.end18
  %24 = load ptr, ptr %blocker, align 8
  call void @g_free(ptr noundef %24)
  br label %if.end28

if.end28:                                         ; preds = %do.end27, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end28
  %25 = load ptr, ptr %next, align 8
  store ptr %25, ptr %blocker, align 8
  br label %for.cond, !llvm.loop !79

for.end:                                          ; preds = %land.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_op_block_all(ptr noundef %bs, ptr noundef %reason) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %reason.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %reason, ptr %reason.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7331, ptr noundef @__PRETTY_FUNCTION__.bdrv_op_block_all) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %bs.addr, align 8
  %2 = load i32, ptr %i, align 4
  %3 = load ptr, ptr %reason.addr, align 8
  call void @bdrv_op_block(ptr noundef %1, i32 noundef %2, ptr noundef %3)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, ptr %i, align 4
  %inc = add i32 %4, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !80

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_op_unblock_all(ptr noundef %bs, ptr noundef %reason) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %reason.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %reason, ptr %reason.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7340, ptr noundef @__PRETTY_FUNCTION__.bdrv_op_unblock_all) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %bs.addr, align 8
  %2 = load i32, ptr %i, align 4
  %3 = load ptr, ptr %reason.addr, align 8
  call void @bdrv_op_unblock(ptr noundef %1, i32 noundef %2, ptr noundef %3)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, ptr %i, align 4
  %inc = add i32 %4, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !81

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_op_blocker_is_empty(ptr noundef %bs) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7349, ptr noundef @__PRETTY_FUNCTION__.bdrv_op_blocker_is_empty) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %0 = load i32, ptr %i, align 4
  %cmp = icmp slt i32 %0, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %bs.addr, align 8
  %op_blockers = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 27
  %2 = load i32, ptr %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr [16 x %struct.anon.2], ptr %op_blockers, i64 0, i64 %idxprom
  %lh_first = getelementptr inbounds %struct.anon.2, ptr %arrayidx, i32 0, i32 0
  %3 = load ptr, ptr %lh_first, align 8
  %cmp1 = icmp eq ptr %3, null
  br i1 %cmp1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %for.body
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end3
  %4 = load i32, ptr %i, align 4
  %inc = add i32 %4, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !82

for.end:                                          ; preds = %for.cond
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then2
  %5 = load i1, ptr %retval, align 1
  ret i1 %5
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_img_create(ptr noundef %filename, ptr noundef %fmt, ptr noundef %base_filename, ptr noundef %base_fmt, ptr noundef %options, i64 noundef %img_size, i32 noundef %flags, i1 noundef zeroext %quiet, ptr noundef %errp) #0 {
entry:
  %filename.addr = alloca ptr, align 8
  %fmt.addr = alloca ptr, align 8
  %base_filename.addr = alloca ptr, align 8
  %base_fmt.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %img_size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  %quiet.addr = alloca i8, align 1
  %errp.addr = alloca ptr, align 8
  %create_opts = alloca ptr, align 8
  %opts = alloca ptr, align 8
  %backing_fmt = alloca ptr, align 8
  %backing_file = alloca ptr, align 8
  %size = alloca i64, align 8
  %drv = alloca ptr, align 8
  %proto_drv = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %ret = alloca i32, align 4
  %bs = alloca ptr, align 8
  %full_backing = alloca ptr, align 8
  %back_flags = alloca i32, align 4
  %backing_options = alloca ptr, align 8
  %cluster_size_hint = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %fmt, ptr %fmt.addr, align 8
  store ptr %base_filename, ptr %base_filename.addr, align 8
  store ptr %base_fmt, ptr %base_fmt.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store i64 %img_size, ptr %img_size.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %frombool = zext i1 %quiet to i8
  store i8 %frombool, ptr %quiet.addr, align 1
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %create_opts, align 8
  store ptr null, ptr %opts, align 8
  store ptr null, ptr %local_err, align 8
  store i32 0, ptr %ret, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7375, ptr noundef @__PRETTY_FUNCTION__.bdrv_img_create) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %fmt.addr, align 8
  %call1 = call ptr @bdrv_find_format(ptr noundef %0)
  store ptr %call1, ptr %drv, align 8
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %do.end
  %2 = load ptr, ptr %errp.addr, align 8
  %3 = load ptr, ptr %fmt.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %2, ptr noundef @.str.2, i32 noundef 7380, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.108, ptr noundef %3)
  br label %return

if.end3:                                          ; preds = %do.end
  %4 = load ptr, ptr %filename.addr, align 8
  %5 = load ptr, ptr %errp.addr, align 8
  %call4 = call ptr @bdrv_find_protocol(ptr noundef %4, i1 noundef zeroext true, ptr noundef %5)
  store ptr %call4, ptr %proto_drv, align 8
  %6 = load ptr, ptr %proto_drv, align 8
  %tobool5 = icmp ne ptr %6, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end3
  br label %return

if.end7:                                          ; preds = %if.end3
  %7 = load ptr, ptr %drv, align 8
  %create_opts8 = getelementptr inbounds %struct.BlockDriver, ptr %7, i32 0, i32 9
  %8 = load ptr, ptr %create_opts8, align 8
  %tobool9 = icmp ne ptr %8, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end7
  %9 = load ptr, ptr %errp.addr, align 8
  %10 = load ptr, ptr %drv, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %10, i32 0, i32 0
  %11 = load ptr, ptr %format_name, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %9, ptr noundef @.str.2, i32 noundef 7391, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.109, ptr noundef %11)
  br label %return

if.end11:                                         ; preds = %if.end7
  %12 = load ptr, ptr %proto_drv, align 8
  %create_opts12 = getelementptr inbounds %struct.BlockDriver, ptr %12, i32 0, i32 9
  %13 = load ptr, ptr %create_opts12, align 8
  %tobool13 = icmp ne ptr %13, null
  br i1 %tobool13, label %if.end16, label %if.then14

if.then14:                                        ; preds = %if.end11
  %14 = load ptr, ptr %errp.addr, align 8
  %15 = load ptr, ptr %proto_drv, align 8
  %format_name15 = getelementptr inbounds %struct.BlockDriver, ptr %15, i32 0, i32 0
  %16 = load ptr, ptr %format_name15, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %14, ptr noundef @.str.2, i32 noundef 7397, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.110, ptr noundef %16)
  br label %return

if.end16:                                         ; preds = %if.end11
  %call17 = call ptr @qemu_get_aio_context()
  call void @aio_context_acquire(ptr noundef %call17)
  %17 = load ptr, ptr %create_opts, align 8
  %18 = load ptr, ptr %drv, align 8
  %create_opts18 = getelementptr inbounds %struct.BlockDriver, ptr %18, i32 0, i32 9
  %19 = load ptr, ptr %create_opts18, align 8
  %call19 = call ptr @qemu_opts_append(ptr noundef %17, ptr noundef %19)
  store ptr %call19, ptr %create_opts, align 8
  %20 = load ptr, ptr %create_opts, align 8
  %21 = load ptr, ptr %proto_drv, align 8
  %create_opts20 = getelementptr inbounds %struct.BlockDriver, ptr %21, i32 0, i32 9
  %22 = load ptr, ptr %create_opts20, align 8
  %call21 = call ptr @qemu_opts_append(ptr noundef %20, ptr noundef %22)
  store ptr %call21, ptr %create_opts, align 8
  %23 = load ptr, ptr %create_opts, align 8
  %call22 = call ptr @qemu_opts_create(ptr noundef %23, ptr noundef null, i32 noundef 0, ptr noundef @error_abort)
  store ptr %call22, ptr %opts, align 8
  %24 = load ptr, ptr %options.addr, align 8
  %tobool23 = icmp ne ptr %24, null
  br i1 %tobool23, label %if.then24, label %if.end28

if.then24:                                        ; preds = %if.end16
  %25 = load ptr, ptr %opts, align 8
  %26 = load ptr, ptr %options.addr, align 8
  %27 = load ptr, ptr %errp.addr, align 8
  %call25 = call zeroext i1 @qemu_opts_do_parse(ptr noundef %25, ptr noundef %26, ptr noundef null, ptr noundef %27)
  br i1 %call25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %if.then24
  br label %out

if.end27:                                         ; preds = %if.then24
  br label %if.end28

if.end28:                                         ; preds = %if.end27, %if.end16
  %28 = load ptr, ptr %opts, align 8
  %call29 = call ptr @qemu_opt_get(ptr noundef %28, ptr noundef @.str.17)
  %tobool30 = icmp ne ptr %call29, null
  br i1 %tobool30, label %if.else33, label %if.then31

if.then31:                                        ; preds = %if.end28
  %29 = load ptr, ptr %opts, align 8
  %30 = load i64, ptr %img_size.addr, align 8
  %call32 = call zeroext i1 @qemu_opt_set_number(ptr noundef %29, ptr noundef @.str.17, i64 noundef %30, ptr noundef @error_abort)
  br label %if.end36

if.else33:                                        ; preds = %if.end28
  %31 = load i64, ptr %img_size.addr, align 8
  %cmp = icmp ne i64 %31, -1
  br i1 %cmp, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.else33
  %32 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %32, ptr noundef @.str.2, i32 noundef 7419, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.111)
  br label %out

if.end35:                                         ; preds = %if.else33
  br label %if.end36

if.end36:                                         ; preds = %if.end35, %if.then31
  %33 = load ptr, ptr %base_filename.addr, align 8
  %tobool37 = icmp ne ptr %33, null
  br i1 %tobool37, label %if.then38, label %if.end42

if.then38:                                        ; preds = %if.end36
  %34 = load ptr, ptr %opts, align 8
  %35 = load ptr, ptr %base_filename.addr, align 8
  %call39 = call zeroext i1 @qemu_opt_set(ptr noundef %34, ptr noundef @.str.112, ptr noundef %35, ptr noundef null)
  br i1 %call39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %if.then38
  %36 = load ptr, ptr %errp.addr, align 8
  %37 = load ptr, ptr %fmt.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %36, ptr noundef @.str.2, i32 noundef 7427, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.113, ptr noundef %37)
  br label %out

if.end41:                                         ; preds = %if.then38
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.end36
  %38 = load ptr, ptr %base_fmt.addr, align 8
  %tobool43 = icmp ne ptr %38, null
  br i1 %tobool43, label %if.then44, label %if.end48

if.then44:                                        ; preds = %if.end42
  %39 = load ptr, ptr %opts, align 8
  %40 = load ptr, ptr %base_fmt.addr, align 8
  %call45 = call zeroext i1 @qemu_opt_set(ptr noundef %39, ptr noundef @.str.114, ptr noundef %40, ptr noundef null)
  br i1 %call45, label %if.end47, label %if.then46

if.then46:                                        ; preds = %if.then44
  %41 = load ptr, ptr %errp.addr, align 8
  %42 = load ptr, ptr %fmt.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %41, ptr noundef @.str.2, i32 noundef 7435, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.115, ptr noundef %42)
  br label %out

if.end47:                                         ; preds = %if.then44
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %if.end42
  %43 = load ptr, ptr %opts, align 8
  %call49 = call ptr @qemu_opt_get(ptr noundef %43, ptr noundef @.str.112)
  store ptr %call49, ptr %backing_file, align 8
  %44 = load ptr, ptr %backing_file, align 8
  %tobool50 = icmp ne ptr %44, null
  br i1 %tobool50, label %if.then51, label %if.end60

if.then51:                                        ; preds = %if.end48
  %45 = load ptr, ptr %filename.addr, align 8
  %46 = load ptr, ptr %backing_file, align 8
  %call52 = call i32 @strcmp(ptr noundef %45, ptr noundef %46) #13
  %tobool53 = icmp ne i32 %call52, 0
  br i1 %tobool53, label %if.end55, label %if.then54

if.then54:                                        ; preds = %if.then51
  %47 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %47, ptr noundef @.str.2, i32 noundef 7444, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.116)
  br label %out

if.end55:                                         ; preds = %if.then51
  %48 = load ptr, ptr %backing_file, align 8
  %arrayidx = getelementptr i8, ptr %48, i64 0
  %49 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %49 to i32
  %cmp56 = icmp eq i32 %conv, 0
  br i1 %cmp56, label %if.then58, label %if.end59

if.then58:                                        ; preds = %if.end55
  %50 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %50, ptr noundef @.str.2, i32 noundef 7448, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.117)
  br label %out

if.end59:                                         ; preds = %if.end55
  br label %if.end60

if.end60:                                         ; preds = %if.end59, %if.end48
  %51 = load ptr, ptr %opts, align 8
  %call61 = call ptr @qemu_opt_get(ptr noundef %51, ptr noundef @.str.114)
  store ptr %call61, ptr %backing_fmt, align 8
  %52 = load ptr, ptr %opts, align 8
  %53 = load i64, ptr %img_size.addr, align 8
  %call62 = call i64 @qemu_opt_get_size(ptr noundef %52, ptr noundef @.str.17, i64 noundef %53)
  store i64 %call62, ptr %size, align 8
  %54 = load ptr, ptr %backing_file, align 8
  %tobool63 = icmp ne ptr %54, null
  br i1 %tobool63, label %land.lhs.true, label %if.else100

land.lhs.true:                                    ; preds = %if.end60
  %55 = load i32, ptr %flags.addr, align 4
  %and = and i32 %55, 256
  %tobool64 = icmp ne i32 %and, 0
  br i1 %tobool64, label %if.else100, label %if.then65

if.then65:                                        ; preds = %land.lhs.true
  store ptr null, ptr %backing_options, align 8
  %56 = load ptr, ptr %filename.addr, align 8
  %57 = load ptr, ptr %backing_file, align 8
  %call66 = call ptr @bdrv_get_full_backing_filename_from_filename(ptr noundef %56, ptr noundef %57, ptr noundef %local_err)
  store ptr %call66, ptr %full_backing, align 8
  %58 = load ptr, ptr %local_err, align 8
  %tobool67 = icmp ne ptr %58, null
  br i1 %tobool67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.then65
  br label %out

if.end69:                                         ; preds = %if.then65
  %59 = load ptr, ptr %full_backing, align 8
  %tobool70 = icmp ne ptr %59, null
  br i1 %tobool70, label %if.then71, label %if.else72

if.then71:                                        ; preds = %if.end69
  br label %if.end73

if.else72:                                        ; preds = %if.end69
  call void @__assert_fail(ptr noundef @.str.118, ptr noundef @.str.2, i32 noundef 7470, ptr noundef @__PRETTY_FUNCTION__.bdrv_img_create) #16
  unreachable

if.end73:                                         ; preds = %if.then71
  %60 = load i32, ptr %flags.addr, align 4
  store i32 %60, ptr %back_flags, align 4
  %61 = load i32, ptr %back_flags, align 4
  %and74 = and i32 %61, -267
  store i32 %and74, ptr %back_flags, align 4
  %62 = load i32, ptr %back_flags, align 4
  %or = or i32 %62, 65536
  store i32 %or, ptr %back_flags, align 4
  %call75 = call ptr @qdict_new()
  store ptr %call75, ptr %backing_options, align 8
  %63 = load ptr, ptr %backing_fmt, align 8
  %tobool76 = icmp ne ptr %63, null
  br i1 %tobool76, label %if.then77, label %if.end78

if.then77:                                        ; preds = %if.end73
  %64 = load ptr, ptr %backing_options, align 8
  %65 = load ptr, ptr %backing_fmt, align 8
  call void @qdict_put_str(ptr noundef %64, ptr noundef @.str.20, ptr noundef %65)
  br label %if.end78

if.end78:                                         ; preds = %if.then77, %if.end73
  %66 = load ptr, ptr %backing_options, align 8
  call void @qdict_put_bool(ptr noundef %66, ptr noundef @.str.59, i1 noundef zeroext true)
  %67 = load ptr, ptr %full_backing, align 8
  %68 = load ptr, ptr %backing_options, align 8
  %69 = load i32, ptr %back_flags, align 4
  %call79 = call ptr @bdrv_open(ptr noundef %67, ptr noundef null, ptr noundef %68, i32 noundef %69, ptr noundef %local_err)
  store ptr %call79, ptr %bs, align 8
  %70 = load ptr, ptr %full_backing, align 8
  call void @g_free(ptr noundef %70)
  %71 = load ptr, ptr %bs, align 8
  %tobool80 = icmp ne ptr %71, null
  br i1 %tobool80, label %if.else82, label %if.then81

if.then81:                                        ; preds = %if.end78
  call void (ptr, ptr, ...) @error_append_hint(ptr noundef %local_err, ptr noundef @.str.119)
  br label %out

if.else82:                                        ; preds = %if.end78
  %72 = load ptr, ptr %backing_fmt, align 8
  %tobool83 = icmp ne ptr %72, null
  br i1 %tobool83, label %if.end87, label %if.then84

if.then84:                                        ; preds = %if.else82
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %local_err, ptr noundef @.str.2, i32 noundef 7495, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.120)
  %73 = load ptr, ptr %bs, align 8
  %drv85 = getelementptr inbounds %struct.BlockDriverState, ptr %73, i32 0, i32 6
  %74 = load ptr, ptr %drv85, align 8
  %format_name86 = getelementptr inbounds %struct.BlockDriver, ptr %74, i32 0, i32 0
  %75 = load ptr, ptr %format_name86, align 8
  call void (ptr, ptr, ...) @error_append_hint(ptr noundef %local_err, ptr noundef @.str.121, ptr noundef %75)
  br label %out

if.end87:                                         ; preds = %if.else82
  %76 = load i64, ptr %size, align 8
  %cmp88 = icmp eq i64 %76, -1
  br i1 %cmp88, label %if.then90, label %if.end98

if.then90:                                        ; preds = %if.end87
  %77 = load ptr, ptr %bs, align 8
  %call91 = call i64 @bdrv_getlength(ptr noundef %77)
  store i64 %call91, ptr %size, align 8
  %78 = load i64, ptr %size, align 8
  %cmp92 = icmp slt i64 %78, 0
  br i1 %cmp92, label %if.then94, label %if.end96

if.then94:                                        ; preds = %if.then90
  %79 = load ptr, ptr %errp.addr, align 8
  %80 = load i64, ptr %size, align 8
  %sub = sub i64 0, %80
  %conv95 = trunc i64 %sub to i32
  %81 = load ptr, ptr %backing_file, align 8
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %79, ptr noundef @.str.2, i32 noundef 7505, ptr noundef @__func__.bdrv_img_create, i32 noundef %conv95, ptr noundef @.str.122, ptr noundef %81)
  %82 = load ptr, ptr %bs, align 8
  call void @bdrv_unref(ptr noundef %82)
  br label %out

if.end96:                                         ; preds = %if.then90
  %83 = load ptr, ptr %opts, align 8
  %84 = load i64, ptr %size, align 8
  %call97 = call zeroext i1 @qemu_opt_set_number(ptr noundef %83, ptr noundef @.str.17, i64 noundef %84, ptr noundef @error_abort)
  br label %if.end98

if.end98:                                         ; preds = %if.end96, %if.end87
  %85 = load ptr, ptr %bs, align 8
  call void @bdrv_unref(ptr noundef %85)
  br label %if.end99

if.end99:                                         ; preds = %if.end98
  br label %if.end106

if.else100:                                       ; preds = %land.lhs.true, %if.end60
  %86 = load ptr, ptr %backing_file, align 8
  %tobool101 = icmp ne ptr %86, null
  br i1 %tobool101, label %land.lhs.true102, label %if.end105

land.lhs.true102:                                 ; preds = %if.else100
  %87 = load ptr, ptr %backing_fmt, align 8
  %tobool103 = icmp ne ptr %87, null
  br i1 %tobool103, label %if.end105, label %if.then104

if.then104:                                       ; preds = %land.lhs.true102
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %local_err, ptr noundef @.str.2, i32 noundef 7516, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.120)
  br label %out

if.end105:                                        ; preds = %land.lhs.true102, %if.else100
  br label %if.end106

if.end106:                                        ; preds = %if.end105, %if.end99
  %88 = load i64, ptr %size, align 8
  %cmp107 = icmp eq i64 %88, -1
  br i1 %cmp107, label %if.then109, label %if.end110

if.then109:                                       ; preds = %if.end106
  %89 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %89, ptr noundef @.str.2, i32 noundef 7521, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.123)
  br label %out

if.end110:                                        ; preds = %if.end106
  %90 = load i8, ptr %quiet.addr, align 1
  %tobool111 = trunc i8 %90 to i1
  br i1 %tobool111, label %if.end116, label %if.then112

if.then112:                                       ; preds = %if.end110
  %91 = load ptr, ptr %filename.addr, align 8
  %92 = load ptr, ptr %fmt.addr, align 8
  %call113 = call i32 (ptr, ...) @printf(ptr noundef @.str.124, ptr noundef %91, ptr noundef %92)
  %93 = load ptr, ptr %opts, align 8
  call void @qemu_opts_print(ptr noundef %93, ptr noundef @.str.125)
  %call114 = call i32 @puts(ptr noundef @.str.95)
  %94 = load ptr, ptr @stdout, align 8
  %call115 = call i32 @fflush(ptr noundef %94)
  br label %if.end116

if.end116:                                        ; preds = %if.then112, %if.end110
  %95 = load ptr, ptr %drv, align 8
  %96 = load ptr, ptr %filename.addr, align 8
  %97 = load ptr, ptr %opts, align 8
  %call117 = call i32 @bdrv_create(ptr noundef %95, ptr noundef %96, ptr noundef %97, ptr noundef %local_err)
  store i32 %call117, ptr %ret, align 4
  %98 = load i32, ptr %ret, align 4
  %cmp118 = icmp eq i32 %98, -27
  br i1 %cmp118, label %if.then120, label %if.end125

if.then120:                                       ; preds = %if.end116
  store ptr @.str.95, ptr %cluster_size_hint, align 8
  %99 = load ptr, ptr %opts, align 8
  %call121 = call i64 @qemu_opt_get_size(ptr noundef %99, ptr noundef @.str.126, i64 noundef 0)
  %tobool122 = icmp ne i64 %call121, 0
  br i1 %tobool122, label %if.then123, label %if.end124

if.then123:                                       ; preds = %if.then120
  store ptr @.str.127, ptr %cluster_size_hint, align 8
  br label %if.end124

if.end124:                                        ; preds = %if.then123, %if.then120
  %100 = load ptr, ptr %errp.addr, align 8
  %101 = load ptr, ptr %fmt.addr, align 8
  %102 = load ptr, ptr %cluster_size_hint, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %100, ptr noundef @.str.2, i32 noundef 7543, ptr noundef @__func__.bdrv_img_create, ptr noundef @.str.128, ptr noundef %101, ptr noundef %102)
  %103 = load ptr, ptr %local_err, align 8
  call void @error_free(ptr noundef %103)
  store ptr null, ptr %local_err, align 8
  br label %if.end125

if.end125:                                        ; preds = %if.end124, %if.end116
  br label %out

out:                                              ; preds = %if.end125, %if.then109, %if.then104, %if.then94, %if.then84, %if.then81, %if.then68, %if.then58, %if.then54, %if.then46, %if.then40, %if.then34, %if.then26
  %104 = load ptr, ptr %opts, align 8
  call void @qemu_opts_del(ptr noundef %104)
  %105 = load ptr, ptr %create_opts, align 8
  call void @qemu_opts_free(ptr noundef %105)
  %106 = load ptr, ptr %errp.addr, align 8
  %107 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %106, ptr noundef %107)
  %call126 = call ptr @qemu_get_aio_context()
  call void @aio_context_release(ptr noundef %call126)
  br label %return

return:                                           ; preds = %out, %if.then14, %if.then10, %if.then6, %if.then2
  ret void
}

declare ptr @qemu_opts_append(ptr noundef, ptr noundef) #2

declare ptr @qemu_opts_create(ptr noundef, ptr noundef, i32 noundef, ptr noundef) #2

declare zeroext i1 @qemu_opts_do_parse(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #2

declare ptr @qemu_opt_get(ptr noundef, ptr noundef) #2

declare zeroext i1 @qemu_opt_set_number(ptr noundef, ptr noundef, i64 noundef, ptr noundef) #2

declare zeroext i1 @qemu_opt_set(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #2

declare i64 @qemu_opt_get_size(ptr noundef, ptr noundef, i64 noundef) #2

declare void @error_append_hint(ptr noundef, ptr noundef, ...) #2

declare i64 @bdrv_getlength(ptr noundef) #2

declare i32 @printf(ptr noundef, ...) #2

declare void @qemu_opts_print(ptr noundef, ptr noundef) #2

declare i32 @puts(ptr noundef) #2

declare i32 @fflush(ptr noundef) #2

declare i32 @bdrv_create(ptr noundef, ptr noundef, ptr noundef, ptr noundef) #2

declare void @qemu_opts_free(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_co_enter(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %self = alloca ptr, align 8
  %old_ctx = alloca ptr, align 8
  %new_ctx = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %call = call ptr @qemu_coroutine_self()
  store ptr %call, ptr %self, align 8
  %0 = load ptr, ptr %self, align 8
  %call1 = call ptr @qemu_coroutine_get_aio_context(ptr noundef %0)
  store ptr %call1, ptr %old_ctx, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %1 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_inc_in_flight(ptr noundef %1)
  %2 = load ptr, ptr %bs.addr, align 8
  %call2 = call ptr @bdrv_get_aio_context(ptr noundef %2)
  store ptr %call2, ptr %new_ctx, align 8
  %3 = load ptr, ptr %new_ctx, align 8
  call void @aio_co_reschedule_self(ptr noundef %3)
  %4 = load ptr, ptr %old_ctx, align 8
  ret ptr %4
}

declare ptr @qemu_coroutine_self() #2

declare ptr @qemu_coroutine_get_aio_context(ptr noundef) #2

declare void @bdrv_inc_in_flight(ptr noundef) #2

declare void @aio_co_reschedule_self(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_leave(ptr noundef %bs, ptr noundef %old_ctx) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %old_ctx.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %old_ctx, ptr %old_ctx.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %old_ctx.addr, align 8
  call void @aio_co_reschedule_self(ptr noundef %0)
  %1 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_dec_in_flight(ptr noundef %1)
  ret void
}

declare void @bdrv_dec_in_flight(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_lock(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_get_aio_context(ptr noundef %0)
  store ptr %call, ptr %ctx, align 8
  %call1 = call ptr @qemu_get_current_aio_context()
  %call2 = call ptr @qemu_get_aio_context()
  %cmp = icmp eq ptr %call1, %call2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.82, ptr noundef @.str.2, i32 noundef 7591, ptr noundef @__PRETTY_FUNCTION__.bdrv_co_lock) #16
  unreachable

if.end:                                           ; preds = %if.then
  %call3 = call zeroext i1 @qemu_in_coroutine()
  br i1 %call3, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.end
  br label %if.end6

if.else5:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.129, ptr noundef @.str.2, i32 noundef 7597, ptr noundef @__PRETTY_FUNCTION__.bdrv_co_lock) #16
  unreachable

if.end6:                                          ; preds = %if.then4
  %1 = load ptr, ptr %ctx, align 8
  %call7 = call ptr @qemu_get_aio_context()
  %cmp8 = icmp ne ptr %1, %call7
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  %2 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %2)
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end6
  ret void
}

declare zeroext i1 @qemu_in_coroutine() #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_co_unlock(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_get_aio_context(ptr noundef %0)
  store ptr %call, ptr %ctx, align 8
  %call1 = call zeroext i1 @qemu_in_coroutine()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.129, ptr noundef @.str.2, i32 noundef 7607, ptr noundef @__PRETTY_FUNCTION__.bdrv_co_unlock) #16
  unreachable

if.end:                                           ; preds = %if.then
  %1 = load ptr, ptr %ctx, align 8
  %call2 = call ptr @qemu_get_aio_context()
  %cmp = icmp ne ptr %1, %call2
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %2 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %2)
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_child_change_aio_context(ptr noundef %c, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca i1, align 1
  %c.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %visited.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %visited, ptr %visited.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7707, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_change_aio_context) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %visited.addr, align 8
  %1 = load ptr, ptr %c.addr, align 8
  %call1 = call i32 @g_hash_table_contains(ptr noundef %0, ptr noundef %1)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  store i1 true, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %do.end
  %2 = load ptr, ptr %visited.addr, align 8
  %3 = load ptr, ptr %c.addr, align 8
  %call4 = call i32 @g_hash_table_add(ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %c.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %bs, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %7 = load ptr, ptr %visited.addr, align 8
  %8 = load ptr, ptr %tran.addr, align 8
  %9 = load ptr, ptr %errp.addr, align 8
  %call5 = call zeroext i1 @bdrv_change_aio_context(ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8, ptr noundef %9)
  store i1 %call5, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end3, %if.then2
  %10 = load i1, ptr %retval, align 1
  ret i1 %10
}

declare i32 @g_hash_table_contains(ptr noundef, ptr noundef) #2

declare i32 @g_hash_table_add(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_change_aio_context(ptr noundef %bs, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %visited.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %state = alloca ptr, align 8
  %.compoundliteral = alloca %struct.BdrvStateSetAioContext, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %visited, ptr %visited.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7774, ptr noundef @__PRETTY_FUNCTION__.bdrv_change_aio_context) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %call1 = call ptr @bdrv_get_aio_context(ptr noundef %0)
  %1 = load ptr, ptr %ctx.addr, align 8
  %cmp = icmp eq ptr %call1, %1
  br i1 %cmp, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  store i1 true, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %do.end
  call void @bdrv_graph_rdlock_main_loop()
  %2 = load ptr, ptr %bs.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %3 = load ptr, ptr %lh_first, align 8
  store ptr %3, ptr %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %4 = load ptr, ptr %c, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %c, align 8
  %6 = load ptr, ptr %ctx.addr, align 8
  %7 = load ptr, ptr %visited.addr, align 8
  %8 = load ptr, ptr %tran.addr, align 8
  %9 = load ptr, ptr %errp.addr, align 8
  %call4 = call zeroext i1 @bdrv_parent_change_aio_context(ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8, ptr noundef %9)
  br i1 %call4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %for.body
  call void @bdrv_graph_rdunlock_main_loop()
  store i1 false, ptr %retval, align 1
  br label %return

if.end6:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %10 = load ptr, ptr %c, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %10, i32 0, i32 10
  %le_next = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %11 = load ptr, ptr %le_next, align 8
  store ptr %11, ptr %c, align 8
  br label %for.cond, !llvm.loop !83

for.end:                                          ; preds = %for.cond
  %12 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 29
  %lh_first7 = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %13 = load ptr, ptr %lh_first7, align 8
  store ptr %13, ptr %c, align 8
  br label %for.cond8

for.cond8:                                        ; preds = %for.inc14, %for.end
  %14 = load ptr, ptr %c, align 8
  %tobool9 = icmp ne ptr %14, null
  br i1 %tobool9, label %for.body10, label %for.end16

for.body10:                                       ; preds = %for.cond8
  %15 = load ptr, ptr %c, align 8
  %16 = load ptr, ptr %ctx.addr, align 8
  %17 = load ptr, ptr %visited.addr, align 8
  %18 = load ptr, ptr %tran.addr, align 8
  %19 = load ptr, ptr %errp.addr, align 8
  %call11 = call zeroext i1 @bdrv_child_change_aio_context(ptr noundef %15, ptr noundef %16, ptr noundef %17, ptr noundef %18, ptr noundef %19)
  br i1 %call11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %for.body10
  call void @bdrv_graph_rdunlock_main_loop()
  store i1 false, ptr %retval, align 1
  br label %return

if.end13:                                         ; preds = %for.body10
  br label %for.inc14

for.inc14:                                        ; preds = %if.end13
  %20 = load ptr, ptr %c, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %20, i32 0, i32 9
  %le_next15 = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %21 = load ptr, ptr %le_next15, align 8
  store ptr %21, ptr %c, align 8
  br label %for.cond8, !llvm.loop !84

for.end16:                                        ; preds = %for.cond8
  call void @bdrv_graph_rdunlock_main_loop()
  %call17 = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 16) #17
  store ptr %call17, ptr %state, align 8
  %22 = load ptr, ptr %state, align 8
  %new_ctx = getelementptr inbounds %struct.BdrvStateSetAioContext, ptr %.compoundliteral, i32 0, i32 0
  %23 = load ptr, ptr %ctx.addr, align 8
  store ptr %23, ptr %new_ctx, align 8
  %bs18 = getelementptr inbounds %struct.BdrvStateSetAioContext, ptr %.compoundliteral, i32 0, i32 1
  %24 = load ptr, ptr %bs.addr, align 8
  store ptr %24, ptr %bs18, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %22, ptr align 8 %.compoundliteral, i64 16, i1 false)
  %25 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_drained_begin(ptr noundef %25)
  %26 = load ptr, ptr %tran.addr, align 8
  %27 = load ptr, ptr %state, align 8
  call void @tran_add(ptr noundef %26, ptr noundef @set_aio_context, ptr noundef %27)
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end16, %if.then12, %if.then5, %if.then2
  %28 = load i1, ptr %retval, align 1
  ret i1 %28
}

declare ptr @g_hash_table_new(ptr noundef, ptr noundef) #2

declare void @g_hash_table_destroy(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_add_aio_context_notifier(ptr noundef %bs, ptr noundef %attached_aio_context, ptr noundef %detach_aio_context, ptr noundef %opaque) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %attached_aio_context.addr = alloca ptr, align 8
  %detach_aio_context.addr = alloca ptr, align 8
  %opaque.addr = alloca ptr, align 8
  %ban = alloca ptr, align 8
  %.compoundliteral = alloca %struct.BdrvAioNotifier, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %attached_aio_context, ptr %attached_aio_context.addr, align 8
  store ptr %detach_aio_context, ptr %detach_aio_context.addr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %call = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 48) #17
  store ptr %call, ptr %ban, align 8
  %0 = load ptr, ptr %ban, align 8
  %attached_aio_context1 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %.compoundliteral, i32 0, i32 0
  %1 = load ptr, ptr %attached_aio_context.addr, align 8
  store ptr %1, ptr %attached_aio_context1, align 8
  %detach_aio_context2 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %.compoundliteral, i32 0, i32 1
  %2 = load ptr, ptr %detach_aio_context.addr, align 8
  store ptr %2, ptr %detach_aio_context2, align 8
  %opaque3 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %.compoundliteral, i32 0, i32 2
  %3 = load ptr, ptr %opaque.addr, align 8
  store ptr %3, ptr %opaque3, align 8
  %deleted = getelementptr inbounds %struct.BdrvAioNotifier, ptr %.compoundliteral, i32 0, i32 3
  store i8 0, ptr %deleted, align 8
  %list = getelementptr inbounds %struct.BdrvAioNotifier, ptr %.compoundliteral, i32 0, i32 4
  call void @llvm.memset.p0.i64(ptr align 8 %list, i8 0, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %.compoundliteral, i64 48, i1 false)
  br label %do.body

do.body:                                          ; preds = %entry
  %call4 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call4, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7901, ptr noundef @__PRETTY_FUNCTION__.bdrv_add_aio_context_notifier) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body5

do.body5:                                         ; preds = %do.end
  %4 = load ptr, ptr %bs.addr, align 8
  %aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 9
  %lh_first = getelementptr inbounds %struct.anon, ptr %aio_notifiers, i32 0, i32 0
  %5 = load ptr, ptr %lh_first, align 8
  %6 = load ptr, ptr %ban, align 8
  %list6 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %6, i32 0, i32 4
  %le_next = getelementptr inbounds %struct.anon.26, ptr %list6, i32 0, i32 0
  store ptr %5, ptr %le_next, align 8
  %cmp = icmp ne ptr %5, null
  br i1 %cmp, label %if.then7, label %if.end13

if.then7:                                         ; preds = %do.body5
  %7 = load ptr, ptr %ban, align 8
  %list8 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %7, i32 0, i32 4
  %le_next9 = getelementptr inbounds %struct.anon.26, ptr %list8, i32 0, i32 0
  %8 = load ptr, ptr %bs.addr, align 8
  %aio_notifiers10 = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 9
  %lh_first11 = getelementptr inbounds %struct.anon, ptr %aio_notifiers10, i32 0, i32 0
  %9 = load ptr, ptr %lh_first11, align 8
  %list12 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %9, i32 0, i32 4
  %le_prev = getelementptr inbounds %struct.anon.26, ptr %list12, i32 0, i32 1
  store ptr %le_next9, ptr %le_prev, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.then7, %do.body5
  %10 = load ptr, ptr %ban, align 8
  %11 = load ptr, ptr %bs.addr, align 8
  %aio_notifiers14 = getelementptr inbounds %struct.BlockDriverState, ptr %11, i32 0, i32 9
  %lh_first15 = getelementptr inbounds %struct.anon, ptr %aio_notifiers14, i32 0, i32 0
  store ptr %10, ptr %lh_first15, align 8
  %12 = load ptr, ptr %bs.addr, align 8
  %aio_notifiers16 = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 9
  %lh_first17 = getelementptr inbounds %struct.anon, ptr %aio_notifiers16, i32 0, i32 0
  %13 = load ptr, ptr %ban, align 8
  %list18 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %13, i32 0, i32 4
  %le_prev19 = getelementptr inbounds %struct.anon.26, ptr %list18, i32 0, i32 1
  store ptr %lh_first17, ptr %le_prev19, align 8
  br label %do.end20

do.end20:                                         ; preds = %if.end13
  ret void
}

; Function Attrs: allocsize(0,1)
declare noalias ptr @g_malloc_n(i64 noundef, i64 noundef) #7

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_remove_aio_context_notifier(ptr noundef %bs, ptr noundef %attached_aio_context, ptr noundef %detach_aio_context, ptr noundef %opaque) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %attached_aio_context.addr = alloca ptr, align 8
  %detach_aio_context.addr = alloca ptr, align 8
  %opaque.addr = alloca ptr, align 8
  %ban = alloca ptr, align 8
  %ban_next = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %attached_aio_context, ptr %attached_aio_context.addr, align 8
  store ptr %detach_aio_context, ptr %detach_aio_context.addr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7913, ptr noundef @__PRETTY_FUNCTION__.bdrv_remove_aio_context_notifier) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 9
  %lh_first = getelementptr inbounds %struct.anon, ptr %aio_notifiers, i32 0, i32 0
  %1 = load ptr, ptr %lh_first, align 8
  store ptr %1, ptr %ban, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %2 = load ptr, ptr %ban, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %3 = load ptr, ptr %ban, align 8
  %list = getelementptr inbounds %struct.BdrvAioNotifier, ptr %3, i32 0, i32 4
  %le_next = getelementptr inbounds %struct.anon.26, ptr %list, i32 0, i32 0
  %4 = load ptr, ptr %le_next, align 8
  store ptr %4, ptr %ban_next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %5 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %5, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %6 = load ptr, ptr %ban, align 8
  %attached_aio_context1 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %attached_aio_context1, align 8
  %8 = load ptr, ptr %attached_aio_context.addr, align 8
  %cmp = icmp eq ptr %7, %8
  br i1 %cmp, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %for.body
  %9 = load ptr, ptr %ban, align 8
  %detach_aio_context2 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %9, i32 0, i32 1
  %10 = load ptr, ptr %detach_aio_context2, align 8
  %11 = load ptr, ptr %detach_aio_context.addr, align 8
  %cmp3 = icmp eq ptr %10, %11
  br i1 %cmp3, label %land.lhs.true4, label %if.end17

land.lhs.true4:                                   ; preds = %land.lhs.true
  %12 = load ptr, ptr %ban, align 8
  %opaque5 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %12, i32 0, i32 2
  %13 = load ptr, ptr %opaque5, align 8
  %14 = load ptr, ptr %opaque.addr, align 8
  %cmp6 = icmp eq ptr %13, %14
  br i1 %cmp6, label %land.lhs.true7, label %if.end17

land.lhs.true7:                                   ; preds = %land.lhs.true4
  %15 = load ptr, ptr %ban, align 8
  %deleted = getelementptr inbounds %struct.BdrvAioNotifier, ptr %15, i32 0, i32 3
  %16 = load i8, ptr %deleted, align 8
  %tobool8 = trunc i8 %16 to i1
  %conv = zext i1 %tobool8 to i32
  %cmp9 = icmp eq i32 %conv, 0
  br i1 %cmp9, label %if.then11, label %if.end17

if.then11:                                        ; preds = %land.lhs.true7
  %17 = load ptr, ptr %bs.addr, align 8
  %walking_aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %17, i32 0, i32 10
  %18 = load i8, ptr %walking_aio_notifiers, align 8
  %tobool12 = trunc i8 %18 to i1
  br i1 %tobool12, label %if.then13, label %if.else15

if.then13:                                        ; preds = %if.then11
  %19 = load ptr, ptr %ban, align 8
  %deleted14 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %19, i32 0, i32 3
  store i8 1, ptr %deleted14, align 8
  br label %if.end16

if.else15:                                        ; preds = %if.then11
  %20 = load ptr, ptr %ban, align 8
  call void @bdrv_do_remove_aio_context_notifier(ptr noundef %20)
  br label %if.end16

if.end16:                                         ; preds = %if.else15, %if.then13
  ret void

if.end17:                                         ; preds = %land.lhs.true7, %land.lhs.true4, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %21 = load ptr, ptr %ban_next, align 8
  store ptr %21, ptr %ban, align 8
  br label %for.cond, !llvm.loop !85

for.end:                                          ; preds = %land.end
  call void @abort() #16
  unreachable
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_do_remove_aio_context_notifier(ptr noundef %ban) #0 {
entry:
  %ban.addr = alloca ptr, align 8
  store ptr %ban, ptr %ban.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7615, ptr noundef @__PRETTY_FUNCTION__.bdrv_do_remove_aio_context_notifier) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body1

do.body1:                                         ; preds = %do.end
  %0 = load ptr, ptr %ban.addr, align 8
  %list = getelementptr inbounds %struct.BdrvAioNotifier, ptr %0, i32 0, i32 4
  %le_next = getelementptr inbounds %struct.anon.26, ptr %list, i32 0, i32 0
  %1 = load ptr, ptr %le_next, align 8
  %cmp = icmp ne ptr %1, null
  br i1 %cmp, label %if.then2, label %if.end8

if.then2:                                         ; preds = %do.body1
  %2 = load ptr, ptr %ban.addr, align 8
  %list3 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %2, i32 0, i32 4
  %le_prev = getelementptr inbounds %struct.anon.26, ptr %list3, i32 0, i32 1
  %3 = load ptr, ptr %le_prev, align 8
  %4 = load ptr, ptr %ban.addr, align 8
  %list4 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %4, i32 0, i32 4
  %le_next5 = getelementptr inbounds %struct.anon.26, ptr %list4, i32 0, i32 0
  %5 = load ptr, ptr %le_next5, align 8
  %list6 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %5, i32 0, i32 4
  %le_prev7 = getelementptr inbounds %struct.anon.26, ptr %list6, i32 0, i32 1
  store ptr %3, ptr %le_prev7, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then2, %do.body1
  %6 = load ptr, ptr %ban.addr, align 8
  %list9 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %6, i32 0, i32 4
  %le_next10 = getelementptr inbounds %struct.anon.26, ptr %list9, i32 0, i32 0
  %7 = load ptr, ptr %le_next10, align 8
  %8 = load ptr, ptr %ban.addr, align 8
  %list11 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %8, i32 0, i32 4
  %le_prev12 = getelementptr inbounds %struct.anon.26, ptr %list11, i32 0, i32 1
  %9 = load ptr, ptr %le_prev12, align 8
  store ptr %7, ptr %9, align 8
  %10 = load ptr, ptr %ban.addr, align 8
  %list13 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %10, i32 0, i32 4
  %le_next14 = getelementptr inbounds %struct.anon.26, ptr %list13, i32 0, i32 0
  store ptr null, ptr %le_next14, align 8
  %11 = load ptr, ptr %ban.addr, align 8
  %list15 = getelementptr inbounds %struct.BdrvAioNotifier, ptr %11, i32 0, i32 4
  %le_prev16 = getelementptr inbounds %struct.anon.26, ptr %list15, i32 0, i32 1
  store ptr null, ptr %le_prev16, align 8
  br label %do.end17

do.end17:                                         ; preds = %if.end8
  %12 = load ptr, ptr %ban.addr, align 8
  call void @g_free(ptr noundef %12)
  ret void
}

; Function Attrs: noreturn nounwind
declare void @abort() #6

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_amend_options(ptr noundef %bs, ptr noundef %opts, ptr noundef %status_cb, ptr noundef %cb_opaque, i1 noundef zeroext %force, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %opts.addr = alloca ptr, align 8
  %status_cb.addr = alloca ptr, align 8
  %cb_opaque.addr = alloca ptr, align 8
  %force.addr = alloca i8, align 1
  %errp.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %opts, ptr %opts.addr, align 8
  store ptr %status_cb, ptr %status_cb.addr, align 8
  store ptr %cb_opaque, ptr %cb_opaque.addr, align 8
  %frombool = zext i1 %force to i8
  store i8 %frombool, ptr %force.addr, align 1
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7938, ptr noundef @__PRETTY_FUNCTION__.bdrv_amend_options) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %do.end
  %2 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %2, ptr noundef @.str.2, i32 noundef 7940, ptr noundef @__func__.bdrv_amend_options, ptr noundef @.str.130)
  store i32 -123, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %do.end
  %3 = load ptr, ptr %bs.addr, align 8
  %drv3 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv3, align 8
  %bdrv_amend_options = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 28
  %5 = load ptr, ptr %bdrv_amend_options, align 8
  %tobool4 = icmp ne ptr %5, null
  br i1 %tobool4, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end2
  %6 = load ptr, ptr %errp.addr, align 8
  %7 = load ptr, ptr %bs.addr, align 8
  %drv6 = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 6
  %8 = load ptr, ptr %drv6, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %format_name, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %6, ptr noundef @.str.2, i32 noundef 7945, ptr noundef @__func__.bdrv_amend_options, ptr noundef @.str.131, ptr noundef %9)
  store i32 -95, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end2
  %10 = load ptr, ptr %bs.addr, align 8
  %drv8 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 6
  %11 = load ptr, ptr %drv8, align 8
  %bdrv_amend_options9 = getelementptr inbounds %struct.BlockDriver, ptr %11, i32 0, i32 28
  %12 = load ptr, ptr %bdrv_amend_options9, align 8
  %13 = load ptr, ptr %bs.addr, align 8
  %14 = load ptr, ptr %opts.addr, align 8
  %15 = load ptr, ptr %status_cb.addr, align 8
  %16 = load ptr, ptr %cb_opaque.addr, align 8
  %17 = load i8, ptr %force.addr, align 1
  %tobool10 = trunc i8 %17 to i1
  %18 = load ptr, ptr %errp.addr, align 8
  %call11 = call i32 %12(ptr noundef %13, ptr noundef %14, ptr noundef %15, ptr noundef %16, i1 noundef zeroext %tobool10, ptr noundef %18)
  store i32 %call11, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then5, %if.then1
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_recurse_can_replace(ptr noundef %bs, ptr noundef %to_replace) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %to_replace.addr = alloca ptr, align 8
  %filtered = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %to_replace, ptr %to_replace.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7969, ptr noundef @__PRETTY_FUNCTION__.bdrv_recurse_can_replace) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then2

lor.lhs.false:                                    ; preds = %do.end
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %lor.lhs.false, %do.end
  store i1 false, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %lor.lhs.false
  %3 = load ptr, ptr %bs.addr, align 8
  %4 = load ptr, ptr %to_replace.addr, align 8
  %cmp = icmp eq ptr %3, %4
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end3
  store i1 true, ptr %retval, align 1
  br label %return

if.end5:                                          ; preds = %if.end3
  %5 = load ptr, ptr %bs.addr, align 8
  %drv6 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %drv6, align 8
  %bdrv_recurse_can_replace = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 15
  %7 = load ptr, ptr %bdrv_recurse_can_replace, align 8
  %tobool7 = icmp ne ptr %7, null
  br i1 %tobool7, label %if.then8, label %if.end12

if.then8:                                         ; preds = %if.end5
  %8 = load ptr, ptr %bs.addr, align 8
  %drv9 = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 6
  %9 = load ptr, ptr %drv9, align 8
  %bdrv_recurse_can_replace10 = getelementptr inbounds %struct.BlockDriver, ptr %9, i32 0, i32 15
  %10 = load ptr, ptr %bdrv_recurse_can_replace10, align 8
  %11 = load ptr, ptr %bs.addr, align 8
  %12 = load ptr, ptr %to_replace.addr, align 8
  %call11 = call zeroext i1 %10(ptr noundef %11, ptr noundef %12)
  store i1 %call11, ptr %retval, align 1
  br label %return

if.end12:                                         ; preds = %if.end5
  %13 = load ptr, ptr %bs.addr, align 8
  %call13 = call ptr @bdrv_filter_bs(ptr noundef %13)
  store ptr %call13, ptr %filtered, align 8
  %14 = load ptr, ptr %filtered, align 8
  %tobool14 = icmp ne ptr %14, null
  br i1 %tobool14, label %if.then15, label %if.end17

if.then15:                                        ; preds = %if.end12
  %15 = load ptr, ptr %filtered, align 8
  %16 = load ptr, ptr %to_replace.addr, align 8
  %call16 = call zeroext i1 @bdrv_recurse_can_replace(ptr noundef %15, ptr noundef %16)
  store i1 %call16, ptr %retval, align 1
  br label %return

if.end17:                                         ; preds = %if.end12
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end17, %if.then15, %if.then8, %if.then4, %if.then2
  %17 = load i1, ptr %retval, align 1
  ret i1 %17
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @check_to_replace_node(ptr noundef %parent_bs, ptr noundef %node_name, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %parent_bs.addr = alloca ptr, align 8
  %node_name.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %to_replace_bs = alloca ptr, align 8
  %aio_context = alloca ptr, align 8
  store ptr %parent_bs, ptr %parent_bs.addr, align 8
  store ptr %node_name, ptr %node_name.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %node_name.addr, align 8
  %call = call ptr @bdrv_find_node(ptr noundef %0)
  store ptr %call, ptr %to_replace_bs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 8011, ptr noundef @__PRETTY_FUNCTION__.check_to_replace_node) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load ptr, ptr %to_replace_bs, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %do.end
  %2 = load ptr, ptr %errp.addr, align 8
  %3 = load ptr, ptr %node_name.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %2, ptr noundef @.str.2, i32 noundef 8014, ptr noundef @__func__.check_to_replace_node, ptr noundef @.str.132, ptr noundef %3)
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %do.end
  %4 = load ptr, ptr %to_replace_bs, align 8
  %call4 = call ptr @bdrv_get_aio_context(ptr noundef %4)
  store ptr %call4, ptr %aio_context, align 8
  %5 = load ptr, ptr %aio_context, align 8
  call void @aio_context_acquire(ptr noundef %5)
  %6 = load ptr, ptr %to_replace_bs, align 8
  %7 = load ptr, ptr %errp.addr, align 8
  %call5 = call zeroext i1 @bdrv_op_is_blocked(ptr noundef %6, i32 noundef 15, ptr noundef %7)
  br i1 %call5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end3
  store ptr null, ptr %to_replace_bs, align 8
  br label %out

if.end7:                                          ; preds = %if.end3
  %8 = load ptr, ptr %parent_bs.addr, align 8
  %9 = load ptr, ptr %to_replace_bs, align 8
  %call8 = call zeroext i1 @bdrv_recurse_can_replace(ptr noundef %8, ptr noundef %9)
  br i1 %call8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end7
  %10 = load ptr, ptr %errp.addr, align 8
  %11 = load ptr, ptr %node_name.addr, align 8
  %12 = load ptr, ptr %parent_bs.addr, align 8
  %node_name10 = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name10, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %10, ptr noundef @.str.2, i32 noundef 8035, ptr noundef @__func__.check_to_replace_node, ptr noundef @.str.133, ptr noundef %11, ptr noundef %arraydecay)
  store ptr null, ptr %to_replace_bs, align 8
  br label %out

if.end11:                                         ; preds = %if.end7
  br label %out

out:                                              ; preds = %if.end11, %if.then9, %if.then6
  %13 = load ptr, ptr %aio_context, align 8
  call void @aio_context_release(ptr noundef %13)
  %14 = load ptr, ptr %to_replace_bs, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %out, %if.then2
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @qobject_ref_impl(ptr noundef %obj) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %obj.addr, align 8
  %base = getelementptr inbounds %struct.QObject, ptr %1, i32 0, i32 0
  %refcnt = getelementptr inbounds %struct.QObjectBase_, ptr %base, i32 0, i32 1
  %2 = load i64, ptr %refcnt, align 8
  %inc = add i64 %2, 1
  store i64 %inc, ptr %refcnt, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @append_strong_runtime_options(ptr noundef %d, ptr noundef %bs) #0 {
entry:
  %retval = alloca i1, align 1
  %d.addr = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %found_any = alloca i8, align 1
  %option_name = alloca ptr, align 8
  %option_given = alloca i8, align 1
  %entry9 = alloca ptr, align 8
  %_o = alloca ptr, align 8
  %_obj67 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp15 = alloca ptr, align 8
  %tmp16 = alloca ptr, align 8
  %entry18 = alloca ptr, align 8
  %_o27 = alloca ptr, align 8
  %_obj68 = alloca ptr, align 8
  %tmp29 = alloca ptr, align 8
  %__mptr32 = alloca ptr, align 8
  %tmp34 = alloca ptr, align 8
  %tmp39 = alloca ptr, align 8
  store ptr %d, ptr %d.addr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store i8 0, ptr %found_any, align 1
  store ptr null, ptr %option_name, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end54, %if.then12, %if.end
  %2 = load ptr, ptr %bs.addr, align 8
  %3 = load ptr, ptr %option_name, align 8
  %call = call ptr @strong_options(ptr noundef %2, ptr noundef %3)
  store ptr %call, ptr %option_name, align 8
  %tobool1 = icmp ne ptr %call, null
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  store i8 0, ptr %option_given, align 1
  %4 = load ptr, ptr %option_name, align 8
  %5 = load ptr, ptr %4, align 8
  %call2 = call i64 @strlen(ptr noundef %5) #13
  %cmp = icmp ugt i64 %call2, 0
  br i1 %cmp, label %if.then3, label %if.else

if.then3:                                         ; preds = %while.body
  br label %if.end4

if.else:                                          ; preds = %while.body
  call void @__assert_fail(ptr noundef @.str.290, ptr noundef @.str.2, i32 noundef 8097, ptr noundef @__PRETTY_FUNCTION__.append_strong_runtime_options) #16
  unreachable

if.end4:                                          ; preds = %if.then3
  %6 = load ptr, ptr %option_name, align 8
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %option_name, align 8
  %9 = load ptr, ptr %8, align 8
  %call5 = call i64 @strlen(ptr noundef %9) #13
  %sub = sub i64 %call5, 1
  %arrayidx = getelementptr i8, ptr %7, i64 %sub
  %10 = load i8, ptr %arrayidx, align 1
  %conv = sext i8 %10 to i32
  %cmp6 = icmp ne i32 %conv, 46
  br i1 %cmp6, label %if.then8, label %if.else17

if.then8:                                         ; preds = %if.end4
  %11 = load ptr, ptr %bs.addr, align 8
  %options = getelementptr inbounds %struct.BlockDriverState, ptr %11, i32 0, i32 33
  %12 = load ptr, ptr %options, align 8
  %13 = load ptr, ptr %option_name, align 8
  %14 = load ptr, ptr %13, align 8
  %call10 = call ptr @qdict_get(ptr noundef %12, ptr noundef %14)
  store ptr %call10, ptr %entry9, align 8
  %15 = load ptr, ptr %entry9, align 8
  %tobool11 = icmp ne ptr %15, null
  br i1 %tobool11, label %if.end13, label %if.then12

if.then12:                                        ; preds = %if.then8
  br label %while.cond, !llvm.loop !86

if.end13:                                         ; preds = %if.then8
  %16 = load ptr, ptr %d.addr, align 8
  %17 = load ptr, ptr %option_name, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %entry9, align 8
  store ptr %19, ptr %_o, align 8
  %20 = load ptr, ptr %_o, align 8
  store ptr %20, ptr %_obj67, align 8
  %21 = load ptr, ptr %_obj67, align 8
  %tobool14 = icmp ne ptr %21, null
  br i1 %tobool14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end13
  %22 = load ptr, ptr %_obj67, align 8
  %base = getelementptr inbounds %struct.QObject, ptr %22, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %23 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %23, i64 0
  store ptr %add.ptr, ptr %tmp15, align 8
  %24 = load ptr, ptr %tmp15, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end13
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %24, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %25 = load ptr, ptr %tmp, align 8
  call void @qobject_ref_impl(ptr noundef %25)
  %26 = load ptr, ptr %_o, align 8
  store ptr %26, ptr %tmp16, align 8
  %27 = load ptr, ptr %tmp16, align 8
  call void @qdict_put_obj(ptr noundef %16, ptr noundef %18, ptr noundef %27)
  store i8 1, ptr %option_given, align 1
  br label %if.end43

if.else17:                                        ; preds = %if.end4
  %28 = load ptr, ptr %bs.addr, align 8
  %options19 = getelementptr inbounds %struct.BlockDriverState, ptr %28, i32 0, i32 33
  %29 = load ptr, ptr %options19, align 8
  %call20 = call ptr @qdict_first(ptr noundef %29)
  store ptr %call20, ptr %entry18, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else17
  %30 = load ptr, ptr %entry18, align 8
  %tobool21 = icmp ne ptr %30, null
  br i1 %tobool21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load ptr, ptr %entry18, align 8
  %call22 = call ptr @qdict_entry_key(ptr noundef %31)
  %32 = load ptr, ptr %option_name, align 8
  %33 = load ptr, ptr %32, align 8
  %call23 = call i32 @strstart(ptr noundef %call22, ptr noundef %33, ptr noundef null)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.then25, label %if.end40

if.then25:                                        ; preds = %for.body
  %34 = load ptr, ptr %d.addr, align 8
  %35 = load ptr, ptr %entry18, align 8
  %call26 = call ptr @qdict_entry_key(ptr noundef %35)
  %36 = load ptr, ptr %entry18, align 8
  %call28 = call ptr @qdict_entry_value(ptr noundef %36)
  store ptr %call28, ptr %_o27, align 8
  %37 = load ptr, ptr %_o27, align 8
  store ptr %37, ptr %_obj68, align 8
  %38 = load ptr, ptr %_obj68, align 8
  %tobool30 = icmp ne ptr %38, null
  br i1 %tobool30, label %cond.true31, label %cond.false36

cond.true31:                                      ; preds = %if.then25
  %39 = load ptr, ptr %_obj68, align 8
  %base33 = getelementptr inbounds %struct.QObject, ptr %39, i32 0, i32 0
  store ptr %base33, ptr %__mptr32, align 8
  %40 = load ptr, ptr %__mptr32, align 8
  %add.ptr35 = getelementptr i8, ptr %40, i64 0
  store ptr %add.ptr35, ptr %tmp34, align 8
  %41 = load ptr, ptr %tmp34, align 8
  br label %cond.end37

cond.false36:                                     ; preds = %if.then25
  br label %cond.end37

cond.end37:                                       ; preds = %cond.false36, %cond.true31
  %cond38 = phi ptr [ %41, %cond.true31 ], [ null, %cond.false36 ]
  store ptr %cond38, ptr %tmp29, align 8
  %42 = load ptr, ptr %tmp29, align 8
  call void @qobject_ref_impl(ptr noundef %42)
  %43 = load ptr, ptr %_o27, align 8
  store ptr %43, ptr %tmp39, align 8
  %44 = load ptr, ptr %tmp39, align 8
  call void @qdict_put_obj(ptr noundef %34, ptr noundef %call26, ptr noundef %44)
  store i8 1, ptr %option_given, align 1
  br label %if.end40

if.end40:                                         ; preds = %cond.end37, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end40
  %45 = load ptr, ptr %bs.addr, align 8
  %options41 = getelementptr inbounds %struct.BlockDriverState, ptr %45, i32 0, i32 33
  %46 = load ptr, ptr %options41, align 8
  %47 = load ptr, ptr %entry18, align 8
  %call42 = call ptr @qdict_next(ptr noundef %46, ptr noundef %47)
  store ptr %call42, ptr %entry18, align 8
  br label %for.cond, !llvm.loop !87

for.end:                                          ; preds = %for.cond
  br label %if.end43

if.end43:                                         ; preds = %for.end, %cond.end
  %48 = load i8, ptr %found_any, align 1
  %tobool44 = trunc i8 %48 to i1
  br i1 %tobool44, label %if.end54, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end43
  %49 = load i8, ptr %option_given, align 1
  %tobool45 = trunc i8 %49 to i1
  br i1 %tobool45, label %land.lhs.true47, label %if.end54

land.lhs.true47:                                  ; preds = %land.lhs.true
  %50 = load ptr, ptr %option_name, align 8
  %51 = load ptr, ptr %50, align 8
  %call48 = call i32 @strcmp(ptr noundef %51, ptr noundef @.str.20) #13
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %land.lhs.true50, label %if.end54

land.lhs.true50:                                  ; preds = %land.lhs.true47
  %52 = load ptr, ptr %option_name, align 8
  %53 = load ptr, ptr %52, align 8
  %call51 = call i32 @strcmp(ptr noundef %53, ptr noundef @.str.5) #13
  %tobool52 = icmp ne i32 %call51, 0
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %land.lhs.true50
  store i8 1, ptr %found_any, align 1
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %land.lhs.true50, %land.lhs.true47, %land.lhs.true, %if.end43
  br label %while.cond, !llvm.loop !86

while.end:                                        ; preds = %while.cond
  %54 = load ptr, ptr %d.addr, align 8
  %call55 = call i32 @qdict_haskey(ptr noundef %54, ptr noundef @.str.20)
  %tobool56 = icmp ne i32 %call55, 0
  br i1 %tobool56, label %if.end59, label %if.then57

if.then57:                                        ; preds = %while.end
  %55 = load ptr, ptr %d.addr, align 8
  %56 = load ptr, ptr %bs.addr, align 8
  %drv58 = getelementptr inbounds %struct.BlockDriverState, ptr %56, i32 0, i32 6
  %57 = load ptr, ptr %drv58, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %57, i32 0, i32 0
  %58 = load ptr, ptr %format_name, align 8
  call void @qdict_put_str(ptr noundef %55, ptr noundef @.str.20, ptr noundef %58)
  br label %if.end59

if.end59:                                         ; preds = %if.then57, %while.end
  %59 = load i8, ptr %found_any, align 1
  %tobool60 = trunc i8 %59 to i1
  store i1 %tobool60, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end59, %if.then
  %60 = load i1, ptr %retval, align 1
  ret i1 %60
}

declare void @qdict_put_null(ptr noundef, ptr noundef) #2

declare ptr @qobject_to_json(ptr noundef) #2

; Function Attrs: nounwind
declare i32 @snprintf(ptr noundef, i64 noundef, ptr noundef, ...) #5

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_dirname(ptr noundef %bs, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %child_bs = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 8299, ptr noundef @__PRETTY_FUNCTION__.bdrv_dirname) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %do.end
  %3 = load ptr, ptr %errp.addr, align 8
  %4 = load ptr, ptr %bs.addr, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %3, ptr noundef @.str.2, i32 noundef 8302, ptr noundef @__func__.bdrv_dirname, ptr noundef @.str.137, ptr noundef %arraydecay)
  store ptr null, ptr %retval, align 8
  br label %return

if.end3:                                          ; preds = %do.end
  %5 = load ptr, ptr %drv, align 8
  %bdrv_dirname = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 32
  %6 = load ptr, ptr %bdrv_dirname, align 8
  %tobool4 = icmp ne ptr %6, null
  br i1 %tobool4, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end3
  %7 = load ptr, ptr %drv, align 8
  %bdrv_dirname6 = getelementptr inbounds %struct.BlockDriver, ptr %7, i32 0, i32 32
  %8 = load ptr, ptr %bdrv_dirname6, align 8
  %9 = load ptr, ptr %bs.addr, align 8
  %10 = load ptr, ptr %errp.addr, align 8
  %call7 = call ptr %8(ptr noundef %9, ptr noundef %10)
  store ptr %call7, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end3
  %11 = load ptr, ptr %bs.addr, align 8
  %call9 = call ptr @bdrv_primary_bs(ptr noundef %11)
  store ptr %call9, ptr %child_bs, align 8
  %12 = load ptr, ptr %child_bs, align 8
  %tobool10 = icmp ne ptr %12, null
  br i1 %tobool10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end8
  %13 = load ptr, ptr %child_bs, align 8
  %14 = load ptr, ptr %errp.addr, align 8
  %call12 = call ptr @bdrv_dirname(ptr noundef %13, ptr noundef %14)
  store ptr %call12, ptr %retval, align 8
  br label %return

if.end13:                                         ; preds = %if.end8
  %15 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_refresh_filename(ptr noundef %15)
  %16 = load ptr, ptr %bs.addr, align 8
  %exact_filename = getelementptr inbounds %struct.BlockDriverState, ptr %16, i32 0, i32 16
  %arrayidx = getelementptr [4096 x i8], ptr %exact_filename, i64 0, i64 0
  %17 = load i8, ptr %arrayidx, align 8
  %conv = sext i8 %17 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %if.then15, label %if.end19

if.then15:                                        ; preds = %if.end13
  %18 = load ptr, ptr %bs.addr, align 8
  %exact_filename16 = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 16
  %arraydecay17 = getelementptr inbounds [4096 x i8], ptr %exact_filename16, i64 0, i64 0
  %call18 = call ptr @path_combine(ptr noundef %arraydecay17, ptr noundef @.str.95)
  store ptr %call18, ptr %retval, align 8
  br label %return

if.end19:                                         ; preds = %if.end13
  %19 = load ptr, ptr %errp.addr, align 8
  %20 = load ptr, ptr %drv, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %format_name, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %19, ptr noundef @.str.2, i32 noundef 8321, ptr noundef @__func__.bdrv_dirname, ptr noundef @.str.138, ptr noundef %21)
  store ptr null, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then15, %if.then11, %if.then5, %if.then2
  %22 = load ptr, ptr %retval, align 8
  ret ptr %22
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_add_child(ptr noundef %parent_bs, ptr noundef %child_bs, ptr noundef %errp) #0 {
entry:
  %parent_bs.addr = alloca ptr, align 8
  %child_bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  store ptr %parent_bs, ptr %parent_bs.addr, align 8
  store ptr %child_bs, ptr %child_bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 8332, ptr noundef @__PRETTY_FUNCTION__.bdrv_add_child) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %parent_bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %do.end
  %2 = load ptr, ptr %parent_bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv1, align 8
  %bdrv_add_child = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 53
  %4 = load ptr, ptr %bdrv_add_child, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.end5, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %do.end
  %5 = load ptr, ptr %errp.addr, align 8
  %6 = load ptr, ptr %parent_bs.addr, align 8
  %call4 = call ptr @bdrv_get_device_or_node_name(ptr noundef %6)
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %5, ptr noundef @.str.2, i32 noundef 8335, ptr noundef @__func__.bdrv_add_child, ptr noundef @.str.139, ptr noundef %call4)
  br label %return

if.end5:                                          ; preds = %lor.lhs.false
  %7 = load ptr, ptr %parent_bs.addr, align 8
  %drv6 = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 6
  %8 = load ptr, ptr %drv6, align 8
  %supports_zoned_children = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 5
  %9 = load i8, ptr %supports_zoned_children, align 1
  %tobool7 = trunc i8 %9 to i1
  br i1 %tobool7, label %if.end16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end5
  %10 = load ptr, ptr %child_bs.addr, align 8
  %bl = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 17
  %zoned = getelementptr inbounds %struct.BlockLimits, ptr %bl, i32 0, i32 13
  %11 = load i32, ptr %zoned, align 8
  %cmp = icmp eq i32 %11, 1
  br i1 %cmp, label %if.then8, label %if.end16

if.then8:                                         ; preds = %land.lhs.true
  %12 = load ptr, ptr %errp.addr, align 8
  %13 = load ptr, ptr %child_bs.addr, align 8
  %bl9 = getelementptr inbounds %struct.BlockDriverState, ptr %13, i32 0, i32 17
  %zoned10 = getelementptr inbounds %struct.BlockLimits, ptr %bl9, i32 0, i32 13
  %14 = load i32, ptr %zoned10, align 8
  %cmp11 = icmp eq i32 %14, 1
  %cond = select i1 %cmp11, ptr @.str.141, ptr @.str.142
  %15 = load ptr, ptr %parent_bs.addr, align 8
  %drv12 = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 6
  %16 = load ptr, ptr %drv12, align 8
  %supports_zoned_children13 = getelementptr inbounds %struct.BlockDriver, ptr %16, i32 0, i32 5
  %17 = load i8, ptr %supports_zoned_children13, align 1
  %tobool14 = trunc i8 %17 to i1
  %cond15 = select i1 %tobool14, ptr @.str.143, ptr @.str.144
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %12, ptr noundef @.str.2, i32 noundef 8354, ptr noundef @__func__.bdrv_add_child, ptr noundef @.str.140, ptr noundef %cond, ptr noundef %cond15)
  br label %return

if.end16:                                         ; preds = %land.lhs.true, %if.end5
  %18 = load ptr, ptr %child_bs.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %19 = load ptr, ptr %lh_first, align 8
  %cmp17 = icmp eq ptr %19, null
  br i1 %cmp17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.end16
  %20 = load ptr, ptr %errp.addr, align 8
  %21 = load ptr, ptr %child_bs.addr, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %21, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %20, ptr noundef @.str.2, i32 noundef 8360, ptr noundef @__func__.bdrv_add_child, ptr noundef @.str.145, ptr noundef %arraydecay)
  br label %return

if.end19:                                         ; preds = %if.end16
  %22 = load ptr, ptr %parent_bs.addr, align 8
  %drv20 = getelementptr inbounds %struct.BlockDriverState, ptr %22, i32 0, i32 6
  %23 = load ptr, ptr %drv20, align 8
  %bdrv_add_child21 = getelementptr inbounds %struct.BlockDriver, ptr %23, i32 0, i32 53
  %24 = load ptr, ptr %bdrv_add_child21, align 8
  %25 = load ptr, ptr %parent_bs.addr, align 8
  %26 = load ptr, ptr %child_bs.addr, align 8
  %27 = load ptr, ptr %errp.addr, align 8
  call void %24(ptr noundef %25, ptr noundef %26, ptr noundef %27)
  br label %return

return:                                           ; preds = %if.end19, %if.then18, %if.then8, %if.then3
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_del_child(ptr noundef %parent_bs, ptr noundef %child, ptr noundef %errp) #0 {
entry:
  %parent_bs.addr = alloca ptr, align 8
  %child.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  store ptr %parent_bs, ptr %parent_bs.addr, align 8
  store ptr %child, ptr %child.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 8371, ptr noundef @__PRETTY_FUNCTION__.bdrv_del_child) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %parent_bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %do.end
  %2 = load ptr, ptr %parent_bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv1, align 8
  %bdrv_del_child = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 54
  %4 = load ptr, ptr %bdrv_del_child, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.end5, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %do.end
  %5 = load ptr, ptr %errp.addr, align 8
  %6 = load ptr, ptr %parent_bs.addr, align 8
  %call4 = call ptr @bdrv_get_device_or_node_name(ptr noundef %6)
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %5, ptr noundef @.str.2, i32 noundef 8374, ptr noundef @__func__.bdrv_del_child, ptr noundef @.str.146, ptr noundef %call4)
  br label %return

if.end5:                                          ; preds = %lor.lhs.false
  %7 = load ptr, ptr %parent_bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %8 = load ptr, ptr %lh_first, align 8
  store ptr %8, ptr %tmp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %9 = load ptr, ptr %tmp, align 8
  %tobool6 = icmp ne ptr %9, null
  br i1 %tobool6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %tmp, align 8
  %11 = load ptr, ptr %child.addr, align 8
  %cmp = icmp eq ptr %10, %11
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %for.body
  br label %for.end

if.end8:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end8
  %12 = load ptr, ptr %tmp, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %12, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %13 = load ptr, ptr %le_next, align 8
  store ptr %13, ptr %tmp, align 8
  br label %for.cond, !llvm.loop !88

for.end:                                          ; preds = %if.then7, %for.cond
  %14 = load ptr, ptr %tmp, align 8
  %tobool9 = icmp ne ptr %14, null
  br i1 %tobool9, label %if.end13, label %if.then10

if.then10:                                        ; preds = %for.end
  %15 = load ptr, ptr %errp.addr, align 8
  %16 = load ptr, ptr %parent_bs.addr, align 8
  %call11 = call ptr @bdrv_get_device_or_node_name(ptr noundef %16)
  %17 = load ptr, ptr %child.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %17, i32 0, i32 0
  %18 = load ptr, ptr %bs, align 8
  %call12 = call ptr @bdrv_get_device_or_node_name(ptr noundef %18)
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %15, ptr noundef @.str.2, i32 noundef 8387, ptr noundef @__func__.bdrv_del_child, ptr noundef @.str.147, ptr noundef %call11, ptr noundef %call12)
  br label %return

if.end13:                                         ; preds = %for.end
  %19 = load ptr, ptr %parent_bs.addr, align 8
  %drv14 = getelementptr inbounds %struct.BlockDriverState, ptr %19, i32 0, i32 6
  %20 = load ptr, ptr %drv14, align 8
  %bdrv_del_child15 = getelementptr inbounds %struct.BlockDriver, ptr %20, i32 0, i32 54
  %21 = load ptr, ptr %bdrv_del_child15, align 8
  %22 = load ptr, ptr %parent_bs.addr, align 8
  %23 = load ptr, ptr %child.addr, align 8
  %24 = load ptr, ptr %errp.addr, align 8
  call void %21(ptr noundef %22, ptr noundef %23, ptr noundef %24)
  br label %return

return:                                           ; preds = %if.end13, %if.then10, %if.then3
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local i32 @bdrv_make_empty(ptr noundef %c, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %bs, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv1, align 8
  store ptr %2, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 8399, ptr noundef @__PRETTY_FUNCTION__.bdrv_make_empty) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %3 = load ptr, ptr %c.addr, align 8
  %perm = getelementptr inbounds %struct.BdrvChild, ptr %3, i32 0, i32 5
  %4 = load i64, ptr %perm, align 8
  %and = and i64 %4, 6
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then2, label %if.else3

if.then2:                                         ; preds = %do.end
  br label %if.end4

if.else3:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.148, ptr noundef @.str.2, i32 noundef 8400, ptr noundef @__PRETTY_FUNCTION__.bdrv_make_empty) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  %5 = load ptr, ptr %drv, align 8
  %bdrv_make_empty = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 29
  %6 = load ptr, ptr %bdrv_make_empty, align 8
  %tobool5 = icmp ne ptr %6, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end4
  %7 = load ptr, ptr %errp.addr, align 8
  %8 = load ptr, ptr %drv, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %format_name, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %7, ptr noundef @.str.2, i32 noundef 8404, ptr noundef @__func__.bdrv_make_empty, ptr noundef @.str.149, ptr noundef %9)
  store i32 -95, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.end4
  %10 = load ptr, ptr %drv, align 8
  %bdrv_make_empty8 = getelementptr inbounds %struct.BlockDriver, ptr %10, i32 0, i32 29
  %11 = load ptr, ptr %bdrv_make_empty8, align 8
  %12 = load ptr, ptr %c.addr, align 8
  %bs9 = getelementptr inbounds %struct.BdrvChild, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %bs9, align 8
  %call10 = call i32 %11(ptr noundef %13)
  store i32 %call10, ptr %ret, align 4
  %14 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %14, 0
  br i1 %cmp, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end7
  %15 = load ptr, ptr %errp.addr, align 8
  %16 = load i32, ptr %ret, align 4
  %sub = sub i32 0, %16
  %17 = load ptr, ptr %c.addr, align 8
  %bs12 = getelementptr inbounds %struct.BdrvChild, ptr %17, i32 0, i32 0
  %18 = load ptr, ptr %bs12, align 8
  %filename = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 11
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %filename, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %15, ptr noundef @.str.2, i32 noundef 8411, ptr noundef @__func__.bdrv_make_empty, i32 noundef %sub, ptr noundef @.str.150, ptr noundef %arraydecay)
  %19 = load i32, ptr %ret, align 4
  store i32 %19, ptr %retval, align 4
  br label %return

if.end13:                                         ; preds = %if.end7
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end13, %if.then11, %if.then6
  %20 = load i32, ptr %retval, align 4
  ret i32 %20
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_filter_child(ptr noundef %bs) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %do.end
  %1 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 6
  %2 = load ptr, ptr %drv, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %do.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load ptr, ptr %bs.addr, align 8
  %drv2 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv2, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %4, i32 0, i32 2
  %5 = load i8, ptr %is_filter, align 4
  %tobool3 = trunc i8 %5 to i1
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end5:                                          ; preds = %if.end
  %6 = load ptr, ptr %bs.addr, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 30
  %7 = load ptr, ptr %backing, align 8
  %tobool6 = icmp ne ptr %7, null
  br i1 %tobool6, label %land.lhs.true, label %if.then8

land.lhs.true:                                    ; preds = %if.end5
  %8 = load ptr, ptr %bs.addr, align 8
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 31
  %9 = load ptr, ptr %file, align 8
  %tobool7 = icmp ne ptr %9, null
  br i1 %tobool7, label %if.else, label %if.then8

if.then8:                                         ; preds = %land.lhs.true, %if.end5
  br label %if.end9

if.else:                                          ; preds = %land.lhs.true
  call void @__assert_fail(ptr noundef @.str.152, ptr noundef @.str.2, i32 noundef 8460, ptr noundef @__PRETTY_FUNCTION__.bdrv_filter_child) #16
  unreachable

if.end9:                                          ; preds = %if.then8
  %10 = load ptr, ptr %bs.addr, align 8
  %backing10 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 30
  %11 = load ptr, ptr %backing10, align 8
  %tobool11 = icmp ne ptr %11, null
  br i1 %tobool11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end9
  br label %cond.end

cond.false:                                       ; preds = %if.end9
  %12 = load ptr, ptr %bs.addr, align 8
  %file12 = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 31
  %13 = load ptr, ptr %file12, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %11, %cond.true ], [ %13, %cond.false ]
  store ptr %cond, ptr %c, align 8
  %14 = load ptr, ptr %c, align 8
  %tobool13 = icmp ne ptr %14, null
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %cond.end
  store ptr null, ptr %retval, align 8
  br label %return

if.end15:                                         ; preds = %cond.end
  %15 = load ptr, ptr %c, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %15, i32 0, i32 3
  %16 = load i32, ptr %role, align 8
  %and = and i32 %16, 4
  %tobool16 = icmp ne i32 %and, 0
  br i1 %tobool16, label %if.then17, label %if.else18

if.then17:                                        ; preds = %if.end15
  br label %if.end19

if.else18:                                        ; preds = %if.end15
  call void @__assert_fail(ptr noundef @.str.153, ptr noundef @.str.2, i32 noundef 8467, ptr noundef @__PRETTY_FUNCTION__.bdrv_filter_child) #16
  unreachable

if.end19:                                         ; preds = %if.then17
  %17 = load ptr, ptr %c, align 8
  store ptr %17, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end19, %if.then14, %if.then4, %if.then
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local ptr @bdrv_primary_child(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  %found = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr null, ptr %found, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %1 = load ptr, ptr %lh_first, align 8
  store ptr %1, ptr %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %2 = load ptr, ptr %c, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %c, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %3, i32 0, i32 3
  %4 = load i32, ptr %role, align 8
  %and = and i32 %4, 16
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.end4

if.then:                                          ; preds = %for.body
  %5 = load ptr, ptr %found, align 8
  %tobool2 = icmp ne ptr %5, null
  br i1 %tobool2, label %if.else, label %if.then3

if.then3:                                         ; preds = %if.then
  br label %if.end

if.else:                                          ; preds = %if.then
  call void @__assert_fail(ptr noundef @.str.155, ptr noundef @.str.2, i32 noundef 8506, ptr noundef @__PRETTY_FUNCTION__.bdrv_primary_child) #16
  unreachable

if.end:                                           ; preds = %if.then3
  %6 = load ptr, ptr %c, align 8
  store ptr %6, ptr %found, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end4
  %7 = load ptr, ptr %c, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %7, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %8 = load ptr, ptr %le_next, align 8
  store ptr %8, ptr %c, align 8
  br label %for.cond, !llvm.loop !89

for.end:                                          ; preds = %for.cond
  %9 = load ptr, ptr %found, align 8
  ret ptr %9
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_do_skip_filters(ptr noundef %bs, i1 noundef zeroext %stop_on_explicit_filter) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %stop_on_explicit_filter.addr = alloca i8, align 1
  %c = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %frombool = zext i1 %stop_on_explicit_filter to i8
  store i8 %frombool, ptr %stop_on_explicit_filter.addr, align 1
  %0 = load ptr, ptr %bs.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr null, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end11, %if.end
  %1 = load i8, ptr %stop_on_explicit_filter.addr, align 1
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %2 = load ptr, ptr %bs.addr, align 8
  %implicit = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 5
  %3 = load i8, ptr %implicit, align 8
  %tobool2 = trunc i8 %3 to i1
  %lnot = xor i1 %tobool2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %4 = phi i1 [ false, %while.cond ], [ %lnot, %land.rhs ]
  %lnot3 = xor i1 %4, true
  br i1 %lnot3, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %5 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_filter_child(ptr noundef %5)
  store ptr %call, ptr %c, align 8
  %6 = load ptr, ptr %c, align 8
  %tobool4 = icmp ne ptr %6, null
  br i1 %tobool4, label %if.end11, label %if.then5

if.then5:                                         ; preds = %while.body
  %7 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 6
  %8 = load ptr, ptr %drv, align 8
  %tobool6 = icmp ne ptr %8, null
  br i1 %tobool6, label %lor.lhs.false, label %if.then9

lor.lhs.false:                                    ; preds = %if.then5
  %9 = load ptr, ptr %bs.addr, align 8
  %drv7 = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 6
  %10 = load ptr, ptr %drv7, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %10, i32 0, i32 2
  %11 = load i8, ptr %is_filter, align 4
  %tobool8 = trunc i8 %11 to i1
  br i1 %tobool8, label %if.else, label %if.then9

if.then9:                                         ; preds = %lor.lhs.false, %if.then5
  br label %if.end10

if.else:                                          ; preds = %lor.lhs.false
  call void @__assert_fail(ptr noundef @.str.291, ptr noundef @.str.2, i32 noundef 8532, ptr noundef @__PRETTY_FUNCTION__.bdrv_do_skip_filters) #16
  unreachable

if.end10:                                         ; preds = %if.then9
  br label %while.end

if.end11:                                         ; preds = %while.body
  %12 = load ptr, ptr %c, align 8
  %bs12 = getelementptr inbounds %struct.BdrvChild, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %bs12, align 8
  store ptr %13, ptr %bs.addr, align 8
  br label %while.cond, !llvm.loop !90

while.end:                                        ; preds = %if.end10, %land.end
  %14 = load ptr, ptr %bs.addr, align 8
  store ptr %14, ptr %retval, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  %15 = load ptr, ptr %retval, align 8
  ret ptr %15
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_cow_bs(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_cow_child(ptr noundef %0)
  %call1 = call ptr @child_bs(ptr noundef %call)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local zeroext i1 @bdrv_bsc_is_data(ptr noundef %bs, i64 noundef %offset, ptr noundef %pnum) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %pnum.addr = alloca ptr, align 8
  %_rcu_read_auto = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store ptr %pnum, ptr %pnum.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %call = call ptr @rcu_read_auto_lock()
  store ptr %call, ptr %_rcu_read_auto, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %1 = load i64, ptr %offset.addr, align 8
  %2 = load ptr, ptr %pnum.addr, align 8
  %call1 = call zeroext i1 @bdrv_bsc_range_overlaps_locked(ptr noundef %0, i64 noundef %1, i64 noundef 1, ptr noundef %2)
  call void @glib_autoptr_cleanup_RCUReadAuto(ptr noundef %_rcu_read_auto)
  ret i1 %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @rcu_read_auto_lock() #0 {
entry:
  call void @rcu_read_lock()
  ret ptr inttoptr (i64 1 to ptr)
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_cleanup_RCUReadAuto(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %1 = load ptr, ptr %0, align 8
  call void @glib_autoptr_clear_RCUReadAuto(ptr noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_bsc_range_overlaps_locked(ptr noundef %bs, i64 noundef %offset, i64 noundef %bytes, ptr noundef %pnum) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %bytes.addr = alloca i64, align 8
  %pnum.addr = alloca ptr, align 8
  %bsc = alloca ptr, align 8
  %_val75 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %overlaps = alloca i8, align 1
  %tmp6 = alloca i8, align 1
  %atomic-temp = alloca i8, align 1
  store ptr %bs, ptr %bs.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %bytes, ptr %bytes.addr, align 8
  store ptr %pnum, ptr %pnum.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %do.end, %entry
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.2, i32 noundef 8591, ptr noundef @__func__.bdrv_bsc_range_overlaps_locked, ptr noundef null) #18
  unreachable

do.end:                                           ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %0 = load ptr, ptr %bs.addr, align 8
  %block_status_cache = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 55
  %1 = load atomic i64, ptr %block_status_cache monotonic, align 8
  store i64 %1, ptr %_val75, align 8
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #15, !srcloc !91
  %2 = load ptr, ptr %_val75, align 8
  store ptr %2, ptr %tmp, align 8
  %3 = load ptr, ptr %tmp, align 8
  store ptr %3, ptr %bsc, align 8
  br label %while.cond1

while.cond1:                                      ; preds = %do.end4, %while.end
  br i1 false, label %while.body2, label %while.end5

while.body2:                                      ; preds = %while.cond1
  br label %do.body3

do.body3:                                         ; preds = %while.body2
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.2, i32 noundef 8595, ptr noundef @__func__.bdrv_bsc_range_overlaps_locked, ptr noundef null) #18
  unreachable

do.end4:                                          ; No predecessors!
  br label %while.cond1

while.end5:                                       ; preds = %while.cond1
  %4 = load ptr, ptr %bsc, align 8
  %valid = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %4, i32 0, i32 1
  %5 = load atomic i8, ptr %valid monotonic, align 8
  store i8 %5, ptr %atomic-temp, align 1
  %6 = load i8, ptr %atomic-temp, align 1
  %tobool = trunc i8 %6 to i1
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %tmp6, align 1
  %7 = load i8, ptr %tmp6, align 1
  %tobool7 = trunc i8 %7 to i1
  br i1 %tobool7, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.end5
  %8 = load i64, ptr %offset.addr, align 8
  %9 = load i64, ptr %bytes.addr, align 8
  %10 = load ptr, ptr %bsc, align 8
  %data_start = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %10, i32 0, i32 2
  %11 = load i64, ptr %data_start, align 8
  %12 = load ptr, ptr %bsc, align 8
  %data_end = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %12, i32 0, i32 3
  %13 = load i64, ptr %data_end, align 8
  %14 = load ptr, ptr %bsc, align 8
  %data_start8 = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %14, i32 0, i32 2
  %15 = load i64, ptr %data_start8, align 8
  %sub = sub i64 %13, %15
  %call = call i32 @ranges_overlap(i64 noundef %8, i64 noundef %9, i64 noundef %11, i64 noundef %sub)
  %tobool9 = icmp ne i32 %call, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.end5
  %16 = phi i1 [ false, %while.end5 ], [ %tobool9, %land.rhs ]
  %frombool10 = zext i1 %16 to i8
  store i8 %frombool10, ptr %overlaps, align 1
  %17 = load i8, ptr %overlaps, align 1
  %tobool11 = trunc i8 %17 to i1
  br i1 %tobool11, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %land.end
  %18 = load ptr, ptr %pnum.addr, align 8
  %tobool12 = icmp ne ptr %18, null
  br i1 %tobool12, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %19 = load ptr, ptr %bsc, align 8
  %data_end13 = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %19, i32 0, i32 3
  %20 = load i64, ptr %data_end13, align 8
  %21 = load i64, ptr %offset.addr, align 8
  %sub14 = sub i64 %20, %21
  %22 = load ptr, ptr %pnum.addr, align 8
  store i64 %sub14, ptr %22, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %land.end
  %23 = load i8, ptr %overlaps, align 1
  %tobool15 = trunc i8 %23 to i1
  ret i1 %tobool15
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_bsc_invalidate_range(ptr noundef %bs, i64 noundef %offset, i64 noundef %bytes) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %bytes.addr = alloca i64, align 8
  %_rcu_read_auto = alloca ptr, align 8
  %.atomictmp = alloca i8, align 1
  store ptr %bs, ptr %bs.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %bytes, ptr %bytes.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %call = call ptr @rcu_read_auto_lock()
  store ptr %call, ptr %_rcu_read_auto, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %1 = load i64, ptr %offset.addr, align 8
  %2 = load i64, ptr %bytes.addr, align 8
  %call1 = call zeroext i1 @bdrv_bsc_range_overlaps_locked(ptr noundef %0, i64 noundef %1, i64 noundef %2, ptr noundef null)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  br label %do.body2

do.body2:                                         ; preds = %if.then
  br label %while.cond

while.cond:                                       ; preds = %do.end4, %do.body2
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body3

do.body3:                                         ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.2, i32 noundef 8626, ptr noundef @__func__.bdrv_bsc_invalidate_range, ptr noundef null) #18
  unreachable

do.cond:                                          ; No predecessors!
  br label %do.end4

do.end4:                                          ; preds = %do.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %3 = load ptr, ptr %bs.addr, align 8
  %block_status_cache = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 55
  %4 = load ptr, ptr %block_status_cache, align 8
  %valid = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %4, i32 0, i32 1
  store i8 0, ptr %.atomictmp, align 1
  %5 = load i8, ptr %.atomictmp, align 1
  store atomic i8 %5, ptr %valid monotonic, align 8
  br label %do.cond5

do.cond5:                                         ; preds = %while.end
  br label %do.end6

do.end6:                                          ; preds = %do.cond5
  br label %if.end

if.end:                                           ; preds = %do.end6, %do.end
  call void @glib_autoptr_cleanup_RCUReadAuto(ptr noundef %_rcu_read_auto)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define dso_local void @bdrv_bsc_fill(ptr noundef %bs, i64 noundef %offset, i64 noundef %bytes) #0 {
entry:
  %x.addr.i = alloca ptr, align 8
  %lockable.addr.i = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %offset.addr = alloca i64, align 8
  %bytes.addr = alloca i64, align 8
  %new_bsc = alloca ptr, align 8
  %old_bsc = alloca ptr, align 8
  %.compoundliteral = alloca %struct.BdrvBlockStatusCache, align 8
  %qemu_lockable_auto76 = alloca ptr, align 8
  %.compoundliteral1 = alloca %struct.QemuLockable, align 8
  %_val77 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %.atomictmp = alloca ptr, align 8
  %tmp17 = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %bytes, ptr %bytes.addr, align 8
  %call = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 40) #17
  store ptr %call, ptr %new_bsc, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load ptr, ptr %new_bsc, align 8
  %rcu = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %.compoundliteral, i32 0, i32 0
  call void @llvm.memset.p0.i64(ptr align 8 %rcu, i8 0, i64 16, i1 false)
  %valid = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %.compoundliteral, i32 0, i32 1
  store i8 1, ptr %valid, align 8
  %data_start = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %.compoundliteral, i32 0, i32 2
  %1 = load i64, ptr %offset.addr, align 8
  store i64 %1, ptr %data_start, align 8
  %data_end = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %.compoundliteral, i32 0, i32 3
  %2 = load i64, ptr %offset.addr, align 8
  %3 = load i64, ptr %bytes.addr, align 8
  %add = add i64 %2, %3
  store i64 %add, ptr %data_end, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %0, ptr align 8 %.compoundliteral, i64 40, i1 false)
  %4 = load ptr, ptr %bs.addr, align 8
  %bsc_modify_lock = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 54
  %object = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral1, i32 0, i32 0
  %5 = load ptr, ptr %bs.addr, align 8
  %bsc_modify_lock2 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 54
  store ptr %bsc_modify_lock2, ptr %object, align 8
  %lock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral1, i32 0, i32 1
  store ptr @qemu_co_mutex_lock, ptr %lock, align 8
  %unlock = getelementptr inbounds %struct.QemuLockable, ptr %.compoundliteral1, i32 0, i32 2
  store ptr @qemu_co_mutex_unlock, ptr %unlock, align 8
  store ptr %bsc_modify_lock, ptr %x.addr.i, align 8
  store ptr %.compoundliteral1, ptr %lockable.addr.i, align 8
  %6 = load ptr, ptr %x.addr.i, align 8
  %tobool.i = icmp ne ptr %6, null
  br i1 %tobool.i, label %cond.true.i, label %cond.false.i

cond.true.i:                                      ; preds = %do.end
  %7 = load ptr, ptr %lockable.addr.i, align 8
  br label %qemu_make_lockable.exit

cond.false.i:                                     ; preds = %do.end
  br label %qemu_make_lockable.exit

qemu_make_lockable.exit:                          ; preds = %cond.false.i, %cond.true.i
  %cond.i = phi ptr [ %7, %cond.true.i ], [ null, %cond.false.i ]
  %call4 = call ptr @qemu_lockable_auto_lock(ptr noundef %cond.i)
  store ptr %call4, ptr %qemu_lockable_auto76, align 8
  br label %while.cond

while.cond:                                       ; preds = %do.end6, %qemu_make_lockable.exit
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body5

do.body5:                                         ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.2, i32 noundef 8647, ptr noundef @__func__.bdrv_bsc_fill, ptr noundef null) #18
  unreachable

do.cond:                                          ; No predecessors!
  br label %do.end6

do.end6:                                          ; preds = %do.cond
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %8 = load ptr, ptr %bs.addr, align 8
  %block_status_cache = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 55
  %9 = load atomic i64, ptr %block_status_cache monotonic, align 8
  store i64 %9, ptr %_val77, align 8
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #15, !srcloc !92
  %10 = load ptr, ptr %_val77, align 8
  store ptr %10, ptr %tmp, align 8
  %11 = load ptr, ptr %tmp, align 8
  store ptr %11, ptr %old_bsc, align 8
  br label %do.body7

do.body7:                                         ; preds = %while.end
  br label %while.cond8

while.cond8:                                      ; preds = %do.end12, %do.body7
  br i1 false, label %while.body9, label %while.end13

while.body9:                                      ; preds = %while.cond8
  br label %do.body10

do.body10:                                        ; preds = %while.body9
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.2, i32 noundef 8648, ptr noundef @__func__.bdrv_bsc_fill, ptr noundef null) #18
  unreachable

do.cond11:                                        ; No predecessors!
  br label %do.end12

do.end12:                                         ; preds = %do.cond11
  br label %while.cond8

while.end13:                                      ; preds = %while.cond8
  %12 = load ptr, ptr %bs.addr, align 8
  %block_status_cache14 = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 55
  %13 = load ptr, ptr %new_bsc, align 8
  store ptr %13, ptr %.atomictmp, align 8
  %14 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %14, ptr %block_status_cache14 release, align 8
  br label %do.cond15

do.cond15:                                        ; preds = %while.end13
  br label %do.end16

do.end16:                                         ; preds = %do.cond15
  %15 = load ptr, ptr %old_bsc, align 8
  %tobool = icmp ne ptr %15, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.end16
  %16 = load ptr, ptr %old_bsc, align 8
  %rcu18 = getelementptr inbounds %struct.BdrvBlockStatusCache, ptr %16, i32 0, i32 0
  store ptr %rcu18, ptr %tmp17, align 8
  %17 = load ptr, ptr %tmp17, align 8
  call void @call_rcu1(ptr noundef %17, ptr noundef @g_free)
  br label %if.end

if.end:                                           ; preds = %if.then, %do.end16
  call void @glib_autoptr_cleanup_QemuLockable(ptr noundef %qemu_lockable_auto76)
  ret void
}

declare void @qemu_co_mutex_lock(ptr noundef) #2

declare void @qemu_co_mutex_unlock(ptr noundef) #2

declare void @call_rcu1(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind willreturn memory(none)
declare i32 @getpagesize() #9

declare noalias ptr @g_strconcat(ptr noundef, ...) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @error_propagator_cleanup(ptr noundef %prop) #0 {
entry:
  %prop.addr = alloca ptr, align 8
  store ptr %prop, ptr %prop.addr, align 8
  %0 = load ptr, ptr %prop.addr, align 8
  %errp = getelementptr inbounds %struct.ErrorPropagator, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %errp, align 8
  %2 = load ptr, ptr %prop.addr, align 8
  %local_err = getelementptr inbounds %struct.ErrorPropagator, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %1, ptr noundef %3)
  ret void
}

declare i32 @blk_co_truncate(ptr noundef, i64 noundef, i1 noundef zeroext, i32 noundef, i32 noundef, ptr noundef) #2

declare i64 @blk_co_getlength(ptr noundef) #2

declare i32 @blk_co_pwrite_zeroes(ptr noundef, i64 noundef, i64 noundef, i32 noundef) #2

declare void @qobject_destroy(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_clear_GraphLockableMainloop(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %_ptr.addr, align 8
  call void @graph_lockable_auto_unlock_mainloop(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @graph_lockable_auto_unlock_mainloop(ptr noundef %x) #0 {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  call void @bdrv_graph_rdunlock_main_loop()
  ret void
}

declare void @qdict_copy_default(ptr noundef, ptr noundef, ptr noundef) #2

declare void @assert_bdrv_graph_writable() #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_backing_attach(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %parent = alloca ptr, align 8
  %backing_hd = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %parent, align 8
  %2 = load ptr, ptr %c.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %bs, align 8
  store ptr %3, ptr %backing_hd, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1265, ptr noundef @__PRETTY_FUNCTION__.bdrv_backing_attach) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %4 = load ptr, ptr %parent, align 8
  %backing_blocker = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 36
  %5 = load ptr, ptr %backing_blocker, align 8
  %tobool = icmp ne ptr %5, null
  br i1 %tobool, label %if.else2, label %if.then1

if.then1:                                         ; preds = %do.end
  br label %if.end3

if.else2:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.171, ptr noundef @.str.2, i32 noundef 1266, ptr noundef @__PRETTY_FUNCTION__.bdrv_backing_attach) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  %6 = load ptr, ptr %parent, align 8
  %backing_blocker4 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 36
  %7 = load ptr, ptr %parent, align 8
  %call5 = call ptr @bdrv_get_device_or_node_name(ptr noundef %7)
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %backing_blocker4, ptr noundef @.str.2, i32 noundef 1269, ptr noundef @__func__.bdrv_backing_attach, ptr noundef @.str.172, ptr noundef %call5)
  %8 = load ptr, ptr %backing_hd, align 8
  call void @bdrv_refresh_filename(ptr noundef %8)
  %9 = load ptr, ptr %parent, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 0
  %10 = load i32, ptr %open_flags, align 8
  %and = and i32 %10, -257
  store i32 %and, ptr %open_flags, align 8
  %11 = load ptr, ptr %backing_hd, align 8
  %12 = load ptr, ptr %parent, align 8
  %backing_blocker6 = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 36
  %13 = load ptr, ptr %backing_blocker6, align 8
  call void @bdrv_op_block_all(ptr noundef %11, ptr noundef %13)
  %14 = load ptr, ptr %backing_hd, align 8
  %15 = load ptr, ptr %parent, align 8
  %backing_blocker7 = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 36
  %16 = load ptr, ptr %backing_blocker7, align 8
  call void @bdrv_op_unblock(ptr noundef %14, i32 noundef 4, ptr noundef %16)
  %17 = load ptr, ptr %backing_hd, align 8
  %18 = load ptr, ptr %parent, align 8
  %backing_blocker8 = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 36
  %19 = load ptr, ptr %backing_blocker8, align 8
  call void @bdrv_op_unblock(ptr noundef %17, i32 noundef 14, ptr noundef %19)
  %20 = load ptr, ptr %backing_hd, align 8
  %21 = load ptr, ptr %parent, align 8
  %backing_blocker9 = getelementptr inbounds %struct.BlockDriverState, ptr %21, i32 0, i32 36
  %22 = load ptr, ptr %backing_blocker9, align 8
  call void @bdrv_op_unblock(ptr noundef %20, i32 noundef 0, ptr noundef %22)
  %23 = load ptr, ptr %backing_hd, align 8
  %24 = load ptr, ptr %parent, align 8
  %backing_blocker10 = getelementptr inbounds %struct.BlockDriverState, ptr %24, i32 0, i32 36
  %25 = load ptr, ptr %backing_blocker10, align 8
  call void @bdrv_op_unblock(ptr noundef %23, i32 noundef 1, ptr noundef %25)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_backing_detach(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  %parent = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %parent, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1304, ptr noundef @__PRETTY_FUNCTION__.bdrv_backing_detach) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %parent, align 8
  %backing_blocker = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 36
  %3 = load ptr, ptr %backing_blocker, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.end
  br label %if.end3

if.else2:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.174, ptr noundef @.str.2, i32 noundef 1305, ptr noundef @__PRETTY_FUNCTION__.bdrv_backing_detach) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  %4 = load ptr, ptr %c.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %bs, align 8
  %6 = load ptr, ptr %parent, align 8
  %backing_blocker4 = getelementptr inbounds %struct.BlockDriverState, ptr %6, i32 0, i32 36
  %7 = load ptr, ptr %backing_blocker4, align 8
  call void @bdrv_op_unblock_all(ptr noundef %5, ptr noundef %7)
  %8 = load ptr, ptr %parent, align 8
  %backing_blocker5 = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 36
  %9 = load ptr, ptr %backing_blocker5, align 8
  call void @error_free(ptr noundef %9)
  %10 = load ptr, ptr %parent, align 8
  %backing_blocker6 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 36
  store ptr null, ptr %backing_blocker6, align 8
  ret void
}

declare void @bdrv_do_drained_begin_quiesce(ptr noundef, ptr noundef) #2

declare zeroext i1 @bdrv_drain_poll(ptr noundef, ptr noundef, i1 noundef zeroext) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_backing_update_filename(ptr noundef %c, ptr noundef %base, ptr noundef %filename, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca ptr, align 8
  %base.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %parent = alloca ptr, align 8
  %read_only = alloca i8, align 1
  %ret = alloca i32, align 4
  store ptr %c, ptr %c.addr, align 8
  store ptr %base, ptr %base.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %opaque = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 4
  %1 = load ptr, ptr %opaque, align 8
  store ptr %1, ptr %parent, align 8
  %2 = load ptr, ptr %parent, align 8
  %call = call zeroext i1 @bdrv_is_read_only(ptr noundef %2)
  %frombool = zext i1 %call to i8
  store i8 %frombool, ptr %read_only, align 1
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1317, ptr noundef @__PRETTY_FUNCTION__.bdrv_backing_update_filename) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %3 = load i8, ptr %read_only, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then2, label %if.end6

if.then2:                                         ; preds = %do.end
  %4 = load ptr, ptr %parent, align 8
  %5 = load ptr, ptr %errp.addr, align 8
  %call3 = call i32 @bdrv_reopen_set_read_only(ptr noundef %4, i1 noundef zeroext false, ptr noundef %5)
  store i32 %call3, ptr %ret, align 4
  %6 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %6, 0
  br i1 %cmp, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.then2
  %7 = load i32, ptr %ret, align 4
  store i32 %7, ptr %retval, align 4
  br label %return

if.end5:                                          ; preds = %if.then2
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %do.end
  %8 = load ptr, ptr %parent, align 8
  %9 = load ptr, ptr %filename.addr, align 8
  %10 = load ptr, ptr %base.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 6
  %11 = load ptr, ptr %drv, align 8
  %tobool7 = icmp ne ptr %11, null
  br i1 %tobool7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end6
  %12 = load ptr, ptr %base.addr, align 8
  %drv8 = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 6
  %13 = load ptr, ptr %drv8, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %13, i32 0, i32 0
  %14 = load ptr, ptr %format_name, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end6
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %14, %cond.true ], [ @.str.95, %cond.false ]
  %call9 = call i32 @bdrv_change_backing_file(ptr noundef %8, ptr noundef %9, ptr noundef %cond, i1 noundef zeroext false)
  store i32 %call9, ptr %ret, align 4
  %15 = load i32, ptr %ret, align 4
  %cmp10 = icmp slt i32 %15, 0
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %cond.end
  %16 = load ptr, ptr %errp.addr, align 8
  %17 = load i32, ptr %ret, align 4
  %sub = sub i32 0, %17
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %16, ptr noundef @.str.2, i32 noundef 1330, ptr noundef @__func__.bdrv_backing_update_filename, i32 noundef %sub, ptr noundef @.str.175)
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %cond.end
  %18 = load i8, ptr %read_only, align 1
  %tobool13 = trunc i8 %18 to i1
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end12
  %19 = load ptr, ptr %parent, align 8
  %call15 = call i32 @bdrv_reopen_set_read_only(ptr noundef %19, i1 noundef zeroext true, ptr noundef null)
  br label %if.end16

if.end16:                                         ; preds = %if.then14, %if.end12
  %20 = load i32, ptr %ret, align 4
  store i32 %20, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end16, %if.then4
  %21 = load i32, ptr %retval, align 4
  ret i32 %21
}

declare i32 @bdrv_change_backing_file(ptr noundef, ptr noundef, ptr noundef, i1 noundef zeroext) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_assign_node_name(ptr noundef %bs, ptr noundef %node_name, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %node_name.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %gen_node_name = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %node_name, ptr %node_name.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %gen_node_name, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1580, ptr noundef @__PRETTY_FUNCTION__.bdrv_assign_node_name) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %node_name.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.else3, label %if.then1

if.then1:                                         ; preds = %do.end
  %call2 = call ptr @id_generate(i32 noundef 1)
  store ptr %call2, ptr %gen_node_name, align 8
  store ptr %call2, ptr %node_name.addr, align 8
  br label %if.end7

if.else3:                                         ; preds = %do.end
  %1 = load ptr, ptr %node_name.addr, align 8
  %call4 = call zeroext i1 @id_wellformed(ptr noundef %1)
  br i1 %call4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.else3
  %2 = load ptr, ptr %errp.addr, align 8
  %3 = load ptr, ptr %node_name.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %2, ptr noundef @.str.2, i32 noundef 1589, ptr noundef @__func__.bdrv_assign_node_name, ptr noundef @.str.184, ptr noundef %3)
  br label %return

if.end6:                                          ; preds = %if.else3
  br label %if.end7

if.end7:                                          ; preds = %if.end6, %if.then1
  %4 = load ptr, ptr %node_name.addr, align 8
  %call8 = call ptr @blk_by_name(ptr noundef %4)
  %tobool9 = icmp ne ptr %call8, null
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  %5 = load ptr, ptr %errp.addr, align 8
  %6 = load ptr, ptr %node_name.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %5, ptr noundef @.str.2, i32 noundef 1596, ptr noundef @__func__.bdrv_assign_node_name, ptr noundef @.str.185, ptr noundef %6)
  br label %out

if.end11:                                         ; preds = %if.end7
  %7 = load ptr, ptr %node_name.addr, align 8
  %call12 = call ptr @bdrv_find_node(ptr noundef %7)
  %tobool13 = icmp ne ptr %call12, null
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end11
  %8 = load ptr, ptr %errp.addr, align 8
  %9 = load ptr, ptr %node_name.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %8, ptr noundef @.str.2, i32 noundef 1602, ptr noundef @__func__.bdrv_assign_node_name, ptr noundef @.str.186, ptr noundef %9)
  br label %out

if.end15:                                         ; preds = %if.end11
  %10 = load ptr, ptr %node_name.addr, align 8
  %call16 = call i64 @strlen(ptr noundef %10) #13
  %cmp = icmp uge i64 %call16, 32
  br i1 %cmp, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  %11 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %11, ptr noundef @.str.2, i32 noundef 1608, ptr noundef @__func__.bdrv_assign_node_name, ptr noundef @.str.187)
  br label %out

if.end18:                                         ; preds = %if.end15
  %12 = load ptr, ptr %bs.addr, align 8
  %node_name19 = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name19, i64 0, i64 0
  %13 = load ptr, ptr %node_name.addr, align 8
  call void @pstrcpy(ptr noundef %arraydecay, i32 noundef 32, ptr noundef %13)
  br label %do.body20

do.body20:                                        ; preds = %if.end18
  %14 = load ptr, ptr %bs.addr, align 8
  %node_list = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 23
  store ptr null, ptr %node_list, align 8
  %15 = load ptr, ptr getelementptr inbounds (%struct.QTailQLink, ptr @graph_bdrv_states, i32 0, i32 1), align 8
  %16 = load ptr, ptr %bs.addr, align 8
  %node_list21 = getelementptr inbounds %struct.BlockDriverState, ptr %16, i32 0, i32 23
  %tql_prev = getelementptr inbounds %struct.QTailQLink, ptr %node_list21, i32 0, i32 1
  store ptr %15, ptr %tql_prev, align 8
  %17 = load ptr, ptr %bs.addr, align 8
  %18 = load ptr, ptr getelementptr inbounds (%struct.QTailQLink, ptr @graph_bdrv_states, i32 0, i32 1), align 8
  %tql_next = getelementptr inbounds %struct.QTailQLink, ptr %18, i32 0, i32 0
  store ptr %17, ptr %tql_next, align 8
  %19 = load ptr, ptr %bs.addr, align 8
  %node_list22 = getelementptr inbounds %struct.BlockDriverState, ptr %19, i32 0, i32 23
  store ptr %node_list22, ptr getelementptr inbounds (%struct.QTailQLink, ptr @graph_bdrv_states, i32 0, i32 1), align 8
  br label %do.end23

do.end23:                                         ; preds = %do.body20
  br label %out

out:                                              ; preds = %do.end23, %if.then17, %if.then14, %if.then10
  %20 = load ptr, ptr %gen_node_name, align 8
  call void @g_free(ptr noundef %20)
  br label %return

return:                                           ; preds = %out, %if.then5
  ret void
}

; Function Attrs: allocsize(0)
declare noalias ptr @g_malloc0(i64 noundef) #3

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @is_power_of_2(i64 noundef %value) #0 {
entry:
  %retval = alloca i1, align 1
  %value.addr = alloca i64, align 8
  store i64 %value, ptr %value.addr, align 8
  %0 = load i64, ptr %value.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, ptr %value.addr, align 8
  %2 = load i64, ptr %value.addr, align 8
  %sub = sub i64 %2, 1
  %and = and i64 %1, %sub
  %tobool1 = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool1, true
  store i1 %lnot, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i1, ptr %retval, align 1
  ret i1 %3
}

declare ptr @id_generate(i32 noundef) #2

declare zeroext i1 @id_wellformed(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_reopen_get_flags(ptr noundef %q, ptr noundef %bs) #0 {
entry:
  %retval = alloca i32, align 4
  %q.addr = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %entry1 = alloca ptr, align 8
  store ptr %q, ptr %q.addr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %q.addr, align 8
  %cmp = icmp ne ptr %0, null
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %q.addr, align 8
  %2 = load ptr, ptr %1, align 8
  store ptr %2, ptr %entry1, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load ptr, ptr %entry1, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load ptr, ptr %entry1, align 8
  %state = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %4, i32 0, i32 1
  %bs2 = getelementptr inbounds %struct.BDRVReopenState, ptr %state, i32 0, i32 0
  %5 = load ptr, ptr %bs2, align 8
  %6 = load ptr, ptr %bs.addr, align 8
  %cmp3 = icmp eq ptr %5, %6
  br i1 %cmp3, label %if.then4, label %if.end

if.then4:                                         ; preds = %for.body
  %7 = load ptr, ptr %entry1, align 8
  %state5 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %7, i32 0, i32 1
  %flags = getelementptr inbounds %struct.BDRVReopenState, ptr %state5, i32 0, i32 1
  %8 = load i32, ptr %flags, align 8
  store i32 %8, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load ptr, ptr %entry1, align 8
  %entry6 = getelementptr inbounds %struct.BlockReopenQueueEntry, ptr %9, i32 0, i32 2
  %10 = load ptr, ptr %entry6, align 8
  store ptr %10, ptr %entry1, align 8
  br label %for.cond, !llvm.loop !93

for.end:                                          ; preds = %for.cond
  br label %if.end7

if.end7:                                          ; preds = %for.end, %entry
  %11 = load ptr, ptr %bs.addr, align 8
  %open_flags = getelementptr inbounds %struct.BlockDriverState, ptr %11, i32 0, i32 0
  %12 = load i32, ptr %open_flags, align 8
  store i32 %12, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then4
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

declare void @tran_add(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_child_set_perm_abort(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %s, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2314, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_set_perm_abort) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load ptr, ptr %s, align 8
  %old_perm = getelementptr inbounds %struct.BdrvChildSetPermState, ptr %1, i32 0, i32 1
  %2 = load i64, ptr %old_perm, align 8
  %3 = load ptr, ptr %s, align 8
  %child = getelementptr inbounds %struct.BdrvChildSetPermState, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %child, align 8
  %perm = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 5
  store i64 %2, ptr %perm, align 8
  %5 = load ptr, ptr %s, align 8
  %old_shared_perm = getelementptr inbounds %struct.BdrvChildSetPermState, ptr %5, i32 0, i32 2
  %6 = load i64, ptr %old_shared_perm, align 8
  %7 = load ptr, ptr %s, align 8
  %child1 = getelementptr inbounds %struct.BdrvChildSetPermState, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %child1, align 8
  %shared_perm = getelementptr inbounds %struct.BdrvChild, ptr %8, i32 0, i32 6
  store i64 %6, ptr %shared_perm, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_topological_dfs(ptr noundef %list, ptr noundef %found, ptr noundef %bs) #0 {
entry:
  %retval = alloca ptr, align 8
  %list.addr = alloca ptr, align 8
  %found.addr = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %child = alloca ptr, align 8
  %local_found = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %list, ptr %list.addr, align 8
  store ptr %found, ptr %found.addr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr null, ptr %local_found, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2285, ptr noundef @__PRETTY_FUNCTION__.bdrv_topological_dfs) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  %0 = load ptr, ptr %found.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end7, label %if.then1

if.then1:                                         ; preds = %do.end
  %1 = load ptr, ptr %list.addr, align 8
  %tobool2 = icmp ne ptr %1, null
  br i1 %tobool2, label %if.else4, label %if.then3

if.then3:                                         ; preds = %if.then1
  br label %if.end5

if.else4:                                         ; preds = %if.then1
  call void @__assert_fail(ptr noundef @.str.188, ptr noundef @.str.2, i32 noundef 2288, ptr noundef @__PRETTY_FUNCTION__.bdrv_topological_dfs) #16
  unreachable

if.end5:                                          ; preds = %if.then3
  %call6 = call ptr @g_hash_table_new(ptr noundef null, ptr noundef null)
  store ptr %call6, ptr %local_found, align 8
  store ptr %call6, ptr %found.addr, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.end5, %do.end
  %2 = load ptr, ptr %found.addr, align 8
  %3 = load ptr, ptr %bs.addr, align 8
  %call8 = call i32 @g_hash_table_contains(ptr noundef %2, ptr noundef %3)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  %4 = load ptr, ptr %list.addr, align 8
  store ptr %4, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end11:                                         ; preds = %if.end7
  %5 = load ptr, ptr %found.addr, align 8
  %6 = load ptr, ptr %bs.addr, align 8
  %call12 = call i32 @g_hash_table_add(ptr noundef %5, ptr noundef %6)
  %7 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %8 = load ptr, ptr %lh_first, align 8
  store ptr %8, ptr %child, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end11
  %9 = load ptr, ptr %child, align 8
  %tobool13 = icmp ne ptr %9, null
  br i1 %tobool13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load ptr, ptr %list.addr, align 8
  %11 = load ptr, ptr %found.addr, align 8
  %12 = load ptr, ptr %child, align 8
  %bs14 = getelementptr inbounds %struct.BdrvChild, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %bs14, align 8
  %call15 = call ptr @bdrv_topological_dfs(ptr noundef %10, ptr noundef %11, ptr noundef %13)
  store ptr %call15, ptr %list.addr, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load ptr, ptr %child, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %14, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %15 = load ptr, ptr %le_next, align 8
  store ptr %15, ptr %child, align 8
  br label %for.cond, !llvm.loop !94

for.end:                                          ; preds = %for.cond
  %16 = load ptr, ptr %list.addr, align 8
  %17 = load ptr, ptr %bs.addr, align 8
  %call16 = call ptr @g_slist_prepend(ptr noundef %16, ptr noundef %17)
  store ptr %call16, ptr %retval, align 8
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then10
  call void @glib_autoptr_cleanup_GHashTable(ptr noundef %local_found)
  %18 = load ptr, ptr %retval, align 8
  ret ptr %18
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_do_refresh_perms(ptr noundef %list, ptr noundef %q, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %list.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %bs = alloca ptr, align 8
  store ptr %list, ptr %list.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2573, ptr noundef @__PRETTY_FUNCTION__.bdrv_do_refresh_perms) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %0 = load ptr, ptr %list.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1 = load ptr, ptr %list.addr, align 8
  %data = getelementptr inbounds %struct._GSList, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %data, align 8
  store ptr %2, ptr %bs, align 8
  %3 = load ptr, ptr %bs, align 8
  %4 = load ptr, ptr %errp.addr, align 8
  %call1 = call zeroext i1 @bdrv_parent_perms_conflict(ptr noundef %3, ptr noundef %4)
  br i1 %call1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %for.body
  store i32 -22, ptr %retval, align 4
  br label %return

if.end3:                                          ; preds = %for.body
  %5 = load ptr, ptr %bs, align 8
  %6 = load ptr, ptr %q.addr, align 8
  %7 = load ptr, ptr %tran.addr, align 8
  %8 = load ptr, ptr %errp.addr, align 8
  %call4 = call i32 @bdrv_node_refresh_perm(ptr noundef %5, ptr noundef %6, ptr noundef %7, ptr noundef %8)
  store i32 %call4, ptr %ret, align 4
  %9 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %9, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end3
  %10 = load i32, ptr %ret, align 4
  store i32 %10, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %if.end3
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %11 = load ptr, ptr %list.addr, align 8
  %next = getelementptr inbounds %struct._GSList, ptr %11, i32 0, i32 1
  %12 = load ptr, ptr %next, align 8
  store ptr %12, ptr %list.addr, align 8
  br label %for.cond, !llvm.loop !95

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then2
  %13 = load i32, ptr %retval, align 4
  ret i32 %13
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_cleanup_GHashTable(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %1 = load ptr, ptr %0, align 8
  call void @glib_autoptr_clear_GHashTable(ptr noundef %1)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_clear_GHashTable(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %_ptr.addr, align 8
  call void @g_hash_table_unref(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @g_hash_table_unref(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_parent_perms_conflict(ptr noundef %bs, ptr noundef %errp) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %a = alloca ptr, align 8
  %b = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2228, ptr noundef @__PRETTY_FUNCTION__.bdrv_parent_perms_conflict) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %1 = load ptr, ptr %lh_first, align 8
  store ptr %1, ptr %a, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc11, %do.end
  %2 = load ptr, ptr %a, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end14

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %bs.addr, align 8
  %parents1 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 32
  %lh_first2 = getelementptr inbounds %struct.anon.4, ptr %parents1, i32 0, i32 0
  %4 = load ptr, ptr %lh_first2, align 8
  store ptr %4, ptr %b, align 8
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %for.body
  %5 = load ptr, ptr %b, align 8
  %tobool4 = icmp ne ptr %5, null
  br i1 %tobool4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %6 = load ptr, ptr %a, align 8
  %7 = load ptr, ptr %b, align 8
  %cmp = icmp eq ptr %6, %7
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %for.body5
  br label %for.inc

if.end7:                                          ; preds = %for.body5
  %8 = load ptr, ptr %a, align 8
  %9 = load ptr, ptr %b, align 8
  %10 = load ptr, ptr %errp.addr, align 8
  %call8 = call zeroext i1 @bdrv_a_allow_b(ptr noundef %8, ptr noundef %9, ptr noundef %10)
  br i1 %call8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end7
  store i1 true, ptr %retval, align 1
  br label %return

if.end10:                                         ; preds = %if.end7
  br label %for.inc

for.inc:                                          ; preds = %if.end10, %if.then6
  %11 = load ptr, ptr %b, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 10
  %le_next = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %12 = load ptr, ptr %le_next, align 8
  store ptr %12, ptr %b, align 8
  br label %for.cond3, !llvm.loop !96

for.end:                                          ; preds = %for.cond3
  br label %for.inc11

for.inc11:                                        ; preds = %for.end
  %13 = load ptr, ptr %a, align 8
  %next_parent12 = getelementptr inbounds %struct.BdrvChild, ptr %13, i32 0, i32 10
  %le_next13 = getelementptr inbounds %struct.anon.15, ptr %next_parent12, i32 0, i32 0
  %14 = load ptr, ptr %le_next13, align 8
  store ptr %14, ptr %a, align 8
  br label %for.cond, !llvm.loop !97

for.end14:                                        ; preds = %for.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end14, %if.then9
  %15 = load i1, ptr %retval, align 1
  ret i1 %15
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_node_refresh_perm(ptr noundef %bs, ptr noundef %q, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %q.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %c = alloca ptr, align 8
  %ret = alloca i32, align 4
  %cumulative_perms = alloca i64, align 8
  %cumulative_shared_perms = alloca i64, align 8
  %cur_perm = alloca i64, align 8
  %cur_shared = alloca i64, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %q, ptr %q.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv1, align 8
  store ptr %1, ptr %drv, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2496, ptr noundef @__PRETTY_FUNCTION__.bdrv_node_refresh_perm) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_get_cumulative_perm(ptr noundef %2, ptr noundef %cumulative_perms, ptr noundef %cumulative_shared_perms)
  %3 = load i64, ptr %cumulative_perms, align 8
  %and = and i64 %3, 6
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %do.end
  %4 = load ptr, ptr %bs.addr, align 8
  %5 = load ptr, ptr %q.addr, align 8
  %call2 = call zeroext i1 @bdrv_is_writable_after_reopen(ptr noundef %4, ptr noundef %5)
  br i1 %call2, label %if.end9, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  %6 = load ptr, ptr %bs.addr, align 8
  %call4 = call zeroext i1 @bdrv_is_writable_after_reopen(ptr noundef %6, ptr noundef null)
  br i1 %call4, label %if.else6, label %if.then5

if.then5:                                         ; preds = %if.then3
  %7 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %7, ptr noundef @.str.2, i32 noundef 2505, ptr noundef @__func__.bdrv_node_refresh_perm, ptr noundef @.str.192)
  br label %if.end8

if.else6:                                         ; preds = %if.then3
  %8 = load ptr, ptr %errp.addr, align 8
  %9 = load ptr, ptr %bs.addr, align 8
  %call7 = call ptr @bdrv_get_node_name(ptr noundef %9)
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %8, ptr noundef @.str.2, i32 noundef 2508, ptr noundef @__func__.bdrv_node_refresh_perm, ptr noundef @.str.193, ptr noundef %call7)
  br label %if.end8

if.end8:                                          ; preds = %if.else6, %if.then5
  store i32 -1, ptr %retval, align 4
  br label %return

if.end9:                                          ; preds = %land.lhs.true, %do.end
  %10 = load i64, ptr %cumulative_perms, align 8
  %and10 = and i64 %10, 6
  %tobool11 = icmp ne i64 %and10, 0
  br i1 %tobool11, label %land.lhs.true12, label %if.end19

land.lhs.true12:                                  ; preds = %if.end9
  %11 = load i64, ptr %cumulative_perms, align 8
  %and13 = and i64 %11, 8
  %tobool14 = icmp ne i64 %and13, 0
  br i1 %tobool14, label %if.end19, label %if.then15

if.then15:                                        ; preds = %land.lhs.true12
  %12 = load ptr, ptr %bs.addr, align 8
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 37
  %13 = load i64, ptr %total_sectors, align 8
  %mul = mul i64 %13, 512
  %14 = load ptr, ptr %bs.addr, align 8
  %bl = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 17
  %request_alignment = getelementptr inbounds %struct.BlockLimits, ptr %bl, i32 0, i32 0
  %15 = load i32, ptr %request_alignment, align 8
  %conv = zext i32 %15 to i64
  %rem = urem i64 %mul, %conv
  %tobool16 = icmp ne i64 %rem, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then15
  %16 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %16, ptr noundef @.str.2, i32 noundef 2525, ptr noundef @__func__.bdrv_node_refresh_perm, ptr noundef @.str.194)
  store i32 -1, ptr %retval, align 4
  br label %return

if.end18:                                         ; preds = %if.then15
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %land.lhs.true12, %if.end9
  %17 = load ptr, ptr %drv, align 8
  %tobool20 = icmp ne ptr %17, null
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %if.end19
  store i32 0, ptr %retval, align 4
  br label %return

if.end22:                                         ; preds = %if.end19
  %18 = load ptr, ptr %bs.addr, align 8
  %19 = load i64, ptr %cumulative_perms, align 8
  %20 = load i64, ptr %cumulative_shared_perms, align 8
  %21 = load ptr, ptr %tran.addr, align 8
  %22 = load ptr, ptr %errp.addr, align 8
  %call23 = call i32 @bdrv_drv_set_perm(ptr noundef %18, i64 noundef %19, i64 noundef %20, ptr noundef %21, ptr noundef %22)
  store i32 %call23, ptr %ret, align 4
  %23 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %23, 0
  br i1 %cmp, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.end22
  %24 = load i32, ptr %ret, align 4
  store i32 %24, ptr %retval, align 4
  br label %return

if.end26:                                         ; preds = %if.end22
  %25 = load ptr, ptr %drv, align 8
  %bdrv_child_perm = getelementptr inbounds %struct.BlockDriver, ptr %25, i32 0, i32 58
  %26 = load ptr, ptr %bdrv_child_perm, align 8
  %tobool27 = icmp ne ptr %26, null
  br i1 %tobool27, label %if.end34, label %if.then28

if.then28:                                        ; preds = %if.end26
  %27 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %27, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %28 = load ptr, ptr %lh_first, align 8
  %cmp29 = icmp eq ptr %28, null
  br i1 %cmp29, label %if.then31, label %if.else32

if.then31:                                        ; preds = %if.then28
  br label %if.end33

if.else32:                                        ; preds = %if.then28
  call void @__assert_fail(ptr noundef @.str.195, ptr noundef @.str.2, i32 noundef 2543, ptr noundef @__PRETTY_FUNCTION__.bdrv_node_refresh_perm) #16
  unreachable

if.end33:                                         ; preds = %if.then31
  store i32 0, ptr %retval, align 4
  br label %return

if.end34:                                         ; preds = %if.end26
  %29 = load ptr, ptr %bs.addr, align 8
  %children35 = getelementptr inbounds %struct.BlockDriverState, ptr %29, i32 0, i32 29
  %lh_first36 = getelementptr inbounds %struct.anon.3, ptr %children35, i32 0, i32 0
  %30 = load ptr, ptr %lh_first36, align 8
  store ptr %30, ptr %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end34
  %31 = load ptr, ptr %c, align 8
  %tobool37 = icmp ne ptr %31, null
  br i1 %tobool37, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %32 = load ptr, ptr %bs.addr, align 8
  %33 = load ptr, ptr %c, align 8
  %bs38 = getelementptr inbounds %struct.BdrvChild, ptr %33, i32 0, i32 0
  %34 = load ptr, ptr %bs38, align 8
  %35 = load ptr, ptr %c, align 8
  %36 = load ptr, ptr %c, align 8
  %role = getelementptr inbounds %struct.BdrvChild, ptr %36, i32 0, i32 3
  %37 = load i32, ptr %role, align 8
  %38 = load ptr, ptr %q.addr, align 8
  %39 = load i64, ptr %cumulative_perms, align 8
  %40 = load i64, ptr %cumulative_shared_perms, align 8
  call void @bdrv_child_perm(ptr noundef %32, ptr noundef %34, ptr noundef %35, i32 noundef %37, ptr noundef %38, i64 noundef %39, i64 noundef %40, ptr noundef %cur_perm, ptr noundef %cur_shared)
  %41 = load ptr, ptr %c, align 8
  %42 = load i64, ptr %cur_perm, align 8
  %43 = load i64, ptr %cur_shared, align 8
  %44 = load ptr, ptr %tran.addr, align 8
  call void @bdrv_child_set_perm(ptr noundef %41, i64 noundef %42, i64 noundef %43, ptr noundef %44)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %45 = load ptr, ptr %c, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %45, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %46 = load ptr, ptr %le_next, align 8
  store ptr %46, ptr %c, align 8
  br label %for.cond, !llvm.loop !98

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.end33, %if.then25, %if.then21, %if.then17, %if.end8
  %47 = load i32, ptr %retval, align 4
  ret i32 %47
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_a_allow_b(ptr noundef %a, ptr noundef %b, ptr noundef %errp) #0 {
entry:
  %retval = alloca i1, align 1
  %a.addr = alloca ptr, align 8
  %b.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %child_bs_name = alloca ptr, align 8
  %a_user = alloca ptr, align 8
  %b_user = alloca ptr, align 8
  %perms = alloca ptr, align 8
  %cleanup.dest.slot = alloca i32, align 4
  store ptr %a, ptr %a.addr, align 8
  store ptr %b, ptr %b.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %a_user, align 8
  store ptr null, ptr %b_user, align 8
  store ptr null, ptr %perms, align 8
  %0 = load ptr, ptr %a.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %bs, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.189, ptr noundef @.str.2, i32 noundef 2201, ptr noundef @__PRETTY_FUNCTION__.bdrv_a_allow_b) #16
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load ptr, ptr %a.addr, align 8
  %bs1 = getelementptr inbounds %struct.BdrvChild, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %bs1, align 8
  %4 = load ptr, ptr %b.addr, align 8
  %bs2 = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %bs2, align 8
  %cmp = icmp eq ptr %3, %5
  br i1 %cmp, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.end
  br label %if.end5

if.else4:                                         ; preds = %if.end
  call void @__assert_fail(ptr noundef @.str.190, ptr noundef @.str.2, i32 noundef 2202, ptr noundef @__PRETTY_FUNCTION__.bdrv_a_allow_b) #16
  unreachable

if.end5:                                          ; preds = %if.then3
  br label %do.body

do.body:                                          ; preds = %if.end5
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then6, label %if.else7

if.then6:                                         ; preds = %do.body
  br label %if.end8

if.else7:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2203, ptr noundef @__PRETTY_FUNCTION__.bdrv_a_allow_b) #16
  unreachable

if.end8:                                          ; preds = %if.then6
  br label %do.cond

do.cond:                                          ; preds = %if.end8
  br label %do.end

do.end:                                           ; preds = %do.cond
  %6 = load ptr, ptr %b.addr, align 8
  %perm = getelementptr inbounds %struct.BdrvChild, ptr %6, i32 0, i32 5
  %7 = load i64, ptr %perm, align 8
  %8 = load ptr, ptr %a.addr, align 8
  %shared_perm = getelementptr inbounds %struct.BdrvChild, ptr %8, i32 0, i32 6
  %9 = load i64, ptr %shared_perm, align 8
  %and = and i64 %7, %9
  %10 = load ptr, ptr %b.addr, align 8
  %perm9 = getelementptr inbounds %struct.BdrvChild, ptr %10, i32 0, i32 5
  %11 = load i64, ptr %perm9, align 8
  %cmp10 = icmp eq i64 %and, %11
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %do.end
  store i1 true, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

if.end12:                                         ; preds = %do.end
  %12 = load ptr, ptr %b.addr, align 8
  %bs13 = getelementptr inbounds %struct.BdrvChild, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %bs13, align 8
  %call14 = call ptr @bdrv_get_node_name(ptr noundef %13)
  store ptr %call14, ptr %child_bs_name, align 8
  %14 = load ptr, ptr %a.addr, align 8
  %call15 = call ptr @bdrv_child_user_desc(ptr noundef %14)
  store ptr %call15, ptr %a_user, align 8
  %15 = load ptr, ptr %b.addr, align 8
  %call16 = call ptr @bdrv_child_user_desc(ptr noundef %15)
  store ptr %call16, ptr %b_user, align 8
  %16 = load ptr, ptr %b.addr, align 8
  %perm17 = getelementptr inbounds %struct.BdrvChild, ptr %16, i32 0, i32 5
  %17 = load i64, ptr %perm17, align 8
  %18 = load ptr, ptr %a.addr, align 8
  %shared_perm18 = getelementptr inbounds %struct.BdrvChild, ptr %18, i32 0, i32 6
  %19 = load i64, ptr %shared_perm18, align 8
  %not = xor i64 %19, -1
  %and19 = and i64 %17, %not
  %call20 = call ptr @bdrv_perm_names(i64 noundef %and19)
  store ptr %call20, ptr %perms, align 8
  %20 = load ptr, ptr %errp.addr, align 8
  %21 = load ptr, ptr %child_bs_name, align 8
  %22 = load ptr, ptr %perms, align 8
  %23 = load ptr, ptr %b_user, align 8
  %24 = load ptr, ptr %child_bs_name, align 8
  %25 = load ptr, ptr %b.addr, align 8
  %name = getelementptr inbounds %struct.BdrvChild, ptr %25, i32 0, i32 1
  %26 = load ptr, ptr %name, align 8
  %27 = load ptr, ptr %a_user, align 8
  %28 = load ptr, ptr %child_bs_name, align 8
  %29 = load ptr, ptr %a.addr, align 8
  %name21 = getelementptr inbounds %struct.BdrvChild, ptr %29, i32 0, i32 1
  %30 = load ptr, ptr %name21, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %20, ptr noundef @.str.2, i32 noundef 2219, ptr noundef @__func__.bdrv_a_allow_b, ptr noundef @.str.191, ptr noundef %21, ptr noundef %22, ptr noundef %23, ptr noundef %24, ptr noundef %26, ptr noundef %27, ptr noundef %28, ptr noundef %30)
  store i1 false, ptr %retval, align 1
  store i32 1, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end12, %if.then11
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %perms)
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %b_user)
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %a_user)
  %31 = load i1, ptr %retval, align 1
  ret i1 %31
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_child_user_desc(ptr noundef %c) #0 {
entry:
  %c.addr = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2186, ptr noundef @__PRETTY_FUNCTION__.bdrv_child_user_desc) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %c.addr, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %klass, align 8
  %get_parent_desc = getelementptr inbounds %struct.BdrvChildClass, ptr %1, i32 0, i32 4
  %2 = load ptr, ptr %get_parent_desc, align 8
  %3 = load ptr, ptr %c.addr, align 8
  %call1 = call ptr %2(ptr noundef %3)
  ret ptr %call1
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_drv_set_perm(ptr noundef %bs, i64 noundef %perm, i64 noundef %shared_perm, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %perm.addr = alloca i64, align 8
  %shared_perm.addr = alloca i64, align 8
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store i64 %perm, ptr %perm.addr, align 8
  store i64 %shared_perm, ptr %shared_perm.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2379, ptr noundef @__PRETTY_FUNCTION__.bdrv_drv_set_perm) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %do.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end2:                                          ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %drv3 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv3, align 8
  %bdrv_check_perm = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 55
  %4 = load ptr, ptr %bdrv_check_perm, align 8
  %tobool4 = icmp ne ptr %4, null
  br i1 %tobool4, label %if.then5, label %if.end11

if.then5:                                         ; preds = %if.end2
  %5 = load ptr, ptr %bs.addr, align 8
  %drv6 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %drv6, align 8
  %bdrv_check_perm7 = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 55
  %7 = load ptr, ptr %bdrv_check_perm7, align 8
  %8 = load ptr, ptr %bs.addr, align 8
  %9 = load i64, ptr %perm.addr, align 8
  %10 = load i64, ptr %shared_perm.addr, align 8
  %11 = load ptr, ptr %errp.addr, align 8
  %call8 = call i32 %7(ptr noundef %8, i64 noundef %9, i64 noundef %10, ptr noundef %11)
  store i32 %call8, ptr %ret, align 4
  %12 = load i32, ptr %ret, align 4
  %cmp = icmp slt i32 %12, 0
  br i1 %cmp, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.then5
  %13 = load i32, ptr %ret, align 4
  store i32 %13, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.then5
  br label %if.end11

if.end11:                                         ; preds = %if.end10, %if.end2
  %14 = load ptr, ptr %tran.addr, align 8
  %tobool12 = icmp ne ptr %14, null
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end11
  %15 = load ptr, ptr %tran.addr, align 8
  %16 = load ptr, ptr %bs.addr, align 8
  call void @tran_add(ptr noundef %15, ptr noundef @bdrv_drv_set_perm_drv, ptr noundef %16)
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end11
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then9, %if.then1
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

declare void @bdrv_parent_drained_begin_single(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_attach_child_common_abort(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %tran = alloca ptr, align 8
  %visited = alloca ptr, align 8
  %ret = alloca i8, align 1
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %s, align 8
  %1 = load ptr, ptr %s, align 8
  %child = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %child, align 8
  %bs1 = getelementptr inbounds %struct.BdrvChild, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %bs1, align 8
  store ptr %3, ptr %bs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3005, ptr noundef @__PRETTY_FUNCTION__.bdrv_attach_child_common_abort) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  call void @assert_bdrv_graph_writable()
  %4 = load ptr, ptr %s, align 8
  %child2 = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %child2, align 8
  call void @bdrv_replace_child_noperm(ptr noundef %5, ptr noundef null)
  %6 = load ptr, ptr %bs, align 8
  %call3 = call ptr @bdrv_get_aio_context(ptr noundef %6)
  %7 = load ptr, ptr %s, align 8
  %old_child_ctx = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %7, i32 0, i32 2
  %8 = load ptr, ptr %old_child_ctx, align 8
  %cmp = icmp ne ptr %call3, %8
  br i1 %cmp, label %if.then4, label %if.end7

if.then4:                                         ; preds = %do.end
  %9 = load ptr, ptr %bs, align 8
  %10 = load ptr, ptr %s, align 8
  %old_child_ctx5 = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %10, i32 0, i32 2
  %11 = load ptr, ptr %old_child_ctx5, align 8
  %call6 = call i32 @bdrv_try_change_aio_context(ptr noundef %9, ptr noundef %11, ptr noundef null, ptr noundef @error_abort)
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %do.end
  %12 = load ptr, ptr %s, align 8
  %child8 = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %12, i32 0, i32 0
  %13 = load ptr, ptr %child8, align 8
  %call9 = call ptr @bdrv_child_get_parent_aio_context(ptr noundef %13)
  %14 = load ptr, ptr %s, align 8
  %old_parent_ctx = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %14, i32 0, i32 1
  %15 = load ptr, ptr %old_parent_ctx, align 8
  %cmp10 = icmp ne ptr %call9, %15
  br i1 %cmp10, label %if.then11, label %if.end23

if.then11:                                        ; preds = %if.end7
  %call12 = call ptr @tran_new()
  store ptr %call12, ptr %tran, align 8
  %call13 = call ptr @g_hash_table_new(ptr noundef null, ptr noundef null)
  store ptr %call13, ptr %visited, align 8
  %16 = load ptr, ptr %s, align 8
  %child14 = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %16, i32 0, i32 0
  %17 = load ptr, ptr %child14, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %17, i32 0, i32 2
  %18 = load ptr, ptr %klass, align 8
  %change_aio_ctx = getelementptr inbounds %struct.BdrvChildClass, ptr %18, i32 0, i32 13
  %19 = load ptr, ptr %change_aio_ctx, align 8
  %20 = load ptr, ptr %s, align 8
  %child15 = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %20, i32 0, i32 0
  %21 = load ptr, ptr %child15, align 8
  %22 = load ptr, ptr %s, align 8
  %old_parent_ctx16 = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %22, i32 0, i32 1
  %23 = load ptr, ptr %old_parent_ctx16, align 8
  %24 = load ptr, ptr %visited, align 8
  %25 = load ptr, ptr %tran, align 8
  %call17 = call zeroext i1 %19(ptr noundef %21, ptr noundef %23, ptr noundef %24, ptr noundef %25, ptr noundef @error_abort)
  %frombool = zext i1 %call17 to i8
  store i8 %frombool, ptr %ret, align 1
  %26 = load ptr, ptr %visited, align 8
  call void @g_hash_table_destroy(ptr noundef %26)
  %27 = load i8, ptr %ret, align 1
  %tobool = trunc i8 %27 to i1
  %conv = zext i1 %tobool to i32
  %cmp18 = icmp eq i32 %conv, 1
  br i1 %cmp18, label %if.then20, label %if.else21

if.then20:                                        ; preds = %if.then11
  br label %if.end22

if.else21:                                        ; preds = %if.then11
  call void @__assert_fail(ptr noundef @.str.200, ptr noundef @.str.2, i32 noundef 3028, ptr noundef @__PRETTY_FUNCTION__.bdrv_attach_child_common_abort) #16
  unreachable

if.end22:                                         ; preds = %if.then20
  %28 = load ptr, ptr %tran, align 8
  call void @tran_commit(ptr noundef %28)
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end7
  %29 = load ptr, ptr %bs, align 8
  call void @bdrv_schedule_unref(ptr noundef %29)
  %30 = load ptr, ptr %s, align 8
  %child24 = getelementptr inbounds %struct.BdrvAttachChildCommonState, ptr %30, i32 0, i32 0
  %31 = load ptr, ptr %child24, align 8
  call void @bdrv_child_free(ptr noundef %31)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_recurse_has_child(ptr noundef %bs, ptr noundef %child) #0 {
entry:
  %retval = alloca i1, align 1
  %bs.addr = alloca ptr, align 8
  %child.addr = alloca ptr, align 8
  %c = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %child, ptr %child.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %1 = load ptr, ptr %child.addr, align 8
  %cmp = icmp eq ptr %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  %2 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %3 = load ptr, ptr %lh_first, align 8
  store ptr %3, ptr %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load ptr, ptr %c, align 8
  %tobool = icmp ne ptr %4, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %c, align 8
  %bs1 = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %bs1, align 8
  %7 = load ptr, ptr %child.addr, align 8
  %call = call zeroext i1 @bdrv_recurse_has_child(ptr noundef %6, ptr noundef %7)
  br i1 %call, label %if.then2, label %if.end3

if.then2:                                         ; preds = %for.body
  store i1 true, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end3
  %8 = load ptr, ptr %c, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %8, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %9 = load ptr, ptr %le_next, align 8
  store ptr %9, ptr %c, align 8
  br label %for.cond, !llvm.loop !99

for.end:                                          ; preds = %for.cond
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %for.end, %if.then2, %if.then
  %10 = load i1, ptr %retval, align 1
  ret i1 %10
}

declare void @bdrv_parent_drained_end_single(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_set_inherits_from(ptr noundef %bs, ptr noundef %new_inherits_from, ptr noundef %tran) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %new_inherits_from.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %.compoundliteral = alloca %struct.BdrvSetInheritsFrom, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %new_inherits_from, ptr %new_inherits_from.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  %0 = load ptr, ptr %tran.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call noalias ptr @g_malloc_n(i64 noundef 1, i64 noundef 16) #17
  store ptr %call, ptr %s, align 8
  %1 = load ptr, ptr %s, align 8
  %bs1 = getelementptr inbounds %struct.BdrvSetInheritsFrom, ptr %.compoundliteral, i32 0, i32 0
  %2 = load ptr, ptr %bs.addr, align 8
  store ptr %2, ptr %bs1, align 8
  %old_inherits_from = getelementptr inbounds %struct.BdrvSetInheritsFrom, ptr %.compoundliteral, i32 0, i32 1
  %3 = load ptr, ptr %bs.addr, align 8
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 28
  %4 = load ptr, ptr %inherits_from, align 8
  store ptr %4, ptr %old_inherits_from, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 8 %1, ptr align 8 %.compoundliteral, i64 16, i1 false)
  %5 = load ptr, ptr %tran.addr, align 8
  %6 = load ptr, ptr %s, align 8
  call void @tran_add(ptr noundef %5, ptr noundef @bdrv_set_inherits_from_drv, ptr noundef %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load ptr, ptr %new_inherits_from.addr, align 8
  %8 = load ptr, ptr %bs.addr, align 8
  %inherits_from2 = getelementptr inbounds %struct.BlockDriverState, ptr %8, i32 0, i32 28
  store ptr %7, ptr %inherits_from2, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_set_inherits_from_abort(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %s, align 8
  %1 = load ptr, ptr %s, align 8
  %old_inherits_from = getelementptr inbounds %struct.BdrvSetInheritsFrom, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %old_inherits_from, align 8
  %3 = load ptr, ptr %s, align 8
  %bs = getelementptr inbounds %struct.BdrvSetInheritsFrom, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %bs, align 8
  %inherits_from = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 28
  store ptr %2, ptr %inherits_from, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_remove_child(ptr noundef %child, ptr noundef %tran) #0 {
entry:
  %child.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  store ptr %child, ptr %child.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  %0 = load ptr, ptr %child.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %child.addr, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %bs, align 8
  %tobool1 = icmp ne ptr %2, null
  br i1 %tobool1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %if.end
  %3 = load ptr, ptr %child.addr, align 8
  %quiesced_parent = getelementptr inbounds %struct.BdrvChild, ptr %3, i32 0, i32 8
  %4 = load i8, ptr %quiesced_parent, align 1
  %tobool3 = trunc i8 %4 to i1
  br i1 %tobool3, label %if.then4, label %if.else

if.then4:                                         ; preds = %if.then2
  br label %if.end5

if.else:                                          ; preds = %if.then2
  call void @__assert_fail(ptr noundef @.str.215, ptr noundef @.str.2, i32 noundef 5376, ptr noundef @__PRETTY_FUNCTION__.bdrv_remove_child) #16
  unreachable

if.end5:                                          ; preds = %if.then4
  %5 = load ptr, ptr %child.addr, align 8
  %6 = load ptr, ptr %tran.addr, align 8
  call void @bdrv_replace_child_tran(ptr noundef %5, ptr noundef null, ptr noundef %6)
  br label %if.end6

if.end6:                                          ; preds = %if.end5, %if.end
  %7 = load ptr, ptr %tran.addr, align 8
  %8 = load ptr, ptr %child.addr, align 8
  call void @tran_add(ptr noundef %7, ptr noundef @bdrv_remove_child_drv, ptr noundef %8)
  br label %return

return:                                           ; preds = %if.end6, %if.then
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_remove_child_commit(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5353, ptr noundef @__PRETTY_FUNCTION__.bdrv_remove_child_commit) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %opaque.addr, align 8
  call void @bdrv_child_free(ptr noundef %0)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @qobject_type(ptr noundef %obj) #0 {
entry:
  %obj.addr = alloca ptr, align 8
  store ptr %obj, ptr %obj.addr, align 8
  %0 = load ptr, ptr %obj.addr, align 8
  %base = getelementptr inbounds %struct.QObject, ptr %0, i32 0, i32 0
  %type = getelementptr inbounds %struct.QObjectBase_, ptr %base, i32 0, i32 0
  %1 = load i32, ptr %type, align 8
  %cmp = icmp ult i32 0, %1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load ptr, ptr %obj.addr, align 8
  %base1 = getelementptr inbounds %struct.QObject, ptr %2, i32 0, i32 0
  %type2 = getelementptr inbounds %struct.QObjectBase_, ptr %base1, i32 0, i32 0
  %3 = load i32, ptr %type2, align 8
  %cmp3 = icmp ult i32 %3, 7
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  call void @__assert_fail(ptr noundef @.str.218, ptr noundef @.str.161, i32 noundef 126, ptr noundef @__PRETTY_FUNCTION__.qobject_type) #16
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load ptr, ptr %obj.addr, align 8
  %base4 = getelementptr inbounds %struct.QObject, ptr %4, i32 0, i32 0
  %type5 = getelementptr inbounds %struct.QObjectBase_, ptr %base4, i32 0, i32 0
  %5 = load i32, ptr %type5, align 8
  ret i32 %5
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @parse_json_protocol(ptr noundef %options, ptr noundef %pfilename, ptr noundef %errp) #0 {
entry:
  %options.addr = alloca ptr, align 8
  %pfilename.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %json_options = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %_obj17 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp10 = alloca ptr, align 8
  store ptr %options, ptr %options.addr, align 8
  store ptr %pfilename, ptr %pfilename.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2023, ptr noundef @__PRETTY_FUNCTION__.parse_json_protocol) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %pfilename.addr, align 8
  %1 = load ptr, ptr %0, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %lor.lhs.false, label %if.then3

lor.lhs.false:                                    ; preds = %do.end
  %2 = load ptr, ptr %pfilename.addr, align 8
  %3 = load ptr, ptr %2, align 8
  %call1 = call i32 @g_str_has_prefix(ptr noundef %3, ptr noundef @.str.8)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %lor.lhs.false, %do.end
  br label %return

if.end4:                                          ; preds = %lor.lhs.false
  %4 = load ptr, ptr %pfilename.addr, align 8
  %5 = load ptr, ptr %4, align 8
  %call5 = call ptr @parse_json_filename(ptr noundef %5, ptr noundef %local_err)
  store ptr %call5, ptr %json_options, align 8
  %6 = load ptr, ptr %local_err, align 8
  %tobool6 = icmp ne ptr %6, null
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end4
  %7 = load ptr, ptr %errp.addr, align 8
  %8 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %7, ptr noundef %8)
  br label %return

if.end8:                                          ; preds = %if.end4
  %9 = load ptr, ptr %options.addr, align 8
  %10 = load ptr, ptr %json_options, align 8
  call void @qdict_join(ptr noundef %9, ptr noundef %10, i1 noundef zeroext false)
  %11 = load ptr, ptr %json_options, align 8
  store ptr %11, ptr %_obj17, align 8
  %12 = load ptr, ptr %_obj17, align 8
  %tobool9 = icmp ne ptr %12, null
  br i1 %tobool9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end8
  %13 = load ptr, ptr %_obj17, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %13, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %14 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %14, i64 0
  store ptr %add.ptr, ptr %tmp10, align 8
  %15 = load ptr, ptr %tmp10, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %15, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %16 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %16)
  %17 = load ptr, ptr %pfilename.addr, align 8
  store ptr null, ptr %17, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then7, %if.then3
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_fill_options(ptr noundef %options, ptr noundef %filename, ptr noundef %flags, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %options.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %flags.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %drvname = alloca ptr, align 8
  %protocol = alloca i8, align 1
  %parse_filename = alloca i8, align 1
  %drv = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  store ptr %options, ptr %options.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %flags, ptr %flags.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %flags.addr, align 8
  %1 = load i32, ptr %0, align 4
  %and = and i32 %1, 32768
  %tobool = icmp ne i32 %and, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %protocol, align 1
  store i8 0, ptr %parse_filename, align 1
  store ptr null, ptr %drv, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2058, ptr noundef @__PRETTY_FUNCTION__.bdrv_fill_options) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %options.addr, align 8
  %3 = load ptr, ptr %2, align 8
  %call1 = call ptr @qdict_get_try_str(ptr noundef %3, ptr noundef @.str.20)
  store ptr %call1, ptr %drvname, align 8
  %4 = load ptr, ptr %drvname, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.then3, label %if.end10

if.then3:                                         ; preds = %do.end
  %5 = load ptr, ptr %drvname, align 8
  %call4 = call ptr @bdrv_find_format(ptr noundef %5)
  store ptr %call4, ptr %drv, align 8
  %6 = load ptr, ptr %drv, align 8
  %tobool5 = icmp ne ptr %6, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.then3
  %7 = load ptr, ptr %errp.addr, align 8
  %8 = load ptr, ptr %drvname, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %7, ptr noundef @.str.2, i32 noundef 2071, ptr noundef @__func__.bdrv_fill_options, ptr noundef @.str.233, ptr noundef %8)
  store i32 -2, ptr %retval, align 4
  br label %return

if.end7:                                          ; preds = %if.then3
  %9 = load ptr, ptr %drv, align 8
  %bdrv_file_open = getelementptr inbounds %struct.BlockDriver, ptr %9, i32 0, i32 24
  %10 = load ptr, ptr %bdrv_file_open, align 8
  %tobool8 = icmp ne ptr %10, null
  %frombool9 = zext i1 %tobool8 to i8
  store i8 %frombool9, ptr %protocol, align 1
  br label %if.end10

if.end10:                                         ; preds = %if.end7, %do.end
  %11 = load i8, ptr %protocol, align 1
  %tobool11 = trunc i8 %11 to i1
  br i1 %tobool11, label %if.then12, label %if.else13

if.then12:                                        ; preds = %if.end10
  %12 = load ptr, ptr %flags.addr, align 8
  %13 = load i32, ptr %12, align 4
  %or = or i32 %13, 32768
  store i32 %or, ptr %12, align 4
  br label %if.end15

if.else13:                                        ; preds = %if.end10
  %14 = load ptr, ptr %flags.addr, align 8
  %15 = load i32, ptr %14, align 4
  %and14 = and i32 %15, -32769
  store i32 %and14, ptr %14, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.else13, %if.then12
  %16 = load ptr, ptr %options.addr, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %flags.addr, align 8
  %19 = load i32, ptr %18, align 4
  call void @update_options_from_flags(ptr noundef %17, i32 noundef %19)
  %20 = load i8, ptr %protocol, align 1
  %tobool16 = trunc i8 %20 to i1
  br i1 %tobool16, label %land.lhs.true, label %if.end24

land.lhs.true:                                    ; preds = %if.end15
  %21 = load ptr, ptr %filename.addr, align 8
  %tobool17 = icmp ne ptr %21, null
  br i1 %tobool17, label %if.then18, label %if.end24

if.then18:                                        ; preds = %land.lhs.true
  %22 = load ptr, ptr %options.addr, align 8
  %23 = load ptr, ptr %22, align 8
  %call19 = call i32 @qdict_haskey(ptr noundef %23, ptr noundef @.str.5)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.else22, label %if.then21

if.then21:                                        ; preds = %if.then18
  %24 = load ptr, ptr %options.addr, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %filename.addr, align 8
  call void @qdict_put_str(ptr noundef %25, ptr noundef @.str.5, ptr noundef %26)
  store i8 1, ptr %parse_filename, align 1
  br label %if.end23

if.else22:                                        ; preds = %if.then18
  %27 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %27, ptr noundef @.str.2, i32 noundef 2095, ptr noundef @__func__.bdrv_fill_options, ptr noundef @.str.234)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end23:                                         ; preds = %if.then21
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %land.lhs.true, %if.end15
  %28 = load ptr, ptr %options.addr, align 8
  %29 = load ptr, ptr %28, align 8
  %call25 = call ptr @qdict_get_try_str(ptr noundef %29, ptr noundef @.str.5)
  store ptr %call25, ptr %filename.addr, align 8
  %30 = load ptr, ptr %drvname, align 8
  %tobool26 = icmp ne ptr %30, null
  br i1 %tobool26, label %if.end39, label %land.lhs.true27

land.lhs.true27:                                  ; preds = %if.end24
  %31 = load i8, ptr %protocol, align 1
  %tobool28 = trunc i8 %31 to i1
  br i1 %tobool28, label %if.then29, label %if.end39

if.then29:                                        ; preds = %land.lhs.true27
  %32 = load ptr, ptr %filename.addr, align 8
  %tobool30 = icmp ne ptr %32, null
  br i1 %tobool30, label %if.then31, label %if.else37

if.then31:                                        ; preds = %if.then29
  %33 = load ptr, ptr %filename.addr, align 8
  %34 = load i8, ptr %parse_filename, align 1
  %tobool32 = trunc i8 %34 to i1
  %35 = load ptr, ptr %errp.addr, align 8
  %call33 = call ptr @bdrv_find_protocol(ptr noundef %33, i1 noundef zeroext %tobool32, ptr noundef %35)
  store ptr %call33, ptr %drv, align 8
  %36 = load ptr, ptr %drv, align 8
  %tobool34 = icmp ne ptr %36, null
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %if.then31
  store i32 -22, ptr %retval, align 4
  br label %return

if.end36:                                         ; preds = %if.then31
  %37 = load ptr, ptr %drv, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %37, i32 0, i32 0
  %38 = load ptr, ptr %format_name, align 8
  store ptr %38, ptr %drvname, align 8
  %39 = load ptr, ptr %options.addr, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %drvname, align 8
  call void @qdict_put_str(ptr noundef %40, ptr noundef @.str.20, ptr noundef %41)
  br label %if.end38

if.else37:                                        ; preds = %if.then29
  %42 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %42, ptr noundef @.str.2, i32 noundef 2114, ptr noundef @__func__.bdrv_fill_options, ptr noundef @.str.225)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end38:                                         ; preds = %if.end36
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %land.lhs.true27, %if.end24
  %43 = load ptr, ptr %drv, align 8
  %tobool40 = icmp ne ptr %43, null
  br i1 %tobool40, label %if.then42, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end39
  %44 = load i8, ptr %protocol, align 1
  %tobool41 = trunc i8 %44 to i1
  br i1 %tobool41, label %if.else43, label %if.then42

if.then42:                                        ; preds = %lor.lhs.false, %if.end39
  br label %if.end44

if.else43:                                        ; preds = %lor.lhs.false
  call void @__assert_fail(ptr noundef @.str.235, ptr noundef @.str.2, i32 noundef 2119, ptr noundef @__PRETTY_FUNCTION__.bdrv_fill_options) #16
  unreachable

if.end44:                                         ; preds = %if.then42
  %45 = load ptr, ptr %drv, align 8
  %tobool45 = icmp ne ptr %45, null
  br i1 %tobool45, label %land.lhs.true46, label %if.end58

land.lhs.true46:                                  ; preds = %if.end44
  %46 = load ptr, ptr %drv, align 8
  %bdrv_parse_filename = getelementptr inbounds %struct.BlockDriver, ptr %46, i32 0, i32 17
  %47 = load ptr, ptr %bdrv_parse_filename, align 8
  %tobool47 = icmp ne ptr %47, null
  br i1 %tobool47, label %land.lhs.true48, label %if.end58

land.lhs.true48:                                  ; preds = %land.lhs.true46
  %48 = load i8, ptr %parse_filename, align 1
  %tobool49 = trunc i8 %48 to i1
  br i1 %tobool49, label %if.then50, label %if.end58

if.then50:                                        ; preds = %land.lhs.true48
  %49 = load ptr, ptr %drv, align 8
  %bdrv_parse_filename51 = getelementptr inbounds %struct.BlockDriver, ptr %49, i32 0, i32 17
  %50 = load ptr, ptr %bdrv_parse_filename51, align 8
  %51 = load ptr, ptr %filename.addr, align 8
  %52 = load ptr, ptr %options.addr, align 8
  %53 = load ptr, ptr %52, align 8
  call void %50(ptr noundef %51, ptr noundef %53, ptr noundef %local_err)
  %54 = load ptr, ptr %local_err, align 8
  %tobool52 = icmp ne ptr %54, null
  br i1 %tobool52, label %if.then53, label %if.end54

if.then53:                                        ; preds = %if.then50
  %55 = load ptr, ptr %errp.addr, align 8
  %56 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %55, ptr noundef %56)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end54:                                         ; preds = %if.then50
  %57 = load ptr, ptr %drv, align 8
  %bdrv_needs_filename = getelementptr inbounds %struct.BlockDriver, ptr %57, i32 0, i32 6
  %58 = load i8, ptr %bdrv_needs_filename, align 8
  %tobool55 = trunc i8 %58 to i1
  br i1 %tobool55, label %if.end57, label %if.then56

if.then56:                                        ; preds = %if.end54
  %59 = load ptr, ptr %options.addr, align 8
  %60 = load ptr, ptr %59, align 8
  call void @qdict_del(ptr noundef %60, ptr noundef @.str.5)
  br label %if.end57

if.end57:                                         ; preds = %if.then56, %if.end54
  br label %if.end58

if.end58:                                         ; preds = %if.end57, %land.lhs.true48, %land.lhs.true46, %if.end44
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end58, %if.then53, %if.else37, %if.then35, %if.else22, %if.then6
  %61 = load i32, ptr %retval, align 4
  ret i32 %61
}

declare zeroext i1 @qdict_get_try_bool(ptr noundef, ptr noundef, i1 noundef zeroext) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_temp_snapshot_options(ptr noundef %child_flags, ptr noundef %child_options, i32 noundef %parent_flags, ptr noundef %parent_options) #0 {
entry:
  %child_flags.addr = alloca ptr, align 8
  %child_options.addr = alloca ptr, align 8
  %parent_flags.addr = alloca i32, align 4
  %parent_options.addr = alloca ptr, align 8
  store ptr %child_flags, ptr %child_flags.addr, align 8
  store ptr %child_options, ptr %child_options.addr, align 8
  store i32 %parent_flags, ptr %parent_flags.addr, align 4
  store ptr %parent_options, ptr %parent_options.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1244, ptr noundef @__PRETTY_FUNCTION__.bdrv_temp_snapshot_options) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load i32, ptr %parent_flags.addr, align 4
  %and = and i32 %0, -9
  %or = or i32 %and, 16
  %1 = load ptr, ptr %child_flags.addr, align 8
  store i32 %or, ptr %1, align 4
  %2 = load ptr, ptr %child_options.addr, align 8
  call void @qdict_set_default_str(ptr noundef %2, ptr noundef @.str.47, ptr noundef @.str.34)
  %3 = load ptr, ptr %child_options.addr, align 8
  call void @qdict_set_default_str(ptr noundef %3, ptr noundef @.str.49, ptr noundef @.str.36)
  %4 = load ptr, ptr %child_options.addr, align 8
  %5 = load ptr, ptr %parent_options.addr, align 8
  call void @qdict_copy_default(ptr noundef %4, ptr noundef %5, ptr noundef @.str.51)
  %6 = load ptr, ptr %child_options.addr, align 8
  %7 = load ptr, ptr %parent_options.addr, align 8
  call void @qdict_copy_default(ptr noundef %6, ptr noundef %7, ptr noundef @.str.57)
  %8 = load ptr, ptr %child_flags.addr, align 8
  %9 = load i32, ptr %8, align 4
  %and1 = and i32 %9, -129
  store i32 %and1, ptr %8, align 4
  ret void
}

declare ptr @qdict_get(ptr noundef, ptr noundef) #2

declare void @warn_report(ptr noundef, ...) #2

declare ptr @blk_new(ptr noundef, i64 noundef, i64 noundef) #2

declare i32 @blk_insert_bs(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @find_image_format(ptr noundef %file, ptr noundef %filename, ptr noundef %pdrv, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %file.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %pdrv.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %buf = alloca [512 x i8], align 16
  %ret = alloca i32, align 4
  store ptr %file, ptr %file.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %pdrv, ptr %pdrv.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store i32 0, ptr %ret, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1019, ptr noundef @__PRETTY_FUNCTION__.find_image_format) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %file.addr, align 8
  %call1 = call zeroext i1 @blk_is_sg(ptr noundef %0)
  br i1 %call1, label %if.then5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %1 = load ptr, ptr %file.addr, align 8
  %call2 = call zeroext i1 @blk_is_inserted(ptr noundef %1)
  br i1 %call2, label %lor.lhs.false3, label %if.then5

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %2 = load ptr, ptr %file.addr, align 8
  %call4 = call i64 @blk_getlength(ptr noundef %2)
  %cmp = icmp eq i64 %call4, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %lor.lhs.false3, %lor.lhs.false, %do.end
  %3 = load ptr, ptr %pdrv.addr, align 8
  store ptr @bdrv_raw, ptr %3, align 8
  %4 = load i32, ptr %ret, align 4
  store i32 %4, ptr %retval, align 4
  br label %return

if.end6:                                          ; preds = %lor.lhs.false3
  %5 = load ptr, ptr %file.addr, align 8
  %arraydecay = getelementptr inbounds [512 x i8], ptr %buf, i64 0, i64 0
  %call7 = call i32 @blk_pread(ptr noundef %5, i64 noundef 0, i64 noundef 512, ptr noundef %arraydecay, i32 noundef 0)
  store i32 %call7, ptr %ret, align 4
  %6 = load i32, ptr %ret, align 4
  %cmp8 = icmp slt i32 %6, 0
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  %7 = load ptr, ptr %errp.addr, align 8
  %8 = load i32, ptr %ret, align 4
  %sub = sub i32 0, %8
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %7, ptr noundef @.str.2, i32 noundef 1030, ptr noundef @__func__.find_image_format, i32 noundef %sub, ptr noundef @.str.236)
  %9 = load ptr, ptr %pdrv.addr, align 8
  store ptr null, ptr %9, align 8
  %10 = load i32, ptr %ret, align 4
  store i32 %10, ptr %retval, align 4
  br label %return

if.end10:                                         ; preds = %if.end6
  %arraydecay11 = getelementptr inbounds [512 x i8], ptr %buf, i64 0, i64 0
  %11 = load ptr, ptr %filename.addr, align 8
  %call12 = call ptr @bdrv_probe_all(ptr noundef %arraydecay11, i32 noundef 512, ptr noundef %11)
  store ptr %call12, ptr %drv, align 8
  %12 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %12, null
  br i1 %tobool, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end10
  %13 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %13, ptr noundef @.str.2, i32 noundef 1038, ptr noundef @__func__.find_image_format, ptr noundef @.str.237)
  %14 = load ptr, ptr %pdrv.addr, align 8
  store ptr null, ptr %14, align 8
  store i32 -2, ptr %retval, align 4
  br label %return

if.end14:                                         ; preds = %if.end10
  %15 = load ptr, ptr %drv, align 8
  %16 = load ptr, ptr %pdrv.addr, align 8
  store ptr %15, ptr %16, align 8
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end14, %if.then13, %if.then9, %if.then5
  %17 = load i32, ptr %retval, align 4
  ret i32 %17
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_open_common(ptr noundef %bs, ptr noundef %file, ptr noundef %options, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %file.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %ret = alloca i32, align 4
  %open_flags = alloca i32, align 4
  %filename = alloca ptr, align 8
  %driver_name = alloca ptr, align 8
  %node_name = alloca ptr, align 8
  %discard = alloca ptr, align 8
  %opts = alloca ptr, align 8
  %drv = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %ro = alloca i8, align 1
  %tmp = alloca i32, align 4
  %atomic-temp = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %file, ptr %file.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %driver_name, align 8
  store ptr null, ptr %node_name, align 8
  store ptr null, ptr %local_err, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1859, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_common) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  call void @bdrv_graph_rdlock_main_loop()
  %0 = load ptr, ptr %bs.addr, align 8
  %file1 = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 31
  %1 = load ptr, ptr %file1, align 8
  %cmp = icmp eq ptr %1, null
  br i1 %cmp, label %if.then2, label %if.else3

if.then2:                                         ; preds = %do.end
  br label %if.end4

if.else3:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.238, ptr noundef @.str.2, i32 noundef 1862, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_common) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  %2 = load ptr, ptr %options.addr, align 8
  %cmp5 = icmp ne ptr %2, null
  br i1 %cmp5, label %land.lhs.true, label %if.else9

land.lhs.true:                                    ; preds = %if.end4
  %3 = load ptr, ptr %bs.addr, align 8
  %options6 = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 33
  %4 = load ptr, ptr %options6, align 8
  %5 = load ptr, ptr %options.addr, align 8
  %cmp7 = icmp ne ptr %4, %5
  br i1 %cmp7, label %if.then8, label %if.else9

if.then8:                                         ; preds = %land.lhs.true
  br label %if.end10

if.else9:                                         ; preds = %land.lhs.true, %if.end4
  call void @__assert_fail(ptr noundef @.str.239, ptr noundef @.str.2, i32 noundef 1863, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_common) #16
  unreachable

if.end10:                                         ; preds = %if.then8
  call void @bdrv_graph_rdunlock_main_loop()
  %call11 = call ptr @qemu_opts_create(ptr noundef @bdrv_runtime_opts, ptr noundef null, i32 noundef 0, ptr noundef @error_abort)
  store ptr %call11, ptr %opts, align 8
  %6 = load ptr, ptr %opts, align 8
  %7 = load ptr, ptr %options.addr, align 8
  %8 = load ptr, ptr %errp.addr, align 8
  %call12 = call zeroext i1 @qemu_opts_absorb_qdict(ptr noundef %6, ptr noundef %7, ptr noundef %8)
  br i1 %call12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end10
  store i32 -22, ptr %ret, align 4
  br label %fail_opts

if.end14:                                         ; preds = %if.end10
  %9 = load ptr, ptr %bs.addr, align 8
  %open_flags15 = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %opts, align 8
  call void @update_flags_from_options(ptr noundef %open_flags15, ptr noundef %10)
  %11 = load ptr, ptr %opts, align 8
  %call16 = call ptr @qemu_opt_get(ptr noundef %11, ptr noundef @.str.20)
  store ptr %call16, ptr %driver_name, align 8
  %12 = load ptr, ptr %driver_name, align 8
  %call17 = call ptr @bdrv_find_format(ptr noundef %12)
  store ptr %call17, ptr %drv, align 8
  %13 = load ptr, ptr %drv, align 8
  %cmp18 = icmp ne ptr %13, null
  br i1 %cmp18, label %if.then19, label %if.else20

if.then19:                                        ; preds = %if.end14
  br label %if.end21

if.else20:                                        ; preds = %if.end14
  call void @__assert_fail(ptr noundef @.str.240, ptr noundef @.str.2, i32 noundef 1876, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_common) #16
  unreachable

if.end21:                                         ; preds = %if.then19
  %14 = load ptr, ptr %opts, align 8
  %call22 = call zeroext i1 @qemu_opt_get_bool(ptr noundef %14, ptr noundef @.str.59, i1 noundef zeroext false)
  %15 = load ptr, ptr %bs.addr, align 8
  %force_share = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 4
  %frombool = zext i1 %call22 to i8
  store i8 %frombool, ptr %force_share, align 1
  %16 = load ptr, ptr %bs.addr, align 8
  %force_share23 = getelementptr inbounds %struct.BlockDriverState, ptr %16, i32 0, i32 4
  %17 = load i8, ptr %force_share23, align 1
  %tobool = trunc i8 %17 to i1
  br i1 %tobool, label %land.lhs.true24, label %if.end28

land.lhs.true24:                                  ; preds = %if.end21
  %18 = load ptr, ptr %bs.addr, align 8
  %open_flags25 = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 0
  %19 = load i32, ptr %open_flags25, align 8
  %and = and i32 %19, 2
  %tobool26 = icmp ne i32 %and, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %land.lhs.true24
  %20 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %20, ptr noundef @.str.2, i32 noundef 1883, ptr noundef @__func__.bdrv_open_common, ptr noundef @.str.241)
  store i32 -22, ptr %ret, align 4
  br label %fail_opts

if.end28:                                         ; preds = %land.lhs.true24, %if.end21
  %21 = load ptr, ptr %file.addr, align 8
  %cmp29 = icmp ne ptr %21, null
  br i1 %cmp29, label %if.then30, label %if.else34

if.then30:                                        ; preds = %if.end28
  call void @bdrv_graph_rdlock_main_loop()
  %22 = load ptr, ptr %file.addr, align 8
  %call31 = call ptr @blk_bs(ptr noundef %22)
  call void @bdrv_refresh_filename(ptr noundef %call31)
  call void @bdrv_graph_rdunlock_main_loop()
  %23 = load ptr, ptr %file.addr, align 8
  %call32 = call ptr @blk_bs(ptr noundef %23)
  %filename33 = getelementptr inbounds %struct.BlockDriverState, ptr %call32, i32 0, i32 11
  %arraydecay = getelementptr inbounds [4096 x i8], ptr %filename33, i64 0, i64 0
  store ptr %arraydecay, ptr %filename, align 8
  br label %if.end36

if.else34:                                        ; preds = %if.end28
  %24 = load ptr, ptr %options.addr, align 8
  %call35 = call ptr @qdict_get_try_str(ptr noundef %24, ptr noundef @.str.5)
  store ptr %call35, ptr %filename, align 8
  br label %if.end36

if.end36:                                         ; preds = %if.else34, %if.then30
  %25 = load ptr, ptr %drv, align 8
  %bdrv_needs_filename = getelementptr inbounds %struct.BlockDriver, ptr %25, i32 0, i32 6
  %26 = load i8, ptr %bdrv_needs_filename, align 8
  %tobool37 = trunc i8 %26 to i1
  br i1 %tobool37, label %land.lhs.true38, label %if.end42

land.lhs.true38:                                  ; preds = %if.end36
  %27 = load ptr, ptr %filename, align 8
  %tobool39 = icmp ne ptr %27, null
  br i1 %tobool39, label %lor.lhs.false, label %if.then41

lor.lhs.false:                                    ; preds = %land.lhs.true38
  %28 = load ptr, ptr %filename, align 8
  %arrayidx = getelementptr i8, ptr %28, i64 0
  %29 = load i8, ptr %arrayidx, align 1
  %tobool40 = icmp ne i8 %29, 0
  br i1 %tobool40, label %if.end42, label %if.then41

if.then41:                                        ; preds = %lor.lhs.false, %land.lhs.true38
  %30 = load ptr, ptr %errp.addr, align 8
  %31 = load ptr, ptr %drv, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %31, i32 0, i32 0
  %32 = load ptr, ptr %format_name, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %30, ptr noundef @.str.2, i32 noundef 1907, ptr noundef @__func__.bdrv_open_common, ptr noundef @.str.242, ptr noundef %32)
  store i32 -22, ptr %ret, align 4
  br label %fail_opts

if.end42:                                         ; preds = %lor.lhs.false, %if.end36
  %33 = load ptr, ptr %bs.addr, align 8
  %34 = load ptr, ptr %filename, align 8
  %tobool43 = icmp ne ptr %34, null
  br i1 %tobool43, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end42
  br label %cond.end

cond.false:                                       ; preds = %if.end42
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %34, %cond.true ], [ @.str.95, %cond.false ]
  %35 = load ptr, ptr %bs.addr, align 8
  %open_flags44 = getelementptr inbounds %struct.BlockDriverState, ptr %35, i32 0, i32 0
  %36 = load i32, ptr %open_flags44, align 8
  %37 = load ptr, ptr %drv, align 8
  %format_name45 = getelementptr inbounds %struct.BlockDriver, ptr %37, i32 0, i32 0
  %38 = load ptr, ptr %format_name45, align 8
  call void @trace_bdrv_open_common(ptr noundef %33, ptr noundef %cond, i32 noundef %36, ptr noundef %38)
  %39 = load ptr, ptr %bs.addr, align 8
  %call46 = call zeroext i1 @bdrv_is_read_only(ptr noundef %39)
  %frombool47 = zext i1 %call46 to i8
  store i8 %frombool47, ptr %ro, align 1
  %40 = load i32, ptr @use_bdrv_whitelist, align 4
  %tobool48 = icmp ne i32 %40, 0
  br i1 %tobool48, label %land.lhs.true49, label %if.end70

land.lhs.true49:                                  ; preds = %cond.end
  %41 = load ptr, ptr %drv, align 8
  %42 = load i8, ptr %ro, align 1
  %tobool50 = trunc i8 %42 to i1
  %call51 = call i32 @bdrv_is_whitelisted(ptr noundef %41, i1 noundef zeroext %tobool50)
  %tobool52 = icmp ne i32 %call51, 0
  br i1 %tobool52, label %if.end70, label %if.then53

if.then53:                                        ; preds = %land.lhs.true49
  %43 = load i8, ptr %ro, align 1
  %tobool54 = trunc i8 %43 to i1
  br i1 %tobool54, label %if.else60, label %land.lhs.true55

land.lhs.true55:                                  ; preds = %if.then53
  %44 = load ptr, ptr %drv, align 8
  %call56 = call i32 @bdrv_is_whitelisted(ptr noundef %44, i1 noundef zeroext true)
  %tobool57 = icmp ne i32 %call56, 0
  br i1 %tobool57, label %if.then58, label %if.else60

if.then58:                                        ; preds = %land.lhs.true55
  call void @bdrv_graph_rdlock_main_loop()
  %45 = load ptr, ptr %bs.addr, align 8
  %call59 = call i32 @bdrv_apply_auto_read_only(ptr noundef %45, ptr noundef null, ptr noundef null)
  store i32 %call59, ptr %ret, align 4
  call void @bdrv_graph_rdunlock_main_loop()
  br label %if.end61

if.else60:                                        ; preds = %land.lhs.true55, %if.then53
  store i32 -95, ptr %ret, align 4
  br label %if.end61

if.end61:                                         ; preds = %if.else60, %if.then58
  %46 = load i32, ptr %ret, align 4
  %cmp62 = icmp slt i32 %46, 0
  br i1 %cmp62, label %if.then63, label %if.end69

if.then63:                                        ; preds = %if.end61
  %47 = load ptr, ptr %errp.addr, align 8
  %48 = load i8, ptr %ro, align 1
  %tobool64 = trunc i8 %48 to i1
  br i1 %tobool64, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %if.then63
  %49 = load ptr, ptr %drv, align 8
  %call65 = call i32 @bdrv_is_whitelisted(ptr noundef %49, i1 noundef zeroext true)
  %tobool66 = icmp ne i32 %call65, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then63
  %50 = phi i1 [ false, %if.then63 ], [ %tobool66, %land.rhs ]
  %cond67 = select i1 %50, ptr @.str.243, ptr @.str.244
  %51 = load ptr, ptr %drv, align 8
  %format_name68 = getelementptr inbounds %struct.BlockDriver, ptr %51, i32 0, i32 0
  %52 = load ptr, ptr %format_name68, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %47, ptr noundef @.str.2, i32 noundef 1930, ptr noundef @__func__.bdrv_open_common, ptr noundef %cond67, ptr noundef %52)
  br label %fail_opts

if.end69:                                         ; preds = %if.end61
  br label %if.end70

if.end70:                                         ; preds = %if.end69, %land.lhs.true49, %cond.end
  br label %while.cond

while.cond:                                       ; preds = %do.end72, %if.end70
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body71

do.body71:                                        ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.2, i32 noundef 1936, ptr noundef @__func__.bdrv_open_common, ptr noundef null) #18
  unreachable

do.end72:                                         ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %53 = load ptr, ptr %bs.addr, align 8
  %copy_on_read = getelementptr inbounds %struct.BlockDriverState, ptr %53, i32 0, i32 42
  %54 = load atomic i32, ptr %copy_on_read monotonic, align 8
  store i32 %54, ptr %atomic-temp, align 4
  %55 = load i32, ptr %atomic-temp, align 4
  store i32 %55, ptr %tmp, align 4
  %56 = load i32, ptr %tmp, align 4
  %cmp73 = icmp eq i32 %56, 0
  br i1 %cmp73, label %if.then74, label %if.else75

if.then74:                                        ; preds = %while.end
  br label %if.end76

if.else75:                                        ; preds = %while.end
  call void @__assert_fail(ptr noundef @.str.245, ptr noundef @.str.2, i32 noundef 1936, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_common) #16
  unreachable

if.end76:                                         ; preds = %if.then74
  %57 = load ptr, ptr %bs.addr, align 8
  %open_flags77 = getelementptr inbounds %struct.BlockDriverState, ptr %57, i32 0, i32 0
  %58 = load i32, ptr %open_flags77, align 8
  %and78 = and i32 %58, 1024
  %tobool79 = icmp ne i32 %and78, 0
  br i1 %tobool79, label %if.then80, label %if.end85

if.then80:                                        ; preds = %if.end76
  %59 = load i8, ptr %ro, align 1
  %tobool81 = trunc i8 %59 to i1
  br i1 %tobool81, label %if.else83, label %if.then82

if.then82:                                        ; preds = %if.then80
  %60 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_enable_copy_on_read(ptr noundef %60)
  br label %if.end84

if.else83:                                        ; preds = %if.then80
  %61 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %61, ptr noundef @.str.2, i32 noundef 1942, ptr noundef @__func__.bdrv_open_common, ptr noundef @.str.246)
  store i32 -22, ptr %ret, align 4
  br label %fail_opts

if.end84:                                         ; preds = %if.then82
  br label %if.end85

if.end85:                                         ; preds = %if.end84, %if.end76
  %62 = load ptr, ptr %opts, align 8
  %call86 = call ptr @qemu_opt_get(ptr noundef %62, ptr noundef @.str.57)
  store ptr %call86, ptr %discard, align 8
  %63 = load ptr, ptr %discard, align 8
  %cmp87 = icmp ne ptr %63, null
  br i1 %cmp87, label %if.then88, label %if.end94

if.then88:                                        ; preds = %if.end85
  %64 = load ptr, ptr %discard, align 8
  %65 = load ptr, ptr %bs.addr, align 8
  %open_flags89 = getelementptr inbounds %struct.BlockDriverState, ptr %65, i32 0, i32 0
  %call90 = call i32 @bdrv_parse_discard_flags(ptr noundef %64, ptr noundef %open_flags89)
  %cmp91 = icmp ne i32 %call90, 0
  br i1 %cmp91, label %if.then92, label %if.end93

if.then92:                                        ; preds = %if.then88
  %66 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %66, ptr noundef @.str.2, i32 noundef 1951, ptr noundef @__func__.bdrv_open_common, ptr noundef @.str.247)
  store i32 -22, ptr %ret, align 4
  br label %fail_opts

if.end93:                                         ; preds = %if.then88
  br label %if.end94

if.end94:                                         ; preds = %if.end93, %if.end85
  %67 = load ptr, ptr %opts, align 8
  %68 = load ptr, ptr %bs.addr, align 8
  %open_flags95 = getelementptr inbounds %struct.BlockDriverState, ptr %68, i32 0, i32 0
  %69 = load i32, ptr %open_flags95, align 8
  %call96 = call i32 @bdrv_parse_detect_zeroes(ptr noundef %67, i32 noundef %69, ptr noundef %local_err)
  %70 = load ptr, ptr %bs.addr, align 8
  %detect_zeroes = getelementptr inbounds %struct.BlockDriverState, ptr %70, i32 0, i32 35
  store i32 %call96, ptr %detect_zeroes, align 8
  %71 = load ptr, ptr %local_err, align 8
  %tobool97 = icmp ne ptr %71, null
  br i1 %tobool97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.end94
  %72 = load ptr, ptr %errp.addr, align 8
  %73 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %72, ptr noundef %73)
  store i32 -22, ptr %ret, align 4
  br label %fail_opts

if.end99:                                         ; preds = %if.end94
  %74 = load ptr, ptr %filename, align 8
  %cmp100 = icmp ne ptr %74, null
  br i1 %cmp100, label %if.then101, label %if.else104

if.then101:                                       ; preds = %if.end99
  %75 = load ptr, ptr %bs.addr, align 8
  %filename102 = getelementptr inbounds %struct.BlockDriverState, ptr %75, i32 0, i32 11
  %arraydecay103 = getelementptr inbounds [4096 x i8], ptr %filename102, i64 0, i64 0
  %76 = load ptr, ptr %filename, align 8
  call void @pstrcpy(ptr noundef %arraydecay103, i32 noundef 4096, ptr noundef %76)
  br label %if.end107

if.else104:                                       ; preds = %if.end99
  %77 = load ptr, ptr %bs.addr, align 8
  %filename105 = getelementptr inbounds %struct.BlockDriverState, ptr %77, i32 0, i32 11
  %arrayidx106 = getelementptr [4096 x i8], ptr %filename105, i64 0, i64 0
  store i8 0, ptr %arrayidx106, align 1
  br label %if.end107

if.end107:                                        ; preds = %if.else104, %if.then101
  %78 = load ptr, ptr %bs.addr, align 8
  %exact_filename = getelementptr inbounds %struct.BlockDriverState, ptr %78, i32 0, i32 16
  %arraydecay108 = getelementptr inbounds [4096 x i8], ptr %exact_filename, i64 0, i64 0
  %79 = load ptr, ptr %bs.addr, align 8
  %filename109 = getelementptr inbounds %struct.BlockDriverState, ptr %79, i32 0, i32 11
  %arraydecay110 = getelementptr inbounds [4096 x i8], ptr %filename109, i64 0, i64 0
  call void @pstrcpy(ptr noundef %arraydecay108, i32 noundef 4096, ptr noundef %arraydecay110)
  %80 = load ptr, ptr %bs.addr, align 8
  %81 = load ptr, ptr %bs.addr, align 8
  %open_flags111 = getelementptr inbounds %struct.BlockDriverState, ptr %81, i32 0, i32 0
  %82 = load i32, ptr %open_flags111, align 8
  %call112 = call i32 @bdrv_open_flags(ptr noundef %80, i32 noundef %82)
  store i32 %call112, ptr %open_flags, align 4
  %83 = load ptr, ptr %opts, align 8
  %call113 = call ptr @qemu_opt_get(ptr noundef %83, ptr noundef @.str.44)
  store ptr %call113, ptr %node_name, align 8
  %84 = load ptr, ptr %drv, align 8
  %bdrv_file_open = getelementptr inbounds %struct.BlockDriver, ptr %84, i32 0, i32 24
  %85 = load ptr, ptr %bdrv_file_open, align 8
  %tobool114 = icmp ne ptr %85, null
  br i1 %tobool114, label %lor.lhs.false115, label %if.then117

lor.lhs.false115:                                 ; preds = %if.end107
  %86 = load ptr, ptr %file.addr, align 8
  %cmp116 = icmp eq ptr %86, null
  br i1 %cmp116, label %if.then117, label %if.else118

if.then117:                                       ; preds = %lor.lhs.false115, %if.end107
  br label %if.end119

if.else118:                                       ; preds = %lor.lhs.false115
  call void @__assert_fail(ptr noundef @.str.248, ptr noundef @.str.2, i32 noundef 1976, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_common) #16
  unreachable

if.end119:                                        ; preds = %if.then117
  %87 = load ptr, ptr %bs.addr, align 8
  %88 = load ptr, ptr %drv, align 8
  %89 = load ptr, ptr %node_name, align 8
  %90 = load ptr, ptr %options.addr, align 8
  %91 = load i32, ptr %open_flags, align 4
  %92 = load ptr, ptr %errp.addr, align 8
  %call120 = call i32 @bdrv_open_driver(ptr noundef %87, ptr noundef %88, ptr noundef %89, ptr noundef %90, i32 noundef %91, ptr noundef %92)
  store i32 %call120, ptr %ret, align 4
  %93 = load i32, ptr %ret, align 4
  %cmp121 = icmp slt i32 %93, 0
  br i1 %cmp121, label %if.then122, label %if.end123

if.then122:                                       ; preds = %if.end119
  br label %fail_opts

if.end123:                                        ; preds = %if.end119
  %94 = load ptr, ptr %opts, align 8
  call void @qemu_opts_del(ptr noundef %94)
  store i32 0, ptr %retval, align 4
  br label %return

fail_opts:                                        ; preds = %if.then122, %if.then98, %if.then92, %if.else83, %land.end, %if.then41, %if.then27, %if.then13
  %95 = load ptr, ptr %opts, align 8
  call void @qemu_opts_del(ptr noundef %95)
  %96 = load i32, ptr %ret, align 4
  store i32 %96, ptr %retval, align 4
  br label %return

return:                                           ; preds = %fail_opts, %if.end123
  %97 = load i32, ptr %retval, align 4
  ret i32 %97
}

declare void @blk_unref(ptr noundef) #2

declare ptr @qdict_first(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_parent_cb_change_media(ptr noundef %bs, i1 noundef zeroext %load) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %load.addr = alloca i8, align 1
  %c = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %frombool = zext i1 %load to i8
  store i8 %frombool, ptr %load.addr, align 1
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3396, ptr noundef @__PRETTY_FUNCTION__.bdrv_parent_cb_change_media) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %parents = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 32
  %lh_first = getelementptr inbounds %struct.anon.4, ptr %parents, i32 0, i32 0
  %1 = load ptr, ptr %lh_first, align 8
  store ptr %1, ptr %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %2 = load ptr, ptr %c, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %c, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %3, i32 0, i32 2
  %4 = load ptr, ptr %klass, align 8
  %change_media = getelementptr inbounds %struct.BdrvChildClass, ptr %4, i32 0, i32 3
  %5 = load ptr, ptr %change_media, align 8
  %tobool1 = icmp ne ptr %5, null
  br i1 %tobool1, label %if.then2, label %if.end6

if.then2:                                         ; preds = %for.body
  %6 = load ptr, ptr %c, align 8
  %klass3 = getelementptr inbounds %struct.BdrvChild, ptr %6, i32 0, i32 2
  %7 = load ptr, ptr %klass3, align 8
  %change_media4 = getelementptr inbounds %struct.BdrvChildClass, ptr %7, i32 0, i32 3
  %8 = load ptr, ptr %change_media4, align 8
  %9 = load ptr, ptr %c, align 8
  %10 = load i8, ptr %load.addr, align 1
  %tobool5 = trunc i8 %10 to i1
  call void %8(ptr noundef %9, i1 noundef zeroext %tobool5)
  br label %if.end6

if.end6:                                          ; preds = %if.then2, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end6
  %11 = load ptr, ptr %c, align 8
  %next_parent = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 10
  %le_next = getelementptr inbounds %struct.anon.15, ptr %next_parent, i32 0, i32 0
  %12 = load ptr, ptr %le_next, align 8
  store ptr %12, ptr %c, align 8
  br label %for.cond, !llvm.loop !100

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @bdrv_append_temp_snapshot(ptr noundef %bs, i32 noundef %flags, ptr noundef %snapshot_options, ptr noundef %errp) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %snapshot_options.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %tmp_filename = alloca ptr, align 8
  %total_size = alloca i64, align 8
  %opts = alloca ptr, align 8
  %bs_snapshot = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %ret = alloca i32, align 4
  %_obj26 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp25 = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %snapshot_options, ptr %snapshot_options.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %tmp_filename, align 8
  store ptr null, ptr %opts, align 8
  store ptr null, ptr %bs_snapshot, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %call = call ptr @bdrv_get_aio_context(ptr noundef %0)
  store ptr %call, ptr %ctx, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call1 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 3887, ptr noundef @__PRETTY_FUNCTION__.bdrv_append_temp_snapshot) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  %1 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %1)
  %2 = load ptr, ptr %bs.addr, align 8
  %call2 = call i64 @bdrv_getlength(ptr noundef %2)
  store i64 %call2, ptr %total_size, align 8
  %3 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %3)
  %4 = load i64, ptr %total_size, align 8
  %cmp = icmp slt i64 %4, 0
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %do.end
  %5 = load ptr, ptr %errp.addr, align 8
  %6 = load i64, ptr %total_size, align 8
  %sub = sub i64 0, %6
  %conv = trunc i64 %sub to i32
  call void (ptr, ptr, i32, ptr, i32, ptr, ...) @error_setg_errno_internal(ptr noundef %5, ptr noundef @.str.2, i32 noundef 3898, ptr noundef @__func__.bdrv_append_temp_snapshot, i32 noundef %conv, ptr noundef @.str.252)
  br label %out

if.end4:                                          ; preds = %do.end
  %7 = load ptr, ptr %errp.addr, align 8
  %call5 = call ptr @create_tmp_file(ptr noundef %7)
  store ptr %call5, ptr %tmp_filename, align 8
  %8 = load ptr, ptr %tmp_filename, align 8
  %tobool = icmp ne ptr %8, null
  br i1 %tobool, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end4
  br label %out

if.end7:                                          ; preds = %if.end4
  %9 = load ptr, ptr getelementptr inbounds (%struct.BlockDriver, ptr @bdrv_qcow2, i32 0, i32 9), align 8
  %call8 = call ptr @qemu_opts_create(ptr noundef %9, ptr noundef null, i32 noundef 0, ptr noundef @error_abort)
  store ptr %call8, ptr %opts, align 8
  %10 = load ptr, ptr %opts, align 8
  %11 = load i64, ptr %total_size, align 8
  %call9 = call zeroext i1 @qemu_opt_set_number(ptr noundef %10, ptr noundef @.str.17, i64 noundef %11, ptr noundef @error_abort)
  %12 = load ptr, ptr %tmp_filename, align 8
  %13 = load ptr, ptr %opts, align 8
  %14 = load ptr, ptr %errp.addr, align 8
  %call10 = call i32 @bdrv_create(ptr noundef @bdrv_qcow2, ptr noundef %12, ptr noundef %13, ptr noundef %14)
  store i32 %call10, ptr %ret, align 4
  %15 = load ptr, ptr %opts, align 8
  call void @qemu_opts_del(ptr noundef %15)
  %16 = load i32, ptr %ret, align 4
  %cmp11 = icmp slt i32 %16, 0
  br i1 %cmp11, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end7
  %17 = load ptr, ptr %errp.addr, align 8
  %18 = load ptr, ptr %tmp_filename, align 8
  call void (ptr, ptr, ...) @error_prepend(ptr noundef %17, ptr noundef @.str.253, ptr noundef %18)
  br label %out

if.end14:                                         ; preds = %if.end7
  %19 = load ptr, ptr %snapshot_options.addr, align 8
  call void @qdict_put_str(ptr noundef %19, ptr noundef @.str.254, ptr noundef @.str.214)
  %20 = load ptr, ptr %snapshot_options.addr, align 8
  %21 = load ptr, ptr %tmp_filename, align 8
  call void @qdict_put_str(ptr noundef %20, ptr noundef @.str.77, ptr noundef %21)
  %22 = load ptr, ptr %snapshot_options.addr, align 8
  call void @qdict_put_str(ptr noundef %22, ptr noundef @.str.20, ptr noundef @.str.255)
  %23 = load ptr, ptr %snapshot_options.addr, align 8
  %24 = load i32, ptr %flags.addr, align 4
  %25 = load ptr, ptr %errp.addr, align 8
  %call15 = call ptr @bdrv_open(ptr noundef null, ptr noundef null, ptr noundef %23, i32 noundef %24, ptr noundef %25)
  store ptr %call15, ptr %bs_snapshot, align 8
  store ptr null, ptr %snapshot_options.addr, align 8
  %26 = load ptr, ptr %bs_snapshot, align 8
  %tobool16 = icmp ne ptr %26, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end14
  br label %out

if.end18:                                         ; preds = %if.end14
  %27 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %27)
  %28 = load ptr, ptr %bs_snapshot, align 8
  %29 = load ptr, ptr %bs.addr, align 8
  %30 = load ptr, ptr %errp.addr, align 8
  %call19 = call i32 @bdrv_append(ptr noundef %28, ptr noundef %29, ptr noundef %30)
  store i32 %call19, ptr %ret, align 4
  %31 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %31)
  %32 = load i32, ptr %ret, align 4
  %cmp20 = icmp slt i32 %32, 0
  br i1 %cmp20, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.end18
  store ptr null, ptr %bs_snapshot, align 8
  br label %out

if.end23:                                         ; preds = %if.end18
  br label %out

out:                                              ; preds = %if.end23, %if.then22, %if.then17, %if.then13, %if.then6, %if.then3
  %33 = load ptr, ptr %snapshot_options.addr, align 8
  store ptr %33, ptr %_obj26, align 8
  %34 = load ptr, ptr %_obj26, align 8
  %tobool24 = icmp ne ptr %34, null
  br i1 %tobool24, label %cond.true, label %cond.false

cond.true:                                        ; preds = %out
  %35 = load ptr, ptr %_obj26, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %35, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %36 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %36, i64 0
  store ptr %add.ptr, ptr %tmp25, align 8
  %37 = load ptr, ptr %tmp25, align 8
  br label %cond.end

cond.false:                                       ; preds = %out
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %37, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %38 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %38)
  %39 = load ptr, ptr %bs_snapshot, align 8
  call void @g_autoptr_cleanup_generic_gfree(ptr noundef %tmp_filename)
  ret ptr %39
}

declare i32 @g_str_has_prefix(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @parse_json_filename(ptr noundef %filename, ptr noundef %errp) #0 {
entry:
  %retval = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %options_obj = alloca ptr, align 8
  %options = alloca ptr, align 8
  %ret = alloca i32, align 4
  %_obj16 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp13 = alloca ptr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1995, ptr noundef @__PRETTY_FUNCTION__.parse_json_filename) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %filename.addr, align 8
  %call1 = call i32 @strstart(ptr noundef %0, ptr noundef @.str.8, ptr noundef %filename.addr)
  store i32 %call1, ptr %ret, align 4
  %1 = load i32, ptr %ret, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then2, label %if.else3

if.then2:                                         ; preds = %do.end
  br label %if.end4

if.else3:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.230, ptr noundef @.str.2, i32 noundef 1998, ptr noundef @__PRETTY_FUNCTION__.parse_json_filename) #16
  unreachable

if.end4:                                          ; preds = %if.then2
  %2 = load ptr, ptr %filename.addr, align 8
  %3 = load ptr, ptr %errp.addr, align 8
  %call5 = call ptr @qobject_from_json(ptr noundef %2, ptr noundef %3)
  store ptr %call5, ptr %options_obj, align 8
  %4 = load ptr, ptr %options_obj, align 8
  %tobool6 = icmp ne ptr %4, null
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %if.end4
  %5 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, ...) @error_prepend(ptr noundef %5, ptr noundef @.str.231)
  store ptr null, ptr %retval, align 8
  br label %return

if.end8:                                          ; preds = %if.end4
  %6 = load ptr, ptr %options_obj, align 8
  %call9 = call ptr @qobject_check_type(ptr noundef %6, i32 noundef 4)
  store ptr %call9, ptr %options, align 8
  %7 = load ptr, ptr %options, align 8
  %tobool10 = icmp ne ptr %7, null
  br i1 %tobool10, label %if.end14, label %if.then11

if.then11:                                        ; preds = %if.end8
  %8 = load ptr, ptr %options_obj, align 8
  store ptr %8, ptr %_obj16, align 8
  %9 = load ptr, ptr %_obj16, align 8
  %tobool12 = icmp ne ptr %9, null
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then11
  %10 = load ptr, ptr %_obj16, align 8
  %base = getelementptr inbounds %struct.QObject, ptr %10, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %11 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %11, i64 0
  store ptr %add.ptr, ptr %tmp13, align 8
  %12 = load ptr, ptr %tmp13, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then11
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %12, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %13 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %13)
  %14 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %14, ptr noundef @.str.2, i32 noundef 2009, ptr noundef @__func__.parse_json_filename, ptr noundef @.str.232)
  store ptr null, ptr %retval, align 8
  br label %return

if.end14:                                         ; preds = %if.end8
  %15 = load ptr, ptr %options, align 8
  call void @qdict_flatten(ptr noundef %15)
  %16 = load ptr, ptr %options, align 8
  store ptr %16, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end14, %cond.end, %if.then7
  %17 = load ptr, ptr %retval, align 8
  ret ptr %17
}

declare void @qdict_join(ptr noundef, ptr noundef, i1 noundef zeroext) #2

declare ptr @qobject_from_json(ptr noundef, ptr noundef) #2

declare zeroext i1 @blk_is_sg(ptr noundef) #2

declare zeroext i1 @blk_is_inserted(ptr noundef) #2

declare i64 @blk_getlength(ptr noundef) #2

declare i32 @blk_pread(ptr noundef, i64 noundef, i64 noundef, ptr noundef, i32 noundef) #2

declare zeroext i1 @qemu_opts_absorb_qdict(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @update_flags_from_options(ptr noundef %flags, ptr noundef %opts) #0 {
entry:
  %flags.addr = alloca ptr, align 8
  %opts.addr = alloca ptr, align 8
  store ptr %flags, ptr %flags.addr, align 8
  store ptr %opts, ptr %opts.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1535, ptr noundef @__PRETTY_FUNCTION__.update_flags_from_options) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %flags.addr, align 8
  %1 = load i32, ptr %0, align 4
  %and = and i32 %1, -131619
  store i32 %and, ptr %0, align 4
  %2 = load ptr, ptr %opts.addr, align 8
  %call1 = call zeroext i1 @qemu_opt_get_bool_del(ptr noundef %2, ptr noundef @.str.49, i1 noundef zeroext false)
  br i1 %call1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  %3 = load ptr, ptr %flags.addr, align 8
  %4 = load i32, ptr %3, align 4
  %or = or i32 %4, 512
  store i32 %or, ptr %3, align 4
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %do.end
  %5 = load ptr, ptr %opts.addr, align 8
  %call4 = call zeroext i1 @qemu_opt_get_bool_del(ptr noundef %5, ptr noundef @.str.47, i1 noundef zeroext false)
  br i1 %call4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end3
  %6 = load ptr, ptr %flags.addr, align 8
  %7 = load i32, ptr %6, align 4
  %or6 = or i32 %7, 32
  store i32 %or6, ptr %6, align 4
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end3
  %8 = load ptr, ptr %opts.addr, align 8
  %call8 = call zeroext i1 @qemu_opt_get_bool_del(ptr noundef %8, ptr noundef @.str.51, i1 noundef zeroext false)
  br i1 %call8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end7
  %9 = load ptr, ptr %flags.addr, align 8
  %10 = load i32, ptr %9, align 4
  %or10 = or i32 %10, 2
  store i32 %or10, ptr %9, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end7
  %11 = load ptr, ptr %opts.addr, align 8
  %call12 = call zeroext i1 @qemu_opt_get_bool_del(ptr noundef %11, ptr noundef @.str.53, i1 noundef zeroext false)
  br i1 %call12, label %if.then13, label %if.end15

if.then13:                                        ; preds = %if.end11
  %12 = load ptr, ptr %flags.addr, align 8
  %13 = load i32, ptr %12, align 4
  %or14 = or i32 %13, 131072
  store i32 %or14, ptr %12, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then13, %if.end11
  ret void
}

declare zeroext i1 @qemu_opt_get_bool(ptr noundef, ptr noundef, i1 noundef zeroext) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @trace_bdrv_open_common(ptr noundef %bs, ptr noundef %filename, i32 noundef %flags, ptr noundef %format_name) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %format_name.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %format_name, ptr %format_name.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %1 = load ptr, ptr %filename.addr, align 8
  %2 = load i32, ptr %flags.addr, align 4
  %3 = load ptr, ptr %format_name.addr, align 8
  call void @_nocheck__trace_bdrv_open_common(ptr noundef %0, ptr noundef %1, i32 noundef %2, ptr noundef %3)
  ret void
}

declare void @bdrv_enable_copy_on_read(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_parse_detect_zeroes(ptr noundef %opts, i32 noundef %open_flags, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %opts.addr = alloca ptr, align 8
  %open_flags.addr = alloca i32, align 4
  %errp.addr = alloca ptr, align 8
  %local_err = alloca ptr, align 8
  %value = alloca ptr, align 8
  %detect_zeroes = alloca i32, align 4
  store ptr %opts, ptr %opts.addr, align 8
  store i32 %open_flags, ptr %open_flags.addr, align 4
  store ptr %errp, ptr %errp.addr, align 8
  store ptr null, ptr %local_err, align 8
  %0 = load ptr, ptr %opts.addr, align 8
  %call = call ptr @qemu_opt_get_del(ptr noundef %0, ptr noundef @.str.55)
  store ptr %call, ptr %value, align 8
  %1 = load ptr, ptr %value, align 8
  %call1 = call i32 @qapi_enum_parse(ptr noundef @BlockdevDetectZeroesOptions_lookup, ptr noundef %1, i32 noundef 0, ptr noundef %local_err)
  store i32 %call1, ptr %detect_zeroes, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %call2 = call zeroext i1 @qemu_in_main_thread()
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1108, ptr noundef @__PRETTY_FUNCTION__.bdrv_parse_detect_zeroes) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %2 = load ptr, ptr %value, align 8
  call void @g_free(ptr noundef %2)
  %3 = load ptr, ptr %local_err, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %if.then3, label %if.end4

if.then3:                                         ; preds = %do.end
  %4 = load ptr, ptr %errp.addr, align 8
  %5 = load ptr, ptr %local_err, align 8
  call void @error_propagate(ptr noundef %4, ptr noundef %5)
  %6 = load i32, ptr %detect_zeroes, align 4
  store i32 %6, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %do.end
  %7 = load i32, ptr %detect_zeroes, align 4
  %cmp = icmp eq i32 %7, 2
  br i1 %cmp, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end4
  %8 = load i32, ptr %open_flags.addr, align 4
  %and = and i32 %8, 16384
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %land.lhs.true
  %9 = load ptr, ptr %errp.addr, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %9, ptr noundef @.str.2, i32 noundef 1119, ptr noundef @__func__.bdrv_parse_detect_zeroes, ptr noundef @.str.251)
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %land.lhs.true, %if.end4
  %10 = load i32, ptr %detect_zeroes, align 4
  store i32 %10, ptr %retval, align 4
  br label %return

return:                                           ; preds = %if.end7, %if.then3
  %11 = load i32, ptr %retval, align 4
  ret i32 %11
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_open_flags(ptr noundef %bs, i32 noundef %flags) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %open_flags = alloca i32, align 4
  store ptr %bs, ptr %bs.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  %0 = load i32, ptr %flags.addr, align 4
  store i32 %0, ptr %open_flags, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1522, ptr noundef @__PRETTY_FUNCTION__.bdrv_open_flags) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load i32, ptr %open_flags, align 4
  %and = and i32 %1, -33033
  store i32 %and, ptr %open_flags, align 4
  %2 = load i32, ptr %open_flags, align 4
  ret i32 %2
}

declare zeroext i1 @qemu_opt_get_bool_del(ptr noundef, ptr noundef, i1 noundef zeroext) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_bdrv_open_common(ptr noundef %bs, ptr noundef %filename, i32 noundef %flags, ptr noundef %format_name) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %filename.addr = alloca ptr, align 8
  %flags.addr = alloca i32, align 4
  %format_name.addr = alloca ptr, align 8
  %_now = alloca %struct.timeval, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %filename, ptr %filename.addr, align 8
  store i32 %flags, ptr %flags.addr, align 4
  store ptr %format_name, ptr %format_name.addr, align 8
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end11

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_BDRV_OPEN_COMMON_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end11

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end11

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #15
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load ptr, ptr %bs.addr, align 8
  %6 = load ptr, ptr %filename.addr, align 8
  %7 = load i32, ptr %flags.addr, align 4
  %8 = load ptr, ptr %format_name.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.249, i32 noundef %call10, i64 noundef %3, i64 noundef %4, ptr noundef %5, ptr noundef %6, i32 noundef %7, ptr noundef %8)
  br label %if.end

if.else:                                          ; preds = %if.then
  %9 = load ptr, ptr %bs.addr, align 8
  %10 = load ptr, ptr %filename.addr, align 8
  %11 = load i32, ptr %flags.addr, align 4
  %12 = load ptr, ptr %format_name.addr, align 8
  call void (ptr, ...) @qemu_log(ptr noundef @.str.250, ptr noundef %9, ptr noundef %10, i32 noundef %11, ptr noundef %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end11

if.end11:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @qemu_loglevel_mask(i32 noundef %mask) #0 {
entry:
  %mask.addr = alloca i32, align 4
  store i32 %mask, ptr %mask.addr, align 4
  %0 = load i32, ptr @qemu_loglevel, align 4
  %1 = load i32, ptr %mask.addr, align 4
  %and = and i32 %0, %1
  %cmp = icmp ne i32 %and, 0
  ret i1 %cmp
}

; Function Attrs: nounwind
declare i32 @gettimeofday(ptr noundef, ptr noundef) #5

declare void @qemu_log(ptr noundef, ...) #2

declare i32 @qemu_get_thread_id() #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_join_options(ptr noundef %bs, ptr noundef %options, ptr noundef %old_options) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %options.addr = alloca ptr, align 8
  %old_options.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %options, ptr %options.addr, align 8
  store ptr %old_options, ptr %old_options.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 1091, ptr noundef @__PRETTY_FUNCTION__.bdrv_join_options) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 6
  %1 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %1, null
  br i1 %tobool, label %land.lhs.true, label %if.else6

land.lhs.true:                                    ; preds = %do.end
  %2 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv1, align 8
  %bdrv_join_options = getelementptr inbounds %struct.BlockDriver, ptr %3, i32 0, i32 22
  %4 = load ptr, ptr %bdrv_join_options, align 8
  %tobool2 = icmp ne ptr %4, null
  br i1 %tobool2, label %if.then3, label %if.else6

if.then3:                                         ; preds = %land.lhs.true
  %5 = load ptr, ptr %bs.addr, align 8
  %drv4 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %drv4, align 8
  %bdrv_join_options5 = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 22
  %7 = load ptr, ptr %bdrv_join_options5, align 8
  %8 = load ptr, ptr %options.addr, align 8
  %9 = load ptr, ptr %old_options.addr, align 8
  call void %7(ptr noundef %8, ptr noundef %9)
  br label %if.end7

if.else6:                                         ; preds = %land.lhs.true, %do.end
  %10 = load ptr, ptr %options.addr, align 8
  %11 = load ptr, ptr %old_options.addr, align 8
  call void @qdict_join(ptr noundef %10, ptr noundef %11, i1 noundef zeroext false)
  br label %if.end7

if.end7:                                          ; preds = %if.else6, %if.then3
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_clear_GSList(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %_ptr.addr, align 8
  call void @g_slist_free(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_reset_options_allowed(ptr noundef %bs, ptr noundef %new_opts, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %bs.addr = alloca ptr, align 8
  %new_opts.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %e = alloca ptr, align 8
  %common_options = alloca [8 x ptr], align 16
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %new_opts, ptr %new_opts.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr align 16 %common_options, ptr align 16 @__const.bdrv_reset_options_allowed.common_options, i64 64, i1 false)
  %0 = load ptr, ptr %bs.addr, align 8
  %options = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 33
  %1 = load ptr, ptr %options, align 8
  %call = call ptr @qdict_first(ptr noundef %1)
  store ptr %call, ptr %e, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load ptr, ptr %e, align 8
  %tobool = icmp ne ptr %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load ptr, ptr %new_opts.addr, align 8
  %4 = load ptr, ptr %e, align 8
  %key = getelementptr inbounds %struct.QDictEntry, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %key, align 8
  %call1 = call i32 @qdict_haskey(ptr noundef %3, ptr noundef %5)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %6 = load ptr, ptr %e, align 8
  %key3 = getelementptr inbounds %struct.QDictEntry, ptr %6, i32 0, i32 0
  %7 = load ptr, ptr %key3, align 8
  %arraydecay = getelementptr inbounds [8 x ptr], ptr %common_options, i64 0, i64 0
  %call4 = call zeroext i1 @is_str_in_list(ptr noundef %7, ptr noundef %arraydecay)
  br i1 %call4, label %if.end, label %land.lhs.true5

land.lhs.true5:                                   ; preds = %land.lhs.true
  %8 = load ptr, ptr %e, align 8
  %key6 = getelementptr inbounds %struct.QDictEntry, ptr %8, i32 0, i32 0
  %9 = load ptr, ptr %key6, align 8
  %10 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 6
  %11 = load ptr, ptr %drv, align 8
  %mutable_opts = getelementptr inbounds %struct.BlockDriver, ptr %11, i32 0, i32 11
  %12 = load ptr, ptr %mutable_opts, align 8
  %call7 = call zeroext i1 @is_str_in_list(ptr noundef %9, ptr noundef %12)
  br i1 %call7, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true5
  %13 = load ptr, ptr %errp.addr, align 8
  %14 = load ptr, ptr %e, align 8
  %key8 = getelementptr inbounds %struct.QDictEntry, ptr %14, i32 0, i32 0
  %15 = load ptr, ptr %key8, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %13, ptr noundef @.str.2, i32 noundef 4315, ptr noundef @__func__.bdrv_reset_options_allowed, ptr noundef @.str.264, ptr noundef %15)
  store i32 -22, ptr %retval, align 4
  br label %return

if.end:                                           ; preds = %land.lhs.true5, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %16 = load ptr, ptr %bs.addr, align 8
  %options9 = getelementptr inbounds %struct.BlockDriverState, ptr %16, i32 0, i32 33
  %17 = load ptr, ptr %options9, align 8
  %18 = load ptr, ptr %e, align 8
  %call10 = call ptr @qdict_next(ptr noundef %17, ptr noundef %18)
  store ptr %call10, ptr %e, align 8
  br label %for.cond, !llvm.loop !101

for.end:                                          ; preds = %for.cond
  store i32 0, ptr %retval, align 4
  br label %return

return:                                           ; preds = %for.end, %if.then
  %19 = load i32, ptr %retval, align 4
  ret i32 %19
}

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @bdrv_reopen_parse_file_or_backing(ptr noundef %reopen_state, i1 noundef zeroext %is_backing, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca i32, align 4
  %reopen_state.addr = alloca ptr, align 8
  %is_backing.addr = alloca i8, align 1
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %new_child_bs = alloca ptr, align 8
  %old_child_bs = alloca ptr, align 8
  %child_name = alloca ptr, align 8
  %value = alloca ptr, align 8
  %str = alloca ptr, align 8
  %ctx = alloca ptr, align 8
  %old_ctx = alloca ptr, align 8
  %has_child = alloca i8, align 1
  %ret = alloca i32, align 4
  store ptr %reopen_state, ptr %reopen_state.addr, align 8
  %frombool = zext i1 %is_backing to i8
  store i8 %frombool, ptr %is_backing.addr, align 1
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  %0 = load ptr, ptr %reopen_state.addr, align 8
  %bs1 = getelementptr inbounds %struct.BDRVReopenState, ptr %0, i32 0, i32 0
  %1 = load ptr, ptr %bs1, align 8
  store ptr %1, ptr %bs, align 8
  %2 = load i8, ptr %is_backing.addr, align 1
  %tobool = trunc i8 %2 to i1
  %cond = select i1 %tobool, ptr @.str.89, ptr @.str.214
  store ptr %cond, ptr %child_name, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 4767, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_parse_file_or_backing) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %3 = load ptr, ptr %reopen_state.addr, align 8
  %options = getelementptr inbounds %struct.BDRVReopenState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %options, align 8
  %5 = load ptr, ptr %child_name, align 8
  %call2 = call ptr @qdict_get(ptr noundef %4, ptr noundef %5)
  store ptr %call2, ptr %value, align 8
  %6 = load ptr, ptr %value, align 8
  %cmp = icmp eq ptr %6, null
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %do.end
  store i32 0, ptr %retval, align 4
  br label %return

if.end4:                                          ; preds = %do.end
  call void @bdrv_graph_rdlock_main_loop()
  %7 = load ptr, ptr %value, align 8
  %call5 = call i32 @qobject_type(ptr noundef %7)
  switch i32 %call5, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb10
  ]

sw.bb:                                            ; preds = %if.end4
  %8 = load i8, ptr %is_backing.addr, align 1
  %tobool6 = trunc i8 %8 to i1
  br i1 %tobool6, label %if.then7, label %if.else8

if.then7:                                         ; preds = %sw.bb
  br label %if.end9

if.else8:                                         ; preds = %sw.bb
  call void @__assert_fail(ptr noundef @.str.265, ptr noundef @.str.2, i32 noundef 4778, ptr noundef @__PRETTY_FUNCTION__.bdrv_reopen_parse_file_or_backing) #16
  unreachable

if.end9:                                          ; preds = %if.then7
  store ptr null, ptr %new_child_bs, align 8
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.end4
  %9 = load ptr, ptr %value, align 8
  %call11 = call ptr @qobject_check_type(ptr noundef %9, i32 noundef 3)
  %call12 = call ptr @qstring_get_str(ptr noundef %call11)
  store ptr %call12, ptr %str, align 8
  %10 = load ptr, ptr %str, align 8
  %11 = load ptr, ptr %errp.addr, align 8
  %call13 = call ptr @bdrv_lookup_bs(ptr noundef null, ptr noundef %10, ptr noundef %11)
  store ptr %call13, ptr %new_child_bs, align 8
  %12 = load ptr, ptr %new_child_bs, align 8
  %cmp14 = icmp eq ptr %12, null
  br i1 %cmp14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %sw.bb10
  store i32 -22, ptr %ret, align 4
  br label %out_rdlock

if.end16:                                         ; preds = %sw.bb10
  %13 = load ptr, ptr %new_child_bs, align 8
  %14 = load ptr, ptr %bs, align 8
  %call17 = call zeroext i1 @bdrv_recurse_has_child(ptr noundef %13, ptr noundef %14)
  %frombool18 = zext i1 %call17 to i8
  store i8 %frombool18, ptr %has_child, align 1
  %15 = load i8, ptr %has_child, align 1
  %tobool19 = trunc i8 %15 to i1
  br i1 %tobool19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end16
  %16 = load ptr, ptr %errp.addr, align 8
  %17 = load ptr, ptr %str, align 8
  %18 = load ptr, ptr %child_name, align 8
  %19 = load ptr, ptr %bs, align 8
  %node_name = getelementptr inbounds %struct.BlockDriverState, ptr %19, i32 0, i32 22
  %arraydecay = getelementptr inbounds [32 x i8], ptr %node_name, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %16, ptr noundef @.str.2, i32 noundef 4792, ptr noundef @__func__.bdrv_reopen_parse_file_or_backing, ptr noundef @.str.202, ptr noundef %17, ptr noundef %18, ptr noundef %arraydecay)
  store i32 -22, ptr %ret, align 4
  br label %out_rdlock

if.end21:                                         ; preds = %if.end16
  br label %sw.epilog

sw.default:                                       ; preds = %if.end4
  br label %do.body22

do.body22:                                        ; preds = %sw.default
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.2, i32 noundef 4802, ptr noundef @__func__.bdrv_reopen_parse_file_or_backing, ptr noundef null) #18
  unreachable

do.end23:                                         ; No predecessors!
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end23, %if.end21, %if.end9
  %20 = load i8, ptr %is_backing.addr, align 1
  %tobool24 = trunc i8 %20 to i1
  br i1 %tobool24, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.epilog
  %21 = load ptr, ptr %bs, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %21, i32 0, i32 30
  %22 = load ptr, ptr %backing, align 8
  %call25 = call ptr @child_bs(ptr noundef %22)
  br label %cond.end

cond.false:                                       ; preds = %sw.epilog
  %23 = load ptr, ptr %bs, align 8
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %23, i32 0, i32 31
  %24 = load ptr, ptr %file, align 8
  %call26 = call ptr @child_bs(ptr noundef %24)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond27 = phi ptr [ %call25, %cond.true ], [ %call26, %cond.false ]
  store ptr %cond27, ptr %old_child_bs, align 8
  %25 = load ptr, ptr %old_child_bs, align 8
  %26 = load ptr, ptr %new_child_bs, align 8
  %cmp28 = icmp eq ptr %25, %26
  br i1 %cmp28, label %if.then29, label %if.end30

if.then29:                                        ; preds = %cond.end
  store i32 0, ptr %ret, align 4
  br label %out_rdlock

if.end30:                                         ; preds = %cond.end
  %27 = load ptr, ptr %old_child_bs, align 8
  %tobool31 = icmp ne ptr %27, null
  br i1 %tobool31, label %if.then32, label %if.end42

if.then32:                                        ; preds = %if.end30
  %28 = load ptr, ptr %old_child_bs, align 8
  %call33 = call ptr @bdrv_skip_implicit_filters(ptr noundef %28)
  %29 = load ptr, ptr %new_child_bs, align 8
  %cmp34 = icmp eq ptr %call33, %29
  br i1 %cmp34, label %if.then35, label %if.end36

if.then35:                                        ; preds = %if.then32
  store i32 0, ptr %ret, align 4
  br label %out_rdlock

if.end36:                                         ; preds = %if.then32
  %30 = load ptr, ptr %old_child_bs, align 8
  %implicit = getelementptr inbounds %struct.BlockDriverState, ptr %30, i32 0, i32 5
  %31 = load i8, ptr %implicit, align 8
  %tobool37 = trunc i8 %31 to i1
  br i1 %tobool37, label %if.then38, label %if.end41

if.then38:                                        ; preds = %if.end36
  %32 = load ptr, ptr %errp.addr, align 8
  %33 = load ptr, ptr %child_name, align 8
  %34 = load ptr, ptr %bs, align 8
  %node_name39 = getelementptr inbounds %struct.BlockDriverState, ptr %34, i32 0, i32 22
  %arraydecay40 = getelementptr inbounds [32 x i8], ptr %node_name39, i64 0, i64 0
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %32, ptr noundef @.str.2, i32 noundef 4819, ptr noundef @__func__.bdrv_reopen_parse_file_or_backing, ptr noundef @.str.266, ptr noundef %33, ptr noundef %arraydecay40)
  store i32 -1, ptr %ret, align 4
  br label %out_rdlock

if.end41:                                         ; preds = %if.end36
  br label %if.end42

if.end42:                                         ; preds = %if.end41, %if.end30
  %35 = load ptr, ptr %bs, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %35, i32 0, i32 6
  %36 = load ptr, ptr %drv, align 8
  %is_filter = getelementptr inbounds %struct.BlockDriver, ptr %36, i32 0, i32 2
  %37 = load i8, ptr %is_filter, align 4
  %tobool43 = trunc i8 %37 to i1
  br i1 %tobool43, label %land.lhs.true, label %if.end49

land.lhs.true:                                    ; preds = %if.end42
  %38 = load ptr, ptr %old_child_bs, align 8
  %tobool44 = icmp ne ptr %38, null
  br i1 %tobool44, label %if.end49, label %if.then45

if.then45:                                        ; preds = %land.lhs.true
  %39 = load ptr, ptr %errp.addr, align 8
  %40 = load ptr, ptr %bs, align 8
  %node_name46 = getelementptr inbounds %struct.BlockDriverState, ptr %40, i32 0, i32 22
  %arraydecay47 = getelementptr inbounds [32 x i8], ptr %node_name46, i64 0, i64 0
  %41 = load ptr, ptr %bs, align 8
  %drv48 = getelementptr inbounds %struct.BlockDriverState, ptr %41, i32 0, i32 6
  %42 = load ptr, ptr %drv48, align 8
  %format_name = getelementptr inbounds %struct.BlockDriver, ptr %42, i32 0, i32 0
  %43 = load ptr, ptr %format_name, align 8
  %44 = load ptr, ptr %child_name, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %39, ptr noundef @.str.2, i32 noundef 4831, ptr noundef @__func__.bdrv_reopen_parse_file_or_backing, ptr noundef @.str.267, ptr noundef %arraydecay47, ptr noundef %43, ptr noundef %44)
  store i32 -22, ptr %ret, align 4
  br label %out_rdlock

if.end49:                                         ; preds = %land.lhs.true, %if.end42
  %45 = load i8, ptr %is_backing.addr, align 1
  %tobool50 = trunc i8 %45 to i1
  br i1 %tobool50, label %if.then51, label %if.else52

if.then51:                                        ; preds = %if.end49
  %46 = load ptr, ptr %old_child_bs, align 8
  %47 = load ptr, ptr %reopen_state.addr, align 8
  %old_backing_bs = getelementptr inbounds %struct.BDRVReopenState, ptr %47, i32 0, i32 4
  store ptr %46, ptr %old_backing_bs, align 8
  br label %if.end53

if.else52:                                        ; preds = %if.end49
  %48 = load ptr, ptr %old_child_bs, align 8
  %49 = load ptr, ptr %reopen_state.addr, align 8
  %old_file_bs = getelementptr inbounds %struct.BDRVReopenState, ptr %49, i32 0, i32 5
  store ptr %48, ptr %old_file_bs, align 8
  br label %if.end53

if.end53:                                         ; preds = %if.else52, %if.then51
  %50 = load ptr, ptr %old_child_bs, align 8
  %tobool54 = icmp ne ptr %50, null
  br i1 %tobool54, label %if.then55, label %if.end56

if.then55:                                        ; preds = %if.end53
  %51 = load ptr, ptr %old_child_bs, align 8
  call void @bdrv_ref(ptr noundef %51)
  %52 = load ptr, ptr %old_child_bs, align 8
  call void @bdrv_drained_begin(ptr noundef %52)
  br label %if.end56

if.end56:                                         ; preds = %if.then55, %if.end53
  %53 = load ptr, ptr %bs, align 8
  %call57 = call ptr @bdrv_get_aio_context(ptr noundef %53)
  store ptr %call57, ptr %old_ctx, align 8
  %54 = load ptr, ptr %new_child_bs, align 8
  %call58 = call ptr @bdrv_get_aio_context(ptr noundef %54)
  store ptr %call58, ptr %ctx, align 8
  %55 = load ptr, ptr %old_ctx, align 8
  %56 = load ptr, ptr %ctx, align 8
  %cmp59 = icmp ne ptr %55, %56
  br i1 %cmp59, label %if.then60, label %if.end61

if.then60:                                        ; preds = %if.end56
  %57 = load ptr, ptr %old_ctx, align 8
  call void @aio_context_release(ptr noundef %57)
  %58 = load ptr, ptr %ctx, align 8
  call void @aio_context_acquire(ptr noundef %58)
  br label %if.end61

if.end61:                                         ; preds = %if.then60, %if.end56
  call void @bdrv_graph_rdunlock_main_loop()
  %59 = load ptr, ptr %new_child_bs, align 8
  call void @bdrv_graph_wrlock(ptr noundef %59)
  %60 = load ptr, ptr %bs, align 8
  %61 = load ptr, ptr %new_child_bs, align 8
  %62 = load i8, ptr %is_backing.addr, align 1
  %tobool62 = trunc i8 %62 to i1
  %63 = load ptr, ptr %tran.addr, align 8
  %64 = load ptr, ptr %errp.addr, align 8
  %call63 = call i32 @bdrv_set_file_or_backing_noperm(ptr noundef %60, ptr noundef %61, i1 noundef zeroext %tobool62, ptr noundef %63, ptr noundef %64)
  store i32 %call63, ptr %ret, align 4
  %65 = load ptr, ptr %ctx, align 8
  call void @bdrv_graph_wrunlock_ctx(ptr noundef %65)
  %66 = load ptr, ptr %old_ctx, align 8
  %67 = load ptr, ptr %ctx, align 8
  %cmp64 = icmp ne ptr %66, %67
  br i1 %cmp64, label %if.then65, label %if.end66

if.then65:                                        ; preds = %if.end61
  %68 = load ptr, ptr %ctx, align 8
  call void @aio_context_release(ptr noundef %68)
  %69 = load ptr, ptr %old_ctx, align 8
  call void @aio_context_acquire(ptr noundef %69)
  br label %if.end66

if.end66:                                         ; preds = %if.then65, %if.end61
  %70 = load ptr, ptr %old_child_bs, align 8
  %tobool67 = icmp ne ptr %70, null
  br i1 %tobool67, label %if.then68, label %if.end69

if.then68:                                        ; preds = %if.end66
  %71 = load ptr, ptr %old_child_bs, align 8
  call void @bdrv_drained_end(ptr noundef %71)
  %72 = load ptr, ptr %old_child_bs, align 8
  call void @bdrv_unref(ptr noundef %72)
  br label %if.end69

if.end69:                                         ; preds = %if.then68, %if.end66
  %73 = load i32, ptr %ret, align 4
  store i32 %73, ptr %retval, align 4
  br label %return

out_rdlock:                                       ; preds = %if.then45, %if.then38, %if.then35, %if.then29, %if.then20, %if.then15
  call void @bdrv_graph_rdunlock_main_loop()
  %74 = load i32, ptr %ret, align 4
  store i32 %74, ptr %retval, align 4
  br label %return

return:                                           ; preds = %out_rdlock, %if.end69, %if.then3
  %75 = load i32, ptr %retval, align 4
  ret i32 %75
}

declare ptr @qstring_get_str(ptr noundef) #2

declare zeroext i1 @qobject_is_equal(ptr noundef, ptr noundef) #2

declare ptr @qdict_next(ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @is_str_in_list(ptr noundef %str, ptr noundef %list) #0 {
entry:
  %retval = alloca i1, align 1
  %str.addr = alloca ptr, align 8
  %list.addr = alloca ptr, align 8
  %i = alloca i32, align 4
  store ptr %str, ptr %str.addr, align 8
  store ptr %list, ptr %list.addr, align 8
  %0 = load ptr, ptr %str.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %entry
  %1 = load ptr, ptr %list.addr, align 8
  %tobool1 = icmp ne ptr %1, null
  br i1 %tobool1, label %if.then, label %if.end6

if.then:                                          ; preds = %land.lhs.true
  store i32 0, ptr %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %2 = load ptr, ptr %list.addr, align 8
  %3 = load i32, ptr %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr ptr, ptr %2, i64 %idxprom
  %4 = load ptr, ptr %arrayidx, align 8
  %cmp = icmp ne ptr %4, null
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load ptr, ptr %str.addr, align 8
  %6 = load ptr, ptr %list.addr, align 8
  %7 = load i32, ptr %i, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr ptr, ptr %6, i64 %idxprom2
  %8 = load ptr, ptr %arrayidx3, align 8
  %call = call i32 @strcmp(ptr noundef %5, ptr noundef %8) #13
  %tobool4 = icmp ne i32 %call, 0
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %for.body
  store i1 true, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, ptr %i, align 4
  %inc = add i32 %9, 1
  store i32 %inc, ptr %i, align 4
  br label %for.cond, !llvm.loop !102

for.end:                                          ; preds = %for.cond
  br label %if.end6

if.end6:                                          ; preds = %for.end, %land.lhs.true, %entry
  store i1 false, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end6, %if.then5
  %10 = load i1, ptr %retval, align 1
  ret i1 %10
}

declare void @bdrv_graph_wrunlock_ctx(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @should_update_child(ptr noundef %c, ptr noundef %to) #0 {
entry:
  %retval = alloca i1, align 1
  %c.addr = alloca ptr, align 8
  %to.addr = alloca ptr, align 8
  %queue = alloca ptr, align 8
  %found = alloca ptr, align 8
  %ret = alloca i8, align 1
  %v = alloca ptr, align 8
  %c2 = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %to, ptr %to.addr, align 8
  %0 = load ptr, ptr %c.addr, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %klass, align 8
  %stay_at_node = getelementptr inbounds %struct.BdrvChildClass, ptr %1, i32 0, i32 0
  %2 = load i8, ptr %stay_at_node, align 8
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, ptr %retval, align 1
  br label %return

if.end:                                           ; preds = %entry
  store i8 1, ptr %ret, align 1
  %call = call ptr @g_hash_table_new(ptr noundef null, ptr noundef null)
  store ptr %call, ptr %found, align 8
  %3 = load ptr, ptr %found, align 8
  %4 = load ptr, ptr %to.addr, align 8
  %call1 = call i32 @g_hash_table_add(ptr noundef %3, ptr noundef %4)
  %call2 = call ptr @g_queue_new()
  store ptr %call2, ptr %queue, align 8
  %5 = load ptr, ptr %queue, align 8
  %6 = load ptr, ptr %to.addr, align 8
  call void @g_queue_push_tail(ptr noundef %5, ptr noundef %6)
  br label %while.cond

while.cond:                                       ; preds = %for.end, %if.end
  %7 = load ptr, ptr %queue, align 8
  %call3 = call i32 @g_queue_is_empty(ptr noundef %7)
  %tobool4 = icmp ne i32 %call3, 0
  %lnot = xor i1 %tobool4, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load ptr, ptr %queue, align 8
  %call5 = call ptr @g_queue_pop_head(ptr noundef %8)
  store ptr %call5, ptr %v, align 8
  %9 = load ptr, ptr %v, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %9, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %10 = load ptr, ptr %lh_first, align 8
  store ptr %10, ptr %c2, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %11 = load ptr, ptr %c2, align 8
  %tobool6 = icmp ne ptr %11, null
  br i1 %tobool6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load ptr, ptr %c2, align 8
  %13 = load ptr, ptr %c.addr, align 8
  %cmp = icmp eq ptr %12, %13
  br i1 %cmp, label %if.then7, label %if.end8

if.then7:                                         ; preds = %for.body
  store i8 0, ptr %ret, align 1
  br label %for.end

if.end8:                                          ; preds = %for.body
  %14 = load ptr, ptr %found, align 8
  %15 = load ptr, ptr %c2, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %15, i32 0, i32 0
  %16 = load ptr, ptr %bs, align 8
  %call9 = call i32 @g_hash_table_contains(ptr noundef %14, ptr noundef %16)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %if.end8
  br label %for.inc

if.end12:                                         ; preds = %if.end8
  %17 = load ptr, ptr %queue, align 8
  %18 = load ptr, ptr %c2, align 8
  %bs13 = getelementptr inbounds %struct.BdrvChild, ptr %18, i32 0, i32 0
  %19 = load ptr, ptr %bs13, align 8
  call void @g_queue_push_tail(ptr noundef %17, ptr noundef %19)
  %20 = load ptr, ptr %found, align 8
  %21 = load ptr, ptr %c2, align 8
  %bs14 = getelementptr inbounds %struct.BdrvChild, ptr %21, i32 0, i32 0
  %22 = load ptr, ptr %bs14, align 8
  %call15 = call i32 @g_hash_table_add(ptr noundef %20, ptr noundef %22)
  br label %for.inc

for.inc:                                          ; preds = %if.end12, %if.then11
  %23 = load ptr, ptr %c2, align 8
  %next = getelementptr inbounds %struct.BdrvChild, ptr %23, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next, i32 0, i32 0
  %24 = load ptr, ptr %le_next, align 8
  store ptr %24, ptr %c2, align 8
  br label %for.cond, !llvm.loop !103

for.end:                                          ; preds = %if.then7, %for.cond
  br label %while.cond, !llvm.loop !104

while.end:                                        ; preds = %while.cond
  %25 = load ptr, ptr %queue, align 8
  call void @g_queue_free(ptr noundef %25)
  %26 = load ptr, ptr %found, align 8
  call void @g_hash_table_destroy(ptr noundef %26)
  %27 = load i8, ptr %ret, align 1
  %tobool16 = trunc i8 %27 to i1
  store i1 %tobool16, ptr %retval, align 1
  br label %return

return:                                           ; preds = %while.end, %if.then
  %28 = load i1, ptr %retval, align 1
  ret i1 %28
}

declare ptr @g_queue_new() #2

declare void @g_queue_push_tail(ptr noundef, ptr noundef) #2

declare i32 @g_queue_is_empty(ptr noundef) #2

declare ptr @g_queue_pop_head(ptr noundef) #2

declare void @g_queue_free(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_replace_child_abort(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  %new_bs = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %s, align 8
  %1 = load ptr, ptr %s, align 8
  %child = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %1, i32 0, i32 0
  %2 = load ptr, ptr %child, align 8
  %bs = getelementptr inbounds %struct.BdrvChild, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %bs, align 8
  store ptr %3, ptr %new_bs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2416, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_abort) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  call void @assert_bdrv_graph_writable()
  %4 = load ptr, ptr %s, align 8
  %child1 = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %4, i32 0, i32 0
  %5 = load ptr, ptr %child1, align 8
  %bs2 = getelementptr inbounds %struct.BdrvChild, ptr %5, i32 0, i32 0
  %6 = load ptr, ptr %bs2, align 8
  %tobool = icmp ne ptr %6, null
  br i1 %tobool, label %if.end10, label %if.then3

if.then3:                                         ; preds = %do.end
  %7 = load ptr, ptr %s, align 8
  %child4 = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %7, i32 0, i32 0
  %8 = load ptr, ptr %child4, align 8
  call void @bdrv_parent_drained_begin_single(ptr noundef %8)
  %9 = load ptr, ptr %s, align 8
  %child5 = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %9, i32 0, i32 0
  %10 = load ptr, ptr %child5, align 8
  %call6 = call zeroext i1 @bdrv_parent_drained_poll_single(ptr noundef %10)
  br i1 %call6, label %if.else8, label %if.then7

if.then7:                                         ; preds = %if.then3
  br label %if.end9

if.else8:                                         ; preds = %if.then3
  call void @__assert_fail(ptr noundef @.str.277, ptr noundef @.str.2, i32 noundef 2431, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_abort) #16
  unreachable

if.end9:                                          ; preds = %if.then7
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %do.end
  %11 = load ptr, ptr %s, align 8
  %child11 = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %11, i32 0, i32 0
  %12 = load ptr, ptr %child11, align 8
  %quiesced_parent = getelementptr inbounds %struct.BdrvChild, ptr %12, i32 0, i32 8
  %13 = load i8, ptr %quiesced_parent, align 1
  %tobool12 = trunc i8 %13 to i1
  br i1 %tobool12, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.end10
  br label %if.end15

if.else14:                                        ; preds = %if.end10
  call void @__assert_fail(ptr noundef @.str.278, ptr noundef @.str.2, i32 noundef 2433, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_abort) #16
  unreachable

if.end15:                                         ; preds = %if.then13
  %14 = load ptr, ptr %s, align 8
  %child16 = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %14, i32 0, i32 0
  %15 = load ptr, ptr %child16, align 8
  %16 = load ptr, ptr %s, align 8
  %old_bs = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %16, i32 0, i32 1
  %17 = load ptr, ptr %old_bs, align 8
  call void @bdrv_replace_child_noperm(ptr noundef %15, ptr noundef %17)
  %18 = load ptr, ptr %new_bs, align 8
  call void @bdrv_unref(ptr noundef %18)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_replace_child_commit(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %s = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %s, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 2406, ptr noundef @__PRETTY_FUNCTION__.bdrv_replace_child_commit) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %1 = load ptr, ptr %s, align 8
  %old_bs = getelementptr inbounds %struct.BdrvReplaceChildState, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %old_bs, align 8
  call void @bdrv_schedule_unref(ptr noundef %2)
  ret void
}

declare zeroext i1 @bdrv_parent_drained_poll_single(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @xdbg_graph_node_num(ptr noundef %gr, ptr noundef %node) #0 {
entry:
  %retval = alloca i64, align 8
  %gr.addr = alloca ptr, align 8
  %node.addr = alloca ptr, align 8
  %ret = alloca i64, align 8
  store ptr %gr, ptr %gr.addr, align 8
  store ptr %node, ptr %node.addr, align 8
  %0 = load ptr, ptr %gr.addr, align 8
  %graph_nodes = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %graph_nodes, align 8
  %2 = load ptr, ptr %node.addr, align 8
  %call = call ptr @g_hash_table_lookup(ptr noundef %1, ptr noundef %2)
  %3 = ptrtoint ptr %call to i64
  store i64 %3, ptr %ret, align 8
  %4 = load i64, ptr %ret, align 8
  %cmp = icmp ne i64 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i64, ptr %ret, align 8
  store i64 %5, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %6 = load ptr, ptr %gr.addr, align 8
  %graph_nodes1 = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %6, i32 0, i32 1
  %7 = load ptr, ptr %graph_nodes1, align 8
  %call2 = call i32 @g_hash_table_size(ptr noundef %7)
  %add = add i32 %call2, 1
  %conv = zext i32 %add to i64
  store i64 %conv, ptr %ret, align 8
  %8 = load ptr, ptr %gr.addr, align 8
  %graph_nodes3 = getelementptr inbounds %struct.XDbgBlockGraphConstructor, ptr %8, i32 0, i32 1
  %9 = load ptr, ptr %graph_nodes3, align 8
  %10 = load ptr, ptr %node.addr, align 8
  %11 = load i64, ptr %ret, align 8
  %12 = inttoptr i64 %11 to ptr
  %call4 = call i32 @g_hash_table_insert(ptr noundef %9, ptr noundef %10, ptr noundef %12)
  %13 = load i64, ptr %ret, align 8
  store i64 %13, ptr %retval, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i64, ptr %retval, align 8
  ret i64 %14
}

declare ptr @g_hash_table_lookup(ptr noundef, ptr noundef) #2

declare i32 @g_hash_table_size(ptr noundef) #2

declare i32 @g_hash_table_insert(ptr noundef, ptr noundef, ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_lockable_lock(ptr noundef %x) #0 {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %lock = getelementptr inbounds %struct.QemuLockable, ptr %0, i32 0, i32 1
  %1 = load ptr, ptr %lock, align 8
  %2 = load ptr, ptr %x.addr, align 8
  %object = getelementptr inbounds %struct.QemuLockable, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %object, align 8
  call void %1(ptr noundef %3)
  ret void
}

declare void @qemu_mutex_unlock_impl(ptr noundef, ptr noundef, i32 noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_clear_QemuLockable(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %_ptr.addr, align 8
  call void @qemu_lockable_auto_unlock(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @qemu_lockable_unlock(ptr noundef %x) #0 {
entry:
  %x.addr = alloca ptr, align 8
  store ptr %x, ptr %x.addr, align 8
  %0 = load ptr, ptr %x.addr, align 8
  %unlock = getelementptr inbounds %struct.QemuLockable, ptr %0, i32 0, i32 2
  %1 = load ptr, ptr %unlock, align 8
  %2 = load ptr, ptr %x.addr, align 8
  %object = getelementptr inbounds %struct.QemuLockable, ptr %2, i32 0, i32 0
  %3 = load ptr, ptr %object, align 8
  call void %1(ptr noundef %3)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @_nocheck__trace_bdrv_lock_medium(ptr noundef %bs, i1 noundef zeroext %locked) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %locked.addr = alloca i8, align 1
  %_now = alloca %struct.timeval, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %frombool = zext i1 %locked to i8
  store i8 %frombool, ptr %locked.addr, align 1
  %0 = load i32, ptr @trace_events_enabled_count, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool2 = icmp ne i64 %conv, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end15

land.lhs.true:                                    ; preds = %entry
  %1 = load i16, ptr @_TRACE_BDRV_LOCK_MEDIUM_DSTATE, align 2
  %conv3 = zext i16 %1 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br i1 %tobool4, label %land.lhs.true5, label %if.end15

land.lhs.true5:                                   ; preds = %land.lhs.true
  %call = call zeroext i1 @qemu_loglevel_mask(i32 noundef 32768)
  br i1 %call, label %if.then, label %if.end15

if.then:                                          ; preds = %land.lhs.true5
  %2 = load i8, ptr @message_with_timestamp, align 1
  %tobool7 = trunc i8 %2 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.then
  %call9 = call i32 @gettimeofday(ptr noundef %_now, ptr noundef null) #15
  %call10 = call i32 @qemu_get_thread_id()
  %tv_sec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 0
  %3 = load i64, ptr %tv_sec, align 8
  %tv_usec = getelementptr inbounds %struct.timeval, ptr %_now, i32 0, i32 1
  %4 = load i64, ptr %tv_usec, align 8
  %5 = load ptr, ptr %bs.addr, align 8
  %6 = load i8, ptr %locked.addr, align 1
  %tobool11 = trunc i8 %6 to i1
  %conv12 = zext i1 %tobool11 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.282, i32 noundef %call10, i64 noundef %3, i64 noundef %4, ptr noundef %5, i32 noundef %conv12)
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load ptr, ptr %bs.addr, align 8
  %8 = load i8, ptr %locked.addr, align 1
  %tobool13 = trunc i8 %8 to i1
  %conv14 = zext i1 %tobool13 to i32
  call void (ptr, ...) @qemu_log(ptr noundef @.str.283, ptr noundef %7, i32 noundef %conv14)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then8
  br label %if.end15

if.end15:                                         ; preds = %if.end, %land.lhs.true5, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_close(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %ban = alloca ptr, align 8
  %ban_next = alloca ptr, align 8
  %child = alloca ptr, align 8
  %next = alloca ptr, align 8
  %.atomictmp = alloca i32, align 4
  %_obj53 = alloca ptr, align 8
  %tmp = alloca ptr, align 8
  %__mptr = alloca ptr, align 8
  %tmp32 = alloca ptr, align 8
  %_obj54 = alloca ptr, align 8
  %tmp33 = alloca ptr, align 8
  %__mptr36 = alloca ptr, align 8
  %tmp38 = alloca ptr, align 8
  %_obj55 = alloca ptr, align 8
  %tmp45 = alloca ptr, align 8
  %__mptr48 = alloca ptr, align 8
  %tmp50 = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 5197, ptr noundef @__PRETTY_FUNCTION__.bdrv_close) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %bs.addr, align 8
  %refcnt = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 26
  %1 = load i32, ptr %refcnt, align 8
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.else2, label %if.then1

if.then1:                                         ; preds = %do.end
  br label %if.end3

if.else2:                                         ; preds = %do.end
  call void @__assert_fail(ptr noundef @.str.285, ptr noundef @.str.2, i32 noundef 5198, ptr noundef @__PRETTY_FUNCTION__.bdrv_close) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  %2 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_drained_begin(ptr noundef %2)
  %3 = load ptr, ptr %bs.addr, align 8
  %call4 = call i32 @bdrv_flush(ptr noundef %3)
  %4 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_drain(ptr noundef %4)
  %5 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %drv, align 8
  %tobool5 = icmp ne ptr %6, null
  br i1 %tobool5, label %if.then6, label %if.end14

if.then6:                                         ; preds = %if.end3
  %7 = load ptr, ptr %bs.addr, align 8
  %drv7 = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 6
  %8 = load ptr, ptr %drv7, align 8
  %bdrv_close = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 25
  %9 = load ptr, ptr %bdrv_close, align 8
  %tobool8 = icmp ne ptr %9, null
  br i1 %tobool8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.then6
  %10 = load ptr, ptr %bs.addr, align 8
  %drv10 = getelementptr inbounds %struct.BlockDriverState, ptr %10, i32 0, i32 6
  %11 = load ptr, ptr %drv10, align 8
  %bdrv_close11 = getelementptr inbounds %struct.BlockDriver, ptr %11, i32 0, i32 25
  %12 = load ptr, ptr %bdrv_close11, align 8
  %13 = load ptr, ptr %bs.addr, align 8
  call void %12(ptr noundef %13)
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.then6
  %14 = load ptr, ptr %bs.addr, align 8
  %drv13 = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 6
  store ptr null, ptr %drv13, align 8
  br label %if.end14

if.end14:                                         ; preds = %if.end12, %if.end3
  %15 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_graph_wrlock(ptr noundef %15)
  %16 = load ptr, ptr %bs.addr, align 8
  %children = getelementptr inbounds %struct.BlockDriverState, ptr %16, i32 0, i32 29
  %lh_first = getelementptr inbounds %struct.anon.3, ptr %children, i32 0, i32 0
  %17 = load ptr, ptr %lh_first, align 8
  store ptr %17, ptr %child, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end14
  %18 = load ptr, ptr %child, align 8
  %tobool15 = icmp ne ptr %18, null
  br i1 %tobool15, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %19 = load ptr, ptr %child, align 8
  %next16 = getelementptr inbounds %struct.BdrvChild, ptr %19, i32 0, i32 9
  %le_next = getelementptr inbounds %struct.anon.14, ptr %next16, i32 0, i32 0
  %20 = load ptr, ptr %le_next, align 8
  store ptr %20, ptr %next, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %21 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %21, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %22 = load ptr, ptr %bs.addr, align 8
  %23 = load ptr, ptr %child, align 8
  call void @bdrv_unref_child(ptr noundef %22, ptr noundef %23)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %24 = load ptr, ptr %next, align 8
  store ptr %24, ptr %child, align 8
  br label %for.cond, !llvm.loop !105

for.end:                                          ; preds = %land.end
  %25 = load ptr, ptr %bs.addr, align 8
  %backing = getelementptr inbounds %struct.BlockDriverState, ptr %25, i32 0, i32 30
  %26 = load ptr, ptr %backing, align 8
  %tobool17 = icmp ne ptr %26, null
  br i1 %tobool17, label %if.else19, label %if.then18

if.then18:                                        ; preds = %for.end
  br label %if.end20

if.else19:                                        ; preds = %for.end
  call void @__assert_fail(ptr noundef @.str.166, ptr noundef @.str.2, i32 noundef 5217, ptr noundef @__PRETTY_FUNCTION__.bdrv_close) #16
  unreachable

if.end20:                                         ; preds = %if.then18
  %27 = load ptr, ptr %bs.addr, align 8
  %file = getelementptr inbounds %struct.BlockDriverState, ptr %27, i32 0, i32 31
  %28 = load ptr, ptr %file, align 8
  %tobool21 = icmp ne ptr %28, null
  br i1 %tobool21, label %if.else23, label %if.then22

if.then22:                                        ; preds = %if.end20
  br label %if.end24

if.else23:                                        ; preds = %if.end20
  call void @__assert_fail(ptr noundef @.str.167, ptr noundef @.str.2, i32 noundef 5218, ptr noundef @__PRETTY_FUNCTION__.bdrv_close) #16
  unreachable

if.end24:                                         ; preds = %if.then22
  %29 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_graph_wrunlock(ptr noundef %29)
  %30 = load ptr, ptr %bs.addr, align 8
  %opaque = getelementptr inbounds %struct.BlockDriverState, ptr %30, i32 0, i32 7
  %31 = load ptr, ptr %opaque, align 8
  call void @g_free(ptr noundef %31)
  %32 = load ptr, ptr %bs.addr, align 8
  %opaque25 = getelementptr inbounds %struct.BlockDriverState, ptr %32, i32 0, i32 7
  store ptr null, ptr %opaque25, align 8
  br label %do.body26

do.body26:                                        ; preds = %if.end24
  br label %while.cond

while.cond:                                       ; preds = %do.end28, %do.body26
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body27

do.body27:                                        ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.2, i32 noundef 5223, ptr noundef @__func__.bdrv_close, ptr noundef null) #18
  unreachable

do.end28:                                         ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %33 = load ptr, ptr %bs.addr, align 8
  %copy_on_read = getelementptr inbounds %struct.BlockDriverState, ptr %33, i32 0, i32 42
  store i32 0, ptr %.atomictmp, align 4
  %34 = load i32, ptr %.atomictmp, align 4
  store atomic i32 %34, ptr %copy_on_read monotonic, align 8
  br label %do.end29

do.end29:                                         ; preds = %while.end
  %35 = load ptr, ptr %bs.addr, align 8
  %backing_file = getelementptr inbounds %struct.BlockDriverState, ptr %35, i32 0, i32 12
  %arrayidx = getelementptr [4096 x i8], ptr %backing_file, i64 0, i64 0
  store i8 0, ptr %arrayidx, align 1
  %36 = load ptr, ptr %bs.addr, align 8
  %backing_format = getelementptr inbounds %struct.BlockDriverState, ptr %36, i32 0, i32 14
  %arrayidx30 = getelementptr [16 x i8], ptr %backing_format, i64 0, i64 0
  store i8 0, ptr %arrayidx30, align 1
  %37 = load ptr, ptr %bs.addr, align 8
  %total_sectors = getelementptr inbounds %struct.BlockDriverState, ptr %37, i32 0, i32 37
  store i64 0, ptr %total_sectors, align 8
  %38 = load ptr, ptr %bs.addr, align 8
  %encrypted = getelementptr inbounds %struct.BlockDriverState, ptr %38, i32 0, i32 1
  store i8 0, ptr %encrypted, align 4
  %39 = load ptr, ptr %bs.addr, align 8
  %sg = getelementptr inbounds %struct.BlockDriverState, ptr %39, i32 0, i32 2
  store i8 0, ptr %sg, align 1
  %40 = load ptr, ptr %bs.addr, align 8
  %options = getelementptr inbounds %struct.BlockDriverState, ptr %40, i32 0, i32 33
  %41 = load ptr, ptr %options, align 8
  store ptr %41, ptr %_obj53, align 8
  %42 = load ptr, ptr %_obj53, align 8
  %tobool31 = icmp ne ptr %42, null
  br i1 %tobool31, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end29
  %43 = load ptr, ptr %_obj53, align 8
  %base = getelementptr inbounds %struct.QDict, ptr %43, i32 0, i32 0
  store ptr %base, ptr %__mptr, align 8
  %44 = load ptr, ptr %__mptr, align 8
  %add.ptr = getelementptr i8, ptr %44, i64 0
  store ptr %add.ptr, ptr %tmp32, align 8
  %45 = load ptr, ptr %tmp32, align 8
  br label %cond.end

cond.false:                                       ; preds = %do.end29
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %45, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %tmp, align 8
  %46 = load ptr, ptr %tmp, align 8
  call void @qobject_unref_impl(ptr noundef %46)
  %47 = load ptr, ptr %bs.addr, align 8
  %explicit_options = getelementptr inbounds %struct.BlockDriverState, ptr %47, i32 0, i32 34
  %48 = load ptr, ptr %explicit_options, align 8
  store ptr %48, ptr %_obj54, align 8
  %49 = load ptr, ptr %_obj54, align 8
  %tobool34 = icmp ne ptr %49, null
  br i1 %tobool34, label %cond.true35, label %cond.false40

cond.true35:                                      ; preds = %cond.end
  %50 = load ptr, ptr %_obj54, align 8
  %base37 = getelementptr inbounds %struct.QDict, ptr %50, i32 0, i32 0
  store ptr %base37, ptr %__mptr36, align 8
  %51 = load ptr, ptr %__mptr36, align 8
  %add.ptr39 = getelementptr i8, ptr %51, i64 0
  store ptr %add.ptr39, ptr %tmp38, align 8
  %52 = load ptr, ptr %tmp38, align 8
  br label %cond.end41

cond.false40:                                     ; preds = %cond.end
  br label %cond.end41

cond.end41:                                       ; preds = %cond.false40, %cond.true35
  %cond42 = phi ptr [ %52, %cond.true35 ], [ null, %cond.false40 ]
  store ptr %cond42, ptr %tmp33, align 8
  %53 = load ptr, ptr %tmp33, align 8
  call void @qobject_unref_impl(ptr noundef %53)
  %54 = load ptr, ptr %bs.addr, align 8
  %options43 = getelementptr inbounds %struct.BlockDriverState, ptr %54, i32 0, i32 33
  store ptr null, ptr %options43, align 8
  %55 = load ptr, ptr %bs.addr, align 8
  %explicit_options44 = getelementptr inbounds %struct.BlockDriverState, ptr %55, i32 0, i32 34
  store ptr null, ptr %explicit_options44, align 8
  %56 = load ptr, ptr %bs.addr, align 8
  %full_open_options = getelementptr inbounds %struct.BlockDriverState, ptr %56, i32 0, i32 15
  %57 = load ptr, ptr %full_open_options, align 8
  store ptr %57, ptr %_obj55, align 8
  %58 = load ptr, ptr %_obj55, align 8
  %tobool46 = icmp ne ptr %58, null
  br i1 %tobool46, label %cond.true47, label %cond.false52

cond.true47:                                      ; preds = %cond.end41
  %59 = load ptr, ptr %_obj55, align 8
  %base49 = getelementptr inbounds %struct.QDict, ptr %59, i32 0, i32 0
  store ptr %base49, ptr %__mptr48, align 8
  %60 = load ptr, ptr %__mptr48, align 8
  %add.ptr51 = getelementptr i8, ptr %60, i64 0
  store ptr %add.ptr51, ptr %tmp50, align 8
  %61 = load ptr, ptr %tmp50, align 8
  br label %cond.end53

cond.false52:                                     ; preds = %cond.end41
  br label %cond.end53

cond.end53:                                       ; preds = %cond.false52, %cond.true47
  %cond54 = phi ptr [ %61, %cond.true47 ], [ null, %cond.false52 ]
  store ptr %cond54, ptr %tmp45, align 8
  %62 = load ptr, ptr %tmp45, align 8
  call void @qobject_unref_impl(ptr noundef %62)
  %63 = load ptr, ptr %bs.addr, align 8
  %full_open_options55 = getelementptr inbounds %struct.BlockDriverState, ptr %63, i32 0, i32 15
  store ptr null, ptr %full_open_options55, align 8
  %64 = load ptr, ptr %bs.addr, align 8
  %block_status_cache = getelementptr inbounds %struct.BlockDriverState, ptr %64, i32 0, i32 55
  %65 = load ptr, ptr %block_status_cache, align 8
  call void @g_free(ptr noundef %65)
  %66 = load ptr, ptr %bs.addr, align 8
  %block_status_cache56 = getelementptr inbounds %struct.BlockDriverState, ptr %66, i32 0, i32 55
  store ptr null, ptr %block_status_cache56, align 8
  %67 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_release_named_dirty_bitmaps(ptr noundef %67)
  %68 = load ptr, ptr %bs.addr, align 8
  %dirty_bitmaps = getelementptr inbounds %struct.BlockDriverState, ptr %68, i32 0, i32 40
  %lh_first57 = getelementptr inbounds %struct.anon.5, ptr %dirty_bitmaps, i32 0, i32 0
  %69 = load ptr, ptr %lh_first57, align 8
  %cmp = icmp eq ptr %69, null
  br i1 %cmp, label %if.then58, label %if.else59

if.then58:                                        ; preds = %cond.end53
  br label %if.end60

if.else59:                                        ; preds = %cond.end53
  call void @__assert_fail(ptr noundef @.str.286, ptr noundef @.str.2, i32 noundef 5239, ptr noundef @__PRETTY_FUNCTION__.bdrv_close) #16
  unreachable

if.end60:                                         ; preds = %if.then58
  %70 = load ptr, ptr %bs.addr, align 8
  %aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %70, i32 0, i32 9
  %lh_first61 = getelementptr inbounds %struct.anon, ptr %aio_notifiers, i32 0, i32 0
  %71 = load ptr, ptr %lh_first61, align 8
  store ptr %71, ptr %ban, align 8
  br label %for.cond62

for.cond62:                                       ; preds = %for.inc68, %if.end60
  %72 = load ptr, ptr %ban, align 8
  %tobool63 = icmp ne ptr %72, null
  br i1 %tobool63, label %land.rhs64, label %land.end66

land.rhs64:                                       ; preds = %for.cond62
  %73 = load ptr, ptr %ban, align 8
  %list = getelementptr inbounds %struct.BdrvAioNotifier, ptr %73, i32 0, i32 4
  %le_next65 = getelementptr inbounds %struct.anon.26, ptr %list, i32 0, i32 0
  %74 = load ptr, ptr %le_next65, align 8
  store ptr %74, ptr %ban_next, align 8
  br label %land.end66

land.end66:                                       ; preds = %land.rhs64, %for.cond62
  %75 = phi i1 [ false, %for.cond62 ], [ true, %land.rhs64 ]
  br i1 %75, label %for.body67, label %for.end69

for.body67:                                       ; preds = %land.end66
  %76 = load ptr, ptr %ban, align 8
  call void @g_free(ptr noundef %76)
  br label %for.inc68

for.inc68:                                        ; preds = %for.body67
  %77 = load ptr, ptr %ban_next, align 8
  store ptr %77, ptr %ban, align 8
  br label %for.cond62, !llvm.loop !106

for.end69:                                        ; preds = %land.end66
  br label %do.body70

do.body70:                                        ; preds = %for.end69
  %78 = load ptr, ptr %bs.addr, align 8
  %aio_notifiers71 = getelementptr inbounds %struct.BlockDriverState, ptr %78, i32 0, i32 9
  %lh_first72 = getelementptr inbounds %struct.anon, ptr %aio_notifiers71, i32 0, i32 0
  store ptr null, ptr %lh_first72, align 8
  br label %do.end73

do.end73:                                         ; preds = %do.body70
  %79 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_drained_end(ptr noundef %79)
  %80 = load ptr, ptr %bs.addr, align 8
  %quiesce_counter = getelementptr inbounds %struct.BlockDriverState, ptr %80, i32 0, i32 46
  %81 = load i32, ptr %quiesce_counter, align 8
  %tobool74 = icmp ne i32 %81, 0
  br i1 %tobool74, label %if.then75, label %if.end76

if.then75:                                        ; preds = %do.end73
  %82 = load ptr, ptr %bs.addr, align 8
  call void @bdrv_drain_all_end_quiesce(ptr noundef %82)
  br label %if.end76

if.end76:                                         ; preds = %if.then75, %do.end73
  ret void
}

declare void @qemu_mutex_destroy(ptr noundef) #2

declare void @bdrv_drain(ptr noundef) #2

declare void @bdrv_release_named_dirty_bitmaps(ptr noundef) #2

declare void @bdrv_drain_all_end_quiesce(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal zeroext i1 @bdrv_parent_change_aio_context(ptr noundef %c, ptr noundef %ctx, ptr noundef %visited, ptr noundef %tran, ptr noundef %errp) #0 {
entry:
  %retval = alloca i1, align 1
  %c.addr = alloca ptr, align 8
  %ctx.addr = alloca ptr, align 8
  %visited.addr = alloca ptr, align 8
  %tran.addr = alloca ptr, align 8
  %errp.addr = alloca ptr, align 8
  %user = alloca ptr, align 8
  store ptr %c, ptr %c.addr, align 8
  store ptr %ctx, ptr %ctx.addr, align 8
  store ptr %visited, ptr %visited.addr, align 8
  store ptr %tran, ptr %tran.addr, align 8
  store ptr %errp, ptr %errp.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7680, ptr noundef @__PRETTY_FUNCTION__.bdrv_parent_change_aio_context) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %visited.addr, align 8
  %1 = load ptr, ptr %c.addr, align 8
  %call1 = call i32 @g_hash_table_contains(ptr noundef %0, ptr noundef %1)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %do.end
  store i1 true, ptr %retval, align 1
  br label %return

if.end3:                                          ; preds = %do.end
  %2 = load ptr, ptr %visited.addr, align 8
  %3 = load ptr, ptr %c.addr, align 8
  %call4 = call i32 @g_hash_table_add(ptr noundef %2, ptr noundef %3)
  %4 = load ptr, ptr %c.addr, align 8
  %klass = getelementptr inbounds %struct.BdrvChild, ptr %4, i32 0, i32 2
  %5 = load ptr, ptr %klass, align 8
  %change_aio_ctx = getelementptr inbounds %struct.BdrvChildClass, ptr %5, i32 0, i32 13
  %6 = load ptr, ptr %change_aio_ctx, align 8
  %tobool5 = icmp ne ptr %6, null
  br i1 %tobool5, label %if.end8, label %if.then6

if.then6:                                         ; preds = %if.end3
  %7 = load ptr, ptr %c.addr, align 8
  %call7 = call ptr @bdrv_child_user_desc(ptr noundef %7)
  store ptr %call7, ptr %user, align 8
  %8 = load ptr, ptr %errp.addr, align 8
  %9 = load ptr, ptr %user, align 8
  call void (ptr, ptr, i32, ptr, ptr, ...) @error_setg_internal(ptr noundef %8, ptr noundef @.str.2, i32 noundef 7692, ptr noundef @__func__.bdrv_parent_change_aio_context, ptr noundef @.str.287, ptr noundef %9)
  %10 = load ptr, ptr %user, align 8
  call void @g_free(ptr noundef %10)
  store i1 false, ptr %retval, align 1
  br label %return

if.end8:                                          ; preds = %if.end3
  %11 = load ptr, ptr %c.addr, align 8
  %klass9 = getelementptr inbounds %struct.BdrvChild, ptr %11, i32 0, i32 2
  %12 = load ptr, ptr %klass9, align 8
  %change_aio_ctx10 = getelementptr inbounds %struct.BdrvChildClass, ptr %12, i32 0, i32 13
  %13 = load ptr, ptr %change_aio_ctx10, align 8
  %14 = load ptr, ptr %c.addr, align 8
  %15 = load ptr, ptr %ctx.addr, align 8
  %16 = load ptr, ptr %visited.addr, align 8
  %17 = load ptr, ptr %tran.addr, align 8
  %18 = load ptr, ptr %errp.addr, align 8
  %call11 = call zeroext i1 %13(ptr noundef %14, ptr noundef %15, ptr noundef %16, ptr noundef %17, ptr noundef %18)
  br i1 %call11, label %if.end18, label %if.then12

if.then12:                                        ; preds = %if.end8
  %19 = load ptr, ptr %errp.addr, align 8
  %tobool13 = icmp ne ptr %19, null
  br i1 %tobool13, label %lor.lhs.false, label %if.then15

lor.lhs.false:                                    ; preds = %if.then12
  %20 = load ptr, ptr %errp.addr, align 8
  %21 = load ptr, ptr %20, align 8
  %tobool14 = icmp ne ptr %21, null
  br i1 %tobool14, label %if.then15, label %if.else16

if.then15:                                        ; preds = %lor.lhs.false, %if.then12
  br label %if.end17

if.else16:                                        ; preds = %lor.lhs.false
  call void @__assert_fail(ptr noundef @.str.288, ptr noundef @.str.2, i32 noundef 7697, ptr noundef @__PRETTY_FUNCTION__.bdrv_parent_change_aio_context) #16
  unreachable

if.end17:                                         ; preds = %if.then15
  store i1 false, ptr %retval, align 1
  br label %return

if.end18:                                         ; preds = %if.end8
  store i1 true, ptr %retval, align 1
  br label %return

return:                                           ; preds = %if.end18, %if.end17, %if.then6, %if.then2
  %22 = load i1, ptr %retval, align 1
  ret i1 %22
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_set_aio_context_commit(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %state = alloca ptr, align 8
  %bs = alloca ptr, align 8
  %new_context = alloca ptr, align 8
  %old_context = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %state, align 8
  %1 = load ptr, ptr %state, align 8
  %bs1 = getelementptr inbounds %struct.BdrvStateSetAioContext, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %bs1, align 8
  store ptr %2, ptr %bs, align 8
  %3 = load ptr, ptr %state, align 8
  %new_ctx = getelementptr inbounds %struct.BdrvStateSetAioContext, ptr %3, i32 0, i32 0
  %4 = load ptr, ptr %new_ctx, align 8
  store ptr %4, ptr %new_context, align 8
  %5 = load ptr, ptr %bs, align 8
  %call = call ptr @bdrv_get_aio_context(ptr noundef %5)
  store ptr %call, ptr %old_context, align 8
  %6 = load ptr, ptr %old_context, align 8
  %call2 = call ptr @qemu_get_aio_context()
  %cmp = icmp ne ptr %6, %call2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load ptr, ptr %old_context, align 8
  call void @aio_context_acquire(ptr noundef %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load ptr, ptr %bs, align 8
  call void @bdrv_detach_aio_context(ptr noundef %8)
  %9 = load ptr, ptr %old_context, align 8
  %call3 = call ptr @qemu_get_aio_context()
  %cmp4 = icmp ne ptr %9, %call3
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %10 = load ptr, ptr %old_context, align 8
  call void @aio_context_release(ptr noundef %10)
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end
  %11 = load ptr, ptr %bs, align 8
  %12 = load ptr, ptr %new_context, align 8
  call void @bdrv_attach_aio_context(ptr noundef %11, ptr noundef %12)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_set_aio_context_clean(ptr noundef %opaque) #0 {
entry:
  %opaque.addr = alloca ptr, align 8
  %state = alloca ptr, align 8
  %bs = alloca ptr, align 8
  store ptr %opaque, ptr %opaque.addr, align 8
  %0 = load ptr, ptr %opaque.addr, align 8
  store ptr %0, ptr %state, align 8
  %1 = load ptr, ptr %state, align 8
  %bs1 = getelementptr inbounds %struct.BdrvStateSetAioContext, ptr %1, i32 0, i32 1
  %2 = load ptr, ptr %bs1, align 8
  store ptr %2, ptr %bs, align 8
  %3 = load ptr, ptr %bs, align 8
  call void @bdrv_drained_end(ptr noundef %3)
  %4 = load ptr, ptr %state, align 8
  call void @g_free(ptr noundef %4)
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_detach_aio_context(ptr noundef %bs) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %baf = alloca ptr, align 8
  %baf_tmp = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  %0 = load ptr, ptr %bs.addr, align 8
  %walking_aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %0, i32 0, i32 10
  %1 = load i8, ptr %walking_aio_notifiers, align 8
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.289, ptr noundef @.str.2, i32 noundef 7624, ptr noundef @__PRETTY_FUNCTION__.bdrv_detach_aio_context) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then1, label %if.else2

if.then1:                                         ; preds = %do.body
  br label %if.end3

if.else2:                                         ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7625, ptr noundef @__PRETTY_FUNCTION__.bdrv_detach_aio_context) #16
  unreachable

if.end3:                                          ; preds = %if.then1
  br label %do.end

do.end:                                           ; preds = %if.end3
  %2 = load ptr, ptr %bs.addr, align 8
  %walking_aio_notifiers4 = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 10
  store i8 1, ptr %walking_aio_notifiers4, align 8
  %3 = load ptr, ptr %bs.addr, align 8
  %aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 9
  %lh_first = getelementptr inbounds %struct.anon, ptr %aio_notifiers, i32 0, i32 0
  %4 = load ptr, ptr %lh_first, align 8
  store ptr %4, ptr %baf, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %5 = load ptr, ptr %baf, align 8
  %tobool5 = icmp ne ptr %5, null
  br i1 %tobool5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %6 = load ptr, ptr %baf, align 8
  %list = getelementptr inbounds %struct.BdrvAioNotifier, ptr %6, i32 0, i32 4
  %le_next = getelementptr inbounds %struct.anon.26, ptr %list, i32 0, i32 0
  %7 = load ptr, ptr %le_next, align 8
  store ptr %7, ptr %baf_tmp, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %8 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %8, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %9 = load ptr, ptr %baf, align 8
  %deleted = getelementptr inbounds %struct.BdrvAioNotifier, ptr %9, i32 0, i32 3
  %10 = load i8, ptr %deleted, align 8
  %tobool6 = trunc i8 %10 to i1
  br i1 %tobool6, label %if.then7, label %if.else8

if.then7:                                         ; preds = %for.body
  %11 = load ptr, ptr %baf, align 8
  call void @bdrv_do_remove_aio_context_notifier(ptr noundef %11)
  br label %if.end9

if.else8:                                         ; preds = %for.body
  %12 = load ptr, ptr %baf, align 8
  %detach_aio_context = getelementptr inbounds %struct.BdrvAioNotifier, ptr %12, i32 0, i32 1
  %13 = load ptr, ptr %detach_aio_context, align 8
  %14 = load ptr, ptr %baf, align 8
  %opaque = getelementptr inbounds %struct.BdrvAioNotifier, ptr %14, i32 0, i32 2
  %15 = load ptr, ptr %opaque, align 8
  call void %13(ptr noundef %15)
  br label %if.end9

if.end9:                                          ; preds = %if.else8, %if.then7
  br label %for.inc

for.inc:                                          ; preds = %if.end9
  %16 = load ptr, ptr %baf_tmp, align 8
  store ptr %16, ptr %baf, align 8
  br label %for.cond, !llvm.loop !107

for.end:                                          ; preds = %land.end
  %17 = load ptr, ptr %bs.addr, align 8
  %walking_aio_notifiers10 = getelementptr inbounds %struct.BlockDriverState, ptr %17, i32 0, i32 10
  store i8 0, ptr %walking_aio_notifiers10, align 8
  %18 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %18, i32 0, i32 6
  %19 = load ptr, ptr %drv, align 8
  %tobool11 = icmp ne ptr %19, null
  br i1 %tobool11, label %land.lhs.true, label %if.end17

land.lhs.true:                                    ; preds = %for.end
  %20 = load ptr, ptr %bs.addr, align 8
  %drv12 = getelementptr inbounds %struct.BlockDriverState, ptr %20, i32 0, i32 6
  %21 = load ptr, ptr %drv12, align 8
  %bdrv_detach_aio_context = getelementptr inbounds %struct.BlockDriver, ptr %21, i32 0, i32 47
  %22 = load ptr, ptr %bdrv_detach_aio_context, align 8
  %tobool13 = icmp ne ptr %22, null
  br i1 %tobool13, label %if.then14, label %if.end17

if.then14:                                        ; preds = %land.lhs.true
  %23 = load ptr, ptr %bs.addr, align 8
  %drv15 = getelementptr inbounds %struct.BlockDriverState, ptr %23, i32 0, i32 6
  %24 = load ptr, ptr %drv15, align 8
  %bdrv_detach_aio_context16 = getelementptr inbounds %struct.BlockDriver, ptr %24, i32 0, i32 47
  %25 = load ptr, ptr %bdrv_detach_aio_context16, align 8
  %26 = load ptr, ptr %bs.addr, align 8
  call void %25(ptr noundef %26)
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %land.lhs.true, %for.end
  %27 = load ptr, ptr %bs.addr, align 8
  %aio_context = getelementptr inbounds %struct.BlockDriverState, ptr %27, i32 0, i32 8
  store ptr null, ptr %aio_context, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @bdrv_attach_aio_context(ptr noundef %bs, ptr noundef %new_context) #0 {
entry:
  %bs.addr = alloca ptr, align 8
  %new_context.addr = alloca ptr, align 8
  %ban = alloca ptr, align 8
  %ban_tmp = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %new_context, ptr %new_context.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call zeroext i1 @qemu_in_main_thread()
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @__assert_fail(ptr noundef @.str.10, ptr noundef @.str.2, i32 noundef 7650, ptr noundef @__PRETTY_FUNCTION__.bdrv_attach_aio_context) #16
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %0 = load ptr, ptr %new_context.addr, align 8
  %1 = load ptr, ptr %bs.addr, align 8
  %aio_context = getelementptr inbounds %struct.BlockDriverState, ptr %1, i32 0, i32 8
  store ptr %0, ptr %aio_context, align 8
  %2 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %2, i32 0, i32 6
  %3 = load ptr, ptr %drv, align 8
  %tobool = icmp ne ptr %3, null
  br i1 %tobool, label %land.lhs.true, label %if.end6

land.lhs.true:                                    ; preds = %do.end
  %4 = load ptr, ptr %bs.addr, align 8
  %drv1 = getelementptr inbounds %struct.BlockDriverState, ptr %4, i32 0, i32 6
  %5 = load ptr, ptr %drv1, align 8
  %bdrv_attach_aio_context = getelementptr inbounds %struct.BlockDriver, ptr %5, i32 0, i32 48
  %6 = load ptr, ptr %bdrv_attach_aio_context, align 8
  %tobool2 = icmp ne ptr %6, null
  br i1 %tobool2, label %if.then3, label %if.end6

if.then3:                                         ; preds = %land.lhs.true
  %7 = load ptr, ptr %bs.addr, align 8
  %drv4 = getelementptr inbounds %struct.BlockDriverState, ptr %7, i32 0, i32 6
  %8 = load ptr, ptr %drv4, align 8
  %bdrv_attach_aio_context5 = getelementptr inbounds %struct.BlockDriver, ptr %8, i32 0, i32 48
  %9 = load ptr, ptr %bdrv_attach_aio_context5, align 8
  %10 = load ptr, ptr %bs.addr, align 8
  %11 = load ptr, ptr %new_context.addr, align 8
  call void %9(ptr noundef %10, ptr noundef %11)
  br label %if.end6

if.end6:                                          ; preds = %if.then3, %land.lhs.true, %do.end
  %12 = load ptr, ptr %bs.addr, align 8
  %walking_aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %12, i32 0, i32 10
  %13 = load i8, ptr %walking_aio_notifiers, align 8
  %tobool7 = trunc i8 %13 to i1
  br i1 %tobool7, label %if.else9, label %if.then8

if.then8:                                         ; preds = %if.end6
  br label %if.end10

if.else9:                                         ; preds = %if.end6
  call void @__assert_fail(ptr noundef @.str.289, ptr noundef @.str.2, i32 noundef 7658, ptr noundef @__PRETTY_FUNCTION__.bdrv_attach_aio_context) #16
  unreachable

if.end10:                                         ; preds = %if.then8
  %14 = load ptr, ptr %bs.addr, align 8
  %walking_aio_notifiers11 = getelementptr inbounds %struct.BlockDriverState, ptr %14, i32 0, i32 10
  store i8 1, ptr %walking_aio_notifiers11, align 8
  %15 = load ptr, ptr %bs.addr, align 8
  %aio_notifiers = getelementptr inbounds %struct.BlockDriverState, ptr %15, i32 0, i32 9
  %lh_first = getelementptr inbounds %struct.anon, ptr %aio_notifiers, i32 0, i32 0
  %16 = load ptr, ptr %lh_first, align 8
  store ptr %16, ptr %ban, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end10
  %17 = load ptr, ptr %ban, align 8
  %tobool12 = icmp ne ptr %17, null
  br i1 %tobool12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %18 = load ptr, ptr %ban, align 8
  %list = getelementptr inbounds %struct.BdrvAioNotifier, ptr %18, i32 0, i32 4
  %le_next = getelementptr inbounds %struct.anon.26, ptr %list, i32 0, i32 0
  %19 = load ptr, ptr %le_next, align 8
  store ptr %19, ptr %ban_tmp, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %20 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %20, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %21 = load ptr, ptr %ban, align 8
  %deleted = getelementptr inbounds %struct.BdrvAioNotifier, ptr %21, i32 0, i32 3
  %22 = load i8, ptr %deleted, align 8
  %tobool13 = trunc i8 %22 to i1
  br i1 %tobool13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %for.body
  %23 = load ptr, ptr %ban, align 8
  call void @bdrv_do_remove_aio_context_notifier(ptr noundef %23)
  br label %if.end16

if.else15:                                        ; preds = %for.body
  %24 = load ptr, ptr %ban, align 8
  %attached_aio_context = getelementptr inbounds %struct.BdrvAioNotifier, ptr %24, i32 0, i32 0
  %25 = load ptr, ptr %attached_aio_context, align 8
  %26 = load ptr, ptr %new_context.addr, align 8
  %27 = load ptr, ptr %ban, align 8
  %opaque = getelementptr inbounds %struct.BdrvAioNotifier, ptr %27, i32 0, i32 2
  %28 = load ptr, ptr %opaque, align 8
  call void %25(ptr noundef %26, ptr noundef %28)
  br label %if.end16

if.end16:                                         ; preds = %if.else15, %if.then14
  br label %for.inc

for.inc:                                          ; preds = %if.end16
  %29 = load ptr, ptr %ban_tmp, align 8
  store ptr %29, ptr %ban, align 8
  br label %for.cond, !llvm.loop !108

for.end:                                          ; preds = %land.end
  %30 = load ptr, ptr %bs.addr, align 8
  %walking_aio_notifiers17 = getelementptr inbounds %struct.BlockDriverState, ptr %30, i32 0, i32 10
  store i8 0, ptr %walking_aio_notifiers17, align 8
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal ptr @strong_options(ptr noundef %bs, ptr noundef %curopt) #0 {
entry:
  %retval = alloca ptr, align 8
  %bs.addr = alloca ptr, align 8
  %curopt.addr = alloca ptr, align 8
  store ptr %bs, ptr %bs.addr, align 8
  store ptr %curopt, ptr %curopt.addr, align 8
  %0 = load ptr, ptr %curopt.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store ptr @strong_options.global_options, ptr %retval, align 8
  br label %return

if.end:                                           ; preds = %entry
  %1 = load ptr, ptr %curopt.addr, align 8
  %incdec.ptr = getelementptr ptr, ptr %1, i32 1
  store ptr %incdec.ptr, ptr %curopt.addr, align 8
  %2 = load ptr, ptr %curopt.addr, align 8
  %cmp = icmp eq ptr %2, getelementptr inbounds ([3 x ptr], ptr @strong_options.global_options, i64 0, i64 2)
  br i1 %cmp, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %3 = load ptr, ptr %bs.addr, align 8
  %drv = getelementptr inbounds %struct.BlockDriverState, ptr %3, i32 0, i32 6
  %4 = load ptr, ptr %drv, align 8
  %tobool1 = icmp ne ptr %4, null
  br i1 %tobool1, label %if.then2, label %if.end4

if.then2:                                         ; preds = %land.lhs.true
  %5 = load ptr, ptr %bs.addr, align 8
  %drv3 = getelementptr inbounds %struct.BlockDriverState, ptr %5, i32 0, i32 6
  %6 = load ptr, ptr %drv3, align 8
  %strong_runtime_opts = getelementptr inbounds %struct.BlockDriver, ptr %6, i32 0, i32 12
  %7 = load ptr, ptr %strong_runtime_opts, align 8
  store ptr %7, ptr %curopt.addr, align 8
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %land.lhs.true, %if.end
  %8 = load ptr, ptr %curopt.addr, align 8
  %tobool5 = icmp ne ptr %8, null
  br i1 %tobool5, label %land.lhs.true6, label %cond.false

land.lhs.true6:                                   ; preds = %if.end4
  %9 = load ptr, ptr %curopt.addr, align 8
  %10 = load ptr, ptr %9, align 8
  %tobool7 = icmp ne ptr %10, null
  br i1 %tobool7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true6
  %11 = load ptr, ptr %curopt.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true6, %if.end4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi ptr [ %11, %cond.true ], [ null, %cond.false ]
  store ptr %cond, ptr %retval, align 8
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %12 = load ptr, ptr %retval, align 8
  ret ptr %12
}

declare ptr @qdict_entry_key(ptr noundef) #2

declare ptr @qdict_entry_value(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @rcu_read_lock() #0 {
entry:
  %p_rcu_reader = alloca ptr, align 8
  %ctr = alloca i32, align 4
  %tmp = alloca i64, align 8
  %atomic-temp = alloca i64, align 8
  %.atomictmp = alloca i64, align 8
  %call = call ptr @get_ptr_rcu_reader()
  store ptr %call, ptr %p_rcu_reader, align 8
  %0 = load ptr, ptr %p_rcu_reader, align 8
  %depth = getelementptr inbounds %struct.rcu_reader_data, ptr %0, i32 0, i32 2
  %1 = load i32, ptr %depth, align 4
  %inc = add i32 %1, 1
  store i32 %inc, ptr %depth, align 4
  %cmp = icmp ugt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %do.end, %if.end
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.292, i32 noundef 87, ptr noundef @__func__.rcu_read_lock, ptr noundef null) #18
  unreachable

do.end:                                           ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %2 = load atomic i64, ptr @rcu_gp_ctr monotonic, align 8
  store i64 %2, ptr %atomic-temp, align 8
  %3 = load i64, ptr %atomic-temp, align 8
  store i64 %3, ptr %tmp, align 8
  %4 = load i64, ptr %tmp, align 8
  %conv = trunc i64 %4 to i32
  store i32 %conv, ptr %ctr, align 4
  br label %do.body1

do.body1:                                         ; preds = %while.end
  br label %while.cond2

while.cond2:                                      ; preds = %do.end5, %do.body1
  br i1 false, label %while.body3, label %while.end6

while.body3:                                      ; preds = %while.cond2
  br label %do.body4

do.body4:                                         ; preds = %while.body3
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.292, i32 noundef 88, ptr noundef @__func__.rcu_read_lock, ptr noundef null) #18
  unreachable

do.end5:                                          ; No predecessors!
  br label %while.cond2

while.end6:                                       ; preds = %while.cond2
  %5 = load ptr, ptr %p_rcu_reader, align 8
  %ctr7 = getelementptr inbounds %struct.rcu_reader_data, ptr %5, i32 0, i32 0
  %6 = load i32, ptr %ctr, align 4
  %conv8 = zext i32 %6 to i64
  store i64 %conv8, ptr %.atomictmp, align 8
  %7 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %7, ptr %ctr7 monotonic, align 8
  br label %do.end9

do.end9:                                          ; preds = %while.end6
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #15, !srcloc !109
  fence seq_cst
  br label %return

return:                                           ; preds = %do.end9, %if.then
  ret void
}

declare ptr @get_ptr_rcu_reader() #2

; Function Attrs: nounwind sspstrong uwtable
define internal void @glib_autoptr_clear_RCUReadAuto(ptr noundef %_ptr) #0 {
entry:
  %_ptr.addr = alloca ptr, align 8
  store ptr %_ptr, ptr %_ptr.addr, align 8
  %0 = load ptr, ptr %_ptr.addr, align 8
  %tobool = icmp ne ptr %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load ptr, ptr %_ptr.addr, align 8
  call void @rcu_read_auto_unlock(ptr noundef %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @rcu_read_auto_unlock(ptr noundef %r) #0 {
entry:
  %r.addr = alloca ptr, align 8
  store ptr %r, ptr %r.addr, align 8
  call void @rcu_read_unlock()
  ret void
}

; Function Attrs: nounwind sspstrong uwtable
define internal void @rcu_read_unlock() #0 {
entry:
  %p_rcu_reader = alloca ptr, align 8
  %.atomictmp = alloca i64, align 8
  %tmp = alloca i8, align 1
  %atomic-temp = alloca i8, align 1
  %.atomictmp23 = alloca i8, align 1
  %call = call ptr @get_ptr_rcu_reader()
  store ptr %call, ptr %p_rcu_reader, align 8
  %0 = load ptr, ptr %p_rcu_reader, align 8
  %depth = getelementptr inbounds %struct.rcu_reader_data, ptr %0, i32 0, i32 2
  %1 = load i32, ptr %depth, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end

if.else:                                          ; preds = %entry
  call void @__assert_fail(ptr noundef @.str.293, ptr noundef @.str.292, i32 noundef 101, ptr noundef @__PRETTY_FUNCTION__.rcu_read_unlock) #16
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load ptr, ptr %p_rcu_reader, align 8
  %depth1 = getelementptr inbounds %struct.rcu_reader_data, ptr %2, i32 0, i32 2
  %3 = load i32, ptr %depth1, align 4
  %dec = add i32 %3, -1
  store i32 %dec, ptr %depth1, align 4
  %cmp2 = icmp ugt i32 %dec, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  br label %if.end25

if.end4:                                          ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.end4
  br label %while.cond

while.cond:                                       ; preds = %do.end, %do.body
  br i1 false, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body5

do.body5:                                         ; preds = %while.body
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.292, i32 noundef 111, ptr noundef @__func__.rcu_read_unlock, ptr noundef null) #18
  unreachable

do.end:                                           ; No predecessors!
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %4 = load ptr, ptr %p_rcu_reader, align 8
  %ctr = getelementptr inbounds %struct.rcu_reader_data, ptr %4, i32 0, i32 0
  store i64 0, ptr %.atomictmp, align 8
  %5 = load i64, ptr %.atomictmp, align 8
  store atomic i64 %5, ptr %ctr release, align 8
  br label %do.end6

do.end6:                                          ; preds = %while.end
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() #15, !srcloc !110
  fence seq_cst
  br label %while.cond7

while.cond7:                                      ; preds = %do.end10, %do.end6
  br i1 false, label %while.body8, label %while.end11

while.body8:                                      ; preds = %while.cond7
  br label %do.body9

do.body9:                                         ; preds = %while.body8
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.292, i32 noundef 115, ptr noundef @__func__.rcu_read_unlock, ptr noundef null) #18
  unreachable

do.end10:                                         ; No predecessors!
  br label %while.cond7

while.end11:                                      ; preds = %while.cond7
  %6 = load ptr, ptr %p_rcu_reader, align 8
  %waiting = getelementptr inbounds %struct.rcu_reader_data, ptr %6, i32 0, i32 1
  %7 = load atomic i8, ptr %waiting monotonic, align 8
  store i8 %7, ptr %atomic-temp, align 1
  %8 = load i8, ptr %atomic-temp, align 1
  %tobool = trunc i8 %8 to i1
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, ptr %tmp, align 1
  %9 = load i8, ptr %tmp, align 1
  %tobool12 = trunc i8 %9 to i1
  %lnot = xor i1 %tobool12, true
  %lnot13 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot13 to i32
  %conv = sext i32 %lnot.ext to i64
  %tobool14 = icmp ne i64 %conv, 0
  br i1 %tobool14, label %if.then15, label %if.end25

if.then15:                                        ; preds = %while.end11
  br label %do.body16

do.body16:                                        ; preds = %if.then15
  br label %while.cond17

while.cond17:                                     ; preds = %do.end20, %do.body16
  br i1 false, label %while.body18, label %while.end21

while.body18:                                     ; preds = %while.cond17
  br label %do.body19

do.body19:                                        ; preds = %while.body18
  call void @g_assertion_message_expr(ptr noundef null, ptr noundef @.str.292, i32 noundef 116, ptr noundef @__func__.rcu_read_unlock, ptr noundef null) #18
  unreachable

do.end20:                                         ; No predecessors!
  br label %while.cond17

while.end21:                                      ; preds = %while.cond17
  %10 = load ptr, ptr %p_rcu_reader, align 8
  %waiting22 = getelementptr inbounds %struct.rcu_reader_data, ptr %10, i32 0, i32 1
  store i8 0, ptr %.atomictmp23, align 1
  %11 = load i8, ptr %.atomictmp23, align 1
  store atomic i8 %11, ptr %waiting22 monotonic, align 8
  br label %do.end24

do.end24:                                         ; preds = %while.end21
  call void @qemu_event_set(ptr noundef @rcu_gp_event)
  br label %if.end25

if.end25:                                         ; preds = %do.end24, %while.end11, %if.then3
  ret void
}

declare void @qemu_event_set(ptr noundef) #2

; Function Attrs: nounwind sspstrong uwtable
define internal i32 @ranges_overlap(i64 noundef %first1, i64 noundef %len1, i64 noundef %first2, i64 noundef %len2) #0 {
entry:
  %first1.addr = alloca i64, align 8
  %len1.addr = alloca i64, align 8
  %first2.addr = alloca i64, align 8
  %len2.addr = alloca i64, align 8
  %last1 = alloca i64, align 8
  %last2 = alloca i64, align 8
  store i64 %first1, ptr %first1.addr, align 8
  store i64 %len1, ptr %len1.addr, align 8
  store i64 %first2, ptr %first2.addr, align 8
  store i64 %len2, ptr %len2.addr, align 8
  %0 = load i64, ptr %first1.addr, align 8
  %1 = load i64, ptr %len1.addr, align 8
  %call = call i64 @range_get_last(i64 noundef %0, i64 noundef %1)
  store i64 %call, ptr %last1, align 8
  %2 = load i64, ptr %first2.addr, align 8
  %3 = load i64, ptr %len2.addr, align 8
  %call1 = call i64 @range_get_last(i64 noundef %2, i64 noundef %3)
  store i64 %call1, ptr %last2, align 8
  %4 = load i64, ptr %last2, align 8
  %5 = load i64, ptr %first1.addr, align 8
  %cmp = icmp ult i64 %4, %5
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %6 = load i64, ptr %last1, align 8
  %7 = load i64, ptr %first2.addr, align 8
  %cmp2 = icmp ult i64 %6, %7
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %8 = phi i1 [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lnot = xor i1 %8, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: nounwind sspstrong uwtable
define internal i64 @range_get_last(i64 noundef %offset, i64 noundef %len) #0 {
entry:
  %offset.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  store i64 %offset, ptr %offset.addr, align 8
  store i64 %len, ptr %len.addr, align 8
  %0 = load i64, ptr %offset.addr, align 8
  %1 = load i64, ptr %len.addr, align 8
  %add = add i64 %0, %1
  %sub = sub i64 %add, 1
  ret i64 %sub
}

attributes #0 = { nounwind sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #1 = { nounwind willreturn memory(read) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #2 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #3 = { allocsize(0) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #6 = { noreturn nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #7 = { allocsize(0,1) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #8 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #9 = { nounwind willreturn memory(none) "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #10 = { noreturn "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cmov,+cx16,+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
attributes #11 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #12 = { nounwind willreturn memory(none) }
attributes #13 = { nounwind willreturn memory(read) }
attributes #14 = { allocsize(0) }
attributes #15 = { nounwind }
attributes #16 = { noreturn nounwind }
attributes #17 = { allocsize(0,1) }
attributes #18 = { noreturn }

!llvm.module.flags = !{!0, !1, !2, !3, !4}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 8, !"PIC Level", i32 2}
!2 = !{i32 7, !"PIE Level", i32 2}
!3 = !{i32 7, !"uwtable", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = distinct !{!5, !6}
!6 = !{!"llvm.loop.mustprogress"}
!7 = distinct !{!7, !6}
!8 = distinct !{!8, !6}
!9 = distinct !{!9, !6}
!10 = distinct !{!10, !6}
!11 = distinct !{!11, !6}
!12 = distinct !{!12, !6}
!13 = distinct !{!13, !6}
!14 = distinct !{!14, !6}
!15 = distinct !{!15, !6}
!16 = distinct !{!16, !6}
!17 = distinct !{!17, !6}
!18 = distinct !{!18, !6}
!19 = distinct !{!19, !6}
!20 = distinct !{!20, !6}
!21 = distinct !{!21, !6}
!22 = distinct !{!22, !6}
!23 = distinct !{!23, !6}
!24 = distinct !{!24, !6}
!25 = distinct !{!25, !6}
!26 = distinct !{!26, !6}
!27 = distinct !{!27, !6}
!28 = distinct !{!28, !6}
!29 = distinct !{!29, !6}
!30 = distinct !{!30, !6}
!31 = distinct !{!31, !6}
!32 = distinct !{!32, !6}
!33 = distinct !{!33, !6}
!34 = distinct !{!34, !6}
!35 = distinct !{!35, !6}
!36 = distinct !{!36, !6}
!37 = distinct !{!37, !6}
!38 = distinct !{!38, !6}
!39 = distinct !{!39, !6}
!40 = distinct !{!40, !6}
!41 = distinct !{!41, !6}
!42 = distinct !{!42, !6}
!43 = distinct !{!43, !6}
!44 = distinct !{!44, !6}
!45 = distinct !{!45, !6}
!46 = distinct !{!46, !6}
!47 = distinct !{!47, !6}
!48 = distinct !{!48, !6}
!49 = distinct !{!49, !6}
!50 = distinct !{!50, !6}
!51 = distinct !{!51, !6}
!52 = distinct !{!52, !6}
!53 = distinct !{!53, !6}
!54 = distinct !{!54, !6}
!55 = distinct !{!55, !6}
!56 = distinct !{!56, !6}
!57 = distinct !{!57, !6}
!58 = distinct !{!58, !6}
!59 = distinct !{!59, !6}
!60 = distinct !{!60, !6}
!61 = distinct !{!61, !6}
!62 = distinct !{!62, !6}
!63 = distinct !{!63, !6}
!64 = distinct !{!64, !6}
!65 = distinct !{!65, !6}
!66 = distinct !{!66, !6}
!67 = distinct !{!67, !6}
!68 = distinct !{!68, !6}
!69 = distinct !{!69, !6}
!70 = distinct !{!70, !6}
!71 = distinct !{!71, !6}
!72 = distinct !{!72, !6}
!73 = distinct !{!73, !6}
!74 = distinct !{!74, !6}
!75 = distinct !{!75, !6}
!76 = distinct !{!76, !6}
!77 = distinct !{!77, !6}
!78 = distinct !{!78, !6}
!79 = distinct !{!79, !6}
!80 = distinct !{!80, !6}
!81 = distinct !{!81, !6}
!82 = distinct !{!82, !6}
!83 = distinct !{!83, !6}
!84 = distinct !{!84, !6}
!85 = distinct !{!85, !6}
!86 = distinct !{!86, !6}
!87 = distinct !{!87, !6}
!88 = distinct !{!88, !6}
!89 = distinct !{!89, !6}
!90 = distinct !{!90, !6}
!91 = !{i64 2152840648}
!92 = !{i64 2152850341}
!93 = distinct !{!93, !6}
!94 = distinct !{!94, !6}
!95 = distinct !{!95, !6}
!96 = distinct !{!96, !6}
!97 = distinct !{!97, !6}
!98 = distinct !{!98, !6}
!99 = distinct !{!99, !6}
!100 = distinct !{!100, !6}
!101 = distinct !{!101, !6}
!102 = distinct !{!102, !6}
!103 = distinct !{!103, !6}
!104 = distinct !{!104, !6}
!105 = distinct !{!105, !6}
!106 = distinct !{!106, !6}
!107 = distinct !{!107, !6}
!108 = distinct !{!108, !6}
!109 = !{i64 2151794335}
!110 = !{i64 2151799496}
